* INITIALIZATION AND STATE-SAVING

* LOCATION COUNTER IS 0

START: GOTO SAVEST IF BRKON, SSMREG_M, M_MAR, CLFAIL;
* NO BREAK. READ SCR
}'Z_SCRADR, ALERT, GOTO *+1 IF AT2OFF;
}'M_READ, GOTO *+1 IF AT1OFF;
}'UNPROTECT, Q_SELFILLBIT;
}'Z_M AND Q, GOTO XSELFFILL IF LB#0, Q_COMPUTEBIT, CLSTROBE;
}'M AND Q, GOTO IRESET IF LB#0, Q_CONTINUEBIT;
* WE ARE NOT DOING ITP INITIALIZATION.}"TURN COMPUTE MODE OFF
* AND SCHEDULE MODE ON. CLEAR STROBE
}'MODE_ONSCHEDULE, CLSTROBE;
}'M AND Q, GOTO WAITGO IF LB=0, MAR_SCRMEM, FETCH;
* CONTINUE SET IN SCR. LOOK AT SCRMEM. IF CONTINUE SET THERE,
* ACCEPT IT AS PROPER SWITCH INFO
}'M AND Q, GOTO GOTSCR IF LB#0;
* MUST WAIT FOR GO, THEN READ SWITCHES INTO SCRMEM
WAITGO: Z_SCRADR, ALERT;
}'GOTO WAITGO ON M_E2>=0, PIN, .VCY, .TAX;

}'MAR_SCRMEM, STORE;
* M AND SCRMEM NOW BOTH CONTAIN THE VALUE OF SCR TO BE USED FOR RESTART
* SEND STROBES TO CHIO AND AMC
* IF THE UTP'S PART IN SYSTEM INITIALIZATION IS ELABORATED, THE
* NEW STUFF GOES HERE
GOTSCR: SK0_CHIOSTROBE+SWAPSTROBE, STROBE;
* WAIT FOR STROBE SIGNAL, THEN LOAD STATE AS IF RETURNING FROM BREAK
}'GOTO * IF NOSTROBE;
}'Z_0, R2_-LSCRATCH, GOTO LOADST, STORE;

* BREAK. DUMP STATE IN THE SAVE AREA.}"THE STRATEGY IS AS FOLLOWS
* 1) SAVE M IN SSMREG IN THE SCRATCHPAD
* 2) STORE MAR AT SAVER0. STORE OS AT SAVEOS
* 3) STORE Z,Q AT SAVEZ,Q AND R1-R6 AT SAVER1 TO SAVER6
* 4) EXCHANGE SCRATCHPAD AND SAVE TO SAVE+LSCRATCH-1

* AFTER SAVING THE STATE, BREAK WAITS UNTILL BRKWAIT
* BECOMES NON-ZERO.

* THE RELOAD STRATEGY IS OBTAINED BY DOING STEPS 4-3 IN REVERSE,
* AND THEN
* 2) FETCH SAVEOS AND DGOTO IT
* 1) DGOTO *+1 (THIS SETS UP OS), FETCH BREAK
* 0) DGOTO M (THIS SETS UP O), FETCH SAVER0
* -1) MAR_M, M_SSMREG

}'MACRO IMS_MAR_Z_Z+1, STORE;
SAVEST: MAR_SAVER0, STORE;
}'M_Z, MAR_SAVEZ, STORE;
}'M_R1, MAR_Z_SAVER1, STORE;
}'M_R2, IMS;
}'M_R3, IMS;
}'M_R4, IMS;
}'M_R5, IMS;
}'M_R6, IMS;
}'M_OS, IMS;
}'M_Q, MAR_Z_MAR+1, STORE;
}'MAR_SAVE-1;
}'R2_-LSCRATCH, Z_0, CALL XSCRATCH;
BWAIT: MAR_BRKWAIT, FETCH;
}'GOTO *-1 ON M=0, R2_-LSCRATCH;
LOADST: MAR_SAVE-1, Z_0, CALL XSCRATCH;
}'MAR_SAVER1, FETCH;
}'R1_M, CALL FN;
}'R2_M, CALL FN;
}'R3_M, CALL FN;
}'R4_M, CALL FN;
}'R5_M, CALL FN;
}'R6_M, CALL FN;
}'DGOTO M, MAR_MAR+1, FETCH;
}'Q_M, MAR_MAR+1, FETCH, CALL *+1;
}'Z_M, MAR_BREAK, FETCH;
}'DGOTO M, MAR_SAVER0, FETCH, .VCY;
}'MAR_M, M_SSMREG;

* SUBROUTINE TO BUMP MAR AND FETCH
FN:}$MAR_MAR+1, FETCH, RETURN;

* SUBROUTINE TO EXCHANGE -(R2) SCRATCHPAD LOCATIONS, STARTING AT (Z),
* WITH CORE LOCATIONS STARTING AT (MAR)+1. CLOBBERS M,Z,R1,R2
XSCRATCH: FETCH, MAR_MAR+1;
}'R1_SKZ;
}'SKZ_M, M_R1, DGOTO XSCRATCH;
}'STORE, Z_Z+1, RETURN ON R2_R2+1>=0;



* ROUTINES TO LOAD AND STORE. THESE ALLOW A CONSTANT FIELD
* TO BE USED IN AN INSTRUCTION WHICH WANTS TO LOAD OR STORE, AT
* THE EXPENSE OF 300 NS, IF THE INSTRUCTION DOES NOT ALSO HAVE
* HAVE A BRANCH ADDRESS
* CALL WITH CALL, DO NOT USE STACK. LEAVE REGISTERS UNTOUCHED

MFETCH: FETCH, RETURN;
MSTORE: STORE, RETURN;
*
* SUBROUTINE CALLING CONVENTIONS
* STKP CONTAINS THE STACK POINTER.}"THE ROUTINE STKLK PUSHES
* OS ONTO THE STACK AND SENDS CONTROL TO (SUBR). THUS A SUBROUTINE
* S CAN BE CALLED IN TWO WAYS
*}&SUBR_S, CALL STKLK
* WHICH USES ABOUT HALF OF THE CALLING INSTRUCTION, OR ALTERNATIVELY
*}&CALL S
* WHERE
* S:}#SUBR_S+1, GOTO STKLK
* WHICH COSES A WORD IN THE SUBROUTINE AND TWO EXTRA CYCLES.}"THE
* TWO SCHEMES ARE INCOMPATIBLE IN THE SENSE THAT A ROUTINE
* WHICH CAN BE CALLED BY METHOD 2 MUST BE ENTERED ONE LOCATION EARLIER
* BY METHOD 1
* THE CALL WIPES SUBR AND SCRATCHPAD LOCATION CALLT1 (WHICH ARE
* THEREFORE NEVER GIVEN ALTERNATE NAMES) BUT PRESERVES MQZ

}'MACRO ENTRY_SUBR_*+1, GOTO STKLK;
}'MACRO QENTRY_Q_*+1, GOTO QSTKLK;
}'MACRO C_SUBR_*1*, CALL STKLK;
* GOING TO RET POPS THE STACK AND RETURNS, CLOBBERING ONLY SUBR.
* GOING TO RETXZ AFTER Z_STKP+1 IS THE SAME BUT ALSO CLOBBERS Z.
* IT IS ONE CYCLE SHORTER
}'MACRO R_GOTO RET;
}'MACRO DR_DGOTO RET;
}'MACRO RXZ_Z_STKP+1, GOTO RETXZ;

QSTKLK: SUBR_Q;
STKLK: Z_STKP, CALLT1_Z;
STKL1: STKP_Q, Q_OS;
}'SKZ_Q, Q_SUBR;
}'DGOTO Q, Q_STKP;
}'STKP_Z-1, Z_CALLT1;

RET:}#SUBR_Z, Z_STKP+1;
RETXZ: Z_SKZ, STKP_Z;
}'GOTO Z, Z_SUBR;

*
* QUEUE CONVENTIONS
* MOST QUEUES HAVE TWO-WORD HEADERS, THE FIRST WORD POINTING
* TO THE FIRST ENTRY ON THE QUEUE AND THE SECOND TO THE LAST. A QUEUE
* POINTER IS 18 BITS AND IS ALWAYS RIGHT-JUSITFIED IN A MEMORY WORD.
* THE TOP 6 BITS OF SUCH A WORD ARE PRESERVED.}"THESE BITS ARE ALWAYS
* 0 FOR A QUEUE POINTER IN A HEADER OR IN THE UPROCESSOR.
* 777777 IS USED FOR THE NULL POINTER.}"A POINTER IS ALWAYS TO
* THE FIRST WORD OF THE ITEM BEING REFERENCED.}"THE NEXT POINTER
* IS USUALLY NOT IN THAT WORD, BUT OFFSET BY AN AMOUNT WHICH 
* QUEUE-HANDLING ROUTINES EXPECT TO FIND IN OFFSET.
* THE QUEUES WHICH HAVE THE ABOVE FORM ARE: USQ'S, WAKEUPQ,
*}&SWFREL, SWAPIQ, SWAPRQ
* ONES WHICH DO NOT ARE: RTQ

* GET NEXT ENTRY FROM QUEUE ADDRESSED BY M.}"LEAVE ITS ADDRESS
* IN Z AND REMOVE IT FROM THE QUEUE.}"LEAVE A NULL POINTER IN Z IF
* THE QUEUE IS EMPTY.
* CALL WITH CALL, USES STACK, WIPES MQZ, MAR, SPT1
GETNEXT: SPT1_MAR_M, QENTRY, FETCH;
}'Q_ADMREG;
}'Z_M AND Q, R IF NULLPTR, Q_OFFSET;
}'MAR_M+Q, FETCH, Q_ADMREG;
}'M_M AND Q, R IF NNPTR, Q_MAR_SPT1, STORE;
* QUEUE HAS BECOME NULL. FIX UP SECOND WORD OF HEADER.
}'M_OFFSET, DR;
}'M_Q-M, MAR_MAR+1, STORE;

* PUT NODE IN Z ON END OF QUEUE IN MAR
* CALL WITH CALL, USES STACK, WIPES MQ, MAR, SPT1,2
* LEAVES Z UNTOUCHED THROUGHOUT.
* LEAVES OLD FIRST WORD OF QUEUE HEADER IN SPT2, Q
APPEND: QENTRY, FETCH;}#*FETCH 1ST WORD OF HEADER
}'SPT2_M, MAR_MAR+1, FETCH;
* FETCH 2ND WORD OF HEADER
}'Q_OFFSET, SPT1_Z;
}'Q_Q+M, M_SPT1, STORE;
*}"STORE PTR TO MODE INTO 2ND WORD OF HEADER
}'MAR_Q, FETCH, Q_ADMREG;
*}#FETCH PTR WORD FROM LOD LAST NODE
}'M_M AND NOT Q ! Z AND Q, STORE, Q_OFFSET;
*}"STORE INTO PTR WORD OF OLD LAST NODE--1ST 6
*}"BITS ARE WHAT WE JUST FETCHED, BITS 6-23 ARE ADDRESS OF
*}"NEW LAST NODE
}'MAR_Q+Z, FETCH, Q_ADMREG, DR;
*}"FETCH PRT WORD FROM NEW LAST NODE
}'M_M OR Q, STORE, Q_SPT2;
*}"STORE INTO PTR WORD OF NEW LAST NODE WHAT WE JUST FETCHED
*}"WITH ADMREG (777777) MERGED IN.
*
* ROUTINES TO FETCH PARTICULAR WORDS FROM A PROCESS WITH PRT ADDRESS
* IN M.}"THE WORD IS LEFT IN M, ITS ADDRESS IN MAR AND SUBR
* CALL WITH CALL, DOES NOT USE STACK, WIPES M, MAR, SUBR

GETPIW: SUBR_Q, Q_PRPIW;

* GET M+Q
GETMPQ: MAR_SUBR_M+Q, FETCH, Q_SUBR, RETURN;

GETST: SUBR_Q, Q_PRST, GOTO GETMPQ;

* THIS ONE ZEROS THE TOP 6 BITS OF M FIRST
GETRTP: SUBR_Q, Q_ADMASK, DGOTO GETMPQ;
}'M_M AND NOT Q, Q_PRRTP;
*
* MAIN LOOP
MAIN:}"STKP_TOPSTACK, GOTO NOUSWORK IF NOSTROBE, M_MODE, CLSTROBE;
}'GOTO NOUSWORK ON M LCY 2>=0;
GOMAIN: TEMP2_OLDRT;
* FETCH CLOCK AND CHECK FOR CHANGE
* TEMP2 CONTAINS THE INITIAL VALUE OF OLDRT THROUGHOUT
* EXCEPT DURING THE CALL OF WAKEUP, WHEN IT IS SAVED IN OLDOLDRT
RTLOOP: UNPROTECT, MAR_RTC, CALL MFETCH;
*$$$$$$$ PATCH 1
}'Q_M, MAR_MAR+1, FETCH, CALL FIX1;
}'M_M LCY 12, Q_17770000B;
}'M_M AND NOT Q ! Z AND Q, Q_10000000B;
}'M_OLDRT_M AND NOT Q LCY 2, Q_TEMP2;
}'M EOR Q, GOTO USIBLP IF LB=0;
* HAVE NEW CLOCK VALUE.
* SAVE SSR AND LOAD SSL
}'Z_SSRADR, ALERT;
}'M_READ, MAR_SSRMEM, CALL MSTORE;
}'Z_SWR5ADR, ALERT;
}'M_READ, MAR_SWR5MEM, CALL MSTORE;
}'MAR_SSLMEM, CALL MFETCH;
}'Z_SSLADR, ALERT;
}'Z_M, POT, M_OLDRT;
* CHECK CLOCK AGAINST TOP OF RTQ
}'Z_TRTQT, CALL TIMINT, OFFSET_PRRTP;
* TRY TO REMOVE TOP PROCESS FROM RTQ AND WAKE IT UP
}'GOTO USIBLP IF R0>=0;
}'M_RTQ, CALL GETNEXT;
}'CPROC_Z, GOTO USIBLP IF NULLPTR, Q_TEMP2;
}(OLDOLDRT_Q,}"GOTO FIX3, M_OFFSET;
FIX3A: TEMP2_RTBIT, M_CPROC, CALL STKLK;
}'GOTO RTLOOP IF NOCRASH, TEMP2_OLDOLDRT;
*
* FALL THROUGH
* NO FURTHER ACTION IN RTQ REQUIRED. CHECK USIB
* CONTROL RETURNS HERE FROM ALL ACTIONS TRIGGERED BY USIB ENTRIES.
USIBLP: UNPROTECT, GOTO *+2 IF NOCRASH;
}'CALL UERROR;
}'PROTECT(USIBPRO);
}'MAR_USIBTOP, FETCH;
}'Q_SPT1_M, MAR_USIBASE, FETCH;
}'M EOR Q, GOTO IBEMPTY IF LB=0, Z_LUSIBE;
}'MAR_SPT1, FETCH, Z_Q-Z;
}'SPT1_Q_M, MAR_MAR+1, FETCH;
}'TEMP2_M;
}'M_Z, MAR_USIBTOP, STORE;
* HAVE FETCHED REQUEST FROM USIB. FIRST WORD IN Q AND SPT1. SECOND
* IN TEMP2. DISPATCH ON OPCODE
}(M_Q LCY 4, Q_60000017B;
}'M_M AND Q LCY 2, Q_MAXUOP, CALL UERROR IF LB=0;
}'UNPROTECT, CPROC_SPT1;
}'CALL UERROR ON Q-M<0, Q_OPTAB-1;
}'SUBR_M+Q, Q_TEMP2, DGOTO USIBLP;
}'MAR_Z_M_CPROC, CALL STKLK, .C_3, .TCX, .TXW;
*}"NOTE THAT MAR IS LOADED WITH CPROC + 3
* DISPATCH WITH FIRST WORD IN M, Z AND TEMP1, SECOND IN Q AND TEMP2.
* USIBLP ON STACK
OPTAB: GOTO WAKEUP;}4* WAKEUP
}'GOTO IWAKEUP;}3* IWAKEUP
RETCALL: GOTO FREECPU, TEMP4_WKUP1;}&* RETURN
}'GOTO CHKPIW, TEMP4_BLOCK1, FETCH;}%* BLOCK
}'GOTO CHKPIW, TEMP4_BLKOUT1, FETCH;}$* BLOCKOUT
}'GOTO FREECPU, TEMP4_UNLOAD1;}$* UNLOAD
}'GOTO GIVEUP;}4* GIVEUP
}'GOTO CHRT;}6* CHANGERT
}'GOTO SETMODE;
}'GOTO SAVEST;
}'.DGO;
}'CALL UERROR;


* EITHER STROBE NOT SET OR US OFF.}"GIVE CONTROL TO ITP IF IT
* NEEDS IT.}"MODE IN M
NOUSWORK: GOTO ICONT ON M<0;
}'GOTO IOWAIT ON M LCY 1<0;
* ITP IS OFF. LOOP
}'GOTO MAIN;
*
* CHRT IS IN THE ITP PACKAGE, SO THAT THIS ONE WILL FIT ON 4 BOARDS

* SUBROUTINE TO DETERMINE WHETHER A TIME T (IN Z) FALLS IN THE
* INTERVAL BETWEEN T1 (IN Q) AND T2 (IN M). IT DOES IF
*}&T1<=T<=T2}"OR}"T>=T1>T2}"OR}"T1>T2>=T
* WIPES MQZ, SUBR. RETURN <0 IN R0
* IF TRUE, >=0 IF FALSE. PUT SPT4 IN M ON EXIT
* ANALYSIS REVEALS THAT SIGN(T-T1) EOR SIGN(T-T2) EOR SIGN(T2-T1)
* IS THE RIGHT THING TO PUT IN THE SIGN OF R0
* CALL WITH CALL, DOES NOT USE STACK, WIPES MQZ, MAR
TIMINT: R0_M-Q;
}'R0_Z-Q, Q_R0;
}'M_Z-M, Z_R0;
}'Q_M EOR Q, DRETURN IF NOCRASH;
}'SUBR_R0_Q EOR Z, M_SPT4;
}'GOTO UERROR;


* SUBROUTINE TO RE-ESTABLISH TRTQT
* CALL WITH CALL, DOES NOT USE STACK, WIPES MQ, MAR
FIXRTQ: MAR_RTQ, FETCH;
}'M, RETURN IF NULLPTR, Q_PRRT;
}'MAR_M+Q, FETCH, DRETURN;
}'TRTQT_M;
*
* WAKEUP PROCESS IN M.}"SECOND WORD (IN TEMP2) IS TO BE MERGED
* INTO PIW.
* CALL WITH C. USES MQZ, CPROC, NEWPIW, OFFSET, TEMP2, SUBR
* MUST UNPROTECT UPON RETURN
WAKEUP: Z_M, CALL CHKPID;
}'PROTECT(PRTPRO);
}'CALL GETPIW, Q_TEMP2;
}'M_M OR Q, Q_BLKBIT, CALL MSTORE;
}'M_CPROC, CALL GETST;
* NOW HAVE M=ST, MAR=ADDR(ST), Q=BITS TO CLEAR IN IT
WKUP2: M_M AND NOT Q, Q_LDDBIT, CALL MSTORE;
*}"CLEAR BLOCK
}'M AND Q, GOTO NOTLDD IF LB=0, Q_USQBIT+RUNBIT;
*}#CHECK LOAD
}'M AND Q, R IF LB#0, Q_USQBIT;
*}"PROCESS IS LOADED, CHECK FOR MSQ OR RUN.}"IF ON MSQ OR RUNNING
* WE ARE DONE.
}'M_M OR Q, Q_PRIMASK, CALL MSTORE;
*}"ELSE SET MSQ
}'Q_M AND Q LCY 12, M_USQBASE;
*}"GET PRIORITY
}'MAR_M+Q, Z_CPROC;
*}"SET UP POINTER TO QUEUE, Z POINTS TO PROCESS TO BE ADDED
}'OFFSET_PRPTR, CALL APPEND;
*}"BRANCH TO ROUTINE TO ADD NODE ON DESIRED PRIORITY QUEUE
}'Q, R IF NNPTR;
}'SCHFLG_4B7, R;
NOTLDD: Q_WAQBIT+SCQBIT+PQBIT+SWQBIT+CBCBIT;
}'M AND Q, R IF LB#0;
* IF SYSTEM IS IDLE, WE WANT TO GET SWAPIN CALLED DIRECTLY.
* OTHERWISE JUST GOTO PUTWQ. ITS RETURN WILL RETURN FROM WAKEUP
}'Q_PUTWQ, CALL CHKIDLE;
* IT IS. FALL THROUGH TO SWAPIN
}'M_CPROC, TEMP2_SWAPIQ, CALL GETST;
*$$$$$$$ PATCH 2
}'M_M MRG SWQBIT, STORE, GOTO FIX2;

* COMMON CODE FOR SWAPPER REQUESTS: READ PROCESS AND WRITE PROCESS ONLY
* CPROC=PRT FOR PROCESS, TEMP2=QUEUE TO PUT REQUEST ON
* OBTAIN ENTRY FROM SWAPPER FREE LIST.
SWREQUEST: UNPROTECT, OFFSET_0;
}'PROTECT(SWAPRO), Q_CPROC;
}'TEMP3_Q-1, M_SWFREL, CALL GETNEXT;
}'SPT1_Z, GOTO SWQEMPTY IF NULLPTR, OFFSET_SWNPTR;
}'SUBR_Z-1, Z_2;
* SET UP REAL NAME
SWRQ1: MAR_TEMP3_TEMP3+1, FETCH, Z_Z-1;
}'Q_MAR_SUBR_SUBR+1, STORE, GOTO *-1 IF Z>=0;
}'M_CPROC, MAR_Q+1, CALL MSTORE;
}'M_SWAPOP, Q_MAR_MAR+1, CALL MSTORE;
}'Z_SPT1, MAR_Q+1, STORE;
* SPLICE ENTRY ONTO PROPER QUEUE
}'MAR_TEMP2, CALL APPEND;
}'SK0_SWAPSTROBE, STROBE, R;
SWQEMPTY: UNPROTECT, GOTO SWREQUEST;


* ALTERNATE ENTRY TO WAKEUP FROM FREECPU: PRST ADDRESS IN MAR,
* PRST IN M, PRTPRO SET
* NOTHING IS DONE TO PIW
WKUP1: Q_BLKBIT, GOTO WKUP2;


* SAME AS WAKEUP EXCEPT THAT FIRST PARAMETER (IN M) HAS TO BE MULTIPLIED
* BY 12 AND HAVE MINPRT ADDED
IWAKEUP: Z_M LCY 1;
}'M_M+Z;
}'M_M LCY 2, Z_MINPRT, DGOTO WAKEUP;
}'M_Z_CPROC_M+Z;

*
* COMMON CODE FOR RETURN, BLOCK, BLOCKOUT, UNLOAD. 
* DECREMENTS AL. SETS SCHFLG IF AL=I. FETCHES ST WORD,
* CLEARS RUNBIT AND STORES IT.
* ENTER WITH LOCATION TO GOTO NEXT IN TEMP4, OTHER REGISTERS SET UP
* BY USIBLP AS USUAL
FREECPU: PROTECT(PRTPRO);
})CALL CHKPID;
}'Z_TEMP2 MRG AL, CALL GETST;
}'CALL UERROR ON Q_SKZ<0;
}'Q_Q LCY 4;
}'GOTO CPUNOTIDLE ON SKZ_Q>=0, Q_RUNBIT+CPUBIT;
}'SCHFLG_4B7+PRI, Z_TEMP2, .TCY;
}'SKZ_10B;
CPUNOTIDLE: M_M AND NOT Q, Q_TEMP4;
}'GOTO Q, STORE;
* LEAVE WITH PRST IN M, ADDR(PRST) IN MAR, PROCESS IN CPROC
* PRTPRO SET

BLOCK1: M_M MRG BLKBIT, STORE, R;

BLKOUT1: M_M MRG BLKBIT, STORE, GOTO SWAPOUT;

UNLOAD1: C(PUTWQ);
* FALL THROUGH INTO SWAPOUT

* SWAPOUT PROCESS IN CPROC AND RETURN TO USIBLP. CLEAR LDD (ST IN TEMP4)
* PRTPRO SET ON ENTRY
SWAPOUT: M_CPROC, CALL GETST, Q_LDDBIT;
}'M_M AND NOT Q, TEMP2_SWAPRQ, STORE, GOTO SWREQUEST;

* GIVEUP IS NOT IMPLEMENTED AT THE MOMENT
GIVEUP: R;

* SET MODE FROM DATA WORD OF REQUEST
SETMODE: R ON MODE_Q>=0;
* TURNING COMPUTE MODE ON. RESET ITP
}'GOTO IRESET;
*
* PUT PROCESS CPROC ON THE END OF WAKEUPQ. SET WAQ
* IN ST.
* CALLED WITH C, USES MQZ, MAR, SPT1,2, OFFSET
* CALLED FROM WAKEUP, UNLOAD
PUTWQ: Z_M_CPROC, CALL GETST, OFFSET_PRPTR;
}'M_M MRG WAQBIT, STORE, DR;
}'MAR_WAKEUPQ, CALL APPEND;


* SUBROUTINE TO CHECK FOR IDLE SYSTEM.
* GOTO Q IF SYSTEM NOT IDLE, RETURN IF IT IS
* CALL WITH CALL[TsOES NOT USE STACK
* CALLED FROM WAKEUP, NOSWITCH
CHKIDLE: Z_AL0, MAR_RIPQ, FETCH;
}'Z_AL1, DGOTO CHKOUT IF Z>=0, MAR_USQBASE-1;
}'Z_NPRI, GOTO CHKOUT IF Z>=0;
}'MAR_MAR+1, FETCH, M, GOTO CHKOUT IF NNPTR;
}'GOTO *-1 ON Z_Z-1>=0, MAR_MAR+1;
}'RETURN;
CHKOUT: GOTO Q;


* SUBROUTINE TO CHECK A PROCESS ID (PRT ADDRESS) IN Z
* FOR VALIDITY. IT LEAVES THE ADDRESS, WITH THE TOP 6 BITS CLEAR,
* IN}"M , Z AND CPROC.}"THE CHECK IS FOR THE ADDRESS TO BE IN THE
* RANGE FOR PRT AND THE LAST TWO BITS TO BE ZERO.CALL UERROR IF
* CHECK FAILS. WIPES R0, MQZ
* ALSO CHECKS FOR ACTIVE PROCESS, AND GOES TO GOMAIN IF THE PROCESS
* IS NOT ACTIVE, AFTER RESETTING THE STACK
* CALL WITH CALL, DOES NOT USE STACK
CHKPID: Q_ADMASK, M_MINPRT;
}'CPROC_Z_Z AND NOT Q, Q_3;
}'R0_Z-M, M_MAXPRT;
}'M_M-Z, M_R0;
* SIGN OF M IS 1 IF ADDRESS IS OUT OF RANGE
}'M_M AND NOT Q LCY 1, M_CPROC;
}'M AND Q, CALL UERROR IF LB#0, Q_2;
}'MAR_Z+Q, FETCH, DRETURN;
}'GOTO *+1 ON M>=0, M_CPROC;
}'STKP_TOPSTACK, GOTO GOMAIN;


*

* IB EMPTY. SCHEDULE CPU AS SPECIFIED BY USI/W-14 PP 5-6
IBEMPTY: UNPROTECT;
}'TEMP1_Z_WNPFLG MRG AL;
}'M_SKZ, .RRN_1, .THY, Q_ALIDLE+ALRUNNING;
}'M AND Q, GOTO MAIN IF LB=0, Z_SCHFLG;
* WAIT IS OVER. CLEAR WNPFLG (I.E. MAKE IT NEGATIVE) AND CHECK SCHFLG
}'WNPFLG_Q, MAR_USQBASE-1, GOTO MAIN IF Z>=0;
* SCHFLG IS SET. CONSIDER RESCHEDULING. SEARCH FOR HIGHEST NON-EMPTY USQI
}'Z_NPRI-1, Q_PRI0;
}'TEMP1_MAR_MAR+1, FETCH, Z_Z-1, GOTO NOSWITCH IF Z<0;
}'MAR_MAR+1, M, GOTO *-1 IF NULLPTR;
}'TEMP3_M;
* FOUND NON-EMPTY USQ, ADDRESS IN TEMP1, ADDRESS OF FIRST ENTRY IN TEMP3,
* NPRI-2-PRIORITY IN Z. COMPARE WITH CPU PRIORITIES
* FIRST COMPUTE SMALLEST CPU PRIORITY
}'M_PRI1, TEMP4_0;
}'R0_Q-M, M_NPRI-2;
}'GOTO *+2 IF R0>=0, Z_TEMP2_M-Z;
}'Q_PRI1, TEMP4_1;
* NOW HAVE WEAKEST CPU IN TEMP4 (0 OR 1), ITS PRIORITY IN Q,
* THE PRIORITY OF THE STRONGEST NON-EMPTY USQ IN Z AND TEMP2
}'R0_Z-Q, Z_TEMP4 MRG AL;
}'GOTO NOSWITCH IF R0>=0, M_SKZ;
* WANT TO SWITCH WEAKEST CPU IF ITS AL#P
}'GOTO SETWNP ON M LCY 8<0, Q_TEMP4;
* GO AHEAD. INCREMENT AL AND STORE NEW PRI
}'M_M LCY 20, Q_TEMP2;
}'SKZ_M, Z_TEMP4 MRG PRI;
}'SKZ_Q, M_TEMP3;
* STORE PRT ADDRESS OF PROCESS FOR CPU AND SEND IT AN ATTENTION
}'MAR_TEMP4 MRG CPUPROC, CALL MSTORE;
}'Q_TEMP4+1, PROTECT(PRTPRO);
}'Q_Q LCY CPUSTSH;
* CLEAR USQBIT, SET RUNBIT AND CPU NUMBER IN ST OF PROCESS
}'Q, STROBE, Q_USQBIT, CALL GETST;
}'M_M AND NOT Q, M_TEMP4 MRG RUNBIT, STORE, DGOTO IBEMPTY;
* REMOVE PROCESS FROM ITS USQ
}'M_TEMP1, OFFSET_PRPTR, CALL GETNEXT;
* NOTE THAT IBEMPTY CLEARS PROTECT
SETWNP: WNPFLG_Q, GOTO MAIN;
NOSWITCH: TEMP2_SCHFLG_0, Q_MAIN, CALL CHKIDLE;
* IDLE. RUN PROCESS ON WAKEUPQ IF THERE IS ONE
}'OFFSET_PRPTR;
}'M_WAKEUPQ, CALL GETNEXT;
}'M_Z, GOTO MAIN IF NULLPTR;
}'CALL GETST, Q_WAQBIT, TEMP2_0;
}'M_M AND NOT Q, STORE, DGOTO IBEMPTY;
}'M_Z, C(WAKEUP);

*$$$$$$$ PATCHES 1 AND 2
FIX1:}"GOTO RTLOOP ON M EOR Q<0;
}'Z_Q LCY 12, RETURN;
FIX2:}"M_CPROC, CALL GETPIW;
}'M_M MRG RSIBIT, STORE, GOTO SWREQUEST;
FIX3:}"FETCH, R0_M+Z, Q_ADMREG, DGOTO FIX3A;
}'M_M AND NOT Q, STORE, SUBR_WAKEUP, CALL FIXRTQ;
}'CALL UERROR;

}'END;
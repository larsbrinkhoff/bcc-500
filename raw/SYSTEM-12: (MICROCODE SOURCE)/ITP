}?
* INTEGRAL TEST PROCESSOR


* HOLDING REGISTERS FOR ITP
})DE R1 AS T;
})DE R2 AS U;
})DE R3 AS R;
})DE R4 AS ABSP;

* PARAMETERS FOR ITP
})DP ADMASK_7774B4;
})DP OPMASK_177B5;
})DP MAXOP_43B;
}'DP POPBIT_1B7;
})DP IABIT_4B4;
})DP RCHMASK_7400B;
})DP SCMASK_77B;
})DP SHOPMSK_3400B;
})DP MAXSHOP_4;
})DP WDLNG_24;
})DP UPSMASK_1400B;
})DP IOPTR_10B;
})DP IOINT_40B;
})DP BRMINS_13B5+IABIT;
})DP IONOINC_4B7;
})DP OUTSHIFT_2;
})DP EOBSHIFT_1;
})DP INTSHIFT_3;
})DP LONGAD_77B6;

* ADDRESS OF FLAG WORD
}'DP FLAGADR_4B7;
* PARAMETERS FOR PAPER TAPE READER, USED BY SELF-FILL
}'DP PTRADR_4B7+1;
}'DP PTRERR_2B7;
}'DP PTRSICK_1B7;
}'DP HLTPTR_2;
}'DP GOPTR_1;


* LOCATION 400B

}'ORG 400B;

* INSTRUCTION TABLE.}"MUST BE ON 128 WORD BOUNDARY
HLT:}%GOTO RSTITP;
* OVERFLOW FROM EXU
EXU1:}$Z_READ, GOTO IL0;
BRU:}%Q_R, Z_-1, GOTO FIXP;
* OVERFLOW FROM BRX
BRX1:}$M AND Q, GOTO FIXP IF LB#0, Q_R;
ETR:}%FETCH, DGOTO ILOOP;
})AR_M AND Q;
MRG:}%FETCH, DGOTO ILOOP;
})AR_M OR Q;
EOR:}%FETCH, DGOTO ILOOP;
})AR_M EOR Q;
NOP:}%GOTO ILOOP;
* OVERFLOW FROM UNPROTECT
UPR2:}$MODE_Q OR Z, GOTO ILOOP;
EXU:}%FETCH, Z_FLAGADR, DGOTO MAIN;
})ALERT, GOTO EXU1 IF NOSTROBE;
STA:}$M_AR, GOTO STOR;
* OVERFLOW FROM SHIFT IN THESE THREE HOLES
ENDLSH:}"AR_M AND Q ! Z AND NOT Q, GOTO ILOOP;
STB:}%M_BR, GOTO STOR;
ENDRSH:}"BR_M AND Q ! Z AND NOT Q, GOTO ILOOP;
STX:}%M_XR, GOTO STOR;
GOTSHM:}"T_Q_Z, M_BR, GOTO DOSHIFT;
BRX:}%M_XR, Z_-1, DGOTO BRX1;
})M_XR_M+1, DGOTO ILOOP, Q_IABIT;
BRM:}%M_P, SETA, CALL STOR;
})Q_0, GOTO FIXP;
UPOT:}$ALERT, DGOTO ILOOP;
})Z_BR, POT;
UPIN:}#ALERT, DGOTO LDB1;
})M_READ, DGOTO ILOOP;
RCH:}%M_R, Q_RCHMASK, DGOTO RCH1;
})M_M AND Q LCY 16, T_Z_XR;
SKE:}%FETCH, DGOTO TEST;
})M_M EOR Q;
BRR:}%Q_ADMASK, FETCH, DGOTO FIXP;
})Q_M AND NOT Q, Z_0;
SKB:}%Q_BR, FETCH;
SKB1:}$M_M AND Q, GOTO TEST;
SKN:}%Q_4B7, FETCH;
SKN1:}$M_M AND Q ! Q, GOTO TEST;
SUB:}%FETCH, DGOTO ILOOP;
})AR_Q-M;
ADD:}%FETCH, DGOTO ILOOP;
})AR_Q+M;
SKR:}%Z_R, FETCH, DGOTO SKN1;
})M_M-1, Q_BOUND, SETA, CALL STOR1;
MIN:}%Q_1, FETCH;
MIN1:}$M_M+Q, GOTO STOR;
XMA:}%FETCH, DGOTO CBA;
})Q_M, M_AR, DGOTO STOR;
ADM:}%FETCH, GOTO MIN1;
* SKG WHERE SIGNS AGREE
SKG1:}"M_M-Q, Q_4B7, GOTO SKN1;
SHIFT:}#M_R, Q_SCMASK, DGOTO SHFT1;
})Z_M AND Q, Q_SHOPMSK;
SKM:}%Q_BR, FETCH;
})M_M AND Q - Z AND Q, GOTO TEST;
LDX:}%Q_0, FETCH, DGOTO ILOOP;
LDX1:}$XR_M AND NOT Q ! Z AND Q;
SKA:}%FETCH, GOTO SKB1;
* SKG WHERE SIGNS DISAGREE
SKG2:}"Q_4B7, GOTO SKN1;
* SKG IS SIGN OF M-AR IF SIGNS AGREE, SIGN OF AR IF NOT
SKG:}#FETCH, DGOTO SKG1;
}'GOTO SKG2 ON M EOR Q<0;
LDB:}%FETCH, DGOTO ILOOP;
LDB1:}$BR_M;
LDA:}%FETCH, DGOTO ILOOP;
LDA1:}$AR_M;
EAX:}%M_R, Q_ADMASK, DGOTO LDX1;
})Z_XR, DGOTO ILOOP;
UPS:}%Q_R, M_UPSMASK;
})GOTO M AND Q LCY 16 MRG UPSTAB, M_Z_MODE;
XJ:}&REL_Q, GOTO BRU;
})CALL UERROR;
LAS:}%Q_Z_R, DGOTO XCA1;
})Q_Q LCY 16;
* LOCATION 510B

* UPS TABLE. MUST BE ON 4-WORD BOUNDARY
UPSTAB:}"Q, STROBE, GOTO ILOOP;
UPR:}%Q, CLRPRO, Q_SAVESCHEDULE, GOTO UPR1;
PRO:}%Q, SETPRO, GOTO * IF PRONEX;
}'Q_SAVESCHEDULE+ONSCHEDULE;
PRO1:}$Z_MODE_Z AND NOT Q, Q_ONSCHEDULE;
})M AND Q, GOTO ILOOP IF LB=0;
})MODE_Z MRG SAVESCHEDULE, GOTO ILOOP;
UPR1:}"Q_M AND Q LCY 1, GOTO UPR2;

* LOCATION 520B
* RCH TABLE. MUST BE ON 16-WORD BOUNDARY.
*}"ENTERED WITH DGOTO ILOOP PENDING, ABX IN MQZ
RCHTAB:}"Q_Z_R MRG LSCRATCH-4, GOTO XCA1;
CCA:}%Z_R MRG LSCRATCH-4, Q_0, GOTO XCA1;
CLAB:}$AR_M_0, GOTO CAB;
CLA:}%AR_0;
CLB:}%BR_0;
CLX:}%XR_0;
CAB:}%BR_M, GOTO ILOOP;
* THIS LINE IS EXECUTED FROM SEVERAL PLACES
CBA:}%AR_Q, Q_LNGSX;
XAB:}%AR_Q, GOTO CAB;
CBX:}%XR_Q;
CXB:}%BR_Z;
XXB:}%XR_Q, GOTO CAB, M_T;
CXA:}%AR_Z, GOTO ILOOP;
CAX:}%XR_M;
XXA:}%XR_M, M_T, GOTO CXA;
CNA:}#AR_0-M;


* RESET SEQUENCE FOR COMPUTE MODE
RSTITP: Z_MODE, Q_ONSCHEDULE+SAVESCHEDULE;
IRESET:}"MODE_Z AND Q, .TCX, MAR_ONCOMPUTE+ITPREL, FETCH;
})Z_REL_M, MAR_ITPBND, FETCH;
})Q_BOUND_4000B;
})GOTO *+2 ON M-Q<0, Q_2;
})BOUND_M;
})MAR_Z+Q, M_P, STORE;
})IOCTL_0, DGOTO MAIN;
})P_3;



* CHECK R FOR < BOUND, THEN STORE M WITH MAR AND GOTO ILOOP
* UNLESS A IS SET, IN WHICH CASE RETURN
STOR:}$Q_BOUND;
STOR1:}#GOTO *+2 ON Z_R<0;
})GOTO RSTITP ON Q-Z<=0;
})STORE, RETURN IF ASET, Q_4B7;
* FALL THROUGH

ILOOP:}#MAR_ABSP_ABSP+1, FETCH, Z_FLAGADR;
})Q_P, ALERT, DGOTO MAIN;
})P_Q+1, Z_READ, GOTO IL0 IF NOSTROBE;
* CPU IN WAIT LOOP
IOWAIT:}"CALL CHECKIO;
})GOTO IOWAIT ON Q AND Z=0;
* CONTINUE EXECUTION, STARTING WITH INSTRUCTION ADDRESSED BY P
ICONT:}#M_P;
})Q_REL;
})MAR_ABSP_M+Q, FETCH, CALL CHECKIO;
IL0:}%Q_IOCTL;
})GOTO DOIO ON Z_Q AND Z#0, Q_OPMASK;
IL1:}%U_Q_M AND Q LCY 8;
})Q_R_Q LCY 2, Z_2*MAXOP+2;
})GOTO POPMB ON Q-Z>=0, Z_REL, CLRA;
IL2:}%CALL INDEX ON T_M LCY 1<0, Q_ADMASK;
})Q_R_M AND NOT Q, M_R;
* CHECK THAT COMPUTE MODE IS ON
})MAR_Q+Z, GOTO IOWAIT ON MODE>=0;
})DGOTO M MRG HLT, Q_T;
})GOTO *+1 ON Q LCY 8<0, Z_Q_AR;
* INDIRECTION
})Z_REL, R_M, FETCH, GOTO *+2;
})GOTO MAIN;
})GOTO IL2 ON M>=0, Q_LONGAD-2B6;}#*2B6 IS PRIVATE MEMORY
* ABSOLUTE INDIRECTION
})CALL INDEX ON M LCY 1<0;
})R_MAR_M AND NOT Q MRG 4B7, Z_R;
})GOTO Z MRG HLT, Z_Q_AR;
* SUBROUTINE FOR INDEXING
INDEX:}#Z_XR, DRETURN;
})M_M+Z, Z_REL;

* OPCODE IN Q GREATER THAN MAX DEFINED.}"TRAP UNLESS IT IS >77B,
* IN}"WHICH CASE IT IS POP.
POPMB:}#Z_POPBIT*2/1B5;
})GOTO RSTITP ON Q AND Z=0, R_EXPOP;

* EXECUTING POP WITH NUMBER RCY 1 IN U, EFFECTIVE ADDRESS IN R. STORE
* P IN 0, R IN 1 AND JUMP TO U
EXPOP:}#Z_MAR_REL;
})M_P MRG IABIT, HSTORE;
}'Z_-1, Q_U, DGOTO FIXP;
}'Q_Q LCY 1;

* SET P TO Q+Z, RECOMPUTE ABSP AND GO TO ILOOP
FIXP:}$Q_P_Q+Z;
})Z_REL, DGOTO ILOOP;
})ABSP_Q+Z;

* THESE LINES ARE USED}"BY SKIP INSTRUCTIONS
TEST:}$M, GOTO ILOOP IF LB#0;
SKIP:}$Q_P, Z_1, GOTO FIXP;
* REMAINDER OF RCH
RCH1:}$DGOTO M MRG RCHTAB, Q_BR;
})M_AR, DGOTO ILOOP;

* SUBROUTINE TO CHECK STROBE, GOTO MAIN IF SET, AND HAVE FLAGWORD IN Z,
* IOCTL IN Q
CHECKIO: Q_IOCTL, Z_FLAGADR, ALERT, DGOTO MAIN;
})Z_READ, RETURN IF NOSTROBE;



* AFTER SETTING A CONTROL REGISTER, GO THROUGH MAIN
* IN CASE MODE HAS CHANGED.}"THIS REQUIRES BUMPING P
XCA1:}$T_SKZ, Z_Q, DGOTO CBA;
})SKZ_M, Q_T, DGOTO *+1;
})Z_P, DGOTO MAIN;
})P_Z+1;


* REST OF SHIFT
SHFT1:}#M_R_M AND Q LCY 16, Q_MAXSHOP;
})GOTO RSTITP ON Q-M<0, Q_WDLNG;
LNGSHL:}"T_BR, GOTO SHORTSH ON Z-Q<0;
})Z_Z-Q, Q_AR, DGOTO CBA;
})T_BR_Q, Q_T, DGOTO *+1;
})GOTO Q+M, Q_WDLNG;
LNGSX:}#GOTO LNGSHL;
})BR_0, GOTO LNGSHL;
})AR_-1, GOTO LNGSHL ON T<0;
})AR_0;
})GOTO LNGSHL;
SHORTSH: Q_1;
}'M AND NOT Q, GOTO *+2 IF LB=0, M_WDLNG;
})Z_M-Z;
})GOTO GOTSHM ON MAR_Q-Z>=0, Q_0;
SHLOOP:}"MAR_MAR+1, Q_Q LCY 1 MRG 1, GOTO SHLOOP IF R0<0;
})M_BR, T_Q;
DOSHIFT: M_M LCL Z, U_AR;
})BR_M LCH Z, M_U;
}(M_M LCL Z, Q_SHMRGX;
})Z_M LCH Z, M_R;
})DGOTO M+Q, M_BR;
})Q_T;
SHMRGX:}"BR_M AND NOT Q ! Z AND Q, GOTO ENDLSH;
})BR_M AND NOT Q, GOTO ENDLSH;
})AR_Z OR NOT Q, GOTO ENDRSH ON U<0;
})AR_Z AND Q, GOTO ENDRSH;
})AR_Z AND Q ! M AND NOT Q, GOTO ENDRSH;
* ENDLSH, ENDRSH AND GOTSHM ARE FILLING EMPTY WORD IN THE
* INSTRUCTION TABLE

* THE AND OF THE FLAG WORD AND IOCTL (IN Z) IS #0. LOOK FOR ACTIVE
* DEVICE
DOIO:}$Q_Z, T_R0_0;
})Q_Q LCY 20, Z_T_T+1, DGOTO *;
})Q_R0_Q LCY 3, GOTO *+1 IF R0<0, M_IOPTR-2;
* GOT DEVICE NUMBER+2 IN T AND Z
})M_M+Z, Q_REL;
})MAR_Q+M, FETCH, Q_2B7;
})Q_Q LCL Z;
})Z_Q LCH Z MRG 4B7, Q_REL;
})U_M+Q;
})GOTO *+2 ON Q_R_M_M+1<0, SETA;
})STORE;
})GOTO ITPOUTPUT ON Q LCY OUTSHIFT<0;
* INPUT
})ALERT, MAR_U, DGOTO DONEIO, M_77B6;
})M_READ, R_Q AND NOT M, CALL STOR;
ITPOUTPUT: DGOTO NOEND ON M LCY EOBSHIFT>=0;
}'MAR_U, FETCH;
}(M EOR Q, GOTO NOEND IF LB#0;
* ENCOUNTERED END-OF-BUFFER
})Q_IOCTL, DGOTO DONEIO;
})IOCTL_Q AND NOT Z;
NOEND:}#ALERT;
})Z_M, POT;
* COMPLETED IO. CHECK FOR INTERRUPT
DONEIO: M_U, Q_OPMASK, DGOTO ICONT;
}'GOTO *+1 ON M LCY INTSHIFT<0, Z_0;
* SHOULD CAUSE IT
})M_T MRG BRMINS+IOINT, GOTO IL1;

* SELF-FILL. TURN ON READER AND READ 64 WORDS (256 6-BIT CHARACTERS)
* INTO THE FIRST 64 (RELATIVE) LOCATIONS IN ITP MEMORY, AFTER
* SETTING ITPREL TO 10000B AND ITPBND TO 40000B
XSELFFILL: U_7777B+2B6;
}'MAR_ITPREL, M_U+1, STORE;
}'MAR_MAR+1, M_40000B+2B6, STORE;
})Z_PTRADR, ALERT;
})Z_GOPTR, POT;
* SKIP OVER INITIAL BLANK TAPE
})Z_PTRADR, ALERT;
})GOTO *-1 ON M_E2>=0, PIN, .VCY, Q_377B, .BL_10B, .BR_10B, .TAX;
})GOTO *-2 ON M AND Q=0, ABSP_-64;
* ASSEMBLE ONE WORD FROM PAPER TAPE. USES AR, R. LEAVES
* RESULTS IN AR,M
SFLOOP:}"M_Q_0, R_-4;
})M_M OR Q LCY 4, DGOTO * ON R_R+1<0;
})AR_M_M LCY 2, CALL RBPT;
* STORE ASSEMBLED WORD AND CLOSE LOOP
})M_M OR Q, MAR_U_U+1, STORE, DGOTO IRESET;
})GOTO SFLOOP ON ABSP_ABSP+1<0, M_0;

* SUBROUTINE TO READ ONE BYTE FROM PAPER TAPE FOR SELF-FILL.
* CHECK FOR SICK READER AND STOP IT IN THAT CASE.
* CHECK PARITY AND STOP THE READER IF IT IS WRONG.}"OTHERWISE
* RETURN THE LAST 6 BITS OF THE BUTE IN Q, AR IN M.
* ASSUME THE READER IS RUNNING ON ENTRY.}"IF IT IS STOPPED,
* THE INPUT WORD WHICH CAUSED THE TROUBLE IS DISPLAYED IN
* THE SENSE LIGHTS.}"CLOBBERS MQZ, R0,T
RBPT:}$Z_PTRADR, ALERT;
}%GOTO RBPT ON T_Q_E2>=0,PIN,.VCY,M_PTRERR+PTRSICK,.BL_10,.BR_10,.TAX;
})GOTO STOPTR ON Z_M AND Q#0, R0_-WDLNG;
* GOT A CHARACTER IN Q. COMPUTE PARITY OF THE WHOLE WORD, WHICH
* SHOULD BE EVEN SINCE THE FLAG BIT IS SET
})Z_Q EOR Z, R0_R0+1;
})Q_Q LCY 1, GOTO *-1 IF R0<0, M_77B;
})Q_M AND Q, M_AR, RETURN IF Z>=0;
* STOP READER AND DISPLAY INPUT WORD IN LIGHTS
STOPTR:}"Z_PTRADR, ALERT;
})Z_HLTPTR, POT;
})Z_SSLADR, ALERT;
})Z_T, POT, GOTO *-1;

}'DP ADMASK_77000000B;

* CHANGERT. SECOND WORD (IN TEMP2) IS DESIRED NEW VALUE OF PRTT.
CHRT:}"CALL CHKPID, SPT1_0;
* SCAN DOWN RTQ LOOKING FOR TWO THINGS
*}"1) SLOT TO INSERT THIS REQUEST.
*}"2) PROCESS (NOW IN M) ON QUEUE. IF FOUND, IT IS REMOVED
* DURING THIS SCAN WE ASSIGN HOLDING REGISTERS AS FOLLOWS
*}&TEMP2 - DESIRED NEW VALUE OF PRTT
*}&TEMP3 - CLOCK VALUE FOR PRECEDING NODE.
*}&TEMP4 - ADDRESS OF PRECEDING NODE
*}&TEMP1 - SAME FOR CURRENT NODE.
*}&SPT1 - SAME FOR ENTRY AFTER WHICH TO INSERT (IF FOUND, OTHERWISE 0)
*}&SPT2 - SAME FOR TARGET PROCESS, BUT WITH 0 IN}"TOP 6 BITS
*}&SPT3 - PRRTP OF TARGET PROCESS, I.E. 0 IF IT IS NOT ON RTQ
*}&SPT4 - CLOBBERED
}'SPT2_M, CALL GETRTP;
}'Q_ADMASK, TEMP3_OLDRT;
}'SPT3_M AND NOT Q, M_TEMP1_RTQ-PRRTP, CALL GETRTP;
* M = ADDRESS OF NEXT (ABOUT TO BECOME CURRENT) NODE ON RTQ,
* Q = ADMASK
RTSCAN: Z_M AND NOT Q, GOTO ENDRTQ IF NULLPTR, Q_TEMP4_TEMP1;
}'Q_SPT2, TEMP1_Z, CALL GETRTP;
}'GOTO CHRT1 ON Z EOR Q#0, Z_TEMP2;
* FOUND THE PROCESS ON RTQ. TAKE IT OFF
}'PROTECT(PRTPRO), Q_ADMREG;
}'TEMP1_M_TEMP4, CALL GETRTP, SPT3_0;
}'Z_M, CALL GETRTP, TEMP4_MAR;
}'Z_SPT4_M AND Q ! Z AND NOT Q;
}'M_M AND NOT Q, STORE;
}'MAR_TEMP4, M_Z, STORE;
* NOW LOOK AT TEMP2 TO SEE WHETHER THE PROCESS HAS TO BE
* PUT BACK ON RTQ
}'GOTO DONERT ON TEMP2<0, UNPROTECT;
* AND AT SPT1 TO SEE WHETHER THE INSERTION POINT HAS ALREADY BEEN FOUND
}'Q_ADMASK, DGOTO RTSCAN, M_SPT1;
}'M, GOTO INSRTQ IF LB#0, M_SPT4;
* IT HAS NOT. PROCEED WITH SCAN FOR INSERTION SLOT (NOTE DGOTO RTSCAN ABOVE)
* FETCH TIME FROM CURRENT NODE
CHRT1: MAR_SUBR+1, FETCH, SPT4_M;
}'TEMP3_M, Q_TEMP3, CALL TIMINT;
}'Q_ADMASK, Z_TEMP4, GOTO RTSCAN IF R0>=0;
* FOUND SLOT FOR INSERTION. RECORD IT
}'SPT1_Z;
}'Q_SPT3, DGOTO INSRTQ;
* IS PROCESS STILL ON RTQ. IF NOT, WE MUST KEEP SCANNING
}'Q, GOTO RTSCAN IF LB#0, Q_ADMASK;


}'ORG 1000B;

* READY TO DO INSERTION. SHOULD WE DO IT (I.E. IS DESIRED TIME >=0)
INSRTQ: GOTO DONERT ON TEMP2<0, Q_ADMASK;
* YES
}'PROTECT(PRTPRO);
}'M_Z_SPT2, CALL GETRTP;
}'SPT2_M, TEMP1_MAR;
}(M_SPT1, CALL GETRTP;
}'TEMP3_Z AND NOT Q ! M AND Q, Z_SPT2;
}'Q_M AND NOT Q ! Z AND Q, M_TEMP3, STORE;
}'Q_MAR_TEMP1, M_Q, STORE, DGOTO DONERT;
}'MAR_Q+1, M_TEMP2, STORE;
* REACHED END OF RTQ. IF INSERTION IS DESIRED, DO IT HERE
ENDRTQ: SPT1_Q, GOTO INSRTQ;
* FINISHED
DONERT: CALL FIXRTQ;
}'R;
}'CALL UERROR;
UERROR:}#Z_SSLADR, ALERT;
})Z_OS MRG 2525B4, POT, GOTO UERR1;
})CALL UERROR;
CHKPIW:}"GOTO FREECPU ON M#0;
})GOTO RETCALL;
}).DGO;
}).LOC;
}).SSP_1;
})CALL UERROR;
UERR1:}#MODE_4B7+14, UNPROTECT, GOTO SAVEST;
}).LOC;
}).SSP_1;
}).C_4B3;
}).DGO;
}).LOC;
}).SSP_1;
}).C_4B3;
}).DGO;
}).LOC;
}).SSP_1;
}).C_4B3;
}).DGO;
}).LOC;
}).SSP_1;
}).C_4B3;
}).DGO;
}).LOC;
}).SSP_1;
}).C_4B3;
}).DGO;
}).LOC;
}).SSP_1;
}).C_4B3;
}).DGO;
}).LOC;
}).SSP_1;
}).C_4B3;
}).DGO;
}).LOC;
}).SSP_1;
}).C_4B3;
}).DGO;
}).LOC;
}).SSP_1;
}).C_4B3;
}).DGO;
}).LOC;
}).SSP_1;
}).C_4B3;
}).DGO;
})CALL UERROR;


}'END;
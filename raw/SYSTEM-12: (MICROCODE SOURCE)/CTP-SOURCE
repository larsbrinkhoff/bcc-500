* THIS IS THE SOURCE FOR THE CTP MICROCODE
* LOCATION 0 IN BANK B

}'ORG 2000B;

* INSTRUCTION TABLE.}"MUST BE ON 128 WORD BOUNDARY
RSTCTP: Z_MODE, GOTO IRESET;
* ENTER CTP FROM CHIO. LOCATION 1 IN BANK B
CTP:}#GOTO ICONT1, M_P;
BRU:}%Q_R, Z_-1, GOTO FIXP;
* OVERFLOW FROM BRX
BRX1:}$M AND Q, GOTO FIXP IF LB#0, Q_R;
ETR:}%FETCH, DGOTO ILOOP;
})AR_M AND Q;
MRG:}%FETCH, DGOTO ILOOP;
})AR_M OR Q;
EOR:}%FETCH, DGOTO ILOOP;
})AR_M EOR Q;
NOP:}%GOTO ILOOP;
* OVERFLOW FROM EXU
EXU1:}$Z_READ, GOTO IL0;
EXU:}%FETCH, Z_FLAGADR;
})ALERT, GOTO EXU1;
STA:}$M_AR, GOTO STOR;
* OVERFLOW FROM SHIFT IN THESE THREE HOLES
ENDLSH:}"AR_M AND Q ! Z AND NOT Q, GOTO ILOOP;
STB:}%M_BR, GOTO STOR;
ENDRSH:}"BR_M AND Q ! Z AND NOT Q, GOTO ILOOP;
STX:}%M_XR, GOTO STOR;
GOTSHM:}"T_Q_Z, M_BR, GOTO DOSHIFT;
BRX:}%M_XR, Z_-1, DGOTO BRX1;
})M_XR_M+1, DGOTO ILOOP, Q_IABIT;
BRM:}%M_P, SETA, CALL STOR;
})Q_0, GOTO FIXP;
UPOT:}$ALERT, DGOTO ILOOP;
})Z_BR, POT;
UPIN:}#ALERT, DGOTO LDB1;
})M_READ, DGOTO ILOOP;
RCH:}%M_R, Q_RCHMASK, DGOTO RCH1;
})M_M AND Q LCY 16, T_Z_XR;
SKE:}%FETCH, DGOTO TEST;
})M_M EOR Q;
BRR:}%Q_ADMASK, FETCH, DGOTO FIXP;
})Q_M AND NOT Q, Z_0;
SKB:}%Q_BR, FETCH;
SKB1:}$M_M AND Q, GOTO TEST;
SKN:}%Q_4B7, FETCH;
SKN1:}$M_M AND Q ! Q, GOTO TEST;
SUB:}%FETCH, DGOTO ILOOP;
})AR_Q-M;
ADD:}%FETCH, DGOTO ILOOP;
})AR_Q+M;
SKR:}%Z_R, FETCH, DGOTO SKN1;
})M_M-1, Q_BOUND, SETA, CALL STOR1;
MIN:}%Q_1, FETCH;
MIN1:}$M_M+Q, GOTO STOR;
XMA:}%FETCH, DGOTO CBA;
})Q_M, M_AR, DGOTO STOR;
ADM:}%FETCH, GOTO MIN1;
* SKG WHERE SIGNS AGREE
SKG1:}"M_M-Q, Q_4B7, GOTO SKN1;
SHIFT:}#M_R, Q_SCMASK, DGOTO SHFT1;
})Z_M AND Q, Q_SHOPMSK;
SKM:}%Q_BR, FETCH;
})M_M AND Q - Z AND Q, GOTO TEST;
LDX:}%Q_0, FETCH, DGOTO ILOOP;
LDX1:}$XR_M AND NOT Q ! Z AND Q;
SKA:}%FETCH, GOTO SKB1;
* SKG WHERE SIGNS DISAGREE
SKG2:}"Q_4B7, GOTO SKN1;
* SKG IS SIGN OF M-AR IF SIGNS AGREE, SIGN OF AR IF NOT
SKG:}#FETCH, DGOTO SKG1;
}'GOTO SKG2 ON M EOR Q<0;
LDB:}%FETCH, DGOTO ILOOP;
LDB1:}$BR_M;
LDA:}%FETCH, DGOTO ILOOP;
LDA1:}$AR_M;
EAX:}%M_R, Q_ADMASK, DGOTO LDX1;
})Z_XR, DGOTO ILOOP;
* NOTE THAT UPS1 SETS UP Z AND PROVIDES THE PENDING DGOTO ILOOP
* NEEDED BY UPSTAB
UPS:}%Q_R, M_UPSMASK, DGOTO UPS1;
})DGOTO M AND Q LCY 16 MRG UPSTAB+BANKBBIT;
XJ:}$T_REL, HFETCH, DGOTO ILOOP;
}'REL_M, M_T, STORE, DGOTO IL0;
UCALL: M_Z_R, Q_4B3, CLRA, DGOTO UC2;
}'Q_M AND Q LCY 12, Q_P, GOTO UC1 IF Z<0;
* OPCODE 44 IS SPARE
}'ALL;
}'ALL;

* LOCATION 112B

* START CTP AND SHUT OFF CHIO
CTPGO: Z_0-1, GOTO IRESET;

IRESET: MODE_-1, MAR_CTPREL, FETCH, CALL MAINCHK;
})Z_REL_M, MAR_MAR+1, FETCH;
})BOUND_M, Q_2;
})MAR_Z+Q, M_P, STORE, DGOTO FIXP;
})Z_IOCTL_0, Q_2;

* LOCATION 120B

* UPS TABLE. MUST BE ON 8-WORD BOUNDARY
* DGOTO ILOOP IS PENDING
UPSTAB:}"Q, STROBE;
UPR:}%Q, CLRPRO;
PRO:}%Q, SETPRO, GOTO * IF PRONEX, Z_0;
* PRO FALLS THROUGH WITH Z=0.
* OTHERWISE Z=R
STR2:}"Z, SETFAIL, GOTO ILOOP;
CLEARMAP: CLRMAP;
WAIT: Q_P, M_WAITINS, GOTO WAIT1;
WAITGO: M_WAITINS, GOTO WAIT2;
* UPS 7 IS SPARE
}'ALL;
}&GOTO SKIP IF AT1OFF;
}'GOTO SKIP IF AT2OFF;
}'GOTO SKIP IF AT3OFF;
}'GOTO SKIP IF NOSTROBE;
}'CLSTROBE;
}'GOTO SKIP IF NOCRASH;
}'CLFAIL;
}'Q, GOTO SKIP IF PRONEX;

* LOCATION 140B
* RCH TABLE. MUST BE ON 16-WORD BOUNDARY.
*}"ENTERED WITH DGOTO ILOOP PENDING, ABX IN MQZ
RCHTAB:}"Q_Z_R, GOTO XSA1;
CSA:}%Z_R, Q_0, GOTO XSA1;
CLAB:}$AR_M_0, GOTO CAB;
CLA:}%AR_0;
CLB:}%BR_0;
CLX:}%XR_0;
CAB:}%BR_M, GOTO ILOOP;
* THIS LINE IS EXECUTED FROM SEVERAL PLACES
CBA:}%AR_Q, Q_LNGSX+BANKBBIT;
XAB:}%AR_Q, GOTO CAB;
CBX:}%XR_Q;
CXB:}%BR_Z;
XXB:}%XR_Q, GOTO CAB, M_T;
CXA:}%AR_Z, GOTO ILOOP;
CAX:}%XR_M;
XXA:}%XR_M, M_T, GOTO CXA;
CNA:}#AR_0-M;

*
* CHECK R FOR < BOUND, THEN STORE M WITH MAR AND GOTO ILOOP
* UNLESS A IS SET, IN WHICH CASE RETURN
STOR:}$Q_BOUND;
STOR1:}#GOTO *+2 ON Z_R<0;
})GOTO RSTCTP ON Q-Z<=0;
})STORE, RETURN IF ASET, Q_4B7;
* FALL THROUGH

ILOOP:}#MAR_ABSP_ABSP+1, FETCH;
WAIT2: Q_MODE, Z_FLAGADR;
}'Q_P, ALERT, DGOTO IL0 ON NOT Q=0;
}'P_Q+1, Z_READ;
}'GOTO 547, BANKA;
})Q_1;}$*WAS GOTO RETCTP IF AT1ON
}(Z_FLAGADR, ALERT, M_P;
}(Z_READ;

* CONTINUE EXECUTION, STARTING WITH INSTRUCTION ADDRESSED BY P
* (NOW IN M)
ICONT1:}"Q_REL;
})MAR_ABSP_M+Q, FETCH;

IL0:}%Q_IOCTL, GOTO *+1;
})GOTO DOIO ON Z_Q AND Z#0, Q_OPMASK;
IL1:}%U_Q_M AND Q LCY 8;
})Q_R_Q LCY 2, Z_2*MAXOP+2;
})GOTO POPMB ON Q-Z>=0, Z_REL, CLRA;
IL2:}%CALL INDEX ON T_M LCY 1<0, Q_ADMASK;
}(Q_R_M AND NOT Q, M_R MRG BANKBBIT;
})MAR_Q+Z;
})DGOTO M, Q_T;
}'GOTO *+1 ON Q LCY 8<0, Z_Q_AR;
* INDIRECTION
})Z_REL, R_M MRG BANKBBIT, FETCH;
})GOTO IL2 ON M>=0, Q_75B6;}"*LONGAD - PRIMEM
* ABSOLUTE INDIRECTION
})CALL INDEX ON M LCY 1<0;
}(R_MAR_M AND NOT Q MRG 4B7, Z_R;
})GOTO Z, Z_Q_AR;
* SUBROUTINE FOR INDEXING
INDEX:}#Z_XR, DRETURN;
})M_M+Z, Z_REL;

* OPCODE IN Q GREATER THAN MAX DEFINED.}"TRAP UNLESS IT IS >77B,
* IN}"WHICH CASE IT IS POP.
POPMB:}#Z_POPBIT*2/1B5;
})GOTO RSTCTP ON Q AND Z=0, R_EXPOP;

* EXECUTING POP WITH NUMBER RCY 1 IN U, EFFECTIVE ADDRESS IN R. STORE
* P IN 0, R IN 1 AND JUMP TO U
EXPOP:}#Z_MAR_REL;
})M_P MRG IABIT, STORE;
}'Z_-1, Q_U, DGOTO FIXP;
}'Q_Q LCY 1;

* COME HERE AFTER XCHREGS ON RETURN FROM UCALL
URET1: GOTO FIXP ON Q_P>=0, Q_Z_SIGN;
}'P_Q AND NOT Z, GOTO *-1 IF ACLEAR, Z_SIGN+1;
* FALL THROUGH TO FIXP

* SET P TO Q+Z, RECOMPUTE ABSP AND GO TO ILOOP
FIXP:}$Q_P_Q+Z;
})Z_REL, DGOTO ILOOP;
})ABSP_Q+Z;

* THESE LINES ARE USED}"BY SKIP INSTRUCTIONS
TEST:}$M, GOTO ILOOP IF LB#0;
SKIP:}$Q_P, Z_1, GOTO FIXP;
*
* REMAINDER OF RCH
RCH1:}$DGOTO M MRG RCHTAB + BANKBBIT, Q_BR;
})M_AR, DGOTO ILOOP;

* FINISH SETTING A CONTROL REGISTER.
XSA1:}$T_SKZ, Z_Q, DGOTO CBA;
})SKZ_M, Q_T, DGOTO ILOOP;

* FINISH WAIT
WAIT1: P_Q-1, GOTO WAIT2;

* OVERFLOW FROM UPS
UPS1:}"Z_R, DGOTO ILOOP;


* REST OF SHIFT
SHFT1:}#M_R_M AND Q LCY 16, Q_MAXSHOP;
})GOTO RSTCTP ON Q-M<0, Q_WDLNG;
LNGSHL:}"T_BR, GOTO SHORTSH ON Z-Q<0;
})Z_Z-Q, Q_AR, DGOTO CBA;
})T_BR_Q, Q_T, DGOTO *+1;
})GOTO Q+M, Q_WDLNG;
LNGSX:}#GOTO LNGSHL;
})BR_0, GOTO LNGSHL;
})AR_-1, GOTO LNGSHL ON T<0;
})AR_0;
})GOTO LNGSHL;
SHORTSH: Q_1;
}'M AND NOT Q, GOTO *+2 IF LB=0, M_WDLNG;
})Z_M-Z;
})GOTO GOTSHM ON MAR_Q-Z>=0, Q_0;
SHLOOP:}"MAR_MAR+1, Q_Q LCY 1 MRG 1, GOTO SHLOOP IF R0<0;
})M_BR, T_Q;
DOSHIFT: M_M LCL Z, U_AR;
})BR_M LCH Z, M_U;
}(M_M LCL Z, Q_SHMRGX+BANKBBIT;
})Z_M LCH Z, M_R;
})DGOTO M+Q, M_BR;
})Q_T;
SHMRGX:}"BR_M AND NOT Q ! Z AND Q, GOTO ENDLSH;
})BR_M AND NOT Q, GOTO ENDLSH;
})AR_Z OR NOT Q, GOTO ENDRSH ON U<0;
})AR_Z AND Q, GOTO ENDRSH;
})AR_Z AND Q ! M AND NOT Q, GOTO ENDRSH;
* ENDLSH, ENDRSH AND GOTSHM ARE FILLING EMPTY WORDS IN THE
* INSTRUCTION TABLE

*
* THE AND OF THE FLAG WORD AND IOCTL (IN Z) IS #0. LOOK FOR ACTIVE
* DEVICE
DOIO:}$Q_Z, T_R0_0;
})Q_Q LCY 20, Z_T_T+1, DGOTO *;
})Q_R0_Q LCY 3, GOTO *+1 IF R0<0, M_IOPTR-2;
* GOT DEVICE NUMBER+2 IN T AND Z
})M_M+Z, Q_REL;
})MAR_Q+M, FETCH, Q_2B7;
})Q_Q LCL Z;
})Z_Q LCH Z MRG 4B7, Q_REL;
})U_M+Q;
})GOTO *+2 ON Q_R_M_M+1<0, SETA;
})STORE;
})GOTO CTPOUTPUT ON Q LCY OUTSHIFT<0;
* INPUT
})ALERT, MAR_U, DGOTO DONEIO, M_77B6;
})M_READ, R_Q AND NOT M, CALL STOR;
CTPOUTPUT: DGOTO NOEND ON M LCY EOBSHIFT>=0;
}'MAR_U, FETCH;
}(M EOR Q, GOTO NOEND IF LB#0;
* ENCOUNTERED END-OF-BUFFER
})Q_IOCTL, DGOTO DONEIO;
})IOCTL_Q AND NOT Z;
NOEND:}#ALERT;
})Z_M, POT;
* COMPLETED IO. CHECK FOR INTERRUPT
DONEIO: M_U, Q_OPMASK, DGOTO CTP;
}'GOTO *+1 ON M LCY INTSHIFT<0, Z_0;
* SHOULD CAUSE IT
})M_T MRG BRMINS+IOINT, GOTO IL1;

*
* SELF-FILL. TURN ON READER AND READ 64 WORDS (256 6-BIT CHARACTERS)
* INTO THE FIRST 64 (RELATIVE) LOCATIONS IN CTP MEMORY, AFTER
* SETTING CTPREL TO 10000B AND CTPBND TO 40000B
XSELFFILL: MAR_CTPREL, CALL MAINCHK;
}'M_U+1, STORE;
}'MAR_MAR+1, M_40000B, STORE;
})Z_PTRADR, ALERT;
})Z_GOPTR, POT;
* SKIP OVER INITIAL BLANK TAPE
})Z_PTRADR, ALERT;
}'GOTO *-1 ON M_E2>=0, PIN, Q_377B, .TAX, .BL_10B, .BR_10B;
})GOTO *-2 ON M AND Q=0, ABSP_-64;
* ASSEMBLE ONE WORD FROM PAPER TAPE. USES AR, R. LEAVES
* RESULTS IN AR,M
SFLOOP:}"M_Q_0, R_-4;
})M_M OR Q LCY 4, DGOTO * ON R_R+1<0;
})AR_M_M LCY 2, CALL RBPT;
* STORE ASSEMBLED WORD AND CLOSE LOOP
})M_M OR Q, MAR_U_U+1, STORE, DGOTO CTPGO;
})GOTO SFLOOP ON ABSP_ABSP+1<0, M_0;

* SUBROUTINE TO READ ONE BYTE FROM PAPER TAPE FOR SELF-FILL.
* CHECK FOR SICK READER AND STOP IT IN THAT CASE.
* CHECK PARITY AND STOP THE READER IF IT IS WRONG.}"OTHERWISE
* RETURN THE LAST 6 BITS OF THE BUTE IN Q, AR IN M.
* ASSUME THE READER IS RUNNING ON ENTRY.}"IF IT IS STOPPED,
* THE INPUT WORD WHICH CAUSED THE TROUBLE IS DISPLAYED IN
* THE SENSE LIGHTS.}"CLOBBERS MQZ, R0,T
RBPT:}$Z_PTRADR, ALERT;
}'GOTO RBPT ON T_Q_E2>=0, PIN, M_PTRERR+PTRSICK, .TAX, .BL_10B, .BR _10B;
})GOTO STOPTR ON Z_M AND Q#0, R0_-WDLNG;
* GOT A CHARACTER IN Q. COMPUTE PARITY OF THE WHOLE WORD, WHICH
* SHOULD BE EVEN SINCE THE FLAG BIT IS SET
})Z_Q EOR Z, R0_R0+1;
})Q_Q LCY 1, GOTO *-1 IF R0<0, M_77B;
})Q_M AND Q, M_AR, RETURN IF Z>=0;
* STOP READER AND DISPLAY INPUT WORD IN LIGHTS
STOPTR:}"Z_PTRADR, ALERT;
})Z_HLTPTR, POT, GOTO *-1, T_T;

*
* OVERFLOW FROM UCALL.
UC1:}#SETA;
UC2:}#P_Q, R0_@SR0+SIGN+100B, CALL XRS;
* FALL THROUGH INTO XCHREGS

* SIGN OF Z(R0) SET ON CALL, CLEAR ON RET
XCHREGS: M_R1, R1_M, CALL XRS;
}'M_R2, R2_M, CALL XRS;
}'M_R3, R3_M, CALL XRS;
}'M_R4, R4_M, CALL XRS;
}'M_R5, R5_M, CALL XRS;
}'M_R6, R6_M, CALL XRS;
}'Q_SKZ, M_Q, CALL XRS;
}'Z_SRR, GOTO URET1 IF Z>=0;
}'DGOTO URET;
}'CALL *+1, R0_SR0;
CALLZ: GOTO Z, Z_XR, DSETBAS;

* CONTROL RETURNS HERE FROM THE MICRO-CODED ROUTINE
URET:}"AR_M, M_R0, DGOTO XCHREGS, SETBBS;
}'XR_Z, Z_R0_@SR0+100B, CALL XRS;


XRS:}#SKZ_M, Z_R0_R0+1, DRETURN;
}'M_SKZ;


* SUBROUTINE TO TRY FOR REL CORE ADDRESS. SETS UP U FOR THE
* CONVENIENCE OF SELFFILL
MAINCHK: U_7777B;
}'RETURN;

* RETURN TO HOST
RETCTP: GOTO CTPRET, BANKA;

* UNUSED CELLS
}'ALL;
}'ALL;



}'END;
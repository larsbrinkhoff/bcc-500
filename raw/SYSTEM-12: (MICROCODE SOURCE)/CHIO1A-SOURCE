*
*TRICKS USED IN CODING:
*
* CERTAIN TABLES ARE ORIGINED AT LOCATIONS DIVISIBLE BY 2 ^ N FOR SOME N
*SO THAT A MRG RATHER THAN AN ADD CAN BE USED TO FETCH A WORD FROM 
*THE TABLE
*
*
* CALL A AND RETURN IS SOMETIMES WRITTEN GOTO A;
* AN EXAMPLE OF THIS IS THAT RCH CALLS LNK WHICH CALLS RCH BUT
*EACH OF THE CALLS IS DONE BY A BRANCH. THIS HAS TWO ADVANTAGES.
* 1) EACH CAN BE WRITTEN AS A LEVEL 0 SUBROUTINE BECAUSE
*}#IT DOESNT HAVE TO SAVE MORE THEN ONE LINK AT A TIME.
* 2) A PROGRAM CAN SORT OF CALL ITSELF RECURSIVELY.
*
@}&NOLIST EXT
*

* DOCUMENTATION CONVENTIONS:
*
* A COMMENT THAT BEGINS WITH THE WORD 'KNOW' INDICATES THAT THE MICROCODE
* AT THAT POINT USES AD HOC KNOWLEDGE ABOUT SOMETHING
*
*
*FOR EACH SUBROUTINE THE}"VARIBLES THAT ARE SET UP FOR THE
*SUBROUTINE ARE LISTED UNDER ARGUMENTS, AND THE VALUE IS LISTED.
*UNDER SIDE EFFECTS IS LISTED THE SCRATCH PAD REIGISTERS THAT MIGHT
* CHANGE AS A RESULT OF THIS CALL
*
*REGISTERS M, Q, Z, R0, AND VR ARE VOLATILE AND MAY BE CHANGED AT ANY 
*TIME UNLESS EXPLICITLY STATED THAY ARE DESTROYED ACROSS 
*SUBROUTINE CALLS
*
*
* CONSIDER THE THE FOLLOWING PAIRS OF SPL AND EQUIVILENT MICROPROCESSOR 
*STATEMENTS:
*
*})MICROPROCESSOR STATEMENT}'SPL STATEMENT
*
*}'DF,F,D,FB,LB;}4DECLARE FIELD F(D:FB,LB);
*
*}'@SKN};NUMBER(0 TO 63) OF THE SCRATCH PAD
*
*}'DISP(F)}:F
*
*}'MASK(F)}:FMASK(F)
*
*}'NMASK(F)}9FMASK(F) EOR -1
*
*}'ONE(F)};IF A_0, A$F_1, THEN A = ONE(F)
*
*}'HIGH(F)}:1 LCY (23 - FB)
*
*}'LDCY(F)}:23-FSHIFT(F)
*
*}'STCY(F)}:FSHIFT(F)
*
*}'[N]STUFF(F)}6M AND [NOT] Q LCY LDCY(F)}"#
*
*}'[N]STUFL(F)}6M AND [NOT] Q LCY LDCYL(F)
*
*
*# COUNT MUST BE 0,1,2,3,4,8,12,16,20 OR ERROR MESSAGE RESULTS
*IF COUNT IS ZERO}"A _ B LCY 0 ASSUMED TO BE JUST A _ B;
* AND IS GATED THROUGH THE ADDER

*
*GENERAL COMMENTS ABOUT READ AND WRITE CHARACTER SUBROUTINES.
*
*READ AN WRITE CHARACTER POINTERS MAY ONLY POINT TO WORDS THUS
*THE REST OF THE WORD MUST BE PADDED WITH NULLS.
*THIS MEANS THAT THERE MAY NOT BE ANY POINTERS TO THE MIDDLE
*OF STRINGS.}"THIS DOES NOT OCCUR IN THE CHIO HOWEVER.
*RCP POINTS TO THE WORD TO BE READ, AND WCP POINTS TO THE
*WORD TO BE WRITTEN.
*
*THE GENERAL READ CHARACTER AND WRITE CHARACTER PRIMITIVES (RCH, WCH)
*HOLD THE WORD}"POINTED TO, THE POINTER, AND THE
* COUNT OF THE NUMBER OF CHARACTER READ (WRITTEN) IN LIVE REGISTERS.
*THIS MINIMIZES MEMORY REFERENCES.
*NEW WORDS MUST BE FETCHED (FOR RCH) OR STORED (FOR WCH) WHENEVER
*THE POINTER IS INCREMENTED.
*
*IF THE READ (WRITE) CHARACTER POINTER ATTEMPTS TO INCREMENT
*INTO A LOCATION DIVISIBLE BY 8 THEN A SUBROUTINE FOUND
*IN RBUF (WBUF) IS CALLED TO MOVE THE POINTER TO THE 
*NEXT BUFFER (GET A NEW BUFFER ).
*
*IF A LINE IS EMPTY BOTH RCH AND WCH POINT TO BUF0 WHICH CONTAINS 0;
*
*IRCH AND IWCH ARE CALLED TO INITIALIZE THE SUBROUTINES AND 
* CRCH AND CWCH ARE CALL TO CLEANUP AFTER THE SUBROUTINES.
*
*WHENEVER A CHARACTER IS READ (WRITTEN),}"RCNT (WCNT) IS INCREMENTED;
*RCP (WCP) IS USED TO HOLD THE POINTER.
*THERE IS AN IMPORTANT CONCEPTIUAL DIFFERENCE BETWEEN RCNT AND WCNT.
*RCNT IS INCREMENTED FOR EACH NULL CHARACTER STEPPED OVER AS WELL AS EACH 
*CHARACTER READ. THUS RCNT IS USED TO DETERMINE THE NUMBR OF 
*CHARACTER SHIPPED FROM THE CPU.
*WCNT INDICATES THE NUMBER OF CHARACTERS WRITTEN AND IS THUS USED
*TO KEEP TRACK OF THE CHARACTER COUNT IN THE LINE
*RWORD (WWORD) IS USED TO HOLD THE WORD BEING
*POINTED TO.
* CORE IS UPDATED TO RWORD AND WWORD ONLY WHEN NECESSARY.
*
*IF RCP, OR WCP IS UPDATED THEN THIS IS SIGNALED BY SETTING
*THE BIT (STFLAG)IN THE WORD:
*
*WCP AND RCP ARE ABSOLUTE MEMORY ADDRESSES
*

* BUFFER ALLOCATION:
*
*1) IF THERE ARE ANY BUFFERS IN THE SYSTEM THEN A REQUEST FOR A 
* BUFFER IS ALWAYS FULFILLED
*2) CONSIDER THE SET OF ALL INPUT LINES SUCH THAT
*
*}'ABCNT > XBCNT}#WHERE D = ABCNT - XBCNT AND ABCNT IS THE ACTUAL
*
* BUFFER COUNT AND}"XBCNT IS THE MAX BUFFER COUNT FOR THE LINE
* THEN XIB IS SET TO BE THE SUM OF D FOR ALL LINES IN THE SET.
*
*SIMILERLY XOB IS SO SET FOR OUTPUT LINES
*
*NFB IS THE NUMBER OF FREE BUFFERS
*
*IF AT ANY TIME ONE OF THE FOLLOWING FORUR CONDITIONS OCCURS:
*
* NFB < MINFB, NFB > MAXFB.
*
*THEN THE PROCESS BERTHOLD IS AWAKENED IF IT IS NOT ALREADY AWAKE
* BRECHT IS A FLAG WHOSE VALUE IS 1 IF BERTHOLD IS NOT AWAKE.
*
*THERE ALSO EXISTS A MULTIPLIER MP WHICH}"MAY TAKE ON A VALUE FROM 1 TO 
*64
*WHENEVER A PROCESS DOES A WST IF:
*
*}'ABCNT >= MP * XBCNT/64
*
*THE PROCESS IS ADVISED NOT TO OUTPUT MORE CHARACTERS. (NSR = 1)
*
*MP IS ONLY UPDATED BY THE CPU
*WHEN A BERTHOLD IS AWAKENED IT SHOULD CHECK FOR THE REASONABLENES OFF
*XIB, XOB, AND NFB;
*

*
*THE TIME INTERUPT QUEUE
*
*SCRATCH PAD REGISTERS NCI TO LCI ARE OF THE FOLLOWING FORM:
*FTOSUB HA A TABLE ENTRY OF A SUBROUTINE
*FTOTIM HAS THE TIME (17 BITS WOTH , CLOCK TICK 10 MICROS.)
*
*THE HIGH ORDER TIME BIT IS NORMALLY 0.
*WHEN A SUBROUTINES IS CALLED IT MUST SPECIFY THE NEXT TIME THAT 
*IT SOULD BE CALLED BY INCREMENTING}"NCI APPROPRIATLY AND WHEN IT
*RETURNS GNRFIN WILL SORT THESE SCRATCH PAD REGISTERS
*THE TABLE OF SUBROUTINES CALLED IN GNR
*THE INITIALIZATION OF SUCH SUBROUTINE CALLS IN NCI TO LCI IS DONE BY THE CPU
*
* DOESN'T WORD IF THE INCRIMENT IS >2^17 * 10 US. (APX. 1 SEC)
*
*HE EIGHTEENTH BIT IS USED AS AN OVERFLOW BIT, IF ALL REGS
*HAVE THE OVERFLOW BIT ON CKFXP IS CALLED TO TURN THEM ALL OFF
*

*
*LIST OF ALL SIGNALS BETWEEN CHIO AND OTHER PROCESSORS
*
*THE CPU CAN SEND A STROBE1 TO THE CHIO INDICATING A REQUEST
*
*THE UTP CAN SEND A STROBE 1 TO THE CHIO INDICATING RESUME FROM RESTART
*SEQUENCE.}"THIS CASE IS DIFFERENT FROM THE ONE BEFORE IT
*BECAUSE IT CAN ONLY OCCUR AFTER A Z.M. SIGNAL.
*
*THE CHIO CAN SEND A STOBE1 (SIGUTP) TO THE UTP INDICATING A PROCESS
*HAS BEEN AWAKENED OR THAT THE CLOCK IN CORE HAS BEEN
*UPDATED (EVERY 1 M.S.)
*
*THE CHIO CAN SEND A STROBE2 (SETFAIL) TO THE}"UTP INDICATEING IT SHOULD 
*CRASH THE SYSTEM.
*THE UTP CAN SEND A STROBE2(NFAIL) TO THE CHIO INDICATING THAT IT SHOULD
*CLEAN UP IN PREPERATION FOR A SYSTEM CRASH
*
*THE MICROSCHEDULER MAY SEND A Z.M. SIGNAL WHICH SETS THE CHIOS
*PROGRAM COUNTER TO 0 AND SIGNALS EITHER A SYSTEM CRASH(FAILURE) OR
*THE CHIO SHOULD RELOAD ITS REGISTERS AND DO
*A SYSTEM RESTART AS DETERMINED BY SRMEM. (SEE RESTART)
*
*THE LOCATION COUNTER MAY ALSO BE SET TO ZERO BY A HARDWARE
*BREAKPOINT.}"THIS IS TESTED BY THE BRANCH CONDITION IBREAK.
*

*
*HERE FOLLOWS THE CALL AND RETURN MICROSUBROUTINES
*FOR LEVELS 0 TO 4;
* A LEVEL - SUBROUTINE WILL CALL NO SUBROUTINES DIRECTLY ALTHOUGH IT 
*MAY BRANCH TO ANOTHER LEVEL - SUBROUTINE
* A LEVEL TOP SUBROUTINE DOES NOT RETURN BUT BRANCHES TO ANOTHER
*TOP LEVEL SUBROUTINE
*WCH AND RCH ARE ON LEVEL 0 BY DEFINITION.}"SUBROUTINES THAT CALL THEM 
* ARE ON LEVEL 1 OR HIGHER.
*NOTE THAT A SUBROUTINE MAY EITHER RETURN BY RETURNING OR
*GOING TO RTSSN. OS IS SET UP TO MAKE THIS POSSIBLE
*
*THE FOLLOWING INSTRUCTION MUST BE IN LOCATION 0
}'ORG 0;
SYSI:}"GOTO SAVEST IF IBREAK;
}'GOTO RESTART;
GOGNR:})GOTO GNR;
}/GOTO 1B, .MS_60B;}#*SET BANK B GOTO CTP
}/M_2404B;}%*CTPREL
*
*BAD CPU REQUEST 
*
ABCPU:}$DGOTO ABORT;}4*TURN OFF DGOTO TO ABORT
}'M _ OS, STORE DISP(VALU), GOTO *+1;
}'FETCH DISP(NSR);
}'Q _ MASK(NSR);
}'M _ M OR Q, Q _ MASK(RWCH);
}'M _ M AND NOT Q, STORE, GOTO GNR;}#*TURN OFF GOTO TO ABORT
ABORT:}$GOTO SAVEST, SETFAIL;
SVOS0: SVR0 _ Z, GOTO ABORT, Z _ OS;
RTSS0:}"VR _ Q, Q _ SVR0;
}'GOTO Q, Q _ VR;
SVOS1: SVR1 _ Z, GOTO ABORT, Z _ OS;
RTSS1:}"Q _ SVR1, VR _ Q;
}'GOTO Q, Q _ VR;
SVOS2: SVR2 _ Z, GOTO ABORT, Z _ OS;
RTSS2:}"Q _ SVR2, VR _ Q;
}'GOTO Q, Q _ VR;
SVOS3: SVR3_Z, GOTO ABORT, Z _ OS;
RTSS3:}"Q _ SVR3, VR _ Q;
}'GOTO Q, Q _ VR;
SVOS4: SVR4 _ Z, GOTO ABORT, Z _ OS;
RTSS4:}"Q _ SVR4, VR _ Q;
}'GOTO Q, Q _ VR;
*
*
*SPECIAL TRIVIAL SUBROUTINES AND LOCATIONS
*
RETRESET:}$RESETA, RETURN;
*
RETSET:}$SETA, RETURN;
*
FSTORE:}#STORE, RETURN;
*
FFETCH:}$FETCH, RETURN;
GOTOZ: GOTO Z;
GOTOM: GOTO M;
GOMPQ: GOTO M+Q;
GOQPZ: GOTO Q+Z;
QQCYZ: Q _ Q LCH Z, DRETURN;
}(Q _ Q LCL Z;
NSR1:}"NSRFLAG_1, RETURN;
NSR2:}"NSRFLAG_2, RETURN;

*
* B2400: HANDLE 2400 BAUD LINE REQUEST
*
* ARGUMENTS: IN HARDWARE INTERFACE
*
*VALUE: NONE
*
*LEVEL: TOP
*
*NMR: 0
*
*SUBROUTINES CALLED: OUTL2, INL2, INLOGIC, GMTL;
*
B2400:})ALERT, Z _ WHYAT2;
}'PIN, M _ E2, Q _ MASK(B24D);
}'BWORD _ Q _}"M AND Q;
*
*SETUP LDVTE
}'Q _ Q LCY 1, Z _ LB24T;
}'LDVTE_ Z + Q, Q _ MASK(ERB);
}'GOTO INER ON M AND Q # 0, Q _ MASK(RRQ);
}'GOTO B24I ON M AND Q # 0, Q _ MASK(TRQ);
}'GOTO B2403 ON M AND Q # 0;
*IF FALSE REQUEST RETURN
}'FETCH F24C;
}'M _ M + 1, STORE, GOTO GNR;
INER:}$ALERT, Z _ BWORD MRG INRQ;
}'PIN, M _ Q _ 71B, Z _ E2;}$*IF TRANS. RATE ERROR ONLY
}'GOTO TRE24 ON M AND Q - Z AND Q = 0;
*SEND STATUS CHANGE INFORMATION
}'BWORD _ Z, CALL GMTL, Z _ 0;
}'CALL INLOGIC, M _ FLDCHAR;
}'M _ BWORD, Q _ MASK(MSF), DGOTO B24I;
}'CALL INLOGIC, M _ STUFF(MSF) MRG 200B;
*OUTPUT CHARACTER
B2403:}$CALL GMTL, Z _ 1;
}'CALL OUTL2;
}'GOTO B24N IF ASET;
}'ALERT, Z _ BWORD MRG OUTRQ;
*
}'Z _ M MRG MASK(TRCH), POT, GOTO GNR;
*INPUT CHARACTER
B24I:}$CALL GMTL, Z _ 0;
}'ALERT, Z _ BWORD MRG 200B + INRQ;
}'M _ E2, PIN, Q _ MASK(RRE);
}'BWORD _ M;
}'GOTO B24I1 ON M AND Q =0, Q _ MASK(ICHAR);
}'CALL INLOGIC, M _ SUBI;
}'FETCH RECC;
}'M _ M + 1, STORE;
}'M _ BWORD;
B24I1:}$BWORD _ STUFF(ICHAR), Q _ MASK(ICR), DGOTO GNR;
}'M _ BWORD, CALL INL2 ON M AND Q # 0;
*
*TRANSMITTER RATE ERROR BUMP TRECNT
TRE24:}$FETCH TRECNT;
}'BWORD _ Z;
}'M _ M + 1, STORE, GOTO B24I;
*
*
* ASET: NO OUTPUT = 0}"ONLY LEGAL CHARACTER
*
B24N:}$GOTO GNR ON M = 0;
}'FETCH ILC24;}4*ILLEGAL CONTROL TO 2400 BAUD LINE
}'M _ M + 1, STORE, GOTO GNR;

*
* BLAKE: KEEPS TRACK OF FREE BUFFERS
*
* BLAKE IS CALLED AT THE END OF EACH REQUEST THAT MIGHT HAVE USED OR
*RETURNED BUFFERS. IT ENSURES THAT PRB WILL NOT POINT TO A BUFFER AND
*THAT AVB WILL.
* BLAKE WILL WAKEUP BERTHOLD IF:
*}'1) NFB< MINFB
*}'2) NFB > MAXFB
*
*NOTE: NORMALLY NO REQUEST MAY USE OR FREE MORE THEN ONE
* BUFFER (ONE REQUEST WILL NOT DO BOTH).
* AN EXCEPTION EXISTS FOR LINKED LINE, WHICH MIGHT USE
*TWO BUFFERS IN ONE REQUEST.}"THEREFORE THE LOGIC THAT HANDLES LINKING
*MUST CALL BLAKE EVERY TIME IT WRITES A CHARACTER IN A LINKED LINE;
*
* ARGUMENTS:
*}'BFLAG: 0, NO ACTION, 4B7: CHECK AVB AND PRB.
* WAKEUP (3 AND 4 ABOVE)
*
*VALUE: NONE
*
*LEVEL: -
*
*SUBROUTINES CALLED: WAKEUP(GOTO)
*
BLAKE:}&Z _ MASK(ZLIN)+7B;
}'Q _ PRB;
* PRB = 0,NO BUFFER RELEASED; PRB = 1 TO 7 , NULL SOURCE BUFFER 
* WHICH SHOULD NOT BE RELEASED
}'GOTO BLAK2 ON Q _ Q AND NOT Z = 0, M _ FREEL;
*RETURN RELEASED BUFFER
}'FREEL _ Q;
}'Z _ BUF0;
}'STORE Q + Z;
}'PRB _ 0, FETCH DISP(NFB);
}'STORE, M _ M + 1, Z _ MAXFB;
}'GOTO BLAK2 ON Z - M > 0, M _ FREEL;
*SIGNAL WAKEUP OF BERTHOLD BY RESETING BFLAG;
}'ALERT, BFLAG _ 0, Z_103B, GOTO 1625B;
*NOW SEE IF THER IS AN AVAILABLE BUFFER AND IF THERE IS NOT MAKE ONE 
* AVAILABLE
*M CONTAINS FREEL
BLAK2:}$M, Z _ AVB, CALL ABORT IF LB=0;}"*IF FREE LIST NULL
}'GOTO BLAKA IF Z>=0, Z _ BUF0; *IF AVB<0, BUFFER IN AVB HAS BEEN USED
*MAKE BUFFER AVAILABLE
}'AVB _ M;
}'FETCH M + Z, Q _ MASK(ZLIN)+7B;
}'CALL ABORT ON M AND Q # 0;}&*BUFFERS SCREWED UP
}'FREEL _ M, FETCH DISP(NFB);
}'STORE, M _ M - 1, Z _ MINFB;
}'Z _ Z - M, GOTO BLAKA ON BFLAG>=0;
*IF Z>=O TURN OFF 360
* BFLAG = 0 USED A FLAG TO WAKEUP BERTHOLD
}'GOTO 1626B, BFLAG _ 0;
*
*WAKEUP BERTHOLD
BLAKA:}$DRETURN ON BFLAG < 0;
}'BFLAG _ 0, Z _ WKBERT;
}'FETCH BRECHT;
}'STORE, RETURN ON M = 0, M _ 0;
}'FETCH BERTHOLD, GOTO WAKEUP;
*

*
* BSCN: BIT SCAN
*
* BSCN IS CALLED EACH 1/7 OF A BIT TIME TO SCAN THE TTYS
* AND DO ANY INPUT OR OUTPUT THAT MIGHT BE NECESSARY
* BSCN LOOKS FOR THREE DIFFERENT TYPES OF REQUESTS:
*
* 1) NO INPUT IN PROGRESS- IF A ONE BIT COMES IN INITIATE CHARACTER READ
* 2) INPUT BIT MUST BE READ
* 3) OUTPUT BIT TO TTY.
*
*THE TTYS
* ARE STAGGERED SO THAT EACH 1/7 OF A BIT TIME 1/7 OF THE TTYS ARE 
*SERVICED AND THAT TTY IS NOT RESERVICED UNTIL THE NEXT BIT TIME.
*
* ARGUMENTS:
*}'M: TIME
*}'Z: INTERVAL (SET UP IN BRANCH VECTOR)
*
*VALUE: NONE
*
*SIDE EFFECTS: ALL VARIABLE REGISTERS MAY BY DESTROYED
*
*LEVEL: TOP
*
*SUBROUTINES CALLED: GLBTE,IBF,FLB,DID,DOD (SETBT, AN INTERNAL SUB)
*
*NOT THAT THE SUBROUTINE NUMBER IS THE DEVICE NUMBER
BSCN:}$NCI _ M + Z, Q _ MASK(FTOSUB);}"*SUB NO IS DEVICE TYPE
}'M _ STUFF(FTOSUB), CALL GLBTE;
}'STORE;}2*UPDATED BSNO
* DO INPUT
}'HFETCH BTIME MRG 1, Q _ -1,}"CALL SETBT;
*M HAS BWORD
BSCN6:}$GOTO BSCN7 ON M=0;
}'CALL FLB;
}'Q _ 3777B, CALL DOD, HFETCH LDVTE;
}'M _ BWORD, GOTO BSCN6;
* DO OUTPUT
BSCN7:}"Q _ -1, FETCH BTIME , CALL SETBT;
*M HAS BWORD
BSCN8:}$GOTO BSCN1 ON M =0;
}'CALL FLB;
}'Q _ 77740000B, CALL DID, HFETCH LDVTE;
}'M _ BWORD, GOTO BSCN8;
*SERVICE LEADING BITS ON INACTIVE INPUT TTYS
BSCN1:}$FETCH LBTBE MRG DISP(NCIP);
}'Z_TINPUT, ALERT;
}'PIN, Q _ E2, GOTO 1657B;
RE1:}#BWORD _ M _ M AND NOT Q;
*M HAS BWORD
BSCN4:}$GOTO GNRFIN ON M =0;
}'CALL FLB;
}'CALL IBF, HFETCH LDVTE;
}'M _ BWORD, GOTO BSCN4;
*
SETBT: BWORD _ M _ M AND Q, RETURN;
*

*
* CKFXP: CLOCK FIXUP
*
* CKFXP IS CALLED WHEN THE OVERFLOW BIT(BIT 18) IS ON FOR ALL THE
* CLOCK DRIVEN FUNCTIONS.
*IT WILL TURN OFF THE BIT IN ALL OF THE CLOCK DRIVEN FUNCTIONS
*(SEE GNR)
*THIS SUBROUTINE MAY BE CALLED TO INITIALIZE THE STACK. IT 
*THIS IS DONE BY STTING THE TIME TO ZERO (THUS THE WHOLE WORD IS ZERO)
* CKFXP WILL THEN SET THE TIME FOR EACH OF THE REGISTERS TO THE CURRENT 
*TIME
*
* ARGUMENTS:
*}'R0: -@LCI+@NCI-1 SETUP IN GNR
*
*VALUE: NONE
*
*SIDE EFFECTS: NONE
*
*LEVEL: -
*
CKFXP:}$VR _ Z _ @NCI+1;
CKL:}#M _ SKZ, Q _ MASK(OVTIM);
}'Z _ M AND NOT Q, GOTO GNRFIN ON R0_R0+1 >=0;
}'GOTO CKL2 ON M AND Q#0, Q _ MASK(FTOTIM);
}'Z _ RDCKL, ALERT;
}'PIN, Z _ E2, NCI _ MASK(OVTIM);
CKL2:}$M _ M AND NOT Q + Z AND Q, Z _ VR;
}'SKZ _ M, Z _ VR _ VR + 1, GOTO CKL;
*

*
* CPUFIN: BRANCHED TO AT END OF CPU REQUEST
*
* ARGUMENTS:
*}'M: VALU
*
CPUFIN:}$STORE DISP(VALU), Q _ NSRFLAG;
}'Q _ Q LCH STCY(NSR);
}'Z _ Q LCL STCY(NSR), Q _ MASK(RWCH);
}'FETCH DISP(RWCH);
*IF NO REQUEST WAITING SOMETHING VERY STRANGE HAPPENED
}'CALL ABORT ON Q AND M = 0;}&*RWCH CLOBBERED
}'M _ M AND NOT Q, Q _ MASK(NSR), DGOTO GNR;
}'M _ M AND NOT Q + Z AND Q, STORE;
*

*
* CPURQ: SERVICE CPU REQUEST
* CPU FUNCTIONS MAY EITHER RETURN OR BRANCH TO CPUFIN
*NOTE: THE LINE NUMBER FOR THE FIELD MUST BE LEGAL EVEN IF NOT USED
*
* ARGUMENTS: CPUIT
*
*VALUE: NONE
*
*LEVEL: TOP
*
*SUBROUTINES CALLED: BRANCHES TO REQUEST SPECIFIC CODE, GLE
*
*
*SIDE EFFECTS: ALL REGISTERS THAT HOLD VARIABLES CLOBBERED
*
CPURQ:}$FETCH DISP(LNO), DGOTO RESTART;
}'NSRFLAG _ 0, Q _ MASK(CRT), GOTO *+1 IF NFAIL;
}'VR _ STUFF(CRT), Q _ MASK(RWCH);
}'CALL BDRQ ON M AND Q=0, Q _ MASK(LNO), RESETCPU;
*KNOW GLE DOES NOT DESTROY VR
}'M _ LINE _ Q AND M, RESETA, CALL GLE;
*
*MAXIMUM LEGAL LINE NUMBER MUST BE HAND COMPILED IN
*
}'Q _ VR, M _ 17B;
}'CALL GOQPZ ON M - Q >= 0, Z _ CPUTBL;
*NOTE NEXT INSTRUCTION}"MUST BE GOTO CPUFIN
CPUTBL:}$GOTO CPUFIN;
}'GOTO WST;
}'GOTO RCND;
}'GOTO RSTB;
}'GOTO MBLK;
}'CPUFLAG _ -1, GOTO CPUFIN;
}'CPUFLAG _ 0, GOTO CPUFIN;
}'GOTO PUTFIELD;
}'GOTO GETFIELD;
}'GOTO GETREG;
}'GOTO PUTREG;
}'GOTO RTUPC;
}'GOTO DOAPOT;
}'GOTO DOAPIN;
}'FETCH, R0 _ 43B, GOTO TOFF24;}#*CARG1 AT LOCATION 43B
*
* INCREMENT MAXIMUM LEGAL LINE NUMBER IF NEW CALLS ADDED
*
}'R2_-LSCRATCH, GOTO LOADST;
}'GOTO CPUFIN, RESETTU;
}'ALL; *SPARE
}%CALL ABORT;}"*SPARE
BDRQ:}$FETCH NULRQC;
}'M _ M + 1, STORE, GOTO GNR;
*

*
* CRCH: CLEANUP FOR RCH
*
*THIS MUST BE CALLED AFTER A SERIES OF CALLS TO RCH
*
* ARGUMENTS: NONE
*
*NMR: 1
*
*VALUE:
*}'A: AS ON ENTRY
*
*SIDE EFFECTS: NONE
*
*LEVEL: -
*
*SUBROUTINES CALLED: NONE
*
*KNOW: A IS LEFT ALONE
*
CRCH:}$M _ RWORD, DRETURN;
}(STORE RCP;
*

*
* CWCH: CLEANUP WRITE CHARACTER SUBROUTINE SUBROUTINE
*
* CWCH MUST BE CALLED AFTER A SERIES OF WCHS ARE CALLED.
* A IS SET FOR RSTB AND RCND SO CHAR CAN BE LEFT JUSTIFIED IN CPUIT
*
* ARGUMENTS: A IS SET IF WORD SHOULD BE LEFT JUSTIFIED BEFORE STORE
*}&Z: UNRTOUCHED (FOR PWP)
*
*NMR: 1
*
*VALUE:
*}&Z: AS ON ENTRY
*
*SIDE EFFECTS: NONE
*
*LEVEL: -
*
*SUBROUTINES CALLED: NONE
*
*KNOW: A IS LEFT AS IS
CWCH:}$M _ WWORD, Q _ MASK(LCHAR), DRETURN IF ARESET;
}'STORE WCP, RETURN ON M = 0;
}'RETURN ON M AND Q # 0;
}'M _ M LCY 8, GOTO *-2;

*
*
* DID: DO INPUT DEVICE
*
*THIS SUBROUTINE IS CALLED WHEN AN INPUT BIT TO}"TTY IS FOUND
*DID SHIFTS IN THE NEXT BIT AND LOOKS FOR 2 IMPORTANT CASES
*}"1) THE CHARACTER WAS AND IS ALL ONES INDICATING A FALSE FIRST BIT WAS FOUND
*}"2) THE LEADING BIT OF THE CHARACTER WAS A ZERO INDICATING THE CHARACTER
*}"IS NOW CORRECT AND SHOULD BE PLACED IN THE LINE. THIS IS DONE.
*}"3) IF THE CHARACTER IS ALL ZEROS (MORE THEN 8 BITS) SEND CBREAK
*
*NOTE THAT THE CHARACTER IS BAS ACKWARDS
*(LOW ORDER BIT FIRST, AND LINE HIGHT MEANS 0.
*
*WHEN THERE IS NO CHARACTER THE BUFFER IS ALL ONES
*
* ARGUMENTS
*}'R0: ADDRESS OF CIPT
*}'M: WORD CONTAINING CIPT
*}'Q: MASK(CIP)
*
*VALUE: NONE
*
*SIDE EFFECTS: CHARACTER IS UPDATED AND PUT IN THE LINE IF COMPLETE
*
*SUBROUTINES CALLED: INLOGIC, GMTL
*
*LEVEL: 4
*
DID:}#Q _ NOT M OR NOT Q LCL 23 MRG 10B;
}'Z _ NOT Q LCH 23, Q _ MASK(CIPT);
}'M _ M AND NOT Q ! Z AND Q, Q _ LBIT;
}'Z_TINPUT, ALERT;
}'Q _ E2, PIN, GOTO 1663B;
*
RE2:}#GOTO DID1 ON Z AND Q=0, Q _ MASK(CIPT), SETA;
}'M _ M MRG}"4B7;
DID1:}$STORE, GOTO DID2 ON NOT M AND Q=0, Q _ 1B5;
}'DRETURN ON NOT M AND Q=0, Q _ 40000B, RESETA;
}'GOTO 1633B ON M AND Q = 0, Z _ NCI MRG 4B6-1;
*IF TYPE = 2741, CHARACTER HAS BEEN RECEIVED OTHERWISE ONE MORE BIT TIME
}'M _ M LCL 23, Q _ M2741T*4B6+4B6-1;
}'M _ M LCH 23 MRG 2B7, DGOTO DID2;
}'RETURN ON Z-Q#0;
DID3:}"Q _ MASK(CIPT), Z _ OS, GOTO SH1;
}'GOTO 1622B ON M AND Q=0, Q _ MASK(CIP);}"* BREAK FOUND
*STORED WORD HAS CHARACTER IN LEFT 8 BITS
}'M _M AND Q LCL LDCY(CIP);
}'CHAR _ M}"LCY 8, CALL GMTL, Z _ 0;
}'M _ MTCE, CALL 1667B;}%* PATCH OF 12/13/75 (WWL)
}'FETCH BTIME;
}'Q _ LBIT, GOTO RTSS4;
}'M _ M AND NOT Q, STORE, CALL DID2;}"*GOTO DID2 AND RETURN
DID5:}"M _ CHAR}"_ CBREAK, CALL INLOGIC;
}'GOTO RTSS4;
*FIRST BIT STORED AS A FALSE START; ALSO CLEVERLY CALLED FROM DID1+7
DID2:}"VR _ M, Q _ LBIT;
}'FETCH BTIME;
}'M _ M AND NOT Q, STORE;
}'FETCH LBTBE MRG DISP(NCIP), DRETURN;
}'M _ M OR Q, STORE, GOTO DID3 IF ARESET;
*

*
*DOAPOT AND DOAPIN
*
*JUST FOR THE CONVIENCE OF RANDOM PEOPLE
*
DOAPOT:}(FETCH, R0 _ 43B;}$*CARG1 AT LOCATION 43B
}'FETCH R0+1, Z _ M;
}'Q _ M, ALERT;
}'Z _ Q, POT, GOTO CPUFIN;
DOAPIN:}"FETCH CARG1;
}'Z _ M, ALERT;
}'PIN, M _ E2;
}'GOTO CPUFIN;
*

*
* DOD: DO OUTPUT DEVICE
*THIS SUBROUTINE IS CALLED TO OUTPUT A BIT TO A LOCAL DEVICE
*
*THIS USES A NINE (2741), TEN (MODEL 37), OR AN ELEVEN (MODEL 35) BIT
*CHARACTER, THE FIRST BIT BEING A 1 AND THE
*LAST}"ONE TWO BEING ZEROS. THIS CHARACTER IS FILLED WITH 1 WHEN IT IS
*SHIFTED AND IF THE CHARACTER IS ALL ONES THEN IT
*HAS BEEN OUTPUT AND MUST BE RELOADED.
*THE BITS ARE BAS ACKWARDS
*LEAST SIGNIFICANT BIT FIRST)
*
* ARGUMENTS
*}'R0: ADDRESS OF COP
*}'M: WORD CONTAINING COP
*}'Q: MASK(COP)
*
*VALUE: NONE
*
*SIDE EFFECTS: 1 BIT IS OUTPUT AND A CHARACTER MAY BE FETCHED.
*
*LEVEL: 4
*
*SUBROUTINES CALLED: OUTLOGIC, GMTL, WKOL,DOD;
*
*SHIFT RIGHT 1 AND SHIFT IN A 0 BIT.
DOD:}#GOTO DOD2 ON Q _ M AND Q}"LCH 23 = 0, Z _ MASK(HCOP);
}'Q _ Q LCL 23;
}'Z _ Q AND NOT Z, Q _ MASK(COP);
}'M _ M AND NOT Q + Z AND Q, STORE, Q _ LBIT;
*4B7 BIT IN Z IS BIT SHIFTED OUT
}'Z _ 0, GOTO DOD1 IF Z>=0, M _ OBITS;
}'Z _ - 1;
*CHANGE OBITS AND OUTPUT
DOD1:}"OBITS _ M _}"M AND NOT Q ! Z AND Q, Z _ TOUTPUT, ALERT;
}'Z_M LCY 16, DGOTO 1654B;
}'POT;
* NEED A NEW CHARACTER, OUTPUT WORD FILLED WITH ZEROS.
DOD2: Z _ OS;
}'CALL GMTL, SVR4 _ Z, Z _ 1;
}'CALL}"OUTL2;
}'GOTO DOD4 IF ASET;}%*IF NO CHARACTERS
}'VR _ 0;
}'VR _ M LCY 1;
DOD9:}"Q _ LBTBE;
*VR NOW HAS WORD TO BE OUTPUT WITH START AND STOP BITS FOR MODEL 35
}'M _ LBTBA;
}'Q _ Q - M;
}'Q _ Q LCY 20, Z _ BV3;
*SET UP OUTPUT BUFFER: 2 STOP BITS(0), CHARACTER, 1 START BIT(1).
*THE WHOLE THING IS COMPLEMENTED ON OUTPUT
*DISPATCH ON DEVICE TYPE
}'DGOTO Q + Z + 1, M _ VR;
}'DGOTO DOD3;
DOD3:}"HFETCH LDVTE, Q _ MASK(COP), DGOTO RTSS4;
***}$HFETCH LDVTE MRG DISP(COP), Q _ MASK(COP), DGOTO RTSS4;
}'M _ M AND NOT Q ! Z AND Q, CALL DOD;
DOD4:}"GOTO DOD9 ON M # 0, VR _ MASK(COP);}"* IF SNULL OUTPUT ALL 1S
*0 MEANS NOT OUTPUT TURN OFF LINE,}"(ALL OTHER CONT CH. AS SNULL)
}'CALL WKOL, Z _ 0;}'*TURN OFF LINE, NO MORE CHARACTERS FOR IT
}'GOTO RTSS4;
*M HAS CHARACTER SHIFTED LEFT ONE
BV3:}#CALL ABORT;}-*OUTPUT TO DEVICE 0 (DOD)
}'Z _ M MRG MASK(COP37); *MODEL 37
}'Z _ M MRG MASK(COP35); *MODEL 35
}'Z _ M MRG MASK(COP41); *IBM 2741
*
*NOTE THAT SNULL IS WRONG

*
*ECHO:}"ECHO CHARACTER TO OUTPUT LINE ALSO
*
*THE NAME ECHO IS SOMEWHAT OF A MISNOMER. ECHO IS CALLED BY
* A SUBROUTINE THAT HAS REASON TO BELIEVE
*THAT THE CHARACTER IN CHAR SHOULD BE OUTPUT TO SOME LINE OTHER
*THE OBVIOUS ONE, EITHER AS AN ECHOED CHARACTER OR AS A LINKED
* CHARACTER (OR BOTH).
*ECHO WILL SEND CHARACTERS TO THE APPROPRIATE LINES,
*IT IS A LITTLE TRICKY BECAUSE IT MUST SAVE AND RESTORE
*THE STATE OF THE LINE BEING WRITTEN
*ECHO SAVES AND RESTORES WCNT, WWORD, WCP AND BFLAG
*
*
*
*ECHO SHOULD:
*}%1) ECHO TO THE OUTPUT LINE IF THE LINE IS AN INPUT LINE
*}&2) LINK TO AN OUTPUT LINE
*
*}"ARGUMENTS:
*}&CHAR: CHARACTER TO BE ECHOED
*
*}"VALUE: NONE
*
*}"LEVEL:}#2
*
*SUBROUNTINES CALLED:}"WCH1,GLE
*
ECHO:}"M _ LINE;
}'XLINK _ M, Z_OS, GOTO SH2;
*
*PUSH DOWN WWORD, WCNT, WCP, BFLAG
}'M _ WWORD;
}'SWORD _ M, M _ WCNT;
}'SWCNT _ M, M _ WCP;
}'SWCP _ M;
}'M _ BFLAG;
}'SBFLAG _ M;
}'CALL BLAKE ON BFLAG<0;
}(M_WD1, Q_MASK(ES);
}'GOTO ECHO2 ON M AND Q =0;
}'GOTO ECHO2 IF ODD, Q _ LINE;
*ECHO CHARACTER
}'SETA,}"CALL GLE, M_LINE MRG 1;
*
*THE FOLLOWING CODE IS A HORRIBLE KLUGE WHICH HANDELS THE PROBLEM OF
*ECHOING (OR NOT ECHOING OF CHISC IS 4B7) SHIFT1 CONTROL CHARACTER
*IF LCWS1 = 1 THEN A SHIFT1 IS ECHOED BEFORE CHAR, ALSO LCWS1 IS
*KLUGILY USED AS STORAGE FOR THE CHARACTER
}'GOTO ECHO2 ON M _ LCWS1<0;
}'GOTO OKTE ON M = 0, M _ CHAR;
}'LCWS1 _ M;
}'CHAR _ SHIFT1;
}'CALL WCH1 ON CHISC >=0;
}'M _ LCWS1;
}'CHAR _ M;
}'ALL;}$*NOP
OKTE:}#CALL WCH1 ON CHISC >=0;}(*DONT ECHO CONTROL CHARS
}'CALL BLAKE ON BFLAG<0;
}'CALL WKOL ON CHISC >= 0, Z _ -1;}#*WAKEUP OUTPUT LINE
*NOW OUTPUT TO LINKED LINE IF LNKBIT IS ON
ECHO2:}%M_WD1, Q_MASK(LNKBIT);
}(GOTO ECHOR ON M AND Q=0, Q _ MASK(LQNK);
*YES LINK, GET THE LINE NUMBER
}(HFETCH MTAE MRG DISP(LQNK);
}(M_STUFF(LQNK), RESETA, CALL GLE;
}'GOTO ECHOR ON M _ LCWS1<0;
}'GOTO OKTR ON M = 0, M _ CHAR;
}'LCWS1 _ M;
}'CHAR _ SHIFT1;
}'CALL WCH1 ON CHISC >=0;
}'M _ LCWS1;
}'CHAR _ M;
}'LCWS1 _ 0;
OKTR:}"CALL WCH1 ON CHISC >=0;
}'CALL WKOL ON CHISC >=0, Z_-1;
*
ECHOR:}%M _ XLINK, RESETA, CALL GLE;
*POP WCNT, WCP, WWORD, BFLAG
}'WCNT _ SWCNT;
}'WCP _ SWCP;
}'M _ SWORD;
}'WWORD _ M, CALL BLAKE;
}'M _ SBFLAG;
}(GOTO RTSS2, BFLAG _ M;
*

*
*FLB: FIND LEADING BIT
*
*LEADING BIT FOUND AND LBIT IS SET TO A MASK WITH THE LEAD BIT ONLY ON.
*
* ARGUMENTS:
*}'M: BITS (AT LEAST ONE BIT MUST BE ON)
*
*VALUE:
*
*SIDE EFFECTS:
*}&LBIT: WORD WITH A BIT SET FOR INPUT TTY
*}&BWORD: OLD BWORD AND NOT LBIT
*}&LLINE: LOCAL LINE NUMBER SETUP
*}&LDVTE: SETUP
*
*LEVEL: -
*
*SUBROUTINES CALLED: NONE
*
FLB:}#R0_-1, Q}"_ 17B;
*FIND FIRST GROUP OF 4 BITS THAT HAS A BIT SET
CYP:}#Q _ Q LCY 20, R0 _ R0 + 1;
CYQ:}#GOTO CYP ON M AND Q = 0;
}'Z _ Q LCY 3;
***}$LBIT _ Q _ Q AND Z, Z _ R0, R0 _ 0;
}'LBIT _ Q _ Q AND Z, Z _ R0, .LR0;
*FIND BIT OF THE GROUP THAT IS SET
CYR:}#GOTO FIB3 ON M AND Q # 0;
}'DGOTO CYR, Q _ Q LCL 23;
}'LBIT _ Q _ Q LCH 23, R0 _ R0 + 1;
FIB3:}"BWORD _ M AND NOT Q;
}'M _ Z, Z _ R0;
}'M _ M LCY 2;
}'LLINE _ M _ M + Z;
}'Q _ M LCY 1, Z _ LDVTA, DRETURN;
}'HFETCH LDVTE _ Q + Z, CALL BLAKE;
*

*
*GAB: GET A BUFFER
*
*GAB IS CALLED TO GET A NEW BUFFER FOR WRITE CHARACTER. IT WILL ALWAYS 
*SUCCEED (OR ABORT.
*
* ARGUMENTS:
*}'WCP IS SETUP
*
*VALUE: NONE
*
*LEVEL: 0
*
*SUBROUTINES CALLED: NONE
*
GAB:}#CALL ABORT ON M_AVB<0, Q _ 8;}&*BUFFERS SCREWED UP
}'Z _ WCP, AVB _ -1;
}'R0 _ Z - Q, Q _ BUF0;
***}$WCP_M + Q + 1 MRG STFLAG;
}'WCP_M + Q MRG STFLAG+1;
}'VR _ M + Q, Q _ LINE;
}'Z _ Q LCY 16, Q _ MASK(ZLIN);
}'M _ M AND NOT Q + Z AND Q, STORE;
}'BFLAG _ 4B7, DRETURN;
}'M _ Z AND Q, STORE VR;
*

*
*GETFIELD: LOAD FIELD FROM LINE TABLE
*
*THIS WILL GET A FIELD FROM EITHER OF THELINE TABLES
*
* ARGUMENTS:
*}'CARG1: FIELD DISCRIPTOR
*VALUE: FIELD
*
*SUBROUTINES CALLED GFD
*
*LEVEL: TOP
*
GETFIELD:}"CALL GFD;
}'M _ M AND Q LCH Z, DGOTO CPUFIN;
}'M _ M LCL Z;
*

*
*GETREG: STORE REGISTER
*
* ARGUMENTS:
*}'CARG1: SAME AS FOR LDRG
*
*VALUE(IN CPUIT): REGISTERS VAALUE
*
*LEVEL: -
*
*SIDE EFFECTS: NONE
*
*SUBROUTINES CALLED: NONE
*
GETREG: FETCH DISP(CARG1);
}'Z _ M;
}'M _ SKZ, GOTO CPUFIN;

*GFD: GET FIELD DESCRIPTOR
*
*GFD WILL FETCH FROM CARG1 A FIELD DESCRIPTOR AND HAVE SEVERAL
*INTERESTING QUANTITIES SET UP ON RETURN
*
* ARGUMENTS: CARG1: FIELD DESCRIPTOR
*
*VALUE:
*}'M: CONTENTS OF WORD POINTED TO BY FIELD DESCRIPTOR
*}'R0: LOCATION POINTED TO BY FIELD DISCRIPTOR (IN LINE TABLE)
*}'Q: MASK FOR THE FIELD
*}'Z: CYCLE SET UP FOR 'STUFF'
*
*LEVEL: -
*
*NMR: 1
*
*SUBROUTINES CALLED: NONE
*
GFD:}#Z_OS,}"Q _ MASK(CXBIT), GOTO SH3;
}'FETCH DISP(CARG1), Z _ MTAE;
}'GOTO GFD1 ON M AND Q = 0, Q _ MASK(SFDDISP);
}'Z _ MTCE;
GFD1:}"R0 _ M AND Q}"+ Z, Q _ MASK(FDSZ);
}'Z _ STUFF(FDSZ), Q _ 1, CALL QQCYZ;
}'GOTO GFD2 ON VR _ Q - 1#0, Q _ MASK(FDFB);
}'VR _ -1;
GFD2:}"Q _ M AND Q LCL LDCY(FDFB);
}'Q _ Q LCH LDCY(FDFB);
}'Z _}"Z+Q, M _ 24;
}'Z _ M - Z, Q _ VR, CALL QQCYZ;
}'FETCH, Z _ M - Z, GOTO RTSS1;
*

*
*GLBTE: GET LOCAL BIT TABLE ENTRY
*
*GLBTE SETS UP LBTBE AND BTIME AND LEAVES BSNO INCREMENTED IN M
*
* ARGUMENTS:
*}'M: DEVICE TYPE
*
*VALUE: M: BIT SLICE NUMBER(0-6)
*}&R0: LOCATION WHERE UPDATED BSNO SHOULD BE STORED
*
*SIDE EFFECTS: LBTBE AND BTIME SETUP
*
*LEVEL: -
*
*NMR: 1
*
*SUBROUTINES CALLED: NONE
*
*KNOW DOES NOT GRONK VR
*
GLBTE: M _ M - 1;
}'Q _ M LCY 4, Z _ LBTBA;
***}$Z _ LBTBE _ Q + Z, FETCH Q + Z + DISP(BSNO);
}'Z _ LBTBE _ Q + Z, FETCH DISP(BSNO), .TXW;
}'GOTO GLB1 ON Q _ M _ M - 1 >= 0;
}'Q _ M _ 6;
GLB1:}"BTIME _ M + Q OR Z, RETURN;}%*LBTBE + 2* BSNO
*

*
*GLE: GENERATE LINE ENTRY
*
* ARGUMENTS:
*}'M: LINE
*}'A: SET IF ABCPU SHOULD BE CALLED IF BAD REQUEST
*
*VALUE: NONE
*
*LEVEL: -
*
*SUBROUTINES CALLED: NONE
*
*SIDE EFFECTS: MTCE, MTAE, WD1, AND WD2 ARE SETUP
*
*NMR: 2
*
*NOTE THAT VR IS NOT DESTROYED
*
GLE:}#Q _ LINE _ M, M _ 1+4B7;
}'Z _ XLINE;
}'GOTO BADGL ON Z - Q<0;}**ILLEGAL LINE NUMBER
}'Z _ Q AND NOT M LCY 1, M _ MTAA;
}'HFETCH MTAE _ M + Z;
}'Z _ Q LCY 1;
}'Z _ Q + Z, Q _ MTCA;
}'WD1 _ M, FETCH R0+1;
}'MTCE _ Z + Q, DRETURN;
}'WD2 _ M;
BADGL:}$CALL ABORT IF ARESET;
}'CALL ABCPU;
*

*
*GMTL: GET MAIN TABLE LINE NUMBER
*
*GMTL WILL SET UP LINE AS EITHER AN INPUT OR OUTPUT LINE
*KNOWING THE LOCAL LINE IS SET UP
*
* ARGUMENTS:
*}'Z: 0 IF INPUTLINE, 1 IF OUTPUT LINE
*}'ASSUMES LDVTE SETUP
*
*VALUE: NONE
*
*LEVEL: 0
*
*NMR: 1
*
*SUBROUTINES CALLED: GLE
*
GMTL:}"Q_1, FETCH LDVTE MRG DISP(CLINE);
*THE GOTO PART OF THIS NEXT INSTRUCTION IS FOR LATER USE (ADVISING?)
*REFER TO PAGE 61 OF CHIO LOG.}"FOR NOW BITS 4 AND 8 ARE CUT TO KEEP
*THE GOTO FROM HAPPENING AND TO KEEP THE ROMPARITY OK
}'GOTO 1641B ON VR _ Q AND Z = 0, Q _ 7777B;
}'M _ STUFF(CLINE), M _ VR, GOTO GLE;

*
*GNR: GET NEXT REQUEST
*
*GNR FINDS THE HIGHEST PRIORITY REQUEST AND SERVICES IT
*IT WILL DO ONE OF THE FOLLOWING:
*}&1) GOTO CPURQ TO SERVICE A CPU REQUEST
*}&2) GOTO B2400 TO SERVICE A 2400 BAUD LINE REQUEST
*}&3) DISPATCH ON A SUBROUTINE IN TIMTBL TO PERFORM A PERIODIC FUNCTION
*
*IF IT DISPATCHES ON A FUNCTION THROUGH 
*TIMTBL THE FUNCTION MAY EITHER RETURN OR GOTO GNRFIN;
*
* ARGUMENTS: NONE
*
*VALUE: NONE
*
*SIDE EFFECTS: ALL
*
*LEVEL: TOP
*
*SUBROUTINES CALLED: CPUREQ, CLOCK SUBROUTINES.
*
ONYCPU:}#DGOTO CPURQ;
}'GOTO GNR IF NOREQ;
* BLAKE WILL ENSURE THAT FREE BUFFERS ARE SET UP OK
GNR:}#CALL BLAKE ON BFLAG < 0, TOCPU;
*IF CPUFLAG IS ON (NEGATIVE) ONLY SERVICE CPU REQUESTS
}'GOTO ONYCPU ON CPUFLAG < 0, Q _ 76B6;}#*SFTIM
}'Z _ RDCKL, ALERT, M _ NCI;
}'PIN, Z _ E2;
}'M _ Z AND NOT Q - M AND NOT Q, Q _ 1B6;}$*STM
}'GOTO SCI ON BL _ M = 0;
}'GOTO 1602B;
}'DGOTO CPURQ;
}'GOTO *+1 IF NOREQ;
}'CALL GOCTP;
}'GOTO GNR, SETBAS;
SCI:}#M _ NCI, Q _ MASK(FTOSUB), DGOTO GNRFIN;
}'Q _ STUFF(FTOSUB), Z _ TIMTBL, CALL GOQPZ;
*NOTE CKFXP SUBROUTINE NUMBER IS ZERO, AND THE SUBROUTINE NUMBER FOR 
*THE BIT SCANNING SUBROUTINES IS THE SUBROUTINE NUMBER
TIMTBL:}#GOTO CKFXP, R0 _ -@LCI+@NCI-1;
}'ORG TIMTBL+M37T;
}'GOTO BSCN, Z _ 60B;}%*FOR 30 CHARS/SEC
}'ORG TIMTBL+M35T;
}'GOTO BSCN, Z _ N35I;
}'ORG TIMTBL+M2741T;
}'GOTO BSCN, Z _ N2741;
}'ORG TIMTBL+4;
*SUBROUTINE SUBNUL IS SUBROUTINE NUMBER 4 IT DOES NOTHING
}'NCI _ M + 1 MRG MASK(FTOTIM), GOTO GNRFIN;
}'GOTO GPRUPDATE, Z _ XLINE;
}'GOTO RTUPDATE, Q _ UPAM;
}'ALL;}$*SPARE
}'CALL ABORT;},*SPARE

*
*GNRFIN: CONTROL GOES HERE FROM ANY OF THE CLOCK DRIVEN FUNCTIONS
*
*GNRFIN MUST SORT THE CLOCK QUEUE AND GO TO MAIN LOOP
*
* ARGUMENTS: NCI: TIME THE FUNCTION SPECIFIED BY NCI WANTS TO BE CALLED
*
*VALUE: NONE
*
*SIDE EFFECTS: NONE
*
*LEVEL: TOP
*
*SUBROUTINES CALLED: NONE
*
***}#Z _ VR _ @NCI, M _ NCI;
GNRFIN:}$Z _ VR _ 32, M _ NCI;
***}$R0 _ @NCI-@LCI;
}'R0 _ -5;
*VR AND Z HAVE NUMBER OF LOWER NUMBERED SCRATCH PAD REG, M HAS ITS CONTENTS
SCIL:}"Z _ Z + 1, Q _ NMASK(FTOTIM);
}'M _ SKZ, Z _ M;
}'DGOTO GNRR ON M AND NOT Q - Z AND NOT Q>=0;
}'VR _ Q _ Z, Z _ VR;
*Z HAS LOWER NUMBER REGISTER SCRATCH PAD ADDRESS, VR HAS OLD CONTENTS
*OF SCRATCH PAD Z.
*PUT CONTENTS OF SCRATCH PAD Z+1 IN SCRATCH PAD Z, AND PRETEND
*TO PUT CONTENTS OF SCRATCH PAD Z INTO SCRATCH PAD Z+1.
}'SKZ _ M, DGOTO SCIL ON R0_R0+1<0;
}'M _ VR, VR _ Z _ Z + 1;
*PUT CONTENTS OF SCRATCH PAD Z IN SCRATCH PAD Z+1(WHICH WE ONLY 
*PRETENDED TO DO).
GNRR:}"SKZ _ Q, GOTO GNR;
*

*
*GPR: GUARANTEED POOR RESPONSE
*
*WHEN GNR HAS NOTHING ELSE TO DO
*GPR IS CALLED TO DECREMENT THE 
* AWT COUNT IN THE LINE TABLE AND IT IT IS ZERO WAKEUP THE OUTPUT DEVICE.
*GPR WILL FIND ITSELF IN ONE OF THREE STATES:
*
*}'1) NORMAL: DECREMENT AWT COUNT(IF NOT 0) ON ONE LINE
*}'2) FINISHED: LAST LINE SERVICED WAS LAST LINE, SET NEXT MIN TIME;
*}'3) WAIT: WAIT UNTIL PNEXT IS EQUAL TO THE CURRENT TIME BEFORE 
*}+GOING TO STATE 1
*
* ARGUMENTS: M: CURRENT TIME
*
*VALUE: 0 WAS IN STATE ONE
*
*SIDE EFFECTS:}"NONE
*
*LEVEL: -
*
*SUBROUTINES CALLED: WKOL
*
GPR:}#Z _ Q _ PLINE, GOTO GPR1 IF ODD, SETA;
}'M _ XLINE, Q _ Q LCY 1;
}'GOTO GPREND ON Z - M>0, M _ MTAA, RESETA;
}'FETCH M + Q MRG DISP(AWT);
GPR1:}"PLINE _ Z + 1, Q _ MASK(AWT), RETURN IF ASET;
}'RETURN ON M AND Q=0, Q _ ONE(AWT), SETA;
}'GOTO 1604B, M _ M - Q, STORE, Z _ -1;
*NOTHING TO DO SO BUMP IDLE COUNT IF A RESET
GPREND:}%R0 _ IDLCNT, RETURN IF ASET;
}'M _ M + 1,}"RETURN;
*

*
*GPRUPDATE: CALLED EACH 1/2 SECOND TO REINITIALIZE PLINE
*
* ARGUMENTS:
*}'Z: XLINE (SET UP BY GNR)
*}'M: TIME OF INTERRUPT
*
*VALUE: NONE
*
*LEVEL: -
*SUBROUTINES CALLED: NONE
*
GPRUPDATE:}$Z _ PLINE, Q _ SEC1H;
}'PLINE _ 0;
}'NCI _ M + Q;
}'GOTO GNRFIN ON Z = 0, FETCH PROB;
}'M _ M + 1, STORE, GOTO GNRFIN;
*

*
*GRP: GET READ POINTER
*
*GRP FINDS MCTA MOD 2 =1 DESIRABLE
*
* ARGUMENTS: NONE
*
*IMPLICIT: ASSUMES THAT GLE HAS BEEN CALLED
*
*VALUE: NONE
*
*SIDE EFFECTS: RWORD, RCP, RTCE1, RCPEND, RCNT AND RBUF ARE SET UP. PRP WORRYS ABOUT CCNT
*
*LEVEL: -
*
*SUBROUTINES CALLED: IRCH
*
*NMR: 2
*
***}$HFETCH MTCE+DISP(RCPF);
GRP:}#HFETCH MTCE, Q _}"NMASK(RCPF);
}'RTCE1 _ M AND Q, R0 _ R0 + 1;
*KNOW RTCE1 HAS RCP PART =0
}'GOTO GRP2 ON M AND NOT Q=0, Z _ BUF0;
}'VR _ M AND NOT Q + Z, FETCH;
}'Q _ M AND NOT Q + Z, Z _ LNKB, DGOTO IRCH;
}'M _ VR;
*NO CHARACTERS IN LINE READ FROM A NULL CHARACTER SOURCE
GRP2:}"M _ Q _}"BUF0 MRG ZRB, DGOTO IRCH;}"
}'Z _ ABORT;}6*LINK FOR NULL CHARACTER SOURCE
*

*
*GWP: GET WRITE POINTER
*
*THIS SUBROUTINE SETS UP AN INPUT LINE SO THAT WCH WHEN CALLED WILL
*STORE CHARACTERS INTO THAT LINE
*
* ARGUMENTS: NONE
* IMPLICIT: ASSUMES THAT GLE HAS BEEN CALLED
*
*VALUE: NONE
*
*SIDE EFFECTS: WWORD, WCP, WTCE2, , AND WBUF ARE SET UP.}"PWP WORRIES ABOUT CCNT
*
*
*SUBROUTINES CALLED: IWCH
*
*KNOW ABCNT, IBCNT AND WCP ARE SINGLE CYCLE FIELDS AND WCP AND ABCNT ARE
* ALL OF ONE WORD.
*LEVEL: -
*
*NMR: 1(MAX 5)
*
GWP:}#Z _ MTCE, Q _ NMASK(WCPF);
}'FETCH Z + DISP(WCPF), Z _ BUF0;
*KNOW WCTE2 HAS ABCNT ON LEFT, AND 0 ON RIGHT
}'WTCE2 _ M AND Q, DGOTO IWCH;
}'Q _ M AND NOT Q + Z, Z _ GAB, GOTO * + 1 IF LB=0;
*NO CHARACTERS IN LINE, GET BUFFER , AND SET READ POINTER
GWPZ: CALL ABORT ON Z _ AVB < 0;}$*NO BUFFER AVAILABLE (GWP)
}'M _ LINE;
}'AVB _ -1, Q _ 377B;
}'M _ M AND Q LCY 16, Q _ BUF0 MRG STFLAG;
}'STORE VR _ Z +Q, Q _ MTCE;
}'FETCH Q + DISP(RCPF), Q _ NMASK(RCPF);
}'BFLAG_4B7;
*STORE READ POINTER
}'M _ M AND Q + Z AND NOT Q + 1, Z _ GAB, STORE, DGOTO IWCH;
*STORE ZERO IN FIRST WORD OF BUFFER (ZEROTH WORD IS LINK)
}'M _ 0, STORE Q _ VR+1;
*

}'END;
*

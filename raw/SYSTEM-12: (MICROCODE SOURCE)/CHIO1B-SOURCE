*IBF: INPUT BIT FOUND
*THIS IS CALLED TO PROCESS AN INPUT ON BIT ON AN INPUT LINE THAT IS
*NOT RECEIVING A CHARACTER AT THE TIME. IT ASSUMES IT IS THE LEADING 
*ONE BIT THAT HEROLDS THE START OF A CHARACTER
*IBF TURNS ON THE INPUT BIT FOR THE TTY FOR (THIS BIT SLICE + 3) MOD 7
*IT ALSO TURNS OFF BIT IN NCIP
*
* ARGUMENTS:
*}'M: WORD CONTAINING CIP
*}'R0: ADDRESS OF CIP
*
*VALUE: NONE
*
*SIDE EFFECTS: BIT TABLE UPDATED TO REFLECT INCOMING BIT
*
*
}'ORG 637B;
IBF:}#M _ M MRG -20000B, STORE;}%*CIPT _ -1
}'Z _ BTIME, Q _ 8;
}'GOTO IBF1 ON Z AND Q#0, M _ 10B;
}'M _ -6;
*SET BIT AT 3 BIT SLICES FURTHER ON, THIS IS DONE BY ADDING
*16 MOD 16 THE THE POINTER INTO THE BIT TABLE WHICH IS
*DONE BY ADDING 8 OR SUBTRACTING 8
IBF1:}"HFETCH Z - M, Q _ LBIT;
}'M _ Q OR M, STORE;
}'HFETCH LBTBE MRG DISP(NCIP), DRETURN;
}'M _ M AND NOT Q, STORE;
*

*
*INLOGIC: INPUT CHARACTER LOGIC
*INLOGIC DOES THE FOLLOWING
*
*}'1) WRITES CHARACTER IN THE INPUT LINE
*}'2) DECIDES IF PROCESS SHOULD BE AWAKENED
*}'3) DECIDES IF CHARACTER SHOULD BE ECHOED
*}'4) IF CHARACTER SHOULD BE ECHOED IT DOES THIS FOR LINKED LINE
*}'5) IF PROCESS IS AWAKENED AND AWT =0 SET AWT TO XWT (BY WAKEUP)
*}'6) IF CHARACTER IS A BREAK CHARACTER ECHO IT IF EBC IS OFF
*}'7) IF A BREAK CHARACTER, SET CLE BIT
*}'8) IF CHAR IS A CARRAIGE RETURN AND LFK BIT IS ON INSERT LINE FEED
*
*IF THE CHARACTER IS > 400B IT WILL WRITE A SHIFT1 AND THEN THE 
*CHARACTER MOD 400B IN THE LINPUT LINE
*
* ARGUMENTS:
*}'M: CHAR
*
*VALUE: NONE
*
*LEVEL: 3
*
*SUBROUTINES CALLED: WCH1, GLE, WAKEUP, WKCQ,ECHO;
*
*SIDEEFFECTS: NONE
*
INLOGIC:}#Z _ OS,}"Q _ MASK(RCHAR), GOTO SH4;
INL1:}"CHARI _ M, Q _ 377B;
}'GOTO CHRS2 ON M AND NOT Q # 0;
INLL:}"CHAR _ M AND Q, CALL WCH1;
*Z <= 0 IF CNT > WKCNT
}'DGOTO WCIL2 IF Z<0;
}'CALL WKCQ, M _ CHARI;
*Z HAS WAKEUP/CHARACTER TYPE
WCIL0:}$M _ WD1, Q _ MASK(CLE);
*ECHO CHARACTER IF CLE IS OFF AND CHARACTER NOT, BREAK;
*IF CHARACTER QUIT OR ESCAPE NOT ECHO IT, IF BREAK, ECHO
*ACCORDING TO EBC, AND SET CLE
}'GOTO NOECH ON M AND Q # 0, Q _ WKB;
}'GOTO DOECH ON Z -Q < 0, Q _MASK(CLE);
*CHARACTER IS BREAK TURN ON CLE
}'WD1 _ M _ M OR Q;
}'STORE MTAE MRG DISP(CLE), Q _ MASK(EBC);
}'GOTO NOECH ON M AND Q =0;
*WAKEUP PROCESS AND ECHO CHARACTER
DOECH:}$CALL WAKEUP ON Z # 0;
}'M _ CHARI, Q _ MASK(RCHAR);
}'CHAR _ M AND Q, CALL ECHO;
}'GOTO NOECC;
*JUST WAKEUP PROCESS
NOECH:}$CALL WAKEUP ON Z # 0;
*IF CHARACTER IS A CARRAIGE RETURN AND LFK IS ON}"INSERT LINE FEED
*(MAKES SENSE FOR MODEL 35 ONLY)
NOECC:}$M _ CHARI, Q _ CRET;
}'GOTO RTSS3 ON M - Q # 0, Q _ MASK(LFK);
}'FETCH MTAE MRG DISP(LFK);
}'GOTO RTSS3 ON M AND Q =0, Q _ 377B;
}'CHAR _ M _ LINEFD, GOTO INL1;
CHRS2:}$CHAR _ SHIFT1, CALL WCH1;
}'M _ CHARI, Q _ MASK(RCHAR), GOTO INLL;
*
WCIL2:}$GOTO WCIL0 ON Z-WKI>=0;
}'Z _ WKI, GOTO WCIL0;
*

*
*INL2: CONVERT FROM ABSOLUTE SET (0-377B)}"AND CALL INLOGIC
*
*INL2 CONVERT CHARS IN THE RANGE FRM 0 TO 37 TO
*CHARACTERS IN THE RANGE 440 TO 447 WO INLOGIC WILL PRINT THEM 
*AS SHIFT1 THEN 40+ CHARACTER, SO CHAR WILL NOT BE CONFUSEED
*WITH A CONTROL CHARACTER
* ARGUMENTS:
*}'M: CHAR
*
*VALUE: NONE
*
*LEVEL: 3
*
*SUBROUTINES CALLED: INLOGIC(GOTO)
*
INL2:}$Q _ 37B;
}'GOTO INLOGIC ON M AND NOT Q # 0, Q _ MASK(RCHAR);
}'M _ M AND Q MRG SHIFT1*400B+40B, GOTO INLOGIC;
*

*
*IRCH: INITIALIZE RCH
*
*MUST BE CALLED BEFORE A SERIES OF RCHS
*
* ARGUMENTS:
*}'M: READ POINTER;
*}'Q: END READ POINTER;
*}'Z: LINK TO NEXT BUFFER SUBROUTINE
*
*VALUE: NONE
*
*SIDE EFFECTS: RWORD, RCP, RBUF, RCPEND ARE SETUP
*
*LEVEL: -
*
*SUBROUTINES CALLED: NONE
*
*
IRCH:}%FETCH RCP _ M;
}'RCPEND _ Q;
}(RBUF _ Z, DRETURN;
}(RWORD _ M;
*

*
*IWCH: INITIALIZE WRITE CHARACTER SUBROUTINE
*
*THIS MUST BE CALLED BEFORE A SERIES OF WCHS ARE CALLED.
*
* ARGUMENTS:
*}'Q: WRITE CHARACTER POINTER.
*}'Z: LOCATION OF SUBROUTINE TO CALL TO LINK TO NEXT BUFFER
*
*VALUE: NONE
*
*LEVEL: -
*
*SIDE EFFECTS: WBUF, WCP, AND WWORD ARE SETUP, WCNT _ 0
*
*SUBROUTINES CALLED: NONE
*
IWCH:}$FETCH WCP _ Q;
}'WBUF _ Z, WCNT _ 0, DRETURN;
}'WWORD _ M;
*

*
*LNKB: LINK TO NEXT BUFFER
*
*LNK JUMPS TO THE NEXT BUFFER. 
*LNKB IS CALLED ONLY FROM RCH
*RCND CAN PREVENT THE BUFFER FROM BEING FREED BY ZEROING PRB
*
* ARGUMENTS:
*}'RCP: POINTS 1 PAST OLD BUFFER
*
*VALUE: NONE
*
*SIDE EFFECTS: RCP UPDATED
*
*LEVEL: -
*
*SUBROUTINES CALLED: NONE
*
LNKB:}$M _ RCP, BFLAG _ 4B7;
}'Z _ 8;
}'M_R0_}"M - Z, Z _ BUF0;
}'PRB_M-Z, FETCH;
}'Q_LINE;
}'Z _ Q LCY 16, Q _ MASK(ZLIN);
}'CALL ABORT ON M AND Q - Z AND Q # 0, Z _ BUF0;}"*(LNKB) ILLEGAL LINE NUMBER IN BUFFER 
LNKB2:}$RCP _ M AND NOT Q + Z MRG STFLAG, RETURN;
*

*
*MBLK: MOVE BLOCK
*
*THIS IS THE CODE THAT MOVES A BLOCK OF DATA FOR THE CPU
*
* ARGUMENTS:
*}'CARG1: SOURCE
*}'CARG2: DESTINATION
*}'CARG3: NUMBER OF WORDS
*
*VALUE: NONE
*
*LEVEL: -
*
*SUBROUTINES CALLED: NONE
*
MBLK:}$FETCH DISP(CARG1);
}'Q _ M-1, FETCH R0+1;
}'Z _ M-1, FETCH R0+1;
}'GOTO CPUFIN ON VR_0-M=0;
LOLP:}$FETCH Q _ Q+1;
}'STORE Z _ Z+1, DGOTO LOLP;
}'GOTO CPUFIN ON VR _ VR + 1 >=0;
*

*
*OUTLOGIC: OUTPUT LOGIC FOR CHARACTER
*
*OUTLOGIC HANDLES THE LOGIC ASSOCIATED WITH GETTING AN OUTPUT CHARACTER 
*IN THE LINE. IT MUST:
*
*}'1) GET THE OUTPUT CHARACTER
*}'2) IF OUTPUT LINE IS EMPTY IT MUST TURN OFF DE IF WIC IS SET
*}'3) IF THE OUTPUT CHARACTER COUNT IS LESS THEN WKCNT IT SHOULD 
*}+AWAKEN THE PROCESS FOR OUTPUT
*
* ARGUMENTS: EXPECTS GMTL TO BE CALLED
*
*VALUE: M: CHARACTER READ
*}&Q: 37B USEFUL FOR OUTL2)
*
*LEVEL: 2
*
*SUBROUTINES CALLED: WAKEUP,RCH1
*
*NMR: O(MAX 1)
*
OUTLOGIC:}$Z _ OS;
}'SVR2 _ Z, CALL RCH1;
}'CALL WAKEUP IF ASET, Z _ WKO;
}'M _ CHAR, Q _ MASK(WIC);
}'M, GOTO OUTLX IF LB#0, Z _ WD1;
}'GOTO OUTLX ON Z AND Q=0, Q _ MASK(DECLE);
}'WD1 _ M _ Z AND NOT Q;
}'STORE MTAE MRG DISP(CLE);
OUTLX:}$M _ CHAR, Q _ 37B, GOTO RTSS2;
*

*
*OUTL2: OUTLOGIC ABSOLUTE
*
*OUTL2 DELIVERS A CHARACTER FOR THE OUTPUT LINE WITH THE
*SHIFT 1 REMOVED UNLESS THERE ISNO SUCH CHARACTER.
*IN TIS CASE IT DELIVERS THE CHARACTER IN M
*AND SETS A AS A SIGNAL
*IF THERE ARE NO CHARACTERS LEFT IN THE LINE
*IT CALLS WKOL TO TURN IT OFF
* ARGUMENTS: NONE
*
*VALUE: M: CHARACTER READ (0-377, NO CONTROL CHARACTERS) IF A SET
*}*OTHERWISE THE CONTROL CHARACTER (SNULL,FLDCHAR, OR 0 IF NO CHARS)
*}'A: SET IF NO CHARACTER TO DELIVER
*
**LEVEL:3
*SUBROUTINES CALLED: OUTLOGIC
*
OUTL2:}%Z _ OS;
OUTLL:}$SVR3 _ Z, CALL OUTLOGIC;
}'GOTO OTRN ON M = 0, Q _ 40B, RESETA;
}'GOTO RTSS3 ON M-Q>=0, Q _ SHIFT1;
}'SETA, GOTO RTSS3}"ON M - Q # 0;
*SHIFT1 RECEIVED
}'CALL OUTLOGIC;
}'CHAR _ M _ M AND Q, GOTO RTSS3, RESETA;
*IF NO MORE CHARS FOR LINE TURN OFF
OTRN:}$CALL WKOL, Z _ 0;
}'GOTO RTSS3, SETA;
*

*
*
*PRP: PUT READ}"POINTER
*
*IF BFLAG < 0 A BUFFER HAS BEEN FREED
*NIQ OR NOQ IS RESET IF CCNT >WCNT
*
* ARGUMENTS: NONE
*
*VALUE: A IS SET ON CCNT <= WCNT, OTHERWISE RESET
*
*SIDE EFFECTS: NONE
*
*LEVEL: -
*
*NMR: 4
*
*SUBROUTINES CALLED: CRCH (BY GOTO)
*
PRP:}#GOTO PRP4 ON M _ RCP >=0, Q _ STFLAG;
}'RCP _ M _ M AND NOT Q, DGOTO PRP2 ON BFLAG >=0;
* DECREASE BUFFER COUNT BY 1
}'Z _ MTCE, Q _ MASK(ABCNT);
}'FETCH VR _ Z + DISP(ABCNT), Z _ RTCE1;
}'DGOTO PRP1 ON M AND Q - Z AND Q<=0, Q _ 1;
}'Z _ M, M _ LINE;
*UPDATE EXTRA BUFFER COUNT (XIB / XOB)
}'FETCH}"M AND Q MRG XIB;
}'M _ M - 1, STORE;
PRP1:}$M _ ONE(ABCNT), Q _ RCPEND;
}'M _ Z-M,}"STORE VR;
}'GOTO PRP2 ON Q>=0, M _ RCP;
*
*IF RCPEND CHANGED ALL CHARS READ, LINE EMPTY
}'M _ RCP _ BUF0;
}'STORE VR, M _ 0, GOTO PRP3;
* BUFFER COUNT IS CORRECT AT THIS POINT
*KNOW THAT RTCE HAS RCP PART = 0
*M HAS RCP
PRP2:}$Z _ BUF0;
}'M _ M - Z;
PRP3:}$Z _ RTCE1, Q _ NMASK(RCPF);
***}#STORE Z _ MTCE + DISP(RCPF), M _ M AND NOT Q + Z AND Q;
}'STORE Z _ MTCE, M _ M AND NOT Q + Z AND Q;
*READ POINTER HAS BEEN UPDATED AT THIS POINT.
*UPDATE CHARACTER COUNT
PRP4:}$Z _ MTCE, Q _ DISP(CCNT);
}'FETCH Q + Z, Z _ WCNT;
}'Z _ M - Z, Q _ MASK(CCNT);
}'Z _ M _ M AND NOT Q + Z AND Q, STORE;
*SETA AND CLEAR NIQ(NOQ) IF CCNT <= WAKEUP COUNT
*KNOW MASK(CCNT) = MASK(WKCNT)
}'Q _ M AND NOT Q LCY 12, .TAX, M _ WD2;
*Z HAS MTCE(2) WHICH HAS WKCNT IN THE LEFT HAND SIDE
}'RESETA, GOTO CRCH ON Q - Z<0, R0 _ MTAE MRG DISP(NIQ);
*KNOW MASK(NOQ) = MASK(NIQ) LCY 1
}'GOTO NOUBLEQ IF NODD,}"LINE, Q _ MASK(NIQ), SETA;
}'Q _ Q LCY 1;
NOUBLEQ:
}'M _ WD2 _ M AND NOT Q, GOTO CRCH, STORE;
*

*
*PWP: PUT WRITE POINTER
*
*PWP MUST:
*}'1) REPLACE POINTERS (IF CHANGED)
*}'2) SET NIQ OR NOQ IF THE BUFFER COUNT EXCEEDS MP*XBCNT
*}'3) INDICATE CHAR COUNT HIGH BY VALUE
*
* ARGUMENTS: NONE
* ASSUMES GLE AND GWP CALLED HAVE BEEN CALLED
*
*VALUE:}"Z < O IF WKCNT < CCNT, ELSE >=0.
*
*LEVEL: -
*
*SUBROUTINES CALLED: CWCH (BY GOTO)
*
*NMR: 2-3
*
PWP:}#GOTO PWP3 ON BFLAG >=0, Q _ MASK(XBCNT);
***}$FETCH MTCE + DISP(XBCNT);
}'FETCH MTCE;
}'Z _ M AND Q LCY 8, R0 _ -8;
}'Q _ 0, M _ MP;
*
*MULTIPLY MP (0 - 64) (IN Z)}"BY ABCNT (IN M LEFT SHIFTED 16) AND DIVIDE BY 64
FFOO:}$Q _ Q LCY 1, GOTO EFOO ON R0 _ R0 + 1 >=0;
}'GOTO FFOO ON}"M _ M LCY 1 >=0;
}'Q _ Q + Z, GOTO FFOO;
EFOO:}$M _ Q LCY 16,Q _ 4B7 + 177B, GOTO 1613B;
}'M _ WTCE2, Z _ ONE(ABCNT);
*}"NOTE FAMOUS 1020 PUNTS DISABLED ON 12/13/75}#(WWL)
*}"NEXT LINE USED TO SAY "CALL ABORT ON M_...Z < 0
}(M _ WTCE2 _ M AND Q + Z;}"*(PWP) BUFFER COUNT NEGATIVE
}'Q _ M AND Q LCY 8, M _ VR;
*
*FINISH MULTIPLY: GOTO PWP3 IF MP*XBCNT/64*4>ABCNT*256
}'GOTO PWP3 ON M - Q>0;
*SET NIQ(NOQ) AND UPDATE XIB(OR XOB)
}(Q _ MASK(NIQ), M _ WD2;
*KNOW: MASK(NIQ) = MASK(NOQ) *2 AND OUTPUT LINE IS ODD
}(GOTO PWP2 IF}"NODD, Z _ 0, LINE;
}(Q _ Q LCY 1, Z _ 1;
PWP2:}%WD2 _ M _ M AND NOT Q+Q;
}'STORE MTAE MRG DISP(NIQ);
*Z STILL HAS A 1 IF LINE IS OUTPUT, 0 IF INPUT
}(FETCH Z MRG XIB;
}(M _ M + 1, STORE;
*UPDATE WCP IF CHANGED
PWP3:}$Z _ MTCE, Q _ STFLAG;
}'GOTO PWP4 ON Z _ WCP>=0, R0_Z+DISP(WCPF);
}'M _ BUF0, Q _ 4B7;
}'M _ Z AND NOT Q - M, M _ WTCE2, STORE;}"*MERGE THEM TOGETHER
*UPDATE CHARACTER COUNT
PWP4:}$M_DISP(CCNT), Z _ MTCE;
}'FETCH Z+M, Z _ WCNT;
}'Z _ M +Z, Q _ MASK(CCNT);
}'M _ M AND NOT Q + Z AND Q, STORE;
}'CALL ABORT ON M AND NOT Q - Z AND NOT Q#0, Q _ MASK(WKCNT); *(PWP) NO MORE CHARS BUT CHAR COUNT = 0
}'M _ STUFF(WKCNT), DGOTO CWCH;
}'Z _ M - Z AND NOT Q, RESETA;
*

*
*PUTFIELD: STORES INTO A LINE TABLE FIELD
*
* ARGUMENTS: 
*}'CARG1: FIELD DISCRIPTER
*}'CARG2: VALUE FOR FIELD
*
*VALUE: NONE
*
*NMR: 2
*
*LEVEL: TOP
*
*SUBROUTINES CALLED: GFD
*
PUTFIELD:}$CALL GFD;
}'VR _ R0, M _ 24;
}'Z _ M - Z, FETCH DISP(CARG2);
}'M _ M LCH Z;
}'Z _ M LCL Z;
}'FETCH VR, DGOTO CPUFIN;
}'M _ M AND NOT Q ! Z AND Q, STORE;
*

*
*PUTREG: LOAD REGISTERS
*
*THIS LOADS THE LIVE REGISTERS OF THE CHIO FOR COMMUNICATION WITH THE CPU
*
*
*THIS IMPLEMENTS THE LOAD REGISTER CPU CALL
*THE SCRATCH PAD REGISTERS MAY BE LOADED BY THIS CALL
*LOWER REGISTERS MAY NOT BE LOADED
*
* ARGUMENTS:
*}'CARG1: SCRATCH PAD REGISTER NUMBER
*}'CARG2: VALUE FOR REGISTER
*
*VALUE: NONE
*
*SIDE EFFECTS: ONE OF THE REGITERS IS CHANGED
*
*LEVEL: -
*
PUTREG:}$FETCH DISP(CARG1);
}'Z _ M, FETCH R0 + 1, DGOTO CPUFIN;
}'SKZ _ M, M _ 0;
*

*
*RCH: READ CHARACTER
*
*THIS IS THE BASIC READ CHARACTER SUBROUTINE USED IN THE CHIO.
*IT ASSUMES THAT RCP POINTS TO A WORD THAT IS IN RWORD AND WILL READ
*ONE CHARACTER FROM RWORD.
*IF RWORD IS EMPTY IT WILL ADVANCE THE POINTER AND FETCH
*THE NEXT WORD AND PLACE IT IN RWORD AND READ A CHARACTER FROM THAT
*WWORD IS FOR THE FORM XXX, XNN, OR XXN, AND OCCASIONALY NNN.
*IF WWORD IS NNN THE CORRECT VALUE WHOULD BE FETCH FROM MEMORY
*NULL CHARACTERS WHICH SHOULD NEVER APPEAR ARE NOT READ AND NOTCOUNTED
*IF THERE ARE NO CHARACTERS THEN CHAR IS SET TO 0
*$RBUF IS CALLED IF THE NEXT BUFFER IS TO BE LINKED TO.
*$RBUF MAY HAVE ABORT OR LNKB IN IT
*
* ARGUMENTS: NONE
*
*VALUE: 
*}'M: CHAR (0 IF NO CHARS LEFT)
*}'CHAR: CHAR
*
*SIDE EFFECTS: RCP, RWORD MODIFIED;
*
*SUBROUTINES CALLED: $RBUF MAYBE
*
*NMR: 1/3
*
*LEVEL: 0
*
RCH:}#M _ RWORD, Q _ MASK(LCHAR);
RCH01:}$Z _ RWORD _ M AND NOT Q LCY 8, VR _ RCNT, DRETURN;
}'GOTO RCH3 ON CHAR _ M _ M AND Q LCY 8 = 0, RCNT _ RCNT + 1;
*
*STEP TO NEXT WORD
RCH2:}$Z _ RCP, Q _ STFLAG;
}'M _ RCPEND;
}'GOTO RCH4 ON M _ M AND NOT Q - Z AND NOT Q =0, Q _ MASK(LCHAR);
}'FETCH RCP _ RCP + 1 MRG STFLAG, GOTO RCH01 IF NMOD8;
}'GOTO SH5, Z _ OS;
}'M _ RBUF, CALL GOTOM;
}'DGOTO RTSS0, M _ CHAR;
*NOTE THAT RCH WHEN CALLED THIS TIME WILL RETURN TO RTSS0 WHICH WILL
*RETURN TO THE CORRECT PLACE.}"RCH WHEN CALLED WILL NOT GET TO
*THIS PLACE UNLESS THE LINKED TO BUFFER CONTAINS 21 NULLS AN IMPOSIBILITY
}'CALL RCH ON M =0;
*
*TRYED TO READ A NULL CHARACTER STEP PAST IT AND UNCOUNT IT
RCH3:}$GOTO RCH01 ON}"M _ Z # 0;
}'GOTO RCH2, RCNT _ VR;
RCH4:}$GOTO SH7, Z _ OS;
FU7:}#CALL BLAKE ON BFLAG <0;
}'Z _ RCP, Q _ BFLAG _ 4B7, .LZX;
}'M _ DISP(RWEB);
*DONT RETURN CPU BUFFER
}'M _ RCP _ BUF0 MRG STFLAG, GOTO *+2 ON M-Z AND NOT Q =0;
}'PRB_ Z AND NOT Q - M AND NOT Q;
}'RCPEND _ M;
}'M _ CHAR, GOTO RTSS0;

*
*RCH1: READ ONE CHARACTER FROM SPECIFIED LINE.
*
* ARGUMENTS:
* IMPLICIT: MTCE
*
*VALUE:
*}'CHAR: CHARACTER READ
*}(A IS SET IF CCNT>=WKCNT, OTHERWISE RESET
*
*SIDE EFFECTS: CCNT, AND RCPF FOR THE LINE ARE MODIFIED 
*
*LEVEL: 1
*
*SUBROUTINES CALLED: GRP, RCH, PRP
*
*NMR: O
*
RCH1:}$Z _ OS;
}'SVR1 _ Z,CALL GRP;
}'WCNT _ 1, CALL RCH;
}'GOTO *+2 ON M#0;
}'WCNT _ 0;
}'CALL PRP;})* A WILL BE SETUP ON RETURN
}'M _ CHAR, GOTO RTSS1;
*

*
*RCND: READ STRING NON DESTRUCTIVELY
*
*RCND WILL READ A STRING WITHOUT ADVANCING THE POINTER
*
* ARGUMENTS: CARG1 NUMBER OF CHARACTERS TO READ
*
*VALUE: M: NUMBER OF CHARACTERS READ
*
*LEVEL: 1
*
*SUBROUTINES CALLED: RCH,WCH,IWCH,CWCH,GRP, NSR1
*
RCND:}$Q _ R0}"_}"DISP(RWSB), M _ 0, STORE;
}'Z _ ABCPU, CALL IWCH;}+*(RCND) WRITE COUNT IN LINE HIGH
}'FETCH DISP(CARG1);
}'CALL GRP, RCNT _ 0-M;
RCLP:}$GOTO RECL ON RCNT >=0;
RCLP1:}$CALL RCH;
}'CALL NSR1 ON M=0;
}'GOTO RECL ON M = 0;
}'PRB _ 0, CALL WCH;
}'GOTO RCLP;
RECL:}$Q _ CHAR, M _ SHIFT1;
}'GOTO RCLP1 ON M - Q = 0;
}'PRB _ 0, CALL CWCH, SETA;
}'M _ WCNT, LCWS1 _ 0;
}'Q _ ICC, DGOTO CPUFIN;
}'ICC _ M + Q;
*

*
*RESTART:}#CONTROL GOES HERE IF A REQUEST STROBE 2 IS RECEIVED
*
*RESTART:}#CALLED WHEN THE IS TO BE RESTARTED
*
*SEE DOCUMENT SINIT/W-19 FOR DETAILS
*
*SUBROUTINES CALLED: TOFF24, GET360(INTERNAL);
*
*
*ZAP RESETS MEMORY, REST OF DEVICE INITIALIZATION MUST PROCEED
*
*SEE SINIT/W-19 TAPE FOR DEFINITION OFRESTART PROCEEDURE
*
RESTART:}$RESETFAIL, GOTO * + 1 IF ATT1;
}'RESETCPU, GOTO * + 1}"IF ATT2, Q _ 14B6; *IF BITS 2,3;
}%.BR_10B, .BL_7, .TAX, UNPROTECT, GOTO * + 1}"IF ATT3, .LZY, .C_4B6;
*-01 DO RESTART
}(R0 _}"SRMEM, GOTO 1610B, RESETTU;}$*INTRPT 360
}'GOTO STEP75 ON M AND Q - Z AND Q # 0;
TAPERESTART:}$CALL TOFF24, M _ MASK(CST);
}'Z_ 103B, ALERT;}#*ADDRESS OF 360
}'Z _ 7667B, POT;})*SEND TAPE RESTART CHARACTER
GNB:}#CALL GET360, CHK360 _ Q _ 0;
}'M _ NUL360;
}'GOTO GNB ON M - Z = 0, Q _ M _ 77B;
}'GOTO 1621B ON M AND Q - Z AND Q=0;
}'Q _ Z AND Q, CALL QQCYZ, Z _ 13B;
}'R0 _ Q - 1;
}'VR _ -2049;
LP360:}$Q _ 0, CALL GET360;
}'CALL GET360;
}'CALL GET360;
}'CALL GET360;
}'Q _ CHK360, M _ Q;
}'Q _ CHK360 _ M EOR Q;}"*M HAS WORD, Q HAS CHKSUM
}'GOTO * + 2 ON VR _ VR + 1 >= 0, Z _ CORCHK;
}'STORE R0 +1, GOTO LP360;
}'GOTO *+2 ON Z - Q = 0, M _ VCC;
}'M _ IVCC;
}'ALERT, Z _ 103B;}(*ADDRESS OF 360
}'POT, Z _ M MRG MASK(TRCH),}"GOTO GNB;
STEP75:}$Z _ 103B, ALERT;}"* ADDRESS OF 360
}'Z _ 7676B, POT;
FIN360:}$GOTO * IF NOREQ;
}'R2 _ -LSCRATCH, GOTO LOADST;
*
*INTERNAL SUBROUTINE TO GET A CHARACTER FROM THE 360
*AND PACKS SIX BITS OF}"IT INTO RIGHT SIDE OF THE Q REGISTER CYCLESIN LEFT 6
*ON RETURN Z HAS THE CHARACTER
*
*USE RCP AS TEMP STORE
*
GET360:}$RCP _ M _ Q, ALERT, Z _ 2B7 + 20B;}"*SCANNER ADDRESS
}'Z _ E2, PIN, Q _ 400B, DGOTO 1614B;}"
}'GOTO GET360 ON Z AND Q=0, Q _ RCP;}"*IF NO CHARACTERS
}'CALL ABORT;}#*NEVER EXECUTED
}'M _ M LCH 6;
}'M _ M LCL 6, Q _ MASK(OCHAR);
}'Z _ Z AND Q, Q _ 77B;
}'Q _ Z AND Q + M AND NOT Q, RETURN;
*

*
*RSTB: READ STRING TO BREAK CHARACTER
*
*RSTB READ CHARACTERS FROM THE SPECIFIED LINE UNTIL:
*}'1) THERE ARE NO CHARACTERS IN THE LINE
*}'2) A BREAK CHARACTER IS REACHED (NSR=0)
*}'3) CARG1 CHARACTERS HAVE BEEN READ (NSR = 0)
*}'4) NO MORE CHARACTERS CAN BE READ(NSR = 2)
*
*RSTB SHOULD NOT BE ASKED TO READ MORE THEN 20 CHARACTERS. IF THE
*LAST CHARACTER TO BE READ IS A SHIFT1, 1 EXTRA CHARACTER IS READ
*
*IF THERE ARE NO INPUT CHARACTERS THEN NONE ARE RETURNED, NSR _ 1;
* AN ATTEMPT TO READ 0 CHARACTERS WILL ALWAYS SUCCEED READING 0 CHARACTERS
*
*RSTB MUST:
*}'1)READ THE CHARACTERS
*}'2)IF THE (INPUT ONLY) LINE IS IN DEFERRED ECHO MODE AND THE ECHO 
*}'STRATAGY IS 1, IT SHOULD ECHO THE CHARACTER
*}'3) DITTO TO THE (INPUT ONLY) LINKED LINE (IF THERE IS ONE)
*}'4) IF AN (INPUT ONLU) LINE INPUTS A BREAK CHARACTE IT MUST NOT BE
*};*ECHOED IF EBC IS OFF 
*}'5) SET DEFERED ECHO MODE IF CHARACTER INPUT IS A BREAK CHARACTER
*}'6) IF THE (INPUT ONLY) LINE IS EMPTY IT MUST RESUME LOCAL ECHO
*}'7) IF THE (INPUT ONLY) LINE IS EMPTY IT MUST WAKEUP ANY CCP TYPE 
*}'PROCESS
*}'8) IF THE LINE IS AN OUTPUT LINE IT MUST TURN OFF OUTPUT
*}'9) IT MUST SIGNAL AN EMPTY LINE NSR=1
*}%10) SET WIC IF INPUT LINE IS EMPTY
*
* ARGUMENTS: IN CPUIT
*
*VALUE: M: NUMBER OF CHARACTERS READ
*
*TURN OFF OUTPUT IF LINE READ FROM IS AN OUTPUT LINE
RSTB:}$Z _ 0;
*SETUP READ AND WRITE ROUTINES
}'R0_Q_DISP(RWSB), M _ 0, STORE;
}'Z _ ABCPU, CALL IWCH;}+*(RSTB) WRITE COUNT IN LINE HIGH
}'FETCH DISP(CARG1);
}'RCNT _ 0-M, CALL GRP;
*RCNT IS SET TO NUMBER OF CHARACTERS TO READ
RSTLP:}$GOTO RSTF1 ON RCNT>=0;
RSTCLP:}$CALL RCH;
}'GOTO RSTF3 ON M = 0;
}'CALL WCH;
}'CALL WKCQ, M _ CHAR;
}'M_WD1, Q_MASK(DE);
}'DGOTO RSTF2 ON Z-WKI>0;
}'CALL ECHO ON M AND Q # 0;
}'GOTO RSTLP;
*FINISHED: STOPPED BY GETTING REQUIRED COUNT (NSR = 0)
RSTF1:}$GOTO RSTCLP ON LCWS1 <0;
}'CALL PRP, LCWS1 _ 0;
}'CALL CWCH, SETA;
RSTF5:}$Q _ ICC;
}'DGOTO CPUFIN, M_WCNT;
}'ICC _ M + Q;
*INPUT LINE EMPTY (NSR = 1)
RSTF3:}$M _ WD1 MRG MASK(WIC), CALL NSR1;
}'STORE MTAE MRG DISP(WIC), CALL 1640B;
}'GOTO RSTF1 IF ODD, LINE, Q _ MASK(CCPBIT);
*WAKEUP ANY CCP TYPE PROCESS
}'GOTO 1636B ON M AND Q=0, Q _ MASK(LNKBIT);
}'FETCH MTAE MRG DISP(LQNK);
}'GOTO 1636B ON Z AND Q#0, Q_MASK(LQNK);
}'M_STUFF(LQNK), RESETA, CALL GLE;
}'FETCH MTAE MRG DISP (PROC);
}'Q_MASK(PROC);
}'M_STUFF(PROC), CALL WAKEUP, Z_WKBERT;
*TURN OFF DEFERRED ECHO AND CLE
RSTFX:}$Q_MASK(DECLE), Z_WD1, DGOTO RSTF1;
}'M _ Z AND NOT Q,}"STORE MTAE MRG DISP(DECLE);
* BREAK, QUIT, OR ESCAPE CHARACTER READ (NSR = 2)
RSTF2:}$M _ WD1, Q _ MASK(DE);
}'GOTO RN2 ON M AND Q #0;
}'M _ M OR Q;
}'M _ WD1 MRG MASK(DE);
}'STORE MTAE MRG DISP(DE), Q _ MASK(EBC);
}'CALL ECHO ON M AND Q=0;
*NSR=2 SIGNALS LAST CHAR IS A BREAK CHARACTER
RN2:}#NSRFLAG _ 2, GOTO RSTF1;

*
*
*RTUPDATE: UPDATE REAL TIME CLOCK IN CORE
*
* ARGUMENTS: M: TIME OF INTERUPT (GNR TYPE CALL ONLY)
*}&Q: UPAM (SET UP BY CALLING BRANCH VECTOR) (GNR TYPE CALL ONLY)
*
*VALUE: NONE
* 
*LEVEL: -
*
*SUBROUTINES CALLED: NONE
*
*ENTRY FROM GNR
*
RTUPDATE:
}'NCI _ Q + M;
*
*ENTRY FROM CPURQ
*
RTUPC:}"Z_RDCKL,ALERT;
}'PIN , M _ E2;
}'Z _ RDCKH, ALERT;
}'PIN, GOTO RTUPC ON VR _ E2<0, Z _ Q}"_ M;
*VR: HIGH ORDER PART; Q,Z: LOW ORDER PART
}'FETCH RTLBASE;
}'Q _ M EOR Q;
}'M _ M + Z, STORE RTLOW;
* CARRY IF OVERFLOW; OVERFLOW IS NOT OF SIGN OF RESULT, IF OPERANDS 
*HAVE DIFFERENT SIGNS; SIGN OF OPERAND, IF OPERANDS HAVE SAME SIGN
*
* AT THIS POINT Q=4B7 IF OPERAND'S SIGN DIFFERENT, 0 IF SAME
*M = RESULT, Z = ONE OF THE OPERANDS
}'M _ NOT M AND Q + Z AND NOT Q, Q _ 4B7;
*M IS NOW 1 IF A CARRY IS TO TAKE PLACE, ELSE ZERO
}'Z _ M AND Q LCY 1, R0 _RTHBASE;
}'FETCH;
}'Z _ M + Z, M _ VR;
}'Z _ M + Z, FETCH RTLOW;}$*FAST MEMORY USED AS SCRATCH PAD
*SIGN OF HIGH ORDER PART IS SAME AS SIGN OF LOW ORDER PART
}'M _ Z AND NOT Q ! M AND Q, DRETURN, STORE RTHIGH;
*STROBE TO UTP
}'SIGUTP, ATMS;
*

*
*SAVESTATE:}"CALLED WHEN STATE SHOULD BE SAVED, ALSO ENTERED
*}$WHEN START SHULD BE RELOADED (BWAIT OR LOADST)
*
* PARAMETERS DEFINING THE SAVE AREA, USED BY THE STATE STORE AND
* LOAD ROUTINES
}'DPM(SAVE,2740B);})* FOR UTP. SEE SYSP/W-15
}'DPM(LSCRATCH,200B);}'*LENGTH OF SCRATCH PDA SAVE
}'DPM(SAVER0,SAVE+LSCRATCH);
* THE CODE SAVES R0-R6, OS, QAND Z IN SEQUENCE
}'DPM(SAVER1,SAVER0+1);
}'DPM(SAVEZ,SAVER0+9);
* A SCRATCHPAD LOCATION MUST BE DEDICATED TO SAVING M
}'REG(SK0,SSMREG);
* THE O REGISTER IS RESTORED FROM
}'DPM(BREAK,22B);}** FOR CHIO. SEE SYSP/W-15
* AND WE WAIT AFTER STORING THE STATE FOR
}'DPM(BRKWAIT,27B);}(* FOR CHIO. SEE SYSP/W-15
* TO BECOME NON-ZERO BEFORE STARTING TO RELOAD

* BREAK. DUMP STATE IN THE SAVE AREA.}"THE STRATEGY IS AS FOLLOWS
* 1) SAVE M IN SSMREG IN THE SCRATCHPAD
* 2) STORE R0 AT SAVER0. STORE OS AT SAVEOS
* 3) STORE Z,Q AT SAVEZ,Q AND R1-R6 AT SAVER1 TO SAVER6
* 4) EXCHANGE SCRATCHPAD AND SAVE TO SAVE+LSCRATCH-1

* AFTER ) EING THE STATE, BREAK WAITS UNTILL BRKWAIT
* BECOMES NON-ZERO.

* THE RELOAD STRATEGY IS OBTAINED BY DOING STEPS 4-3 IN REVERSE,
* AND THEN
* 2) FETCH SAVEOS AND DGOTO IT
* 1) DGOTO *+1 (THIS SETS UP OS), FETCH BREAK
* 0) DGOTO M (THIS SETS UP O), FETCH SAVER0
* -1) R0_M, M_SSMREG

}'MACRO IMS_R0_Z_Z+1, STORE;
SAVEST:}#SSMREG _ M, STORE, GOTO 1635B;
}'M_Z, R0_SAVEZ, STORE;
}'M_R1, R0_Z_SAVER1, STORE;
}'M_R2, IMS;
}'M_R3, IMS;
}'M_R4, IMS;
}'M_R5, IMS;
}'M_R6, IMS;
}'M_OS, IMS;
}'M_Q, R0_Z_R0+1, STORE;
}'R0_SAVE-1;
}'R2_-LSCRATCH, Z_0, CALL XSCRATCH;
}(R0_BRKWAIT, STORE, M _ 0;
}'Q _ 12343210B, FETCH;
}'GOTO *-1 ON M-Q#0, R2_-LSCRATCH;
LOADST: R0_SAVE-1, Z_0, CALL XSCRATCH;
}'R0_SAVER1, FETCH;
}'R1_M, CALL FN;
}'R2_M, CALL FN;
}'R3_M, CALL FN;
}'R4_M, CALL FN;
}'R5_M, CALL FN;
}'R6_M, CALL FN;
}'DGOTO M, R0_R0+1, FETCH;
}'Q_M, R0_R0+1, FETCH, CALL *+1;
}'Z_M, R0_BREAK, FETCH;
}'DGOTO M, R0_SAVER0, FETCH;
}'R0_M, M_SSMREG;

* SUBROUTINE TO BUMP R0 AND FETCH
FN:}$R0_R0+1, FETCH, RETURN;

* SUBROUTINE TO EXCHANGE -(R2) SCRATCHPAD LOCATIONS, STARTING AT (Z),
* WITH CORE LOCATIONS STARTING AT (R0)+1. CLOBBERS M,Z,R1,R2
XSCRATCH: FETCH, R0_R0+1;
}'R1_SKZ;
}'SKZ_M, M_R1, DGOTO XSCRATCH;
}'STORE, Z_Z+1, RETURN ON R2_R2+1>=0;

*
*TOFF24: POT TO ALL 2400 BAUD LINES FOR INITIALIZATION
*
*ALSO MAY BE CALLED AS A CPU REQUEST
*
*ARGUMENTS M: (CARG1:) OUTPUT REQUEST (Z REG WHEN POT)
TOFF24:}$VR _ -100B;
I24LP:}$Q _ 77B, Z _ VR;
}'DRETURN, ALERT, Z _ Q AND Z MRG OUTRQ;
}'POT, Z _ M, GOTO I24LP ON VR _ VR+1<0;
*
*

*
*WAKEUP: WAKEUP A PROCESS
*
*WAKEUP WILL WAKEUP A PROCESS WITH THE WAKEUP SPECIFIED BY Z.
*EXCEPT THAT IF IT IS TO WAKE IT UP FOR INPUT OR OUTPUT IT WILL
*INSIST THAT WIC OR WOC BE SET.
*IF THE PROCESS IS AWAKENED FOR OUTPUT AND IT IS LINKED THEN IT WILL
* BE AWAKENED IF NOQ IS OFF FOR BOTH LINES, BUT IF IT IS ON
*THEN AN ATTEMPT IS MADE TO AWAKE BOTH PROCESSES
*
*IF A PROCESS IS AWAKENED FOR INPUT THEN: AWT _ XWT
*NOTE THAT THE VALUE OF WKCQ IS THE ARGUMENT FOR WAKEUP
*
* ARGUMENTS: 
*}'Z: TYPE OF WAKEUP
*}(0) WKNONE: NO WAKEUP
*}(1) WKI:}#WAKEUP FOR INPUT IF WIC IS ON
*}(2) WKB:}$SAME AS WKI
*}(3) WKQ:}%WAKEUP FOR A QUIT CHARACTER
*}(4) WKX:}%WAKEUP FOR AN ESCAPE CHARACTER
*}(5) WKN:}%WAKEUP NORMAL
*}(6) WKBERT:}"WAKEUP PROCESS IN M NORMAL
*}(7) WK0:}%WAKEUP FOR OUTPUT IF WOC IS ON
*}&M: PROCESS TO WAKEUP IF Z = WKBERT
*
*VALUE: A IS SET IF PROCESS IS AWAKENED
*
*SIDE EFFECTS: PROCESS (USUALLY) AWAKENED.
*
*LEVEL: -
*
*SUBROUTINES CALLED: NONE
*
WAKEUP:}$Q _ WKBV, RESETA, VR _ 0, GOTO GOQPZ;
WKBV:}$RETURN;}.*WKNONE=0
}'Q_Q;}$*NULL INSTRUCTION *WKI=1
}'M _ WD1, Q _ MASK(WIC), GOTO WKP4;}$*WKB=2
}'Z _ MASK(QWKW), GOTO WIN;}$*WKQ=3
}'Z _ MASK(XWKW), GOTO WIN;}$*WKX=4
}'Z _ MASK(NWKW), GOTO WIN;}$*WKN=5
}'VR _ M, Z _ MASK(NWKW), GOTO WIN3;}$*WKBERT=6
* ATTEMPT TO AWAKE PROCESS FOR LINE FOR OUTPUT
TWKOW:}#M _ WD1, Q _ MASK(LNKBIT); *GOTO WKP1}#WKO = 7
WKP1:}$GOTO WKP3 ON M AND Q#0, Q _ MASK(WOC);
*MASK(WIC) OR MASK(WOC) IN Q, WD1 IN M
*TEST WIC,WOC;}"IF SET CLEAR AND WAKEUP, ELSE RETURN
WKP2:}$RETURN ON M AND Q=0, Z _ MASK(NWKW);
}'M _ M AND NOT Q, STORE MTAE MRG DISP(WIC);
*WAKEUP WORD IN Z, PROCESS IN MTAE.PROC
WIN:}#FETCH MTAE MRG DISP(PROC);
}'Q _ MASK(PROC);
}'M _ VR _ STUFF(PROC);
*WAKEUP PROCESS IN VR, WORD IN Z
WIN3:}%M_10B, UNPROTECT;
}'PROTECT, M, Q _ 2, GOTO WIN3 IF IFUNPRO;
}'FETCH WPL;
}'GOTO 1606B, M _ M + Q,}"Q _ 37B;
*NO SPACE IN TABLE SO INCREMENT BADWK WHILE WAITING
}'FETCH BADWK;
}'M _ M + 1, STORE, GOTO WIN3;
WKPZ:}%SIGUTP, ATMS;
}'STORE, Q_ MASK(WKPRF);
}'R0 _ M;
}'Z _ VR, VR _ Z;
}'M _ Z AND NOT Q MRG WKPRI, STORE;
}'M _ VR, VR _ Z;
}'STORE R0 + 1;
*IF VR<0 LINKED LINE'S PROCESS WAS AWAKENED, WAKEUP PROCESS FOR NORMAL LINE
}'UNPROTECT, 10B, RETURN}"ON VR>=0;
}'M _ WD1, Q _ MASK(WOC), GOTO WKP2;
*WKI, WKB CONTINUED
WKP4:}$RETURN ON M AND Q=0, FETCH MTAE MRG DISP(AWT);
*MTAE.AWT_MTAE.XWT
* A +23 IS HIDDEN IS STCY THAT HAS TO BE COUNTERACTED BY THE TWO -23S
}'Z _ M LCY 20, Q_MASK(AWT);
}'M _ M AND NOT Q+ Z AND Q, STORE;
}'M _ WD1, Q _ MASK(WIC), GOTO WKP2;
*PROCESS LINKED, WAKEUP SHOULD ONLY OCCUR IF NOQ OF BOTH LINES ARE OFF
*KLUDEGERY HERE, IF LINKED PROCESS HAS NOQ ON, RETURN, OTHERWISE
* ATTEMPT TO AWAKE BOTHE, WAKEING THE LINKED PROCESS BY PUTTING IT
*IN Z AND GOING TO WIN3, AND SETTING THE 4B7 BIT IN VR(THE PROCESS) AS
* A FLAG INDICATING THE NORMAL PROCESS SHOULD BE AWAKENED
WKP3:}$M _ WD2, Q _ MASK(NOQ);
}'RETURN ON M AND Q # 0, FETCH MTAE MRG DISP(LQNK);
}'Z _ MTAA, Q _ 17776B;
***}$M _ STUFF(LQNK)+2, Q _ MASK(NOQ);
}'M _ M AND Q LCY 1, Q _ MASK(NOQ);
***}$Z _ M + Z, FETCH M + Z MRG DISP(NOQ);
}'Z _ M + Z, FETCH DISP(NOQ), .TXW;
}'RETURN ON M AND Q#0, Q _ MASK(WOC);
}'FETCH Z, Z _ 2B5;
}'RETURN ON M AND Q = 0, Q _17777B;
}'FETCH R0 MRG DISP(PROC);
}'VR _ STUFF(PROC) MRG 4B7, GOTO WIN3;
*

*
*WCH:}"WRITE CHARACTER;
*
*THIS IS THE GENERAL WRITE CHARACTER SUBROUTINE.
* ALL WRITING OF CHARACTERS IS DONE WITH THIS SUBROUTINE.
*IT ASSUMES THAT WCP POINTS TO THE WORD INTO WHICH THE
* CHARACTER IS BEING WRITTEN}"AND WILL STORE INTO THE WORD
*POINTED TO BY WCP, AND INCREMENT WCP.
*WCH WILL NEVER FETCH FROM MEMORY AND WILL STORE INTO MEMORY ON 
*ONLY ONE OF EVERY THREE CALLS.
*IF WCP IS INCREMENTED ACROSS A BUFFER BOUNDARY
*(WCP WAS 7 MOD 8) THEN THE SUBROUTINE SPECIFIED BY WBUF IS CALLED TO
*SETUP WCH TO POINT TO THE APPROPRIATE LOCATION.
*
*WWORD IS ASSUMED TO BE NNX, NXX, OR XXX WHERE N IS THE NULL CHARACTER,
* AND X'S ARE NON NULL CHARACTERS. WHEN Y IS WRITTEN WWORD
* BECOMES: NYX, YXX, OR NNY.}"IN THE LAST CASE THE OLD WWORD IS STORED IN
*THE LOCATION SPECIFIED BY WCP, AND WCP IS INCREMENTED BY ONE AND IF
*IT CROSSES A MOD 8 BOUNDRY $WBUFF IS CALLED. (GAB ONLY)
*WCNT IS INCREMENTED BY 1
*THIS SUBROUTINE IS A NO OP IF THE CHARACTER IS A NULL (0)
*
* ARGUMENTS:
*}'M: CHARACTER TO BE STORED
*
*VALUE: NONE
*
*SIDE EFFECTS: WCP, WWORD,MAY BE MODIFIED
*
*LEVEL: -
*
*SUBROUTINES CALLED: $WBUF (GAB OR ABORT ONLY) (GOTO)
*
*NMR: 1/3
*
WCH:}#RETURN ON Q _ M = 0, M _ MASK(RCHAR);
}'R0 _ Z _ Q _ Q AND M LCY 16, M _ WWORD;
}'WWORD _ Q OR M LCY 8, Q _ MASK(LCHAR);
*}**RETURN IF OLD WWORD WAS NOT XXX.
}'M AND Q, RETURN IF LB=0, WCNT _ WCNT + 1;
}'STORE WCP, Q _ Z;
}'WWORD _ Q LCY 8;
}'WCP _ WCP + 1 MRG STFLAG, RETURN IF NMOD8;
}'Z _ WBUF, GOTO GOTOZ;}#* CALL WBUF AND RETURN
*

*
*WCH1: WRITE ONE CHARACTER IN LINE
*
*
* ARGUMENTS: 
*}'CHAR: CHARACTER OR SHIFT1, CHARACTER
*}'LINE, MTCE ARE SETUP
*
*VALUE: Z < 0 IF CCNT >= WKCNT, ELSE Z >=0;
*
*SIDE EFFECTS: WWORD, WCP MODIFIED
*
*LEVEL: 1
*
*SUBROUTINES CALLED: GWP,WCH,PWP
*
*NMR: 0
*
WCH1:}$Z _ OS;
}'CALL GWP, SVR1 _ Z;
}'M _ CHAR, Q _ MASK(RCHAR);
}'GOTO WCH11 ON M AND NOT Q = 0;
}'CHAR _ M AND Q, Q _ MASK(MCHAR);
}'M _ STUFF(MCHAR), CALL WCH;
WCH11:}$CALL WCH, M _ CHAR;
}'CALL PWP;
}'GOTO RTSS1;
*

*
*WKCQ: IS IT A WAKEUP (W), BREAK (B), QUIT (Q), OR ESCAPE (X)
*
*ON RETURN Z WILL CONTAIN
*}'0) WKNONE}+CHAR NOT Q, B, W, OR X.
*}'1) WKI}.CHAR IS W, IS NOT Q, B, OR X.
*}'2) WKB}.CHAR IS B, NOT Q OR X.
*}'3) WKQ}.CHAR IS Q, NOT X.
*}'4) WKX}.CHAR IS X.
*
*WITH THE EXCEPTHIO OF SHIFT1 ALL CONTROL CHARS ARE BREAK CHARS.
*CBREAK MAY EVE BE A QUIT CHARCTER. THIS IS AN AMBIGIOUS CASE
*BECAUSE QUITC=377B WILL CAUSE IT TO STOP ON EITHER 377B ON CBREAK.
**IF A SHIFT1 1 IS RECEIVED IT IS NOT A BREAK CHARACTER. THE 
*FLAG LCWS1 IS SET.
*IT THIS FLAG IS SET ON INPUT THE CHARACTER IS TAKEN TO BE THEINPUT CHAR
*MOD 40B.
*ANY SUBROUTINE THAT MIGHT CALL WKCQ WITH A SHIFT1
*THAT WILL NOT IMMEDIATLTY RECALL IT MUST RESET LCWS1;
*
*NOTE THAT THE VALUE OF WKCQ IS THE ARGUMENT FOR WAKEUP
*
* ARGUMENTS: 
*}'M: CHARACTER EITHER 8 BIT CHARACTER OR SHIFT1 8 BIT CHARACTER
*}.(ALL CSES HANDLED CORRECTLY INCLUDING
*}.SUCSEVICE CALLS WITH SHIFT1 AND 40+CHAR)
*
*VALUE:
*}'Z: SEE ABOVE
*
*LEVEL: 1
*
*SUBROUTINES CALLED: NONE
*
*NMR: 1,2
*
*SIDE EFFECTS: LCWS1, CHISC ARE SETUP
*
WKCQ:}%VR _ M;
}'Q _ MASK(MDTYP), M _ WD1;
}'Q _ M AND Q LCY 2;
}'Z _ Q LCY 3, M _ VR;
}'Q _ Q + Z, Z _ DVTBA;
}'DVTBE _ Q + Z, Q _ 400B;
*THAT CODE WAS TO SET UP DVTBE TO DVTBA+36D(44B)*DEVICE TYPE
}'GOTO WK17 ON M-Q>=0, Q_37B;
}'DGOTO NORC ON LCWS1 >=0;}#*IF CHAR = SHIFT1 CHAR
}'M AND NOT Q, GOTO ISACC IF LB=0, Z _ SHIFT1;
WK17:}$LCWS1 _ 1;
}'VR _ M _ M AND Q, GOTO CCOMC;
* IS A CONTROL CHARACTER
ISACC:}$GOTO TRCB ON Z-M #0, Q _ Z _ CBREAK;
}'LCWS1 _ 4B7, Z _ WKNONE, RETURN;
TRCB:}$GOTO TQC ON Z-M = 0, M _ Q _ MASK(QUITC);}"*MASK(QUITC) = 377B
}'GOTO TESC, Z _ WKNONE;
*NORMAL CHARACTER
NORC:}#LCWS1 _ 0;
CCOMC:}$Z _ WD2, Q _ MASK(QUITC);
TQC:}#GOTO *+2 ON M AND Q- Z AND Q # 0, RESETA;
*}"FOLLOWING CAUSES "0" QUITC TO BE IGNORED}"7/4/75}#(WWL)
}'GOTO *-1 ON Z AND Q = 0, Z _ 1, SETA;
}'Z _ M _ M LCY 1, Q _ 760B;
}'Q _ M AND Q LCY 20, M _ DVTBE MRG DISP(C0);
}'FETCH M+Q, Q _ 17B;
}'Z _ Z AND Q;
}'M _ M LCL Z;
}'M _ M LCH Z, Q _ 6B7;
}'Z _ M _ M AND Q LCY 2, Q _ 3;
}'CHISC _ 0;
}'M EOR Q, GOTO *+2 IF LB#0;
}'CHISC _ 4B7;
*
*A WAS SET IF QUIT CHAR SO CHISC COULD BE SETUP}"IF QUIT CANT BE WS OR BS
}'Q _ MASK(WS), M _ WD1, GOTO SQE IF ASET;
}'M_ STUFF(WS), GOTO WKNOT IF LB=0;
}'M _ M + Z, Q _ 3;
*
*
*
*IF WS+CHAR TYPE>=3 THEN CHAR IS A WAKEUP CHAR AND MAYBE A BREAK CHAR
*WIITH ONE EXCEPTION WS=0 (AND CHAR TYPE IMPLICITY 3)
*
}'GOTO WKNOT ON M-Q<0;
}'M _ WD1, Q _ MASK(BS);
}'M _ STUFF(BS), Q _ 3;
}'M _ M + Z;
*
*IF BS + CHAR TYPE >=3 THEN CHAR IS A BREAK CHAR}%BS<=WS
*
}'GOTO TESC ON M-Q< 0, Z _ WKI;
}'Z _ WKB, GOTO TESC;
SQE:}#Z _ WKQ, GOTO TESC;
WKNOT:}$Z _ WKNONE;
*Z HAS WAKEUP TYPE UNLESS WAKEUP TYPE IS ESCAPE(WKX)
TESC:}$FETCH DVTBE MRG DISP(ESCCH), Q _ MASK(ESCCH);
}'Q _ STUFF(ESCCH), M _ VR;
*}"CHANGE DISABLES ESCAPE WAKEUPS:}"RETURN (ON M - Q # 0)
}'RETURN;
}'Z _ WKX, RETURN;
*

*WKOL: WAKEUP AN OUTPUT LINE
*
*WKOL SET A BIT IN THE LOCAL DEVICE BIT TABLE
*SO THAT CHARACTERS CAN BE OUTPUT BY BSCN;
*IT WILL NOT TURN THE LINE ON IF AWT # 0
*2400 BAUD LINES ARE ALSO AWAKENED
*
* ARGUMENTS:
*}'Z: 0 IF LINE IS TO BE TURNED OFF, -1 IF IT IS TO BE TURNED ON
*
*VALUE: NONE
*
*SIDE EFFECTS: SEE GLBTE
*
*LEVEL: 1
*
*SUBROUTINES CALLED: GLBTE
*
WKOL:}$Z _ OS, GOTO SH6, TFWK _ Z;
FU6:}#FETCH MTAE MRG DISP(AWT);
}'Q _ MASK(AWT), Z _ WD1;
}'GOTO RTSS1 ON M AND Q#0, Q _ MASK(RCNO);
}'M _ WD1, Z _ ONE(RCNO);
}'GOTO W24 ON M AND Q - Z = 0, R0_MTAE MRG DISP(LDVN);
}'CALL ABORT ON M AND Q #0, Q _ MASK(MDTYP);}"*ILLEGAL DEVICE TYPE (WKOK)
}'M _ M AND Q, GOTO 1616B;
*GET DEVICE NUMBER
}'FETCH MTAE MRG DISP(LDVN);
}'VR _ M;
*GENERATE RANDOM NUMBER 0-6 REPEATABLE GIVEN LINE NUMBER 
}'M _ MTCE, Q _ 16B;
}'GOTO *+2 ON Q _ M AND Q - 1 >=0; *Q HAS -1,1,3,5,7,11B,13B OR 15B
}'Q _ 1;}2*Q HAS 1,3,4,7,11B,13B OR 15B
*NOW SET (RESET) THE BIT
}(R0 _ Q + Z;
}'M _ VR, Q _ MASK(LDVN);
}'M _ STUFF(LDVN), Z _ 24;
}'Z _ Z - M, Q _ 4B7, CALL QQCYZ;
}'Z _ TFWK, DGOTO RTSS1, FETCH;
}'M _ M AND NOT Q + Z AND Q, STORE;
*
*RCNO = 1}"MEANS 2400 BAUD LINE
W24:}#FETCH, Q _ MASK(LDVN);
}'Z_STUFF(LDVN) MRG 100B; *OUTREQ
}'M _ TFWK, Q _ MASK(TRON), ALERT, DRETURN;
}'Z _ M AND Q MRG MASK(RCON)+CHSTAT+RQSEND, POT;
*

*
*WST: WRITE STRING
*
*WST DOES THE FOLLOWING:
*
*}'1) COPY STRING TO BUFFERS
*}'2) WAKEUP PROCESS IF LINE BEING WRITTEN ON IS AN INPUT LINE
*}'3) IF NOQ IS SET (BY PWP) SET WOC 
*}'4) IF THE LINE IS AN OUTPUT LINE WAKEUP THE LINE 
*}'5) IF THE CHARACTER IS AN ILLEGAL}"CONTROL CHARACTER CHECK CARG2
*}'6) SET NSR = 1 IF NIQ(NOQ) IS SET
*}'7) OUTPUT TO LINKED LINE
*}'8) WOC IS SET IF AN OUTPUT LINE AND NSR =1
*
*
*ARGUMENTS: IN CPUIT
*
*VALUE: NONE
*
*SIDE EFFECTS: RCP, WCP ETC GET GRONKED, LINE BUFFERS
*MIGHT HAVE CHANGED MARKEDLY.
*
*LEVEL: TOP
*
*}"SUBROUTINES CALLED WCH,RCH,IRCH, CRCH,GWP,PWP,WAKEUP,ECHO;

WST:}#M_DISP(RWSB);
}'Q_DISP(RWEB);
}'Z _ ABCPU, CALL IRCH;}+*READ COUNT TOO HIGH (WST)
}'CALL GWP;
}'FETCH DISP(CARG1);
}'RCNT_-1-M;
*COPY STRING TO BUFFERS
WSTLP:}$CALL RCH;
*CONSIDER ILLEGAL CONTROL CHARS
}'GOTO WSTFIN ON RCNT>=0;
}'VR _ M, Q_CHAX;
}'GOTO BADCH ON Q-M>0;
WSTOK:}#CALL WCH;
}'M_WD1, Q_MASK(LNKBIT), DGOTO WSTLP;
}'CALL ECHO ON CHISC _ M AND Q#0;
*RCNT INCREMENTED BY RCH
WSTFIN:}$CALL PWP;
*SET NSR TO 1 IF NIQ/NOQ SET
}'M_WD2, Q_MASK(NIQ);
}'CALL QQCYZ IF ODD,}"LINE, Z _ 1;
}'GOTO WST2 ON M AND Q=0, VR _ LINE;
}'NSRFLAG _ 1, VR, GOTO WST2 IF NODD;
}'M _ WD1 MRG MASK(WOC);
}'STORE MTAE MRG DISP(WOC);
WST2:}$CALL WKOL IF ODD, LINE, Z _ -1;
}'CALL WAKEUP IF NODD, Z_WKI,}"LINE;
}'M _ OUTCC;
}'Q _ WCNT, DGOTO CPUFIN;
}'OUTCC _ M + Q;
*DONT WCH CONTROL CHARACTERS UNLESS CARG SAYS OK
BADCH:}$.VCY_0;}#*NOP
}'GOTO WSTFIN ON Q _ M = 0, FETCH DISP(CARG2);
}'GOTO WSTOK ON M <0, M _ VR;
}'NSRFLAG_2, GOTO WSTLP;
*START OF PATCHES
SH1:}#SVR4 _ Z, M _ VR, GOTO 273B;
SH2:}#SVR2 _ Z, GOTO 361B;
SH3:}#SVR1 _ Z, GOTO 472B;
SH4:}#SVR3 _ Z, GOTO 650B;
SH5:}#SVR0 _ Z, GOTO 1066B;
SH6:}#SVR1 _ Z, GOTO 1506B;
SH7:}#GOTO 1074B, SVR0 _ Z;
PA1:}#Q _ Q LCY 8, GOTO RE1;
PA2:}#Q _ Q LCY 8, GOTO RE2;
}'GOTO 544B IF ATT2;
}'GOTO B2400;
}'Q _ 36B5, DRETURN;
}'GOTO WKOL ON M AND Q = 0;
}'GOTO WKPZ ON M AND Q # 0;
}'GOTO 1357B;
}'GOTO * IF NOREQ;
}'DGOTO RESTART, RESETCPU;
}'GOTO 1136B, FETCH;
}'VR _ M AND Q LCY 1, Q _ 776B5, GOTO 1016B;
}'ALERT, Z _ 2B7 + 103B;
}'PIN, Z _ E2, GOTO 1175B;
}'M _ M - 1;
}'Q _ M LCY 4, Z _ LBTBA;
}'Z _ Q + Z, GOTO 1515B;
}'SIGUTP, 2, GOTO 1167B;
}'Q _ 2B4, FETCH LDVTE;
}'GOTO RTSS4 ON M AND Q = 0;
}'M _ M AND NOT Q, STORE LDVTE, GOTO 1631B;
}'Z _ 23400B, POT, GOTO 130B;
}&RETURN ON Z < 0;
}'ALERT, Z _ 103B;
}'POT, Z _ 400B, GOTO 141B;
}'CALL 530B;
}'GOTO DID5;
}'DGOTO DID2, VR _ M, Q _ 7774B4;
}'GOTO DID3 ON M AND Q = 0;
}'GOTO 1270B, R0 _ SAVER0, M _ R0, STORE;
}'WD1 _ M, GOTO 1237B;
}'ORG 1640B;
}'LCWS1 _ 0, RETURN;
}'M _ M AND NOT Q LCY 12, GOTO GLE;
*}"PATCH TO ALLOW CHECKING FOR CTP
GOCTP:}#M _ MODE, .MS_53B;}$*SET BANK B SCRATCHPADS
}'RETURN ON M > 0;
}'GOTO 172B, Z _ 0, .MS_60B;}&*GOTO CTP AT 2172B
*PATCHES FOR 24 CHIO PORTS
}'ORG 1654B;
}'Z_42B, ALERT;
}'Z_M, POT, RETURN;
}'POT;
}'Z_42B, ALERT;
}'PIN, Z_ E2;
}'Q_Q LCY 8,DGOTO 166B;
}'Q_Q OR Z;
}'Z_42B, ALERT;
}'PIN, Z_ E2;
}'Q_Q LCY 8, DGOTO 262B;
}'Z _ Q OR Z, Q_ LBIT;
}'R0_M+1, FETCH, DGOTO INL2;
}'M_CHAR, RETURN ON M<0;
}'ORG 1677B;
}'CALL ABORT;
}'END;
*

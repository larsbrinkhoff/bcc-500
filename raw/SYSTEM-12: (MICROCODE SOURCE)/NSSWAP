*}"THE PHILOSOPHY OF STARTUP.


*}"WHEN IT COMES TIME TO SEND A COMMAND TO A TSU THE ROUTINES IN THIS
*}"PACKAGE ARE CALLED.}"THE DISKS AND DRUMS HAVE THE SAME PROPERTIES I.E.
*}$A.}"THERE ARE SEVERAL UNITS, ANY OF WHICH MAY BE SICK.
*}$B.}"A DATA STRUCTURE IS ASSOCIATED WITH EACH DEVICE CALLED A 
*}("SECTOR TABLE".
*}$C.}"IT IS BEST TO AVOID CHANGING UNITS IF POSSIBLE.


*}"BECAUSE OF THESE SIMILARITIES A PAIR OF ROUTINES CALLED GET FIRST
*}"DEVICE (GTFDV) AND DO STARTUP (DOSTART) DO MOST OF THE WORK OF THE
*}"STARTUP.}"GET FIRST DEVICE ALSO HAS AN ENTRY POINT AT GET NEXT NODE
*}"(GTNND).


*}"THE IDEA IS THEN THAT STARTUP FOR THE DRUM INITIALIZES A FEW
*}"SCRATCHPAD REGISTERS AND CALLS GET FIRST DEVICE.}"IF THIS ROUTINE 
*}"RETURNS THE DISK ADDRESS WILL BE IN M, THE CURRENT UNIT IN Z.}"BY
*}"DOING A DHT SEARCH THE UNIT # CAN BE COMPARED.}"IF THEY COMPARE (OR
*}"THE SEARCH FAILS), DOSTART IS CALLED.}"OTHERWISE, GET NEXT NODE IS
*}"CALLED.


*}"THE DISK STARTUP IS SIMILAR EXCEPT THAT THE COMPARISON IS MADE ON THE
*}"DISK UNIT #.}"THIS COMPARISON IS MADE SUCH THAT ADJACENT UNITS
*}"(EG 0,1) ARE TREATED AS THE SAME UNIT.}"NOTE THE CURRENT FIND 
*}"SECTOR ROUTINE COMPUTES THE SECTOR IMPROPERLY FOR A DUAL 
*}"POSITIONER DISK WHEN THE FUNCTIONAL UNIT IS CHANGED.}"IT WILL 
*}"CAUSE ONE WHOLE SECTOR TO BE MISSED.}"


*}"FEATURES AND IDIOSYNCRASIES


*}"THE FLAG WORD CONTAINS TWO BIT TABLES FOR DESIGNATING ACTIVE
*}"UNITS.}"BITS 20 THROUGH 23 REPRESENT DRUMS UNIT 0-3 RESPECTIVELY,
*}"AND BITS 16 THROUGH 19 REPRESENT DISK UNIT 0-3 RESPECTIVELY.


*}"IF IT IS DESIRED TO EXECUTE AN APU-CODED STARTUP ROUTINE A NEGATIVE
*}"NUMBER IS PLACED IN STAPUFLAG IN CORE.}"WHEN THIS OCCURS, THE GET 
*}"FIRST DEVICE ROUTINE NOTES THIS AND BRANCHES INTO THE DOSTART ROUTINE.
*}"P WILL BE EITHER APUREAD OR APUDISK DEPENDING ON THE TSU VALUE.
*}"WHEN STAPUFLAG=-1 THE FOLLOWING APU-CODE PRECEEDING THE NORMAL APU
*}"STARTUP ROUTINE WILL ALLOW ONE TSU TO BE STARTED BY THE MICROCODE:
*}%CSX SELUNIT; LDS SR5,=GTDV0; CALL FRET,Q;
*}"THE OTHER TSU MAY THEN BE STARTED BY WHATEVER METHOD DESIRED.


*}"WHEN THE APU CODE IS CALLED, THE NODE HAS BEEN REMOVED FROM ITS
*}"QUEUE, AND ITS POINTER IS IN A AND B.}"X CONTAINS THE REQUEST CODE.
*}"DIRECT I/O REQUESTS (CODES 4,5) ALWAYS CAUSE A STARTUP.


*}"IF A STARTUP CANNOT BE BEGUN ONE OF TWO THINGS OCCUR DEPENDING ON THE
*}"TSU NUMBER:
*}$1.}"A WRITE IS CONSIDERED FOR THE DRUM.}"IF THE WRITE LIST IS EMPTY
*}(THE TSU WILL IDLE.
*}$2.}"THE NUMBER OF DISK TRANSFERS IN THE SECTOR TABLE (NKT) IS CHECKED
*}(IF NKT#0 AND MAXCHECKNKT>=0.}"THIS CHECK MERELY INSURES
*}(THAT NKT WILL ALWAYS GO TO ZERO AFTER A SUFFICIENTLY LONG TIME.


*}"DOSTART NEVER RETURNS TO THE PLACE FROM WHICH IT WAS CALLED, HOWEVER
*}"IT DOES UNWIND THE STACK.}"THIS KLUDGE IS NECESSARY SINCE IT IS
*}"BRANCHED TO FROM THE GET FIRST DEVICE ROUTINE FOR DIRECT I/O.


*}"PROTECT 2 IS SET BY GET FIRST DEVICE BEFORE RETURNING THE DISK 
*}"ADDRESS.}"THEREFORE THE DHT SEARCH IS UNDER PROTECT 2.}"UNPROTECTS 
*}"ARE SCATTERED THROUGH THE CODE SUCH THAT PROTECT 2 IS RESET AFTER
*}"THE SEARCH IS COMPLETED.}"IT IS ALWAYS RESET BEFORE THE APU IS CALLED
*}"OR CONTROL RETURNED TO THE PROCESS ATTENTION ROUTINE AT RESUMESTARTUP.


*}"INITIALIZATION BY MONITOR

*}"THE MONITOR MUST INITIALIZE THE FOLLOWING REGISTERS AS FOLLOWS:

*}"NAME}(LOCATION}'CONTENTS}(COMMENT

*}"STAPUFLAG}&164}.0}#FAST STARTUP
*}A-1}#USE APU CODE
*}"NPAGSW})165}-?}$NUMBER OF PAGES IN SWAP SPACE
*}"NPAGQ}*166})777777}#NEW PAGE QUEUE
*}1167},161
*}"FLAGRG}(2523},314}#FLAG BITS FOR DRUM UNITS 0,1, 
*}FDISK UNITS 0,1
*}"DSRL}*2543}-?}$LOCATION OF DRUM SECTOR READ LIST
*}"MAXCHECKNKT}#2544},200?}"NUMBER OF DISK SECTORS BEFORE
*}FNKT RESET TO 0 WHEN ERRONEOUSLY
*}FNOT 0
*}A-1}#OR DO NOT CHECK NKT AT ALL
*}"DFPT}*2554}-?}$BASE ADDRESS OF FREE DRUM PAGE 
*}FTABLE (TABLE BEGINS AT 1 MOD 8)


*}"PATCH IN THE FSTR ROUTINE ALSO REQUIRES ONE OTHER CELL TO BE 
*}"INITIALIZED:

*}"FSTRPM}(2542}*10-14}#POSITION W/IN SECTOR AFTER WHICH
*}FFSTR FAILS


@SSWAP IDENT;
}'ORG 1400B;

*}"DECLERATIONS


*SCRATCHPAD PARAMETERS
}'SPM(DSRL);}6*DRUM SECTOR READ LIST BASE
}'SPM(MAXCHECKNKT);


*}"LOOP VARIABLES
}'SPM(SECTORQUEUES);}.*HOLDS SECTOR QUEUE BASE
}'SPM(DEVICEMASK);}0*BIT TO MASK FLAGRG FOR UNIT TEST
}'SPM(CURUNIT);
}'SPM(CQUEUE);
}'SPM(LASTNODE);
}'SPM(CHECKNKT);
}'SPM(SELUNIT);
}'SPM(FDPT);}6*FREE DRUM PAGE TABLE BASE ADDRESS
}'SPM(IDSEQ);}5*IDENTIFICATION SEQUENCE NUMBER
}'SPM(DHTPT);}5*DHT POINTER
}'SPM(DRUMAD);}4*DRUM ADDRESS
}'SPM(DHTST);}5*DHT STATE WORD
}'SPM(CHTPT);}5*CHT POINTER
}'SPM(PRTPT);}5*PRT POINTER
}'SPM(CWSI);}6*CWS INDEX
}'SPM(BCWS);}6*BASE OF CWS
}'SPM(BPMT);}6*BASE OF PMT
}'SPM(CWSPT);}5*PTR TO CWS ENTRY
}'SPM(CWSWD);}5*CWS WORD
}'SPM(PMTPT);}5*PTR TO PMT ENTRY
}'REG(SR2,SK10);}2*IMAGE HOLDING REGISTER IN SKP
}'REG(SR3,SK11);
}'REG(SR4,SK12);
}'REG(DKACMP,EW0);}0*DISK ADDRESS COMPARE FLAG, SIGN BIT
}'REG(MAXSOT,EW1);*}/*MAXIMUM NUMBER OF BITS IN SECTOR
}'REG(OLDAGE,EW3);}0*OLD CWS
}'REG(OCWSI,EW4);}1*OLD CWSI 
}G*OCCUPIED TABLE
}'REG(FA1,BR);*}3*FAIL ADDRESS # 1, USES BR


* PARAMETERS
}'PM(LASTDEVICE,3);}/*LAST DRUM 
}'PM(NKTER,152B);}1*CORE ADDRESS OF NKT ERRORS
}'PM(STAPUFLAG,164B);}-*CORE ADDRESS OF APU START FLAG
}'PM(APUREAD,3B);}1*ADRESS OF DRUM READ START ROUTINE
}'PM(APUDISK,11B);}0*ADDRESS OF DISK START ROUTINE
}'PM(SRKTSU,4B6);}3*SELECT REGISTER DISK TSU
}'PM(CDSDDT,4);}3*REQUEST CODE FOR DIRECT I/O STARTUP
}'PM(DKSLB,136B);}1*DISK SECTOR LIST BASE ADDRESS
}'PM(ACTQ,102B);}2* ACTIVATE QUEUE HEADER
}'PM(NCTX,153B);*}1*NUMBER OF CONTEXT BLOCK CONSIDERED
}'PM(KCQB,160B);*}1*DISK CYLINDER QUEUE
}'PM(RELQ,170B);}2*RELEASE QUEUE HEADER
}'PM(PMTDSP,300B-4);}.*PMT DISPLACEMENT IN CONTEXT BLOCK
}'PM(CWSDSP,2731B);}/*CWS DISPLACEMENT IN CONTEXT BLOCK
}'PM(PRST,8);}5*PRT STATUS INDEX
}'PM(AMCSTSBITS,11710B);}**PRT STATE BITS
}'PM(INCORM,24B6);}0*IN CORE MASK
}'PM(INSTC,60B);}1*INSTRUCTION FROM TSU
}'PM(STATC,77B);}2*STATUS REGISTER
}'PM(TSTAG,4B7);}2*TSU TAG ERROR
}'PM(TSUNE,2B7);}2*UNIQUE NAME DOES NOT COMPARE


*}"FIELDS

}'DF(DIORCD,4,18,22);}.*MAPS BOTH DIRECT I/O INTO
*}FONE CODE
}'DF(DISKADDRESS,2,2,23);
}'DF(DHTUNIT,0,22,23);
}'DF(FLAGDM0,0,20,20);},*FLAG FOR DRUM UNITS
}'DF(FLAGDK0,0,16,16);},*FLAG FOR DISK UNITS
}'DF(DKA,2,2,23);*}0DISK ADDRESS
}'DF(NCWS,2,0,23);*}/NUMBER OF CWS ENTRIES
}'DF(SOT,10,0,23);}0*SECTOR OCCUPIED TABLE
}'DF(RF,3,1,1);}3*REFERENCE FLAG
}'DF(UHIST,0,5,12);}/*USE HISTORY FIELD OF CWS
}'DF(AGEF,0,0,12);*}/*AGE FIELD
}'DF(IDCOD,5,0,3);}0*IDENTIFICATION CODE
}'DF(ERRF,0,12,23);}/*TSU ERROR FIELD IN STATUS REGISTER


*}"SPECIAL CONDITIONS
}'SC(BANKA,61B);}2*SET BANK A
}'SC(BANKB,60B);}2*SET BANK B


*}"GET FIRST DEVICE
FUNCTION(GTFDV), SECTORQUEUES_M;
}'Z_Z MRG TSFU, ALERT;
}'ADR_Z_PIN, Q_MASK(DHTUNIT);
}'Z_SELUNIT_Z AND Q, FETCH STAPUFLAG;
}'GOTO DOST0 ON M<0;

GTDV0: CURUNIT_Z;
}'M_SAVEPATI, Q_FINSTART, CALL FSTR;
}'Z_Q LCY 1, M_SECTORQUEUES;
}'CQUEUE_M_M+Z, Q_5, DGOTO GTDV1;
}'M_M-Q, Q_NADB;
*}"FIND NEXT NODE
GTNND: M_LASTNODE, Q_DISP(EQP), DGOTO GTDV1;
}'FETCH M+Q, Q_NADB;
GTDV1: LASTNODE_M_M AND NOT Q, Q_DISP(EQP);
}'FETCH M+Q, CALL STCSTK;
*}"QUEUE EMPTY?
}'ENDL(GTDV4,M), Q_NADB;
*}"STUFF POINTER TO NODE AWAY
}'T2_M_AR_M AND NOT Q, Q_DISP(RCD);
}'FETCH M+Q, Z_TSUNM MRG TSPC0, ALERT;
}'Q_PIN, Z_CDSDDT;
* INSURE CLEANUP NOT PENDING
}'GOTO FINSTART ON Q LCY 2 < 0, Q_MASK(DIORCD);
*}"DIRECT I/O?
}'DGOTO DOSTART ON M AND Q-Z=0, Q_MASK(RCD);
}'XR_M AND Q, Q_DISP(DISKADDRESS);
}'M_T2, PRO(2);
*}"RETURN W/DISK ADDRESS IN M AND PROTECT 2 SET
}'FETCH M+Q, Z_CURUNIT, R;


*}"ENTRY POINT INTO FUNCTION (CALL WITH C(DOSTART))
*}"BEGINS APU CODE FOR STARTUP
*}"AR,BR - POINTER TO NODE RELEASED
*}"XR CONTAINS REQUEST CODE
DOSTART: M_LASTNODE, UNPRO(2);
}'Q_CQUEUE, Z_PNT, CALL RELEQP;
DOST0: BR_Q, CALL SICONT;

*}"RETURN TO PROCESS ATTENTION STARTUP LOOP
FINSTART: Z_SAVEPATI, Q_X_2, UNPROTECT;
}'FRA(RESUMESTARTUP);

*}"FIND NEXT DRUM
GTDV4: Z_CURUNIT, ADR_0;
GTDV5: Z_Z+1, M_LASTDEVICE;
}'CALL SWITCH ON Z-M>0, M_SELUNIT;
}'GOTO NOREAD ON Z-M=0, M_FLAGRG;
}'M_M LCL Z, Q_DEVICEMASK, DGOTO GTDV0;
}'GOTO GTDV5 ON ADR_M AND Q=0;


*}"DRUM OR DISK TSU?
NOREAD: Q_SAVEPATI, FETCH NPGQ, DGOTO NKTOK;
}'GOTO STWRT ON Q-1<=0, Q_MAXCHECKNKT;
}'

*}"START DRUM WRITE
STWRT: P_NEWPAGE, DGOTO NPAGE;
}'BR_M, CALL SICONT IF NENDLT;


*}"CHECK NKT COUNT
NKTOK: GOTO FINSTART ON Q<0, M_NKT;
}'GOTO FINSTART ON M<=0, ADR_DKSLB;
}'Q_CHECKNKT, Z_-NKSECT, FETCH;
*}"LOOP WHICH SCANS DISK SECTOR TABLE
}'NENDL(NKTK0,M), ADR_ADR+1;
}'FETCH ADR+1, GOTO *-1 ON INC(Z)<0;
}'CHECKNKT_Q_Q+1;
}'Z_MAXCHECKNKT, DGOTO FINSTART;
*}"IS CHECK NKT TOO BIG?
}'GOTO *+1 ON Q-Z>0;
}'NKT_0, MIN(NKTER);
*}"RESET CHECK NKT
NKTK0: CHECKNKT_0, GOTO FINSTART;


* START DRUM
STDRUM: DEVICEMASK_MASK(FLAGDM0);
}'M_DSRL, DGOTO STDM1;
}'P_APUREAD, CALL GTFDV;

STDM0: C(GTNND);
*}"FIND DRUM ADDRESS, IF CANNOT DO START
STDM1: Z_STDM3, CALL DHTSCH;
}'FETCH Z, Q_MASK(DHTUNIT);
STDM2: Z_CURUNIT, UNPRO(2);
*}"CHECK UNIT NUMBER AGAINST CURRENT UNIT
}'GOTO STDM0 ON M AND Q - Z # 0;
STDM3: C(DOSTART);


*}"START DISK?
STDISK: DEVICEMASK_MASK(FLAGDK0);
}'M_DKSLB, DGOTO STDK1;
}'P_APUDISK, CALL GTFDV;

STDK0: C(GTNND);
STDK1: Q_X_2, UNPROTECT, DGOTO STDK0;}"*CONSECUTIVE UNITS ARE TREATED
}G*AS THE SAME UNIT
}'CALL STKLK ON M AND Q - Z = 0, SUBR_DOSTART;


*}"ROUTINE TO BE USED TO IMPLEMENT CONDITIONALS
SWITCH: Z_ADR, ADR_Z, RETURN;


*}"BLOCK COPY - NO OVERLAPPING BLOCKS
*}"R0 - SOURCE BLOCK
*}"Q - DESTINATION BLOCK
*}"Z - COUNT
BCOPY: FETCH, GOTO *+2;
BCOP0: R0_Q, Q_R0+1, FETCH;
}'R0_Q, Q_R0+1, STORE, DGOTO BCOP0;
}'RETURN ON Z_Z-1<=0;


*}"CYCLE Q BY AMOUNT IN Z
CYLQ:}"Q_Q LCH Z, DRETURN;
}'Q_Q LCL Z;


*}"FIND ENTRY IN DRUM FREE PAGE TABLE
*}"R1 - SECTOR
*}"R2 - UNIT
*}"RETURN}"R0 - ADDRESS OF ENTRY
*}+Q - R4
*}+Z - 24
FDPTE: M_R1, Z_24;
}'M_M LCY 3, Q_R2;
}'Q_Q LCY 1, Q_FDPT, DRETURN;
}'R0_M+Q, Q_R4;


*}"FIND BAND IN FREE DRUM PAGE TABLE
*}"FA0 - FAIL ADDRESS
*}"R1 - SECTOR
*}"R2 - UNIT
*}"CALL WITH C(FBFDPT) OR SCALL FBFDPT,FA0
*}"RETURN
*}"M - DRUM ADDRESS

FBFDPT: CALL FDPTE, R4_-48;
}'FETCH R0+1, GOTO FRA0 ON Q_Q+Z>0;
}'GOTO *-1 ON M=0, R3_0;
}'Z_M;
}'M_Z_M LCY 1, DGOTO *+1 IF Z>=0;
}'M_Z_M LCY 1, DGOTO * IF Z>=0, R3_R3+1;
}'M_R3, Z_23, GOTO *+1;
}'M_M+Q, Q_R1, DR;
}'M_M+Z, Z_R2, CALL *+1;
*}"NOW BAND IS IN M, SECTOR IN Q, UNIT IN Z.
*}"FALL THROUGH TO MAKE DRUM ADDRESS

MDRM:}"T_Q, Q_377B;
}'M_M AND Q LCL 5, Q_37B;
}'T_M LCH 5, M_T;
}'M_M AND Q, M_T;
}'M_M LCY 2, Q_3, DRETURN;
}'M_M AND NOT Q ! Z AND Q;


*}"PARSE DRUM ADDRESS
*}"M - DRUM ADDRESS
*}"CALL WITH C(PDRM) OR SCALL PDRM
*}"RETURN:
*}"R1 - SECTOR
*}"R2 - UNIT
*}"M - DRUM ADDRESS
*}"Q - BAND

PDRM:}"Q_3;
}'R2_M AND Q, Q_MASK(DSTR);
}'Q_M AND Q, Z_LDCY(DSTR), CALL CYLQ;
}'R1_Q, Q_MASK(DBND), DR;
}'Q_M AND Q, Z_LDCY(DBND), CALL CYLQ;


*}"CLEAR/SET DRUM FREE PAGE TABLE
*}"M - DRUM ADDRESS
*}"R3 - 0 FOR CLEAR
*}%- -1 FOR SET
*}"CALL WITH SCALL CSFDPT

CSFDPT: C(PDRM);
}'CALL FDPTE, R4_Q;
}'GOTO * ON Q_Q-Z>=0, R0_R0+1;
}'Z_0-Q, Q_4B7, CALL CYLQ, HFETCH;
}'R3_M AND Q, Z_R3;
}'M_M AND NOT Q ! Z AND Q, STORE;
}'Z_Z AND Q, Q_R3, DR;
}'PUNT ON Q EOR Z = 0;


*}"INCORE ROUTINE
*}"Z - PTR TO REAL NAME
*}"CALL WITH SCALL INCOR,FA0
*}"RETURN: M - STATUS, SCH WORD OF CHT ENTRY
*}*Q,Z - PTR TO CHT ENTRY
****}$PROTECT 2 IS LEFT SET BY THIS ROUTINE}#****
INCOR: HFETCH Z, Z_FRA0;
}'UN0_M, FETCH R0+1;
}'Q_M, FETCH R0+1;
}'DKACMP_X_40000002B, PROTECT, GOTO * IF PRONS;
}'T4_M, M_UN0, CALL CHTSCH;
}'CHTPT_Z, FETCH R0+1;},*PATCH *********
*}#NOTE THAT CHTPT_Z IS NOT INSTALLED YET (FOR 1.03)
}'M_M MRG NKAD, Q_T4, .TCY;
}'GOTO *+2 ON DKACMP_M EOR Q#0, Q_NADB;
}'Q_Z, FETCH R0+1, R;

*}"CONTINUE SCANNING CHT
}'C(CONSCN);
}'PUNT;
CONSCN: T_FRA0, GOTO CHTS0;


*}"CLEAR FLAG REGISTER BIT
*}"M - (BIT TO CLEAR) - 1

CFLG:}"Q_M+1, Z_FLAGRG, GOTO SFLG0;*********PATCH
*}#NOTE NOT INSTALLED YET (1.03)


*}"EXECUTE COMMAND
*}"M - DRUM ADDRESS (DEVICE ADDRESS + TSU# + UNIT#)
*}"Q - CHTPT}#==> WORD COUNT =4000B,UNIQUE NAME =$CHTPT
*}$- CHTPT,4}0=}"0}/=$CHTPT
*}$-}#0}4=}"0}/=}"0
*}$-}#1}4=}"1}/=}"0
*}"Z - INSTRUCTION
*}"CALL WITH SCALL EXEC

EXEC:}"T_Q, Q_MASK(DTSU);
}'T1_M AND Q, Q_MASK(DNUMR);
KEXC0: T4_M AND Q ! Z AND NOT Q, Q_IDSEQ, .TYW;
}'T3_M, Z_4B6;
}'IDSEQ_Q+Z, GOTO EXEC3 ON Z_T<0;
}'GOTO EXEC1 ON Z-1<=0, Q_DISP(PG);
}'FETCH Z+Q, Q_MASK(PG);
}'T2_M AND Q, Z_4000B;
EXEC0: R0_T+1, HFETCH, DGOTO EXEC2;
}'Q_M, FETCH T, DGOTO STSUI;
EXEC1: T2_M_Q_0, DGOTO STSUI;
EXEC2: R0_T1;
EXEC3: T2_Z_0, GOTO EXEC0;


* EXECUTE DISK COMMAND
* M - INTERNAL DISK ADDRESS
* Q - CHTPT (AS FOR Q ABOVE)
* T2 - INSTRUCTION
*}"CALL WITH SCALL KEXEC

WUEXEC: Q_Q MRG 4B7;
KEXEC: T_Q, Q_MASK(KTSU);
}'Q_M AND Q, Z_23, CALL CYLQ;
}'T1_Q, Q_MASK(KTRK);
}'T3_M AND Q LCY 2;
}'Q _ MASK(KBD);
}'Z_M AND Q LCY 1, Q_77B;
}'M_M AND Q ! Z AND NOT Q, M_T3, DGOTO KEXC0;
}'Z_T2, Q_MASK(DNUMR);


*}"SUCCESS/FAIL RETURN ACTIVATE
*}"AR - DATA WORD
*}"USE GOTO
SRACT: M_Q_AR_0, GOTO *+2;
FRACT: M_AR, Q_4B7+37B;
}'MIN(M AND Q MRG 200B);
}'M_AR, STORE ACTCL+1, DGOTO RET1;
}'M_Q, STORE ACTCL;


*}"REMOVE ENTRY FROM ACTIVATE QUEUE
*}"Z - FAIL ADDRESS
*}"USE CALL REACT,Z
*}"RETURN M,Q,Z,EPTR - PTR TO NODE
REACT: Q_ACTQ, CALL RTEQP;
REAC0: MDC(NFREL);
REAC1: M_EPTR_Z_Q, GOTO CALL3;


*}"REMOVE GENERAL RQUEST FROM GRQ
*}"USE CALL REGRQ
*}"RETURN M,Q,Z,EPTR - PTR TO NODE

REGRQ: Q_GRQ, DGOTO REAC0;
}'Z_PNT, CALL RTEQP;


*}"REMOVE ENTRY FROM APPROPRIATE CLEANUP QUEUE
*}"USE CALL RECLQ
*}"RETURN M,Q,Z,EPTR - PTR TO NODE

RECLQ: FETCH RELL MRG TSUSTATE, DGOTO REAC1;
}'Q_M, Z_PNT, CALL RTEQP;


*}"REMOVE ENTRY FROM CONTEXT BLOCK QUEUE
RCTXQ: MDC(NCTX);
}'DGOTO REAC1 ON M>=0, Q_CTXQ;
}'Z_PNT, CALL RTEQP;
}'M_0, STORE NCTX, GOTO REAC1;


*}"REMOVE ENTRY FROM SWAPIN QUEUE
RSWAP: Q_SWAPIN, DGOTO REAC0;
}'Z_RET1, CALL RTEQP;


*}"REMOVE ENTRY FROM RELEASE QUEUE
RRELQ: Q_RELQ, DGOTO REAC1; 
}'CALL RTEQP;


*}"FAIL ROUTINE
FRA1:}"GRA(FA1);


*}"RETURN DOING UNPROTECT
*}"USE GOTO

RET1:}"UNPRO(17B), R;


*}"RELEASE NODE AND RETURN
*}"EPTR - PTR TO NODE OR
*}'- 0
*}"USE GOTO IF RETURNING TO UCODE ROTINES OTHERWISE,
*}"USE SCALL FRENOD
FRENOD: Q_EPTR, UNPRO(17B), DR;
}'CALL SETFL ON Q#0;


*}"FIND DHT ENTRY
*}"EPTR - PTR TO NODE
*}"BR - FAIL ADDRESS
*}"FAILS IF DHT ENTRY DOES NOT EXIST
*}"OTHERWISE RETURNS WITH
*}"M,DRUMAD - DRUM ADDRESS
*}"Q,DHTST - DHT STATUS WORD
*}"Z,DHTPT - PTR TO DHT ENTRY

FDHT:}"M_EPTR, Q_DISP(DKA);
}'FETCH M+Q, Z_FRA1, CALL DHTSCH;
FDHT0: FETCH DHTPT_Z;
}'DRUMAD_Q_M, FETCH R0+1;
}'DHTST_T_M, DR;
}'M_Q, Q_T;


*}"APPEND OR STACK ON DRUM SECTOR READ LIST
*}"EPTR - PTR TO NODE
*}"DRUMAD,DHTST - DHT DATA
*}"Z - FAIL ADDRESS
*}"RETURN Z - PTR TO QUEUE IN DSRL

SDRD:}"M_DHTST, R1_Q_MASK(DSTR)+4B7, GOTO *+2;
ADRD:}"M_DHTST, R1_Q_MASK(DSTR);
}'GOTO FRZ ON M LCY 1>=0, M_DRUMAD;
}'Q_M AND Q, Z_LDCY(DSTR)+1, CALL CYLQ;
}'M_Q, Z_24*2;
}'GOTO *-1 ON Q_Q-Z>=0, Z_DSRL;
}'R2_M_M+Z, Q_EPTR;
}'CALL AELEQP ON R1>=0;
}'CALL SELEQP ON R1<0;
}'Z_R2, R;


*}"INITIALIZE CONTEXT BLOCK DESCRIPTOR TABLE}"(PRTPT,BPMT,BCWS)
*}"Z - PTR TO NODE CONTAINING PRT POINTER
*}"BR - FAIL ADDRESS
*}"USE SCALL ICBTBL,Q;
*}"FAILS IF CONTEXT BLOCK NOT IN CORE
*}"RETURNS: M - CWSI
*}"Q - CHT STATUS WORD FOR CONTEXT BLOCK
*}"Z - BCWS

ICBTBL: FA0_FRA1, CALL SPRTPT;
}'C(INCOR);
}'DKACMP_Q_INCORM;
}'GOTO FRA1 ON M AND Q # 0, Q_MASK(PG);
}'BPMT_M AND Q MRG PMTDSP;
}'R0_Z_BCWS_M AND Q MRG CWSDSP, DR;
}'Q_M, FETCH R0+1;


*}"CLEAR/SET SF
*}"M - INDEX OF CWS ENTRY
*}"SETS CWSI, CWSPT, CWSWD, PMTPT
*}"CLEARS OR SETS SF ACCORDING TO ENTRY POINT USED
*}"RETURNS PMT[3] IN M
*}*Q - OLD SF BIT

STSF:}"M_CWSI, R3_MASK(SF), GOTO *+4;
CLSF:}"M_CWSI, R3_0, GOTO *+3;
ICSF:}"CWSI_M, R3_0, GOTO *+2;
ISSF:}"CWSI_M, R3_MASK(SF);
}'Z_BCWS;
}'FETCH CWSPT_Z-M, Q_MASK(PMTF);
}'Q_M AND Q LCY 2, Z_BPMT;
}'CWSWD_M, M_DISP(SF);
}'PMTPT_Z_Z+Q;
}'HFETCH M+Z, Q_MASK(SF);
*}"FALL THROUGH TO SET/CLEAR SF


*}"SET/CLEAR N BITS IN M
*}"M - ORIGINAL WORD
*}"Q - MASK OF BITS TO REPLACE
*}"R0 - ADDRESS OF WORD
*}"R3 - REPLACEMENT BITS
*}"RETURN
*}"M - NEW WORD WHICH IS STORED AT R0
*}"Q - BITS WHICH WERE REPLACED

SCNBT: T_M AND Q, Z_R3;
}'M_M AND NOT Q ! Q AND Z, Q_T, STORE, RETURN;


*}"SET PRTPT
*}"Z - PTR TO NODE CONTAINING PROCESS TABLE PTR
*}"RETURN : Q,Z,PRTPT - POINTER TO PRT FOR PROCESS
*}&M - CONTENTS OF T
*}"USE CALL SPRTPT
SPRTPT: R3_M, Q_DISP(EPRT);
}'FETCH Z+Q, Q_NADB, DRETURN;
}'Q_Z_PRTPT_M AND NOT Q, M_T;


*}"MANIPULATE PROCESS STATUS BITS
*}"RETURN: M - PROCESS STATUS WORD
*}*Q - OLD VALUE OF BITS
*}"BITS AFFECTED: PGF, CBC, PDW, PQ, SWQ, LDD


*}"CLEAR/SET PROCESS STATUS BITS
*}"PRTPT - POINTER TO PROCESS TABLE
*}"R3 VALUE OF RESULTING AMC STATUS BITS
*}"USE CALL CSSTS
CSSTS: Z_PRTPT, M_PRST;
CSST0: FETCH M+Z, Q_AMCSTSBITS, GOTO SCNBT;

*}"CLEAR/SET PROCESS STATUS BITS
*}"EPTR - PTR TO NODE CONTAINING PRTPT
*}"M - VALUE OF RESULTING AMC STATUS BITS
*}"USE SCALL PSTS
PSTS:}"Z _ EPTR, T_PRST, CALL SPRTPT;
}'CALL CSST0;
}'R;


*}"READ PROCESS STATUS BITS
*}"Z - POINTER TO NODE CONTAINING PRTPT
*}"USE SCALL RSTS
RSTS:}"T_PRST, CALL SPRTPT;
}'FETCH M+Z, R;


*}"SET SECTOR OCCUPIED TABLE
*}"DRUMAD - DRUM ADDRESS
*}"PRTPT - PTR POINTER
*}"BR - FAIL ADDRESS

SSOT:}"M_DRUMAD, C(PDRM);
}'M_PRTPT, Z_DISP(SOT);
}'HFETCH M+Z;
}'Q_1, Z_R1, .LRN_4, CALL CYLQ;
SSOT0: R3_Q, CALL SCNBT;
}'Q, GOTO FRA1 IF BL#0, Z_MAXSOT;
}'Q_M-1, DGOTO *;
}'M_M AND Q, Q_INC(T1), GOTO *+1 IF BL=0;
}'R ON Z-Q>=0;
}'Q_R3, T1_M_0, GOTO SSOT0;


*}"AGE CORE WORKING SET
*}"PMTPT, CWSPT, CWSWD ALL REQUIRED TO BE ACCURATE
*}"MERGES REFERENCE FLAG INTO BIT 5 AND RIGHT SHIFTS}"THE USE HISTORY ONE
*}"BIT.}"RETURNS WITH NEW CWS WORD IN M

AGECWS: M_PMTPT, Q_DISP(RF), .LRN_3;*}"CLEAR R3
}'HFETCH M+Q, Q_MASK(RF), CALL SCNBT;
}'R3_Q RCY 4, Q_MASK(UHIST);
}'M_CWSWD, Z_23;
}'Q_M AND Q, R0_CWSPT, CALL CYLQ;
}'R3_Q, R3, .TYW;*}(****R3_Q MRG R3
}'Q_MASK(UHIST), CALL SCNBT;
}'CWSWD_M, R;


*}"COMPUTE OLDEST CWS ENTRY
OCWS:}"Q_CWSWD, M_MASK(AGEF);
}'Q_M AND Q RCY 4, M_OLDAGE;
}'RETURN ON Q-M>=0, M_CWSI;
}'OLDAGE_Q, DRETURN;
}'OCWSI_M;


*}"EXCHANGE MEMORY AND T
*}"R0 - ADDRESS IN MEMORY
*}"T - DATA TO STORE
*}"RETURN: Q,T - DATA FROM MEMORY

XMT:}#HFETCH, DRETURN;
}'Q_T_M, M_T, STORE;


*}"INCREMENT NCWS AND EXCHANGE CWS ENTRIES
*}"BCWS - BASE OF CORE WORKING SET
*}"CWSPT - POINTER TO ENTRY TO MOVE TO LAST POSITION
*}"RETURN: M - CWSI

XCWS:}"Z_BCWS, Q_DISP(NCWS);
}'MDC(Q+Z);
}'T1_R0_Z-M, CALL XMT;
}'R0_CWSPT, CALL XMT;
}'M_Q, STORE T1, DR;
}'M_CWSI;


*}"DRUM BASH ROUTINE
*}"THIS ROUTINE WILL RUN THE DRUM AT FULL SPEED PROVIDED IT IS STARTED
*}"CORRECTLY.}"
*}"IT USES THE FOLLOWING REGISTERS FOR PARAMETERS
*}"REL - BASE REGISTER OF TSU DUMP (AND APU STARTUP ROUTINE)

*}"AR - UNIQUE NAME 0 USED IN ALL TRANSFERS
*}"BR - UNIQUE NAME 1 USED IN ALL TRANSFERS
*}"SR1 - FIRST INSTRUCTION V UNIT NUMBER
*}"SR4 - SECOND INSTRUCTION V UNIT NUMBER
*}"SR2 - DEVICE ADDRESS (WHICH SHOULD HAVE 0 SECTOR FIELD)

*}"THE STRATEGY IS TO USE THE FIRST INSTRUCTION FOR 24 SECTORS (0-23), 
*}"THEN REINITIALIZE THE DRUM ADDRERS, CORE ADDRESS, AND SWAP
*}"INSTRUCTIONS, THEN LOOP.
*}"TWO COUNTERS ARE INCREMENTED BY THIS ROUTINE.}"IF AN ERROR OCCURS
*}"DURING EXECUTION CELL 4 IS INCREMENTED.}"EACH TIME AROUND
*}"THE BAND CELL 5 IS INCREMENTED.

DMBASH: M_AR, Z_4000B;
}'R3_Q_SR3;
}'SR3_Q+Z, R0_0;
}'Q_BR, C(STSUI);
}'Z_R1, T1_M_4B7, CALL GETPOS IF ATTS;
}'GOTO *-1 ON M<0, M_0;
}'R0_RELL MRG TSUSTATE+1, CALL DPTSU;
}'Z_R2, Q_MASK(ERRF);
}'M AND Q, MIN(Q_ONE(DSTR)) IF BL#0;
}'R2_M_Q+Z, Q_MASK(DSTR);
}'M_M AND Q, Q_ONE(DSTR)*24;
}'GOTO DMBASH ON M-Q<0, Q_SR4;
}'R1_Q, Q_R1;
}'SR4_Q, MIN(ONE(DSTR)+1);
}'R2_SR2, DGOTO DMBASH;
}'SR3_20000B;


*}"DECREMENT SCHEDULED COUNT
*}"M - CHT STATUS FIELD
*}"R0 - PTR TO CHT STATUS FIELD
*}"RETURN
*}"M, CHT STATUS - NEW CHT STATUS WORD

DSCH:}"T_Q, Q_MASK(SCH);
}'M AND Q, Q_T, RETURN IF BL=0;
}'M_M-1, STORE, RETURN;


}'CHECK 2000B;


*}"CONCATENATE STANDARD LISTS
*}"R0 - ADDRESS OF HEADER OF LIST MOVED
*}"R1 - ADDRESS OF HEADER OF DESTINATION LIST

CONC:}"HFETCH, Z_R0, Q_DISP(EQP);
}'R2_M, M_777777B, STORE, RETURN IF ENDLT;
}'HFETCH R0+1, AR_Z-Q;
}'Z_M, M_AR, STORE;
}'HFETCH R1+1, DGOTO CONC0;
}'R1_M+Q, Q_NADB, DGOTO *+1;
}'HFETCH R1, DRETURN;
CONC0: M_M AND Q ! Z AND NOT Q, Z_ R2, STORE;


*}"ERROR CHECK
*}"THIS ROUTINE CHECKS ALL SOURCES OF ERRORS
*}"IT SUCCEEDS IF THERE ARE NO ERRORS, OTHERWISE IT FAILS WITH A 
*}"BIT WORD STATING THE NATURE OF THE ERROR IN Q, AND THE TSU UN MRG IN M,
*}"Z CONTAINS EPTR
*}"BR - FAIL ADDRESS

ERRCK: FETCH RELL MRG STATC;
}'Q_MASK(ERRF);
*}"INITIALIZE ERROR STATUS WORD
}'T_M AND Q;
*}"TEST IDENTIFICATION CODE (IS MEANINGLESS IF RLV SET)
}'T1_Z_EPTR, Q_DISP(IDCOD);
}'FETCH Z+Q, Q_MASK(IDCOD);
}'Z_M, FETCH RELL MRG INSTC;
}'CALL SETBIT ON M AND Q - Z AND Q #0, Q_TSTAG;
*TEST UNIQUE NAME
}'FETCH Z_R0 MRG 6;
}'XR_Q_M, FETCH T1, CALL UNTEST;
}'FETCH R0+1, AR_Z-1;
}'Q_M, FETCH AR, CALL UNTEST;
*}"MERGE UN IN M FOR ZERO TEST
}'M_M, M_XR;
}'Q_T, DR, BANKA;
}'Q, Z_T1, GOTO FRA1 IF BL#0, BANKA;


*}"UNIQUE NAME TEST
UNTEST: RETURN ON M EOR Q = 0, Q_TSUNE;
*}"FALL THROUGH AND SET BIT 2B7 IN ERROR STATUS WORD


*SET BIT ROUTINE, MERGES BIT INTO T,Q

SETBIT: Q_T_T, Q_Q, .TXW, RETURN;


*}"SEARCH LIST ROUTINES
*}"BEGIN SEARCH
BSCHL: T1_M, Q_DISP(DKA);
}'FETCH Z+Q, Q_NADB;
}'EW2_M, M_T1, GOTO CHTS0-1, BANKA;


*}"TEST DISK ADDRESS
*}"FAIL IF DISK ADDRESS COMPARE
TSCH:}"FETCH R0+1;
}'M_M MRG NKAD, Q_EW2, .TCY, DGOTO FT, BANKA;
}'M EOR Q, Q_NADB, RETURN IF BL#0;


*}"MAKE NODE
*}"AR - REQUEST CODE
*}"T - FAIL ADDRESS
*}"EPTR - PTR TO REAL NAME
*}"RETURN:}"EPTR,Q,Z,R1 - PTR TO NODE
*}"USE CALL MNODE,T;

MNODE: Z_FT, CALL REFFL, BANKA;
}'R0_EPTR, Z_3, CALL BCOPY, BANKA;
}'Q_CWSI, Z_18, CALL CYLQ, BANKA;
}'M_PRTPT, R2_Q;
}'STORE Q_R0+1;
}'M_R2, .SSP_5, .TSPY, STORE Q+1;
}'Q_R1, GOTO REAC1, BANKA;


*}"ENTER CHT ENTRY
*}"M - BITS TO MERGE INTO STATUS WORD IN CHT ENTRY
*}"Z - PTR TO CHT ENTRY (CLEAN)
*}"EPTR - PTR TO NODE CONTAINING REAL NAME

ECHTE: Q_M, M_DISP(SCH);
}'HFETCH Z+M;
}'M_M OR Q, STORE;
}'HFETCH EPTR;
}'Q_M, FETCH R0+1;
}'UN1_M, FETCH R0+1;
}'EW2_M;
}'M_Q, Q_UN1;
}'M OR Q, GOTO FRA0 IF BL=0;
}'CHTPT_Z, CALL ECHT, BANKA;
}'Q_Z_CHTPT, R, BANKA;


*}"FETCH DISK ADDRESS FROM NODE

GDISK: Z_EPTR, M_DISP(DKA), DRETURN;
}'FETCH M+Z;


*}"QUEUE ENTRY ONTO DISK SECTOR LIST
*}"EPTR - PTR TO ENTRY
QKSL:}"Q_MASK(KSTR), CALL GDISK;
}'Q_M AND Q, Z_23, CALL CYLQ, BANKA;
}'Z_NKSECT*2, CALL MOD, BANKA;
}'Z_KSQ, DR, BANKA;
}'M_M+Z, Q_EPTR, CALL AELEQP, BANKA;


*}"QUEUE ENTRY ONTO DISK CYLINDER QUEUE
*}"EPTR - PTR TO ENTRY

QKCYL: Q_MASK(KTRK), CALL GDISK;
}'Q_M AND Q, Z_LDCY(KTRK), CALL CYLQ, BANKA;
}'Z_NKCQ, CALL MOD, BANKA;
}'Q_M, FETCH KCQB;
}'FETCH M+Q, Q_NADB;
}'T_M, Z_EPTR, CALL AEL0, BANKA;
}'M_MASK(STKCQ)-1, CALL CFLG, BANKA;
}'KCQCNT_-NKCQ, R, BANKA;
}'CALL PNT, BANK A;


}'END;

}(PROGRAM ACQPMT;
}*INCLUDE PROFILE, SPTD, PMTD, GLOBAL;
}*DECLARE NAME, MEC, MEM;
*
}(FUNCTION ACQPMT(PMTX), FRETURN, MONITOR _ 50;
}*NAME _ SPNAME; GOTO ACQ05;
*}"ENTRY POINT FOR MONITOR
}(ENTRY MACQPMT(PMTX, NAME), FRETURN;
*}"LOOK FOR A FREE PMT ENTRY IF PMTX = -1.
ACQ05:}$IF PMTX=-1 DO;
}-FOR PMTX_1 TO NPMTE DO;
}0GOTO ACQ10 IF PMT[PMTX]$PMTCL=0;
}-ENDFOR;
}-PMTX _ FREE'PMT(//FRETURN(MEC, MEM):MEC, MEM);
}*ENDIF;
*}"INITIALIZE THE PMT ENTRY.
ACQ10:}$FRETURN('PMI', 110) UNLESS (1<=PMTX AND PMTX<=NPMTE);
}*FRETURN('PMA', 119) IF PMT[PMTX]$PMTCL#0;
}*PMT[PMTX]_ LONGLONG'ZERO;
}*PMT[PMTX]$PMTAL_NAME;
}*PMT[PMTX]$PMTCL_NAME;
*
}*RETURN PMTX;

}(END;

}(PROGRAM NPPMT;
}*INCLUDE PROFILE, PMTD, SPTD, SWPD, RESMON, GLOBAL, APTD;
}*DECLARE ARRAY REQ[LSWQN];
}*DECLARE KEY, STATUS, NODE, T, MEC, MEM, PMTE, APTE;
*
}(FUNCTION NPPMT(PMTX), FRETURN, MONITOR _ 51;
}*KEY _ SPKEY; STATUS _ SPSTATUS; GOTO NP10;
*}"ENTRY POINT FOR MONITOR
}(ENTRY MNPPMT(PMTX, KEY, STATUS), FRETURN;
*}"CHECK FOR ERRORS
NP10:}%FRETURN('PMI',110) UNLESS (1<=PMTX AND PMTX<=NPMTE);
}*PMTE _ @PMT[PMTX];
}*FRETURN('PMC',121) IF (KEY A' PMTE.PMTCL)=0;
}*FRETURN('PMF',122) UNLESS PMTE.PMTDKA=0;
}*FRETURN('DWF',123) IF (LDWS=OLDWS AND STATUS$DDWSO=0);
}*FRETURN('CWF',124) IF (LCWS=OLCWS AND STATUS$DCWSO=0);
*!!}'FRETURN('KSE',125) IF RSE[0]$DKSP=0;
*}"MAKE ROOM IN CWS AND DWS IF NECESSARY
}*DPCWS(-1//VALUE PUNT(MEC):MEC, MEM) IF LCWS=OLCWS;
}*DPDWS(-1//VALUE PUNT(MEC):MEC, MEM) IF LDWS=OLDWS;
*}"SET-UP PMT[PMTX]
}*PMTE.PMTUN _ PMT[1]$PMTUN;* USE CB'S UNIQUE NAME
}*PMTE.PMTINDEX _ PMTX;* WITH PMT INDEX OVERWRITTEN
}*PMTE.PMTDKA _ GET'DISK'ADDR(PMT[1]$PMTDKA//NP81);
}*PMTE.PMTRO _ 0;
}*PMTE.PMTSF _ 0;
}*PMTE.PMTRF _ 0;
}*PMTE.PMTNC _ 0;
}*PMTE.PMTCCE _ 0;
}*PMTE.PMTFP_0;
}*GOTO NP20;*}"JUMP AROUND SPECIAL ENTRY POINT
*}"SPECIAL ENTRY POINT FOR FILE SYSTEM
}(ENTRY NFPPMT(PMTX), FRETURN;
}*KEY _ MKEY; STATUS _ MSTATUS;
*}"SEND REQUEST FOR NEW PAGE TO AMC
NP20:}%NODE _ @REQ[0];
}*BSET(NODE, 0, LSWQN);
}*NODE.SWUN_PMTE.PMTUN;
}*NODE.SWDKA_PMTE.PMTDKA;
}*NODE.SWWAKF _ 1;* REQUEST A WAKEUP
}*NODE.SWRCD _ CRGFP;
NP25:}%SWPREQ(REQ, 0//NP82: MEC, MEM);
*}"SET SF, PUT PAGE IN APT, CLEAR IT TO 0.
}*PMTE.PMTSF_1;
}*APTE _ (-1)@APTUH V' 1@APTDWS V' 1@APTCWS V' PMTX;
}*MAKE'APT'ENTRY(APTE//VALUE PUNT('APT'));
}*T_RDPRMB(MSC1);
}*SETPRMB(MSC1,PMTX);
}*BSET(PAGESA(MSC1), 0, 2048);
}*SETPRMB(MSC1,T);
}*RETURN;
*}"ERROR RETURN FROM DISK ALLOCATOR
NP81:}%PUNT('KAL');
*}"AMC REJECTED THE REQUEST FOR A NEW PAGE FOR ONE OF THE FOLLOWING
*}"REASONS.
*}"(1) UNER - THERE IS ALREADY A CHT ENTRY WITH OUR 'NEW' UNIQUE
*}&NAME IN IT.}"PUNT.
*}"(2) DKINU - THERE IS ALREADY A DHT ENTRY WITH OUR 'FREE' DISK ADDRESS
*}&IN IT.}"PUNT.
NP82:}%PUNT('PAE') IF MEM=UNER;
}*PUNT('KBT') IF MEM=DKINU;
}*PUNT('AME');

}(END;

}(PROGRAM RNPMT;
}*INCLUDE SPTD, GLOBAL, PMTD, PROFILE;
}*DECLARE PMTE;
}(FUNCTION RNPMT(PMTX,LONG UNQN, INTEGER DKA), FRETURN,
}PMONITOR _ 52;
*}"CHECK FOR ERRORS
}*FRETURN('STS',127) UNLESS SPSTATUS$SD;
}*FRETURN('PMI',110) UNLESS (1<=PMTX AND PMTX<=NPMTE);
}*PMTE _ @PMT[PMTX];
}*FRETURN('PMC',121) IF (SPKEY A' PMTE.PMTCL) = 0;
}*FRETURN('PMF',122) IF PMTE.PMTDKA#0;
}*FRETURN('ARG',999) IF DKA=0;
*}"PUT REAL NAME INTO PMT[PMTX]
}*PMTE.PMTUN_UNQN;
}*PMTE.PMTDKA_DKA;
}*PMTE.PMTRO_0;
}*PMTE.PMTSF_0;
}*PMTE.PMTRF_0;
}*PMTE.PMTNC_0;
}*PMTE.PMTCCE _ 0;
}*PMTE.PMTFP_1;*}"TREAT LIKE FILE PAGE
*
}*RETURN;

}(END;

}(PROGRAM CLRPMT;
}*INCLUDE PROFILE, SPTD, PMTD, GLOBAL;
}*DECLARE KEY, MEC, MEM, PMTE, RF, AL, CL;
*
}(FUNCTION CLRPMT(PMTX), FRETURN, MONITOR _ 53;
}*KEY _ SPKEY; GOTO CLR10;
*}"ENTRY POINT FOR MONITOR
}(ENTRY MCLRPMT(PMTX, KEY), FRETURN;
*}"CHECK FOR ERRORS
CLR10:}$FRETURN('PMI',110) UNLESS (1<=PMTX AND PMTX<=NPMTE);
}*PMTE _ @PMT[PMTX];
}*FRETURN('PMC',121) IF KEY A' PMTE.PMTCL=0;
*}"RELEASE PAGE FROM DWS, AND DESTROY IT IF IT IS PRIVATE MEMORY.
}*MDPDWS(PMTX, KEY//VALUE PUNT(MEC):MEC,MEM);
}*IF (PMTE.PMTDKA#0 AND PMTE.PMTFP=0) DO;
}-DESTROY'PAGE(PMTE.PMTDKA, PMTE.PMTUN//
}0VALUE PUNT(MEC): MEC, MEM);
}*ENDIF;
*}"CLEAR PMT[PMTX] EXCEPT FOR CL AND AL AND
*}"CLEAR PHYSICAL MAP IF REFERENCE FLAG IS SET.
}*RF _ PMTE.PMTRF;
}*AL _ PMTE.PMTAL;
}*CL _ PMTE.PMTCL;
}*PMT[PMTX] _ LONGLONG'ZERO;
}*PMTE.PMTAL _ AL;
}*PMTE.PMTCL _ CL;
}*IF RF DO;
}-CLEAR'MAP;
}*ENDIF;
}*RETURN;
*

}(END;

}(PROGRAM DELPMT;
}*INCLUDE PROFILE, SPTD, PMTD, GLOBAL;
}*DECLARE KEY, I, LMAP, J;
}*DECLARE MEC, MEM, LM, SPTE, PRME;
}*DECLARE FIXED FIELD B0'11(0:0,11), B12'23(0:12,23),
}-BYTE0(0:4,11), BYTE1(0:16,23);
*
}(FUNCTION DELPMT(PMTX), FRETURN, MONITOR _ 54;
}*KEY _ SPKEY; GOTO DEL10;
*}"ENTRY POINT FOR MONITOR
}(ENTRY MDELPMT(PMTX, KEY), FRETURN;
*}"CHECK FOR ERRORS
DEL10:}$FRETURN('PMI',110) UNLESS (1<=PMTX AND PMTX<=NPMTE);
}*FRETURN('PMC',121) IF KEY A' PMT[PMTX]$PMTCL=0;
*}"FIRST CLEAR PMT[PMTX]
}*MCLRPMT(PMTX, KEY//VALUE PUNT(MEC):MEC,MEM);

*}"PMTX MUST NOW BE REMOVED FROM ALL MAPS, DAMMIT.
*}"THE PROCESS MAP:
}*FOR I _ 0 TO 63 DO;
}-IF (PRME _ PRMAP[I]) # 0 DO;
}0PRMAP[I]$B0'11 _ 0 IF PRME$BYTE0=PMTX;
}0PRMAP[I]$B12'23 _ 0 IF PRME$BYTE1=PMTX;
}-ENDIF;
}*ENDFOR;
*}"THE SUB-PROCESS MAPS:
}*FOR I _ 1 TO NSPTE DO;
}-IF SPT[I]$SPTOL#0 DO;
}0SPTE _ @SPT[I];
}0LMAP _ SPTE.SPTLM;
}0LM _ 0;
}0FOR J _ 0 TO LMAP DO;
}3IF SPTE.(PXFLDS[J])=PMTX DO;
}6SPTE.(PXFLDS[J]) _ 0;
}6SPTE.(ROFLDS[J]) _ 0;
}3ENDIF;
}3LM _ J IF SPTE.(PXFLDS[J])#0;
}0ENDFOR;
}0SPTE.SPTLM _ LM;
}-ENDIF;
}*ENDFOR;

*}"FINALLY, FREE PMT[PMTX].
}*PMT[PMTX]$PMTAL _ 0;
}*PMT[PMTX]$PMTCL _ 0;
}*RETURN;
*

}(END;

}(PROGRAM SPMTAL;
}*INCLUDE PROFILE, SPTD, PMTD, GLOBAL;
}*DECLARE KEY;
*
}(FUNCTION SPMTAL(PMTX,AL), FRETURN, MONITOR _ 55;
}*KEY _ SPKEY; GOTO SAL10;
*}"ENTRY POINT FOR MONITOR
}(ENTRY MSPMTAL(PMTX, AL, KEY), FRETURN;
*}"CHECK FOR ERRORS
SAL10:}$FRETURN('PMI',110) UNLESS (1<=PMTX AND PMTX<=NPMTE);
}*FRETURN('PMC',121) UNLESS
}-(KEY A' PMT[PMTX]$PMTCL#0 OR
}-(KEY A' PMT[PMTX]$PMTAL#0 AND
}0(PMT[PMTX]$PMTAL A' N' AL) A' N' KEY=0));
*}"DO IT.
}*PMT[PMTX]$PMTAL_AL;
*
}*RETURN;

}(END;

}(PROGRAM SPMTCL;
}*INCLUDE PROFILE, SPTD, PMTD, GLOBAL;
}*DECLARE KEY, MEC, MEM;
*
}(FUNCTION SPMTCL(PMTX, CL), FRETURN, MONITOR _ 56;
}*KEY _ SPKEY; GOTO SCL10;
*}"ENTRY POINT FOR MONITOR
}(ENTRY MSPMTCL(PMTX, CL, KEY), FRETURN;
*}"CHECK FOR ERRORS
SCL10:}$FRETURN('PMI',110) UNLESS (1<=PMTX AND PMTX <=NPMTE);
}*FRETURN('PMC',121) IF KEY A' PMT[PMTX]$PMTCL = 0;
*}"RELEASE PMT[PMTX] IF CL GOES TO 0.
}*MDELPMT(PMTX,KEY//VALUE PUNT(MEC):MEC,MEM) IF CL=0;
}*PMT[PMTX]$PMTCL_CL;
*
}*RETURN;
*

}(END;

}(PROGRAM SPMTRO;
}*INCLUDE GLOBAL, PMTD, PROFILE, SPTD;
*
}(FUNCTION SPMTRO(PMTX,RO), FRETURN, MONITOR _ 57;
*}"CHECK FOR ERRORS
}*FRETURN('PMI',110) UNLESS (1<=PMTX AND PMTX<=NPMTE);
}*FRETURN('PMC',121) IF SPKEY A' PMT[PMTX]$PMTCL = 0;
}*FRETURN('FPR',135) IF (PMT[PMTX]$PMTRO=1
}-AND PMT[PMTX]$PMTFP=1 AND
}0RO@PMTRO=0);
*}"SET/RESET THE BIT AND CLEAR THE PHYSICAL MAP IF NECESSARY
}*PMT[PMTX]$PMTRO_RO;
}*IF PMT[PMTX]$PMTRF DO;
}-CLEAR'MAP;
}*ENDIF;
}*RETURN;

}(END;

}(PROGRAM READPMT;
}*INCLUDE GLOBAL, PMTD, APTD, PROFILE;
}*DECLARE I;
*
}(FUNCTION READPMT(PMTX, ARRAY PMTE), FRETURN, MONITOR _ 58;
*}"CHECK FOR ERRORS
}*FRETURN('PMI',110) UNLESS (1<=PMTX AND PMTX<=NPMTE);
}*PMTE[I] _ (@PMT[PMTX])[I] FOR I _ 0 TO LPMTE-1;
}*PMTE[LPMTE] _ GET'APT'ENTRY(PMTX//VALUE 0);
}*RETURN;

}(FUNCTION READ'APT(APTX), FRETURN, MONITOR _ 72;
}*FRETURN('API',164) UNLESS (1<=APTX AND APTX<=NAPTE);
}*RETURN APT[NAPTE-APTX+1];

}(END;

}(PROGRAM AGE'APS;
*
*}"MAINTAIN USE HISTORIES FOR ACTIVE PAGES
*
*}"IF THIS ROUTINE NEEDS TO BE MORE EFFICIENT IT CAN BE CODED AS FOLLOWS.
*})FOR I _ NAPTE BY -1 TO NAPTE-LDWS+1 DO;
*},.EAX APT[I], LDX $APTPMT, EAX $PMT, LDA 0, XMA $PMTRF;
*},.LSHA LAPTUH, EAX APT[I], IOR $APTUH, LSHA -1, STA $APTUH;
*})ENDFOR;
}*INCLUDE APTD, PROFILE, PMTD, GLOBAL;
}*DECLARE I;
}(FUNCTION AGE'APS();
*
}*FOR I_NAPTE BY-1 TO NAPTE-LDWS+1 DO;
}-APT[I]$APTUH _ ((PMT[APT[I]$APTPMT]$PMTRF LSH LAPTUH) V'
}=APT[I]$APTUH) RSH 1;
}-PMT[APT[I]$APTPMT]$PMTRF_0;
}*ENDFOR;
}*CLEAR'MAP;
}*RETURN;

}(END;

}(PROGRAM OLDEST'PAGE;
*}$THIS PROGRAM FINDS THE 'OLDEST' ENTRY IN APT WHICH SATISFIES THE
*}"CONDITION SPECIFIED BY THE TWO ARGUMENTS, MASKA AND MASKB.}"MASKA
*}"SELECTS BITS IN AN APT ENTRY, MASKB SPECIFIES THE VALUES THE
*}"SELECTED BITS SHOULD HAVE.}"THE ROUTINE FINDS THE 'OLDEST' ENTRY,
*}"APTE, FOR WHICH (APTE AND MASKA)=MASKB.}"IT RETURNS
*}"THIS ENTRY.}"IT FAILS IF THERE ARE NO SUCH ENTRIES.
*}$THE PAGE LOCK FIELD IS GIVEN SPECIAL TREATMENT.
}*INCLUDE APTD, GLOBAL, PROFILE, PMTD;
}*DECLARE OLDEST, T, I, AGE, PGL, FLAG;
}(ENTRY FIND'OLDEST'PAGE(MASKA, MASKB), FRETURN;
}*FLAG _ 0; GOTO OLDST05;
*
}(FUNCTION OLDEST'PAGE(MASKA, MASKB), FRETURN;
}*FLAG _ 1;
OLDST05:}"MASKB _ MASKB A' MASKA;
}*PGL _ (-1)@APTPGL A' N' MASKA;
}*MASKA _ MASKA V' PGL;
}*OLDEST _ 0;
}*T _ (1 LSH LAPTUH) V' (-1)$APTUH;
OLDST10:}"FOR I _ NAPTE BY -1 TO NAPTE-LDWS+1 DO;
}-IF APT[I] A' MASKA=MASKB DO;
}0AGE _ (PMT[APT[I]$APTPMT]$PMTRF LSH LAPTUH) V'
}3APT[I]$APTUH;
}0(T _ AGE & OLDEST _ I) IF AGE<=T;
}-ENDIF;
}*ENDFOR;
}*IF OLDEST=0 DO;
}-FRETURN IF PGL=0;
}-MASKA _ MASKA A' N' PGL;
}-PGL _ 0;
}-GOTO OLDST10;
}*ENDIF;
*
}*RETURN (APT[OLDEST] IF FLAG ELSE OLDEST);
*

}(END;

}(PROGRAM GET'APT'ENTRY;
}*INCLUDE PROFILE, APTD;
}*DECLARE I, FLAG;
*
}(ENTRY GET'APT'ENTRY(PMTX), FRETURN;
}*FLAG _ 1; GOTO GAP10;
}(ENTRY FIND'APT'ENTRY(PMTX), FRETURN;
}*FLAG _ 0;
GAP10:}$FOR I _ NAPTE BY -1 TO NAPTE-LDWS+1 DO;
}-GOTO GAP20 IF APT[I]$APTPMT=PMTX;
}*ENDFOR;
}*FRETURN;
GAP20:}$RETURN(APT[I] IF FLAG ELSE I);

}(END;

}(PROGRAM DELETE'APT'ENTRY;
}*INCLUDE PROFILE, APTD;
}*DECLARE APTX, LAST'CWS, LAST'DWS;
*
}(ENTRY DELETE'APT'ENTRY(PMTX);
}*APTX _ FIND'APT'ENTRY(PMTX//RETURN);
}*LAST'CWS _ NAPTE-LCWS+1;
}*LAST'DWS _ NAPTE-LDWS+1;
}*IF APTX>=LAST'CWS DO;
}-APT[APTX] _ APT[LAST'CWS];
}-APT[LAST'CWS] _ APT[LAST'DWS];
}-APT[LAST'DWS] _ 0;
}-LCWS _ LCWS-1;
}-LDWS _ LDWS-1;
}*ELSEIF APTX>=LAST'DWS DO;
}-APT[APTX] _ APT[LAST'DWS];
}-APT[LAST'DWS] _ 0;
}-LDWS _ LDWS-1;
}*ELSE DO;
}-PUNT('APT');
}*ENDIF;
}*RETURN;

}(END;

}(PROGRAM MAKE'APT'ENTRY;
}*INCLUDE PROFILE, APTD;
}*DECLARE FIRST'NOT'CWS, FIRST'FREE, APTX;
*
}(ENTRY MAKE'APT'ENTRY(APTE), FRETURN;
}*DELETE'APT'ENTRY(APTE$APTPMT);
}*FRETURN IF LDWS>=NAPTE;
}*FIRST'NOT'CWS _ NAPTE-LCWS;
}*FIRST'FREE _ NAPTE-LDWS;
}*IF APTE$APTCWS DO;
}-APT[FIRST'FREE] _ APT[FIRST'NOT'CWS];
}-APT[FIRST'NOT'CWS] _ APTE;
}-APTX _ FIRST'NOT'CWS;
}-LCWS _ LCWS+1;
}-LDWS _ LDWS+1;
}*ELSEIF APTE$APTDWS DO;
}-APT[FIRST'FREE] _ APTE;
}-APTX _ FIRST'FREE;
}-LDWS _ LDWS+1;
}*ELSE DO;
}-APTX _ 0;
}*ENDIF;
}*RETURN APTX;

}(END;

}(PROGRAM PPDWS;
}*INCLUDE PROFILE, SPTD, PMTD, GLOBAL, APTD;
}*DECLARE MEC, MEM, IN'DWS, APTE, KEY, STATUS;
}*MACRO DWS'FULL _ (LDWS>=OLDWS);
*
}(FUNCTION PPDWS(PMTX), FRETURN, MONITOR _ 65;
}*KEY _ SPKEY; STATUS _ SPSTATUS;
*}"CHECK FOR ERRORS
}*FRETURN ('PMI', 110) UNLESS (1<=PMTX AND PMTX<=NPMTE);
}*FRETURN('PMC', 121) IF KEY A'
}-(PMT[PMTX]$PMTCL V' PMT[PMTX]$PMTAL) = 0;
}*GOTO PDWS10;
*}"ENTRY POINT FOR MONITOR
}(ENTRY MPPDWS(PMTX, KEY, STATUS), FRETURN;
*}"MAKE ROOM IN DWS IF NECESSARY
PDWS10:}#APTE _ 0;
}*IN'DWS _ 1;
}*APTE _ GET'APT'ENTRY(PMTX//VALUE IN'DWS _ 0);
}*IF DWS'FULL DO;
}-IF NOT IN'DWS DO;
}0FRETURN('DWF', 133) IF STATUS$DDWSO=0;
}0DPDWS(-1//PDWS80: MEC, MEM);
}-ENDIF;
}*ENDIF;
*}"BRING IN THE PAGE AND MAKE APT ENTRY.
}*IF (APTE$APTDWS=0 AND PMT[PMTX]$PMTDKA#0) DO;
}-GETDP(PMTX//PDWS81:MEC, MEM);
}*ENDIF;
}*APTE _ APTE V' (-1)@APTUH V' 1@APTDWS V' PMTX@APTPMT;
}*MAKE'APT'ENTRY(APTE//VALUE PUNT('APT'));
}*RETURN;

*}"ATTEMPT TO MAKE ROOM IN DWS FAILED
PDWS80:}#FRETURN('RDW', 212) IF (MEC='WSL' OR MEC='PGL' OR
}-MEC='DME' OR MEC='DKE' OR MEC='DWE');
}*PUNT(MEC);

*}"COULDN'T BRING THE PAGE IN
PDWS81:}#FRETURN(MEC, MEM) IF (MEC='RNE' OR MEC='DME' OR MEC='DKE');
}*PUNT(MEC);

}(END;

}(PROGRAM PPCWS;
}*INCLUDE PROFILE, SPTD, APTD, GLOBAL;
}*DECLARE MEC, MEM, APTE, KEY, STATUS, IN'DWS;
}*MACRO CWS'FULL _ (LCWS>=OLCWS);
}*MACRO IN'CWS _ (APTE$APTCWS);
*
}(FUNCTION PPCWS(PMTX), FRETURN, MONITOR _ 66;
}*KEY _ SPKEY; STATUS _ SPSTATUS;
}*FRETURN('PMI', 110) UNLESS (1<=PMTX AND PMTX<=NPMTE);
}*FRETURN('PMC', 121) IF KEY A'
}-(PMT[PMTX]$PMTCL V' PMT[PMTX]$PMTAL)=0;
}*GOTO PCWS10;
*}"ENTRY POINT FOR MONITOR
}(ENTRY MPPCWS(PMTX, KEY, STATUS), FRETURN;
PCWS10:}#APTE _ 0;
}*IN'DWS _ 1;
}*APTE _ GET'APT'ENTRY(PMTX//VALUE IN'DWS _ 0);
}*IF NOT IN'DWS DO;
}-FRETURN('NOD', 208) IF STATUS$DPNOD=0;
}-MPPDWS(PMTX,KEY, STATUS//PCWS80: MEC,MEM);
}-APTE _ GET'APT'ENTRY(PMTX//VALUE PUNT('APT'));
}-PUNT('APT') IF APTE$APTDWS=0;
}*ENDIF;
*}"MAKE ROOM IN CWS IF NECESSARY
}*IF CWS'FULL DO;
}-IF NOT IN'CWS DO;
}0FRETURN('CWF', 132) IF STATUS$DCWSO=0;
}0DPCWS(-1//PCWS81:MEC, MEM);
}0APTE _ GET'APT'ENTRY(PMTX//VALUE PUNT('APT'));
}-ENDIF;
}*ENDIF;
*}"UPDATE THE PAGE'S ENTRY IN APT.
}*APTE _ APTE V' (-1)@APTUH V' 1@APTCWS;
}*MAKE'APT'ENTRY(APTE//VALUE PUNT('APT'));
}*RETURN;

*}"COULDN'T PUT THE PAGE IN DWS
PCWS80:}#FRETURN(MEC, MEM) IF (MEC='DWF' OR MEC='RDW' OR MEC='RNE' OR
}-MEC='DME' OR MEC='DKE');
}*PUNT(MEC);

*}"COULDN'T MAKE ROOM IN CWS
PCWS81:}#FRETURN(MEC, MEM) IF (MEC='CWE' OR MEC='WSL');
}*PUNT(MEC);


}(END;

}(PROGRAM DPDWS;
}*INCLUDE GLOBAL, PMTD, APTD, PROFILE, SPTD;
}*DECLARE APTE, KEY, MEC, MEM;
*
}(FUNCTION DPDWS(PMTX), FRETURN, MONITOR _ 67;
}*KEY _ SPKEY; GOTO DDWS10;

*}"ENTRY POINT FOR MONITOR
}(ENTRY MDPDWS(PMTX, KEY), FRETURN;

DDWS10:}#GOTO DDWS30 IF PMTX#-1;

*}"CHOOSE DWS ENTRY FOR DELETION. TRY TO PICK ONE WHICH ISN'T IN CWS.
}*APTE _ OLDEST'PAGE(1@APTCWS,0//DDWS20);
}*PUNT('PGL') IF APTE$APTPGL#0;
}*PMTX _ APTE$APTPMT;
}*GOTO DDWS40;
*}#THEY ARE ALL IN CWS.}"PICK ANY ONE.
DDWS20:}#APTE _ OLDEST'PAGE(0,0//FRETURN('DWE', 159));
}*FRETURN('WSL', 130) IF APTE$APTPGL#0;
}*PMTX _ APTE$APTPMT;
}*GOTO DDWS40;

*}"CALLER SPECIFIED ENTRY TO BE DELETED.}"CHECK FOR ERRORS.
DDWS30:}#FRETURN('PMI', 110) UNLESS (1<=PMTX AND PMTX<=NPMTE);
}*FRETURN('PMC', 121) IF KEY A'
}-(PMT[PMTX]$PMTCL V' PMT[PMTX]$PMTAL) = 0;
DDWS35:}#APTE _ GET'APT'ENTRY(PMTX//RETURN -1);
}*FRETURN('PGL', 203) IF APTE$APTPGL#0;

*}"RELEASE PAGE FROM CORE AND DRUM.
DDWS40:}#IF APTE$APTCWS DO;
}-RELCP(PMTX//VALUE PUNT(MEC):MEC, MEM) IF PMT[PMTX]$PMTSF;
}-MAKE'APT'ENTRY(APTE A' N' 1@APTCWS//VALUE PUNT('APT'));
}*ENDIF;
}*IF (APTE$APTDWS AND PMT[PMTX]$PMTDKA#0) DO;
}-RELDP(PMTX//DDWS80: MEC, MEM);
}*ENDIF;
*}"REMOVE ENTRY FROM APT.
}*DELETE'APT'ENTRY(PMTX);
}*RETURN PMTX;

*}"FAILURE RETURN FROM RELDP.}"ONLY LEGITIMATE REASON IS A DRUM
*}"OR DISK ERROR.
DDWS80:}#FRETURN('DME', 213) IF MEC='DRE';
}*FRETURN('DKE', 214) IF MEC='KRE';
}*PUNT(MEC);

}(END;

}(PROGRAM DPCWS;
}*INCLUDE APTD, PMTD, GLOBAL, PROFILE, SPTD;
}*DECLARE APTE, MEC, MEM;
*
}(FUNCTION DPCWS(PMTX), FRETURN, MONITOR _ 68;
}*IF PMTX=-1 DO;
}-APTE _ OLDEST'PAGE(1@APTCWS, 1@APTCWS//FRETURN('CWE',158));
}-FRETURN('WSL', 205) IF APTE$APTPGL#0;
}-PMTX _ APTE$APTPMT;
}*ELSE DO;
}-FRETURN('PMI', 110) UNLESS (1<=PMTX AND PMTX<=NPMTE);
}-FRETURN('PMC', 121) IF SPKEY A'
}0(PMT[PMTX]$PMTCL V' PMT[PMTX]$PMTAL) = 0;
}-APTE _ GET'APT'ENTRY(PMTX//RETURN -1);
}-RETURN -1 IF APTE$APTCWS=0;
}-FRETURN('PGL', 204) IF APTE$APTPGL#0;
}*ENDIF;
*}"RELEASE PAGE FROM CORE AND UPDATE APT.
}*RELCP(PMTX//VALUE PUNT(MEC):MEC, MEM) IF PMT[PMTX]$PMTSF;
}*MAKE'APT'ENTRY(APTE A' N' 1@APTCWS//VALUE PUNT('APT'));
}*IF PMT[PMTX]$PMTRF DO;
}-CLEAR'MAP;
}-PMT[PMTX]$PMTRF _ 0;
}*ENDIF;
}*RETURN PMTX;
*

}(END;

}(PROGRAM READ'LWS;
}*INCLUDE PROFILE, GLOBAL, APTD;
}*DECLARE NCODES _ 6;
}*DECLARE CHARACTER ARRAY CODES[NCODES] _
}-('CWS', 'OCW', 'MCW', 'DWS', 'ODW', 'MDW');
}*DECLARE POINTER ARRAY PTRS[NCODES] _
}-(@LCWS, @OLCWS, @MLCWS, @LDWS, @OLDWS, @MLDWS);
}*DECLARE I, LWS;
}(ENTRY READ'LWS(CODE), FRETURN, MONITOR _ 70;
}*GOTO RLWS20 IF (0<=CODE AND CODE<NCODES);
}*FOR I _ 0 TO NCODES-1 DO;
}-(CODE_I & GOTO RLWS20) IF CODES[I]=CODE;
}*ENDFOR;
}*FRETURN('ARG', 191);
*
RLWS20:}#LWS _ $PTRS[CODE];
}*RETURN LWS;
*
}(ENTRY SET'LWS(CODE, LNGTH), FRETURN, MONITOR _ 71;
}*GOTO SLWS20 IF (CODE=0 OR CODE=4);
}*FOR I _ 1 BY 3 TO 4 DO;
}-(CODE_I & GOTO SLWS20) IF CODES[I]=CODE;
}*ENDFOR;
}*FRETURN('ARG', 191);
*
SLWS20:}#FRETURN('WSL', 192) UNLESS ($PTRS[CODE-1]<=LNGTH AND
}BLNGTH<=$PTRS[CODE+1]);
}*FRETURN('WSL', 192) IF
}-(CODE=1 AND LNGTH>OLDWS) OR
}-(CODE=4 AND LNGTH<OLCWS);
}*$PTRS[CODE] _ LNGTH;
}*RETURN;
*

}(END;

}(PROGRAM AMCREQ;
*}"PUT A REQUEST ON AMC QUEUE
}*INCLUDE RESMON, SWPD, GLOBAL, PROFILE, ICTD;
}*DECLARE NFN, TR, TV, I, REQCODE, RESP, DATA, SWER, WAIT'COUNT;
}*DECLARE WAIT'LIMIT _ 64, LONG WAIT'TIME _ (0,30000);
}*DECLARE QNO;
*
}(FUNCTION SWPREQ(OCTAL ARRAY NODE, SCALAR NFNA), FRETURN;
}*REQCODE _ (@NODE[0]).SWRCD;
}*QNO _ QNOS[REQCODE];
}*WAIT'COUNT _ 0;

*}"CHECK AVAILABILITY OF FREE REQUEST NODES
REQ10:}$FOR I _ 1 TO SWWLIM DO;
}-PROTECT(PRO2);
}0GOTO REQ20;
REQ15:}'UNPROTECT(PRO2);
*},FRETURN('NFN',NFN) IF NFNA;
}*ENDFOR;
}*PUNT('NFN');
*}"GET AN EMPTY REQUEST NODE FROM THE FREE LIST AND COPY
*}$THE REQUEST INTO IT.
REQ20:}'TV _ RMQUEU(SWFREL, SWFEQP//REQ15);
}-TV[I]_NODE[I] FOR I_0 TO LSWQN-1;
}-TV.SWEPRT_@(PRT[PRTI])-RESM IF TV.SWEPRT = 0;
}-TV.SWERRCNT _ 0;
}-TV.SWEQP _ SWEOQ;
}-NFNA _ TV.SWWAKF;
*}"PUT REQUEST NODE ON END OF APPROPRIATE REQUEST QUEUE
}-PUTQUEU(TV, SWQS[QNO], 1, SWEQP);
}-AMCA[0] _ 1 IF QNO=ACTQ;
}*UNPROTECT(PRO2);
*}"CLEAR THE ERROR WORD IN PRT.
}*PROTECT(PRO1);
}-PRT[PRTI]$PRACTE _ 0;
}*UNPROTECT(PRO1);
*}"POKE THE AMC.
}*ATTENTION(ATT1);
}*RETURN IF QNO#ACTQ;
*}"WAIT AND SEE WHAT HAPPENS IF REQUEST IS 'ACTIVATE' TYPE
}*FOR I _ 1 TO SWWLIM DO;
}-GOTO REQ40 IF AMCA[0]#1;
}*ENDFOR;
}*PUNT('SNR');* SWAPPER NOT RESPONDING
REQ40:}$RESP _ AMCA[0];
}*DATA _ AMCA[1];
}*RETURN IF RESP=SWSUCCESS;
}*AMCA[1] _ 0;
}*AMCA[0] _ 0;* RELEASE ACTIVATE

*}"REQUEST 'FAILED' - DATA CONTAINS ERROR CODE
}*IF DATA=CPWAIT DO;
}-PUNT('WTL') IF (WAIT'COUNT _ WAIT'COUNT+1) > WAIT'LIMIT;
}-SBLOCK(WAIT'TIME);
}-GOTO REQ10;
}*ELSEIF DATA=WAITWK DO;
}-RETURN IF NFNA=0;
}-MBLOCK(AMC);
}-PROTECT(PRO1);
}0DATA _ PRT[PRTI]$PRACTE;
}0PRT[PRTI]$PRACTE _ 0;
}-UNPROTECT(PRO1);
}-RETURN IF DATA=0;
}*ENDIF;
}*FRETURN('AME', DATA);
}*RETURN;


}(END;

}(PROGRAM GETCP;
}*INCLUDE PMTD, APTD, SWPD, GLOBAL, PROFILE;
}*DECLARE ARRAY REQ[LSWQN];
}*DECLARE NODE, MEC, MEM;
}(ENTRY GETCP(PMTX), FRETURN;
}*FRETURN('PMI', 110) UNLESS (1<=PMTX AND PMTX<=NPMTE);
}*FRETURN('PME', 128) IF PMT[PMTX]$PMTDKA=0;
*}"SEND 'RESERVE PAGE' REQUEST TO AMC.
}*NODE _ @REQ[0];
}*BSET(NODE, 0, LSWQN);
}*NODE.SWUN _ PMT[PMTX]$PMTUN;
}*NODE.SWDKA _ PMT[PMTX]$PMTDKA;
}*NODE.SWWAKF _ 0;* NO WAKEUP REQUIRED
}*NODE.SWRCD _ CRRSP;
}*SWPREQ(REQ, 0//GCP80: MEC, MEM);
*}"SET 'SCHEDULED FLAG' FOR PAGE
}*PMT[PMTX]$PMTSF _ 1;
}*RETURN;

*}"REQUEST TO AMC FAILED.}"POSSIBLE ERROR CODES AND THEIR SIGNIFICANCE
*}"ARE:
*}"(1) NCHT - NO ENTRY FOR PAGE IN CHT.}"THIS MEANS OTHER STEPS MUST
*}&BE TAKEN TO GET THE PAGE.}"FAIL RETURN.
*}"(2) DNCHT - THERE WAS AN ENTRY IN CHT FOR THE PAGE, BUT THE DISK
*}&ADDRESS IN IT WAS DIFFERRENT FROM THE ONE WE GOT OUT OF PMT.
*}&ANOTHER FAILURE RETURN.
*}"(3) SCHOVF - THE PAGE WAS IN CHT WITH THE SAME DISK ADDRESS WE HAD,
*}&BUT THE SCHEDULE COUNT FIELD IN THE CHT ENTRY WAS FULL.}"PUNT.
GCP80:}$FRETURN('NCH', 999) IF MEM=NCHT;
}*FRETURN('DNC', 999) IF MEM=DNCHT;
}*PUNT('SCO') IF MEM=SCHOVF;
}*PUNT('AME');

}(END;

}(PROGRAM RELCP;
}*INCLUDE PMTD, SWPD, GLOBAL;
}*DECLARE ARRAY REQ[LSWQN];
}*DECLARE MEC, MEM, NODE;
*
}(FUNCTION RELCP(PMTX), FRETURN;
*}"CHECK FOR ERRORS
}*FRETURN('PMI', 110) UNLESS (1<=PMTX AND PMTX<=NPMTE);
RELCP05:}"FRETURN('PNS', 112) UNLESS PMT[PMTX]$PMTSF;
*}"SEND 'RELEASE PAGE TO DRUM' REQUEST TO AMC.}"THIS REQUEST
*}"CANNOT FAIL.
RELCP10:}"NODE _ @REQ[0];
}*BSET(NODE, 0, LSWQN);
}*NODE.SWUN_PMT[PMTX]$PMTUN;
}*NODE.SWDKA_PMT[PMTX]$PMTDKA;
}*NODE.SWWAKF _ 0;* NO WAKEUP REQUIRED
}*NODE.SWRCD _ CWRPG;
}*SWPREQ(REQ, 0//VALUE PUNT(MEC):MEC, MEM);
*}"RESET 'SCHEDULED FLAG' FOR PAGE
}*PMT[PMTX]$PMTSF_0;
}*RETURN;
*

}(END;

}(PROGRAM RELDP;
}*INCLUDE SWPD, PMTD, GLOBAL, APTD, PROFILE;
}*DECLARE ARRAY REQ[LSWQN];
}*DECLARE NODE, MEC, MEM, APTE;
*
}(FUNCTION RELDP(PMTX), FRETURN;
}*FRETURN('PMI', 110) UNLESS (1<=PMTX AND PMTX<=NPMTE);
}*FRETURN('PME', 128) IF PMT[PMTX]$PMTDKA=0;
}*APTE _ GET'APT'ENTRY(PMTX//VALUE 0);
}*FRETURN('PNA', 129) IF APTE$APTDWS=0;* THIS PROCESS ISN'T USING PAGE
}*GOTO RDP10;
*}"ENTRY POINT FOR PUT'IN'CWS
}(ENTRY MRELDP(PMTX), FRETURN;
*}"SEND 'DRUM TO DISK TRANSFER' REQUEST TO AMC
RDP10:}$NODE _ @REQ[0];
}*BSET(NODE, 0, LSWQN);
}*NODE.SWUN_PMT[PMTX]$PMTUN;
}*NODE.SWDKA_PMT[PMTX]$PMTDKA;
}*NODE.SWWAKF _ 1;* REQUEST A WAKEUP
}*NODE.SWRCD _ CRDK;
}*SWPREQ(REQ, 0//RDP80: MEC, MEM);
}*RETURN;

*}$THE AMC FAILED TO DO THE TRANSFER FOR SOME REASON.}"POSSIBLE VALUES
*}"OF MEM AND THEIR SIGNIFICANCE ARE:
*}"(1) NINDHT - PAGE NOT FOUND IN DHT.}"THIS WE ASSUME TO MEAN THAT WE
*}&DON'T HAVE TO RELEASE THE PAGE.
*}"(2) DNCHT - PAGE IS IN CHT WITH A DISK ADDRESS DIFFERENT FROM THE ONE
*}&WE SPECICIED.}"WE ASSUME OUR DISK ADDRESS IS OLD AND WE DON'T
*}&NEED TO RELEASE THE PAGE.
*}"(3) DKRAS - CLASS CODE CHECK ON DRUM FAILED.}"AGAIN WE ASSUME OUR
*}&DISK ADDRESS IS OLD AND WE DON'T HAVE TO RELEASE THE PAGE.
*}"(4) HERDR - 'HARD ERROR' IN READING FROM THE DRUM.}"WE PUNT.
*}"(5) SERDR - 'SOFT ERROR' IN READING FROM DRUM.}"WE FAIL RETURN.
*}"(6) HERDK - 'HARD ERROR' IN REFERENCING THE DISK.}"WE PUNT.
*}"(7) UNERK - CLASS CODE CHECK ON DISK FAILED AFTER DRUM CHECK
*}&SUCCEEDED.}"WE PUNT.
*}"(8) SERDK - 'SOFT ERROR' IN READING FROM DISK.}"WE FAIL RETURN.
RDP80:}$PUNT('AMC') UNLESS MEC='AME';
}*IF MEM=NINDHT DO;
}-RETURN;
}*ELSEIF MEM=DNCHT DO;
}-RETURN;
}*ELSEIF MEM=DKRAS DO;
}-RETURN;
}*ELSEIF MEM=HERDR DO;
}-PUNT('HDE');
}*ELSEIF MEM=SERDR DO;
}-FRETURN('DRE', 206);
}*ELSEIF MEM=UNERK DO;
}-PUNT('DHT');
}*ELSEIF MEM=SERDK DO;
}-FRETURN('KRE', 207);
}*ELSE DO;
}-PUNT('AME');
}*ENDIF;
*

}(END;

}(PROGRAM GETDP;
}*INCLUDE PMTD, APTD, SWPD, GLOBAL, PROFILE;
}*DECLARE ARRAY REQ[LSWQN];
}*DECLARE MEC, MEM, APTE, NODE;
*
}(FUNCTION GETDP(PMTX), FRETURN;
*}"CHECK FOR ERRORS
}*FRETURN('PMI', 110) UNLESS (1<=PMTX AND PMTX<=NPMTE);
}*FRETURN('PME', 128) IF PMT[PMTX]$PMTDKA=0;
}*APTE _ GET'APT'ENTRY(PMTX//GDP20);
}*RETURN IF APTE$APTDWS;
}*GOTO GDP20;
}(ENTRY MGETDP(PMTX), FRETURN;
*}"SEND 'DISK TO DRUM TRANSFER' REQUEST TO AMC
GDP20:}$NODE _ @REQ[0];
}*BSET(NODE, 0, LSWQN);
}*NODE.SWUN_PMT[PMTX]$PMTUN;
}*NODE.SWDKA_PMT[PMTX]$PMTDKA;
}*NODE.SWWAKF _ 1;* REQUEST A WAKEUP
}*NODE.SWRCD _ CRKD;
}*SWPREQ(REQ, 0//GDP80: MEC, MEM);
*
}*RETURN;

*}"AMC FAILED FOR ONE OF THE FOLLOWING REASONS.
*}"(1) UNER - CLASS CODE ERROR READING FROM DISK.}"WE ASSUME OUR
*}&DISK ADDRESS IS WRONG.
*}"(2) DNCHT - DISK ADDRESS IN CHT DIFFERENT FROM THE ONE WE HAVE.
*}"(3) DKRAS - UNIQUE NAME ON DRUM DIFFERENT FROM OURS.
*}"(4) HERDR - HARD ERROR READING FROM DRUM.
*}"(5) HERDK - HARD ERROR READING FROM DISK.
*}"(6) SERDK - SOFT ERROR READING FROM DRUM.
GDP80:}$FRETURN('RNE', 209) IF (MEM=UNER OR MEM=DNCHT
}-OR MEM=DKRAS OR MEM=UNERK);
}*FRETURN('DME', 210) IF MEM=HERDR;
}*FRETURN('DKE', 211) IF (MEM=HERDK OR MEM=SERDK);
}*PUNT('AME');
*

}(END;

}(PROGRAM CRDKPG;
}*INCLUDE SWPD;
}*DECLARE OCTAL ARRAY REQ[LSWQN];
}*DECLARE MEC, MEM, NODE;
*
}(ENTRY CRDKPG(DKA, LONG UNQN), FRETURN;
*}"GET A DISK ADDRESS 'NEAR' DKA FROM THE DISK ALLOCATOR
}*DKA _ GET'DISK'ADDR(DKA//VALUE PUNT('KBT'));
*}"SEND A 'WRITE UNIQUE NAME' REQUEST TO THE AMC
}*NODE _ @REQ[0];
}*BSET(NODE, 0, LSWQN);
}*NODE.SWUN _ UNQN;
}*NODE.SWDKA _ DKA;
}*NODE.SWWAKF _ 1;* REQUEST A WAKEUP
}*NODE.SWRCD _ CRWUN;
}*SWPREQ(REQ, 0//CDKP80: MEC, MEM);
}*RETURN DKA;

*}"AMC FAILED TO WRITE THE UNIQUE NAME FOR ONE OF THE FOLLOWING REASONS.
*}"(1) UNER - THE 'NEW' NAME IS ALREADY IN CHT.}"PUNT.
*}"(2) DKINU - THE DISK PAGE IS NOT FREE (I.E., ITS CLASS CODE IS
*}&NON-ZERO.}"PUNT.
*}"(3) HERDK - THERE WAS A 'HARD' ERROR IN REFERENCING THE DISK.}"PUNT.
CDKP80:}#PUNT('UNE') IF MEM=UNER;
}*PUNT('KBT') IF MEM=DKINU;
}*PUNT('DKE') IF MEM=HERDK;
}*PUNT('AME');
*

}(END;

}(PROGRAM DESTROY'PAGE;
}*INCLUDE SWPD, ICTD;
}*DECLARE ARRAY REQ[LSWQN];
}*DECLARE MEC, MEM, NODE;
*
}(FUNCTION DESTROY'PAGE (DKA, LONG UNQN), FRETURN;
*}"SEND 'DESTROY PAGE' REQUEST TO AMC
}*NODE _ @REQ[0];
}*BSET(NODE, 0, LSWQN);
}*NODE.SWUN_ UNQN;
}*NODE.SWDKA_ DKA;
}*NODE.SWWAKF _ 1;* REQUEST A WAKEUP
}*NODE.SWRCD _ CRDEST;
}*SWPREQ(REQ, 0//DEST80:MEC, MEM);
*}"RELEASE PAGE TO DISK ALLOCATOR
}*REL'DISK'ADDR(DKA//VALUE PUNT('KBT'));
}*RETURN;
*

*}"AMC FAILED TO DESTROY THE PAGE FOR ONE OF THE FOLLOWING REASONS.
*}"(1) UNER - UNIQUE NAME ON DRUM DIFFERENT FROM GIVEN ONE.}"FAIL RETURN.
*}"(2) DNCHT - UNIQUE NAME IS IN CHT WITH A DISK ADDRESS DIFFERENT
*}&FROM THE GIVEN ONE.}"FAIL RETURN.
*}"(3) DKRAS - CLASS CODE AT GIVEN DISK ADDRESS DIFFERENT FROM GIVEN
*}&UNIQUE NAME.}"FAIL RETURN.
*}"(4) HERDK - 'HARD' ERROR IN REFERENCING DISK.}"FAIL RETURN.
*}"(5) UNERK - CLASS CODE CHECK ON DISK FAILED AFTER DRUM CHECK
*}&SUCCEEDED.}"PUNT.
DEST80:}#FRETURN('RNE', 999) IF (MEM=UNER OR MEM=DNCHT OR MEM=DKRAS);
}*FRETURN('DKE', 999) IF MEM=HERDK;
}*PUNT('DHT') IF MEM=UNERK;
}*PUNT('AME');
*

}(END;

}(PROGRAM PNIC'TRAP;
}*INCLUDE RESMON, PMTD, APTD, CHTD, PARD,SPTD,CHTD,PROFILE;
}*DECLARE PMTX, SOURCE, SCHEDULED, CCE, IN'CWS, IN'DWS,
}2ON'DRUM, IN'CHT, READ'ERROR, APTE, Q, MEC,
}*MEM, PC, APTX;
}*DECLARE ARRAY CHTE[LCHTE];

}(ENTRY PNIC'TRAP();
}*AGE'APS();*}"CALL THIS FCN FROM SOMEWHERE ELSE!!

WHY'PNIC:
*}"THIS CODE FINDS OUT THE THINGS THAT THE PNIC TRAP-HANDLING
*}"ROUTINE NEEDS TO KNOW ABOUT A PAGE THAT THE CPU HAS FOUND TO BE NOT-
*}"IN-CORE.}"IT SETS UP THE FOLLOWING FLAGS.
*}%SOURCE - SET IF TRAP CAME OUT OF MONITOR RING
*}%SCHEDULED - SET IF SF IS SET IN THE PAGE'S PMT ENTRY
*}%CCE - SET IF CCE IS SET IN THE PAGE'S PMT ENTRY
*}%IN'CWS - SET IF CWS IS SET IN THE PAGE'S APT ENTRY
*}%IN'DWS - SET IF THE PAGE APPEARS IN APT
*}%ON'DRUM - SET IF DWS IS SET IN THE PAGE'S APT ENTRY
*}%IN'CHT - SET IF THE PAGE APPEARS IN CHT
*}%READ'ERROR - SET IF THE STATUS FIELD IN THE PAGE'S CHT ENTRY
*}/INDICATES A DRUM READ ERROR (AND NO OTHER FUNNY STATUS)

}*Q _ TPAR;
}*PC _ TRSTATE.STPC;
}*PMTX _ RDPRMB(PAGENO(Q))$PRMPMT;
}*PUNT('PMI') UNLESS (1<=PMTX AND PMTX<=NPMTE);
}*SOURCE _ (1 IF MRING(PC) ELSE 0);
*}"ABORT IF LOOPING THROUGH CWS.
}*IF TRSTATE.INSTD DO;
}-PNIC'COUNT _ PNIC'COUNT+1;
*},IF PNIC'COUNT > LWCS DO;
*}/TRSTATE.INSTD _ 0;
*}/TRAP(TNO(PNIC),Q,SOURCE);
*},ENDIF;
}*ELSE DO;
}-TRSTATE.INSTD _ 1;
}-PNIC'COUNT _ 0;
}*ENDIF;
}*SCHEDULED _ PMT[PMTX]$PMTSF;
}*CCE _ PMT[PMTX]$PMTCCE;
}*APTX _ FIND'APT'ENTRY(PMTX//VALUE APTX _ 0);
}*APTE _ (APT[APTX] IF APTX#0 ELSE 0);
}*IN'CWS _ APTE$APTCWS;
}*IN'DWS _ (APTE#0);
}*ON'DRUM _ APTE$APTDWS;
}*IN'CHT _ 0;
}*IF SCHEDULED DO;
}-READ'ERROR _ 0;
}-RDCHT(PMT[PMTX]$PMTUN, CHTE//WHY30);
}-IN'CHT _ 1;
}-READ'ERROR _ ((@CHTE[0]).CSTA=RDER);
}*ENDIF;
WHY30:}$GOTO CASE1 IF NOT (MRING(PC) OR MRING(Q));
}*GOTO CASE2 IF MRING(PC) AND NOT MRING(Q);
}*GOTO CASE3 IF MRING(PC) AND MRING(Q);
}*PUNT('MAC');*

*}"CASE 1:}"PC AND Q BOTH IN NON-MONITOR RING
CASE1:}$IF NOT SCHEDULED DO;
}-IF NOT IN'CWS DO;
}0TRAP(TNO(PNIC), Q, 0) IF SPSTATUS$DPNIC=0;
}0PUT'IN'CWS(PMTX,APTX,APTE//PNC80:MEC, MEM);
}0GOTO SWAP'OUT;
}-ELSE DO;* IN CWS BUT NOT SCHEDULED
}0IF NOT ON'DRUM DO;
}3MPPDWS(PMTX,MKEY,MSTATUS//PNC81:MEC, MEM);
}3GOTO SWAP'OUT;
}0ELSE DO;* IN CWS AND ON DRUM BUT NOT SCHEDULED
}3IF CCE DO;
}6TRAP(TNO(NEP), Q, 0);
}3ELSE DO;
}6GOTO SWAP'OUT;
}3ENDIF;
}0ENDIF;
}-ENDIF;
}*ELSE DO;* SCHEDULED
}-IF NOT IN'CHT DO;
}0PMT[PMTX]$PMTSF _ 0;*RESET SCHEDULED FLAG
}0GOTO SWAP'OUT;
}-ELSE DO;* SCHEDULED AND IN CHT
}0IF READ'ERROR DO;
}3TRAP(TNO(DMRD), Q, 0);
}0ELSE DO;* SCHEDULED, IN CHT, NO READ ERROR
}3GOTO SWAP'OUT;
}0ENDIF;
}-ENDIF;
}*ENDIF;

*}"FAILURE RETURN FROM MPPCWS.}"THIS TRANSLATES INTO SOME VARIETY OF TRAP.
PNC80:}$TRAP(TNO(DWSO), Q, 0) IF MEC='RDW';
}*TRAP(TNO(NEP), Q, 0) IF MEC='RNE';
}*TRAP(TNO(DMRD), Q, 0) IF (MEC='DME' OR MEC='DKE');
}*TRAP(TNO(CWSO), Q, 0) IF (MEC='CWE' OR MEC='WSL');
}*PUNT(MEC);
*}"FAILURE RETURN FROM MPPDWS.}"THIS TRANSLATES INTO SOME KIND OF TRAP.
PNC81:}$TRAP(TNO(DWSO), Q, 0) IF MEC='RDW';
}*TRAP(TNO(NEP), Q, 0) IF MEC='RNE';
}*TRAP(TNO(DMRD), Q, 0) IF (MEC='DME' OR MEC='DKE');
}*PUNT(MEC);*

*}"CASE 2: PC IN MONITOR RING, Q IN NON-MONITOR RING
CASE2:}$IF NOT SCHEDULED DO;
}-IF NOT IN'CWS DO;
}0PUT'IN'CWS(PMTX, APTX, APTE//PNC82:MEC, MEM);
}0GOTO SWAP'OUT;
}-ELSE DO;* IN CWS BUT NOT SCHEDULED
}0IF NOT ON'DRUM DO;
}3MPPDWS(PMTX, MKEY, MSTATUS//PNC83:MEC, MEM);
}3GOTO SWAP'OUT;
}0ELSE DO;* IN CWS AND ON DRUM BUT NOT SCHEDULED
}3IF CCE DO;
}6TRAP(TNO(NEP), Q, 1);
}3ELSE DO;
}6GOTO SWAP'OUT;
}3ENDIF;
}0ENDIF;
}-ENDIF;
}*ELSE DO;* SCHEDULED
}-IF NOT IN'CHT DO;
}0PMT[PMTX]$PMTSF _ 0;*RESET SCHEDULED FLAG
}0GOTO SWAP'OUT;
}-ELSE DO;* SCHEDULED AND IN CHT
}0IF READ'ERROR DO;
}3TRAP(TNO(DMRD), Q, 1);
}0ELSE DO;* SCHEDULED, IN CHT, NO READ ERROR
}3GOTO SWAP'OUT;
}0ENDIF;
}-ENDIF;
}*ENDIF;

*}"FAILURE RETURN FROM MPPCWS.}"THIS TRANSLATES INTO SOME VARIETY OF TRAP.
PNC82:}$TRAP(TNO(DWSO), Q, 1) IF MEC='RDW';
}*TRAP(TNO(NEP), Q, 1) IF MEC='RNE';
}*TRAP(TNO(DMRD), Q, 1) IF (MEC='DME' OR MEC='DKE');
}*TRAP(TNO(CWSO), Q, 1) IF (MEC='CWE' OR MEC='WSL');
}*PUNT(MEC);
*}"FAILURE RETURN FROM MPPDWS.}"THIS TRANSLATES INTO SOME KIND OF TRAP.
PNC83:}$TRAP(TNO(DWSO), Q, 1) IF MEC='RDW';
}*TRAP(TNO(NEP), Q, 1) IF MEC='RNE';
}*TRAP(TNO(DMRD), Q, 1) IF (MEC='DME' OR MEC='DKE');
}*PUNT(MEC);*

*}"CASE 3: PC AND Q BOTH IN MONITOR RING
CASE3:}$IF NOT SCHEDULED DO;
}-IF NOT IN'CWS DO;
}0PUT'IN'CWS(PMTX, APTX, APTE//VALUE PUNT(MEC):MEC, MEM);
}0GOTO SWAP'OUT;
}-ELSE DO;* IN CWS BUT NOT SCHEDULED
}0IF NOT ON'DRUM DO;
}3MPPDWS(PMTX, MKEY, MSTATUS//VALUE PUNT(MEC):MEC, MEM);
}3GOTO SWAP'OUT;
}0ELSE DO;* IN CWS AND ON DRUM BUT NOT SCHEDULED
}3IF CCE DO;
}6PUNT('CCE');
}3ELSE DO;
}6GOTO SWAP'OUT;
}3ENDIF;
}0ENDIF;
}-ENDIF;
}*ELSE DO;* SCHEDULED
}-IF NOT IN'CHT DO;
}0PMT[PMTX]$PMTSF _ 0;*RESET SCHEDULED FLAG
}0GOTO SWAP'OUT;
}-ELSE DO;* SCHEDULED AND IN CHT
}0IF READ'ERROR DO;
}3PUNT('DMR');
}0ELSE DO;*SCHEDULED, IN CHT, NO READ ERROR
}3GOTO SWAP'OUT;
}0ENDIF;
}-ENDIF;
}*ENDIF;

SWAP'OUT:
*}"AFTER DOING WHATEVER SHOULD BE DONE TO CORRECT THE PAGE FAULT, WE
*}"BLOCK.}"THIS WILL HAVE THE EFFECT OF FORCING THE SWAPPER TO MAKE AN
*}"ATTEMPT TO BRING IN THE MISSING PAGE, AND WILL ALSO GIVE TIME FOR ANY
*}"TRANSIENT CONDITIONS (LIKE PAGE IN PROCESS OF BEING DESTROYED) TO
*}"STABILIZE.
*})PROTECT(PRO1);
*},PRT[PRTI]$PRPGF _ 1;
*})UNPROTECT(PRO1);
}*PAGE'FAULTS_PAGE'FAULTS + 1;
}*SWBLOCK();
}*RETURN;


}(END;

}(PROGRAM PNIM'TRAP;
}*INCLUDE TRAPD, GLOBAL, RESMON, SPTD, SPCSD, PROFILE;
}*DECLARE Q, PC, PMTX, TARGET'SP, MEC, MEM, SOURCE, BYTENO;
}*DECLARE NAME, SPTE;

}(ENTRY PNIM'TRAP();
}*Q _ TPAR;
}*PC _ TRSTATE.STPC;
}*BYTENO _ PAGENO(Q);
}*PMTX _ RDPRMB(BYTENO)$PRMPMT;
}*TARGET'SP _ (SPCS[SPCSL]$CSR0SP IF URING(Q) ELSE
}7SPCS[SPCSL]$CSR1SP IF YRING(Q) ELSE
}70);
}*NAME _ 1 LSH TARGET'SP;
}*SOURCE _ (1 IF MRING(PC) ELSE 0);

}*GOTO CASE1 IF NOT (MRING(PC) OR MRING(Q));
}*GOTO CASE2 IF MRING(PC) AND NOT MRING(Q);
}*GOTO CASE3 IF MRING(PC) AND MRING(Q);
}*PUNT('MAC');

*}"CASE 1: PC AND Q BOTH IN NON-MONITOR RING
CASE1:}$TRAP(TNO(MACC), Q, SOURCE) IF TARGET'SP=0;
}*TRAP(TNO(PNIM), Q, SOURCE) IF SPSTATUS$DPNIM=0;
}*IF PMTX=0 DO;
}-PMTX _ MACQPMT(-1, NAME//PNM80:MEC, MEM);
}*ENDIF;
}*MNPPMT(PMTX, MKEY, MSTATUS//VALUE PUNT(MEC):MEC, MEM);
}*GOTO PUT'IN'MAP;

*}"CASE 2: PC IN MONITOR RING, Q IN NON-MONITOR RING
CASE2:}$TRAP(TNO(MACC), Q, SOURCE) IF TARGET'SP=0;
}*IF PMTX=0 DO;
}-PMTX _ MACQPMT(-1, NAME//PNM80:MEC, MEM);
}*ENDIF;
}*MNPPMT(PMTX, MKEY, MSTATUS//VALUE PUNT(MEC):MEC, MEM);
}*GOTO PUT'IN'MAP;

*}"CASE 3: PC AND Q BOTH IN MONITOR RING
CASE3:}$PUNT('PNM');

PUT'IN'MAP:
}*SETPRMB(BYTENO, PMTX);
}*BYTENO _ BYTENO-64 IF SPT[TARGET'SP]$SPTRING=1;
}*SPTE _ @SPT[TARGET'SP];
}*SPTE.(PXFLDS[BYTENO]) _ PMTX;
}*SPTE.(ROFLDS[BYTENO]) _ 0;
}*SPTE.SPTLM _ BYTENO IF BYTENO > SPTE.SPTLM;
}*RETURN;

*}"FAILURE RETURN FROM ACQPMT IS REASONABLE ONLY IF PMT IS FULL.
PNM80:}$TRAP(TNO(PMTO), Q, SOURCE) IF MEC='PMO';
}*PUNT(MEC);


}(END;

}(PROGRAM PUT'IN'CWS;
}*INCLUDE GLOBAL, PROFILE, APTD, PMTD, SWPD;
}*DECLARE APTX', APTE', PMTX', PMTE', MEC, MEM, DISK;
}*MACRO IN'CWS _ (APTE$APTCWS);
}*MACRO CWS'FULL _ (LCWS>=OLCWS);
}*MACRO LAST'CWS _ (NAPTE+1-LCWS);
}*MACRO FIRST'NOT'CWS _ (NAPTE-LCWS);
}*MACRO IN'DWS _ (APTE$APTDWS);
}*MACRO DWS'FULL _ (LDWS>=OLDWS);
}*MACRO LAST'DWS _ (NAPTE+1-LDWS);
}*MACRO FIRST'FREE _ (NAPTE-LDWS);

}(ENTRY PUT'IN'CWS(PMTX, APTX, APTE), FRETURN;
}*DISK _ (0 IF DRUM'SYSTEM ELSE 1);
*}"TAKE CARE OF THE CASE WHERE THE DWS BIT HAS BEEN RESET BY AMC
}*IF NOT IN'DWS AND APTE#0 DO;
}-GETDP(PMTX//GETDP'FAILURE: MEC,MEM) IF DISK;
}-APTE$APTDWS _ 1;
}*ENDIF;

}*GOTO NOT'IN'DWS IF NOT IN'DWS;

*}"THE PAGE IS IN DWS BUT NOT IN CWS (OR ELSE WE SHOULDN'T BE CALLING
*}"THIS FUNCTION).}"THERE ARE TWO CASES, DISTINGUISHED BY WHETHER CWS
*}"IS FULL.
}*GOTO CWS'NOT'FULL IF NOT CWS'FULL;

*}"THE PAGE IS ALREADY IN DWS, BUT CWS IS FULL AND WE HAVE TO MAKE ROOM
}*APTX' _ FIND'OLDEST'PAGE(1@APTCWS, 1@APTCWS//FRETURN('CWE',158));
}*APTE' _ APT[APTX'];
}*FRETURN('WSL',205) IF APTE'$APTPGL#0;
}*PMTX' _ APTE'$APTPMT;
}*RELCP(PMTX'//VALUE PUNT(MEC): MEC,MEM) IF PMT[PMTX']$PMTSF;
}*APT[APTX'] _ APTE V' (-1)@APTUH V' 1@APTCWS;
}*APT[APTX] _ APTE' A' N' 1@APTCWS;
}*RETURN;

CWS'NOT'FULL:
*}"THE PAGE IS IN DWS AND THERE IS ROOM FOR IT IN CWS
}*APT[APTX] _ APT[FIRST'NOT'CWS];
}*APT[FIRST'NOT'CWS] _ APTE V' (-1)@APTUH V' 1@APTCWS;
}*LCWS _ LCWS+1;
}*RETURN;
*
NOT'IN'DWS:
*}"THE PAGE ISN'T IN EITHER OF THE CORE AND DRUM WORKING SETS.}"THERE
*}"ARE 4 CASES TO CONSIDER.
}*GOTO CASE1 IF CWS'FULL AND DWS'FULL;
}*GOTO CASE2 IF CWS'FULL AND NOT DWS'FULL;
}*GOTO CASE3 IF NOT CWS'FULL AND DWS'FULL;
}*GOTO CASE4 IF NOT CWS'FULL AND NOT DWS'FULL;
}*PUNT('EH?');

*}"CASE 1: CWS AND DWS BOTH FULL
CASE1:}$APTX' _ FIND'OLDEST'PAGE(1@APTCWS, 1@APTCWS//FRETURN('CWE',158));
}*APTE' _ APT[APTX'];
}*FRETURN('WSL',205) IF APTE'$APTPGL#0;
}*PMTX' _ APTE'$APTPMT;
}*PMTE' _ @PMT[PMTX'];
}*RELCP(PMTX'//VALUE PUNT(MEC): MEC, MEM) IF PMTE'.PMTSF;
}*APT[APTX'] _ APT[LAST'CWS];
}*APTX' _ LAST'CWS;
}*APT[LAST'CWS] _ APTE' A' N' 1@APTCWS;
}*LCWS _ LCWS-1;
}*IF APTE'$APTDWS AND PMTE'.PMTDKA#0 DO;
}-MRELDP(PMTX'//CASE1'ERROR1: MEC,MEM) IF DISK;
}*ENDIF;
}*IF PMT[PMTX]$PMTDKA#0 DO;
}-MGETDP(PMTX//CASE1'ERROR2: MEC,MEM) IF DISK;
}*ENDIF;
}*APT[APTX'] _ (-1)@APTUH V' 1@APTDWS V' 1@APTCWS V' PMTX@APTPMT;
}*LCWS _ LCWS+1;
}*RETURN;

CASE1'ERROR1:
}*GOTO RELDP'FAILURE;

CASE1'ERROR2:
}*APT[APTX'] _ APT[LAST'DWS];
}*APT[LAST'DWS] _ 0;
}*LDWS _ LDWS-1;
}*GOTO GETDP'FAILURE;
*
*}"CASE 2: CWS FULL, DWS NOT FULL
CASE2:}$APTX' _ FIND'OLDEST'PAGE(1@APTCWS, 1@APTCWS//FRETURN('CWE',158));
}*APTE' _ APT[APTX'];
}*FRETURN('WSL',205) IF APTE'$APTPGL#0;
}*PMTX' _ APTE'$APTPMT;
}*RELCP(PMTX'//VALUE PUNT(MEC): MEC,MEM) IF PMT[PMTX']$PMTSF;
}*APT[FIRST'FREE] _ APTE' A' N' 1@APTCWS;
}*APT[APTX'] _ (-1)@APTUH V' 1@APTDWS V' 1@APTCWS V' PMTX@APTPMT;
}*LDWS _ LDWS+1;
}*IF PMT[PMTX]$PMTDKA#0 DO;
}-MGETDP(PMTX//CASE2'ERROR1: MEC,MEM) IF DISK;
}*ENDIF;
}*APT[APTX']$APTDWS _ 1;
}*RETURN;

CASE2'ERROR1:
}*PUNT('SFS') IF PMT[PMTX]$PMTSF;
}*APT[APTX'] _ APT[LAST'DWS] V' 1@APTCWS;
}*APT[LAST'DWS] _ 0;
}*LDWS _ LDWS-1;
}*GOTO GETDP'FAILURE;
*

*}"CASE 3: CWS NOT FULL, DWS FULL
CASE3:}$APTX' _ FIND'OLDEST'PAGE(1@APTCWS, 0//VALUE PUNT('APT'));
}*APTE' _ APT[APTX'];
}*PMTX' _ APTE'$APTPMT;
}*IF APTE'$APTDWS AND PMT[PMTX']$PMTDKA#0 DO;
}-MRELDP(PMTX'//CASE3'ERROR1: MEC,MEM) IF DISK;
}*ENDIF;
}*IF PMT[PMTX]$PMTDKA#0 DO;
}-MGETDP(PMTX//CASE3'ERROR2: MEC,MEM) IF DISK;
}*ENDIF;
}*APT[APTX'] _ APT[FIRST'NOT'CWS];
}*APT[FIRST'NOT'CWS] _ (-1)@APTUH V' 1@APTDWS V' 1@APTCWS V'
}?PMTX@APTPMT;
}*LCWS _ LCWS+1;
}*RETURN;

CASE3'ERROR1:
}*GOTO RELDP'FAILURE;
CASE3'ERROR2:
}*APT[APTX'] _ APT[LAST'DWS];
}*APT[LAST'DWS] _ 0;
}*LDWS _ LDWS-1;
}*GOTO GETDP'FAILURE;

*}"CASE 4: NEITHER CWS NOR DWS FULL
CASE4:}$IF PMT[PMTX]$PMTDKA#0 DO;
}-MGETDP(PMTX//CASE4'ERROR1: MEC,MEM) IF DISK;
}*ENDIF;
}*APT[FIRST'FREE] _ APT[FIRST'NOT'CWS];
}*APT[FIRST'NOT'CWS] _ (-1)@APTUH V' 1@APTDWS V' 1@APTCWS V'
}?PMTX@APTPMT;
}*LCWS _ LCWS+1;
}*LDWS _ LDWS+1;
}*RETURN;

CASE4'ERROR1:
GETDP'FAILURE:
}*FRETURN(MEC,MEM) IF (MEC='RNE' OR MEC='DME' OR MEC='DKE');
}*PUNT(MEC);

RELDP'FAILURE:
}*FRETURN('DME',213) IF MEC='DRE';
}*FRETURN('DKE',214) IF MEC='KRE';
}*PUNT(MEC);
}(END;
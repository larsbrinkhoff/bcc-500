}(PROGRAM ACQPMT;
}*INCLUDE PROFILE, SPTD, PMTD, GLOBAL, PMS'MACROS;

*}"ACQUIRE AND INITIALIZE A PMT ENTRY.}"ENTER WITH PMTX = -1 OR 
*}%SOME VALUE INDEXING PMT.}"IF -1, GETS "NEXT" FREE ENTRY (ONE
*}%WHOSE CL=0.}"IF THERE IS NONE, IT "FREES" ONE.)}"IF # -1,
*}%IT STILL REQUIRES THAT THE ENTRY BE FREE.}"THE ENTRY IS ZEROED
*}%AND AL AND CL ARE SET TO THE NAME OF THE CALLING SUB-PROCESS,
*}%PMTX IS RETURNED.

}*DECLARE NAME, PMTE, MEC, MEM;

}(ENTRY ACQPMT(PMTX), FRETURN, MONITOR _ 50;
}*NAME _ SPNAME;

}(ENTRY MACQPMT(PMTX, NAME), FRETURN;

}*IF PMTX=-1 DO;
}-FOR PMTX_PMT'PTR TO NPMTE DO;
FIND'FREE'PMT:}"(PMT'PTR_PMTX+1 & GOTO SET'PMTE) IF PMT[PMTX]$PMTCL=0;
}-ENDFOR;
}-(PMTX_PMT'PTR_1 & GOTO FIND'FREE'PMT) IF PMT'PTR#1;
}-PMTX_FREE'PMT(//FRETURN(MEC,MEM): MEC,MEM);
SET'PMTE:}$PMTE_@PMT[PMTX];
}*ELSE DO;
}-GET'PMT'POINTER;
}-FRETURN('PMA',119) IF PMTE.PMTCL#0;
}*ENDIF;
*}"INITIALIZE THE PMT ENTRY
}*PMT[PMTX]_LONGLONG'ZERO;
}*PMTE.PMTAL_PMTE.PMTCL_NAME;

}*RETURN PMTX;

PMTX'ILLEGAL:
*}"CONTROL COMES HERE IF CALLER PASSES OUT-OF-BOUNDS PMT INDEX
}*FRETURN('PMI',110);

}(END;

}(PROGRAM NPPMT;
}*INCLUDE PROFILE, PMTD, SPTD, SWPD, RESMON, GLOBAL, APTD;
}*INCLUDE PMS'MACROS;

*}"CREATE A PRIVATE MEMORY PAGE AND PUT ITS REAL NAME INTO PMT.
*}%ENTER WITH PMTX.}"A PRIVATE MEMORY PAGE IS CREATED AND ITS
*}%UNIQUE NAME AND DISK ADDRESS ARE PUT INTO THE APPROPRIATE
*}%FIELDS OF THE PMT ENTRY.}"THE PAGE IS PUT INTO THE CORE AND DRUM
*}%WORKING SETS OF THE PROCESS.}"THE SF BIT AND PMTDWS BITS ARE SET
*}%AND THE OTHER STATUS BITS OF THE ENTRY ARE CLEARED.

}*DECLARE KEY, STATUS, MEC, MEM, PMTE, APTE, TEMP, APTX;

}(FUNCTION NPPMT(PMTX), FRETURN, MONITOR _ 51;
}*KEY _ SPKEY; STATUS _ SPSTATUS;

*}"ENTRY POINT FOR MONITOR
}(ENTRY MNPPMT(PMTX, KEY, STATUS), FRETURN;

*}"CHECK FOR ERRORS
}*GET'PMT'POINTER;
}*FRETURN('PMC',121) IF (KEY A' PMTE.PMTCL)=0;* MUST HAVE CONTROL
}*FRETURN('PMF',122) UNLESS PMTE.PMTDKA=0;* ENTRY MUST BE CLEAR
}*FRETURN('DWF',123) IF (DWS'FULL AND STATUS$DDWSO=0);
}*FRETURN('CWF',124) IF (CWS'FULL AND STATUS$DCWSO=0);
*!!}'FRETURN('KSE',125) IF RSE[0]$DKSP=0;

*}"SET-UP PMT[PMTX]
*}"LEAVE OUT DKA FOR THE MOMENT SO THAT PUT'IN'CWS DOESN'T DO A KDT.
}*TEMP_PMTE.WD3;}//* PRESERVE AL AND CL */
}*PMT[PMTX] _ LONGLONG'ZERO;
}*PMTE.PMTUN _ PMT[1]$PMTUN;* USE CB'S UNIQUE NAME
}*PMTE.PMTINDEX _ PMTX;* WITH PMT INDEX OVERWRITTEN
}*PMTE.WD3 _ TEMP A' (1@PMTDWS V' (-1)@PMTAL V' (-1)@PMTCL);

*}"PUT PAGE IN APT WITH 'NEW-PAGE' BIT SET AND
*}"SEND REQUEST FOR NEW PAGE TO AMC.}"THIS CAN FAIL ONLY IF THE REAL
*}"NAME WE JUST CREATED ALBEADY EXISTS.

}*APTX _ PUT'IN'CWS(PMTX,0,0//FRETURN(MEC,MEM): MEC,MEM);
}*APT[APTX]$APTNPG _ 1;
}*PMTE.PMTDKA _ GET'DISK'ADDR(PMT[1]$PMTDKA//NP81);
}*AMC'REQUEST(CRGFP,PMTX,PRTI,0//VALUE PUNT(MEC):MEC,MEM);

*}"IF THE AMC WAS ABLE TO ASSIGN A FREE CORE PAGE FOR OUR NEW PAGE,
*}"WE HAVE NOW TO ZERO THE PAGE, SET SF, AND RESET NPG.}"IF THERE WAS NO
*}"FREE CORE, AMC'REQUEST WILL HAVE BLOCKED AND THE AMC WILL HAVE ATTEMPTED
*}"TO CREATE OUR PAGE AS IT SWAPPED OUR PROCESS BACK IN.}"IF THIS 
*}"SUCCEEDED, WE WILL HAVE SF SET, NPG RESET, AND THE PAGE WILL BE
*}"ZEROED.}"IF IT FAILED WE WILL HAVE SF RESET, NPG SET, AND SOME
*}"ERROR INDICATION.
}*RETURN IF PMTE.PMTSF;
}*PUNT('NPG') IF (NOT PMTE.PMTDWS OR PMTE.PMTERR);
}*PMTE.PMTSF _ 1;
}*APT[APTX]$APTNPG _ 0;
}*SETPRMB(NEW'PAGE'BYTE,PMTX);
}*BSET(PAGESA(NEW'PAGE'BYTE), 0, 2048);
}*RETURN;

*}"ERROR RETURN FROM DISK ALLOCATOR
NP81:}%PUNT('KAL');

PMTX'ILLEGAL:
*}"CONTROL COMES HERE IF CALLER PASSES OUT-OF-BOUNDS PMT INDEX
}*FRETURN('PMI',110);

}(END;

}(PROGRAM RNPMT;
}*INCLUDE SPTD, GLOBAL, PMTD, PROFILE, PMS'MACROS;

*}"PUT SPECIFIED REAL NAME INTO DESIGNATED PMT ENTRY.}"THE UNIQUE NAME,
*}%AND DISK ADDRESS SUPPLIED ARE SIMPLY COPIED INTO THE APPROPRIATE
*}%FIELDS OF THE DESIGNATED PMT ENTRY.}"THE FP BIT IS SET AND THE
*}%OTHER STATUS BITS ARE CLEARED.

}*DECLARE PMTE, TEMP;

}(FUNCTION RNPMT(PMTX,LONG UNQN, INTEGER DKA), FRETURN,
}PMONITOR _ 52;
*}"CHECK FOR ERRORS
}*FRETURN('STS',127) UNLESS SPSTATUS$SD;
}*GET'PMT'POINTER;
}*FRETURN('PMC',121) IF (SPKEY A' PMTE.PMTCL) = 0;
}*FRETURN('PMF',122) IF PMTE.PMTDKA#0;
}*FRETURN('ARG',999) IF DKA=0;

*}"PUT REAL NAME INTO PMT[PMTX]
}*TEMP _ PMTE.WD3;
}*PMT[PMTX] _ LONGLONG'ZERO;
}*PMTE.PMTUN_UNQN;
}*PMTE.PMTDKA_DKA;
}*PMTE.WD3 _ TEMP A' ((-1)@PMTAL V' (-1)@PMTCL);
}*PMTE.PMTFP_1;*}"TREAT LIKE FILE PAGE
*
}*RETURN;

PMTX'ILLEGAL:
*}"CONTROL COMES HERE IF CALLER PASSES OUT-OF-BOUNDS PMT INDEX
}*FRETURN('PMI',110);

}(END;

}(PROGRAM CLRPMT;
}*INCLUDE PROFILE,SPTD,PMTD,GLOBAL,PMS'MACROS,SWPD,RESMON;

*}"CLEAR PMT ENTRY AND RELEASE ITS PAGE.}"THE PAGE WHOSE REAL NAME
*}%APPEARS IN THE DESIGNATED PMT ENTRY IS RELEASED FROM THE CORE
*}%AND DRUM WORKING SETS OF THE PROCESS.}"THE PAGE IS DESTROYED
*}%IF IT IS PRIVATE MEMORY.}"THE PMT ENTRY IS CLEARED.}"AL AND CL
*}%ARE PRESERVED.

}*DECLARE KEY, MEC, MEM, PMTE, TEMP;

}(FUNCTION CLRPMT(PMTX), FRETURN, MONITOR _ 53;
}*KEY _ SPKEY;

*}"ENTRY POINT FOR MONITOR
}(ENTRY MCLRPMT(PMTX, KEY), FRETURN;

*}"CHECK FOR ERRORS
}*GET'PMT'POINTER;
}*FRETURN('PMC',121) IF KEY A' PMTE.PMTCL=0;

*}"RELEASE PAGE FROM DWS, AND DESTROY IT IF IT IS PRIVATE MEMORY.

*** NOTE: THERE IS REAL INEFFICIENCY HERE IF PAGE DOES GET DESTROYED

}*RELEASE'THIS'DWS(PMTX//FRETURN(MEC,MEM): MEC,MEM);
}*PMTE.PMTDWS _ 0;
}*IF (PMTE.PMTDKA#0 AND PMTE.PMTFP=0) DO;
}-AMC'REQ'WITH'RN(CRDEST,PMTE.PMTUN,PMTE.PMTDKA,@PRT[PRTI],1//
}2VALUE PUNT(MEC): MEC, MEM);
}-REL'DISK'ADDR(PMTE.PMTDKA// VALUE PUNT('KBT'));
}*ENDIF;

*}"CLEAR PMT[PMTX] EXCEPT FOR CL AND AL AND
*}"CLEAR PHYSICAL MAP IF REFERENCE FLAG IS SET.
}*IF PMTE.PMTRF DO;
}-CLEAR'MAP;
}*ENDIF;
}*TEMP _ PMTE.WD3;
}*PMT[PMTX] _ LONGLONG'ZERO;
}*PMTE.WD3 _ TEMP A' ((-1)@PMTAL V' (-1)@PMTCL);
}*RETURN;

PMTX'ILLEGAL:
*}"CONTROL COMES HERE IF CALLER PASSES OUT-OF-BOUNDS PMT INDEX
}*FRETURN('PMI',110);

}(END;

}(PROGRAM DELPMT;
}*INCLUDE PROFILE, SPTD, PMTD, GLOBAL, PMS'MACROS;

*}"RELEASE PMT ENTRY.}"DOES A CLRPMT BUT LEAVES AL AND CL CLEARED AS WELL.
*}%ALL POINTERS TO THE DESIGNATED PMT ENTRY FROM VARIOUS MAPS ARE
*}%DELETED AT THIS TIME.

}*DECLARE KEY, I, LMAP, J;
}*DECLARE MEC, MEM, LM, SPTE, PRME, PMTE;
}*DECLARE FIXED FIELD B0'11(0:0,11), B12'23(0:12,23),
}-BYTE0(0:4,11), BYTE1(0:16,23);

}(FUNCTION DELPMT(PMTX), FRETURN, MONITOR _ 54;
}*KEY _ SPKEY;

*}"ENTRY POINT FOR MONITOR
}(ENTRY MDELPMT(PMTX, KEY), FRETURN;

*}"CHECK FOR ERRORS
}*GET'PMT'POINTER;
}*FRETURN('PMC',121) IF KEY A' PMTE.PMTCL=0;

*}"FIRST CLEAR PMT[PMTX]
}*MCLRPMT(PMTX, KEY//VALUE PUNT(MEC):MEC,MEM);

*}"PMTX MUST NOW BE REMOVED FROM ALL MAPS, DAMMIT.
*}"THE PROCESS MAP:
}*FOR I _ 0 TO 63 DO;
}-IF (PRME _ PRMAP[I]) # 0 DO;
}0PRMAP[I]$B0'11 _ 0 IF PRME$BYTE0=PMTX;
}0PRMAP[I]$B12'23 _ 0 IF PRME$BYTE1=PMTX;
}-ENDIF;
}*ENDFOR;
*}"THE SUB-PROCESS MAPS:
}*FOR I _ 1 TO NSPTE DO;
}-IF SPT[I]$SPTOL#0 DO;
}0SPTE _ @SPT[I];
}0LMAP _ SPTE.SPTLM;
}0LM _ 0;
}0FOR J _ 0 TO LMAP DO;
}3IF SPTE.(PXFLDS[J])=PMTX DO;
}6SPTE.(PXFLDS[J]) _ 0;
}6SPTE.(ROFLDS[J]) _ 0;
}3ENDIF;
}3LM _ J IF SPTE.(PXFLDS[J])#0;
}0ENDFOR;
}0SPTE.SPTLM _ LM;
}-ENDIF;
}*ENDFOR;

*}"FINALLY, FREE PMT[PMTX].
}*PMTE.WD3 _ 0;
}*RETURN;

PMTX'ILLEGAL:
*}"CONTROL COMES HERE IF CALLER PASSES OUT-OF-BOUNDS PMT INDEX
}*FRETURN('PMI',110);

}(END;

}(PROGRAM SET'PMT'FIELDS;
}*INCLUDE PROFILE, SPTD, PMTD, GLOBAL, PMS'MACROS;

*}"SET AL, CL, OR RO FIELDS OF A PMT ENTRY.}"IF CL = 0, THE PMT ENTRY
*}%IS RELEASED WITH DELPMT.

}*DECLARE KEY, MEC, MEM, PMTE;

}(ENTRY SPMTAL(PMTX,AL), FRETURN, MONITOR _ 55;
}*KEY _ SPKEY;
*}"ENTRY POINT FOR MONITOR
}(ENTRY MSPMTAL(PMTX, AL, KEY), FRETURN;
*}"CHECK FOR ERRORS
}*GET'PMT'POINTER;
}*FRETURN('PMC',121) UNLESS
}-(KEY A' PMTE.PMTCL#0 OR
}-(KEY A' PMTE.PMTAL#0 AND
}0(PMTE.PMTAL A' N' AL) A' N' KEY=0));
}*PMTE.PMTAL_AL;
}*RETURN;

}(ENTRY SPMTCL(PMTX, CL), FRETURN, MONITOR _ 56;
}*KEY _ SPKEY;
*}"ENTRY POINT FOR MONITOR
}(ENTRY MSPMTCL(PMTX, CL, KEY), FRETURN;
*}"CHECK FOR ERRORS
}*GET'PMT'POINTER;
}*FRETURN('PMC',121) IF KEY A' PMTE.PMTCL = 0;
*}"RELEASE PMT[PMTX] IF CL GOES TO 0.
}*MDELPMT(PMTX,KEY//VALUE PUNT(MEC):MEC,MEM) IF CL=0
}/ELSE PMTE.PMTCL_CL;
}*RETURN;

}(ENTRY SPMTRO(PMTX,RO), FRETURN, MONITOR _ 57;
*}"CHECK FOR ERRORS
}*GET'PMT'POINTER;
}*FRETURN('PMC',121) IF SPKEY A' PMTE.PMTCL = 0;
}*RETURN IF PMTE.PMTRO=RO;
}*FRETURN('FPR',135) IF (PMTE.PMTRO=1 AND PMTE.PMTFP=1);
*}"SET/RESET THE BIT AND CLEAR THE PHYSICAL MAP IF NECESSARY
}*PMTE.PMTRO_RO;
}*IF PMTE.PMTRF DO;
}-CLEAR'MAP;
}*ENDIF;
}*RETURN;

PMTX'ILLEGAL:
*}"CONTROL COMES HERE IF CALLER PASSES OUT-OF-BOUNDS PMT INDEX
}*FRETURN('PMI',110);

}(END;

}(PROGRAM READPMT;
}*INCLUDE GLOBAL, PMTD, APTD, PROFILE, PMS'MACROS;

*}"READ A DESIGNATED PMT ENTRY.}"FIVE WORDS ARE COPIED INTO THE CALLER'S
*}%ARRAY.}"THE FIRST FOUR ARE THE FOUR WORDS OF THE PMT ENTRY.
*}%THE FIFTH IS THE APT ENTRY WHICH POINTS THE PMT ENTRY OR ZERO IF
*}%THERE IS NONE SUCH IN APT.

}*DECLARE I, PMTE;

}(FUNCTION READPMT(PMTX, ARRAY PMT'ARRAY), FRETURN, MONITOR _ 58;

*}"CHECK FOR ERRORS
}*GET'PMT'POINTER;
}*PMT'ARRAY[I] _ PMTE[I] FOR I _ 0 TO LPMTE-1;
}*PMT'ARRAY[LPMTE] _ GET'APT'ENTRY(PMTX:I);
}*RETURN;

}(FUNCTION READ'APT(APTX), FRETURN, MONITOR _ 72;
}*FRETURN('API',164) UNLESS (1<=APTX AND APTX<=NAPTE);
}*RETURN APT[NAPTE-APTX+1];

PMTX'ILLEGAL:
*}"CONTROL COMES HERE IF CALLER PASSES OUT-OF-BOUNDS PMT INDEX
}*FRETURN('PMI',110);

}(END;

}(PROGRAM AGE'APS;
*
*}"MAINTAIN USE HISTORIES FOR ACTIVE PAGES
*
}*INCLUDE APTD, PROFILE, PMTD, GLOBAL, PMS'MACROS;
}*DECLARE I;

}(ENTRY AGE'CWS();
}*FOR I _ APTL-1 BY -1 TO LAST'CWS DO;
*
*}"THE CODE HERE IS THE SAME AS:
*},APT[I]$APTUH_((PMT[APT[I]$APTPMT]$PMTRF LSH LAPTUH)
*}.V' APT[I]$APTUH) RSH 1;
*},PMT[APT[I]$APTPMT]$PMTRF_0;
*}"I.E., RIGHT SHIFT THE USE HISTORY FIELD BY 1, DRAGGING IN FROM
*}%THE LEFT A 1 IF THE REFERENCED FLAG IS SET FOR THE GIVEN PAGE,
*}%ELSE 0.}"
}-.EAX APT[I], LDX $G'[4103B], EAX $(PMT$WD0), LDA 0,
}-.XMA $G'[4100B], LSHA LAPTUH, EAX APT[I],
}-.IOR $G'[4101B], LSHA -1, STA $G'[4101B];
}*ENDFOR;
}*CLEAR'MAP;
}*RETURN;

}(ENTRY AGE'DWS();
}*FOR I _ LAST'CWS-1 BY -1 TO LAST'DWS DO;
*}"THE CODE HERE IS THE SAME AS:
*},APT[I]$APTUH_APT[I]$APTUH RSH 1;
*}"I.E., RIGHT SHIFT THE USE HISTORY FIELD BY 1, DRAGGING IN A ZERO
*}%FROM THE LEFT.
}-.EAX APT[I], .LDA $G'[4101B], LSHA -1, STA $G'[4101B];
}*ENDFOR;
}*RETURN;

}(END;

}(PROGRAM FIND'APT'ENTRY;
}*INCLUDE APTD, PROFILE, PMTD, GLOBAL, PMS'MACROS;
}*DECLARE I, OLDEST, USE;

}(ENTRY FIND'OLDEST'CWS(), FRETURN;
}*FRETURN IF LCWS<=0;
LOOK'THROUGH'CWS:
}*USE _ 4B7-1;* MAKES USE IMPOSSIBLY YOUNG
*}"THE FOLLOWING LOOP COMPARES EACH CWS ENTRY WITH USE, LEAVING THE
*}$"OLDEST" IN USE AND ITS INDEX IN I.}"REMEMBER THAT THE 1'S
*}$REPRESENT REFERENCED INDICATIONS.}"HENCE, IT IS THE 0'S THAT
*}$STAND FOR OLD AGE.}"THE LOOP LOOKS FOR THE NUMERICALLY SMALLEST
*}$VALUE OF PGL*2^17+LOCK*2^16+UH*2^8+RF*2^8+UH*2^(-1).
}*FOR I _ APTL-1 BY -1 TO LAST'CWS DO;
}-.EAX APT[I], LDX $G'[4103B], EAX $(PMT$WD0),
}-.LDA $G'[4100B], LSHA LAPTUH, EAX APT[I],
}-.IOR $G'[4101B], LSHD -(LAPTUH+1), IOR $G'[4102B];
}-.LSHD LAPTUH, ICP USE, BGE R'[4], STA USE, LDA I, STA OLDEST;
}*ENDFOR;
}*RETURN(OLDEST, APT[OLDEST]);

}(ENTRY FIND'OLDEST'DWS(), FRETURN;
}*FRETURN IF LDWS<=0;
}*GOTO LOOK'THROUGH'CWS IF LDWS<=LCWS;
}*USE _ 4B7-1;
*}"THIS LOOP BEHAVES AS THE ONE ABOVE, EXCEPT THAT JUST THE USE
*}$HISTORY FIELDS ARE COMPARED AS THEY CURRENTLY ARE.
}*FOR I _ LAST'CWS-1 BY -1 TO LAST'DWS DO;
}-.EAX APT[I], LDA $G'[4101B], ICP USE, BGE R'[4];
}-.STA USE, LDA I, STA OLDEST;
}*ENDFOR;
}*RETURN(OLDEST, APT[OLDEST]);

}(ENTRY GET'APT'ENTRY(PMTX);
}*FOR I _ APTL-1 BY -1 TO LAST'DWS DO;
}-(RETURN(APT[I], I)) IF APT[I]$APTPMT=PMTX;
}*ENDFOR;
}*RETURN(0,0);

}(END;

}(PROGRAM CHANGE'WS;
}*INCLUDE PROFILE, GLOBAL, PMTD, APTD, SPTD, PMS'MACROS;

*}"INSERT OR REMOVE DESIGNATED PMT ENTRY INTO/FROM WORKING SETS.
*}%NO ACTION OCCURS IF ENTRY IS ALREADY IN WORKING SET.}"IF WORKING
*}%SET IS FULL, ANOTHER PAGE IS DELETED TO MAKE ROOM FOR IT.
*}%AN ENTRY PLACED INTO CWS WILL NOT NECESSARILY CAUSE AN IMMEDIATE
*}%XFER INTO CORE, I.E., A PAGE FAULT MAY OCCUR FIRST.
*}%IT IS POSSIBLE TO SUPPLY -1 AS THE PMT ENTRY NUMBER, IN WHICH
*}%CASE, A "CONVENIENT" ENTRY WILL BE DELETED FROM THE WORKING SET.

}*DECLARE APTX, APTE, MEC, MEM, PMTE;

}(ENTRY PPDWS(PMTX), FRETURN, MONITOR _ 65;
}*GET'PMT'POINTER;
}*GET'APT'ENTRY(PMTX: APTE,APTX);
}*RETURN IF IN'DWS;
}*FRETURN('DWF',133) IF (DWS'FULL AND SPSTATUS$DDWSO=0);
}*PUT'IN'DWS(PMTX//FRETURN(MEC,MEM): MEC,MEM);
}*RETURN;

}(ENTRY PPCWS(PMTX), FRETURN, MONITOR _ 66;
}*GET'PMT'POINTER;
}*GET'APT'ENTRY(PMTX: APTE,APTX);
}*RETURN IF IN'CWS;
}*IF NOT IN'DWS DO;
}-FRETURN('NOD', 208) IF SPSTATUS$DPNOD=0;
}-FRETURN('DWF',133) IF (DWS'FULL AND SPSTATUS$DDWSO=0);
}*ENDIF;
}*FRETURN ('CWF',132) IF SPSTATUS$DCWSO=0;
}*PUT'IN'CWS(PMTX,APTX,APTE//FRETURN(MEC,MEM): MEC,MEM);
}*RETURN;

}(ENTRY DPDWS(PMTX), FRETURN, MONITOR _ 67;
}*IF PMTX # -1 DO;
}-GET'PMT'POINTER;
}-PMTX _ RELEASE'THIS'DWS(PMTX//FRETURN(MEC,MEM): MEC,MEM);
}*ELSE DO;
}-PMTX _ RELEASE'SOME'DWS(//FRETURN(MEC,MEM): MEC,MEM);
}*ENDIF;
}*RETURN PMTX;

}(ENTRY DPCWS(PMTX), FRETURN, MONITOR _ 68;
}*IF PMTX # -1 DO;
}-GET'PMT'POINTER;
}-PMTX _ RELEASE'THIS'CWS(PMTX//FRETURN(MEC,MEM): MEC,MEM);
}*ELSE DO;
}-PMTX _ RELEASE'SOME'CWS(//FRETURN(MEC,MEM): MEC,MEM);
}*ENDIF;
}*RETURN PMTX;

PMTX'ILLEGAL:
*}"CONTROL COMES HERE IF CALLER PASSES OUT-OF-BOUNDS PMT INDEX
}*FRETURN('PMI',110);

}(END;

}(PROGRAM READ'LWS;
}*INCLUDE PROFILE, GLOBAL, APTD;

*}"READ OR SET CURRENT VALUES OF WORKING SET SIZES, INCLUDING THEIR
*}%OVERFLOW SIZES.}"SEE BELOW FOR THE RULES FOR SETTING SIZES.

}*DECLARE NCODES _ 6;
}*DECLARE CHARACTER ARRAY CODES[NCODES] _
}-('CWS', 'OCW', 'MCW', 'DWS', 'ODW', 'MDW');
}*DECLARE POINTER ARRAY PTRS[NCODES] _
}-(@LCWS, @OLCWS, @MLCWS, @LDWS, @OLDWS, @MLDWS);
}*DECLARE LABEL ARRAY ACTION[NCODES] _
}-(SET'LCWS,SET'OLCWS,SET'MLCWS,SET'LDWS,SET'OLDWS,SET'MLDWS);
}*DECLARE I, LWS, MEC, MEM;
}*DECLARE DAMMIT;

}(ENTRY READ'LWS(CODE), FRETURN, MONITOR _ 70;
}*GOTO RETURN'LENGTH IF (0<=CODE AND CODE<=NCODES-1);
}*FOR I _ 0 TO NCODES-1 DO;
}-(CODE_I & GOTO RETURN'LENGTH) IF CODES[I]=CODE;
}*ENDFOR;
}*FRETURN('ARG', 191);
RETURN'LENGTH:
}*LWS _ $PTRS[CODE];
}*RETURN LWS;

}(ENTRY SET'LWS(CODE, LNGTH), FRETURN, MONITOR _ 71;
}*GOTO ACTION[CODE] IF (0<=CODE AND CODE<=NCODES-1);
}*FOR I _ 0 TO NCODES-1 DO;
}-(CODE_I & GOTO ACTION[I]) IF CODES[I]=CODE;
}*ENDFOR;
}*FRETURN('ARG', 191);
SET'LCWS:
*}"LCWS CANNOT BE MADE LESS THAN 0 OR GREATER THAN ITS CURRENT VALUE.
*}"DECREASING IT IMPLIES RELEASING PAGES FROM CWS.
}*FRETURN('WSL',192) UNLESS (0<=LNGTH AND LNGTH<=LCWS);

REDUCE'CWS:
}*FOR I _ LCWS-1 BY -1 TO LNGTH DO;
}-RELEASE'SOME'CWS(//RETURN'NEW'LNGTH: MEC,MEM);
}*ENDFOR;
}*GOTO RETURN'NEW'LNGTH;

SET'OLCWS:
*}"OLCWS CANNOT BE MADE LESS THAN 0 OR GREATER THAN MLCWS.}"MAKING IT
*}"SMALLER THAN THE CURRENT VALUE OF LCWS IMPLIES RELEASING
*}"PAGES FROM CWS.
}*FRETURN('WSL',192) UNLESS (0<=LNGTH AND LNGTH<=MLCWS);
}*OLCWS _ LNGTH;
}*GOTO RETURN'NEW'LNGTH IF OLCWS>=LCWS;
}*GOTO REDUCE'CWS;

SET'MLCWS:
SET'MLDWS:
*}"THIS FUNCTION CANNOT BE USED TO MODIFY THESE PARAMETERS.
}*FRETURN('ARG',191);

SET'LDWS:
*}"LDWS CANNOT BE MADE LESS THAN 0 OR GREATER THAN ITS CURRENT VALUE.
*}"DECREASING IT IMPLIES RELEASING PAGES FROM DWS.
}*FRETURN('WSL',192) UNLESS (0<=LNGTH AND LNGTH<=LDWS);

REDUCE'DWS:
}*FOR I _ LDWS-1 BY -1 TO LNGTH DO;
}-RELEASE'SOME'DWS(//RETURN'NEW'LNGTH: MEC,MEM);
}*ENDFOR;
}*GOTO RETURN'NEW'LNGTH;

SET'OLDWS:
*}"OLDWS CANNOT BE MADE LESS THAN 0 OR GREATER THAN MLDWS.}"MAKING IT
*}"SMALLER THAN THE CURRENT VALUE OF LDWS IMPLIES RELEASING PAGES FROM
*}"DWS.
}*FRETURN('WSL',192) UNLESS (0<=LNGTH AND LNGTH<=MLDWS);
}*OLDWS _ LNGTH;
}*GOTO REDUCE'DWS IF OLDWS<LDWS;

RETURN'NEW'LNGTH:
}*OLCWS _ MAX(OLCWS,LCWS);
}*OLDWS _ MAX(OLDWS,LDWS);
}*RETURN DAMMIT _ $PTRS[CODE];

}(END;

}(PROGRAM AMC'REQUEST;
}*INCLUDE RESMON, SWPD, GLOBAL, PROFILE, ICTD;
}*DECLARE LONG UNIQUE'NAME;
}*DECLARE DISK'ADDRESS, QUEUE, NO'FREE'NODE'CNT, FREE'NODE,
}-ERROR'CODE, TRY'AGAIN'CNT, REQUEST'TIME,
}-REQUEST, PRT'ADDRESS, I, BEGIN'PTR;
}*DECLARE POINTER FREE'LIST _ SWFREL - RESM;
}*DECLARE NO'FREE'NODE'LIM _ 100, TRY'AGAIN'LIM _ 5,
}-AMC'WAIT'LIMIT _ 1000,
}-LONG WAIT'TIME _ (0,30000),
}-LONG NPG'WAIT'TIME _ (0,10000);
}*DECLARE ARRAY INTERNAL'ARRAY[LSWQN];
}*DECLARE LABEL ARRAY ERROR'ACTION[NSWRCDS-CRRSP+1] _
}-(CRRSP'ERROR, CWRPG'ERROR, CRDK'ERROR, CRWUN'ERROR,
}.CRKD'ERROR, CRGFP'ERROR, CRDEST'ERROR);
}*DECLARE ARRAY REAL'CORE[4*2048:,RESM];

*}"ALL REQUESTS ON THE AMC ARE MADE THROUGH THIS FUNCTION.}"IT HAS
*}"3 ENTRY POINTS - THE FIRST TAKES A REQUEST CODE, A PMT INDEX,
*}"A PRT INDEX, AND A 'WAIT FLAG' AS ARGUMENTS.}"THE SECOND TAKES A
*}"REQUEST CODE, A UNIQUE NAME, A DISK ADDRESS, A VIRTUAL PRT ADDRESS,
*}"AND A 'WAIT FLAG'.}"THE THIRD TAKES A FULLY FORMED REQUEST NODE.
*}"THE 'WAIT FLAG' IS PASSED ON TO THE AMC IN THE WAKF FIELD OF THE
*}"REQUEST.}"IF IT IS 0, THE MONITOR WILL NOT BLOCK AND WAIT FOR THE
*}"AMC TO RESPOND ON THOSE ACTIVATE REQUESTS WHICH CANNOT BE IMMEDIATELY
*}"COMPLETED.

}(ENTRY AMC'REQUEST(REQUEST'CODE, PMT'INDEX, PRT'INDEX,
}IWAIT'FLAG), FRETURN;
}*UNIQUE'NAME _ PMT[PMT'INDEX]$PMTUN;
}*DISK'ADDRESS _ PMT[PMT'INDEX]$PMTDKA;
}*PRT'ADDRESS _ @PRT[PRT'INDEX];

}(ENTRY AMC'REQ'WITH'RN(REQUEST'CODE, LONG UNIQUE'NAME,
}&INTEGER DISK'ADDRESS, PRT'ADDRESS, WAIT'FLAG), FRETURN;

FORM'REQUEST:
}*REQUEST _ @INTERNAL'ARRAY[0];
}*BSET(REQUEST, 0, LSWQN);
}*REQUEST.SWUN _ UNIQUE'NAME;
}*REQUEST.SWDKA _ DISK'ADDRESS;
}*REQUEST.SWWAKF _ WAIT'FLAG;
}*REQUEST.SWEPRT _ PRT'ADDRESS-RESM;
}*REQUEST.SWRCD _ REQUEST'CODE;
}*REQUEST.SWEQP _ SWEOQ;
}*GOTO SEND'REQUEST;

}(ENTRY DIRECT'AMC'REQ(ARRAY REQUEST'ARRAY), FRETURN;
}*REQUEST _ @REQUEST'ARRAY[0];
}*REQUEST'CODE _ REQUEST.SWRCD;
}*WAIT'FLAG _ REQUEST.SWWAKF;

SEND'REQUEST:
}*QUEUE _ AMC'QUEUES[REQUEST'CODE] - RESM;
}*TRY'AGAIN'CNT _ NO'FREE'NODE'CNT _ 0;

GET'FREE'NODE:
*}"REMOVE A NODE FROM THE SWAPPER'S FREE LIST.
}*PROTECT(2);
}-GOTO NO'FREE'NODES IF
}0(FREE'NODE _ REAL'CORE[FREE'LIST]$MADF) = SWEOQ;
}-BEGIN'PTR _ REAL'CORE[FREE'LIST]$MADF _
}0REAL'CORE[FREE'NODE]$SWFEQP;
}-REAL'CORE[FREE'LIST]$MADF1 _
}0FREE'NODE - SWFEQP$FDDISP IF BEGIN'PTR = SWEOQ;
}*UNPROTECT(2);
*}"NOW COPY OUR READY-TO-GO NODE INTO IT.
}*BCOPY(FREE'NODE+RESM, REQUEST, LSWQN);
*}"AND PLACE NODE ON THE DESIGNATED SWAPPER QUEUE.
}*PROTECT(2);
}-IF REAL'CORE[QUEUE]$MADF = SWEOQ DO;
}0REAL'CORE[QUEUE]$MADF _
}3REAL'CORE[QUEUE]$MADF1 _ FREE'NODE;
}-ELSE DO;
}0REAL'CORE[QUEUE]$MADF1 _
}3REAL'CORE[REAL'CORE[QUEUE]$MADF1]$SWEQP _ FREE'NODE;
}-ENDIF;
}-ACTL.WD0 _ 1 IF QUEUE = AMCQ-RESM;
}*UNPROTECT(2);
*}"START AMC
}*ATTENTION(1);
*}"NOW SEE WHAT TO DO NEXT.
}*RETURN IF QUEUE # AMCQ-RESM;
}*FOR I _ 1 TO AMC'WAIT'LIMIT DO;
}-GOTO CHECK'RESPONSE IF ACTL.WD0 # 1;
}*ENDFOR;
}*PUNT('SNR');

CHECK'RESPONSE:
}*RETURN IF ACTL.WD0=0;
}*PUNT('AME') IF ACTL.WD0 # 4B7;
}*ERROR'CODE _ ACTL.WD1;
}*REQUEST'TIME _ 1;
}*GOTO WAIT'FOR'WAKEUP IF ERROR'CODE=WAITWK;
}*GOTO TRY'AGAIN'LATER IF ERROR'CODE=CPWAIT;

ANALYZE'ERROR:
}*PUNT('AME') IF (ERROR'CODE=ARQOB OR ERROR'CODE=NOREQ);
}*GOTO ERROR'ACTION[REQUEST'CODE-CRRSP];

WAIT'FOR'WAKEUP:
*}"RETURN IF WAIT'FLAG ISN'T SET.}"OTHERWISE
*}"BLOCK UNTIL AMC COMPLETES THE REQUEST AND GENERATES A WAKEUP.
*}"ERRORS ENCOUNTERED DURING THIS PART OF THE PROCESSING ARE
*}"REPORTED IN A SPECIAL FIELD IN PRT, WHICH THE AMC CLEARS WHEN IT
*}"RETURNS A WAITWK RESPONSE.
}*RETURN IF WAIT'FLAG=0;
}*MBLOCK(AMC);
}*PROTECT(1);
}-ERROR'CODE _ PRT[PRTI]$PRACTE;
}-PRT[PRTI]$PRACTE _ 0;
}*UNPROTECT(1);
}*RETURN IF ERROR'CODE = 0;
}*REQUEST'TIME _ 0;
}*GOTO ANALYZE'ERROR;

TRY'AGAIN'LATER:
*}"BLOCK FOR A LITTLE WHILE (300 MILLI-SECS) AND THEN MAKE THE REQUEST
*}"AGAIN.}"PUNT IF THIS HAPPENS MORE THAN TRY'AGAIN'LIM TIMES FOR
*}"THE SAME REQUEST.
}*GOTO SWAP'OUT IF REQUEST'CODE=CRGFP;
}*PUNT('WTL') IF (TRY'AGAIN'CNT _ TRY'AGAIN'CNT+1) >
}-TRY'AGAIN'LIM;
}*SBLOCK(WAIT'TIME);
}*GOTO GET'FREE'NODE;

CRRSP'ERROR:
}*FRETURN('NCH',999) IF ERROR'CODE=NCHT;
}*FRETURN('DAO',999) IF ERROR'CODE=DNCHT;
}*PUNT('SCO') IF ERROR'CODE=SCHOVF;
}*PUNT('AME');

CWRPG'ERROR:
}*PUNT('AME');

CRDK'ERROR:
}*RETURN IF (ERROR'CODE=UNER OR ERROR'CODE=NINDHT OR
}5ERROR'CODE=DNCHT OR ERROR'CODE=DKRAS OR
}5ERROR'CODE=HERDR OR ERROR'CODE=SERDR OR
}5ERROR'CODE=HERDK OR ERROR'CODE=SERDK);
}*PUNT('DHT') IF ERROR'CODE=UNERK;
}*PUNT('AME');

CRWUN'ERROR:
}*IF ERROR'CODE=UNER DO;
}-FRETURN('UNU',999) IF REQUEST'TIME;
}-FRETURN('DAU',999);
}*ENDIF;
}*FRETURN('DAU',999) IF ERROR'CODE=DKINU;
}*FRETURN('DKE',999) IF ERROR'CODE=HERDK;
}*PUNT('AME');

CRKD'ERROR:
}*FRETURN('DAO',999) IF (ERROR'CODE=UNER OR ERROR'CODE=DNCHT OR
}AERROR'CODE=DKRAS OR ERROR'CODE=UNERK);
}*FRETURN('DME',999) IF ERROR'CODE=HERDR;
}*FRETURN('DKE',999) IF (ERROR'CODE=HERDK OR ERROR'CODE=SERDK);
}*PUNT('AME');

CRGFP'ERROR:
}*FRETURN('UNU',999) IF ERROR'CODE=UNER;
}*FRETURN('DAU',999) IF ERROR'CODE=DKINU;
}*PUNT('AME');

CRDEST'ERROR:
}*FRETURN('DAO',999) IF (ERROR'CODE=UNER OR ERROR'CODE=DNCHT OR
}AERROR'CODE=DKRAS);
}*FRETURN('DKE',999) IF ERROR'CODE=HERDK;
}*PUNT('DHT') IF ERROR'CODE=UNERK;
}*PUNT('AME');

NO'FREE'NODES:
}*UNPROTECT(2);
}*GOTO GET'FREE'NODE IF (NO'FREE'NODE'CNT _ NO'FREE'NODE'CNT+1) <
}-NO'FREE'NODE'LIM;
}*PUNT('NFN');


** NOTE: SWAP'OUT IS SUPPOSED TO DO MORE THAN JUST RETURN!!

SWAP'OUT: SBLOCK(NPG'WAIT'TIME);
}*GOTO GET'FREE'NODE;

}(END;

}(PROGRAM PNIC'TRAP;
}*INCLUDE RESMON, PMTD, APTD, PARD, SPTD, PROFILE, SWPD;
}*INCLUDE PMS'MACROS;
}*DECLARE PMTX, SOURCE, APTE, MEC, MEM, APTX,
}-TARGET, PMTE;
}*MACRO SCHEDULED _ (PMTE.PMTSF);
}*MACRO ON'DRUM _ (PMTE.PMTDWS);
}*MACRO CLASS'CODE'ERROR _ (PMTE.PMTCCE);
}*MACRO READ'ERROR _ (PMTE.PMTRDE);

}(ENTRY PNIC'TRAP();

*}"THE PNIC TRAP-HANDLING ROUTINE USES THE FOLLOWING INFORMATION
*}"IN DECIDING WHAT TO DO TO CORRECT A PAGE-NOT-IN-CORE TRAP.
*}%SOURCE - TRUE IF TRAP CAME OUT OF MONITOR RING
*}%TARGET - TRUE IF REFERENCE WAS TO MONITOR RING
*}%SCHEDULED - TRUE IF SF IS SET IN THE PAGE'S PMT ENTRY
*}%CLASS'CODE'ERROR - TRUE IF CCE IS SET IN THE PAGE'S PMT ENTRY
*}%IN'CWS - TRUE IF THE PAGE IS IN CWS
*}%IN'DWS - TRUE IF THE PAGE APPEARS IN APT
*}%ON'DRUM - TRUE IF DWS IS SET IN THE PAGE'S PMT ENTRY
*}%IN'CHT - TRUE IF THE PAGE APPEARS IN CHT
*}%READ'ERROR - TRUE IF RDE IS SET IN THE PAGE'S PMT ENTRY

}*PMTX _ RDPRMB(PAGENO(TPAR))$PRMPMT;
}*PMTE _ @PMT[PMTX];
*}"CONVERT TO PNIM IF PMT ENTRY 'CLEAR'
}*IF PMTE.PMTDKA=0 DO;
}-PNIM'TRAP();
}-RETURN;
}*ENDIF;
}*GET'APT'ENTRY(PMTX: APTE,APTX);
}*SOURCE _ MRING(TRSTATE.STPC);
}*TARGET _ MRING(TPAR);
*}"ABORT IF LOOPING THROUGH CWS.
}*IF TRSTATE.INSTD DO;
}-PNIC'COUNT _ PNIC'COUNT+1;
}-IF PNIC'COUNT > LCWS DO;
}0TRSTATE.INSTD _ 0;
}0TRAP(TNO(PNIC), TPAR, SOURCE);
}-ENDIF;
}*ELSE DO;
}-TRSTATE.INSTD _ 1;
}-PNIC'COUNT _ 0;
}*ENDIF;


FIX'IT:}#IF NOT SCHEDULED DO;
}-IF NOT IN'CWS DO;
}0TRAP(TNO(PNIC), TPAR, 0) IF (SPSTATUS$DPNIC=0 AND SOURCE=0);
}0PUT'IN'CWS(PMTX,APTX,APTE//CANT'PUT'IN'CWS:MEC,MEM);
}0GOTO SWAP'OUT;
}-ELSE DO;* IN CWS BUT NOT SCHEDULED
}0IF NOT ON'DRUM DO;
}3AMC'REQUEST(CRKD,PMTX,PRTI,1//TRANSFER'FAILURE: MEC,MEM);
}3PMTE.PMTDWS _ 1;
}3GOTO SWAP'OUT;
}0ELSE DO;* IN CWS AND ON DRUM BUT NOT SCHEDULED
}3IF CLASS'CODE'ERROR DO;
}6(TRAP(TNO(NEP), TPAR, SOURCE) IF (SOURCE=0 OR
}7TARGET=0) ELSE PUNT('CCE'));
}3ELSEIF READ'ERROR DO;
}6(TRAP(TNO(DMRD), TPAR, SOURCE) IF (SOURCE=0 OR
}7TARGET=0) ELSE PUNT('DMR'));
}3ELSE DO;* EVERYTHING LOOKS OKAY
}6GOTO SWAP'OUT;
}3ENDIF;
}0ENDIF;
}-ENDIF;
}*ELSE DO;* SCHEDULED, BUT UNAVAILABLE TO CPU
}-GOTO SWAP'OUT;
}*ENDIF;

CANT'PUT'IN'CWS:
}*PUNT(MEC) IF (SOURCE=1 AND TARGET=1);
}*IF ((SOURCE=1) AND (MEC='WSE' OR MEC='CWE' OR MEC='WSL')) DO;
}-SET'LWS('OCW',OLCWS+1//CANT'INC'OCW);
}-GOTO FIX'IT;
CANT'INC'OCW:SET'LWS('ODW',OLDWS+1//GIVE'UP);
}-GOTO FIX'IT;
}*ENDIF;
GIVE'UP:}"TRAP(TNO(CWSO), TPAR, SOURCE) IF (MEC='CWE' OR MEC='WSL');

TRANSFER'FAILURE:
}*PUNT(MEC) IF (SOURCE=1 AND TARGET=1);
}*TRAP(TNO(NEP), TPAR, SOURCE) IF MEC='DAO';
}*TRAP(TNO(DMRD), TPAR, SOURCE) IF (MEC='DME' OR MEC='DKE');
}*PUNT(MEC);

SWAP'OUT:
*}"AFTER DOING WHATEVER SHOULD BE DONE TO CORRECT THE PAGE FAULT, WE 
*}"BLOCK.}"THIS WILL HAVE THE EFFECT OF FORCING THE SWAPPER TO MAKE AN
*}"ATTEMPT TO BRING IN THE MISSING PAGE, AND WILL ALSO GIVE TIME FOR ANY
*}"TRANSIENT CONDITIONS (LIKE PAGE IN PROCESS OF BEING DESTROYED) TO
*}"STABILIZE.
}*PROTECT(1);
}-PRT[PRTI]$PRPGF _ 1;
}*UNPROTECT(1);
}*SWBLOCK();
}*RETURN;

}(END;

}(PROGRAM PNIM'TRAP;
}*INCLUDE TRAPD, GLOBAL, RESMON, SPTD, SPCSD, PROFILE;
}*DECLARE Q, PC, PMTX, TARGET'SP, MEC, MEM, SOURCE, BYTENO;
}*DECLARE NAME, SPTE;

}(ENTRY PNIM'TRAP();
}*Q _ TPAR;
}*PC _ TRSTATE.STPC;
}*BYTENO _ PAGENO(Q);
}*PMTX _ RDPRMB(BYTENO)$PRMPMT;
}*TARGET'SP _ (SPCS[SPCSL]$CSR0SP IF URING(Q) ELSE
}7SPCS[SPCSL]$CSR1SP IF YRING(Q) ELSE
}70);
}*NAME _ 1 LSH TARGET'SP;
}*SOURCE _ MRING(PC);

}*PUNT('PNM') IF MRING(PC) AND MRING(Q);
}*PUNT('MAC') IF MRING(Q) AND NOT MRING(PC);

}*TRAP(TNO(PNIM), Q, SOURCE) IF TARGET'SP=0;
}*TRAP(TNO(PNIM), Q, SOURCE) IF SPSTATUS$DPNIM=0 AND NOT MRING(PC);
}*IF PMTX=0 DO;
}-PMTX _ MACQPMT(-1, NAME//PMT'FULL:MEC, MEM);
}*ENDIF;
}*MNPPMT(PMTX, MKEY, MSTATUS//VALUE PUNT(MEC):MEC, MEM);

PUT'IN'MAP:
}*SETPRMB(BYTENO, PMTX);
}*BYTENO _ BYTENO-64 IF SPT[TARGET'SP]$SPTRING=1;
}*SPTE _ @SPT[TARGET'SP];
}*SPTE.(PXFLDS[BYTENO]) _ PMTX;
}*SPTE.(ROFLDS[BYTENO]) _ 0;
}*SPTE.SPTLM _ BYTENO IF BYTENO > SPTE.SPTLM;
}*RETURN;

*}"FAILURE RETURN FROM ACQPMT IS REASONABLE ONLY IF PMT IS FULL.
PMT'FULL: TRAP(TNO(PMTO), Q, SOURCE) IF MEC='PMO';
}*PUNT(MEC);

}(END;

}(PROGRAM PUT'INTO'WS;
}*INCLUDE GLOBAL, PROFILE, APTD, PMTD, SWPD, PMS'MACROS;
}*DECLARE APTX', APTE', PMTX', PMTE', MEC, MEM,
}-PUT'IN'DWS'ONLY, TEMP;
}*MACRO ON'DRUM _ (PMT[PMTX]$PMTDWS);
}*MACRO FIRST'NOT'CWS _ (NAPTE-LCWS);

}(ENTRY PUT'IN'CWS(PMTX, APTX, APTE), FRETURN;

*}"ENTER HERE TO PUT THE PAGE WITH REAL NAME IN PMT[PMTX] INTO CWS.
*}"THIS FUNCTION MUST NOT BE CALLED IF THE PAGE IS ALREADY IN CWS.}"IF 
*}"THE PAGE HAS AN APT ENTRY, APTX MUST BE ITS INDEX AND APTE MUST
*}"BE APT[APTX].}#IF THE PAGE HAS NO APT ENTRY, APTX AND APTE MUST
*}"BE 0.}"IN THIS LATTER CASE WE MUST PUT THE PAGE INTO DWS BEFORE
*}"PUTTING IT INTO CWS.

}*GOTO ALREADY'IN'DWS IF IN'DWS;
}*PUT'IN'DWS'ONLY _ 0;
}*GOTO PUT'INTO'DWS;

}(ENTRY PUT'IN'DWS(PMTX), FRETURN;

*}"ENTER HERE TO PUT THE PAGE WITH REAL NAME IN PMT[PMTX] INTO DWS.
*}"DO NOT CALL THIS FUNCTION FOR A PAGE WHICH ALREADY HAS AN ENTRY
*}"IN APT.}"THIS CODE IS ALSO USED IN PUTTING A PAGE INTO CWS IF
*}"THE PAGE ISN'T ALREADY IN DWS.

}*APTX _ APTE _ 0;
}*PUT'IN'DWS'ONLY _ 1;

PUT'INTO'DWS:
*}"FIRST WE READ THE PAGE FROM DISK TO DRUM.}"IF THIS FAILS, WE HAVE
*}"NOT DISTURBED THE WORKING SET IN ANY WAY.}"IT IS POSSIBLE THAT
*}"PMT[PMTX] IS "CLEAR", IN WHICH CASE WE DON'T ATTEMPT A TRANSFER.

}*IF PMT[PMTX]$PMTDKA # 0 DO;
}-AMC'REQUEST(CRKD,PMTX,PRTI,0//FRETURN(MEC,MEM): MEC,MEM);
}-PMT[PMTX]$PMTDWS _ 1;
}*ENDIF;

*}"IF THE DRUM WORKING SET IS FULL, WE MUST RELEASE A PAGE FROM IT
*}"BEFORE WE PUT IN THE NEW ONE.}"THE FUNCTION TO DO THIS CAN FAIL ONLY
*}"IF APT IS EMPTY OR ALL PAGES IN IT ARE LOCKED.}"IF IT DOES FAIL, WE HAVE
*}"TO RETURN THE PAGE WE JUST READ BACK TO THE DISK.

}*IF DWS'FULL DO;
}-RELEASE'SOME'DWS(//PUT'PAGE'BACK: MEC,MEM);
}*ENDIF;

*}"NOW WE ARE READY TO MAKE THE ENTRY IN APT.}"WE PUT THE ENTRY
*}"AT THE END OF THE CURRENT DRUM WORKING SET AND INCREMENT LDWS.}"THE
*}"ENTRY'S USE HISTORY IS SET TO THE MAXIMUM POSSIBLE VALUE.}"THIS IS ALL
*}"UNLESS THE CODE IS RUNNING AS PART OF PUT'IN'CWS.

}*LDWS _ LDWS+1;
}*APT[APTX_LAST'DWS] _ APTE _ (-1)@APTUH V' PMTX@APTPMT;
}*RETURN APTX IF PUT'IN'DWS'ONLY;

ALREADY'IN'DWS:
*}"THE PAGE IS NOW IN DWS AND ITS INDEX IS APTX.}"IF CWS IS CURRENTLY FULL,
*}"WE HAVE TO RELEASE A PAGE FROM IT BEFORE PUTTING THE NEW ONE IN.

}*APTE' _ APT[APTX' _ FIRST'NOT'CWS];
}*GOTO PUT'INTO'CWS IF NOT CWS'FULL;

*}"WE MUST CHOOSE A PAGE TO REMOVE FROM CWS.}"OLDEST'CWS WILL POINT
*}"TO THE PAGE LEAST RECENTLY USED UNLESS WE HAVE ALREADY RELEASED
*}"A PAGE SINCE THE LAST SWAP, IN WHICH CASE OLDEST'CWS WILL BE 0.
*}"IN THIS CASE WE MUST FIND THE LEAST RECENTLY REFERENCED PAGE BY
*}"COMPARING THE USE FIELDS OF ALL CWS PAGES.}"THE FUNCTION TO DO
*}"THIS WILL FAIL ONLY IF CWS IS EMPTY.}"IT IS POSSIBLE THAT ALL OF
*}"CWS IS LOCKED, IN WHICH CASE WE CANNOT MAKE ROOM.

}*IF OLDEST'CWS # 0 DO;
}-APTE' _ APT[APTX' _ APTL-OLDEST'CWS];
}-OLDEST'CWS _ 0;
}-GOTO FIND'OLDEST IF (PMT[APTE'$APTPMT]$PMTRF OR
}BAPTE'$APTLOCKS#0);
}*ELSE DO;
FIND'OLDEST:
}-APTX' _ FIND'OLDEST'CWS(:APTE'//FRETURN('CWE',158));
}*ENDIF;
}*FRETURN('WSL',205) IF APTE'$APTLOCKS#0;

PUT'INTO'CWS:
*}"WE ARE NOW READY TO MOVE OUR APT ENTRY INTO THE CWS SECTION
*}"OF THE TABLE.}"APTX IS THE ENTRY'S CURRENT INDEX AND APTX' IS
*}"THE INDEX OF THE ENTRY IT SHOULD REPLACE.}"LCWS GETS
*}"INCREMENTED IF THE ENTRY BEING REPLACED WASN'T IN CWS.}"LTBW GETS
*}"INCREMENTED IF THE ENTRY WE'RE PUTTING INTO CWS WASN'T ALREADY
*}"IN TBW.}"THEN WE SHUFFLE THE ENTRIES AROUND AND ARE DONE.

}*LCWS _ LCWS+1 IF APTL-APTX'>LCWS;
}*LTBW _ LTBW+1 IF APTL-APTX > LTBW;
}*TEMP _ APT[APTX]; APT[APTX] _ APT[LAST'TBW];
}*APT[LAST'TBW] _ APT[APTX']; APT[APTX'] _ TEMP;
}*APT[APTX']$APTUH _ -1;
}*RETURN APTX';

PUT'PAGE'BACK:
*}"DWS IS FULL AND WE CAN'T MAKE ROOM FOR THE NEW ENTRY.}"WE MUST
*}"RELEASE THE NEW PAGE FROM THE DRUM.}"DON'T WAIT FOR TRANSFER
*}"TO COMPLETE.

}*IF PMT[PMTX]$PMTDKA#0 DO;
}-AMC'REQUEST(CRDK, PMTX, PRTI, 0//VALUE PUNT(MEC):MEC,MEM);
}-PMT[PMTX]$PMTDWS _ 0;
}*ENDIF;
}*FRETURN(MEC,MEM);

}(END;

}(PROGRAM RELEASE'FROM'WS;
}*INCLUDE PROFILE, APTD, PMTD, SWPD, GLOBAL, PMS'MACROS;
}*DECLARE APTX, APTE, PMTX, TEMP, MEC, MEM;

}(ENTRY RELEASE'SOME'CWS(), FRETURN;

*}"ENTER HERE TO RELEASE THE LEAST RECENTLY REFERENCED PAGE FROM CWS.
*}"OLDEST'CWS SHOULD POINT TO THE RIGHT PAGE TO RELEASE, BUT IT MAY
*}"NOT, EITHER BECAUSE WE HAVE ALREADY USED OLDEST'CWS SINCE IT WAS
*}"LAST UPDATED, OR BECAUSE THE PAGE IT POINTS TO HAS BEEN REFERENCED
*}"SINCE APT WAS LAST AGED.
}*IF OLDEST'CWS#0 DO;
}-APTE _ APT[APTX _ APTL-OLDEST'CWS];
}-OLDEST'CWS _ 0;
}-GOTO FIND'OLDEST IF (PMT[APTE$APTPMT]$PMTRF OR
}BAPTE$APTLOCKS#0);
}*ELSE DO;
FIND'OLDEST:
}-APTX _ FIND'OLDEST'CWS(:APTE//FRETURN('CWE',999));
}*ENDIF;
}*FRETURN('WSL',205) IF APTE$APTLOCKS#0;
}*PMTX _ APTE$APTPMT;
}*GOTO MOVE'APT'ENTRY;

}(ENTRY RELEASE'THIS'CWS(PMTX), FRETURN;

*}"ENTER HERE TO RELEASE THE PAGE PMT[PMTX] FROM CWS.}"FAILS ONLY
*}"IF PAGE IS LOCKED.
}*GET'APT'ENTRY(PMTX: APTE,APTX);
}*FRETURN('PGL',999) IF APTE$APTLOCKS#0;

MOVE'APT'ENTRY:
*}"THE APT ENTRY IS NOW MOVED OUT OF THE CWS SECTION OF APT.}"IT IS
*}"LEFT IN THE TBW SECTION.}"THIS IS DONE BY EXCHANGING IT WITH THE
*}"LAST ENTRY IN THE CWS SECTION AND DECREMENTING LCWS.
}*TEMP _ APT[APTX];}"APT[APTX] _ APT[LAST'CWS];
}*APT[LAST'CWS] _ TEMP;
}*LCWS _ LCWS-1;
}*RETURN PMTX;

}(ENTRY RELEASE'SOME'DWS(), FRETURN;

*}"THIS FUNCTION CHOOSES THE BEST PAGE TO RELEASE FROM THE DRUM WORKING
*}"SET AND CALLS ON THE AMC TO RETURN IT TO THE DISK.}"IT FAILS ONLY
*}"IN THE UNLIKELY CASE THAT THE ACTIVE PAGE TABLE IS EMPTY OR
*}"ALL ENTRIES IN IT ARE LOCKED IN.}"IT WILL RELEASE A PAGE FROM THE
*}"CORE WORKING SET IF CWS=DWS.
}*FRETURN('WSE',999) IF LDWS=0;
}*APTX _ FIND'OLDEST'DWS(:APTE);
}*FRETURN('WSL',999) IF APTE$APTLOCKS#0;
}*PMTX _ APTE$APTPMT;
}*GOTO CHECK'NEW'PAGE;

}(ENTRY RELEASE'THIS'DWS(PMTX), FRETURN;

*}"ENTER HERE TO RELEASE A SPECIFIC PAGE FROM THE DRUM WORKING SET.
}*GET'APT'ENTRY(PMTX: APTE,APTX);
}*RETURN -1 IF NOT IN'DWS;
}*FRETURN('PGL',203) IF APTE$APTLOCKS#0;

CHECK'NEW'PAGE:
*}"IF APTE HAS THE 'NEW PAGE' BIT SET, THE PAGE DOESN'T EXIST EXCEPT
*}"FOR THE PMT AND APT ENTRIES.}"WE JUST WRITE ITS UNIQUE NAME ON THE
*}"DISK.}"ANY ERROR WE GET IN DOING THIS CAUSES A PUNT FOR THE PRESENT.
}*IF APTE$APTNPG DO;
}-AMC'REQUEST(CRWUN,PMTX,PRTI,1//VALUE PUNT(MEC): MEC,MEM);
}-GOTO DELETE'APT'ENTRY;
}*ENDIF;

*}"PAGE MUST BE SPECIFICALLY RELEASED FROM CORE IF SF IS SET.
}*IF PMT[PMTX]$PMTSF DO;
}-AMC'REQUEST(CWRPG,PMTX,PRTI,0//VALUE PUNT(MEC): MEC,MEM);
}*ENDIF;

DELETE'APT'ENTRY:
*}"WE HAVE TO FIX UP APT BEFORE WE MAKE THE REQUEST TO WRITE THE PAGE
*}"ON THE DISK BECAUSE WE MAY GET SWAPPED OUT WHILE THE TRANSFER TAKES
*}"PLACE.
}*IF IN'CWS DO;
}-APT[APTX] _ APT[LAST'CWS];}"APT[LAST'CWS] _ APT[LAST'TBW];
}-APT[LAST'TBW] _ APT[LAST'DWS];
}-LCWS _ LCWS-1;}"LTBW _ LTBW-1;
}*ELSEIF IN'TBW DO;
}-APT[APTX] _ APT[LAST'TBW];}"APT[LAST'TBW] _ APT[LAST'DWS];
}-LTBW _ LTBW-1;
}*ELSE DO;
}-APT[APTX] _ APT[LAST'DWS];
}*ENDIF;
}*APT[LAST'DWS] _ 0;
}*LDWS _ LDWS-1;
}*RETURN PMTX IF APTE$APTNPG;

*}"FINALLY, WE RELEASE THE PAGE FROM THE DRUM, IF PMT[PMTX] HAS THE
*}"DWS BIT SET AND IS NOT 'CLEAR'.
}*IF PMT[PMTX]$PMTDKA#0 AND PMT[PMTX]$PMTDWS DO;
}-AMC'REQUEST(CRDK,PMTX,PRTI,0//VALUE PUNT(MEC):MEC,MEM);
}*ENDIF;
}*PMT[PMTX]$PMTDWS _ 0;
}*IF PMT[PMTX]$PMTRF DO;
}-PMT[PMTX]$PMTRF _ 0;
}-CLEAR'MAP;
}*ENDIF;
}*RETURN PMTX;

}(END;

}(PROGRAM SIMULATE'AMC'103;
*}"THIS CODE DOES THE THINGS THAT WILL BE DONE BY THE AMC IN THE 1.03
*}"VERSION.}"CONVERTING THE MONITOR TO RUN WITH THE 1.03 AMC SHOULD
*}"MAINLY BE A MATTER OF DELETING ALL CALLS ON THE FUNCTIONS IN THIS
*}"PROGRAM.
}*INCLUDE PROFILE, APTD, PMTD, SWPD, GLOBAL, PMS'MACROS;
}*DECLARE APTX, APTE, PMTX, PMTE, MEC, MEM, TEMP;

}(ENTRY FREE'TBW'PAGES();

*}"THIS FUNCTION SHOULD BE CALLED JUST BEFORE EACH BLOCK.}"IT RELEASES
*}"FROM CORE ALL PAGES IN TBW BUT NOT IN CWS, THAT IS, ALL PAGES WHICH
*}"HAVE BEEN REMOVED FROM CWS SINCE THE LAST SWAP-IN.
}*FOR LTBW _ LTBW BY -1 TO LCWS+1 DO;
}-APTE _ APT[APTX _ LAST'TBW];
}-PMTE _ @PMT[PMTX _ APTE$APTPMT];
}-IF PMTE.PMTSF DO;
}0AMC'REQUEST(CWRPG,PMTX,PRTI,0//VALUE PUNT(MEC): MEC,MEM);
}0PMTE.PMTSF _ 0;
}-ENDIF;
}*ENDFOR;
}*LTBW _ LCWS;
}*RETURN;

}(ENTRY SHRINK'CWS();

*}"THIS FUNCTION REMOVES FROM CWS ALL PAGES WHOSE APT ENTRIES HAVE
*}"NO BITS IN COMMON WITH THE CONTROL WORD, MUMBLE.}"IT SHOULD BE
*}"CALLED BEFORE FREE'TBW'PAGES AND AFTER AGE'APS.}"IF MUMBLE = -1,
*}"IT WON'T DO ANYTHING.
}*FOR APTX _ APTL-LCWS TO APTL-1 DO;
}-IF APT[APTX] A' MUMBLE = 0 DO;
}0TEMP _ APT[APTX];}"APT[APTX] _ APT[LAST'CWS];
}0APT[LAST'CWS] _ TEMP;
}0LCWS _ LCWS-1;
}-ENDIF;
}*ENDFOR;
}*RETURN;

}(END;
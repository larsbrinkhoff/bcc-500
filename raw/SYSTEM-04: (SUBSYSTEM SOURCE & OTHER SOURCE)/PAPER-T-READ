}'COMMON ENTRY'DEFS;

*}&THIS COMMON BLOCK CONTAINS THE VARIABLES NECESSARY FOR THE
* PROGRAM BLOCK ENTRIES, SUCH THINGS AS THE SIZE OF THE STACK, THE
* STACK BOUNDS, STACK POINTER, AND STACK LIMIT.

}'DECLARE PARAMETER
}*STACK'SIZE _ 3000B;

}'DECLARE ARRAY
}*STACK[STACK'SIZE];

}'DECLARE ARRAY
}*STATE[10];})/* THE SAVED STATE KEPT BY THE MONITOR}#*/

}'DECLARE PARAMETER
}*STACK'POINTER = G'[2],
}*STACK'LIMIT = G'[3],
}*INITIAL'SP _ @STACK[0],
}*INITIAL'SL _ @STACK[STACK'SIZE - 1];

}'DECLARE PARAMETER}%/* INDEXES INTO STATE}4*/
}*P'INDEX _ 0,}'/* PROGRAM COUNTER}7*/
}*L'INDEX _ 7,}'/* LOCAL REGISTER}8*/
}*G'INDEX _ 8;}'/* GLOBAL REGISTER}7*/

}'DECLARE FIELD})/* FOR A SPCS ENTRY}6*/
}*PC (0:6,23),}'/* THE SAVED P-COUNTER}3*/
}*LR (1:6,23),}'/* THE SAVED L-REGISTER}2*/
}*GR (2:6,23);}'/* THE SAVED G-REGISTER}2*/

}'MACRO SAVE'STATE (CURRENT'STATE) _ .STX CURRENT'STATE[6],
}*.EAX CURRENT'STATE[0], .STORS;



}'END;

}'PROGRAM ENTRIES;

* THIS PROGRAM BLOCK CONTAINS THE ENTRY POINTS TO THE WHOLE PROGRAM

}'INCLUDE ENTRY'DEFS;

}'DECLARE INTEGER
}*SP'INT'NO = L'[0],
}*SP'TRAP'NO = L'[0],
}*SP'TRAP'PARAM = L'[1];



* SUB-PROCESS TRAP ENTRY POINT
}'FUNCTION SP'TRAP'ENTRY(), SP'ENTRY _ 0;
}'SAVE'STATE(STATE);
}'SP'TRAP'HANDLER(SP'TRAP'NO, SP'TRAP'PARAM);



* INTERRUPT ENTRY POINT
}'FUNCTION INTERRUPT'ENTRY(), SP'ENTRY _ 1;
}'FATAL'ERROR();



* INITIAL ENTRY POINT
}'FUNCTION INITIAL'ENTRY(), SP'ENTRY _ 2;
}'STACK'POINTER _ INITIAL'SP;
}'STACK'LIMIT _ INITIAL'SL;
}'FROM'THE'READER();



* CONTINUE ENTRY POINT
}'FUNCTION CONTINUE'ENTRY(), SP'ENTRY _ 3;
}'STACK'POINTER _ INITIAL'SP;
}'STACK'LIMIT _ INITIAL'SL;
}'/*CONTINUE'*/FROM'THE'READER();



}'END;

}'COMMON MONITOR'CALLS;


******************************
*
* CALLS TO MANIPULATE MULTI-INDEX BLOCKS (MIBS) AND SUB-INDEX BLOCKS (SIBS)
*
******************************

}'INTEGER MONITOR CREATE'MIB _ 190;})
}'UNKNOWN MONITOR READ'MIBOB'INDEX _ 0;}%* READ CONTENTS OF ENTRY
}'UNKNOWN MONITOR READ'MIBOB'NAME _ 1;}&* READ ENTRY
}'UNKNOWN MONITOR SET'MIBOB'NAME _ 2;}'* SET NAME OF ENTRY
}'UNKNOWN MONITOR SET'MIBOB'ACCESS _ 3;}%* SET PUBLIC, FRIEND AND OWENER ACCESS OF OBJECT
}'UNKNOWN MONITOR SET'LOCK'LIST _ 4;}(* SET LOCK AND ACCESS FOR LOCK
}'UNKNOWN MONITOR DELETE'MIBOB _ 5;})* DELETE ENTRY
}'INTEGER MONITOR CREATE'MIBOB _ 6;})* CREATE NEW ENTRY
}'UNKNOWN MONITOR MERGE'MCW _ 9;},* READ OR MERGE THE MIB CAPABILITY WORK (MCW) INTO SPT
}'UNKNOWN MONITOR SET'MIB'ACCESS _ 10;}&* COPY MIB CAPABILITIES WORD FROM ONE MIB TO ANOTHER
}'INTEGER MONITOR READ'MIB'ACCESS _ 11;}%* READ MIB ACCESS
}'UNKNOWN MONITOR SET'MIBOB'VALUE _ 12;}%* SET VALUE OF OBJECT
}'INTEGER MONITOR COPY'MIBOB _ 14;}** COPY ACCESS KEY FROM ONE MIB TO ANOTHER (NOT IMPLEMENTED)
}'UNKNOWN MONITOR SET'NO'CHARGE _ 15;}'* SET NO DRUM CHARGE FLAG FOR FILE
}'INTEGER MONITOR READ'MIB'SPACE _ 16;}&* READ AVAILABLE SPACE IN MIB
}'UNKNOWN MONITOR SET'FILE'LOCK _ 18;}'* SET WRITTEN AND REFERENCE DATE ON FILE (NOT IMPLEMENTED)
}'UNKNOWN MONITOR SET'DURABILITY _ 28;}&* SET THE DURABILITY FIELD OF THE MIB (BUT, NO ONE LOOKS AT IT)





******************************
*
* OPEN FILE TABLE (OFT) CALLS
*
******************************

}'INTEGER MONITOR MON'OPEN'FILE _ 19;}'* OPEN OBJECT
}'UNKNOWN MONITOR MON'READ'OFT _ 20;}(* READ OFT ENTRY
}'UNKNOWN MONITOR MON'SET'OFT'AC _ 21;}&* SET OFT ACCESS LOCK
}'UNKNOWN MONITOR MON'SET'OFT'CL _ 22;}&* SET OFT CONTROL LOCK
}'UNKNOWN MONITOR SET'FILE'LENGTH _ 23;}%* SET WORD LENGTH FOR OFT ENTRY
}'INTEGER MONITOR CREATE'FILE'PAGE _ 24;}$* CREATE A PRIVATE MEMORY PAGE
}'INTEGER MONITOR DEL'FILE'PAGE _ 25;}'* DELETE A PAGE OF AN OBJECT
}'INTEGER MONITOR NEXT'FILE'PAGE _ 26;}&* GET NEXT PAGE OF FILE
}'UNKNOWN MONITOR MOVE'PAGE'PMT _ 27;}'* PUT REAL NAME OF A PAGE OF A FILE INTO A PMT ENTRY

******************************
*
* PROCESS MEMORY TABLE (PMT) CALLS
*
******************************

}'INTEGER MONITOR ACQUIRE'PMT _ 50;})* ACQUIRE AND INITIALIZE A PMT ENTRY
}'UNKNOWN MONITOR NEW'PMT'PAGE _ 51;}(* CREATE A PRIVATE MEMORY PAGE AND PUT ITS REAL NAME INTO PMT
}'UNKNOWN MONITOR COPY'RN'PMT _ 52;})* PUT SPECIFIED REAL NAME INTO A PMT ENTRY
}'UNKNOWN MONITOR CLEAR'PMT _ 53;}+* RELEASE PAGE FROM PMT ENTRY
}'UNKNOWN MONITOR DELETE'PMT _ 54;}** RELEASE PMT ENTRY (RELEASE PAGE FROM PMT ENTRY AND FREE ENTRY)
}'UNKNOWN MONITOR SET'PMT'ACC'LOCK _ 55;}$* SET THE ACCESS LOCK OF A PMT ENTRY
}'UNKNOWN MONITOR SET'PMT'CON'LOCK _ 56;}$* SET THE CONTROL LOCK OF AN PMT ENTRY
}'UNKNOWN MONITOR SET'PMT'RO _ 57;}** SET THE READ ONLY BIT IN A PMT ENTRY
}'UNKNOWN MONITOR READ'PMT _ 58;},* READ A PMT ENTRY



******************************
*
* WORKING SET CALLS
*
******************************

}'UNKNOWN MONITOR PUT'PAGE'DWS _ 65;}(* PUT PAGE IN THE DRUM WORKING SET
}'UNKNOWN MONITOR PUT'PAGE'CWS _ 66;}(* PUT A PAGE IN THE CORE WORKING SET
}'INTEGER MONITOR DEL'PAGE'DWS _ 67;}(* DELETE A PAGE FROM THE DWS
}'INTEGER MONITOR DEL'PAGE'CWS _ 68;}(* DELETE A PAGE FROM THE CWS
}'INTEGER MONITOR READ'LEN'WS _ 70;})* READ THE LENGTH OF A SPECIFIED THE WORKING SET
}'UNKNOWN MONITOR SET'LEN'WS _ 71;}** SET THE OVERFLOW LENGTH OF A SPECIFIED WS



******************************
*
* SUB-PROCESS TABLE (SPT) CALLS
*
******************************

}'INTEGER MONITOR MON'CREATE'SP _ 90;}'* ACQUIRE AND INITIALIZE AN SPT ENTRY
}'UNKNOWN MONITOR MON'DESTROY'SP _ 91;}&* DELETE THE CONTENTS OF AN SPT ENTRY
}'UNKNOWN MONITOR MON'READ'SPT _ 95;}(* READ AN SPT ENTRY
}'UNKNOWN MONITOR MON'READ'SPCS _ 96;}'* READ AN SPCS ENTRY
}'INTEGER MONITOR MON'READ'SPT'FLD _ 97;}$* READ A SELECTED FIELD OF AN SPT ENTRY
}'UNKNOWN MONITOR MON'SET'SPT'FLD _ 98;}%* SET THE VALUE OF A SPECIFIED FIELD OF AN SPT ENTRY
}'UNKNOWN MONITOR READ'SPT'MAP _ 99;}(* READ THE MAP OF AN SPT ENTRY
}'UNKNOWN MONITOR SET'SPT'MAP _ 100;}(* SET THE MAP OF AN SPT ENTRY
}'INTEGER MONITOR READ'MAP'BYTE _ 101;}&* READ A BYTE IN THE MAP OF AN SPT ENTRY
}'UNKNOWN MONITOR SET'MAP'BYTE _ 102;}'* SET A BYTE IN THE MAP OF AN SPT ENTRY
}'UNKNOWN MONITOR READ'ACCESS'KEY _ 103;}$* READ AN ACCESS KEY FROM AN SPT ENTRY
}'UNKNOWN MONITOR COPY'ACCESS'KEY _ 104;}$* COPY AN ACCESS KEY FROM ONE SPT ENTRY TO ANOTHER
}'UNKNOWN MONITOR COPY'TAK _ 105;}+* COPY THE TEMPORARAY ACCESS KEY
}'INTEGER MONITOR READ'SPS'PARAM _ 106;

******************************
*
* SUB-PROCESS CALL STACK (SPCS) CALLS
*
******************************

}'UNKNOWN MONITOR SP'CALL _ 111;},* CALL A SUB-PROCESS
}'UNKNOWN MONITOR SP'JUMP _ 112;},* JUMP TO A SUB-PROCESS
}'UNKNOWN MONITOR SP'TRAP _ 113;},* GENERATE A SOFTWARE TRAP
}'UNKNOWN MONITOR TRAP'RETURN _ 114;}(* POP UP THE SUB-PROCESS CALL STACK AND GENERATE A SOFTWARE TRAP
}'UNKNOWN MONITOR SP'BRANCH _ 115;}** BRANCH INTO A SUB-PROCESS
}'UNKNOWN MONITOR SP'RETURN _ 116;}** RETURN TO A CALLING SUB-PROCESS
}'UNKNOWN MONITOR JUMP'RETURN _ 117;}(* RETURN TO A SPECIFIED LEVEL IN THE SUB-PROCESS CALL STACK
}'UNKNOWN MONITOR MARK'CALL _ 118;}** RECORD A FUNCTION CALL ON THE SPCS
}'UNKNOWN MONITOR DELETE'CALL _ 119;}(* DELETE A FUNCTION CALL FROM THE SPCS
}'UNKNOWN MONITOR MODIFY'CALL _ 120;}(* CHANGE A FUNCTION CALL ON THE SPCS



******************************
*
* PROCESS CALLS
*
******************************

}'INTEGER MONITOR COPY'PMT'PROC _ 130;}&* COPY A PMT ENTRY FROM ONE PROCESS TO ANOTHER
}'INTEGER MONITOR ACTIVATE'PROC _ 132;}&* ACTIVATE A PROCESS
}'UNKNOWN MONITOR TRANSFER'TERM _ 133;}&* TRANSFER A TERMINAL
}'UNKNOWN MONITOR MAKE'DORMANT _ 134;}'* MAKE A PROCESS DORMANT
}'UNKNOWN MONITOR INIT'PROC'PAGE _ 135;}%* INITIALIZE UTILITY AREA OF THE CONTEXT BLOCK OR PRIVATE MEMORY PAGE
*}P*}#IN A NEW PROCESS
}'UNKNOWN MONITOR INIT'PROC'MAP _ 136;}&
}'UNKNOWN MONITOR INIT'SPT _ 137;
}'INTEGER MONITOR READ'PROC'PARAM _ 211;

******************************
*
* OPERATIONS ON INTERRUPT CHANNEL TABLE (ICT)
*
******************************

}'UNKNOWN MONITOR SET'PROC'INT _ 163;}'* SET PIW BITS
}'INTEGER MONITOR QUIT'BLOCK _ 164;
}'INTEGER MONITOR GET'INT'NUM _ 165;}(* CONVERT INTERRUPT CHARACTER CONSTANT TO INTERRUPT NUMBER
}'INTEGER MONITOR READ'ICT _ 166;}+* READ INTERRUPT CELL
}'INTEGER MONITOR READ'PIW _ 167;}+* READ PROGRAM INTERRUPT WORD (PIW)
}'UNKNOWN MONITOR ALLOW'INTS _ 168;})* RESET NON-INTERRUPTABILITY
}'UNKNOWN MONITOR REFUSE'INTS _ 169;}(* MAKE NON-INTERRUPTABLE
}'UNKNOWN MONITOR BLOCK _ 170;}.* BLOCK THE PROCESS
}'UNKNOWN MONITOR CLEAR'PIW _ 171;}** CLEAR PIW BITS
}'UNKNOWN MONITOR SET'ICT _ 172;},* SET INTERRUPT CELL
}'UNKNOWN MONITOR SET'ICT'CON'LOCK _ 173;}#* SET CONTROL LOCK IN INTERRUPT CELL
}'INTEGER MONITOR ACQUIRE'ICT _ 174;}(* ACQUIRE INTERRUPT CELL



******************************
*
* CHIO CALLS
*
******************************

}'UNKNOWN MONITOR SET'LINE'FIELD _ 180;}%* SET THE VALUE OF A PARAMETER FOR THE CHIO LINE
}'UNKNOWN MONITOR READ'LINE'TABLE _ 181;}$* READ CHIO LINE TABLE
}'STRING MONITOR READ'STRING _ 182;})* INPUT STRING FROM CHIO LINE
}'STRING MONITOR WRITE'STRING _ 183;}(* OUTPUT A STRING ONTO A CHIO LINE



******************************
*
* MISCELLANEOUS
*
******************************

}'MONITOR SEIZE'SEM _ 29;}3* (NOT IMPLEMENTED)
}'MONITOR RELEASE'SEM _ 30;}1* (NOT IMPLEMENTED)
}'MONITOR DIAGNOSTIC'DIO _ 59;}.* DIRECT INPUT/OUTPUT?
}'MONITOR KLUDGE'IO _ 128;}2* VARIATION OF DIAGNOSTIC'DIO?
}'UNKNOWN MONITOR DO'POT'PIN _ 129;})* HARDWARE KLUDGE
}'MONITOR MOVE'DISK'RES _ 149;}.* MOVE DISK RESOURCES (WHO CARES?)
}'LONG MONITOR READ'CLOCK _ 210;},* READ REAL-TIME CLOCK
}'MONITOR READ'WRITE'CM _ 255;}.* READS AND WRITES INTO CENTRAL MEMORY



}'END;

}'COMMON UTILITY'CALLS;

******************************
*
* MISCELLANEOUS UCALLS
*
******************************

}'UNKNOWN UTILITY BREAK'POINT _ 0;}** UCALL FOR DEBUGGING PROGRAMS
}'STRING UTILITY ERRORMSG _ 1;}.* RETURN SYSTEM ERROR MESSAGE
}'STRING UTILITY GET'PARAM _ 2;}-* STRIP PARAMETER FROM STRING
}'STRING UTILITY GET'COM'LINE _ 3;}** GET CURRENT COMMAND LINE FROM UTS
}'INTEGER UTILITY ABRV'LKP _ 4;}-* LOOK UP ABBREVIATED NAME IN STRING ARRAY
}'INTEGER UTILITY CON'ABRV'LKP _ 5;})* CONTINUE SAME IN NEW STRING ARRAY
}'STRING UTILITY GET'CMP'COMLINE _ 6;}'* GET SAVED COMMAND LINE AND USER NUMBER OF ATTACHED FILE
}'UNKNOWN UTILITY SET'COM'LINE _ 7;})* SET THE SAVED COMMAND LINE

******************************
*
* FILE SYSTEM CALLS
*
******************************

}'UNKNOWN UTILITY NAME'SEARCH _ 10;})* CONVERT FILE ST TO UTS NAME
}'UNKNOWN UTILITY SPECIAL'SEARCH _ 11;}&* VARIATION OF ABOVE
}'INTEGER UTILITY CONV'NAME _ 12;}+* CONVERT FROM UTS TO MON FILE NAME
}'LONG UTILITY SPREAD'NAME _ 13;},* SPLIT FILE NAME STRING INTO COMP.
}'UNKNOWN UTILITY READ'MIBOB'VALUE _ 14;}$* READ 'VALUE' OF MIB OBJECT
}'UNKNOWN UTILITY DELETE'FILE _ 15;})* DELETE FILE AND CONTENTS
}'INTEGER UTILITY OPEN'FILE _ 16;}+* OPEN FILE W/WO LOCKING
}'UNKNOWN UTILITY CLOSE'FILE _ 17;}** CLOSE AND UNLOCK FILE
}'UNKNOWN UTILITY READ'OFT _ 18;},* READ OFT
}'INTEGER UTILITY READ'OFT'FIELD _ 19;}&* READ OFT FIELD
}'UNKNOWN UTILITY SET'OFT'CL _ 20;}** SET OFT CONTROL LOCK
}'INTEGER UTILITY CONV'KEY _ 21;},* CONVERT DEFAULT ACCESS KEY


******************************
*
* EXTENDED SUB-PROCESS SYSTEM (SPS) CALLS
*
******************************

}'INTEGER UTILITY CREATE'SSP _ 30;}** CREATE SUBSIDIARY SUB-PROCESS
}'INTEGER UTILITY CREATE'PSP _ 31;}** CREATE PARALLEL SUB-PROCESS
}'UNKNOWN UTILITY ATTACH _ 32;}.* ATTACH PIF FILE TO SUB-PROCESS
}'UNKNOWN UTILITY DESTROY'SP _ 33;}** DESTROY SUB-PROCESSES
}'UNKNOWN UTILITY READ'SPT _ 34;},* READ SPT
}'INTEGER UTILITY READ'SPT'FIELD _ 35;}&* READ SPT FIELD
}'UNKNOWN UTILITY SET'SPT'FIELD _ 36;}'* SET SPT FIELD
}'STRING UTILITY READ'SPNAME _ 37;}** READ SUB-PROC NAME
}'UNKNOWN UTILITY SET'SPNAME _ 38;}** SET SUB-PROC NAME
}'INTEGER UTILITY SPNAME'SEARCH _39;}(* LOOK UP SP NAME

******************************
*
* CONTROL INPUT/OUTPUT STREAMS (CIOS) MANIPULATION
*
******************************

}'INTEGER UTILITY CREATE'CIOS _ 40;})* CREATE CONTROL I/O STREAM
}'INTEGER UTILITY READ'CIOS'FIELD _ 41;}%* READ CIOS FIELD
}'UNKNOWN UTILITY SET'CIOS'FIELD _ 42;}&* SET (SOME) CIOS FIELDS
}'UNKNOWN UTILITY SET'CIOS'INPUT _ 43;}&* SET UP FOR INPUT
}'UNKNOWN UTILITY SET'CIOS'OUTPUT _ 44;}%* SET UP FOR OUTPUT



******************************
*
* CIOS INPUT/OUTPUT
*
******************************

}'UNKNOWN UTILITY PRINT'STRING _ 45;}(* WRITE STRING ON CIOS
}'UNKNOWN UTILITY PRINT'CHAR _ 46;}** WRITE (= BUFFER) CHAR ON CIOS
}'UNKNOWN UTILITY START'OUTPUT _ 47;}(* DUMP OUTPUT BUFFER
}'STRING UTILITY READ'LINE _ 48;},* READ NEXT INPUT LINE
}'STRING UTILITY EDIT'LINE _ 49;},* EDIT CURRENT LINE
}'CHARACTER UTILITY READ'CHAR _ 50;})* READ NEXT CHARACTER
}'UNKNOWN UTILITY BLOCK'OB'EMPTY _ 51;}&* WAIT UNTIL OUT BUFFER IS EMPTY



******************************
*
* USER, ACCOUNT, AND GROUP PROFILES
*
******************************

}'STRING UTILITY READ'UP'ITEM _ 60;})* READ ITEM FROM USER PROFILE
}'STRING UTILITY READ'UP'NAMES _ 61;}(* READ NAMES OF UP ITEMS
}'UNKNOWN UTILITY SET'UP'ITEM _ 62;})* SET (CREATE) VALUE OF UP ITEM
}'UNKNOWN UTILITY SET'UP'ACCESS _ 63;}'* SET ACCESS TO UP ITEM
}'LONG UTILITY FIND'MIB _ 64;}/* CONVERT USER NAME/NUMBER TO MIB ADDR
}'INTEGER UTILITY CREATE'UP'ENTRY _ 65;}%* CREATE USER/UP ENTRY
}'UNKNOWN UTILITY DELETE'UP'ENTRY _ 66;}%* DELETE USER/UP ENTRY

******************************
*
* PROCESSES, AND PROCESS PROFILE
*
******************************

}'UNKNOWN UTILITY CREATE'PROCESS _ 70;}&* CREATE/INITIALIZE PROCESS
}'STRING UTILITY READ'PP'ITEM _ 71;})* READ ITEM FROM PROCESS PROFILE
}'STRING UTILITY READ'PP'NAMES _ 72;}(* READ NAMES OF PP ITEMS
}'UNKNOWN UTILITY SET'PP'ITEM _ 73;})* SET (CREATE) VALUE OF PP ITEM
}'UNKNOWN UTILITY DESTROY'PROCESS _ 74;}%* DESTROY THIS PROCESS



******************************
*
* TIME CALCULATIONS
*
******************************

}'INTEGER UTILITY SYS'TIME'NUM _ 80;}(* NUMERICAL SYSTEM TIMES
}'INTEGER UTILITY ANY'TIME'NUM _ 81;}(* CHARACTER SPECIFIC TIMES
}'STRING UTILITY ANY'TIME'CHAR _ 82;}(* CHARACTER SPECIFIC TIMES 


}'END;

}'COMMON ERROR'DEFS;

*}&THIS COMMON BLOCK DECLARES ALL THE VARIABLES USED TO PRINT OUT
* ERROR MESSAGES AND THE MACROS USED IN THE FAILURE RETURN FIELD OF
* FUNCTION CALLS.

* BE CAREFUL, MACROS!
}'MACRO IMPERFECTION _ RUNTIME'FAILURE();
}'MACRO CALAMITY _ FATAL'ERROR();
}'MACRO MISFORTUNE _ SYSTEM'ERROR(): ERROR'CODE, ERROR'NUMBER;

}'DECLARE INTEGER
}*ERROR'CODE,}(/* CHARACTER CODE OF ERROR}/*/
}*ERROR'FILE'NUM,}$/* THE FILE NUMBER USED BY THE FORMAT-}#*/
}=/*}#TING OUTPUT FUNCTIONS}/*/
}*ERROR'NUMBER,}&/* NUMERICAL CODE OF ERROR}/*/
}*ERROR'RADIX;}'/* THE RADIX OF NUMBERS OUTPUT BY THE}$*/
}=/*}#FORMATTING OUTPUT FUNCTIONS})*/

}'DECLARE STRING
}*ERROR'STRING (200);/* THE STRING USED BY THE FORMATTING}%*/
}=/*}#OUTPUT FUNCTIONS}4*/



}'END;

}'COMMON ARRAY'DEFS;

*}&THIS COMMON BLOCK DEFINES ALL THE FIELDS USED TO MANIPULATE
* ARRAYS WITH.

}'INCLUDE ERROR'DEFS;

}'DECLARE FIELD})/* FOR THE ARRAY DESCRIPTOR ITSELF}'*/
}*INDEXING'ORGIN (0:2,2),
}*ARRAY'TRAP'BIT (0:3,3),
}*LEB (0:4,4),
}*ITEM'SIZE'LEB0 (0:5,6),
}*ITEM'SIZE'LEB1 (0:5,10),
}*UPPER'BOUND'LEB0 (0:7,23),
}*UPPER'BOUND'LEB1 (0:11,23),
}*ARRAY'DESC'ADDR (1);

}'DECLARE FIELD})/* FOR GENERAL INDIRECT ADDRESS WORDS}$*/
}*IAW'TYPE (0:0,1),
}*IAW'TAG (0:2,4),
}*IAW'TRAP (0:5,5),
}*IAW'ADDRESS (0:6,23);

}'DECLARE PARAMETER}%/* FOR IAW'TYPE}:*/
}*NORMAL'IAW _ 0,
}*FIELD'IAW _ 1,
}*STRING'IAW _ 2,
}*ARRAY'IAW _ 3;

}'DECLARE PARAMETER}%/* FOR IAW'TAG};*/
}*DIRECT _ 0,
}*INDIRECT _ 1,
}*INDEXED _ 2,
}*BASE'INDEXED _ 3,
}*POINTER'DISP _ 4,
}*IND'PTR'DISP _ 5,
}*BASE'INDEX'DISP _ 6,
}*RELATIVE _ 7;


}'END;

}'PROGRAM CONS'ARRAY'DESC;

*}&THIS FUNCTION CREATES AN ARRAY DESCRIPTOR GIVEN THE BASE ADDRESS,
* THE NUMBER OF ELEMENTS, ELEMENT SIZE, AND LOWER BOUND.}"THIS FUNCTION
* FAILS IF ONE THE THE ARGUMENTS ARE INVALID.

}'INCLUDE ARRAY'DEFS;

}'DECLARE ARRAY
}*ARRAY'DESC;

}'DECLARE FIELD
}*MULTIPLIER,}(/* WHAT IT IS DEPENDS ON LEB}-*/
}*UPPER'LIMIT;}'/* WHAT IT IS DEPENDS ON LEB}-*/

}'DECLARE INTEGER
}*BASE'ADDRESS,}&/* FIRST ADDRESS THAT STORAGE BEGINS IN}"*/
}*ELEMENT'SIZE,}&/* NUMBER OF WORDS PER ENTRY}-*/
}*KLUDGE,
}*LARGE'ELEMENT,
}*LOWER'BOUND,}'/* AN ARRAY OR AN ARRAYONE}/*/
}*NO'OF'ELEMENTS,}$/* NUMBER OF ELEMENTS}4*/
}*UPPER'BOUND;}'/* HIGHEST VALID SUBSCRIPT}/*/



}'ARRAY FUNCTION CONS'ARRAY'DESC(BASE'ADDRESS, NO'OF'ELEMENTS,
}*ELEMENT'SIZE, LOWER'BOUND), FRETURN;

* CHECK THE PARAMETERS PASSED TO SEE IF THEY ARE VALID
}'IMPERFECTION IF (BASE'ADDRESS < 0 OR BASE'ADDRESS > (-1)$IAW'ADDRESS);
}'IMPERFECTION IF NO'OF'ELEMENTS < 0;
}'IMPERFECTION IF (ELEMENT'SIZE < 1 OR ELEMENT'SIZE >
}*(-1)$ITEM'SIZE'LEB1 + 1);
}'IMPERFECTION IF (LOWER'BOUND # 0 AND LOWER'BOUND # 1);

* SET UP THE FIELDS FOR SMALL OR LARGE ELEMENT CASES
}'IF ELEMENT'SIZE <= 4 DO;
}*LARGE'ELEMENT _ 0;
}*MULTIPLIER _ ITEM'SIZE'LEB0;
}*UPPER'LIMIT _ UPPER'BOUND'LEB0;
}'ELSE DO;
}*LARGE'ELEMENT _ 1;
}*MULTIPLIER _ ITEM'SIZE'LEB1;
}*UPPER'LIMIT _ UPPER'BOUND'LEB1;
}'ENDIF;

* COMPUTE AND CHECK UPPER'BOUND
}'UPPER'BOUND _ LOWER'BOUND + NO'OF'ELEMENTS - 1;
*}&A CONSTANT OR PARAMETER TAILED WITH A VARIABLE FIELD CAUSES SPL
* TO GENERATE INCORRECT CODE, SO HERE'S THE KLUDGE.
}'KLUDGE _ -1;
}'CALAMITY IF UPPER'BOUND > KLUDGE$UPPER'LIMIT;

* CONSTRUCT AND RETURN THE DESCRIPTOR
}'ARRAY'DESC$IAW'TYPE _ ARRAY'IAW;
}'ARRAY'DESC$INDEXING'ORGIN _ LOWER'BOUND;
}'ARRAY'DESC$ARRAY'TRAP'BIT _ 0;
}'ARRAY'DESC$LEB _ LARGE'ELEMENT;
}'ARRAY'DESC$MULTIPLIER _ ELEMENT'SIZE - 1;
}'ARRAY'DESC$UPPER'LIMIT _ UPPER'BOUND;
}'ARRAY'DESC$ARRAY'DESC'ADDR _ NORMAL'IAW@IAW'TYPE V'
}*INDEXED@IAW'TAG V' 0@IAW'TRAP V' BASE'ADDRESS@IAW'ADDRESS;

}'RETURN ARRAY'DESC;


}'END;

}'COMMON STRING'DEFS;

*}&THIS COMMON BLOCK DEFINES ALL THE FIELDS USED TO MANIPULATE
* STRINGS WITH.

}'INCLUDE ERROR'DEFS;

}'DECLARE FIELD
}*BP (0),},/* BEGIN POINTER}9*/
}*RP (1),},/* READ POINTER}:*/
}*WP (2),},/* WRITE POINTER}9*/
}*EP (3);},/* END POINTER};*/

}'DECLARE FIELD
}*CHAR'SIZE (0:2,3), /* THE SIZE OF CHARACTERS IN THE STRING}"*/
}=/*}#(0 = 6 BITS, 1 = 8 BITS,},*/
}=/*}#2 = 12 BITS, AND 3 = 24 BITS)}'*/
}*CHAR'POSITION}&/* THE CHARACTER POSITION IN THE WORD}$*/
},(0:4,5);

}'DECLARE FIELD})/* FOR 6 BIT CHARACTERS}2*/
}*CHAR6'0 (0:0,5),
}*CHAR6'1 (0:6,11),
}*CHAR6'2 (0:12,17),
}*CHAR6'3 (0:18,23);

}'DECLARE FIELD})/* FOR 8 BIT CHARACTERS}2*/
}*CHAR8'0 (0:0,7),
}*CHAR8'1 (0:8,15),
}*CHAR8'2 (0:16,23);

}'DECLARE FIELD})/* FOR 12 BIT CHARACTERS}1*/
}*CHAR12'0 (0:0,11),
}*CHAR12'1 (0:12,23);

}'DECLARE STRING FIELD}"/* A KLUDGE SO THAT WHEN THE POINTER TO}"*/
}*STRING'DESC (0);}#/*}#ONTO STRING DESCRIPTOR IS ASSIGNED}"*/
}=/*}#TO ANOTHER, SPL WILL DO THE RIGHT}#*/
}=/*}#THING.}>*/



}'END;

}'PROGRAM APPEND;

*}&THIS PROGRAM BLOCK TAKES AS ITS ARGUMENTS TWO STRINGS WHICH IT
* ATTEMPTS TO CONCATENATE TOGETHER.}"THERE ARE TWO ENTRY POINTS TO THE
* PROGRAM, SCOPY, AND APPEND.}"SCOPY IS JUST A SPECIAL CASE OF APPEND
* IN WHICH ONE STRING WILL BE COPIED TO THE BEGINNING OF THE OTHER
* STRING.
*}&I TRIED TO BE CONSISTENT AND DECLARE ALL VARIABLES EXPLICITLY,
* IN "DECLARE" STATEMENTS, BUT THERE SEEM TO BE PROBLEMS WITH DECLARING
* A STRING WHICH WILL BE AN ARGUMENT TO A FUNCTION AND LATER IN THE
* FUNCTION DEFINITION, INFORMING SPL THAT THAT STRING WILL BE CALLED
* BY WHAT I CONSIDER TO BE CALL BY NAME.

}'INCLUDE STRING'DEFS;

}'DECLARE STRING
}*ADDENDUM,}*/* THE STRING FROM WHICH CHARACTERS ARE}"*/
}=/*}#COPIED INTO THE FIRST ARGUMENT}&*/
*})OBJECT,},/* THE STRING TO WHICH CHARACTERS WILL}#*/
}=/*}#BE COPIED};*/
}*WORKING'NAME;}&/* TO KEEP SPL HAPPY}5*/

}'DECLARE INTEGER
}*COUNT,}-/* JUST A COUNTER FOR A FOR LOOP})*/
}*LENGTH'ADDENDUM;}#/* LENGTH OF THE STRING ADDENDUM})*/



* SCOPY - COPY THE SECOND STRING INTO THE FIRST
}'UNKNOWN FUNCTION SCOPY(STRING @OBJECT, ADDENDUM), FRETURN;
}'OBJECT.WP _ OBJECT.RP _ OBJECT.BP;



* APPEND - APPEND THE SECOND STRING TO THE FIRST
}'UNKNOWN FUNCTION APPEND(STRING @OBJECT, ADDENDUM), FRETURN;
}'WORKING'NAME _ OBJECT.STRING'DESC;
}'CALAMITY IF ADDENDUM$CHAR'SIZE # WORKING'NAME$CHAR'SIZE;
}'LENGTH'ADDENDUM _ LENGTH(ADDENDUM);
}'IMPERFECTION IF
}*LENGTH'ADDENDUM > LNGDES(WORKING'NAME$WP, WORKING'NAME$EP);

}'FOR COUNT _ 1 TO LENGTH'ADDENDUM DO;
}*WCI(GCI(ADDENDUM), WORKING'NAME);
}'ENDFOR;

}'OBJECT.WP _ WORKING'NAME$WP;
}'RETURN;


}'END;

}'PROGRAM SETUP'KLUDGE;

*}&THIS FUNCTION DOES WHAT SETUP OUGHT TO DO -- TAKE A VARIABLE
* CHARACTER SIZE.}"UNFORTUNATELY, THE ONLY WAY IT CAN DO IT IS BY DOING
* A SETUP FOR EACH POSSIBLE CHARACTER SIZE.

}'INCLUDE STRING'DEFS;

}'DECLARE INTEGER
}*BEGIN'ADDRESS,
}*CHARACTER'SIZE,
}*LENGTH;

}'DECLARE STRING
*})STR'DESC'POINTER,
}*WORKING'NAME;



}'UNKNOWN FUNCTION SETUP'KLUDGE(STRING @STR'DESC'POINTER, LENGTH,
}*BEGIN'ADDRESS, CHARACTER'SIZE), FRETURN;

}'WORKING'NAME _ STR'DESC'POINTER.STRING'DESC;
}'IF CHARACTER'SIZE = 6 DO;
}*SETUP(WORKING'NAME, LENGTH, BEGIN'ADDRESS, 6);
}'ELSEIF CHARACTER'SIZE = 8 DO;
}*SETUP(WORKING'NAME, LENGTH, BEGIN'ADDRESS, 8);
}'ELSEIF CHARACTER'SIZE = 12 DO;
}*SETUP(WORKING'NAME, LENGTH, BEGIN'ADDRESS, 12);
}'ELSEIF CHARACTER'SIZE = 24 DO;
}*SETUP(WORKING'NAME, LENGTH, BEGIN'ADDRESS, 24);
}'ELSE DO;
}*RUNTIME'FAILURE();
}*FRETURN;
}'ENDIF;
}'STR'DESC'POINTER.STRING'DESC _ WORKING'NAME;

}'RETURN;



}'END;

}'PROGRAM CNS;

*}&THIS FUNCTION APPENDS A SINGLE PRECISION INTEGER TO A STRING
* AFTER CONVERTING THE INTEGER FROM INTERNAL REPRESENTATION TO CHAR-
* ATER REPRESENTATION.}"THIS FUNCTION FAILS IF THE BASE THE NUMBER WILL
* BE CONVERTED TO IS OUTSIDE THE ALLOWABLE RANGE OF 2 TO 36, INCLUSIVE,
* OR IF THE STRING PASSED TO IT CAN'T HOLD ALL THE CHARACTERS OF THE 
* BER.

}'INCLUDE STRING'DEFS;

}'DECLARE INTEGER
}*BASE,}./* THE BASE THE NUMBER WILL BE CONVERTED */
}=/*}#TO}B*/
}*CHAR,}./* THE CHARACTER TO WRITE INTO THE STRING*/
}*COUNT,}-/* JUST A COUNTER FOR FOR LOOPS}**/
}*LENGTH'TEMP,}'/* LENGTH OF THE STRING TEMP}-*/
}*NUMBER,},/* THE NUMBER TO CONVERT}1*/
}*NUMBER'OF'CHARS,}#/* BITS (18-23) OF SIGN'NUM'CHARS}(*/
}*SIGN'FLAG,})/* SET IF NEGATIVE NUMBERS ARE TO BE}%*/
}=/*}#CONVERTED SIGNED}4*/
}*SIGN'NUM'CHARS;}$/* DETERMINES IF THE NUMBER WILL BE}&*/
}=/*}#SIGNED AND HOW MANY CHARACTERS TO}#*/
}=/*}#GENERATE.}"IF IT IS 0, IT WILL BE}#*/
}=/*}#CONVERTED SIGNED AND WITHOUT PAD-}#*/
}=/*}#DING OR TRUNCATION}2*/

}'DECLARE STRING
}*TEMP (24),})/* A TEMPORARY STRING EACH DIGIT IS}&*/
}*WORKING'NAME;}&/* TO KEEP SPL HAPPY}5*/
}=/*}#WRITTEN INTO}8*/



}'UNKNOWN FUNCTION CNS(NUMBER, STRING @STRING'CREATED,
}*SIGN'NUM'CHARS, BASE), FRETURN;

}'IMPERFECTION IF BASE < 2 OR BASE > 36;
}'WORKING'NAME _ STRING'CREATED.STRING'DESC;
}'SIGN'FLAG _ (-1 IF SIGN'NUM'CHARS >= 0 AND NUMBER < 0 ELSE 0);
}'NUMBER _ -NUMBER IF SIGN'FLAG;

* BE CLEVER AND WRITE THE STRING BACKWARDS
}'TEMP$RP _ TEMP$WP _ TEMP$EP;

}'IF NUMBER # 0 DO;
}*WHILE NUMBER # 0 DO;
}-.LDA NUMBER, LSHD -23, DIV BASE, STA NUMBER, STB CHAR;
}-WCD(CHAR + ('0' IF CHAR < 10 ELSE 'A' - 10), TEMP);
}*ENDFOR;
}'ELSE DO;
}*WCD('0', TEMP);
}'ENDIF;

}'WCD('-', TEMP) IF SIGN'FLAG;

* ALL WE NEED NOW IS HOW MANY CHARACTERS TO GENERATE
}'NUMBER'OF'CHARS _ SIGN'NUM'CHARS A' 77B;
}'LENGTH'TEMP _ LENGTH(TEMP);

* TRUNCATE CHARACTERS IF NECESSARY
}'IF NUMBER'OF'CHARS # 0 AND NUMBER'OF'CHARS < LENGTH'TEMP DO;
}*TEMP$RP _ INCDES(TEMP$EP, -NUMBER'OF'CHARS);

* OR PAD
}'ELSEIF NUMBER'OF'CHARS # 0 AND NUMBER'OF'CHARS > LENGTH'TEMP DO;
}*FOR COUNT _ LENGTH'TEMP + 1 TO NUMBER'OF'CHARS DO;
}-WCI(' ', WORKING'NAME//IMPERFECTION);
}*ENDFOR;
}'ENDIF;

}'FOR COUNT _ 1 TO LENGTH(TEMP) DO;
}*CHAR _ GCI(TEMP);
}*WCI(CHAR, WORKING'NAME//IMPERFECTION);
}'ENDFOR;

FINISH:STRING'CREATED.WP _ WORKING'NAME$WP;
}'RETURN;


}'END;

}'COMMON SEQ'FILE'DEFS;

*}&THIS COMMON BLOCK CONTAINS THE DECLARATIONS OF IDENTIFIERS
* USED IN FILE HANDLING OPERATIONS.

}'DECLARE ARRAYONE
}*OPEN'FILE'TABLE[16];
}=/* ARRAY DETERMINING WHICH FILES ARE OPEN*/

}'DECLARE FIELD
}*PAGE'NUM'ADDR}&/* THE PAGE NUMBER OF THE ADDRESS}(*/
}-(0:6,12),
}*PAGES'IN'FILE}&/* NUMBER OF PAGES IN THE FILE}+*/
}-(0:2,12),
}*WORDS'IN'PAGE}&/* WORD NUMBER IN THE LAST PAGE}**/
}-(0:13,23);

}'DECLARE PARAMETER
}*A'PAGE _ 2048;}%/* WORDS TO A PAGE}7*/

}'DECLARE PARAMETER}%/* FOR IOFLAG VALUES}5*/
}*READ'FILE _ 0,
}*WRITE'FILE _ 1,
}*APPEND'FILE _ 2;

}'DECLARE PARAMETER}%/* FOR OBJECT TYPES}6*/
}*SMALL'FILE _ 0,
}*LARGE'FILE _ 1;

}'DECLARE PARAMETER}%/* FOR FILE TYPES}8*/
}*SUBCOMMAND'FILE _ 6'9SUB',
}*SAVE'FILE _ 6'9SAV',
}*BINARY'FILE _ 6'9BIN',
}*SYMBOLIC'FILE _ 6'9SYM',
}*DUMP'FILE _ 6'9DMP',
}*UNKNOWN'FILE _ 6'}$';

}'DECLARE PARAMETER}%/* FOR THE MAXIMUM LENGTH OF FILENAMES}#*/
}*LENGTH'PFS'NAMES _ 13,
}*LENGTH'TSS'NAMES _ 16;



}'END;

}'COMMON WINDOW'DEFS;
}'
* THIS COMMON BLOCK DECLARES THE STRUCTURE OF A WINDOW DESCRIPTOR

}'DECLARE PARAMETER
}*NUM'SEQ'FILES _ 2;

}'DECLARE ARRAY
}*SEQ'FILE'TABLE[NUM'SEQ'FILES:21];

}'DECLARE SIGNED FIELD
}*PAGE'IN'WINDOW (0:0,11); /* PAGE NUMBER OF THE FILE})*/
}'
}'DECLARE FIELD
}*PMT'INDEX (0:12,19),}%/* PMT INDEX OF THE FILE}+*/
}*WINDOW'IN'USE (0:20,20),
}B/* BIT SIGNALING THE WINDOW IS IN}"*/
}C/*}#USE};*/
}*LARGE'OR'SMALL (0:21,21),/* LARGE OR SMALL FILE}-*/
}*OPERATION (0:22,23),}%/* BITS REPRESENTING WHAT WILL BE}"*/
}C/*}#DONE TO THE FILE}.*/
}*FILE'NUM (1:1,5),}(/* NUMBER OF THE FILE}.*/
}*WINDOW'ADDRESS (1:6,23), /* ADDRESS OF THE WINDOW IN USE}$*/
}*CHARACTER'SIZE (2:0,5),}"/* NUMBER OF BITS PER CHARACTER}$*/
}*CHARS'PER'WORD (2:6,8),}"/* NUMBER OF CHARACTERS PER WORD}#*/
}*CHARS'PER'PAGE (2:9,23), /* NUMBER OF CHARACTERS PER PAGE}#*/
}*NAME'STORAGE (3);}(/* STORAGE FOR THE M1 FORMATTED}$*/
}C/*}#NAME}:*/

}'DECLARE STRING FIELD
}*READ'DESC (11);}*/* STRING DESCRIPTOR FOR A FILE}$*/
}C/*}#WHICH WILL BE READ},*/

}'DECLARE FIELD
}*CHARS'LEFT (15);})/* NUMBER OF CHARACTERS YET TO BE}"*/
}C/*}#READ FROM THE FILE (AFTER THE */
}C/*}#CURRENT PAGE HAS BEEN READ)}#*/

}'DECLARE STRING FIELD
}*WRITE'DESC (16);})/* STRING DESCRIPTOR OF A FILE}%*/
}C/*}#WHICH WILL BE READ},*/

}'DECLARE FIELD
}*LENGTH'IN'CHARS (20);}$/* NUMBER OF CHARACTERS ALREADY}$*/
}C/*}#WRITTEN INTO THE FILE (AFTER}"*/
}C/*}#THE LAST PAGE HAD BEEN}(*/
}C/*}#WRITTEN)}6*/
}'
}'DECLARE ARRAY
}*SEQ'FILE'WINDOWS[NUM'SEQ'FILES] _ (100000B, 104000B);


}'END;

}'COMMON SPECIAL'CHARS;

*}&THIS COMMON BLOCK DECLARES ALL THE SPECIAL CHARACTERS USED IN
* THIS PROGRAM OTHER THAN THOSE NEED BY THE DTP FUNCTIONS.

}'DECLARE PARAMETER}%/* FOR 940 CHARACTER CONSTANTS}+*/
}*BLANK _ 0,
}*MB _ 135B,})/*}#940 MULTIPLE BLANK CHARACTER}(*/
}*EOF _ 137B,}(/*}#940 END OF FILE CHARACTER}+*/
}*NULL _ 140B,
}*LF _ 152B,
}*CR _ 155B;

}'DECLARE PARAMETER}%/* FOR M1 CHARACTER CONSTANTS},*/
}*ESCAPE'CHAR _ 37B, /*}#FOR I/O THROUGH THE CHIO},*/
}*M1'MB _ 200B,
}*M1'NULL _ 300B,
}*M1'NL _ 307B,
}*M1'LF _ 310B,
}*M1'CR _ 355B;

}'DECLARE PARAMETER}%/* ASCII CHARACTER CONSTANTS}-*/
}*ASCII'NULL _ 0,
}*ASCII'LF _ 12B,
}*ASCII'CR _ 15B,
}*ASCII'BLANK _ 40B;


}'END;

}'COMMON ASCII'940'TABLES;

* TRANSLATES BETWEEN ASCII AND 940

}'INCLUDE SPECIAL'CHARS;

}'DECLARE ARRAY TRANS'TBL'940'AS[200B] _ (ASCII'NULL);
}'MACRO CNVRT'940'ASCII (CHAR) _
}*DECLARE ARRAY TRANS'TBL'940'AS[CHAR] _ ;

}'CNVRT'940'ASCII (}"0B) ( 40B,}"41B,}"42B,}"43B,}"44B,}"45B,}"46B,}"47B);
}'CNVRT'940'ASCII ( 10B) ( 50B,}"51B,}"52B,}"53B,}"54B,}"55B,}"56B,}"57B);
}'CNVRT'940'ASCII ( 20B) ( 60B,}"61B,}"62B,}"63B,}"64B,}"65B,}"66B,}"67B);
}'CNVRT'940'ASCII ( 30B) ( 70B,}"71B,}"72B,}"73B,}"74B,}"75B,}"76B,}"77B);
}'CNVRT'940'ASCII ( 40B) (100B, 101B, 102B, 103B, 104B, 105B, 106B, 107B);
}'CNVRT'940'ASCII ( 50B) (110B, 111B, 112B, 113B, 114B, 115B, 116B, 117B);
}'CNVRT'940'ASCII ( 60B) (120B, 121B, 122B, 123B, 124B, 125B, 126B, 127B);
}'CNVRT'940'ASCII ( 70B) (130B, 131B, 132B, 133B, 134B, 135B, 136B, 137B);
}'CNVRT'940'ASCII (100B) (140B, 141B, 142B, 143B, 144B, 145B, 146B, 147B);
}'CNVRT'940'ASCII (110B) (150B, 151B, 152B, 153B, 154B, 155B, 156B, 157B);
}'CNVRT'940'ASCII (120B) (160B, 161B, 162B, 163B, 164B, 165B, 166B, 167B);
}'CNVRT'940'ASCII (130B) (170B, 171B, 172B, 173B, 174B, 174B, 176B, 177B);
}'CNVRT'940'ASCII (140B) (}"0B,}#1B,}#2B,}#3B,}#4B,}#5B,}#6B,}#7B);
}'CNVRT'940'ASCII (150B) ( 10B,}"11B,}"12B,}"13B,}"14B,}"15B,}"16B,}"17B);
}'CNVRT'940'ASCII (160B) ( 20B,}"21B,}"22B,}"23B,}"24B,}"25B,}"26B,}"27B);
}'CNVRT'940'ASCII (170B) ( 30B,}"31B,}"32B,}"33B,}"34B,}"35B,}"36B,}"37B);


}'DECLARE ARRAY TRANS'TBL'AS'940[200B] _ (NULL);
}'MACRO CNVRT'ASCII'940 (CHAR) _
}*DECLARE ARRAY TRANS'TBL'AS'940[CHAR] _ ;

}'CNVRT'ASCII'940 (}"0B) (140B, 141B, 142B, 143B, 144B, 145B, 146B, 147B);
}'CNVRT'ASCII'940 ( 10B) (150B, 151B, 152B, 153B, 154B, 155B, 156B, 157B);
}'CNVRT'ASCII'940 ( 20B) (160B, 161B, 162B, 163B, 164B, 165B, 166B, 167B);
}'CNVRT'ASCII'940 ( 30B) (170B, 171B, 172B, 173B, 174B, 175B, 176B, 177B);
}'CNVRT'ASCII'940 ( 40B) (}"0B,}#1B,}#2B,}#3B,}#4B,}#5B,}#6B,}#7B);
}'CNVRT'ASCII'940 ( 50B) ( 10B,}"11B,}"12B,}"13B,}"14B,}"15B,}"16B,}"17B);
}'CNVRT'ASCII'940 ( 60B) ( 20B,}"21B,}"22B,}"23B,}"24B,}"25B,}"26B,}"27B);
}'CNVRT'ASCII'940 ( 70B) ( 30B,}"31B,}"32B,}"33B,}"34B,}"35B,}"36B,}"37B);
}'CNVRT'ASCII'940 (100B) ( 40B,}"41B,}"42B,}"43B,}"44B,}"45B,}"46B,}"47B);
}'CNVRT'ASCII'940 (110B) ( 50B,}"51B,}"52B,}"53B,}"54B,}"55B,}"56B,}"57B);
}'CNVRT'ASCII'940 (120B) ( 60B,}"61B,}"62B,}"63B,}"64B,}"65B,}"66B,}"67B);
}'CNVRT'ASCII'940 (130B) ( 70B,}"71B,}"72B,}"73B,}"74B,}"75B,}"76B,}"77B);
}'CNVRT'ASCII'940 (140B) (100B, 101B, 102B, 103B, 104B, 105B, 106B, 107B);
}'CNVRT'ASCII'940 (150B) (110B, 111B, 112B, 113B, 114B, 115B, 116B, 117B);
}'CNVRT'ASCII'940 (160B) (120B, 121B, 122B, 123B, 123B, 125B, 126B, 127B);
}'CNVRT'ASCII'940 (170B) (130B, 131B, 132B, 133B, 134B, 135B, 136B, 137B);



}'END;

}'COMMON MESSAGES;

*}&THIS COMMON BLOCK JUST DECLARES ALL THE ERROR MESSAGES THAT MAY
* BE PRINTED OUT BY THIS PROGRAM.

}'MACRO PRINT'ERROR _
}*VALUE OUTPUT'STRING(ERROR'MESSAGES[ERROR'NUMBER]) & RETURN:
}*ERROR'NUMBER;

}'DECLARE STRING ARRAY
}*ERROR'MESSAGES[100] _ ("");

}'MACRO PROGRAM'ERROR (X) _ DECLARE STRING ARRAY ERROR'MESSAGES[X];

}'PROGRAM'ERROR(0) _ "INVALID ARGUMENTS FOR CON'ARRAY'DESC";
}'PROGRAM'ERROR(1) _ "COULDN'T WRITE CHARACTER INTO THE STRING";
}'PROGRAM'ERROR(2) _ "COULDN'T READ CHARACTER FROM THE STRING";
}'PROGRAM'ERROR(3) _ "CAN'T APPEND THE STRING";
}'PROGRAM'ERROR(4) _ "INVALID ARGUMENTS FOR CNS";
}'PROGRAM'ERROR(5) _ "INVALID ARGUMENTS FOR CSN";
}'PROGRAM'ERROR(6) _ "EXPECTED PARAMETER WITH COMMAND";

* ERROR MESSAGES GENERATED BY RUN
}'PROGRAM'ERROR(10) _ "COMMAND NOT FOUND";
}'PROGRAM'ERROR(11) _ "COMMAND IS AMBIGUOUS";
}'PROGRAM'ERROR(12) _ "COMMAND SPECIFICATION ERROR";

* ERROR MESSAGES GENERATED BY GET'FILENAME
}'PROGRAM'ERROR(15) _ "FILE NOT FOUND";
}'PROGRAM'ERROR(16) _ "FILE NAME IS AMBIGUOUS";
}'PROGRAM'ERROR(17) _ "FILE NAME SPECIFICATION ERROR";

* ERROR MESSAGES GENERATED BY ACQUIRE'ENTRY
}'PROGRAM'ERROR(20) _ "SORRY, QUEUE FULL";

* ERROR MESSAGES GENERATED BY DEL'LIST'ENTRY AND QUEUE
}'PROGRAM'ERROR(25) _ "NO SUCH COMMAND ON THE QUEUE";

* SYSTEM ERRORS
}'PROGRAM'ERROR(30) _ "SYSTEM ERROR";




}'END;

}'COMMON READER'DEFS;

}'DECLARE NUM'RDR'CMDS _ 3;
}'DECLARE NUM'RDR'REPLIES _ 4;
}'DECLARE STRING ARRAY PTR'CMDS[NUM'RDR'CMDS] _ 
}+("GO", "PTRD", "STOP");
}'DECLARE STRING ARRAY PTR'REPLIES[NUM'RDR'REPLIES] _
}*("BYE", "NG", "OFF", "OK");



}'END;
**********
}'COMMON GLOBAL'VARIABLES;

*}&THIS BLOCK CONTAINS GENERAL CONSTANTS AND VARIABLES USED
* THROUGHTOUT THE PROGRAM

}'INCLUDE MONITOR'CALLS, UTILITY'CALLS, STRING'DEFS, WINDOW'DEFS,
}*SPECIAL'CHARS, READER'DEFS, MESSAGES, SEQ'FILE'DEFS;

}'DECLARE PARAMETER}%/* FOR SETTING FLAGS}5*/
}*FALSE _ 0,
}*TRUE _ 1;

}'DECLARE INTEGER
}*CNTRL'LINE'4,}&/* FOURTH WORD OF THE ENTRY}.*/
}*DATA'LINE'4,}'/* FOURTH WORD OF THE ENTRY}.*/
}*INIT'STACK'LEVEL,}"/* STACK LEVEL UPON ENTRY}0*/
}*CHIO'WATCH,}(/* CHIO INTERRUPT NUMBER}1*/
}*THIS'PROCESS,
}*THIS'SUB'PROCESS;}"/* CURRENT SUB-PROCESS INDEX INTO THE SPT*/

}'DECLARE PARAMETER}%/* IO DEFS}?*/
}*DESTRUCTIVELY _ 0,
}*MOST'POSSIBLE _ -1,
}*CNTRL'READ'LINE _ 28,
}*CNTRL'WRITE'LINE _ 29,
}*DATA'READ'LINE _ 30,
}*DATA'WRITE'LINE _ 31;

}'DECLARE FIELD
}*CHARS'FOUND(0:2,23);

}'DECLARE INTEGER
}*BYE'INDEX _ 0, NG'INDEX _ 1, OFF'INDEX _ 2, OK'INDEX _ 3,
}*OUTPUT'FILE;}'/* SO SP'TRAP'HANDLER CAN CLOSE IT}'*/

}'DECLARE STRING
}*INCOMPLETE(30), INPUT'DATA'BLK(2000);



}'END;

}'PROGRAM FROM'THE'READER;

*}&THIS FUNCTION FIGURES OUT WHAT THE USER HAS REQUESTED

}'INCLUDE GLOBAL'VARIABLES;

}'DECLARE INTEGER
}*COMMAND'INDEX,}%/* INTO ARRAY OF LEGAL COMMANDS}**/
}*OPEN'FILE'NUM,
}*SEQ'FILE'NUM,
})TM'BITS'SET;

}'DECLARE STRING
}*COMMAND'LINE(100), /* LINE TYPED BY THE USER TO THE EXEC}$*/
}*COMMAND(30),}'/* THE COMMAND THE USER WANTS EXECUTED}#*/
}*FILE'NAME(30);



}'FUNCTION FROM'THE'READER();

* INITIALIZE FILE WINDOWS
}'FOR SEQ'FILE'NUM _ 0 TO NUM'SEQ'FILES - 1 DO;
}*SEQ'FILE'TABLE[SEQ'FILE'NUM]$WINDOW'IN'USE _ FALSE;
}'ENDFOR;
}'FOR OPEN'FILE'NUM _ 1 TO 16 DO;
}*OPEN'FILE'TABLE[OPEN'FILE'NUM] _ -1;
}'ENDFOR;

* READ SYSTEM INDEXES
}'THIS'PROCESS _ READ'PROC'PARAM('PRT'//MISFORTUNE);
}'THIS'SUB'PROCESS _ READ'SPS'PARAM('CSP'//FATAL'ERROR():
}*ERROR'CODE, ERROR'NUMBER);
}'INIT'STACK'LEVEL _ READ'SPS'PARAM('CSL'//FATAL'ERROR():
}*ERROR'CODE, ERROR'NUMBER);
}'TM'BITS'SET _ READ'SPT'FIELD(THIS'SUB'PROCESS, 'TM'//MISFORTUNE);
}'SET'SPT'FIELD(THIS'SUB'PROCESS, 'TM', (TM'BITS'SET V' 1)//MISFORTUNE);
}'CHIO'WATCH _ GET'INT'NUM('CHI'//FATAL'ERROR():
}*ERROR'CODE, ERROR'NUMBER);

* INITIALIZE IO (CNTRL WAKEUPS UP ON CONTROL, DATA ON ANYTHING)
}'SET'LINE'TABLES();
}'SET'LINE'FIELD(CNTRL'READ'LINE, 'BWS', 1//MISFORTUNE);
}'SET'LINE'FIELD(DATA'READ'LINE, 'BWS', 3//MISFORTUNE);
}'SET'LINE'FIELD(CNTRL'READ'LINE, 'WKC', 3B3//MISFORTUNE);
}'SET'LINE'FIELD(DATA'READ'LINE, 'WKC', 3B3//MISFORTUNE);
}'READ'CALL();
}'RES'LINE'TABLES();
}'EXIT();


}'END;

}'PROGRAM SET'LINE'TABLES;

*}&THE FUNCTION SET'LINE'TABLES ACQUIRES THE LINES NECESSARY FOR
* FTP TO RUN -- THE CONTROL AND DATA LINES.}"THE FUNCTION RES'LINE'TABLES
* RESETS THE TABLES TO THEIR ORIGINAL FORM.

}'INCLUDE GLOBAL'VARIABLES;

}'DECLARE FIELD
}*HIGH'HALF(0:0,11);

}'DECLARE OCTAL PARAMETER
}*ENTRY'LENGTH _ 4,
}*MAIN'TABLE'BASE}$/* BASE ADDRESS OF THE MAIN TABLE}(*/
}-_ 6104B,
}*REL'COMPENSATION}#/* THE NUMBER NECESSARY TO TURN AN ABSO- */
}-_ 664B3;}(/*}#LUTE ADDRESS INTO A RELATIVE ONE}$*/

}'DECLARE PARAMETER
}*READ _ 0,
}*WRITE _ 1;

}'DECLARE INTEGER
}*ADDRESS,
}*DATA;}./* WHAT THE ENTRIES WILL BE CHANGED TO}#*/



}'UNKNOWN FUNCTION SET'LINE'TABLES();

}'ADDRESS _ (CNTRL'READ'LINE/2)*ENTRY'LENGTH + MAIN'TABLE'BASE + 3 +
}*REL'COMPENSATION;
}'CNTRL'LINE'4 _ READ'WRITE'CM(ADDRESS, CNTRL'LINE'4, READ//MISFORTUNE);
}'DATA _ CNTRL'LINE'4 A' 7777B4 V' THIS'PROCESS;
}'READ'WRITE'CM(ADDRESS, DATA, WRITE//MISFORTUNE);

}'ADDRESS _ (DATA'READ'LINE/2)*ENTRY'LENGTH + MAIN'TABLE'BASE + 3 +
}*REL'COMPENSATION;
}'DATA'LINE'4 _ READ'WRITE'CM(ADDRESS, DATA'LINE'4, READ//MISFORTUNE);
}'DATA _ DATA'LINE'4 A' 7777B4 V' THIS'PROCESS;
}'READ'WRITE'CM(ADDRESS, DATA, WRITE//MISFORTUNE);
}'READ'WRITE'CM(ADDRESS - 2, 0, WRITE//MISFORTUNE);

}'RETURN;



}'UNKNOWN FUNCTION RES'LINE'TABLES();

}'ADDRESS _ (CNTRL'READ'LINE/2)*ENTRY'LENGTH + MAIN'TABLE'BASE + 3 +
}*REL'COMPENSATION;
}'READ'WRITE'CM(ADDRESS, CNTRL'LINE'4, WRITE//MISFORTUNE);

}'ADDRESS _ (DATA'READ'LINE/2)*ENTRY'LENGTH + MAIN'TABLE'BASE + 3 +
}*REL'COMPENSATION;
}'READ'WRITE'CM(ADDRESS, DATA'LINE'4, WRITE//MISFORTUNE);

}'RETURN;




}'END;

}'PROGRAM READ'CALL;

}'INCLUDE GLOBAL'VARIABLES;

}'DECLARE INTEGER INDEX, FIRST'TIME, NUMBER'TRIES, REPLY'INDEX, CHAR;
}'DECLARE LABEL ARRAY NEXT'ACTION[NUM'RDR'REPLIES] _
}*(REDO, CALL'FE, TURN'ON, ALL'RIGHT);
}'DECLARE STRING FILENAME(30), EXEC'CMD'LINE(80);



}'FUNCTION READ'CALL();

* CLEAN OUT THE LINES
}'CLEAN'CNTRL'BUF();
}'CLEAN'DATA'BUF();

* TRY TO GET THE ATTENTION OF THE CTP CODE
}'NUMBER'TRIES _ 0;
REDO:}"RUNTIME'FAILURE() IF NUMBER'TRIES > 1;
}'SEND'TO'CTP("STOP&155");
}'NUMBER'TRIES _ NUMBER'TRIES + 1;
}'BLOCK(4B7 RSH CHIO'WATCH//MISFORTUNE);
}'GOTO REDO IF INT'CTP'REPLY(//CALAMITY) # NG'INDEX;


* NOW TRY TO GET THE CTP TO RUN THIE READER
}'NUMBER'TRIES _ 0;
RESTART:
}'RUNTIME'FAILURE() IF NUMBER'TRIES > 1;
}'SEND'TO'CTP("PTRD&155");
}'NUMBER'TRIES _ NUMBER'TRIES + 1;
}'BLOCK(4B7 RSH CHIO'WATCH//MISFORTUNE);
}'INDEX _ INT'CTP'REPLY(//CALAMITY);
}'GOTO NEXT'ACTION[INDEX];

* GOT BACK AN "OK"
ALL'RIGHT:
}'CLEAN'DATA'BUF();

* CTP NOW AWAKE, OPEN THE OUTPUT FILE
}'EXEC'CMD'LINE _ GET'COM'LINE(EXEC'CMD'LINE//MISFORTUNE);
}'GET'PARAM(EXEC'CMD'LINE);
}'FILENAME _ GET'FILENAME(FILENAME, EXEC'CMD'LINE);
}'OUTPUT'FILE _ OPEN'SEQ'FILE(FILENAME, WRITE'FILE, BINARY'FILE,
}*8//IMPERFECTION);
}'SEND'TO'CTP("GO&155");
}'FIRST'TIME _ 1;
}'WHILE 1 DO;
*})BLOCK(4B7 RSH CHIO'WATCH//MISFORTUNE);
MORE:}%CHECK'FOR'CD(//CLOSE); * FAILS IF CONTROL-D FOUND
}*REPLY'INDEX _ INT'CTP'REPLY(//GET'DATA);
}*IF REPLY'INDEX = NG'INDEX DO;
}-OUTPUT'STRING("&/READER ERROR");
}-GOTO CLOSE;
}*ELSE DO;
}-FATAL'ERROR();
}*ENDIF;
GET'DATA: INPUT'DATA'BLK _ INPUT'FROM'PUNCH(INPUT'DATA'BLK//MORE);
}*IF FIRST'TIME DO;
}-CHAR _ NULL;
}-CHAR _ GCI(INPUT'DATA'BLK//MORE) WHILE CHAR = NULL;
}-WCD(CHAR, INPUT'DATA'BLK);
}-FIRST'TIME _ 0;
}*ENDIF;
}*OUTPUT'SEQ'FILE(OUTPUT'FILE, INPUT'DATA'BLK//IMPERFECTION);
}*SETS(INPUT'DATA'BLK);
}'ENDFOR;

* THE DUMMY FORGOT TO TURN ON THE READER
TURN'ON:
}'OUTPUT'STRING("&/&/TURN ON THE READER!!!&/&/");
}'RETURN;

CLOSE: SEND'TO'CTP("STOP&155");
}'BLOCK(4B7 RSH CHIO'WATCH//MISFORTUNE);
}'FATAL'ERROR() IF INT'CTP'REPLY(//FATAL'ERROR()) # BYE'INDEX;
}'CLEAN'DATA'BUF();
}'CLOSE'SEQ'FILE(OUTPUT'FILE//IMPERFECTION);
}'RETURN;

* CTP BLEW IT.}"SHOULDN'T HAVE RETURNED A NG IN THIS CASE
CALL'FE: FATAL'ERROR();



}'END;

}'PROGRAM GET'FILENAME;

*}&THIS FUNCTION GETS THE NAME OF THE FILE FOR THE COMMAND YOU
* SPECIFIED.

}'INCLUDE GLOBAL'VARIABLES;

}'DECLARE STRING
}*COMMAND'LINE(30),}"/* HOLDS WHAT THE USER TYPES IF THE FILE-*/
}=/*}#NAME WASN'T ORGINALLY SPECIFIED}%*/
}*EXEC'CMD'LINE,}%/* THE EXEC CMD LINE AFTER BEGIN STRIPPED*/
}=/*}#OF ITS FIRST PARAMETER}.*/
}*FILE'NAME,
}*TEMP(30);



}'STRING FUNCTION GET'FILENAME(FILE'NAME, EXEC'CMD'LINE);

}'TEMP _ GET'PARAM(EXEC'CMD'LINE);

* SINCE THE FILENAME WASN'T SPECIFIED, GET IT.}"A DIFFERENT STRING MUST
* BE USED TO PERMIT LONGER FILENAMES THAN EXEC'CMD'LINE CAN HOLD
* (GET'PARAM MAY MAKE IT NULL)
}'WHILE LENGTH(TEMP) = 0 DO;
* CHANGE THIS TO HANDLE CONTROL-K'S
TRY'AGAIN:OUTPUT'STRING("&/M1 FILENAME: ");
}*COMMAND'LINE _ INPUT'STRING(COMMAND'LINE);
}*TEMP _ GET'PARAM(COMMAND'LINE);
}'ENDFOR;
}'SCOPY(FILE'NAME, TEMP//IMPERFECTION);
}'RETURN FILE'NAME;

BAD'NAME:
}'IF ERROR'CODE = 'NNF' DO;
}*OUTPUT'STRING(ERROR'MESSAGES[15]);
}'ELSEIF ERROR'CODE = 'NAM' DO;
}*OUTPUT'STRING(ERROR'MESSAGES[16]);
}'ELSE DO;
}*OUTPUT'STRING(ERROR'MESSAGES[17]);
}'ENDIF;
}'GOTO TRY'AGAIN;



}'END;

}'PROGRAM INT'CTP'REPLY;

}'INCLUDE GLOBAL'VARIABLES, ASCII'940'TABLES;

}'DECLARE INTEGER CHAR, COUNT, INDEX;

}'DECLARE STRING INPUT(12);



}'FUNCTION INT'CTP'REPLY(), FRETURN;

}'INPUT _ INPUT'DATA(CNTRL'READ'LINE, INPUT//FRETURN);
}'FOR COUNT _ 1 TO LENGTH(INPUT) DO;
}*CHAR _ GCI(INPUT);
}*CHAR _ GCI(INPUT) A' 37B IF CHAR = 37B;
}*IF CHAR < 40B DO;
}-FATAL'ERROR() IF CHAR # 15B;
}-INDEX _ ABRV'LKP(INCOMPLETE, PTR'REPLIES//MISFORTUNE);
}-SETS(INCOMPLETE);
}-RETURN INDEX;
}*ENDIF;
}*WCI(TRANS'TBL'AS'940[CHAR], INCOMPLETE);
}'ENDFOR;

* ANY CHARS AFTER THE CR ARE IGNORED, SHOULD NEVER BE ANTHING THERE ANYWAY
}'FRETURN; * NO COMPLETE COMMAND



}'END;



**********



}'PROGRAM SEND'TO'CTP;

}'INCLUDE GLOBAL'VARIABLES;

}'DECLARE STRING DATA, OUTPUT(200);



}'FUNCTION SEND'TO'CTP(DATA);

}'OUTPUT _ TRANS'940'ASCII(DATA, OUTPUT//IMPERFECTION);
}'OUTPUT'DATA(CNTRL'WRITE'LINE, OUTPUT);
}'RETURN;


}'END;

}'PROGRAM CHECK'FOR'CD;

*}&THIS FUNCTION CHECKS THE INPUT BUFFER OF THE CONTROLLING TELETYPE
* FOR CONTROL-D'S.}"THIS SIGNALS THAT THE FILE SHOULD BE CLOSED AND THE
* READER STOPPED.

}'INCLUDE GLOBAL'VARIABLES;

}'DECLARE INTEGER
}*COUNTER, STATUS'INDICATOR;

}'DECLARE FIELD
}*CHARS'FOUND(0:2,23);

}'DECLARE STRING
}*INPUT(21);



}'FUNCTION CHECK'FOR'CD(), FRETURN;

}'WHILE 1 DO;
}*SETS(INPUT);
}*READ'STRING(-2, -1, 0, INPUT: INPUT, STATUS'INDICATOR//MISFORTUNE);
}*RETURN IF STATUS'INDICATOR$CHARS'FOUND = 0;
}*FRETURN IF GCI(INPUT) = 204B FOR COUNTER _ 1 TO LENGTH(INPUT);
}'ENDFOR;
}'RETURN;



}'END;

}'PROGRAM INPUT'DATA;

* THIS FUNCTION FAILS ONLY IF THE LINE IS EMPTY WHEN THE FUNCTION IS
* CALLED.

}'INCLUDE GLOBAL'VARIABLES;

}'DECLARE INTEGER CHAR, FIRST'TIME, LINE, STATUS'INDICATOR;
}'DECLARE STRING INPUT, TEMP;



}'STRING FUNCTION INPUT'DATA(LINE, INPUT), FRETURN;

}'FIRST'TIME _ 1;
}'SETS(INPUT);
}'WHILE 1 DO;
}*READ'STRING(LINE, MOST'POSSIBLE, DESTRUCTIVELY, INPUT:
}-INPUT, STATUS'INDICATOR//MISFORTUNE);
}*IF STATUS'INDICATOR$CHARS'FOUND = 0 AND FIRST'TIME DO;
}-FRETURN;
}*ELSEIF STATUS'INDICATOR$CHARS'FOUND = 0 DO;
}-RETURN INPUT;
}*ENDIF;
}*FIRST'TIME _ 0;
}'ENDFOR;



}'STRING FUNCTION INPUT'FROM'PUNCH(INPUT), FRETURN;

}'INPUT _ INPUT'DATA(DATA'READ'LINE, INPUT//FRETURN);
}'TEMP _ INPUT;
}'SETS(INPUT);
}'WHILE 1 DO;
}*CHAR _ GCI(TEMP//RETURN INPUT);
}*CHAR _ GCI(TEMP) A' 37B IF CHAR = 37B;
}*WCI(CHAR, INPUT);
}'ENDFOR;




}'END;

}'PROGRAM OUTPUT'DATA;

}'INCLUDE GLOBAL'VARIABLES;

}'DECLARE OCTAL CHAR, INTEGER CHARS'LEFT;
}'DECLARE STRING RAW'DATA, DATA(200);



}'UNKNOWN FUNCTION OUTPUT'DATA(LINE, RAW'DATA);
}'WHILE 1 DO;
}*CHAR _ GCI(RAW'DATA//OUTPUT);
}*IF CHAR < 40B DO;
}-WCI(37B, DATA);
}-CHAR _ CHAR V' 40B;
}*ENDIF;
}*WCI(CHAR, DATA);
}'ENDFOR;

OUTPUT:CHARS'LEFT _ 1;
}'WHILE CHARS'LEFT DO;
}*WRITE'STRING(LINE, MOST'POSSIBLE, DATA: DATA, CHARS'LEFT//
}-MISFORTUNE);
}*BLOCK(4B7 RSH CHIO'WATCH//MISFORTUNE) IF CHARS'LEFT;
}'ENDFOR;
}'RETURN;


}'END;

}'PROGRAM ASCII'940;

*}&THIS PROGRAM BLOCK CONTAINS THE FUNCTIONS WHICH TRANSLATE BE-
* TWEEN THE 940 AND ASCII CHARACTER SETS.}"THE FUNCTION TRANS'940'ASCII
* TAKES AS ITS ARGUMENTS, TWO STRINGS, THE FIRST, A STRING IN THE 940
* CHARACTER SET AND THE SECOND, THE STRING TO HOLD THE CORRESPONDING
* STRING THE ASCII'68 CHARACTER SET.}"TRANS'ASCII'940 IS SIMPLY THE IN-
* VERSE OF TRANS'940'ASCII AND WORKS IN THE SAME MANNER.}"BOTH FUNCTIONS
* FAIL IF THE FIRST ARGUMENT, WHEN TRANSLATED, IS TOO LONG TO FIT INTO
* THE SECOND ARGUMENT.

}'INCLUDE ASCII'940'TABLES, ERROR'DEFS;

}'DECLARE CHARACTER
}*CHAR;

}'DECLARE STRING
}*INPUT,}-/* THE STRING TO BE CONVERTED},*/
}*OUTPUT;},/* THE STRING CORRESPONDING TO THE INPUT */
}=/*}#STRING AFTER TRANSLATION},*/



}'STRING FUNCTION TRANS'ASCII'940(INPUT, OUTPUT), FRETURN;

}'SETS(OUTPUT, 0, 0);
}'WHILE 1 DO;
}*CHAR _ GCI(INPUT//RETURN OUTPUT);
}*CHAR _ TRANS'TBL'AS'940[CHAR];
}*WCI(CHAR, OUTPUT//IMPERFECTION);
}'ENDFOR;



}'STRING FUNCTION TRANS'940'ASCII(INPUT, OUTPUT), FRETURN;

}'SETS(OUTPUT, 0, 0);
}'WHILE 1 DO;
}*CHAR _ GCI(INPUT//RETURN OUTPUT);
}*CHAR _ TRANS'TBL'940'AS[CHAR];
}*WCI(CHAR, OUTPUT//IMPERFECTION);
}'ENDFOR;



}'END;

}'PROGRAM CLEAN'OUT'BUFS;

*}&THIS PROGRAM BLOCK CONTAINS THE FUNCTIONSWHICH CLEAN OUT THE
* INPUT/OUTPUT BUFFERS, CLEAN'DATA'BUF, AND CLEAN'CNTRL'BUF.}"THEY
* SIMPLY READ CHARACTERS FROM THE I/O LINE UNTIL THERE AREN'T ANY CHAR-
* ACTERS LEFT.

}'INCLUDE GLOBAL'VARIABLES;

}'DECLARE INTEGER
}*STATE'OF'LINE;}%/* TELLS WHY THE MONITOR CALL TERMINATED */

}'DECLARE STRING
}*PART'OF'BUFFER(21);/* NOT NECESSARILY A "LINE"}.*/



}'UNKNOWN FUNCTION CLEAN'CNTRL'BUF();

}'STATE'OF'LINE$CHARS'FOUND _ 1;
}'WHILE STATE'OF'LINE$CHARS'FOUND DO;
}*SETS(PART'OF'BUFFER, 0, 0);
}*READ'STRING(CNTRL'READ'LINE, MOST'POSSIBLE, DESTRUCTIVELY,
}-PART'OF'BUFFER: PART'OF'BUFFER, STATE'OF'LINE//MISFORTUNE);
}'ENDFOR;
}'STATE'OF'LINE$CHARS'FOUND _ 1;
}'WHILE STATE'OF'LINE$CHARS'FOUND DO;
}*SETS(PART'OF'BUFFER, 0, 0);
}*READ'STRING(CNTRL'WRITE'LINE, MOST'POSSIBLE, DESTRUCTIVELY,
}-PART'OF'BUFFER: PART'OF'BUFFER, STATE'OF'LINE//MISFORTUNE);
}'ENDFOR;
}'RETURN;


}'UNKNOWN FUNCTION CLEAN'DATA'BUF();

}'STATE'OF'LINE$CHARS'FOUND _ 1;
}'WHILE STATE'OF'LINE$CHARS'FOUND DO;
}*SETS(PART'OF'BUFFER, 0, 0);
}*READ'STRING(DATA'READ'LINE, MOST'POSSIBLE, DESTRUCTIVELY,
}-PART'OF'BUFFER: PART'OF'BUFFER, STATE'OF'LINE//MISFORTUNE);
}'ENDFOR;
}'STATE'OF'LINE$CHARS'FOUND _ 1;
}'WHILE STATE'OF'LINE$CHARS'FOUND DO;
}*SETS(PART'OF'BUFFER, 0, 0);
}*READ'STRING(DATA'WRITE'LINE, MOST'POSSIBLE, DESTRUCTIVELY,
}-PART'OF'BUFFER: PART'OF'BUFFER, STATE'OF'LINE//MISFORTUNE);
}'ENDFOR;
}'RETURN;


}'END;

}'PROGRAM OPEN'SEQ'FILE;

*}&THIS FUNCTION OPENS A FILE SPECIFIED BY THE ARGUMENT FILE'NAME
* FOR INPUT OR OUTPUT DEPENDING ON THE SECOND ARGUMENT, IOFLAG.}"THE
* THIRD ARGUMENT, CHAR'LENGTH DETERMINES WHAT THE SIZE OF THE CHAR-
* ACTERS READ FROM OR WRITTEN INTO THE FILE ARE.}"THIS FUNCTION WILL
* FAIL FOR MANY REASONS, SUCH AS IF ANY OF THE SYSTEM CALLS IT USES
* FRETURNS.}"HOWEVER, THE USER CAN CAUSE THE FUNCTION TO FAIL BY PAS-
* SING A BAD FILE NAME, OR BY SPECIFYING AN OBJECT WHICH REALLY ISN'T A
* FILE.}"THIS FUNCTION ALSO FAILS IF THE USER TRIES TO OPEN A FILE WHEN
* HE ALREADY HAS THE MAXIMUM ALLOWABLE NUMBER OF FILES OPEN.

}'INCLUDE GLOBAL'VARIABLES;

}'DECLARE ARRAY
}*FORMATTED'NAME,}$/* M1 FORMATTED NAME}5*/
}*LENGTH'WORD[3];}$/* VALUE OF THE M1 FORMATTED NAME}(*/


}'DECLARE INTEGER
}*ACCESS'SPEC,}'/* ACCESS SPECIFICATION TO THE FILE}&*/
}*CHAR'LENGTH,}'/* LENGTH OF A CHARACTER IN BITS})*/
}*FILE'LENGTH,}'/* LENGTH OF FILE IN CHARACTERS}**/
}*FILE'NUMBER,}'/* TSS FILE NUMBER}7*/
}*FILE'TYPE,})/* TYPE OF FILE: SYMBOLIC, BINARY, ETC.}"*/
}*IOFLAG,},/* OPERATION TO BE PERFORMED ON THE FILE */
}=/*}#(0 - RETRIEVE, 1 - STORE)}+*/
}*GARBAGE,}+/* UNNECESSARY RETURNED VALUES}+*/
}*LAST'PAGE,})/* LAST PAGE OF THE FILE}1*/
}*LAST'WORD,})/* LAST WORD OF THE LAST PAGE OF THE FILE*/
}*OBJECT'TYPE,}'/* TYPE OF FILE}:*/
}=/*}"(0 - SMALL FILE, 1 - LARGE FILE)}%*/
}*PAGE'NUMBER,}'/* PAGE NUMBER OF THE FILE}/*/
}*SEQ'FILE'NUM;}&/* NUMBER OF SEQUENTIAL FILES OPEN}'*/

}'DECLARE POINTER
}*FILE;}./* A POINTER TO THE FILE WINDOW}**/

}'DECLARE STRING
}*NULL'STRING,}'/* JUST A NULL STRING}4*/
}*FILE'NAME;})/* FILE THE USER WANTS TO OPEN}+*/
}*



}'FUNCTION OPEN'SEQ'FILE(FILE'NAME, IOFLAG, FILE'TYPE, CHAR'LENGTH),
}*FRETURN;

* CAN THE USER OPEN A FILE?
}'FOR SEQ'FILE'NUM _ 0 TO NUM'SEQ'FILES - 1 DO;
}*GOTO SET IF NOT SEQ'FILE'TABLE[SEQ'FILE'NUM]$WINDOW'IN'USE;
}'ENDFOR;
}'IMPERFECTION;

* SET UP A POINTER TO THE FILE'S WINDOW DESCRIPTOR
SET:}#FILE _ @SEQ'FILE'TABLE[SEQ'FILE'NUM];

* SET UP AN ARRAY DESCRIPTOR
}'FORMATTED'NAME _ CONS'ARRAY'DESC(@(FILE.NAME'STORAGE), 8, 1, 0 //
}*FRETURN);

* GET THE M1 FORMATTED NAME FROM THE FILE NAME TYPED IN BY THE USER
}'NAME'SEARCH(FILE'NAME, FORMATTED'NAME, IOFLAG, FILE'TYPE, -1//
}-MISFORTUNE);

* MAY HAVE TO BE CHANGED FOR THE APPEND
}'ACCESS'SPEC _ ('WU' IF IOFLAG ELSE 'RU');

* IS THE FILE NEW (FORMATTED'NAME[2] = -1)?
}'IF FORMATTED'NAME[2] = -1 DO;
}*FILE'NUMBER _ OPEN'FILE(-1, FORMATTED'NAME, ACCESS'SPEC, -1//
}-MISFORTUNE);
}*FILE'LENGTH _ 0;
}*OBJECT'TYPE _ SMALL'FILE;

}'ELSE DO;
*}'THE FILE ALREADY EXISTS.}"DO THIS TO BE SAFE, THE OLD NAME MAY
* NOT HAVE BEEN A MONITOR FORMATTED NAME.
}*CONV'NAME(FORMATTED'NAME, FORMATTED'NAME, -1:
}-GARBAGE, OBJECT'TYPE, GARBAGE//MISFORTUNE);
}*IF (OBJECT'TYPE = SMALL'FILE) OR (OBJECT'TYPE = LARGE'FILE) DO;
}-READ'MIBOB'VALUE(FORMATTED'NAME, 1, LENGTH'WORD, 2, -1//
}0MISFORTUNE);
}-FILE'NUMBER _ OPEN'FILE(-1, FORMATTED'NAME, ACCESS'SPEC, -1//
}0MISFORTUNE);
}-LAST'PAGE _ LENGTH'WORD[2]$PAGES'IN'FILE - 1;
}-LAST'WORD _ LENGTH'WORD[2]$WORDS'IN'PAGE + 1;
}-FILE'LENGTH _ (0 IF NEXT'FILE'PAGE(FILE'NUMBER, -1//
}0SYSTEM'ERROR() & GOTO ABORT: ERROR'CODE, ERROR'NUMBER) = -1
}0ELSE (24/CHAR'LENGTH)*((2048*LAST'PAGE) + LAST'WORD));

}-IF FILE'LENGTH AND IOFLAG = WRITE'FILE DO;
}0DEL'SEQ'FILE(FILE'NUMBER//ABORT);
}0FILE'LENGTH _ 0;
}-ENDIF;
}*ELSE DO;
}-FRETURN;

}*ENDIF;

}'ENDIF;

* FILL UP THE WINDOW
}'FILE.PAGE'IN'WINDOW _ -1;
}'FILE.PMT'INDEX _ ACQUIRE'PMT(-1//SYSTEM'ERROR() &
}*GOTO ABORT: ERROR'CODE, ERROR'NUMBER);
}'FILE.WINDOW'IN'USE _ 1;
}'FILE.LARGE'OR'SMALL _ (0 IF OBJECT'TYPE = SMALL'FILE ELSE 1);
}'FILE.OPERATION _ IOFLAG;
}'FILE.FILE'NUM _ FILE'NUMBER;
}'FILE.WINDOW'ADDRESS _ SEQ'FILE'WINDOWS[SEQ'FILE'NUM];
}'FILE.CHARACTER'SIZE _ CHAR'LENGTH;
}'FILE.CHARS'PER'WORD _ 24/CHAR'LENGTH;
}'FILE.CHARS'PER'PAGE _ 4000B*24/CHAR'LENGTH;
}'FILE.CHARS'LEFT _ FILE'LENGTH;
}'FILE.LENGTH'IN'CHARS _ FILE'LENGTH;

}'SET'MAP'BYTE(THIS'SUB'PROCESS, FILE.WINDOW'ADDRESS$PAGE'NUM'ADDR,
}*FILE.PMT'INDEX//SYSTEM'ERROR() & GOTO ABORT:
}*ERROR'CODE, ERROR'NUMBER);

*}&THIS IS RIDICULOUS.}"THE STATEMENT SHOULD BE 
*})SETUP(NULL'STRING, 0, FILE.WINDOW'ADDRESS, CHAR'LENGTH);
* EXCEPT THAT SPL WON'T TAKE A VARIABLE CHARACTER LENGTH.
* (THERE ARE SIMILAR STATEMENTS IN MAP'IN'NEXT'PAGE AND CREATE'PAGE)
}'SETUP'KLUDGE(NULL'STRING, 0, FILE.WINDOW'ADDRESS,
}*FILE.CHARACTER'SIZE//ABORT);
}'FILE.READ'DESC _ NULL'STRING;
}'FILE.WRITE'DESC _ (PREPARE'APPEND(FILE, LAST'PAGE//ABORT) IF
}*IOFLAG = APPEND'FILE ELSE NULL'STRING);
}'OPEN'FILE'TABLE[FILE'NUMBER] _ SEQ'FILE'NUM;
}'RETURN FILE'NUMBER;

* SOMETHING WENT WRONG, SO RESET THINGS
ABORT: FILE.WINDOW'IN'USE _ 0;
}'CLOSE'SEQ'FILE(FILE'NUMBER//FRETURN);
}'FRETURN;



}'END;

}'PROGRAM DEL'SEQ'FILE;

*}&THIS FUNCTION DELETES ALL THE PAGES OF AN EXISTING FILE WHICH HAS
* BEEN OPENED FOR OUTPUT.}"THE FUNCTION FAILS ONLY IF ONE OF THE MONITOR
* CALLS IT USES FAILS.}"THE NAME OF THIS FUNCTION ISN'T EXACTLY AC-
* CURATE, BECAUSE IT ACTUALLY ONLY DELETES THE EXISTING PAGES OF THE
* FILE BUT DEL'FILE'PAGES IS EASILY CONFUSED WITH DEL'FILE'PAGE.

}'INCLUDE GLOBAL'VARIABLES;

}'DECLARE INTEGER
}*FILE'NUMBER,}'/* TSS FILE NUMBER}7*/
}*PAGE'NUMBER;}'/* PAGE (MEMORY PAGE) NUMBER OF THE FILE */



}'FUNCTION DEL'SEQ'FILE(FILE'NUMBER), FRETURN;

}'PAGE'NUMBER _ 0;
}'WHILE PAGE'NUMBER # -1 DO;
}*DEL'FILE'PAGE(FILE'NUMBER, PAGE'NUMBER//
}-MISFORTUNE);
}*PAGE'NUMBER _ NEXT'FILE'PAGE(FILE'NUMBER, PAGE'NUMBER//
}-MISFORTUNE);
}'ENDFOR;
}'SET'FILE'LENGTH(FILE'NUMBER, 0//MISFORTUNE);

}'RETURN;


}'END;

}'PROGRAM OUTPUT'SEQ'FILE;

*}&THIS FUNCTION APPENDS THE STRING SPECIFIED BY ITS SECOND ARGUMENT
* TO THE FILE SPECIFIED BY THE SECOND ARGUMENT.}"THE FIRST TIME THIS 
* FUNCTION IS CALLED AFTER OPENING THE FILE, ONE OF THE WCI'S WILL FAIL
* BECAUSE FILE.WRITE'DESC WAS SETUP WITH A LENGTH OF ZERO.}"CREATE'NEW'-
* PAGE IS THEN CALLED TO CREATE ANOTHER FILE PAGE.}"IT IS EXPECTED THAT
* INPUT'LINE WILL BE A STRING IN THE 940 CHARACTER SET, SO THAT THE
* STRING CAN SIMPLY BE WRITTEN INTO THE FILE.}"THIS FUNCTION FAILS ONLY
* IF CREATE'NEW'PAGE FAILS.

}'INCLUDE GLOBAL'VARIABLES;

}'DECLARE INTEGER
}*CHAR,}./* A CHARACTER TO BE WRITTEN INTO A FILE */
}*FILE'NUMBER;}'/* THE NUMBER OF THE FILE}0*/

}'DECLARE POINTER
}*FILE;}./* A POINTER TO THE FILE WINDOW}**/

}'DECLARE STRING
}*INPUT'LINE,}(/* THE STRING FROM WHICH CHARACTERS ARE}"*/
}=/*}#WRITTEN INTO THE FILE}/*/
}*OUTPUT'DUMMY;}&/* A WORKING STRING}6*/



}'FUNCTION OUTPUT'SEQ'FILE(FILE'NUMBER, INPUT'LINE), FRETURN;

}'FILE _ @SEQ'FILE'TABLE[OPEN'FILE'TABLE[FILE'NUMBER]];
}'OUTPUT'DUMMY _ FILE.WRITE'DESC;
}'WHILE 1 DO;
}*CHAR _ GCI(INPUT'LINE//
}-FILE.WRITE'DESC _ OUTPUT'DUMMY & RETURN);
WRITE'CHAR:
}*WCI(CHAR, OUTPUT'DUMMY//OUTPUT'DUMMY _
}0CREATE'NEW'PAGE(FILE//FRETURN) & GOTO WRITE'CHAR);
}'ENDFOR;



}'END;

}'PROGRAM CREATE'NEW'PAGE;

*}&THIS FUNCTION CREATES A NEW FILE PAGE SO THAT MORE CHARACTERS CAN
* BE WRITTEN OUT TO THE FILE.}"IT RESETS THE STRING OUTPUT'DUMMY SO MORE
* CHARACTERS CAN BE WRITTEN INTO IT AND OVERLAYS THE STRING ON THE PAGE
* IT HAS JUST CREATED.}"THE LENGTH OF THE FILE KEPT IN THE WINDOW IS
* INCREMENTED BY A PAGE WORTH OF CHARACTERS.}"IF THE PAGE ISN'T FILLED,
* CLOSE'SEQ'FILE SETS THE EXACT LENGTH WHEN IT TRIES TO CLOSE THE FILE.
* THIS FUNCTION FAILS IF ANY OF THE MONITOR CALLS IT USES FAILS.

}'INCLUDE GLOBAL'VARIABLES;

}'DECLARE POINTER
}*FILE;}./* A POINTER TO THE FILE WINDOW}**/

}'DECLARE STRING
}*OUTPUT'DUMMY;}&/* THE STRING THAT THE CHARACTERS WILL}#*/
}=/*}#BE WRITTEN INTO}5*/



}'STRING FUNCTION CREATE'NEW'PAGE(FILE), FRETURN;

* IS THE FILE REALLY OPEN?}"IS IT OPEN FOR OUTPUT?
}'IMPERFECTION IF NOT FILE.WINDOW'IN'USE OR NOT FILE.OPERATION;

* DO THINGS TO MAP IN A NEW PAGE INTO THE WINDOW
}'FILE.PAGE'IN'WINDOW _ FILE.PAGE'IN'WINDOW + 1;
}'CREATE'FILE'PAGE(FILE.FILE'NUM, FILE.PAGE'IN'WINDOW//
}*MISFORTUNE);
}'CLEAR'PMT(FILE.PMT'INDEX//MISFORTUNE);
}'MOVE'PAGE'PMT(FILE.FILE'NUM, FILE.PAGE'IN'WINDOW, FILE.PMT'INDEX//
}*MISFORTUNE);
}'SETUP'KLUDGE(OUTPUT'DUMMY, FILE.CHARS'PER'PAGE,
}*FILE.WINDOW'ADDRESS, FILE.CHARACTER'SIZE//FRETURN);

}'FILE.LENGTH'IN'CHARS _ FILE.PAGE'IN'WINDOW*FILE.CHARS'PER'PAGE;
}'RETURN OUTPUT'DUMMY;



}'END;

}'PROGRAM PREPARE'APPEND;

*}&THIS FUNCTION IS A SPECIAL CASE OF MAP'IN'NEXT'PAGE WHERE THE
* PAGE WHICH WILL BE MAPPED INTO THE WINDOW IS THE LAST PAGE OF THE FILE.

}'INCLUDE GLOBAL'VARIABLES;

}'DECLARE INTEGER
}*LAST'PAGE;})/* THE LAST PAGE OF THE FILE}-*/

}'DECLARE POINTER
}*FILE;}./* A POINTER TO THE FILE WINDOW}**/

}'DECLARE STRING
}*APPEND'DESC;}'/* THE STRING DESCRIPTOR SET UP SO THAT}"*/
}=/*}#THE FILE CAN HAVE MORE CHARACTERS}#*/
}=/*}#APPENDED TO IT}6*/




}'STRING FUNCTION PREPARE'APPEND(FILE, LAST'PAGE), FRETURN;

* IS THE FILE REALLY OPEN?}"IS IT OPEN FOR OUTPUT?
}'IMPERFECTION IF NOT FILE.WINDOW'IN'USE OR
}*FILE.OPERATION # APPEND'FILE;

* DO THINGS TO MAP IN A NEW PAGE INTO THE WINDOW
}'FILE.PAGE'IN'WINDOW _ LAST'PAGE;
}'CLEAR'PMT(FILE.PMT'INDEX//MISFORTUNE);
}'MOVE'PAGE'PMT(FILE.FILE'NUM, FILE.PAGE'IN'WINDOW, FILE.PMT'INDEX//
}*MISFORTUNE);
*}&CHANGE THE CHARACTER COUNT SO DET'END'OF'FILE DOESN'T CREATE A
* STRING OVER A PAGE LONG.
}'FILE.CHARS'LEFT _ FILE.CHARS'LEFT - FILE.CHARS'PER'PAGE*LAST'PAGE;
}'APPEND'DESC _ DET'END'OF'FILE(FILE//FRETURN);
*}&MOVE THE END POINTER OF THE STRING SO THAT THE STRING IS A WHOLE
* PAGE LONG.
}'APPEND'DESC$EP _ INCDES(APPEND'DESC$BP, FILE.CHARS'PER'PAGE);
}'FILE.LENGTH'IN'CHARS _ FILE.CHARS'PER'PAGE*(FILE.PAGE'IN'WINDOW);

}'RETURN APPEND'DESC;



}'END;

}'PROGRAM DET'END'OF'FILE;

*}&THIS FUNCTION DETERMINES WHERE THE LAST ACTUAL CHARACTER OF THE
* FILE IS.}"THE MONITOR KNOWS THE LENGTH OF THE FILE IN WORDS.}"THE
* REASON THINGS ARE SO INEXACT IS BECAUSE ON ONE KNEW HOW MANY EOF'S OLD
* SPL WROTE INTO FILES.}"THIS FUNCTION WILL SET THE WRITE POINTER OF
* THE STRING TO THE RIGHT PLACE IF THE FIRST EOF IS ANYWHERE IN THE LAST
* WORD OR EVEN IF THERE IS NO EOF WRITTEN.}"THE FUNCTION RETURNS A
* STRING DESCRIPTOR SETUP TO READ HOWEVER MANY CHARACTERS ARE LEFT IN
* THE FILE.

}'INCLUDE GLOBAL'VARIABLES;

}'DECLARE INTEGER
}*CHAR,}./* A CHARACTER READ FROM THE STRING}&*/
}*COUNT;}-/* JUST A COUNTER FOR A FOR LOOP}(*/

}'DECLARE PARAMETER
}*CHARS'TO'CHECK _ 3;/* THE SPAN OF CHARACTERS CHECKED WHILE}"*/
}=/*}#LOOKING FOR THE EOF CHARACTER}'*/

}'DECLARE POINTER
}*FILE;}./* A POINTER TO THE WINDOW IN USE}(*/

}'DECLARE STRING
}*LAST'FILE'PAGE;}$/* THE STRING WHICH OVERLAYS THE WORDS}#*/
}=/*}#OF THE FILE}9*/



}'STRING FUNCTION DET'END'OF'FILE(FILE), FRETURN;

}'SETUP'KLUDGE(LAST'FILE'PAGE, FILE.CHARS'LEFT,
}*FILE.WINDOW'ADDRESS, FILE.CHARACTER'SIZE//FRETURN);
}'LAST'FILE'PAGE$WP _ LAST'FILE'PAGE$EP;
}'LAST'FILE'PAGE$RP _ INCDES(LAST'FILE'PAGE$EP, -CHARS'TO'CHECK);

}'FOR COUNT _ 1 TO CHARS'TO'CHECK DO;
}*GOTO END'OF'FILE IF (CHAR _ GCI(LAST'FILE'PAGE) A' 177B = EOF);
}'ENDFOR;
END'OF'FILE:
}'LAST'FILE'PAGE$WP _ INCDES(LAST'FILE'PAGE$RP, -1) IF CHAR = EOF;
}'SETR(LAST'FILE'PAGE, 0);
}'FILE.CHARS'LEFT _ 0;

}'RETURN LAST'FILE'PAGE;


}'END;

}'PROGRAM CLOSE'SEQ'FILE;

*}&THIS FUNCTION CLOSES THE FILE SPECIFIED BY ITS ONLY ARGUMENT.
* IT IS CALLED TO CLOSE BOTH FILES WHICH WERE OPENED FOR INPUT AND OUT-
* PUT.}"HOWEVER, FOR FILES WHICH HAVE BEEN OPENED FOR OUTPUT, IT MUST
* DETERMINE THE EXACT LENGTH OF THE FILE AND LET THE MONITOR KNOW ABOUT
* IT.}"THE FUNCTION FAILS ONLY FOR INTERNAL REASONS: THE FILE IS ALREADY
* CLOSED, OR ONE OF THE MONITOR CALLS IT USES FAILS.

}'INCLUDE GLOBAL'VARIABLES;

}'DECLARE INTEGER
}*FILE'NUMBER,
}*LENGTH'IN'WORDS;}#/* LENGTH OF THE FILE IN WORDS}+*/

}'DECLARE POINTER
}*FILE;}./* A POINTER TO THE FILE WINDOW}**/



}'UNKNOWN FUNCTION CLOSE'SEQ'FILE(FILE'NUMBER), FRETURN;

}'FILE _ @SEQ'FILE'TABLE[OPEN'FILE'TABLE[FILE'NUMBER]];
* CHECK TO SEE IF WHAT IT IS GOING TO BE CLOSED ALREADY IS
}'IMPERFECTION IF NOT FILE.WINDOW'IN'USE;
}'IF FILE.OPERATION DO;
}*OUT'CHAR'FILE(FILE'NUMBER, EOF//FRETURN);
}*LENGTH'IN'WORDS _
}-(LENGTH(FILE.WRITE'DESC)*(FILE.CHARACTER'SIZE) + 23)/24;
}*SET'FILE'LENGTH(FILE'NUMBER, LENGTH'IN'WORDS -1//
}-MISFORTUNE);
}'ENDIF;

* FREE THE WINDOW
}'CLOSE'FILE(FILE'NUMBER//MISFORTUNE);
}'FILE.WINDOW'IN'USE _ 0;
}'OPEN'FILE'TABLE[FILE'NUMBER] _ -1;
}'DELETE'PMT(FILE.PMT'INDEX//MISFORTUNE);

}'RETURN;



}'END;

}'PROGRAM OUTPUT'TO'FILE;

*}&THIS PROGRAM BLOCK CONTAINS FUNCTIONS USED TO OUTPUT CHARACTERS,
* WORDS, AND NUMBERS TO FILES.

}'DECLARE INTEGER
}*BASE,}./* THE BASE OF THE NUMBER TO OUTPUT}&*/
}*CHAR,}./* THE CHARACTER TO OUTPUT}/*/
}*FILE'NUMBER,}'/* THE NUMBER OF THE FILE}0*/
}*NUMBER,},/* THE NUMBER TO OUTPUT}2*/
}*SIGN'NUM'CHARS,}$/* DETERMINES THE NUMBER OF DIGITS TO}$*/
}=/*}#CONVERT THE NUMBER TO AND WHETHER}#*/
}=/*}#IT}"WILL BE SIGNED}2*/
}*WORD;}./* THE WORD TO OUTPUT}4*/

}'DECLARE STRING
}*CHAR'REPRES}(/* THE CHARACTER REPRESENTATION OF THE}#*/
}-(100),}*/*}#NUMBER TO BE OUTPUT AFTER CONVERSION*/
}*OUTPUT;},/* THE STRING TO OUTPUT}2*/



}'UNKNOWN FUNCTION OUT'CHAR'FILE(FILE'NUMBER, CHAR), FRETURN;

}'IF FILE'NUMBER = -1 DO;
}*OUT'CHAR'TTY(CHAR//FRETURN);
}*RETURN;
}'ENDIF;
}'SETUP(OUTPUT, 3, @CHAR);
}'SETS(OUTPUT, 2, 3);
}'OUTPUT'SEQ'FILE(FILE'NUMBER, OUTPUT//FRETURN);
}'RETURN;



}'UNKNOWN FUNCTION OUT'WORD'FILE(FILE'NUMBER, WORD), FRETURN;

}'IF FILE'NUMBER = -1 DO;
}*OUT'WORD'TTY(WORD//FRETURN);
}*RETURN;
}'ENDIF;
}'SETUP(OUTPUT, 3, @WORD);
}'OUTPUT'SEQ'FILE(FILE'NUMBER, OUTPUT//FRETURN);
}'RETURN;

}'UNKNOWN FUNCTION OUT'NUMBER'FILE(FILE'NUMBER, NUMBER,
}*SIGN'NUM'CHARS, BASE), FRETURN;

}'IF FILE'NUMBER = -1 DO;
}*OUT'NUMBER'TTY(NUMBER, SIGN'NUM'CHARS, BASE//FRETURN);
}*RETURN;
}'ENDIF;
}'CNS(NUMBER, CHAR'REPRES, SIGN'NUM'CHARS, BASE//FRETURN);
}'OUTPUT'SEQ'FILE(FILE'NUMBER, CHAR'REPRES//FRETURN);
}'RETURN;



}'UNKNOWN FUNCTION OUT'CHAR'TTY(CHAR), FRETURN;
}'SETUP(OUTPUT, 3, @CHAR);
}'SETS(OUTPUT, 2, 3);
}'OUTPUT'STRING(OUTPUT);
}'RETURN;



}'UNKNOWN FUNCTION OUT'WORD'TTY(WORD), FRETURN;
}'SETUP(OUTPUT, 3, @WORD);
}'OUTPUT'STRING(OUTPUT);
}'RETURN;



}'UNKNOWN FUNCTION OUT'NUMBER'TTY(NUMBER, SIGN'NUM'CHARS, BASE),
}*FRETURN;
}'CNS(NUMBER, CHAR'REPRES, SIGN'NUM'CHARS, BASE//FRETURN);
}'OUTPUT'STRING(CHAR'REPRES);
}'RETURN;


}'END;

}'PROGRAM TERMINAL'IO;

*}&THIS PROGRAM BLOCK CONTAINS THE TERMINAL INPUT AND OUTPUT
* FUNCTIONS.}"THESE FUNCTIONS DON'T HAVE FRETURNS, BUT CALL THE FUNCTION
* SYSTEM'ERROR WHICH WILL RETURN IMMEDIATELY IF THE FLAG DEBUGGING ISN'T
* SET, WHICH MAY TOTALLY SCREW THINGS UP.}"HOWEVER, ALL CALLS TO THESE
* FUNCTION ARE MADE ONLY IF DEBUGGER HAS BEEN SET.

}'INCLUDE GLOBAL'VARIABLES;

}'DECLARE CHARACTER
}*CHAR;}./* THE CHARACTER TO INPUT OR OUTPUT}&*/

}'DECLARE STRING
}*INPUT,}-/* THE STRING READ IN FROM THE TERMINAL}"*/
}*OUTPUT;},/* THE STRING TO OUTPUT TO THE TERMINAL}"*/




* IF THE FUNCTION FAILS, THE CHARACTER RETURNED WILL BE A BLANK
}'CHARACTER FUNCTION INPUT'CHARACTER();
}'CHAR _ READ'CHAR(-1, 0//
}*SYSTEM'ERROR() & 0: ERROR'CODE, ERROR'NUMBER);
}'RETURN CHAR;


}'UNKNOWN FUNCTION OUTPUT'CHARACTER(CHAR);
}'PRINT'CHAR(-1, CHAR, 0//
}*SYSTEM'ERROR(): CHAR, ERROR'CODE, ERROR'NUMBER);
}'START'OUTPUT(-1, 0//SYSTEM'ERROR(): ERROR'CODE, ERROR'NUMBER);
}'RETURN;



*}&IF THE FUNCTIONS FAILS, THE STRING RETURNED WILL BE WHATEVER
* WAS IN INPUT AT THAT POINT
}'STRING FUNCTION INPUT'STRING(INPUT);
}'INPUT _ READ'LINE(-1, INPUT, "", 0//
}*SYSTEM'ERROR() & INPUT: INPUT, ERROR'CODE, ERROR'NUMBER);
}'RETURN INPUT;


}'UNKNOWN FUNCTION OUTPUT'STRING(OUTPUT);
}'PRINT'STRING(-1, OUTPUT, 0//
}*SYSTEM'ERROR(): OUTPUT, ERROR'CODE, ERROR'NUMBER);
}'RETURN;


}'END;

}'PROGRAM FAILURES;

*}&THIS PROGRAM BLOCK CONTAINS THE FUNCTIONS CALLED WHEN SOMETHING
* GOES WRONG

}'INCLUDE GLOBAL'VARIABLES;

}'DECLARE INTEGER
}*ERROR'ADDR = L'[0];/* ADDRESS OF CALLING STATEMENT}**/
}=/*}#(WHERE FAILURE OCCURRED)},*/

}'DECLARE STRING
}*EXPLANATION;}'/* JUST A STRING USED TO WRITE INTO}&*/



*}&RUNTIME FAILURE IS CALLED WHEN THE PROGRAM ARRIVES SOMEWHERE IT
* ISN'T SUPPOSED TO, USUALLY CAUSED BY SEVERAL UNFORTUNATE CIRCUMSTANCES
* (SUCH AS TRYING TO CLOSE A FILE THAT'S ALREADY CLOSED OR TRYING TO
* TO WRITE MORE CHARACTERS INTO A STRING THAN WILL FIT)
}'UNKNOWN FUNCTION RUNTIME'FAILURE();
}'FOR'OUTPUT'TTY ("&/RUNTIME FAILURE AT P = #B");
}'OUTPUT'NUMBER (ERROR'ADDR);
}'OUTPUT'STRING("&/");
}'EXIT();


* SYSTEM'ERROR IS CALLED WHEN A MONITOR OR UTILITY CALL HAS FAILED
}'UNKNOWN FUNCTION SYSTEM'ERROR();
}'OUTPUT'STRING("&/SYSTEM CALL FAILED: CODE = ");
}'SETUP (EXPLANATION, 3, @ERROR'CODE);
}'SETS (EXPLANATION, 0, 3);
}'OUTPUT'STRING(EXPLANATION);
}'FOR'OUTPUT'TTY (", NUMBER = *");
}'OUTPUT'NUMBER (ERROR'NUMBER);
}'FOR'OUTPUT'TTY (" AT P = #B");
}'OUTPUT'NUMBER (ERROR'ADDR);
}'OUTPUT'STRING("&/");
}'EXIT();


*}&FATAL'ERROR IS CALLED WHEN AN ERROR OCCURS THAT WILL ALWAYS OCCUR
* EVEN IF RERUN (SUCH AS COMPARING THE LENGTH OF TWO STRINGS WITH DIF-
* FERENT CHARACTER SIZES)
}'UNKNOWN FUNCTION FATAL'ERROR();
}'FOR'OUTPUT'TTY ("&/FATAL ERROR AT P = #B");
}'OUTPUT'NUMBER (ERROR'ADDR);
}'OUTPUT'STRING("&/");
}'EXIT();

}'END;

}'PROGRAM FORMATTED'OUTPUT;

*}&THIS PROGRAM BLOCK CONTAINS THE FUNCTIONS WHICH FORMAT OUTPUT
* THE FUNCTIONS FOR'OUTPUT'FILE AND OUTPUT'NUMBER WORK AS COUROUTINES
* FOR'OUTPUT'TTY IS JUST A SPECIAL CASE OF FOR'OUTPUT'FILE.
*}&FORMATTED'OUTPUT CONVERTS THE NUMBER TO A STRING AND OUTPUTS
* THEM TO A FILE, OR THE TELETYPE.

}'INCLUDE GLOBAL'VARIABLES;

}'DECLARE INTEGER
}*BASE,}./* THE BASE THE NUMBER IS IN}-*/
}*CHAR,}./* A CHARACTER READ FROM A STRING}(*/
}*FILE'NUMBER,}'/* THE NUMBER OF THE FILE}0*/
}*NUMBER,},/* THE NUMBER WHICH MUST BE OUTPUT}'*/
}*SIGN'UNSIGN;}'/* NUMBER DETERMINING WHETHER THE NUMBER */
}=/*}#WILL BE SIGNED OR UNSIGNED}**/

}'DECLARE STRING
}*OUTPUT;},/* THE STRING TO BE OUTPUT}/*/



}'UNKNOWN FUNCTION FOR'OUTPUT'FILE(OUTPUT, FILE'NUMBER);

}'ERROR'FILE'NUM _ FILE'NUMBER;
FOF0:}"SCOPY(ERROR'STRING, OUTPUT//EXIT());

}'WHILE 1 DO;
}*CHAR _ GCI(ERROR'STRING//RETURN);
}*IF CHAR = '&'' DO;
}-OUT'CHAR'FILE(ERROR'FILE'NUM, GCI(ERROR'STRING//EXIT())//
}0EXIT());
}*ELSEIF CHAR = '/' DO;
}-OUTPUT'SEQ'FILE(ERROR'FILE'NUM, M1'NL//EXIT());
}*ELSEIF CHAR = '#' DO;
}-ERROR'RADIX _ 8;
}-RETURN;})/* COROUTINE RETURN}6*/
}*ELSEIF CHAR = '*' DO;
}-ERROR'RADIX _ 10;
}-RETURN;})/* COROUTINE RETURN}6*/

* CHAR IS NOT UNDEFINED BECAUSE THE ONLY WAY TO GET HERE IS BY ENTERING
*}#THROUGH OUTPUT'NUMBER
FOF1:}%OUT'NUMBER'FILE(ERROR'FILE'NUM, NUMBER,
}-4B7 IF NUMBER < -4B4 ELSE 0, ERROR'RADIX//EXIT());

}*ELSEIF CHAR < 100B DO;
}-OUT'CHAR'FILE(ERROR'FILE'NUM, CHAR//EXIT());
}*ENDIF;
}'ENDFOR;

}'UNKNOWN FUNCTION FOR'OUTPUT'TTY(OUTPUT);
}'ERROR'FILE'NUM _ -1;
}'GOTO FOF0;


}'UNKNOWN FUNCTION OUTPUT'NUMBER(NUMBER);
}'GOTO FOF1;



}'END;

}'PROGRAM SP'TRAP'HANDLER;

*}&THIS PROGRAM WILL EVENTUALLY HANDLE MORE SP'TRAPS, BUT NOW IT
* JUST HANDLES QUITS(CONTROL-K), AND TYPES OUT ERROR MESSAGES FOR THE REST

}'INCLUDE GLOBAL'VARIABLES, ENTRY'DEFS;

}'DECLARE ARRAY
}*CALLER'STATE[5];}#/* A SPCS ENTRY}:*/


}'DECLARE INTEGER
}*QUIT _ 23,})/* TRAP GENERATED BY TYPING A CONTROL-K}"*/
}*CUR'STACK'LEVEL,}#/* CURRENT STACK LEVEL}3*/
}*SP'TRAP'NO,}(/* THE NUMBER OF THE SUB-PROCESS TRAP}$*/
}=/*}#GENERATED, THE TRAP NUMBER CORRES-}"*/
}=/*}#PONDS TO THE BIT POSITION IN THE}$*/
}=/*}#TM OF THE SPT WHICH IDENTIFYS IT}$*/
}*SP'TRAP'PARAM,}%/* THE PARAMETER PASSED WHEN THE SP'TRAP */
}=/*}#IS GENERATED, IT IS USUALLY THE AD- */
}=/*}#DRESS OF THE GUILTY STATEMENT}'*/
}*TM'BITS'SET;




}'FUNCTION SP'TRAP'HANDLER(SP'TRAP'NO, SP'TRAP'PARAM);

* REARM QUIT TRAPS
}'TM'BITS'SET _ READ'SPT'FIELD(THIS'SUB'PROCESS, 'TM'//
}*SYSTEM'ERROR(): ERROR'CODE, ERROR'NUMBER);
}'SET'SPT'FIELD(THIS'SUB'PROCESS, 'TM', (TM'BITS'SET V' 1B)//
}*SYSTEM'ERROR(): ERROR'CODE, ERROR'NUMBER);

}'STATE[L'INDEX] _ CALLER'STATE[0]$LR;
}'STATE[G'INDEX] _ CALLER'STATE[0]$GR;

* TAKE CARE OF QUITS
}'IF SP'TRAP'NO = QUIT DO;
}*STATE[0] _ @EXIT'QUIT;
}*.EAX STATE[0], .LOADS;
EXIT'QUIT:SP'RETURN(//SYSTEM'ERROR(): ERROR'CODE, ERROR'NUMBER);
}'ELSE DO;
*}&MAY HAVE TO DO FANCIER THINGS, SUCH AS READING THE SPCS ENTRY
* OF THE CALLER INTO CALLER'STATE
}*FOR'OUTPUT'TTY("&/SUB-PROCESS TRAP NUMBER #B, AT #B");
}*OUTPUT'NUMBER(SP'TRAP'NO);
}*OUTPUT'NUMBER(SP'TRAP'PARAM);
}*CUR'STACK'LEVEL _ READ'SPS'PARAM('CSL'//
}-SYSTEM'ERROR(): ERROR'CODE, ERROR'NUMBER);
}*JUMP'RETURN(CUR'STACK'LEVEL - INIT'STACK'LEVEL//
}-SYSTEM'ERROR(): ERROR'CODE, ERROR'NUMBER);
}'ENDIF;


}'END;

}'PROGRAM EXIT;

* THIS PROGRAM PERFORMS THE RETURN TO THE EXECUTIVE

}'INCLUDE GLOBAL'VARIABLES;

}'DECLARE STRING
}*LINE;



}'UNKNOWN FUNCTION EXIT'KLUDGE(LINE);


}'UNKNOWN FUNCTION EXIT();
}'SP'RETURN(// VALUE HALT(): ERROR'CODE, ERROR'NUMBER);

}'UNKNOWN FUNCTION HALT();
}'.HLT 0;





}'END;


}(COMMON ENTRY'DEFS;

*}&THIS COMMON BLOCK CONTAINS THE VARIABLES NECESSARY FOR THE
* PROGRAM BLOCK ENTRIES, SUCH THINGS AS THE SIZE OF THE STACK, THE
* STACK BOUNDS, STACK POINTER, AND STACK LIMIT.

})DECLARE PARAMETER
})STACK'SIZE _ 3000B;

})DECLARE ARRAY
})STACK[STACK'SIZE];

})DECLARE ARRAY
})STATE[10];})/* THE SAVED STATE KEPT BY THE MONITOR}#*/

})DECLARE PARAMETER
})STACK'POINTER = G' [2],
})STACK'LIMIT = G' [3],
})INITIAL'SP _ @STACK[0],
})INITIAL'SL _ @STACK[STACK'SIZE - 1];

})DECLARE PARAMETER /* INDEXES INTO STATE}4*/
})P'INDEX _ 0,}'/* PROGRAM COUNTER}7*/
})L'INDEX _ 7,}'/* LOCAL REGISTER}8*/
})G'INDEX _ 8;}'/* GLOBAL REGISTER}7*/

})DECLARE FIELD /* FOR A SPCS ENTRY}6*/
})PC (0:6,23),}'/* THE SAVED P-COUNTER}3*/
})LR (1:6,23),}'/* THE SAVED L-REGISTER}2*/
})GR (2:6,23);}'/* THE SAVED G-REGISTER}2*/

})MACRO SAVE'STATE (CURRENT'STATE) _ .STX CURRENT'STATE[6],
}).EAX CURRENT'STATE[0], .STORS;



})END;

}(COMMON MONITOR'CALLS;


******************************
*
* CALLS TO MANIPULATE MULTI-INDEX BLOCKS (MIBS) AND SUB-INDEX BLOCKS (SIBS)
*
******************************

})INTEGER MONITOR CREATE'MIB _ 190;
}(UNKNOWN MONITOR READ'MIBOB'INDEX _ 0;}%* READ CONTENTS OF ENTRY
}(UNKNOWN MONITOR READ'MIBOB'NAME _ 1;}&* READ ENTRY
}(UNKNOWN MONITOR SET'MIBOB'NAME _ 2;}'* SET NAME OF ENTRY
}(UNKNOWN MONITOR SET'MIBOB'ACCESS _ 3;}%* SET PUBLIC, FRIEND AND OWENER ACCESS OF OBJECT
}(UNKNOWN MONITOR SET'LOCK'LIST _ 4;}(* SET LOCK AND ACCESS FOR LOCK
}(UNKNOWN MONITOR DELETE'MIBOB _ 5;})* DELETE ENTRY
}(INTEGER MONITOR CREATE'MIBOB _ 6;})* CREATE NEW ENTRY
}(UNKNOWN MONITOR MERGE'MCW _ 9;},* READ OR MERGE THE MIB CAPABILITY WORK (MCW) INTO SPT
}(UNKNOWN MONITOR SET'MIB'ACCESS _ 10;}&* COPY MIB CAPABILITIES WORD FROM ONE MIB TO ANOTHER
}(INTEGER MONITOR READ'MIB'ACCESS _ 11;}%* READ MIB ACCESS
}(UNKNOWN MONITOR SET'MIBOB'VALUE _ 12;}%* SET VALUE OF OBJECT
}(INTEGER MONITOR COPY'MIBOB _ 14;}** COPY ACCESS KEY FROM ONE MIB TO ANOTHER (NOT IMPLEMENTED)
}(UNKNOWN MONITOR SET'NO'CHARGE _ 15;}'* SET NO DRUM CHARGE FLAG FOR FILE
}(INTEGER MONITOR READ'MIB'SPACE _ 16;}&* READ AVAILABLE SPACE IN MIB
}(UNKNOWN MONITOR SET'FILE'LOCK _ 18;}'* SET WRITTEN AND REFERENCE DATE ON FILE (NOT IMPLEMENTED)
}(UNKNOWN MONITOR SET'DURABILITY _ 28;}&* SET THE DURABILITY FIELD OF THE MIB





******************************
*
* OPEN FILE TABLE (OFT) CALLS
*
******************************

})INTEGER MONITOR MON'OPEN'FILE _ 19;}'* OPEN OBJECT
}(UNKNOWN MONITOR MON'READ'OFT _ 20;}(* READ OFT ENTRY
}(UNKNOWN MONITOR MON'SET'OFT'AC _ 21;}&* SET OFT ACCESS LOCK
}(UNKNOWN MONITOR MON'SET'OFT'CL _ 22;}&* SET OFT CONTROL LOCK
}(UNKNOWN MONITOR SET'FILE'LENGTH _ 23;}%* SET WORD LENGTH FOR OFT ENTRY
}(INTEGER MONITOR CREATE'FILE'PAGE _ 24;}$* CREATE A PRIVATE MEMORY PAGE
}(INTEGER MONITOR DEL'FILE'PAGE _ 25;}'* DELETE A PAGE OF AN OBJECT
}(INTEGER MONITOR NEXT'FILE'PAGE _ 26;}&* GET NEXT PAGE OF FILE
}(UNKNOWN MONITOR MOVE'PAGE'PMT _ 27;}'* PUT REAL NAME OF A PAGE OF A FILE INTO A PMT ENTRY

******************************
*
* PROCESS MEMORY TABLE (PMT) CALLS
*
******************************

})INTEGER MONITOR ACQUIRE'PMT _ 50;})* ACQUIRE AND INITIALIZE A PMT ENTRY
}(UNKNOWN MONITOR NEW'PMT'PAGE _ 51;}(* CREATE A PRIVATE MEMORY PAGE AND PUT ITS REAL NAME INTO PMT
}(UNKNOWN MONITOR COPY'RN'PMT _ 52;})* PUT SPECIFIED REAL NAME INTO A PMT ENTRY
}(UNKNOWN MONITOR CLEAR'PMT _ 53;}+* RELEASE PAGE FROM PMT ENTRY
}(UNKNOWN MONITOR DELETE'PMT _ 54;}** RELEASE PMT ENTRY (RELEASE PAGE FROM PMT ENTRY
}(UNKNOWN MONITOR SET'PMT'ACC'LOCK _ 55;}$* SET THE ACCESS LOCK OF A PMT ENTRY
}(UNKNOWN MONITOR SET'PMT'CON'LOCK _ 56;}$* SET THE CONTROL LOCK OF AN PMT ENTRY
}(UNKNOWN MONITOR SET'PMT'RO _ 57;}** SET THE READ ONLY BIT IN A PMT ENTRY
}(UNKNOWN MONITOR READ'PMT _ 58;},* READ A PMT ENTRY



******************************
*
* WORKING SET CALLS
*
******************************

})UNKNOWN MONITOR PUT'PAGE'DWS _ 65;}(* PUT PAGE IN THE DRUM WORKING SET
}(UNKNOWN MONITOR PUT'PAGE'CWS _ 66;}(* PUT A PAGE IN THE CORE WORKING SET
}(INTEGER MONITOR DEL'PAGE'DWS _ 67;}(* DELETE A PAGE FROM THE DWS
}(INTEGER MONITOR DEL'PAGE'CWS _ 68;}(* DELETE A PAGE FROM THE CWS
}(INTEGER MONITOR READ'LEN'WS _ 70;})* READ THE LENGTH OF A SPECIFIED THE WORKING SET
}(UNKNOWN MONITOR SET'LEN'WS _ 71;}** SET THE OVERFLOW LENGTH OF A SPECIFIED WS



******************************
*
* SUB-PROCESS TABLE (SPT) CALLS
*
******************************

})INTEGER MONITOR MON'CREATE'SP _ 90;}'* ACQUIRE AND INITIALIZE AN SPT ENTRY
}(UNKNOWN MONITOR MON'DESTROY'SP _ 91;}&* DELETE THE CONTENTS OF AN SPT ENTRY
}(UNKNOWN MONITOR MON'READ'SPT _ 95;}(* READ AN SPT ENTRY
}(UNKNOWN MONITOR MON'READ'SPCS _ 96;}'* READ AN SPCS ENTRY
}(INTEGER MONITOR MON'READ'SPT'FLD _ 97;}$* READ A SELECTED FIELD OF AN SPT ENTRY
}(UNKNOWN MONITOR MON'SET'SPT'FLD _ 98;}%* SET THE VALUE OF A SPECIFIED FIELD OF AN SPT ENTRY
}(UNKNOWN MONITOR READ'SPT'MAP _ 99;}(* READ THE MAP OF AN SPT ENTRY
}(UNKNOWN MONITOR SET'SPT'MAP _ 100;}(* SET THE MAP OF AN SPT ENTRY
}(INTEGER MONITOR READ'MAP'BYTE _ 101;}&* READ A BYTE IN THE MAP OF AN SPT ENTRY
}(UNKNOWN MONITOR SET'MAP'BYTE _ 102;}'* SET A BYTE IN THE MAP OF AN SPT ENTRY
}(UNKNOWN MONITOR READ'ACCESS'KEY _ 103;}$* READ AN ACCESS KEY FROM AN SPT ENTRY
}(UNKNOWN MONITOR COPY'ACCESS'KEY _ 104;}$* COPY AN ACCESS KEY FROM ONE SPT ENTRY TO ANOTHER
}(UNKNOWN MONITOR COPY'TAK _ 105;}+* COPY THE TEMPORARAY ACCESS KEY
}(INTEGER MONITOR READ'SPS'PARAM _ 106;

******************************
*
* SUB-PROCESS CALL STACK (SPCS) CALLS
*
******************************

})UNKNOWN MONITOR SP'CALL _ 111;},* CALL A SUB-PROCESS
}(UNKNOWN MONITOR SP'JUMP _ 112;},* JUMP TO A SUB-PROCESS
}(UNKNOWN MONITOR SP'TRAP _ 113;},* GENERATE A SOFTWARE TRAP
}(UNKNOWN MONITOR TRAP'RETURN _ 114;}(* POP UP SUB-PROCESS CALL STACK & GENERATE A SOFTWARE TRAP
}(UNKNOWN MONITOR SP'BRANCH _ 115;}** BRANCH INTO A SUB-PROCESS
}(UNKNOWN MONITOR SP'RETURN _ 116;}** RETURN TO A CALLING SUB-PROCESS
}(UNKNOWN MONITOR JUMP'RETURN _ 117;}(* RETURN TO A SPECIFIED LEVEL IN THE SUB-PROCESS CALL STACK
}(UNKNOWN MONITOR MARK'CALL _ 118;}** RECORD A FUNCTION CALL ON THE SPCS
}(UNKNOWN MONITOR DELETE'CALL _ 119;}(* DELETE A FUNCTION CALL FROM THE SPCS
}(UNKNOWN MONITOR MODIFY'CALL _ 120;}(* CHANGE A FUNCTION CALL ON THE SPCS



******************************
*
* PROCESS CALLS
*
******************************

})INTEGER MONITOR COPY'PMT'PROC _ 130;}&* COPY A PMT ENTRY FROM ONE PROCESS TO ANOTHER
}(INTEGER MONITOR ACTIVATE'PROC _ 132;}&* ACTIVATE A PROCESS
}(UNKNOWN MONITOR TRANSFER'TERM _ 133;}&* TRANSFER A TERMINAL
}(UNKNOWN MONITOR MAKE'DORMANT _ 134;}'* MAKE A PROCESS DORMANT
}(UNKNOWN MONITOR INIT'PROC'PAGE _ 135;}%* INITIALIZE THE UTILITY AREA OF THE CONTEXT BLOCK OR A
*}P*}#PRIVATE MEMORY PAGE IN A NEW PROCESS
})UNKNOWN MONITOR INIT'PROC'MAP _ 136;
}(UNKNOWN MONITOR INIT'SPT _ 137;
}(INTEGER MONITOR READ'PROC'PARAM _ 211;



******************************
*
* RESOURCE CALLS
*
******************************

* I BELIEVE ONE MOVE'DISK'RES IS IMPLEMENTED, AND WHO CARES?
})UNKNOWN MONITOR READ'RESOURCES _ 145;}%* READ THE ITEMS OF THE RESOURCE ALLOCATION
}(UNKNOWN MONITOR MOVE'RESOURCES _ 146;}%* MOVE RESOURCES FROM ONE OBJECT TO ANOTHER
}(UNKNOWN MONITOR SPLIT'TIME _ 147;})* SPLIT RESOURCES FOR TIME
}(UNKNOWN MONITOR MERGE'TIME _ 148;})* MERGE RESOURCES FOR TIME
}(MONITOR MOVE'DISK'RES _ 149;}.* MOVE DISK RESOURCES
*}&UNKNOWN MONITOR SPLIT'RESOURCES;
*}&UNKNOWN MONITOR MERGE RESOURCES;

******************************
*
* OPERATIONS ON INTERRUPT CHANNEL TABLE (ICT)
*
******************************

})UNKNOWN MONITOR SET'PROC'INT _ 163;}'* SET PIW BITS
}(INTEGER MONITOR QUIT'BLOCK _ 164;
}(INTEGER MONITOR GET'INT'NUM _ 165;}(* CONVERT INTERRUPT CHARACTER CONSTANT TO INTERRUPT NUMBER
}(INTEGER MONITOR READ'ICT _ 166;}+* READ INTERRUPT CELL
}(INTEGER MONITOR READ'PIW _ 167;}+* READ PROGRAM INTERRUPT WORD (PIW)
}(UNKNOWN MONITOR ALLOW'INTS _ 168;})* RESET NON-INTERRUPTABILITY
}(UNKNOWN MONITOR REFUSE'INTS _ 169;}(* MAKE NON-INTERRUPTABLE
}(UNKNOWN MONITOR BLOCK _ 170;}.* BLOCK THE PROCESS
}(UNKNOWN MONITOR CLEAR'PIW _ 171;}** CLEAR PIW BITS
}(UNKNOWN MONITOR SET'ICT _ 172;},* SET INTERRUPT CELL
}(UNKNOWN MONITOR SET'ICT'CON'LOCK _ 173;}#* SET CONTROL LOCK IN INTERRUPT CELL
}(INTEGER MONITOR ACQUIRE'ICT _ 174;}(* ACQUIRE INTERRUPT CELL



******************************
*
* CHIO CALLS
*
******************************

})UNKNOWN MONITOR SET'LINE'FIELD _ 180;}%* SET THE VALUE OF A PARAMETER FOR THE CHIO LINE
}(UNKNOWN MONITOR READ'LINE'TABLE _ 181;}$* READ CHIO LINE TABLE
}(STRING MONITOR READ'STRING _ 182;})* INPUT STRING FROM CHIO LINE
}(STRING MONITOR WRITE'STRING _ 183;}(* OUTPUT A STRING ONTO A CHIO LINE



******************************
*
* MISCELLANEOUS
*
******************************

})MONITOR ACQUIRE'SEM _ 29;}1* ACQUIRE SEMAPHORE (NOT IMPLEMENTED)
}(MONITOR RELEASE'SEM _ 30;}1* (NOT IMPLEMENTED)
}(MONITOR DIAGNOSTIC'DIO _ 59;}.* DIRECT INPUT/OUTPUT?
}(MONITOR KLUDGE'IO _ 128;}2* VARIATION OF DIAGNOSTIC'DIO?
}(UNKNOWN MONITOR DO'POT'PIN _ 129;})* HARDWARE KLUDGE
}(LONG MONITOR READ'CLOCK _ 210;},* READ REAL-TIME CLOCK
}(MONITOR READ'WRITE'CM _ 255;}.* READS AND WRITES INTO CENTRAL MEMORY


})END;

}(COMMON UTILITY'CALLS;

******************************
*
* MISCELLANEOUS UCALLS
*
******************************

})UNKNOWN UTILITY BREAK'POINT _ 0;}** UCALL FOR DEBUGGING PROGRAMS
}(STRING UTILITY ERRORMSG _ 1;}.* RETURN SYSTEM ERROR MESSAGE
}(STRING UTILITY GET'PARAM _ 2;}-* STRIP PARAMETER FROM STRING
}(STRING UTILITY GET'COM'LINE _ 3;}** GET CURRENT COMMAND LINE FROM UTS
}(INTEGER UTILITY ABRV'LKP _ 4;}-* LOOK UP ABBREVIATED NAME IN STRING ARRAY
}(INTEGER UTILITY CON'ABRV'LKP _ 5;})* CONTINUE SAME IN NEW STRING ARRAY
}(STRING UTILITY GET'CMP'COMLINE _ 6;}'* GET SAVED COMMAND LINE AND USER NUMBER OF ATTACHED FILE
}(UNKNOWN UTILITY SET'COM'LINE _ 7;})* SET THE SAVED COMMAND LINE

******************************
*
* FILE SYSTEM CALLS
*
******************************

})UNKNOWN UTILITY NAME'SEARCH _ 10;})* CONVERT FILE ST TO UTS NAME
}(UNKNOWN UTILITY SPECIAL'SEARCH _ 11;}&* VARIATION OF ABOVE
}(INTEGER UTILITY CONV'NAME _ 12;}+* CONVERT FROM UTS TO MON FILE NAME
}(LONG UTILITY SPREAD'NAME _ 13;},* SPLIT FILE NAME STRING INTO COMP.
}(UNKNOWN UTILITY READ'MIBOB'VALUE _ 14;}$* READ 'VALUE' OF MIB OBJECT
}(UNKNOWN UTILITY DELETE'FILE _ 15;})* DELETE FILE AND CONTENTS
}(INTEGER UTILITY OPEN'FILE _ 16;}+* OPEN FILE W/WO LOCKING
}(UNKNOWN UTILITY CLOSE'FILE _ 17;}** CLOSE AND UNLOCK FILE
}(UNKNOWN UTILITY READ'OFT _ 18;},* READ OFT
}(INTEGER UTILITY READ'OFT'FIELD _ 19;}&* READ OFT FIELD
}(UNKNOWN UTILITY SET'OFT'CL _ 20;}** SET OFT CONTROL LOCK
}(INTEGER UTILITY CONV'KEY _ 21;},* CONVERT DEFAULT ACCESS KEY


******************************
*
* EXTENDED SUB-PROCESS SYSTEM (SPS) CALLS
*
******************************

})INTEGER UTILITY CREATE'SSP _ 30;}** CREATE SUBSIDIARY SUB-PROCESS
}(INTEGER UTILITY CREATE'PSP _ 31;}** CREATE PARALLEL SUB-PROCESS
}(UNKNOWN UTILITY ATTACH _ 32;}.* ATTACH PIF FILE TO SUB-PROCESS
}(UNKNOWN UTILITY DESTROY'SP _ 33;}** DESTROY SUB-PROCESSES
}(UNKNOWN UTILITY READ'SPT _ 34;},* READ SPT
}(INTEGER UTILITY READ'SPT'FIELD _ 35;}&* READ SPT FIELD
}(UNKNOWN UTILITY SET'SPT'FIELD _ 36;}'* SET SPT FIELD
}(STRING UTILITY READ'SPNAME _ 37;}** READ SUB-PROC NAME
}(UNKNOWN UTILITY SET'SPNAME _ 38;}** SET SUB-PROC NAME
}(INTEGER UTILITY SPNAME'SEARCH _39;}(* LOOK UP SP NAME

******************************
*
* CONTROL INPUT/OUTPUT STREAMS (CIOS) MANIPULATION
*
******************************

})INTEGER UTILITY CREATE'CIOS _ 40;})* CREATE CONTROL I/O STREAM
}(INTEGER UTILITY READ'CIOS'FIELD _ 41;}%* READ CIOS FIELD
}(UNKNOWN UTILITY SET'CIOS'FIELD _ 42;}&* SET (SOME) CIOS FIELDS
}(UNKNOWN UTILITY SET'CIOS'INPUT _ 43;}&* SET UP FOR INPUT
}(UNKNOWN UTILITY SET'CIOS'OUTPUT _ 44;}%* SET UP FOR OUTPUT



******************************
*
* CIOS INPUT/OUTPUT
*
******************************

})UNKNOWN UTILITY PRINT'STRING _ 45;}(* WRITE STRING ON CIOS
}(UNKNOWN UTILITY PRINT'CHAR _ 46;}** WRITE CHAR ON CIOS
}(UNKNOWN UTILITY START'OUTPUT _ 47;}(* DUMP OUTPUT BUFFER
}(STRING UTILITY READ'LINE _ 48;},* READ NEXT INPUT LINE
}(STRING UTILITY EDIT'LINE _ 49;},* EDIT CURRENT LINE
}(CHARACTER UTILITY READ'CHAR _ 50;})* READ NEXT CHARACTER
}(UNKNOWN UTILITY BLOCK'OB'EMPTY _ 51;}&* WAIT UNTIL OUT BUFFER IS EMPTY



******************************
*
* USER, ACCOUNT, AND GROUP PROFILES
*
******************************

})STRING UTILITY READ'UP'ITEM _ 60;})* READ ITEM FROM USER PROFILE
}(STRING UTILITY READ'UP'NAMES _ 61;}(* READ NAMES OF UP ITEMS
}(UNKNOWN UTILITY SET'UP'ITEM _ 62;})* SET (CREATE) VALUE OF UP ITEM
}(UNKNOWN UTILITY SET'UP'ACCESS _ 63;}'* SET ACCESS TO UP ITEM
}(LONG UTILITY FIND'MIB _ 64;}/* CONVERT USER NAME/NUMBER TO MIB ADDR
}(INTEGER UTILITY CREATE'UP'ENTRY _ 65;}%* CREATE USER/UP ENTRY
}(UNKNOWN UTILITY DELETE'UP'ENTRY _ 66;}%* DELETE USER/UP ENTRY

******************************
*
* PROCESSES, AND PROCESS PROFILE
*
******************************

})UNKNOWN UTILITY CREATE'PROCESS _ 70;}&* CREATE/INITIALIZE PROCESS
}(STRING UTILITY READ'PP'ITEM _ 71;})* READ ITEM FROM PROCESS PROFILE
}(STRING UTILITY READ'PP'NAMES _ 72;}(* READ NAMES OF PP ITEMS
}(UNKNOWN UTILITY SET'PP'ITEM _ 73;})* SET (CREATE) VALUE OF PP ITEM
}(UNKNOWN UTILITY DESTROY'PROCESS _ 74;}%* DESTROY THIS PROCESS



******************************
*
* TIME CALCULATIONS
*
******************************

})INTEGER UTILITY SYS'TIME'NUM _ 80;}(* NUMERICAL SYSTEM TIMES
}(INTEGER UTILITY ANY'TIME'NUM _ 81;}(* CHARACTER SPECIFIC TIMES
}(STRING UTILITY ANY'TIME'CHAR _ 82;}(* CHARACTER SPECIFIC TIMES 


})END;

}(COMMON SEQ'FILE'DEFS;

*}&THIS COMMON BLOCK CONTAINS THE DECLARATIONS OF IDENTIFIERS
* USED IN FILE HANDLING OPERATIONS.

})DECLARE ARRAYONE /* ARRAY DETERMINING WHICH FILES ARE OPEN */
})OPEN'FILE'TABLE[16];

})DECLARE FIELD
})PAGE'NUM'ADDR /* THE PAGE NUMBER OF THE ADDRESS})*/
})(0:6,12),
})PAGES'IN'FILE /* NUMBER OF PAGES IN THE FILE},*/
})(0:2,12),
})WORDS'IN'PAGE /* WORD NUMBER IN THE LAST PAGE}+*/
})(0:13,23);

})DECLARE PARAMETER
})A'PAGE _ 2048;}#/* WORDS TO A PAGE}8*/

})DECLARE PARAMETER /* FOR IOFLAG VALUES}6*/
})READ'FILE _ 0,
})WRITE'FILE _ 1,
})APPEND'FILE _ 2;

})DECLARE PARAMETER /* FOR OBJECT TYPES}7*/
})SMALL'FILE _ 0,
})LARGE'FILE _ 1;

})DECLARE PARAMETER /* FOR FILE TYPES}9*/
})SUBCOMMAND'FILE _ 6'9SUB',
})SAVE'FILE _ 6'9SAV',
})BINARY'FILE _ 6'9BIN',
})SYMBOLIC'FILE _ 6'9SYM',
})DUMP'FILE _ 6'9DMP',
})UNKNOWN'FILE _ 6'}$';

})DECLARE PARAMETER /* FOR THE MAXIMUM LENGTH OF FILENAMES}$*/
})LENGTH'PFS'NAMES _ 13,
})LENGTH'TSS'NAMES _ 16;



})END;

}(COMMON WINDOW'DEFS;

* THIS COMMON BLOCK DECLARES THE STRUCTURE OF A WINDOW DESCRIPTOR

})DECLARE PARAMETER
})NUM'SEQ'FILES _ 6;

})DECLARE ARRAY
})SEQ'FILE'TABLE[NUM'SEQ'FILES:21];

})DECLARE SIGNED FIELD
})PAGE'IN'WINDOW (0:0,11); /* PAGE NUMBER OF THE FILE}(*/

})DECLARE FIELD
})PMT'INDEX (0:12,19),}%/* PMT INDEX OF THE FILE}**/
})WINDOW'IN'USE (0:20,20), /* BIT SIGNALING THE WINDOW IS IN */
/*}%USE}8*/
})LARGE'OR'SMALL (0:21,21),/* LARGE OR SMALL FILE},*/
})OPERATION (0:22,23),}%/* BITS REPRESENTING WHAT WILL BE */
/*}#DONE TO THE FILE}-*/
})FILE'NUM (1:1,5),}(/* NUMBER OF THE FILE}-*/
})WINDOW'ADDRESS (1:6,23), /* ADDRESS OF THE WINDOW IN USE}#*/
})CHARACTER'SIZE (2:0,5),}"/* NUMBER OF BITS PER CHARACTER}#*/
})CHARS'PER'WORD (2:6,8),}"/* NUMBER OF CHARACTERS PER WORD}"*/
})CHARS'PER'PAGE (2:9,23), /* NUMBER OF CHARACTERS PER PAGE}"*/
})NAME'STORAGE (3);}(/* STORAGE FOR THE M1 FORMATTED}#*/
/*}#NAME}9*/

})DECLARE STRING FIELD
})READ'DESC (11);}*/* STRING DESCRIPTOR FOR A FILE}#*/
/*}#WHICH WILL BE READ}+*/

})DECLARE FIELD
})CHARS'LEFT (15);})/* NUMBER OF CHARACTERS YET TO BE */
/*}"READ FROM THE FILE (AFTER THE */
/*}"CURRENT PAGE HAS BEEN READ)}#*/

})DECLARE STRING FIELD
})WRITE'DESC (16);})/* STRING DESCRIPTOR OF A FILE}$*/
/*}#WHICH WILL BE READ}+*/

})DECLARE FIELD
})LENGTH'IN'CHARS (20);}$/* NUMBER OF CHARACTERS ALREADY}#*/
/*}#WRITTEN INTO THE FILE (AFTER */
/*}#THE LAST PAGE HAD BEEN}'*/
/*}#WRITTEN)}5*/

})DECLARE ARRAY
})SEQ'FILE'WINDOWS[NUM'SEQ'FILES] _ (100000B, 104000B, 110000B,
})114000B, 120000B, 124000B);



})END;

}(COMMON ERROR'DEFS;

*}&THIS COMMON BLOCK DECLARES ALL THE VARIABLES USED TO PRINT OUT
* ERROR MESSAGES AND THE MACROS USED IN THE FAILURE RETURN FIELD OF
* FUNCTION CALLS.

* BE CAREFUL, MACROS!
})MACRO WARNING _ RUNTIME'FAILURE() & FRETURN;
}(MACRO CATASTROPHE _ FATAL'ERROR() & FRETURN;
}(MACRO DISTRESS _ SYSTEM'ERROR() & FRETURN :
})ERROR'CODE, ERROR'NUMBER;

})DECLARE PARAMETER
})DEBUGGING _ -1;}$/* A FLAG WHICH WHEN SET CAUSES NOTIFI- */
/* CATION OF MOST FAILURES TO BE PRINT- */
/*}"ED OUT AT THE LOWEST POSSIBLE LEVEL */

})DECLARE INTEGER
})ERROR'CODE,}(/* CHARACTER CODE OF ERROR}.*/
})ERROR'FILE'NUM,}$/* THE FILE NUMBER USED BY THE FORMAT-}"*/
/*}"TING OUTPUT FUNCTIONS}/*/
})ERROR'NUMBER,}&/* NUMERICAL CODE OF ERROR}.*/
})RADIX;}-/* THE RADIX OF NUMBERS OUTPUT BY THE}#*/
/*}#FORMATTING OUTPUT FUNCTIONS}(*/

})DECLARE STRING
})ERROR'STRING (200);/* THE STRING USED BY THE FORMATTING}$*/
/*}#OUTPUT FUNCTIONS}3*/



})END;

}(COMMON STRING'DEFS;

*}&THIS COMMON BLOCK DEFINES ALL THE FIELDS USED TO MANIPULATE
* STRINGS WITH.

})INCLUDE ERROR'DEFS;

})DECLARE FIELD
})BP (0),},/* BEGIN POINTER}9*/
})RP (1),},/* READ POINTER}:*/
})WP (2),},/* WRITE POINTER}9*/
})EP (3);},/* END POINTER};*/

})DECLARE FIELD
})CHAR'SIZE (0:2,3), /* THE SIZE OF CHARACTERS IN THE STRING}"*/
/*}#(0 = 6 BITS, 1 = 8 BITS,},*/
/*}#2 = 12 BITS, AND 3 = 24 BITS)}'*/
})CHAR'POSITION /* THE CHARACTER POSITION IN THE WORD}$*/
})(0:4,5),
})CHAR'ADDRESS /* THE ADDRESS OF THE STRING POINTER}%*/
})(0:6,23);

})DECLARE FIELD /* FOR 6 BIT CHARACTERS}2*/
})CHAR6'0 (0:0,5),
})CHAR6'1 (0:6,11),
})CHAR6'2 (0:12,17),
})CHAR6'3 (0:18,23);

})DECLARE FIELD /* FOR 8 BIT CHARACTERS}2*/
})CHAR8'0 (0:0,7),
})CHAR8'1 (0:8,15),
})CHAR8'2 (0:16,23);

})DECLARE FIELD /* FOR 12 BIT CHARACTERS}1*/
})CHAR12'0 (0:0,11),
})CHAR12'1 (0:12,23);

})DECLARE STRING FIELD /* A KLUDGE SO THAT WHEN THE POINTER TO}"*/
})STRING'DESC (0);}#/*}#ONE STRING DESCRIPTOR IS ASSIGNED}#*/
/*}#TO ANOTHER, SPL WILL DO THE RIGHT}#*/
/*}#THING (MOVE 4 WORDS)}0*/

* THIS ALLOWS PROGRAM BLOCKS TO USE SOMETHING OTHER THAT LARGE LOCAL
* STRINGS FOR TEMPORARY STORAGE
})DECLARE ARRAY
})TEMP'STRING'STOR[100];

})DECLARE PARAMETER ARRAY
})POSS'CHAR'SIZES[4] _ (6, 8, 12, 24);



})END;

}(COMMON SPECIAL'CHARS;

*}&THIS COMMON BLOCK DECLARES ALL THE SPECIAL CHARACTERS USED IN
* THIS PROGRAM OTHER THAN THOSE NEED BY THE DTP FUNCTIONS.

})DECLARE PARAMETER /* FOR 940 CHARACTER CONSTANTS}**/
})BLANK _ 0,
})MB _ 135B,}*/*}#940 MULTIPLE BLANK CHARACTER}'*/
})EOF _ 137B,})/*}#940 END OF FILE CHARACTER}**/
})NULL _ 140B,}(/*}#940 NULL CHARACTER}1*/
})LF _ 152B,}*/*}#940 LINE FEED}6*/
})CNTL'A _ 225,}'/*}#940 CONTROL-A}6*/
})CR _ 155B;}*/*}#940 CARRIAGE RETURN}0*/

})DECLARE PARAMETER /* FOR M1 CHARACTER CONSTANTS}+*/
})ESCAPE'CHAR _ 37B,}"/*}#FOR I/O THROUGH THE CHIO}+*/
})M1'MB _ 200B,}'/*}#M1 MULTIPLE BLANK CHARACTER}(*/
})M1'NULL _ 300B,}%/*}#M1 NULL CHARTER}4*/
})M1'NL _ 307B,}'/*}#M1 NEW LINE CHARACTER (A 940 CRLF) */
})M1'LF _ 310B,}'/*}#M1 LINE FEED}7*/
})INQUISITION'CHAR _ 345B,
/* THE CHARACTER SEND BY THE INQUISITOR */
})M1'CR _ 355B;}'/*}#M1 CARRIAGE RETURN}1*/

})DECLARE PARAMETER
})ASCII'NULL _ 0,
})ASCII'LF _ 12B,
})ASCII'CR _ 15B,
})ASCII'BLANK _ 40B;


})END;

}(COMMON ARRAY'DEFS;

*}&THIS COMMON BLOCK DEFINES ALL THE FIELDS USED TO MANIPULATE
* ARRAYS WITH.

})DECLARE FIELD /* FOR THE ARRAY DESCRIPTOR ITSELF}'*/
})INDEXING'ORIGIN (0:2,2),
})ARRAY'TRAP'BIT (0:3,3),
})LEB (0:4,4),
})ITEM'SIZE'LEB0 (0:5,6),
})ITEM'SIZE'LEB1 (0:5,10),
})UPPER'BOUND'LEB0 (0:7,23),
})UPPER'BOUND'LEB1 (0:11,23),
})ARRAY'DESC'ADDR (1);

})DECLARE FIELD /* FOR GENERAL INDIRECT ADDRESS WORDS}$*/
})IAW'TYPE (0:0,1),
})IAW'TAG (0:2,4),
})IAW'TRAP (0:5,5),
})IAW'ADDRESS (0:6,23);

})DECLARE PARAMETER /* FOR IAW'TYPE}:*/
})NORMAL'IAW _ 0,
})FIELD'IAW _ 1,
})STRING'IAW _ 2,
})ARRAY'IAW _ 3;

})DECLARE PARAMETER /* FOR IAW'TAG};*/
})DIRECT _ 0,
})INDIRECT _ 1,
})INDEXED _ 2,
})BASE'INDEXED _ 3,
})POINTER'DISP _ 4,
})IND'PTR'DISP _ 5,
})BASE'INDEX'DISP _ 6,
})RELATIVE _ 7;


})END;

}(COMMON GLOBAL'VARIABLES;

* THIS BLOCK CONTAINS GENERAL CONSTANTS AND VARIABLES USED THROUGHOUT
*}#THE PROGRAM

})INCLUDE MONITOR'CALLS, UTILITY'CALLS, STRING'DEFS,
})SEQ'FILE'DEFS, WINDOW'DEFS, ERROR'DEFS,
})SPECIAL'CHARS;

})DECLARE PARAMETER /* FOR SETTING FLAGS */
})NO _ 0,
})YES _ 1;

})DECLARE INTEGER
})INIT'STACK'LEVEL,}"/* STACK LEVEL UPON ENTRY */
})THIS'SUB'PROCESS;}"/* CURRENT SUB-PROCESS INDEX INTO THE SPT*/


})END;

}(PROGRAM INITIALIZE;

*}&THIS FUNCTION SETS UP THE TABLES SHOWING HOW MANY FILES ARE OPEN
* (THIS IS FOR THE USE OF THE FILE HANDLING FUNCTIONS, IT DOESN'T HAVE 
* TO BE CORRECT AND KNOW ABOUT ALL THE FILES A USER HAS OPEN.}"THE MON-
* TOR HAS THE TRUTH COPY.) AND THE WINDOWS IN USE.
*}&THE FUNCTION ALSO INITIALIZES THE GLOBAL VARIABLES USED BY THIS
* THIS PROGRAM.

})INCLUDE GLOBAL'VARIABLES;

})DECLARE ARRAY
})FORMATTED'NAME[8]; /* THE MONITOR FORMATTED NAME OF THE}%*/
/*}#EMULATOR}<*/

})DECLARE INTEGER
})FLAG,
})OPEN'FILE'NUM,
})SEQ'FILE'NUM,
})TM'BITS'SET,}'/* THE TRAPS WHICH THE USER IS ALLOWED}#*/
/*}#TO HANDLE};*/
})USER'ACCESS'KEY;

})DECLARE LONG
})DISK'ADDRESS /* ONLY USEFUL WHEN THE CELL IS USED AS A*/
})_ (0, 0);}(/*}#TIMER}?*/


})FUNCTION INITIALIZE(FLAG);

* DETERMINE STACK LEVEL UPON ENTRY
})INIT'STACK'LEVEL _ READ'SPS'PARAM('CSL'//
})INIT'FAIL: ERROR'CODE, ERROR'NUMBER);

* DETERMINE CURRENT SUB-PROCESS NUMBER
})THIS'SUB'PROCESS _ READ'SPS'PARAM('CSP'//
})INIT'FAIL: ERROR'CODE, ERROR'NUMBER);
}(ALLOW'INTS();

* SET UP A LOOP TO SHOW THAT EACH WINDOW IS AVAILABLE FOR USE
})FOR SEQ'FILE'NUM _ 0 TO NUM'SEQ'FILES-1 DO;
},SEQ'FILE'TABLE[SEQ'FILE'NUM]$WINDOW'IN'USE _ NO;
}(ENDFOR;

*}&SET THE FILE NUMBERS TO -1 (IF OPEN'FILE'TABLE[OPEN'FILE'NUM]
* # -1 IT CONTAINS THE NUMBER OF THE WINDOW THE FILE USES)
})FOR OPEN'FILE'NUM _ 1 TO 16 DO;
},OPEN'FILE'TABLE[OPEN'FILE'NUM] _ -1;
}(ENDFOR;

*}&INSERT FUNCTION ENTRY HERE!!!!!!!!!!!!!!!!!!!!!!!
})DEBUGGER(FLAG);

INIT'FAIL:EXIT();

})END;

}(PROGRAM FAILURES;

*}&THIS PROGRAM BLOCK CONTAINS THE FUNCTIONS CALLED WHEN SOMETHING
* GOES WRONG

})INCLUDE GLOBAL'VARIABLES;

})DECLARE INTEGER
})ERROR'ADDR = L' [0];}#/* ADDRESS OF CALLING STATEMENT}&*/
/*}#(WHERE FAILURE OCCURRED)}(*/

})DECLARE STRING
})EXPLANATION;}+/* JUST A STRING USED TO WRITE INTO}"*/



*}&RUNTIME FAILURE IS CALLED WHEN THE PROGRAM ARRIVES SOMEWHERE IT
* ISN'T SUPPOSED TO, USUALLY CAUSED BY SEVERAL UNFORTUNATE CIRCUMSTANCES
* (SUCH AS TRYING TO CLOSE A FILE THAT'S ALREADY CLOSED OR TRYING TO
* TO WRITE MORE CHARACTERS INTO A STRING THAN WILL FIT)
})UNKNOWN FUNCTION RUNTIME'FAILURE();
}(RETURN IF NOT DEBUGGING;
}(PUTA("&307RUNTIME FAILURE AT P = ",0);
}(OUTPUT'NUMBER (ERROR'ADDR);
}(OUTPUT'STRING("&307");
}(EXIT();


* SYSTEM'ERROR IS CALLED WHEN A MONITOR OR UTILITY CALL HAS FAILED
})UNKNOWN FUNCTION SYSTEM'ERROR();
}(RETURN IF NOT DEBUGGING;
}(OUTPUT'STRING("&307SYSTEM CALL FAILED: CODE = ");
}(SETUP (EXPLANATION, 3, @ERROR'CODE);
}(SETS (EXPLANATION, 0, 3);
}(OUTPUT'STRING(EXPLANATION);
}(PUTA (", NUMBER = ",0);
}(OUTPUT'NUMBER (ERROR'NUMBER);
}(PUTA (" AT P = ",0);
}(OUTPUT'NUMBER (ERROR'ADDR);
}(OUTPUT'STRING("&307");
}(EXIT();


*}&FATAL'ERROR IS CALLED WHEN AN ERROR OCCURS THAT WILL ALWAYS OCCUR
* EVEN IF RERUN (SUCH AS COMPARING THE LENGTH OF TWO STRINGS WITH DIF-
* FERENT CHARACTER SIZES)
})UNKNOWN FUNCTION FATAL'ERROR();
}(RETURN IF NOT DEBUGGING;
}(PUTA ("&307FATAL ERROR AT P = ",0);
}(OUTPUT'NUMBER (ERROR'ADDR);
}(OUTPUT'STRING("&307");
}(EXIT();

})END;

}(PROGRAM EXIT;

* THIS PROGRAM PERFORMS THE RETURN TO THE EXECUTIVE

})INCLUDE GLOBAL'VARIABLES;

})UNKNOWN FUNCTION EXIT();
}(SP'RETURN(// VALUE HALT(): ERROR'CODE, ERROR'NUMBER);

})UNKNOWN FUNCTION HALT();
}(.HLT 0;





})END;

}(PROGRAM OPEN'SEQ'FILE;

*}&THIS FUNCTION OPENS A FILE SPECIFIED BY THE ARGUMENT FILE'NAME
* FOR INPUT OR OUTPUT DEPENDING ON THE SECOND ARGUMENT, IOFLAG.}"THE
* THIRD ARGUMENT, CHAR'LENGTH DETERMINES WHAT THE SIZE OF THE CHAR-
* ACTERS READ FROM OR WRITTEN INTO THE FILE ARE.}"THIS FUNCTION WILL
* FAIL FOR MANY REASONS, SUCH AS IF ANY OF THE SYSTEM CALLS IT USES
* FRETURNS.}"HOWEVER, THE USER CAN CAUSE THE FUNCTION TO FAIL BY PAS-
* SING A BAD FILE NAME, OR BY SPECIFYING AN OBJECT WHICH REALLY ISN'T A
* FILE.}"THIS FUNCTION ALSO FAILS IF THE USER TRIES TO OPEN A FILE WHEN
* HE ALREADY HAS THE MAXIMUM ALLOWABLE NUMBER OF FILES OPEN.

})INCLUDE GLOBAL'VARIABLES;

})DECLARE ARRAY
})FORMATTED'NAME,}$/* M1 FORMATTED NAME}5*/
})LENGTH'WORD[3];}$/* VALUE OF THE M1 FORMATTED NAME}(*/


})DECLARE INTEGER
})ACCESS'SPEC,}'/* ACCESS SPECIFICATION TO THE FILE}&*/
})CHAR'LENGTH,}'/* LENGTH OF A CHARACTER IN BITS})*/
})FILE'LENGTH,}'/* LENGTH OF FILE IN CHARACTERS}**/
})FILE'NUMBER,}'/* TSS FILE NUMBER}7*/
})FILE'TYPE,})/* TYPE OF FILE: SYMBOLIC, BINARY, ETC.}"*/
/*}#(FILE TYPES DEFINED IN FILE'DEFS)}#*/
})IOFLAG,},/* OPERATION TO BE PERFORMED ON THE FILE */
/*}#(0-RETRIEVE, 1-STORE, 2-APPEND)}%*/
})GARBAGE,}+/* UNNECESSARY RETURNED VALUES}+*/
})LAST'PAGE,})/* LAST PAGE OF THE FILE}1*/
})LAST'WORD,})/* LAST WORD OF THE LAST PAGE OF THE FILE*/
})OBJECT'TYPE,}'/* TYPE OF FILE}:*/
/*}"(0 - SMALL FILE, 1 - LARGE FILE)}%*/
})PAGE'NUMBER,}'/* PAGE NUMBER OF THE FILE}/*/
})SEQ'FILE'NUM;}&/* NUMBER OF SEQUENTIAL FILES OPEN}'*/

})DECLARE POINTER
})FILE;}./* A POINTER TO THE FILE WINDOW}**/

})DECLARE STRING
})NULL'STRING,}'/* JUST A NULL STRING}4*/
})FILE'NAME;})/* FILE THE USER WANTS TO OPEN}+*/




})FUNCTION OPEN'SEQ'FILE(FILE'NAME, IOFLAG, FILE'TYPE, CHAR'LENGTH),
})FRETURN;

* CAN THE USER OPEN A FILE?
})FOR SEQ'FILE'NUM _ 0 TO NUM'SEQ'FILES - 1 DO;
},GOTO SET IF NOT SEQ'FILE'TABLE[SEQ'FILE'NUM]$WINDOW'IN'USE;
}(ENDFOR;
}(WARNING;

* SET UP A POINTER TO THE FILE'S WINDOW DESCRIPTOR
SET:}%FILE _ @SEQ'FILE'TABLE[SEQ'FILE'NUM];

* SET UP AN ARRAY DESCRIPTOR
})FORMATTED'NAME _ CONS'ARRAY'DESC(@(FILE.NAME'STORAGE), 8, 1, 0 //
})FRETURN);

* GET THE M1 FORMATTED NAME FROM THE FILE NAME TYPED IN BY THE USER
})NAME'SEARCH(FILE'NAME, FORMATTED'NAME, IOFLAG, FILE'TYPE, -1//
})FRETURN : ERROR'CODE, ERROR'NUMBER);

* MAY HAVE TO BE CHANGED FOR THE APPEND
})ACCESS'SPEC _ ('WU' IF IOFLAG ELSE 'RU');

* IS THE FILE NEW (FORMATTED'NAME[2] = -1)?
})IF FORMATTED'NAME[2] = -1 DO;
},FILE'NUMBER _ OPEN'FILE(-1, FORMATTED'NAME, ACCESS'SPEC, -1//
}-DISTRESS);
},FILE'LENGTH _ 0;
},OBJECT'TYPE _ SMALL'FILE;

})ELSE DO;
*}'THE FILE ALREADY EXISTS.}"DO THIS TO BE SAFE, THE OLD NAME MAY
* NOT HAVE BEEN A MONITOR FORMATTED NAME.
}-CONV'NAME(FORMATTED'NAME, FORMATTED'NAME, -1:
}-GARBAGE, OBJECT'TYPE, GARBAGE//DISTRESS);
},IF (OBJECT'TYPE = SMALL'FILE) OR (OBJECT'TYPE = LARGE'FILE) DO;
}0READ'MIBOB'VALUE(FORMATTED'NAME, 1, LENGTH'WORD, 2, -1//
}1DISTRESS);
}0FILE'NUMBER _ OPEN'FILE(-1, FORMATTED'NAME, ACCESS'SPEC, -1//
}1DISTRESS);
}0LAST'PAGE _ LENGTH'WORD[2]$PAGES'IN'FILE - 1;
}0LAST'WORD _ LENGTH'WORD[2]$WORDS'IN'PAGE + 1;
}0FILE'LENGTH _ (0 IF NEXT'FILE'PAGE(FILE'NUMBER, -1//
}1SYSTEM'ERROR() & GOTO ABORT: ERROR'CODE, ERROR'NUMBER) = -1
}1ELSE (24/CHAR'LENGTH)*((2048*LAST'PAGE) + LAST'WORD));

}1IF FILE'LENGTH AND IOFLAG = WRITE'FILE DO;
}4DEL'SEQ'FILE(FILE'NUMBER//ABORT);
}4FILE'LENGTH _ 0;
}0ENDIF;
},ELSE DO;
}0FRETURN;

}-ENDIF;

})ENDIF;

* FILL UP THE WINDOW
})FILE.PAGE'IN'WINDOW _ -1;
}(FILE.PMT'INDEX _ ACQUIRE'PMT(-1//SYSTEM'ERROR() &
})GOTO ABORT: ERROR'CODE, ERROR'NUMBER);
}(FILE.WINDOW'IN'USE _ 1;
}(FILE.LARGE'OR'SMALL _ (0 IF OBJECT'TYPE = SMALL'FILE ELSE 1);
}(FILE.OPERATION _ IOFLAG;
}(FILE.FILE'NUM _ FILE'NUMBER;
}(FILE.WINDOW'ADDRESS _ SEQ'FILE'WINDOWS[SEQ'FILE'NUM];
}(FILE.CHARACTER'SIZE _ CHAR'LENGTH;
}(FILE.CHARS'PER'WORD _ 24/CHAR'LENGTH;
}(FILE.CHARS'PER'PAGE _ 4000B*24/CHAR'LENGTH;
}(FILE.CHARS'LEFT _ FILE'LENGTH;
}(FILE.LENGTH'IN'CHARS _ FILE'LENGTH;

})SET'MAP'BYTE(THIS'SUB'PROCESS, FILE.WINDOW'ADDRESS$PAGE'NUM'ADDR,
})FILE.PMT'INDEX//SYSTEM'ERROR() & GOTO ABORT:
})ERROR'CODE, ERROR'NUMBER);

*}&THIS IS RIDICULOUS.}"THE STATEMENT SHOULD BE 
*})SETUP(NULL'STRING, 0, FILE.WINDOW'ADDRESS, CHAR'LENGTH);
* EXCEPT THAT SPL WON'T TAKE A VARIABLE CHARACTER LENGTH.
* (THERE ARE SIMILAR STATEMENTS IN MAP'IN'NEXT'PAGE AND CREATE'PAGE)
})SETUP'KLUDGE(NULL'STRING, 0, FILE.WINDOW'ADDRESS,
})FILE.CHARACTER'SIZE//ABORT);
}(FILE.READ'DESC _ NULL'STRING;
}(FILE.WRITE'DESC _ (PREPARE'APPEND(FILE, LAST'PAGE//ABORT) IF
})IOFLAG = APPEND'FILE ELSE NULL'STRING);
}(OPEN'FILE'TABLE[FILE'NUMBER] _ SEQ'FILE'NUM;
}(RETURN FILE'NUMBER;

* SOMETHING WENT WRONG, SO RESET THINGS
ABORT:}#FILE.WINDOW'IN'USE _ 0;
}(CLOSE'SEQ'FILE(FILE'NUMBER// FRETURN);
}(FRETURN;



})END;

}(PROGRAM CLOSE'SEQ'FILE;

*}&THIS FUNCTION CLOSES THE FILE SPECIFIED BY ITS ONLY ARGUMENT.
* IT IS CALLED TO CLOSE BOTH FILES WHICH WERE OPENED FOR INPUT AND OUT-
* PUT.}"HOWEVER, FOR FILES WHICH HAVE BEEN OPENED FOR OUTPUT, IT MUST
* DETERMINE THE EXACT LENGTH OF THE FILE AND LET THE MONITOR KNOW ABOUT
* IT.}"THE FUNCTION FAILS ONLY FOR INTERNAL REASONS: THE FILE IS ALREADY
* CLOSED, OR ONE OF THE MONITOR CALLS IT USES FAILS.

})INCLUDE GLOBAL'VARIABLES;

})DECLARE INTEGER
})FILE'NUMBER,
})LENGTH'IN'WORDS;}#/* LENGTH OF THE FILE IN WORDS}+*/

})DECLARE POINTER
})FILE;}./* A POINTER TO THE FILE WINDOW}**/



})UNKNOWN FUNCTION CLOSE'SEQ'FILE(FILE'NUMBER), FRETURN;

})FILE _ @SEQ'FILE'TABLE[OPEN'FILE'TABLE[FILE'NUMBER]];
* CHECK TO SEE IF WHAT IT IS GOING TO BE CLOSED ALREADY IS
})WARNING IF NOT FILE.WINDOW'IN'USE;
}(IF FILE.OPERATION DO;
},OUTPUT'SEQ'FILE(FILE'NUMBER, "&137"// FRETURN);
},LENGTH'IN'WORDS _
}-(LENGTH(FILE.WRITE'DESC)*(FILE.CHARACTER'SIZE) + 23)/24;
},SET'FILE'LENGTH(FILE'NUMBER, LENGTH'IN'WORDS -1//
}-DISTRESS);
}(ENDIF;

* FREE THE WINDOW
})CLOSE'FILE(FILE'NUMBER//DISTRESS);
}(FILE.WINDOW'IN'USE _ 0;
}(OPEN'FILE'TABLE[FILE'NUMBER] _ -1;
}(DELETE'PMT(FILE.PMT'INDEX//DISTRESS);

})RETURN;



})END;

}(PROGRAM INPUT'SEQ'FILE;

*}&THIS FUNCTION READS A LINE FROM A SPECIFIED FILE AND RETURNS IT
* TO THE CALLING FUNCTION.}"A "LINE" IS A STRING OF CHARACTERS ENDING
* WITH A CARRIAGE RETURN LINEFEED, A CARRIAGE RETURN, OR A LINEFEED.
* THE LINE THE FUNCTION RETURNS HAS HAD ANY MULTIPLE BLANK CHARACTERS
* REMOVED AND THE APPROPRIATE NUMBER OF BLANKS INSERTED.
*}&WHEN THIS FUNCTION IS CALLED THE FIRST TIME AFTER OPENING THE
* FILE, THE GCI AT READ FAILS BECAUSE FILE.READ'DESC WAS SET UP TO A
* LENGTH OF ZERO.}"THE WAY END-OF-FILE IS SIGNALED IN THIS FUNCTION IS
* WHEN IT RETURNS A STRING OF LENGTH ZERO, SO THAT MUST CONSTANTLY BE
* TESTED FOR.

})INCLUDE GLOBAL'VARIABLES;

})DECLARE INTEGER
})CHAR,}./* A CHARACTER READ FROM THE FILE}(*/
})COUNT,}-/* JUST A COUNTER FOR A FOR LOOP})*/
})FINISHED,}*/* A FLAG SIGNALING THAT THE FILE HAS}$*/
/*}#BEEN COMPLETELY READ}0*/
})FILE'NUMBER;}'/* THE NUMBER OF THE FILE}0*/

})DECLARE POINTER
})FILE;}./* A POINTER TO THE FILE WINDOW}**/

})DECLARE STRING
})INPUT'DUMMY,}'/* A STRING CONTAINING A PAGE OF THE FILE*/
/*}#UNLESS IT IS THE LAST PAGE WHEN IT}"*/
/*}#CONTAINS THE REMAINDER OF THE FILE}"*/
})OUTPUT'LINE;}'/* THE STRING RETURNED WITH A LINE READ}"*/
/*}#FROM THE FILE}7*/



})STRING FUNCTION INPUT'SEQ'FILE(FILE'NUMBER, OUTPUT'LINE), FRETURN;

})SETS(OUTPUT'LINE);
* SET UP THE POINTER TO THE FILE
})FILE _ @SEQ'FILE'TABLE[OPEN'FILE'TABLE[FILE'NUMBER]];

* MAKE A DUMMY ASSIGNMENT OF THE STRING DESCRIPTOR TO KEEP SPL HAPPY
*}#(REMEMBER TO REASSIGN FILE.READ'DESC BEFORE RETURNING)
})INPUT'DUMMY _ FILE.READ'DESC;

})FINISHED _ NO;
}(WHILE 1 DO;
READ:}'GOTO PAU IF FINISHED;
},CHAR _ GCI(INPUT'DUMMY//
}-MAP'IN'NEXT'PAGE(FILE:INPUT'DUMMY, FINISHED// FRETURN) &
}-GOTO READ) A' 177B;

* IS IT A MULTIPLE BLANK CHAR
}-IF CHAR = MB DO;
BLANKS:})GOTO PAU IF FINISHED;
}0CHAR _ GCI(INPUT'DUMMY//
}1MAP'IN'NEXT'PAGE(FILE:INPUT'DUMMY, FINISHED// FRETURN) &
}1GOTO BLANKS) A' 77B;
}0WCI(BLANK, OUTPUT'LINE//WARNING) FOR
}1COUNT _ 1 TO CHAR - 1;
}0CHAR _ BLANK;

* TEST FOR END OF LINE CHARACTER/CHARACTERS
}-ELSEIF CHAR = CR DO;
C'RET:}*GOTO PAU IF FINISHED;
}0CHAR _ GCI(INPUT'DUMMY//
}1MAP'IN'NEXT'PAGE(FILE: INPUT'DUMMY, FINISHED// FRETURN) &
}1GOTO C'RET) A' 177B;

}1IF CHAR = LF DO;
}4WCI(CR, OUTPUT'LINE//WARNING);
}0ELSE DO;
}4CHAR _ CHAR V' 200B;
}4INPUT'DUMMY$RP _ INCDES(INPUT'DUMMY$RP, -1);
}0ENDIF;
},ENDIF;
},WCI(CHAR, OUTPUT'LINE//WARNING);
},IF CHAR = LF OR CHAR = CR DO;
PAU:},FILE.READ'DESC _ INPUT'DUMMY;
}0RETURN OUTPUT'LINE;
},ENDIF;
}(ENDFOR;

CARR:}$WCI(CR, OUTPUT'LINE// FRETURN);
}(FILE.READ'DESC _ INPUT'DUMMY;
}(RETURN OUTPUT'LINE;




})END;

}(PROGRAM OUTPUT'SEQ'FILE;

*}&THIS FUNCTION APPENDS THE STRING SPECIFIED BY ITS SECOND ARGUMENT
* TO THE FILE SPECIFIED BY THE SECOND ARGUMENT.}"THE FIRST TIME THIS 
* FUNCTION IS CALLED AFTER OPENING THE FILE, ONE OF THE WCI'S WILL FAIL
* BECAUSE FILE.WRITE'DESC WAS SETUP WITH A LENGTH OF ZERO.}"CREATE'NEW'-
* PAGE IS THEN CALLED TO CREATE ANOTHER FILE PAGE.}"IT IS EXPECTED THAT
* INPUT'LINE WILL BE A STRING IN THE 940 CHARACTER SET, SO THAT THE
* STRING CAN SIMPLY BE WRITTEN INTO THE FILE.}"THIS FUNCTION FAILS ONLY
* IF CREATE'NEW'PAGE FAILS.

})INCLUDE GLOBAL'VARIABLES;

})DECLARE INTEGER
})CHAR,}./* A CHARACTER TO BE WRITTEN INTO A FILE */
})FILE'NUMBER;}'/* THE NUMBER OF THE FILE}0*/

})DECLARE POINTER
})FILE;}./* A POINTER TO THE FILE WINDOW}**/

})DECLARE STRING
})INPUT'LINE,}(/* THE STRING FROM WHICH CHARACTERS ARE}"*/
/*}#WRITTEN INTO THE FILE}/*/
})OUTPUT'DUMMY;}&/* A WORKING STRING}6*/



})FUNCTION OUTPUT'SEQ'FILE(FILE'NUMBER, INPUT'LINE), FRETURN;

})FILE _ @SEQ'FILE'TABLE[OPEN'FILE'TABLE[FILE'NUMBER]];
}(OUTPUT'DUMMY _ FILE.WRITE'DESC;
}(WHILE 1 DO;
},CHAR _ GCI(INPUT'LINE//
}-FILE.WRITE'DESC _ OUTPUT'DUMMY & RETURN);
WRITE'CHAR:
},WCI(CHAR, OUTPUT'DUMMY//OUTPUT'DUMMY _
}-CREATE'NEW'PAGE(FILE// FRETURN) & GOTO WRITE'CHAR);
}(ENDFOR;



})END;

}(PROGRAM DEL'SEQ'FILE;

*}&THIS FUNCTION DELETES ALL THE PAGES OF AN EXISTING FILE WHICH HAS
* BEEN OPENED FOR OUTPUT.}"THE FUNCTION FAILS ONLY IF ONE OF THE MONITOR
* CALLS IT USES FAILS.}"THE NAME OF THIS FUNCTION ISN'T EXACTLY AC-
* CURATE, BECAUSE IT ACTUALLY ONLY DELETES THE EXISTING PAGES OF THE
* FILE BUT DEL'FILE'PAGES IS EASILY CONFUSED WITH DEL'FILE'PAGE.

})INCLUDE GLOBAL'VARIABLES;

})DECLARE INTEGER
})FILE'NUMBER,}'/* TSS FILE NUMBER}7*/
})PAGE'NUMBER;}'/* PAGE (MEMORY PAGE) NUMBER OF THE FILE */



})FUNCTION DEL'SEQ'FILE(FILE'NUMBER), FRETURN;

})PAGE'NUMBER _ 0;
}(WHILE PAGE'NUMBER # -1 DO;
},DEL'FILE'PAGE(FILE'NUMBER, PAGE'NUMBER//
}-DISTRESS);
},PAGE'NUMBER _ NEXT'FILE'PAGE(FILE'NUMBER, PAGE'NUMBER//
}-DISTRESS);
}(ENDFOR;
}(SET'FILE'LENGTH(FILE'NUMBER, 0//DISTRESS);

})RETURN;


})END;

}(PROGRAM MAP'IN'NEXT'PAGE;

*}&THIS FUNCTION SETS THINGS UP SO THAT ANOTHER PAGE MAY BE READ BY
* ACQUIRING A PMT INDEX FOR THE NEXT PAGE AND MAPPING IT IN.}"IF IT IS
* SUCCESSFUL IN DOING THAT, THE FUNCTION RETURNS THE STRING DESCRIPTOR
* FOR THE STRING WHICH OVERLAYS THE PAGE OF THE FILE AND A FLAG SIGNAL-
* WHETHER THE FILE HAS BEEN FULLY READ.}"THIS FUNCTION FAILS ONLY ON
* INTERNAL ERRORS.

})INCLUDE GLOBAL'VARIABLES;

})DECLARE INTEGER
})CHAR;}./* A CHARACTER READ FROM THE FILE}(*/

})DECLARE POINTER
})FILE;}./* POINTER TO THE FILE WINDOW},*/

})DECLARE STRING
})INPUT'DUMMY;}'/* STRING THAT CHARACTERS ARE READ FROM}"*/




})STRING FUNCTION MAP'IN'NEXT'PAGE(FILE), FRETURN;

* IS THE FILE WINDOW AVAILABLE?}"IS THE FILE OPEN FOR INPUT?
})WARNING IF NOT FILE.WINDOW'IN'USE OR FILE.OPERATION
})OR FILE.CHARS'LEFT < 0;

})IF FILE.CHARS'LEFT = 0 DO;
},SETUP'KLUDGE(INPUT'DUMMY, 0, FILE.WINDOW'ADDRESS,
}-FILE.CHARACTER'SIZE// FRETURN);
},RETURN (INPUT'DUMMY, YES);
}(ENDIF;
}(FILE.PAGE'IN'WINDOW _ FILE.PAGE'IN'WINDOW + 1;
}(CLEAR'PMT(FILE.PMT'INDEX//DISTRESS);
}(MOVE'PAGE'PMT(FILE.FILE'NUM, FILE.PAGE'IN'WINDOW, FILE.PMT'INDEX//
})DISTRESS);

* IF THERE'S MORE THAN A PAGE LEFT
})IF FILE.CHARS'LEFT > FILE.CHARS'PER'PAGE DO;
},SETUP'KLUDGE(INPUT'DUMMY, FILE.CHARS'PER'PAGE,
}-FILE.WINDOW'ADDRESS, FILE.CHARACTER'SIZE// FRETURN);
},INPUT'DUMMY$WP _ INPUT'DUMMY$EP;
},FILE.CHARS'LEFT _ FILE.CHARS'LEFT - FILE.CHARS'PER'PAGE;

* IF IT'S THE LAST PAGE
})ELSE DO;
},INPUT'DUMMY _ DET'END'OF'FILE(FILE// FRETURN);
}(ENDIF;
}(RETURN (INPUT'DUMMY, NO);


})END;

}(PROGRAM CREATE'NEW'PAGE;

*}&THIS FUNCTION CREATES A NEW FILE PAGE SO THAT MORE CHARACTERS CAN
* BE WRITTEN OUT TO THE FILE.}"IT RESETS THE STRING OUTPUT'DUMMY SO MORE
* CHARACTERS CAN BE WRITTEN INTO IT AND OVERLAYS THE STRING ON THE PAGE
* IT HAS JUST CREATED.}"THE LENGTH OF THE FILE KEPT IN THE WINDOW IS
* INCREMENTED BY A PAGE WORTH OF CHARACTERS.}"IF THE PAGE ISN'T FILLED,
* CLOSE'SEQ'FILE SETS THE EXACT LENGTH WHEN IT TRIES TO CLOSE THE FILE.
* THIS FUNCTION FAILS IF ANY OF THE MONITOR CALLS IT USES FAILS.

})INCLUDE GLOBAL'VARIABLES;

})DECLARE POINTER
})FILE;}./* A POINTER TO THE FILE WINDOW}**/

})DECLARE STRING
})OUTPUT'DUMMY;}&/* THE STRING THAT THE CHARACTERS WILL}#*/
/*}#BE WRITTEN INTO}5*/



})STRING FUNCTION CREATE'NEW'PAGE(FILE), FRETURN;

* IS THE FILE REALLY OPEN?}"IS IT OPEN FOR OUTPUT?
})WARNING IF NOT FILE.WINDOW'IN'USE OR NOT FILE.OPERATION;

* DO THINGS TO MAP IN A NEW PAGE INTO THE WINDOW
})FILE.PAGE'IN'WINDOW _ FILE.PAGE'IN'WINDOW + 1;
}(CREATE'FILE'PAGE(FILE.FILE'NUM, FILE.PAGE'IN'WINDOW//
})DISTRESS);
}(CLEAR'PMT(FILE.PMT'INDEX//DISTRESS);
}(MOVE'PAGE'PMT(FILE.FILE'NUM, FILE.PAGE'IN'WINDOW, FILE.PMT'INDEX//
})DISTRESS);
}(SETUP'KLUDGE(OUTPUT'DUMMY, FILE.CHARS'PER'PAGE,
})FILE.WINDOW'ADDRESS, FILE.CHARACTER'SIZE// FRETURN);

})FILE.LENGTH'IN'CHARS _ FILE.PAGE'IN'WINDOW*FILE.CHARS'PER'PAGE;
}(RETURN OUTPUT'DUMMY;



})END;

}(PROGRAM PREPARE'APPEND;

*}&THIS FUNCTION IS A SPECIAL CASE OF MAP'IN'NEXT'PAGE WHERE THE
* PAGE WHICH WILL BE MAPPED INTO THE WINDOW IS THE LAST PAGE OF THE FILE.

})INCLUDE GLOBAL'VARIABLES;

})DECLARE INTEGER
})LAST'PAGE;})/* THE LAST PAGE OF THE FILE}-*/

})DECLARE POINTER
})FILE;}./* A POINTER TO THE FILE WINDOW}**/

})DECLARE STRING
})APPEND'DESC;}'/* THE STRING DESCRIPTOR SET UP SO THAT}"*/
/*}#THE FILE CAN HAVE MORE CHARACTERS}#*/
/*}#APPENDED TO IT}6*/




})STRING FUNCTION PREPARE'APPEND(FILE, LAST'PAGE), FRETURN;

* IS THE FILE REALLY OPEN?}"IS IT OPEN FOR OUTPUT?
})WARNING IF NOT FILE.WINDOW'IN'USE OR
})FILE.OPERATION # APPEND'FILE;

* DO THINGS TO MAP IN A NEW PAGE INTO THE WINDOW
})FILE.PAGE'IN'WINDOW _ LAST'PAGE;
}(CLEAR'PMT(FILE.PMT'INDEX//DISTRESS);
}(MOVE'PAGE'PMT(FILE.FILE'NUM, FILE.PAGE'IN'WINDOW, FILE.PMT'INDEX//
})DISTRESS);
*}&CHANGE THE CHARACTER COUNT SO DET'END'OF'FILE DOESN'T CREATE A
* STRING OVER A PAGE LONG.
})FILE.CHARS'LEFT _ FILE.CHARS'LEFT - FILE.CHARS'PER'PAGE*LAST'PAGE;
}(APPEND'DESC _ DET'END'OF'FILE(FILE// FRETURN);
*}&MOVE THE END POINTER OF THE STRING SO THAT THE STRING IS A WHOLE
* PAGE LONG.
})APPEND'DESC$EP _ INCDES(APPEND'DESC$BP, FILE.CHARS'PER'PAGE);
}(FILE.LENGTH'IN'CHARS _ FILE.CHARS'PER'PAGE*(FILE.PAGE'IN'WINDOW);

})RETURN APPEND'DESC;



})END;

}(PROGRAM MY'TERMINAL'''IO;

*}&THIS PROGRAM BLOCK CONTAINS THE TERMINAL INPUT AND OUTPUT
* FUNCTIONS.}"THESE FUNCTIONS DON'T HAVE FRETURNS, BUT CALL THE FUNCTION
* SYSTEM'ERROR WHICH WILL RETURN IMMEDIATELY IF THE FLAG DEBUGGING ISN'T
* SET, WHICH MAY TOTALLY SCREW THINGS UP.}"HOWEVER, ALL CALLS TO THESE
* FUNCTION ARE MADE ONLY IF DEBUGGER HAS BEEN SET.

})INCLUDE GLOBAL'VARIABLES;

})DECLARE CHARACTER
})CHAR;}./* THE CHARACTER TO INPUT OR OUTPUT}&*/

})DECLARE STRING
})INPUT,}-/* THE STRING READ IN FROM THE TERMINAL}"*/
})OUTPUT;},/* THE STRING TO OUTPUT TO THE TERMINAL}"*/



* IF THE FUNCTION FAILS, THE CHARACTER RETURNED WILL BE A BLANK
})CHARACTER FUNCTION INPUT'CHARACTER();

})CHAR _ READ'CHAR(-1, 0//
})ERROR'MESSAGE(7) & RETURN 307B:ERROR'CODE,ERROR'NUMBER);
}(PRINT'CHAR(-1, CHAR,0//
})SYSTEM'ERROR(): CHAR,ERROR'CODE,ERROR'NUMBER);
}(START'OUTPUT(-1,0//SYSTEM'ERROR(): ERROR'CODE, ERROR'NUMBER);
}(RETURN CHAR;

})UNKNOWN FUNCTION OUTPUT'CHARACTER(CHAR);
}(PRINT'CHAR(-1, CHAR, 0//
})SYSTEM'ERROR(): CHAR, ERROR'CODE, ERROR'NUMBER);
}(START'OUTPUT(-1, 0//SYSTEM'ERROR(): ERROR'CODE, ERROR'NUMBER);
}(RETURN;



*}&IF THE FUNCTIONS FAILS, THE STRING RETURNED WILL BE WHATEVER
* WAS IN INPUT AT THAT POINT
})STRING FUNCTION INPUT'STRING(INPUT);
}(INPUT _ READ'LINE(-1, INPUT, "", 0//
})SYSTEM'ERROR() & INPUT: INPUT, ERROR'CODE, ERROR'NUMBER);
}(RETURN INPUT;


})UNKNOWN FUNCTION OUTPUT'STRING(OUTPUT);
}(PRINT'STRING(-1, OUTPUT, 0//
})SYSTEM'ERROR(): OUTPUT, ERROR'CODE, ERROR'NUMBER);
}(RETURN;


})END;

}(PROGRAM OUTPUT'NUMBER;

*}'PROGRAM PRINTS OUT THE NUMBER PASSED TO IT ON THE TTY IN
* BASE 10.


})DECLARE INTEGER NUMBER;},/* THE NUMBER TO BE PRINTED */

})DECLARE STRING S(10);}./* STRING TO BE PRINTED}%*/

})FUNCTION OUTPUT'NUMBER(NUMBER);

})CNS(NUMBER,S,0,10//EXIT());

})PUTA(S,0);

})RETURN;

})END;

}(PROGRAM PUTA;

*}&THIS PROGRAM TYPES OUT THE STRING PASSED TO IT TO THE TELETYPE
*}"FOLLOWED BY A NUMBER OF LINE FEEDS, SPECIFIED BY THE SECOND ARGUMENT.

})DECLARE STRING S, TEMP(200);

})DECLARE INTEGER
})I,
})N;

})DECLARE CHARACTER
})CHAR,
})CR _ 155B,
})LF _ 152B;


})UNKNOWN MONITOR SP'RETURN _ 116;


})FUNCTION PUTA(S,N);

})FOR I _ 1 TO LENGTH(S) DO;
},CHAR _ GCI(S//FAILED);
},WCI(CHAR,TEMP//FAILED);
}(ENDFOR;

})WCI(CR,TEMP//FAILED) IF N # 0;

})FOR I _ 1 TO N DO;
},WCI(LF,TEMP//FAILED);
}(ENDFOR;

})OUTPUT'STRING(TEMP);

})RETURN;

FAILED:}"OUTPUT'STRING("",2//BAD);
}(OUTPUT'STRING("OUTPUT FAILURE",1//BAD);

*}&RETURN TO MONITOR

})SP'RETURN(//BAD);

BAD:}%EXIT();

})END;

}(PROGRAM SETUP'KLUDGE;

*}&THIS FUNCTION DOES WHAT SETUP OUGHT TO DO -- TAKE A VARIABLE
* CHARACTER SIZE.}"UNFORTUNATELY, THE ONLY WAY IT CAN DO IT IS BY DOING
* A SETUP FOR EACH POSSIBLE CHARACTER SIZE.

})INCLUDE STRING'DEFS;

})DECLARE INTEGER
})BEGIN'ADDRESS,
})CHARACTER'SIZE,
})LENGTH;

})DECLARE STRING
*})KLUDGE,
})WORKING'NAME;



})UNKNOWN FUNCTION SETUP'KLUDGE(STRING @KLUDGE, LENGTH, BEGIN'ADDRESS,
})CHARACTER'SIZE), FRETURN;

})WORKING'NAME _ KLUDGE.STRING'DESC;
}(IF CHARACTER'SIZE = 6 DO;
},SETUP(WORKING'NAME, LENGTH, BEGIN'ADDRESS, 6);
}(ELSEIF CHARACTER'SIZE = 8 DO;
},SETUP(WORKING'NAME, LENGTH, BEGIN'ADDRESS, 8);
}(ELSEIF CHARACTER'SIZE = 12 DO;
},SETUP(WORKING'NAME, LENGTH, BEGIN'ADDRESS, 12);
}(ELSEIF CHARACTER'SIZE = 24 DO;
},SETUP(WORKING'NAME, LENGTH, BEGIN'ADDRESS, 24);
}(ELSE DO;
},FRETURN;
}(ENDIF;
}(KLUDGE.STRING'DESC _ WORKING'NAME;

})RETURN;



})END;

}(PROGRAM CNS;

*}&THIS FUNCTION APPENDS A SINGLE PRECISION INTEGER TO A STRING
* AFTER CONVERTING THE INTEGER FROM INTERNAL REPRESENTATION TO CHAR-
* ATER REPRESENTATION.}"THIS FUNCTION FAILS IF THE BASE THE NUMBER WILL
* BE CONVERTED TO IS OUTSIDE THE ALLOWABLE RANGE OF 2 TO 36, INCLUSIVE,
* OR IF THE STRING PASSED TO IT CAN'T HOLD ALL THE CHARACTERS OF THE 
* BER.

})INCLUDE STRING'DEFS;

})DECLARE INTEGER
})BASE,}./* THE BASE THE NUMBER WILL BE CONVERTED */
/*}#TO}B*/
})CHAR,}./* THE CHARACTER TO WRITE INTO THE STRING*/
})COUNTER,}+/* JUST A COUNTER}8*/
})LENGTH'TEMP,}'/* LENGTH OF THE STRING TEMP}-*/
})NUMBER,},/* THE NUMBER TO CONVERT}1*/
})NUMBER'OF'CHARS,}#/* BITS (18-23) OF SIGN'NUM'CHARS}(*/
})SIGN'FLAG,})/* SET IF NEGATIVE NUMBERS ARE TO BE}%*/
/*}#CONVERTED SIGNED}4*/
})SIGN'NUM'CHARS;}$/* DETERMINES IF THE NUMBER WILL BE}&*/
/*}#SIGNED AND HOW MANY CHARACTERS TO}#*/
/*}#GENERATE.}"IF IT IS 0, IT WILL BE}#*/
/*}#CONVERTED SIGNED AND WITHOUT PAD-}#*/
/*}#DING OR TRUNCATION}2*/

})DECLARE STRING
})TEMP (24),})/* A TEMPORARY STRING EACH DIGIT IS}&*/
})WORKING'NAME;}&/* TO KEEP SPL HAPPY}5*/
/*}#WRITTEN INTO}8*/



})UNKNOWN FUNCTION CNS(NUMBER, STRING @STRING'CREATED,
})SIGN'NUM'CHARS, BASE), FRETURN;

})FRETURN IF BASE < 2 OR BASE > 36;
}(WORKING'NAME _ STRING'CREATED.STRING'DESC;
}(SIGN'FLAG _ (-1 IF SIGN'NUM'CHARS >= 0 AND NUMBER < 0 ELSE 0);
}(NUMBER _ -NUMBER IF SIGN'FLAG;

* BE CLEVER AND WRITE THE STRING BACKWARDS
})TEMP$RP _ TEMP$WP _ TEMP$EP;

})IF NUMBER # 0 DO;
},WHILE NUMBER # 0 DO;
* TRIED TO USE MOD HERE, BUT FOR SOME REASON, IT DIDN'T WORK OUT RIGHT
}1.LDA NUMBER, LSHD -23, DIV BASE, STA NUMBER, STB CHAR;
}0WCD(CHAR + ('0' IF CHAR < 10 ELSE 'A' - 10), TEMP);
},ENDFOR;
}(ELSE DO;
},WCD('0', TEMP);
}(ENDIF;

})WCD('-', TEMP) IF SIGN'FLAG;

* ALL WE NEED NOW IS HOW MANY CHARACTERS TO GENERATE
})NUMBER'OF'CHARS _ SIGN'NUM'CHARS A' 77B;
}(LENGTH'TEMP _ LENGTH(TEMP);

* TRUNCATE CHARACTERS IF NECESSARY
})IF NUMBER'OF'CHARS # 0 AND NUMBER'OF'CHARS < LENGTH'TEMP DO;
},TEMP$RP _ INCDES(TEMP$EP, -NUMBER'OF'CHARS);

* OR PAD
})ELSEIF NUMBER'OF'CHARS # 0 AND NUMBER'OF'CHARS > LENGTH'TEMP DO;
},FOR COUNTER _ LENGTH'TEMP + 1 TO NUMBER'OF'CHARS DO;
}0WCI(' ', WORKING'NAME// FRETURN);
},ENDFOR;
}(ENDIF;

})FOR COUNTER _ 1 TO LENGTH(TEMP) DO;
},CHAR _ GCI(TEMP);
},WCI(CHAR, WORKING'NAME// FRETURN);
}(ENDFOR;

FINISH:}"STRING'CREATED.WP _ WORKING'NAME$WP;
}(RETURN;


})END;

}(PROGRAM CSN;

*}&THIS FUNCTION TAKES AS ITS FIRST ARGUMENT A STRING WHICH IT
* ATTEMPTS TO CONVERT FROM THE BASE SPECIFIED IN THE SECOND ARGUMENT TO
* AN INTEGER.}"THIS FUNCTION FRETURNS IF THE BASE IS ILLEGAL, IF THE
* STRING IS BLANK, OR THE FIRST CHARACTER ENCOUNTERED CAN'T BE PART
* OF A NUMBER.

})INCLUDE STRING'DEFS;

})DECLARE INTEGER
})BASE,}./* THE RADIX THE REPRESENTATION OF THE}#*/
/*}#NUMBER WILL BE IN}3*/
})BEGINNING'OF'NUM,}"/* THE FIRST CHARACTER POSITION IN THE}#*/
/*}#STRING WHICH IS PART OF THE NUMBER}"*/
})CHAR,}./* JUST A CHARACTER FROM THE STRING}&*/
})COUNTER,}+/* JUST A COUNTER FOR A LOOP}-*/
})DIGIT,}-/* ONE CHARACTER TO BE WRITTEN INTO THE}"*/
/*}$STRING}=*/
})NEGATIVE'NUM,}&/* FLAG SET IF THE NUMBER IS NEGATIVE}$*/
})NUMBER,},/* THE NUMBER THE STRING WILL BE})*/
/*}#CONVERTED TO}8*/
})POWER,}-/* SPECIFIES THE EXPONENT TO THE BASE}$*/
})POWER'DONE;}(/* FLAG SET WHEN THE POWER IS CALCULATED */
/*}#FOR THE FIRST TIME}2*/

})DECLARE STRING
*})OBJECT,
})WORKING'NAME;}&/* TO KEEP SPL HAPPY}5*/



})FUNCTION CSN(STRING @OBJECT, BASE), FRETURN;

})FRETURN IF BASE < 2 OR BASE > 36;
}(WORKING'NAME _ OBJECT.STRING'DESC;

* INITIALIZE FLAGS
})NEGATIVE'NUM _ POWER'DONE _ 0;

* INITIALIZE VARIABLES
})POWER _ 0;
}(CHAR _ ' ';

* SKIP OVER LEADING BLANKS
})CHAR _ GCI(WORKING'NAME// FRETURN) WHILE CHAR = ' ';

* DETERMINE THE SIGN OF THE NUMBER
})IF CHAR = '-' DO;
},NEGATIVE'NUM _ -1;
}(ELSEIF CHAR # '+' DO;
},WCD (CHAR, WORKING'NAME);
}(ENDIF;

* REMEMBER WHERE WE ARE IN CASE WE HAVE TO DO IT OVER
})BEGINNING'OF'NUM _ WORKING'NAME$RP;

*}&GET A CHARACTER, CONVERT IT TO A NUMBER AND ADD IT TO A SUM
* (CONTROL PASSES BACK TO HERE IF WE FIND OUT THAT WE HAVE BEEN
* ASSUMING THE WRONG BASE)
AGAIN:}#NUMBER _ 0;
}(WHILE 1 DO;
},CHAR _ GCI(WORKING'NAME//PAU);
},IF CHAR >= '0' AND CHAR <= '9' DO;
}0DIGIT _ CHAR - '0';
},ELSEIF CHAR >= 'A' AND CHAR <='Z' DO;
}0DIGIT _ CHAR - ('A' - 10);
},ELSE DO;
}0FRETURN IF LNGDES(BEGINNING'OF'NUM, WORKING'NAME$RP) = 1
}1ELSE GOTO INVALID;
},ENDIF;
},GOTO INVALID IF DIGIT >= BASE;
},NUMBER _ NUMBER*BASE + DIGIT;
}(ENDFOR;

* TEST ALL CHARACTERS WHICH AREN'T DIGITS OF THE NUMBER
INVALID:
}(IF BASE <= 10 AND CHAR = 'B' OR CHAR = 'D' DO;
},IF POWER'DONE DO; * DO WE KNOW WHAT THE NEXT CHARACTER IS
},CHAR _ GCI(WORKING'NAME);
},ELSE DO; * NO, WE HAVEN'T BEEN THROUGH HERE BEFORE
},POWER'DONE _ -1;
}0POWER _ GCI(WORKING'NAME//NO'POWER);
}0IF POWER >= '0' AND POWER <= '9' DO;
}4POWER _ POWER - '0';
}0ELSE DO;
}4WCD(POWER, WORKING'NAME);
}0ENDIF;
NO'POWER:}'IF CHAR = 'B' AND BASE # 8 DO;
}4BASE _ 8;
}0ELSEIF CHAR = 'D' AND BASE # 10 DO;
}4BASE _ 10;
}0ELSE DO;
}4GOTO PAU;
}0ENDIF;
}0WORKING'NAME$RP _ BEGINNING'OF'NUM;
}0GOTO AGAIN;
},ENDIF;
}(ELSE DO;
},WCD(CHAR, WORKING'NAME);
}(ENDIF;

PAU:}%NUMBER _ NUMBER*BASE FOR COUNTER _ 1 TO POWER;
}(OBJECT.RP _ WORKING'NAME$RP;
}(RETURN (-NUMBER IF NEGATIVE'NUM ELSE NUMBER);


})END;

}(PROGRAM APPEND;

*}&THIS PROGRAM BLOCK TAKES AS ITS ARGUMENTS TWO STRINGS WHICH IT
* ATTEMPTS TO CONCATENATE TOGETHER.}"THERE ARE TWO ENTRY POINTS TO THE
* PROGRAM, SCOPY, AND APPEND.}"SCOPY IS JUST A SPECIAL CASE OF APPEND
* IN WHICH ONE STRING WILL BE COPIED TO THE BEGINNING OF THE OTHER
* STRING.
*}&I TRIED TO BE CONSISTENT AND DECLARE ALL VARIABLES EXPLICITLY,
* IN "DECLARE" STATEMENTS, BUT THERE SEEM TO BE PROBLEMS WITH DECLARING
* A STRING WHICH WILL BE AN ARGUMENT TO A FUNCTION AND LATER IN THE
* FUNCTION DEFINITION, INFORMING SPL THAT THAT STRING WILL BE CALLED
* BY WHAT I CONSIDER TO BE CALL BY NAME.
*}&THIS FUNCTION FAILS IF THE TWO STRINGS HAVE DIFFERENT CHARACTER
* SIZES OR THE FIRST STRING ISN'T LARGE ENOUGH TO HOLD THE SECOND.}"IF
* THE FUNCTION DOES FAIL, NONE OF THE ARGUMENTS TO THE FUNCTION ARE
* CHANGED, IF IT SUCCEEDS, ONLY THE FIRST IS CHANGED.}"THIS WILL BE
* STANDARD FOR MOST STRING MANIPULATION FUNCTIONS.
*}&THE STRING MANIPULATION FUNCTIONS WILL FAIL TO DO WHAT THE PRO-
* GRAMMER WANTS IF THE ARGUMENT IS BEING CALLED BY NAME AND IT IS COM-
* PLEX (SUCH AS AN ELEMENT OF A STRING ARRAY).}"THE REASON IS THAT SPL
* WILL CREATE A TEMPORAY STRING DESCRIPTOR AND PASS THAT AS THE ARGUMENT.

})INCLUDE STRING'DEFS;

})DECLARE STRING
})ADDENDUM,}*/* THE STRING FROM WHICH CHARACTERS ARE}"*/
/*}#COPIED INTO THE FIRST ARGUMENT}&*/
*})OBJECT,},/* THE STRING TO WHICH CHARACTERS WILL}#*/
/*}#BE COPIED};*/
})WORKING'NAME;}&/* TO KEEP SPL HAPPY}5*/

})DECLARE INTEGER
})COUNTER,
})LENGTH'ADDENDUM;}#/* LENGTH OF THE STRING ADDENDUM})*/



* SCOPY - COPY THE SECOND STRING INTO THE FIRST
})UNKNOWN FUNCTION SCOPY(STRING @OBJECT, ADDENDUM), FRETURN;
}(OBJECT.WP _ OBJECT.RP _ OBJECT.BP;

* APPEND - APPEND THE SECOND STRING TO THE FIRST
})UNKNOWN FUNCTION APPEND(STRING @OBJECT, ADDENDUM), FRETURN;
}(WORKING'NAME _ OBJECT.STRING'DESC;
}(FRETURN IF ADDENDUM$CHAR'SIZE # WORKING'NAME$CHAR'SIZE;
}(LENGTH'ADDENDUM _ LENGTH(ADDENDUM);
}(FRETURN IF /* THE STRING WON'T FIT INTO OBJECT}&*/
})LENGTH'ADDENDUM > LNGDES(WORKING'NAME$WP, WORKING'NAME$EP);
}(WCI(GCI(ADDENDUM), WORKING'NAME) FOR COUNTER _ 1 TO LENGTH'ADDENDUM;
}(OBJECT.WP _ WORKING'NAME$WP;
}(RETURN;


})END;

}(PROGRAM LEXICAL'COMPARES;

*}'THIS PROGRAM BLOCK CONTAINS THE FUNCTIONS WHICH PERFORM STRING
* COMPARISONS. THE MAJOR FUNCTION IS LGT WHICH TAKES AS ITS ARGUMENTS
* TWO STRINGS WHICH IT COMPARES TO SEE IF THE FIRST IF LEXICALLY GREATER
* THAN THE SECOND. IT DETERMINES THIS BY COMPARING THE 940 CHARCTER
* CODES OF THEIR CHARACTERS. THE FUNCTION FAILS IF THE TWO STRINGS HAVE
* DIFFERENT CHARACTER SIZES. IF THE SECOND STRING IS LEXICALLY LESS
* THAN THE FIRST, THE FUNCTION RETURNS -1, OTHERWISE 0.

})INCLUDE STRING'DEFS;

})DECLARE CHARACTER
})CHAR1,
})CHAR2;

})DECLARE STRING
})A'STRING,
})A'LESSER'STRING;}#/* FOR THE FUNCTION TO RETURN -1 ANYWAY}#*/


})FUNCTION LGT(A'STRING, A'LESSER'STRING), FRETURN;

})FRETURN IF A'STRING$CHAR'SIZE # A'LESSER'STRING$CHAR'SIZE;

})WHILE 1 DO;
* READ FROM THE SUPPOSEDLY GREATER ONE FIRST TO TAKE CARE OF THE
* EQUALITY CONDITION

}-CHAR1 _ GCI(A'STRING// RETURN 0);
},CHAR2 _ GCI(A'LESSER'STRING// RETURN -1);
},IF CHAR1 > CHAR2 DO;
}0RETURN -1;
},ELSEIF CHAR1 < CHAR2 DO;
}0RETURN 0;
},ENDIF;

})ENDFOR;


})FUNCTION LLE(A'STRING, A'LESSER'STRING), FRETURN;
}(RETURN (N' LGT(A'STRING, A'LESSER'STRING// FRETURN));


})FUNCTION LLT(A'LESSER'STRING, A'STRING), FRETURN;
}(RETURN LGT(A'STRING, A'LESSER'STRING// FRETURN);


})FUNCTION LGE(A'LESSER'STRING, A'STRING), FRETURN;
}(RETURN (N' LGT(A'STRING, A'LESSER'STRING// FRETURN));


})END;

}(PROGRAM REPEAT;

*}&THIS FUNCTION TAKES THREE ARGUMENTS, THE FIRST OF WHICH SPECIFIES
* THE STRING TO BE WRITTEN INTO AND THE SECOND SPECIFIES THE STRING TO
* BE COPIED, AND THE THIRD SPECIFIES HOW MANY TIMES THE SECOND ARGUMENT
* IS TO BE COPIED INTO THE SECOND.}"THE FUNCTION FAILS IF THE STRINGS
* HAVE DIFFERENT CHARACTER SIZES OR THE FIRST ARGUEMENT ISN'T LONG
* ENOUGH TO HOLD THE SECOND ARGUMENT THE SPECIFIED NUMBER OF TIMES.
* THE USUAL CONVENTIONS ABOUT THE STATUS OF THE ARGUMENTS HOLD.

})INCLUDE STRING'DEFS;

})DECLARE INTEGER
})COUNTER0,
})COUNTER1,
})LENGTH'REFERENCE,
})NUMBER'OF'CHARS,}#/* THE TOTAL NUMBER OF CHARACTERS TO BE}"*/
/*}#WRITTEN INTO THE FIRST ARGUMENT}%*/
})NUMBER'OF'TIMES,
})REFERENCE'SAVE;

})DECLARE STRING
*})OBJECT,},/* STRING TO APPEND TO}3*/
})REFERENCE,})/* STRING TO COPY FROM}3*/
})WORKING'NAME;



})UNKNOWN FUNCTION REPEAT(STRING @OBJECT, REFERENCE,
})NUMBER'OF'TIMES), FRETURN;

})FRETURN IF NUMBER'OF'TIMES < 0;
}(WORKING'NAME _ OBJECT.STRING'DESC;
}(FRETURN IF REFERENCE$CHAR'SIZE # WORKING'NAME$CHAR'SIZE;

})LENGTH'REFERENCE _ LENGTH(REFERENCE);
}(NUMBER'OF'CHARS _ NUMBER'OF'TIMES*LENGTH(REFERENCE);
}(FRETURN IF LNGDES(WORKING'NAME$WP, WORKING'NAME$EP) <
})NUMBER'OF'CHARS;

})RETURN IF NUMBER'OF'CHARS = 0;
}(REFERENCE'SAVE _ REFERENCE$RP;
}(FOR COUNTER0 _ 1 TO NUMBER'OF'TIMES DO;
},WCI(GCI(REFERENCE), WORKING'NAME) FOR
}-COUNTER1 _ 1 TO LENGTH'REFERENCE;
},REFERENCE$RP _ REFERENCE'SAVE;
}(ENDFOR;

})OBJECT.WP _ WORKING'NAME$WP;

})RETURN;


})END;

}(PROGRAM COMPARE'STRING;

*}&THIS FUNCTION COMPARES TWO STRING AND RETURNS -1 IF THEY ARE
* IDENTICAL AND 0 IF THEY AREN'T.}"THIS FUNCTION FAILS IF THE TWO STRINGS
* DON'T HAVE THE SAME CHARACTER SIZES.

})INCLUDE STRING'DEFS;

})DECLARE INTEGER
})CHAR1,},/* A CHARACTER READ FROM THE STRING FIRST */
})CHAR2,},/* A CHARACTER READ FROM THE STRING}'*/
/*}#SECOND}?*/
})COUNT,},/* JUST A COUNTER FOR A FOR LOOP}**/
})LENGTH'FIRST;}%/* THE LENGTH OF THE STRING FIRST})*/

})DECLARE STRING
})FIRST,
})SECOND;


})FUNCTION COMPARE'STRING(FIRST, SECOND), FRETURN;

})CATASTROPHE IF FIRST$CHAR'SIZE # SECOND$CHAR'SIZE;
}(LENGTH'FIRST _ LENGTH(FIRST);

})IF LENGTH'FIRST # LENGTH(SECOND) DO;
},RETURN 0;
}(ELSE DO;
},FOR COUNT _ 1 TO LENGTH'FIRST DO;
}0CHAR1 _ GCI(FIRST);
}0CHAR2 _ GCI(SECOND);
}0RETURN 0 IF CHAR1 # CHAR2;
},ENDFOR;
},RETURN -1;
}(ENDIF;



})END;

}(PROGRAM DET'END'OF'FILE;

*}&THIS FUNCTION DETERMINES WHERE THE LAST ACTUAL CHARACTER OF THE
* FILE IS.}"THE MONITOR KNOWS THE LENGTH OF THE FILE IN WORDS.}"THE
* REASON THINGS ARE SO INEXACT IS BECAUSE NO ONE KNEW HOW MANY EOF'S OLD
* SPL WROTE INTO FILES.}"THIS FUNCTION WILL SET THE WRITE POINTER OF
* THE STRING TO THE RIGHT PLACE IF THE FIRST EOF IS ANYWHERE IN THE LAST
* WORD OR EVEN IF THERE IS NO EOF WRITTEN.}"THE FUNCTION RETURNS A
* STRING DESCRIPTOR SETUP TO READ HOWEVER MANY CHARACTERS ARE LEFT IN
* THE FILE.

})INCLUDE GLOBAL'VARIABLES;

})DECLARE INTEGER
})CHAR,}./* A CHARACTER READ FROM THE STRING}&*/
})COUNT;}-/* JUST A COUNTER FOR A FOR LOOP}(*/

})DECLARE PARAMETER
})CHARS'TO'CHECK _ 3;/* THE SPAN OF CHARACTERS CHECKED WHILE}"*/
/*}#LOOKING FOR THE EOF CHARACTER}'*/

})DECLARE POINTER
})FILE;}./* A POINTER TO THE WINDOW IN USE}(*/

})DECLARE STRING
})LAST'FILE'PAGE;}$/* THE STRING WHICH OVERLAYS THE WORDS}#*/
/*}#OF THE FILE}9*/



})STRING FUNCTION DET'END'OF'FILE(FILE), FRETURN;

})SETUP'KLUDGE(LAST'FILE'PAGE, FILE.CHARS'LEFT,
})FILE.WINDOW'ADDRESS, FILE.CHARACTER'SIZE// FRETURN);
}(LAST'FILE'PAGE$WP _ LAST'FILE'PAGE$EP;
}(LAST'FILE'PAGE$RP _ INCDES(LAST'FILE'PAGE$EP, -CHARS'TO'CHECK);

})FOR COUNT _ 1 TO CHARS'TO'CHECK DO;
},GOTO END'OF'FILE IF (CHAR _ GCI(LAST'FILE'PAGE) A' 177B = EOF);
}(ENDFOR;
END'OF'FILE:
}(LAST'FILE'PAGE$WP _ INCDES(LAST'FILE'PAGE$RP, -1) IF CHAR = EOF;
}(SETR(LAST'FILE'PAGE, 0);
}(FILE.CHARS'LEFT _ 0;

})RETURN LAST'FILE'PAGE;


})END;

}(PROGRAM CONS'ARRAY'DESC;

*}&THIS FUNCTION CREATES AN ARRAY DESCRIPTOR GIVEN THE BASE ADDRESS,
* THE NUMBER OF ELEMENTS, ELEMENT SIZE, AND LOWER BOUND.}"THIS FUNCTION
* FAILS IF ONE THE THE ARGUMENTS ARE INVALID.

})INCLUDE ARRAY'DEFS;

})DECLARE ARRAY
})ARRAY'DESC;

})DECLARE FIELD
})MULTIPLIER,}(/* WHAT IT IS DEPENDS ON LEB}-*/
})UPPER'LIMIT;}'/* WHAT IT IS DEPENDS ON LEB}-*/

})DECLARE INTEGER
})BASE'ADDRESS,}&/* FIRST ADDRESS THAT STORAGE BEGINS IN}"*/
})ELEMENT'SIZE,}&/* NUMBER OF WORDS PER ENTRY}-*/
})KLUDGE,
})LARGE'ELEMENT,
})LOWER'BOUND,}'/* AN ARRAY OR AN ARRAYONE}/*/
})NO'OF'ELEMENTS,}$/* NUMBER OF ELEMENTS}4*/
})UPPER'BOUND;}'/* HIGHEST VALID SUBSCRIPT}/*/



})ARRAY FUNCTION CONS'ARRAY'DESC(BASE'ADDRESS, NO'OF'ELEMENTS,
})ELEMENT'SIZE, LOWER'BOUND), FRETURN;

* CHECK THE PARAMETERS PASSED TO SEE IF THEY ARE VALID
})FRETURN IF (BASE'ADDRESS < 0 OR BASE'ADDRESS > (-1)$IAW'ADDRESS);
}(FRETURN IF NO'OF'ELEMENTS < 0;
}(FRETURN IF (ELEMENT'SIZE < 1 OR ELEMENT'SIZE >
})(-1)$ITEM'SIZE'LEB1 + 1);
}(FRETURN IF (LOWER'BOUND # 0 AND LOWER'BOUND # 1);

* SET UP THE FIELDS FOR SMALL OR LARGE ELEMENT CASES
})IF ELEMENT'SIZE <= 4 DO;
},LARGE'ELEMENT _ 0;
},MULTIPLIER _ ITEM'SIZE'LEB0;
},UPPER'LIMIT _ UPPER'BOUND'LEB0;
}(ELSE DO;
},LARGE'ELEMENT _ 1;
},MULTIPLIER _ ITEM'SIZE'LEB1;
},UPPER'LIMIT _ UPPER'BOUND'LEB1;
}(ENDIF;

* COMPUTE AND CHECK UPPER'BOUND
})UPPER'BOUND _ LOWER'BOUND + NO'OF'ELEMENTS - 1;
*}&A CONSTANT OR PARAMETER TAILED WITH A VARIABLE FIELD CAUSES SPL
* TO GENERATE INCORRECT CODE, SO HERE'S THE KLUDGE.
})KLUDGE _ -1;
}(FRETURN IF UPPER'BOUND > KLUDGE$UPPER'LIMIT;

* CONSTRUCT AND RETURN THE DESCRIPTOR
})ARRAY'DESC$IAW'TYPE _ ARRAY'IAW;
}(ARRAY'DESC$INDEXING'ORIGIN _ LOWER'BOUND;
}(ARRAY'DESC$ARRAY'TRAP'BIT _ 0;
}(ARRAY'DESC$LEB _ LARGE'ELEMENT;
}(ARRAY'DESC$MULTIPLIER _ ELEMENT'SIZE - 1;
}(ARRAY'DESC$UPPER'LIMIT _ UPPER'BOUND;
}(ARRAY'DESC$ARRAY'DESC'ADDR _ NORMAL'IAW@IAW'TYPE V'
})INDEXED@IAW'TAG V' 0@IAW'TRAP V' BASE'ADDRESS@IAW'ADDRESS;

})RETURN ARRAY'DESC;


})END;

}(PROGRAM LONG'COMPARE;

*}&THIS PROGRAM BLOCK CONTAINS TWO FUNCTIONS WHICH COMPARE TWO
* OBJECT OF LENGTH GREATER THAN ONE WORD.}"THE FIRST FUNCTION, LONG'-
* COMPARE IS INTENDED TO JUST COMPARE LONGS.}"THE SECOND FUNCTION IS
* MORE GENERAL AND WILL COMPARE BLOCKS OF WORDS STARTING AT THE FIRST
* ARGUMENT AGAINST THOSE STARTING AT THE SECOND ARGUMENT FOR THE NUMBER
* OF WORDS SPECIFIED BY THE THIRD ARGUMENT.

})DECLARE FIELD
})W0(0),
})W1(1);

})DECLARE INTEGER
})CNTRLED'VARIABLE;

})DECLARE LONG
})X,
})Y;

})DECLARE POINTER
})THIS,
})THAT;


})FUNCTION LONG'COMPARE(X, Y);

})IF X$W0 = Y$W0 AND X$W1 = Y$W1 DO;
},RETURN -1;
}(ELSE DO;
},RETURN 0;
}(ENDIF;



})FUNCTION BLOCK'COMPARE(@THIS, @THAT, THIS'MANY);

})FOR CNTRLED'VARIABLE _ 1 TO THIS'MANY DO;
},RETURN 0 IF THIS[CNTRLED'VARIABLE].W0 #
}-THAT[CNTRLED'VARIABLE].W0;
}(ENDFOR;
}(RETURN -1;


})END;

}(PROGRAM ENTRIES;

* THIS PROGRAM BLOCK CONTAINS THE ENTRY POINTS TO THE WHOLE PROGRAM

})INCLUDE ENTRY'DEFS;

})DECLARE INTEGER
})SP'INT'NO = L' [0],
})SP'TRAP'NO = L' [0],
})SP'TRAP'PARAM = L' [1];



* SUB-PROCESS TRAP ENTRY POINT
})FUNCTION SP'TRAP'ENTRY(), SP'ENTRY _ 0;
}(SAVE'STATE(STATE);
}(EXIT();



* INTERRUPT ENTRY POINT
})FUNCTION INTERRUPT'ENTRY(), SP'ENTRY _ 1;
}(SAVE'STATE(STATE);
}(EXIT();



* INITIAL ENTRY POINT
})FUNCTION INITIAL'ENTRY(), SP'ENTRY _ 2;
}(STACK'POINTER _ INITIAL'SP;
}(STACK'LIMIT _ INITIAL'SL;
}(INITIALIZE(1);
}(EXIT();



* CONTINUE ENTRY POINT
})FUNCTION CONTINUE'ENTRY(), SP'ENTRY _ 3;
}(STACK'POINTER _ INITIAL'SP;
}(STACK'LIMIT _ INITIAL'SL;
/*CONTINUE'*/INITIALIZE(0);
}(EXIT();



})END;

}(PROGRAM HELP;
}(FUNCTION HELP();
}(PUTA("HELP!!!!!!!", 1);
BREAK:}"EXIT();
}(END;

}(COMMON FIELD'DESC;

})DECLARE FIELD

})OLD'DATA(0:0,7),
})OLD'COUNT(0:8,11),
})OP'SORT(0:3,10),
})INCRE(0:0,2),
})B'7'7 (0:7,7),
})B'16'19 (0:16,19),
})B'21'23 (0:21,23),
})B'18'19 (0:18,19),
})B'8'23 (0:8,23),
})PSW (0:0,7),
})REG'A (0:8,15),
})REG'B (1:0, 7),
})REG'C (1:8,15),
})REG'D (2:0,7),
})REG'E (2:8,15),
})REG'H (3:0,7),
})REG'L (3:8,15),
})REG'B'C (1:0,15),
})REG'D'E (2:0,15),
})REG'H'L (3:0,15),
})B'20'23 (0:20,23),
})B'23'23 (0:23,23),
})B'15'15 (0:15,15),
})B'16'16 (0:16,16),
})B'19'19 (0:19,19),
})B'16'23 (0:16,23),
})B'8'15 (0:8,15),
})B'0'7 (0:0,7),
})CARRY'BIT (0:7,7),
})SIGN'BIT (0:0,0),
})ZERO'BIT (0:1,1),
})AUX'CARRY (0:3,3),
})PARITY'BIT (0:5,5),
})B'18'20 (0:18,20);


})END;}"/*}"END FIELD'DESC.}"*/

}(COMMON SIMU'VARS;
*
*}"THIS COMMON BLOCK DEFINES ALL GLOBAL VARIABLES USED IN
*}"THE SIMULATOR.}"ALL PERMANENT STORAGE IS DECLARED IN THIS BLOCK.
*
*

*}"THIS DECLARES THE INSTRUCTION OPCODES AND THEIR LENGTH.
*
})DECLARE INTEGER ARRAY INSTR'DATA[256] _
})(16340000B,34360000B,14200000B,14220000B,14240000B,14260000B,24300000B,14320000B);
}(DECLARE INTEGER ARRAY INSTR'DATA[8] _
})(-3440000B,14160000B,14000000B,14020000B,14040000B,14060000B,24100000B,14120000B);
}(DECLARE INTEGER ARRAY INSTR'DATA[16] _
})(-3640000B,36140000B,15160000B,15000000B,15020000B,15040000B,25060000B,15100000B);
}(DECLARE INTEGER ARRAY INSTR'DATA[24] _
})(-2660000B,15140000B,17140000B,16320000B,16700000B,17700000B,21360000B,11760000B);
}(DECLARE INTEGER ARRAY INSTR'DATA[32] _
})(-2020000B,35600000B,35620000B,15640000B,15660000B,15700000B,25720000B,15740000B);
}(DECLARE INTEGER ARRAY INSTR'DATA[40] _
})(-1300000B,16100000B,37500000B,17300000B,17740000B,17100000B,26300000B,11160000B);
}(DECLARE INTEGER ARRAY INSTR'DATA[48] _
})(-7560000B,30620000B,31220000B,11620000B,11720000B,10120000B,20320000B,10520000B);
}(DECLARE INTEGER ARRAY INSTR'DATA[56] _
})(-7060000B,11120000B,31320000B,11520000B,10260000B,10660000B,21260000B,11660000B);
}(DECLARE INTEGER ARRAY INSTR'DATA[64] _
})(17460000B,17660000B,13540000B,16660000B,11700000B,10100000B,10300000B,10500000B);
}(DECLARE INTEGER ARRAY INSTR'DATA[72] _
})(10700000B,11100000B,11300000B,11500000B,10060000B,10460000B,11060000B,11460000B);
}(DECLARE INTEGER ARRAY INSTR'DATA[80] _
})(16640000B,17640000B,16060000B,16440000B,16040000B,17440000B,17240000B,17040000B);
}(DECLARE INTEGER ARRAY INSTR'DATA[88] _
})(16240000B,11640000B,10240000B,10640000B,11240000B,10020000B,10420000B,11020000B);
}(DECLARE INTEGER ARRAY INSTR'DATA[96] _
})(11420000B,13760000B,13600000B,13620000B,13640000B,13660000B,13700000B,13720000B);
}(DECLARE INTEGER ARRAY INSTR'DATA[104] _
})(13740000B,12160000B,12000000B,12020000B,12040000B,12060000B,12100000B,12120000B);
}(DECLARE INTEGER ARRAY INSTR'DATA[112] _
})(12140000B,12360000B,12200000B,12220000B,12240000B,12260000B,12300000B,12320000B);
}(DECLARE INTEGER ARRAY INSTR'DATA[120] _
})(12340000B,12560000B,12400000B,12420000B,12440000B,12460000B,12500000B,12520000B);
}(DECLARE INTEGER ARRAY INSTR'DATA[128] _
})(12540000B,12760000B,12600000B,12620000B,12640000B,12660000B,12700000B,12720000B);
}(DECLARE INTEGER ARRAY INSTR'DATA[136] _
})(12740000B,13160000B,13000000B,13020000B,13040000B,13060000B,13100000B,13120000B);
}(DECLARE INTEGER ARRAY INSTR'DATA[144] _
})(13140000B,13360000B,13200000B,13220000B,13240000B,13260000B,13300000B,13320000B);
}(DECLARE INTEGER ARRAY INSTR'DATA[152] _
})(13340000B,13560000B,13400000B,13420000B,13440000B,13460000B,13500000B,13520000B);
}(DECLARE INTEGER ARRAY INSTR'DATA[160] _
})(11740000B,10140000B,10340000B,10540000B,10740000B,11140000B,11340000B,11540000B);
}(DECLARE INTEGER ARRAY INSTR'DATA[168] _
})(10000000B,15560000B,15400000B,15420000B,15440000B,15460000B,15500000B,15520000B);
}(DECLARE INTEGER ARRAY INSTR'DATA[176] _
})(15540000B,17540000B,16460000B,17220000B,16020000B,16420000B,17020000B,17420000B);
}(DECLARE INTEGER ARRAY INSTR'DATA[184] _
})(16120000B,16520000B,17120000B,17520000B,10560000B,10760000B,16600000B,16220000B);
}(DECLARE INTEGER ARRAY INSTR'DATA[192] _
})(10160000B,17600000B,36400000B,36000000B,37400000B,17200000B,27000000B,10360000B);
}(DECLARE INTEGER ARRAY INSTR'DATA[200] _
})(16160000B,16360000B,36560000B,-1020000B,37160000B,37360000B,27560000B,17760000B);
}(DECLARE INTEGER ARRAY INSTR'DATA[208] _
})(16200000B,14760000B,34600000B,24620000B,34640000B,14660000B,24700000B,14720000B);
}(DECLARE INTEGER ARRAY INSTR'DATA[216] _
})(14740000B,-1040000B,31040000B,27620000B,31440000B,-7740000B,20440000B,11560000B);
}(DECLARE INTEGER ARRAY INSTR'DATA[224] _
})(14560000B,14400000B,34420000B,14440000B,34460000B,14500000B,24520000B,14540000B);
}(DECLARE INTEGER ARRAY INSTR'DATA[232] _
})(16540000B,10200000B,30400000B,10600000B,31000000B,-6600000B,21400000B,11600000B);
}(DECLARE INTEGER ARRAY INSTR'DATA[240] _
})(16260000B,16620000B,36720000B,17320000B,37720000B,17260000B,25360000B,15200000B);
}(DECLARE INTEGER ARRAY INSTR'DATA[248] _
})(15220000B,15240000B,35260000B,15300000B,35320000B,-2440000B,37340000B,17060000B);
}(DECLARE INTEGER ARRAY INSTR'DATA[248] _
})(15220000B,15240000B,35260000B,15300000B,35320000B,-2440000B,37340000B,17060000B);

*}"THIS STRING ARRAY IS USED TO DUMP CORE IN MNEMONIC FORM.
*
})DECLARE STRING(8) ARRAY INSTR'MNEMONICS[256] _
})("NOP", "LXI B", "STAX B", "INX B", "INR B", "DCR B", "MVI B", "RLC");
}(DECLARE STRING(8) ARRAY INSTR'MNEMONICS[8] _
})("TRAP", "DAD B", "LDAX B", "DCX B", "INR C", "DCR C", "MVI C", "RRC");
}(DECLARE STRING(8) ARRAY INSTR'MNEMONICS[16] _
})("TRAP", "LXI D", "STAX D", "INX D", "INR D", "DCR D", "MVI D", "RAL");
}(DECLARE STRING(8) ARRAY INSTR'MNEMONICS[24] _
})("TRAP", "DAD D", "LDAX D", "DCX D", "INR E", "DCR E", "MVI E", "RAR");
}(DECLARE STRING(8) ARRAY INSTR'MNEMONICS[32] _
})("TRAP", "LXI H", "SHLD", "INX H", "INR H", "DCR H", "MVI H", "DAA");
}(DECLARE STRING(8) ARRAY INSTR'MNEMONICS[40] _
})("TRAP", "DAD H", "LHLD", "DCX H", "INR L", "DCR L", "MVI L", "CMA");
}(DECLARE STRING(8) ARRAY INSTR'MNEMONICS[48] _
})("TRAP", "LXI SP", "STA", "INX SP", "INR M", "DCR M", "MVI M", "STC");
}(DECLARE STRING(8) ARRAY INSTR'MNEMONICS[56] _
})("TRAP", "DAD SP", "LDA", "DCX SP", "INR A", "DCR A", "MVI A", "CMC");
}(DECLARE STRING(8) ARRAY INSTR'MNEMONICS[64] _
})("MOV B,B", "MOV B,C", "MOV B,D", "MOV B,E", "MOV B,H", "MOV B,L", "MOV B,M", "MOV B,A");
}(DECLARE STRING(8) ARRAY INSTR'MNEMONICS[72] _
})("MOV C,B", "MOV C,C", "MOV C,D", "MOV C,E", "MOV C,H", "MOV C,L", "MOV C,M", "MOV C,A");
}(DECLARE STRING(8) ARRAY INSTR'MNEMONICS[80] _
})("MOV D,B", "MOV D,C", "MOV D,D", "MOV D,E", "MOV D,H", "MOV D,L", "MOV D,M", "MOV D,A");
}(DECLARE STRING(8) ARRAY INSTR'MNEMONICS[88] _
})("MOV E,B", "MOV E,C", "MOV E,D", "MOV E,E", "MOV E,H", "MOV E,L", "MOV E,M", "MOV E,A");
}(DECLARE STRING(8) ARRAY INSTR'MNEMONICS[96] _
})("MOV H,B", "MOV H,C", "MOV H,D", "MOV H,E", "MOV H,H", "MOV H,L", "MOV H,M", "MOV H,A");
}(DECLARE STRING(8) ARRAY INSTR'MNEMONICS[104] _
})("MOV L,B", "MOV L,C", "MOV L,D", "MOV L,E", "MOV L,H", "MOV L,L", "MOV L,M", "MOV L,A");
}(DECLARE STRING(8) ARRAY INSTR'MNEMONICS[112] _
})("MOV M,B", "MOV M,C", "MOV M,D", "MOV M,E", "MOV M,H", "MOV M,L", "HLT", "MOV M,A");
}(DECLARE STRING(8) ARRAY INSTR'MNEMONICS[120] _
})("MOV A,B", "MOV A,C", "MOV A,D", "MOV A,E", "MOV A,H", "MOV A,L", "MOV A,M", "MOV A,A");
}(DECLARE STRING(8) ARRAY INSTR'MNEMONICS[128] _
})("ADD B", "ADD C", "ADD D", "ADD E", "ADD H", "ADD L", "ADD M", "ADD A");
}(DECLARE STRING(8) ARRAY INSTR'MNEMONICS[136] _
})("ADC B", "ADC C", "ADC D", "ADC E", "ADC H", "ADC L", "ADC M", "ADC A");
}(DECLARE STRING(8) ARRAY INSTR'MNEMONICS[144] _
})("SUB B", "SUB C", "SUB D", "SUB E", "SUB H", "SUB L", "SUB M", "SUB A");
}(DECLARE STRING(8) ARRAY INSTR'MNEMONICS[152] _
})("SBB B", "SBB C", "SBB D", "SBB E", "SBB H", "SBB L", "SBB M", "SBB A");
}(DECLARE STRING(8) ARRAY INSTR'MNEMONICS[160] _
})("ANA B", "ANA C", "ANA D", "ANA E", "ANA H", "ANA L", "ANA M", "ANA A");
}(DECLARE STRING(8) ARRAY INSTR'MNEMONICS[168] _
})("XRA B", "XRA C", "XRA D", "XRA E", "XRA H", "XRA L", "XRA M", "XRA A");
}(DECLARE STRING(8) ARRAY INSTR'MNEMONICS[176] _
})("ORA B", "ORA C", "ORA D", "ORA E", "ORA H", "ORA L", "ORA M", "ORA A");
}(DECLARE STRING(8) ARRAY INSTR'MNEMONICS[184] _
})("CMP B", "CMP C", "CMP D", "CMP E", "CMP H", "CMP L", "CMP M", "CMP A");
}(DECLARE STRING(8) ARRAY INSTR'MNEMONICS[192] _
})("RNZ", "POP B", "JNZ", "JMP", "CNZ", "PUSH B", "ADI", "RST 0");
}(DECLARE STRING(8) ARRAY INSTR'MNEMONICS[200] _
})("RZ", "RET", "JZ", "TRAP", "CZ", "CALL", "ACI", "RST 1");
}(DECLARE STRING(8) ARRAY INSTR'MNEMONICS[208] _
})("RNC", "POP D", "JNC", "OUT", "CNC", "PUSH D", "SUI", "RST 2");
}(DECLARE STRING(8) ARRAY INSTR'MNEMONICS[216] _
})("RC", "TRAP", "JC", "IN", "CC", "TRAP", "SBI", "RST 3");
}(DECLARE STRING(8) ARRAY INSTR'MNEMONICS[224] _
})("RPO", "POP H", "JPO", "XTHL", "CPO", "PUSH H", "ANI", "RST 4");
}(DECLARE STRING(8) ARRAY INSTR'MNEMONICS[232] _
})("RPE", "PCHL", "JPE", "XCHG", "CPE", "TRAP", "XRI", "RST 5");
}(DECLARE STRING(8) ARRAY INSTR'MNEMONICS[240] _
})("RP", "POP PSW", "JP", "DI", "CP", "PUSH PSW", "ORI", "RST 6");
}(DECLARE STRING(8) ARRAY INSTR'MNEMONICS[248] _
})("RM", "SPHL", "JM", "EI", "CM", "TRAP", "CPI", "RST 7");

})DECLARE INTEGER ARRAY INSTR'INCRE[256];

})DECLARE INTEGER ARRAY INSTR'INCRE[0] _
})(1,3,1,1,1,1,2,1);
}(DECLARE INTEGER ARRAY INSTR'INCRE[8] _
})(-1,1,1,1,1,1,2,1);
}(DECLARE INTEGER ARRAY INSTR'INCRE[16] _
})(-1,3,1,1,1,1,2,1);
}(DECLARE INTEGER ARRAY INSTR'INCRE[24] _
})(-1,1,1,1,1,1,2,1);
}(DECLARE INTEGER ARRAY INSTR'INCRE[32] _
})(-1,3,3,1,1,1,2,1);
}(DECLARE INTEGER ARRAY INSTR'INCRE[40] _
})(-1,1,3,1,1,1,2,1);
}(DECLARE INTEGER ARRAY INSTR'INCRE[48] _
})(-1,3,3,1,1,1,2,1);
}(DECLARE INTEGER ARRAY INSTR'INCRE[56] _
})(-1,1,3,1,1,1,2,1);
}(DECLARE INTEGER ARRAY INSTR'INCRE[64] _
})(1,1,1,1,1,1,1,1);
}(DECLARE INTEGER ARRAY INSTR'INCRE[72] _
})(1,1,1,1,1,1,1,1);
}(DECLARE INTEGER ARRAY INSTR'INCRE[80] _
})(1,1,1,1,1,1,1,1);
}(DECLARE INTEGER ARRAY INSTR'INCRE[88] _
})(1,1,1,1,1,1,1,1);
}(DECLARE INTEGER ARRAY INSTR'INCRE[96] _
})(1,1,1,1,1,1,1,1);
}(DECLARE INTEGER ARRAY INSTR'INCRE[104] _
})(1,1,1,1,1,1,1,1);
}(DECLARE INTEGER ARRAY INSTR'INCRE[112] _
})(1,1,1,1,1,1,1,1);
}(DECLARE INTEGER ARRAY INSTR'INCRE[120] _
})(1,1,1,1,1,1,1,1);
}(DECLARE INTEGER ARRAY INSTR'INCRE[128] _
})(1,1,1,1,1,1,1,1);
}(DECLARE INTEGER ARRAY INSTR'INCRE[136] _
})(1,1,1,1,1,1,1,1);
}(DECLARE INTEGER ARRAY INSTR'INCRE[144] _
})(1,1,1,1,1,1,1,1);
}(DECLARE INTEGER ARRAY INSTR'INCRE[152] _
})(1,1,1,1,1,1,1,1);
}(DECLARE INTEGER ARRAY INSTR'INCRE[160] _
})(1,1,1,1,1,1,1,1);
}(DECLARE INTEGER ARRAY INSTR'INCRE[168] _
})(1,1,1,1,1,1,1,1);
}(DECLARE INTEGER ARRAY INSTR'INCRE[176] _
})(1,1,1,1,1,1,1,1);
}(DECLARE INTEGER ARRAY INSTR'INCRE[184] _
})(1,1,1,1,1,1,1,1);
}(DECLARE INTEGER ARRAY INSTR'INCRE[192] _
})(1,1,3,3,3,1,2,1);
}(DECLARE INTEGER ARRAY INSTR'INCRE[200] _
})(1,1,3,-1,3,3,2,1);
}(DECLARE INTEGER ARRAY INSTR'INCRE[208] _
})(1,1,3,2,3,1,2,1);
}(DECLARE INTEGER ARRAY INSTR'INCRE[216] _
})(1,-1,3,2,3,-1,2,1);
}(DECLARE INTEGER ARRAY INSTR'INCRE[224] _
})(1,1,3,1,3,1,2,1);
}(DECLARE INTEGER ARRAY INSTR'INCRE[232] _
})(1,1,3,1,3,-1,2,1);
}(DECLARE INTEGER ARRAY INSTR'INCRE[240] _
})(1,1,3,1,3,1,2,1);
}(DECLARE INTEGER ARRAY INSTR'INCRE[248] _
})(1,1,3,1,3,-1,2,1);

*}"THESE VARIABLES DECLARE THE STRING MESSAGES
*}"TO BE ISSUED DURING ERROR CONDITIONS.
*
})DECLARE STRING(30) ARRAY MESS1[11] _
})("BREAK POINT",
})"NON-EXISTENT INSTRUCTION",
})"MEMORY WRITE ERROR",
})"MEMORY READ ERROR",
})"I/O PORT NOT SUPPORTED",
})"PROGRAM HALT",
})"INTERRUPT INSTRUCTION IGNORED",
})"CNTL-K ON INPUT",
})"CNTL-K ON OUTPUT",
})"CONTROL BREAK",
})"CONTROL TRACE");

})DECLARE STRING(30) ARRAYONE MESS2[9] _
})("IMPROPER OBJECT FILE FORMAT",
})"CONVERSION ERROR",
})"UNEXPECTED EOF DURING LOADING",
})"CHECK SUM ERROR",
})"COMMAND NOT IMPLEMENTED",
})"WHAT?",
})"BREAK POINT NOT FOUND");

})DECLARE STRING(30) ARRAYONE MESS2[8] _
})("EXPRESSION ERROR",
})"MNEMONIC ERROR");

})DECLARE PARAMETER
})MAX'MEM _ 65536, /* DEFINES THE MAXIMUM MEMORY SIZE */
})ACC _ 7;

})DECLARE STRING
})MEMORY;}+/* THE 8080'S MEMORY */

})DECLARE INTEGER ARRAY
*}(SYMBOL TABLE STRING SPACE
})SYMBOL'SPACE[2000],
*}(VALUES OF SYMBOLS
})VALUES[1000],
*}(SORT POINTERS
})SORT'PTRS[1000],
})B'P'TABLE[100],}"/*}"BREAK POINT TABLE}"*/
})OLD'STORE[8],}"/*}"FOR THE DUMP ROUTINE}"*/
*}:CONTAINS THE OLD CONTENTS OF REGISTERS
})REG'STORE[8];}#/*}"REGISTER FILE}"*/

})DECLARE INTEGER
})DUMP'BREAK,
})CONTROL'TRACE,}"/*}"CONTROLS THIS FEATURE}"*/
})CONTROL'BREAK,}"/*}"SIMILAR TO ABOVE}"*/
})CURRENT'LINE,}#/*}"VALUE OF PREVIOUS}"EXPRESSION}"*/
})SYMBOL'START _ @SYMBOL'SPACE[0],
*}(THIS IS A POINTER TO THE START OF THE SYMBOL STRING.
})LAST'SYMBOL,}&/*}"LAST SYMBOL IN SYMBOL TABLE}"*/
})MODE,}-/*}"MODE OF OUTPUT}"*/
})REG'AREA _ @REG'STORE[0],
})NEXT'B'P,}(/*}"POINTER TO NEXT ELEMENT IN}"*/
*}=BREAK POINT TABLE.
})P'COUNTER,}(/*}"PROGRAM COUNTER}"*/
})CURRENT'INSTR,}$/*}"CURRENT INSTRUCTION BEING EXECUTED.}"*/
})STACK;},/*}"STACK POINTER}"*/

})END;}"/*}"END SIMU'VARS.}"*/

}(COMMON MESSAGE'BLOCK;

})DECLARE STRING(60) ARRAYONE MESSAGES[12];
}(DECLARE STRING(60) ARRAYONE MESSAGES[1] _

})("SYMBOL WAS NOT FOUND.",
})"CONVERSION ERROR FOR HEX NUMBER.",
})"CONVERSION ERROR FOR DECIMAL NUMBER.",
})"LITERAL DID NOT FOLLOW AFTER QUOTE.",
})"LABEL IS GREATER THAN 5 CHARACTERS LONG.",
})"LABEL STARTS WITH A NUMBER.",
})"DUPLICATE LABEL FOUND.",
})"NO OPCODE FIELD FOUND.");

})DECLARE STRING(60) ARRAYONE MESSAGES[9] _
})("ILLEGAL OPCODE IN STATEMENT.",
})"2 OPERANDS REQUIRED.}"ONLY ONE FOUND.",
})"REGISTER VALUE SPECIFIED OUT OF RANGE.",
})"OPERAND IS LARGER THAN 8 BITS.");
}(END;

}(PROGRAM ALU;
*
*}"THIS PROGRAM BLOCK CONTAINS ALL THE FUNCTIONS NECESSARY TO
*}"CARRY OUT ALL OF THE 8080 ARITHMETIC AND LOGIC FUNCTIONS.
*

})INCLUDE SIMU'VARS, FIELD'DESC;

})DECLARE INTEGER
})DATA,
})I1, I2, I3, I4;

})FUNCTION ADD(DATA);

})I1 _ REG'AREA.REG'A;
}(I2 _ I1 + DATA;
}(I3 _ I1$B'20'23 + DATA$B'20'23;
}(SET'STATUS(I2, I3);
}(REG'AREA.REG'A _ I2;
}(RETURN;

})FUNCTION ADC(DATA);

})I1 _ REG'AREA.REG'A;
}(I2 _ I1 + DATA + REG'AREA.CARRY'BIT;
}(I3 _ I1$B'20'23 + DATA$B'20'23 + REG'AREA.CARRY'BIT;
}(SET'STATUS(I2, I3);
}(REG'AREA.REG'A _ I2;
}(RETURN;

})FUNCTION SUB(DATA);

})I4 _ (N' DATA)$B'16'23;
}(I1 _ REG'AREA.REG'A;
}(I2 _ I1 + I4 + 1;
}(I3 _ I1$B'20'23 + I4$B'20'23 + 1;
}(SET'STATUS(I2, I3);
*}'REVERSE THE SENSE OF THE CARRY BIT SINCE
*}'THIS IS A SUBTRACTION.
})REG'AREA.CARRY'BIT _ N' REG'AREA.CARRY'BIT;
}(REG'AREA.REG'A _ I2;
}(RETURN;

})FUNCTION SBB(DATA);

})I1 _ REG'AREA.REG'A;
}(I4 _ (DATA + REG'AREA.CARRY'BIT)$B'16'23;
}(I2 _ ((N' I4)+1)$B'16'23 + I1;
}(I3 _ I1$B'20'23 + I4$B'20'23 + REG'AREA.CARRY'BIT + 1;
}(SET'STATUS(I2, I3);
*}'REVERSE THE SENSE OF THE CARRY BIT SINCE
*}'THIS IS A SUBTRACTION.
})REG'AREA.CARRY'BIT _ N' REG'AREA.CARRY'BIT;
}(REG'AREA.REG'A _ I2;
}(RETURN;

})FUNCTION ANA(DATA);

})I2 _ REG'AREA.REG'A A' DATA;
}(SET'STATUS(I2, 0);
}(REG'AREA.REG'A _ I2;
}(REG'AREA.CARRY'BIT _ 0;
}(RETURN;

})FUNCTION XRA(DATA);

})I2 _ REG'AREA.REG'A E' DATA;
}(SET'STATUS(I2, 0);
}(REG'AREA.REG'A _ I2;
}(REG'AREA.CARRY'BIT _ 0;
}(RETURN;

})FUNCTION ORA(DATA);

})I2 _ REG'AREA.REG'A V' DATA;
}(SET'STATUS(I2, 0);
}(REG'AREA.REG'A _ I2;
}(REG'AREA.CARRY'BIT _ 0;
}(RETURN;

})FUNCTION CMP(DATA);

})I4 _ (N' DATA)$B'16'23;
}(I1 _ REG'AREA.REG'A;
}(I2 _ I1 + I4 + 1;
}(I3 _ I1$B'20'23 + I4$B'20'23+1;
}(SET'STATUS(I2, I3);
*}'REVERSE THE SENSE OF THE CARRY BIT SINCE
*}'THIS IS A SUBTRACTION.
})REG'AREA.CARRY'BIT _ N' REG'AREA.CARRY'BIT;
}(RETURN;


})END;}"/*}"END ALU.}"*/

}(PROGRAM CONTROL'INSTR;
*
*}"THIS BLOCK CONTAINS ALL OF THE FUNCTIONS WHICH IMPLEMENT TRANSFER
*}"OF CONTROL INSTRUCTIONS (E.G. JMP, CALL, RET).
*

})INCLUDE SIMU'VARS, FIELD'DESC;

})DECLARE INTEGER
})I1;

})FUNCTION RST'ADDRS(), FRETURN;

})IF CONTROL'BREAK
})DO;
},ERROR'MESSAGE(9);
},DUMP'REG() IF DUMP'BREAK;
},FRETURN;
}(ELSEIF CONTROL'TRACE
})DO;
},ERROR'MESSAGE(10);
}(ENDIF;
}(I1 _ P'COUNTER+1;
}(PUT'M(I1$B'8'15, STACK-1// FRETURN);
}(PUT'M(I1$B'16'23,STACK-2// FRETURN);
}(STACK _ STACK - 2;
}(P'COUNTER _ CURRENT'INSTR$B'18'20 LSH 3;
}(P'COUNTER _ P'COUNTER - 1;
}(RETURN;

})FUNCTION PCHL'ADDR();

})IF CONTROL'BREAK
})DO;
},ERROR'MESSAGE(9);
},DUMP'REG() IF DUMP'BREAK;
},FRETURN;
}(ELSEIF CONTROL'TRACE
})DO;
},ERROR'MESSAGE(10);
}(ENDIF;
}(P'COUNTER$B'8'15 _ REG'AREA.REG'H;
}(P'COUNTER$B'16'23 _ REG'AREA.REG'L;
}(P'COUNTER _ P'COUNTER - 1;
}(RETURN;

})FUNCTION JUMP(), FRETURN;

})IF CONTROL'BREAK
})DO;
},ERROR'MESSAGE(9);
},DUMP'REG() IF DUMP'BREAK;
},FRETURN;
}(ELSEIF CONTROL'TRACE
})DO;
},ERROR'MESSAGE(10);
}(ENDIF;
}(I1 _ 0;
}(I1$B'16'23 _ GET'M(P'COUNTER + 1// FRETURN);
}(I1$B'8'15 _ GET'M(P'COUNTER + 2// FRETURN);
}(P'COUNTER _ I1 - 3;
}(RETURN;

})FUNCTION CALL'ADDR(), FRETURN;

})IF CONTROL'BREAK
})DO;
},ERROR'MESSAGE(9);
},DUMP'REG() IF DUMP'BREAK;
},FRETURN;
}(ELSEIF CONTROL'TRACE
})DO;
},ERROR'MESSAGE(10);
}(ENDIF;
}(I1 _ P'COUNTER + 3;
}(PUT'M(I1$B'16'23, STACK - 2// FRETURN);
}(PUT'M(I1$B'8'15, STACK - 1// FRETURN);
}(STACK _ STACK - 2;
}(I1 _ P'COUNTER;
}(P'COUNTER$B'16'23 _ GET'M(I1+1// FRETURN);
}(P'COUNTER$B'8'15 _ GET'M(I1+2// FRETURN);
}(P'COUNTER _ P'COUNTER - 3;
}(RETURN;

})FUNCTION RET'P(), FRETURN;

})IF CONTROL'BREAK
})DO;
},ERROR'MESSAGE(9);
},DUMP'REG() IF DUMP'BREAK;
},FRETURN;
}(ELSEIF CONTROL'TRACE
})DO;
},ERROR'MESSAGE(10);
}(ENDIF;
}(P'COUNTER$B'16'23 _ GET'M(STACK// FRETURN);
}(P'COUNTER$B'8'15 _ GET'M(STACK+1// FRETURN);
}(STACK _ STACK + 2;
}(P'COUNTER _ P'COUNTER - 1;
}(RETURN;

})END;}"/*}"END CONTROL'INSTR.}"*/

}(PROGRAM GET'D;
*
*}"THIS DOES THE OPPOSITE OF PUT'D.
*

})INCLUDE SIMU'VARS, FIELD'DESC;

})DECLARE INTEGER
})RP;

})DECLARE LABEL ARRAY CASE[4] _
})(CASE0, CASE1, CASE2, CASE3);

})FUNCTION GET'D(RP);

/*}#HELP() IF RP < 0 OR RP > 3; */

})GOTO CASE[RP];

})CASE0:
}(RETURN REG'AREA.REG'B'C;
}(CASE1:
}(RETURN REG'AREA.REG'D'E;
}(CASE2:
}(RETURN REG'AREA.REG'H'L;
}(CASE3:
}(RETURN STACK$B'8'23;

})END;}"/*}"END GET'D.}"*/

*
*}'RUNOFF IS COMPOSED OF 5 SEPARATE PACKAGES
*
*
*}+1)}"NOP
*}+2)}"NCP
*}+3)}"NTP
*}+4)}"NFP
*}+5)}"NIP
*
******** RUNOFF (HOW TO LOAD AND RUN)}"FIRST SEPARATE THE PACKAGES INTO FILES.
}'@QRUN

}';T}#RUNOFF-NIP.
}'IDENT.}#IPROC}#2564

}';T}#RUNOFF-NFP.
}'IDENT.}#FPROC}#13357

}'%R}#20303100}#12
}'20B6,12;R
}'4000;T}#RUNOFF-NCP.
}'IDENT.}#CPROC}#10026

}';T RUNOFF-NOP.
}'IDENT.}#OPROC}#12054

}';T RUNOFF-NTP.
}'IDENT.}#TPROC}#16525

}';U

}'%R}#20323335}#12
}'20323335,303112;R
}'..;G
}(3/12/71
}'INPUT FROM: R-6.

}'OUTPUT TO: FOO.

}'%F
}'@

****************}%NOP}%*******************

**QSPL
}'IDENT OPROC;


* GENERAL FIELD AND PARAMETER DEFINITIONS FOR RUNOFF

* FIELDS FOR STRING DESCRIPTORS
DECLARE FIELD $BPTR(0), $RPTR(1), $WPTR(2), $EPTR(3);
DECLARE FIELD CH1(0:0,7),CH2(0:8,15),CH3(0:16,23);

* CHARACTER VALUE DEFINITIONS
DECLARE PARAMETER NILCH _ 200B, BOPCH _ 201B, VSPCH _ 202B,
}'EODCH _ 204B, TABCH _ 211B, COMCH _ 213B,
}'EOLCH _ 215B, BFNCH _ 216B, EFNCH _ 217B;

DECLARE MACRO BIO(F,C,SL) _ POP(576B, F, C,, SL);

* TEXT FIELDS AND PARAMETERS
DECLARE FIELD LTYPF(0: 0, 2), CTYPF(0: 3, 5), ADDRF(0: 10, 23);
DECLARE MACRO RTYPE(X) _ LTYPF(COMCD) OR CTYPF(2) OR CH2(X);
DECLARE PARAMETER LINCD _0, TABCD _ 1, FLDCD _ 2, CNTCD _ 3,
}'STRCD _ 6, COMCD _ 7,
}'SFLCD _ LTYPF(COMCD) OR CTYPF(1),
}'PMDCD _ RTYPE(1), HMDCD _ RTYPE(2), BPGCD _ RTYPE(3),
}'EPGCD _ RTYPE(4), VSPCD _ RTYPE(5), LLACD _ RTYPE(6),
}'HLACD _ RTYPE(7), PLACD _ RTYPE(8), PGNCD _ RTYPE(9),
}'ODPCD _ RTYPE(10), EJECD _ RTYPE(11), HYBCD _ RTYPE(12),
}'INPCD _ RTYPE(13);

* EXTERNALS
DECLARE *FILLF, *FMTP, *PAGF, *DOF, *ERFLG, *CMB,
}'*CNCTR, *SYPPC, *MAX, *MIN, *SBLK, *DSPF;

* MARGIN TABLES
DECLARE FIXED ARRAY $AMAR(7) _ PRLA, NLAM, NRAM, NTAM,
}'NBAM, NLILN, NLORG;
DECLARE FIXED ARRAY $OAMAR(7) _ 0, LAMAR, RAMAR, TAMAR, BAMAR,
}'LINORG, LINLEN;
DECLARE FIXED ARRAY $LMAR(5) _ PRLL, NLLM, NRLM, NNCL, NCSP;
DECLARE FIXED ARRAY $OLMAR(5) _ 0, LHMAR, RHMAR, NCOL, ZMAR;
DECLARE FIXED ARRAY $PMAR(4) _ PRPL, NTPM, NBPM, NPTOL;
DECLARE FIXED ARRAY $OPMAR(4) _ 0, TPMAR, BPMAR, PSLOP;
DECLARE FIXED ARRAY $IMAR(3) _ PRRM, NLLM, NRLM;
DECLARE FIXED ARRAY $UMAR(3) _ PREM, NLLM, NRLM;
DECLARE FIXED ARRAY $ORMAR(3) _ 0, ZMAR, ZMAR;
DECLARE ZMAR _ 0;


DECLARE LAMAR, LLMAR, LHMAR, RAMAR, RLMAR, RHMAR, NCOL, CSPC;* LINE MARGINS
DECLARE LINORG, LINLEN, MLLM, MRLM, MXLM, NLILN, NLORG;
DECLARE NLAM, NLLM, NRAM, NRLM, NNCL, NCSP;

DECLARE BAMAR, BPMAR, TAMAR, TPMAR, PSLOP;* PAGE MARGINS
DECLARE NBAM, NBPM, NTAM, NTPM, NPTOL;

DECLARE *TOPGC, GAM3, TOPFC, TOPFB, TOPLI, TOPPI, TOPLM,
}'OBFF, OBFL, OBFP, OBFIF, PTCHN, PTCHW, PTCHC;

DECLARE MACRO STERF()_ ERFLG _ ERFLG + 1;

* CONTROL FUNCTIONS FOR LINE FORMATTING
FUNCTION USLM(); PRER() WHILE PRCMS > 0; RETURN;

FUNCTION PRLA();
}'(STERF() & RETURN) IF MIN(NLORG + NLILN - NLAM, NRAM - NLORG) <=
}/MAX(NLAM - NLORG, NLORG + NLILN - NRAM) OR
}*NLILN <= 25 OR NBAM - NTAM <= 6;
}'USLM(); LAMAR _ NLAM; RAMAR _ NRAM; NCOL _ 1; CSPC _ 0;
}'LINORG _ NLORG; LHMAR _ 15; LLMAR _ 0;
}'RHMAR _ (LINLEN _ NLILN) - 10; MXLM _ RLMAR _ RHMAR - LHMAR;
}'MRLM _ MIN(LINLEN, MIN(RAMAR - LINORG, LINLEN + LINORG - LAMAR));
}'MLLM _ MAX(0, MAX(LAMAR - LINORG, LINORG + LINLEN - RAMAR));
}'TPMAR _ TAMAR _ NTAM; BPMAR _ (BAMAR _ NBAM) - 6; PSLOP _ 4;
}'DMPL(); DMHL(); DMLL(); RETURN;

FUNCTION PRLL(); USLM();
}'(STERF() & RETURN) IF NRLM > MRLM OR NNCL <= 0 OR NLLM < MLLM
},OR NCSP < 0 OR (NRLM - NLLM - NCSP *(NNCL - 1))/ NNCL <= 0;
}'LHMAR _ NLLM; RHMAR _ NRLM; LLMAR _ 0; NCOL _ NNCL; CSPC _ NCSP;
}'MXLM _ RLMAR _ (RHMAR - LHMAR - CSPC *(NCOL - 1))/ NCOL;
}'DMHL(); DMLL(); RETURN;

* RELATIVE MARGINS
DECLARE PRCMS, PRCMT;
FUNCTION PREM(), LINK XPRER;
}'NLLM _ LLMAR - NLLM; NRLM _ RLMAR + NRLM; GOTO PRCM;

FUNCTION PRRM(), LINK XPRER;
}'NLLM _ LLMAR + NLLM; NRLM _ RLMAR - NRLM;

PRCM:}"PRCMT _ MAKE(3); PRCMT[0] _ LLMAR; PRCMT[1] _ RLMAR;
}'PRCMT[2] _ PRCMS; PRCMS _ PRCMT;
}'(LLMAR _ NLLM & RLMAR _ NRLM) IF NRLM <= MXLM AND NRLM > NLLM AND
}/NLLM >= 0 ELSE STERF();
}'DMLL(); RETURN;

FUNCTION $PRER(), LINK XPRER; RETURN IF PRCMS = 0;
}'PRCMT _ PRCMS; PRCMS _ PRCMT[2]; RLMAR _ PRCMT[1];
}'LLMAR _ PRCMT[0]; FREE(PRCMT); DMLL(); RETURN;

* PARAGRAPH SPACING
FUNCTION $PRPI(TOPPI); RETURN;
FUNCTION $PRPU(TOPPI); TOPPI _ - TOPPI; RETURN;

FUNCTION $PRIN(TOPLI); RETURN;
FUNCTION $PRUN(TOPLI); TOPLI _ - TOPLI; RETURN;

* SINGLE LINE COMMANDS
FUNCTION $PRCE(); TOPLM _ 1; RETURN;
FUNCTION $PRMA(); TOPLM _ 2; RETURN;

* CONTROL FUNCTIONS FOR PAGE FORMATTING
FUNCTION PRPL(); GOTO PRPLE IF TAMAR > NTPM OR NBPM > BAMAR OR
}/NBPM <= NTPM OR (NBPM - NTPM) <= NPTOL;
}'TPMAR _ NTPM; BPMAR _ NBPM; PSLOP _ NPTOL; DMPL(); RETURN;
PRPLE: STERF(); RETURN;

FUNCTION $PREJ(TOPTS); TOPPW(EJECD OR CH3(TOPTS)); RETURN;
FUNCTION $PROP(); TOPPW(ODPCD); RETURN;
FUNCTION $PRPN(TOPTS); TOPPW(PGNCD OR CH3(TOPTS)) IF TOPTS > 0;
}'OFLAG(SFLCD, @PAGF, -1); RETURN;
FUNCTION $PRIP(TOPTS); TOPPW(INPCD OR CH3(TOPTS)); RETURN;

FUNCTION $PRHM(TOPTS); TOPPW(HMDCD OR CH3(TOPTS)); RETURN;
FUNCTION $PRPH(TOPTS); TOPPW(PMDCD OR CH3(TOPTS)); RETURN;

FUNCTION $PRBG(); CINIT(BPGCD); CFILL(); RETURN;
FUNCTION $PREG(); CINIT(EPGCD); CFILL(); RETURN;
FUNCTION $PRFS(TOPTS); PRBG(); PRSP(TOPTS); PREG(); RETURN;

FUNCTION $PRSP(TOPTS); TOPTS _ 1 IF TOPTS < 0;
}'SYPPC(VSPCH); TLF(TOPTS); RETURN;

FUNCTION $PRHB(TOPTS); CINIT(HYBCD OR CH3(TOPTS)); CFILL(); RETURN;

FUNCTION $PRPS(TOPPS); RETURN;

* COLLECT AND OUTPUT STRING FOR PFP
FUNCTION $CPCS(CPCSC, CPCST); CINIT(LTYPF(STRCD) OR CTYPF(CPCST));

CPCS1: CPCST _ GCI(CMB: CPCS5); GOTO CPCS2 IF CPCST = CPCSC;
}'PTCH(CPCST); GOTO CPCS1;

CPCS2: PTCH(EOLCH); SBLK(CPCS3);
CPCS3: CFILL(); SRETURN;

CPCS5: STERF(); CFILL(); RETURN;

FUNCTION $OFLAG(LTYP, OFLAGF, OFLAGV); CINIT(LTYP OR ADDRF(OFLAGF));
}'CFILL(); $OFLAGF _ OFLAGV; RETURN;

FUNCTION CINIT(LTYP); DECLARE OBFCF; OBFCF _ OBFIF;
}'(PTCH(COMCH) & TFILL()) IF OBFCF < 0; TINIT(LTYP); RETURN;
FUNCTION CFILL(); TFILL(); TINIT(LTYPF(CNTCD)) IF OBFCF < 0; RETURN;

FUNCTION DMPL(); TOPPW(PLACD OR CH3(TPMAR - TAMAR));
}'TOPPW(CH1(BPMAR - TAMAR) OR CH3(PSLOP)); RETURN;

FUNCTION DMHL(); TOPPW(HLACD OR CH3(RHMAR - LHMAR));
}'TOPPW(CH1(LINLEN - RHMAR + LINORG - LAMAR) OR
}/CH3(LHMAR + LINORG - LAMAR));
}'TOPPW(CH1(NCOL) OR CH3(CSPC)); RETURN;

FUNCTION DMLL(); TOPPW(LLACD OR CH3(LLMAR)); TOPPW(RLMAR); RETURN;

* OUTPUT BUFFERING FUNCTIONS FOR PASS 3

FUNCTION TINIT(LTYP); FTLERR() IF OBFIF < 0;

}'TOPPW(LTYP);* SET UP HEADER WORD

* INITIALIZE PTCH, AND RETURN
}'PTCHN _ 2; OBFIF _ -1; RETURN;

FUNCTION TFILL(); RETURN IF OBFIF >= 0;
IF PTCHN = 0 DO; PTCHW _ PTCHW LSH 8 OR CH3(NILCH); GOTO TFL1;
ELSEIF PTCHN = 1 DO; PTCHW _ PTCHW LSH 16 OR (CH2(NILCH) OR CH3(NILCH));
}'GOTO TFL1;
ELSE DO; GOTO TFL2;
ENDIF;

TFL1:}"TOPPW(PTCHW);
TFL2:}"OBFIF _ 0; RETURN;

* PUT CHARACTER INTO OUTPUT BUFFER, AND DUMP ON OVERFLOW
FUNCTION PTCH(PTCHC); FTLERR() IF OBFIF >= 0;
}'PTCHW _ PTCHW LSH 8 OR PTCHC; RETURN IF (PTCHN _ PTCHN - 1) >= 0;
}'TOPPW(PTCHW); PTCHN _ 2; RETURN;

* OUTPUT BLANK LINES
FUNCTION TLF(PTCHC); TOPPW(VSPCD OR ADDRF(PTCHC)); RETURN;

FUNCTION TOPPW(TOPWD); $OBFP _ TOPWD; RETURN IF (OBFP _ OBFP + 1) < OBFL;
}'BIO(DOF, 256, OBFF: FTLERR); OBFP _ OBFF; RETURN;

*
* TEXT OUTPUT COROUTINE
*

* INITIAL LAYOUTS FOR DEVICES
DECLARE FIXED ARRAY ILAM[3] _ 6, 5, 0;
DECLARE FIXED ARRAY IRAM[3] _ 89, 137, 512;
DECLARE FIXED ARRAY ILOR[3] _ 0, 15, 0;

* INITIALIZE TOP
FUNCTION $ITOP(TOPTS);
}'OBFP _ OBFF _ MAKE(256); OBFL _ OBFF + 256; OBFIF _ 0;
}'FMTP _ FILLF _ -1; PRCMS _ 0;
}'NLAM _ ILAM[TOPTS]; NRAM _ IRAM[TOPTS]; NTAM _ 6; NBAM _ 66;
}'NLILN _ 85; NLORG _ ILOR[TOPTS]; PRLA();
}'TOPLM _ 0; TOPPS _ 1; TOPPI _ 5; TOPGC _ CNCTR(FTLERR); RETURN;

FUNCTION $TOP();

* BETWEEN LINE COLLECTION
TOP1:}"GAM3 _ TOPGC(); RETURN IF GAM3 = EODCH ELSE
}'GOTO TOP1 IF GAM3 = EOLCH OR GAM3 = VSPCH;

TOP2:}"GOTO FTP1 IF FMTP >= 0 ELSE GOTO LTP1;

TOP3:}"GAM3 _ TOPGC(); RETURN IF GAM3 = EODCH ELSE
}'GOTO TOP3 IF GAM3 = EOLCH ELSE GOTO TOP1 IF GAM3 = VSPCH ELSE
}'TLF(TOPPS) IF GAM3 = BOPCH; GOTO TOP2;

FUNCTION $DTOP(); BIO(DOF, OBFP - OBFF, OBFF: FTLERR);
}'FREE(OBFF); FREE(TOPGC); RETURN;

* FILL/NOFILL LINE COLLECTION
LTP1:}"TOPFB _ ((GAM3 _ TOPGC() & TOPPI) IF GAM3 = BOPCH ELSE 0) + TOPLI;
}'TOPLI _ TOPFB + LLMAR; (STERF() & TOPFB _ 0) IF TOPLI < 0 OR
}/RLMAR - TOPLI <= 0;
}'TINIT(LTYPF(LINCD) OR CTYPF(TOPLM) OR ADDRF(TOPFB));
}'TOPLI _ TOPLM _ 0;

LTP2:}"PTCH(GAM3); (TFILL() & GOTO TOP3) IF GAM3 = EOLCH;
}'GAM3 _ TOPGC(); GOTO LTP2;

* TABLE ENTRY COLLECTION
FTP1:}"TINIT(LTYPF(TABCD) OR ADDRF(FMTP));
}'TOPFC _ FMTP.CH3; GAM3 _ TOPGC() IF GAM3 = BOPCH;

FTP2:}"PTCH(GAM3); (TFILL() & GOTO TOP3) IF GAM3 = EOLCH;
}'((STERF() & GOTO FTP3) IF (TOPFC _ TOPFC - 1) < 0)
}/IF GAM3 = TABCH;
}'GAM3 _ TOPGC(); GOTO FTP2;

FTP3:}"GAM3 _ TOPGC(); GOTO FTP3 IF GAM3 # EOLCH ELSE GOTO TOP3;

}'END;

***************}"NCP}"*******************

**QSPL
}'IDENT CPROC;

* GENERAL FIELD AND PARAMETER DEFINITIONS FOR RUNOFF

* FIELDS FOR STRING DESCRIPTORS
DECLARE FIELD BPTR(0), RPTR(1), WPTR(2), EPTR(3);
DECLARE FIELD CH1(0:0,7), CH2(0:8,15), CH3(0:16,23);
DECLARE FIELD LKPTR(0: 10, 23), LENGF(-1: 10, 23);

* CHARACTER VALUE DEFINITIONS
DECLARE PARAMETER DQCH _ 2, CSHFT _ 40B,
}'EOCCH _ 203B, EOPCH _ 214B, EOLCH _ 215B;

* EXTERNAL ARRAYS, STRINGS, AND ROUTINES FOR PROCESSORS
DECLARE EXTERNAL ARRAY AMAR, LMAR, PMAR, IMAR, UMAR,
}'OAMAR, OLMAR, OPMAR, ORMAR;

DECLARE EXTERNAL PRCL,PREJ,PRHM,PRCE,PRMA,PROP,PRPH,PRPN,PRIP,PRPS,PRSH;
DECLARE EXTERNAL PRFS,PRES,PRLI,PRSP,PRIN,PRPI,PRPU,PRUN,PRER;
DECLARE EXTERNAL PRTC,PRDF,PRFM,PRFI,PRNF,PRBG,PREG,PRHB,PRISS;

DECLARE *DSPF, *HYPF, *ULNF, *JUSTF, *FILLF, *FMTP, *PAGF, *TOPGF, *ERFLG;
DECLARE *CNCTR, *CONEC, *TRUNC, *LKP, *INS, *CPCS, *INSGW,
}'*CVCGC, *GCHPC, *TOPGC, *SYPPC;

DECLARE PARAMETER HESCD _ 0, PFSCD _ 1, SCSCD _ 2, SFSCD _ 3, IXSCD _ 4;

DECLARE MACRO INC(X, Y) _ X _ X + (Y);

* CURRENT COMMAND TABLES
DECLARE LCTAB, ARRAY ATAB, STAB, CTAB;

* COMMAND TABLES
DECLARE PARAMETER LNCTAB _ 44;
DECLARE STRING STSAD _ "ADJUST", STSBG _ "BEGIN GROUP", STSBR _ "BREAK",
}#STSCL _ "CALL", STSCE _ "CENTER", STSDC _ "DEFINE COMMAND",
}#STSDF _ "DEFINE FORMAT", STSDS _ "DOUBLE SPACE", STSEJ _ "EJECT";
DECLARE STRING STSEC _ "END COMMAND", STSEF _ "END FORMAT",
}#STSEG _ "END GROUP", STSER _ "END REDUCTION", STSES _ "ESCAPE",
}#STSEM _ "EXPAND MARGIN", STSFS _ "FIGURE SPACING", STSFI _ "FILL",
}#STSFM _ "FORMAT", STSGL _ "GLOSSARY", STSHE _ "HEADER";
DECLARE STRING STSHM _ "HEADING MODE", STSHY _ "HYPHENATE",
}#STSHB _ "HYPHENATION BREAK", STSIN _ "INDENT",
}#STSIP _ "INCREMENT PAGE", STSIX _ "INDEX",
}#STSLA _ "LAYOUT", STSLL _ "LINE LAYOUT", STSLI _ "LITERAL",
}#STSMA _ "MARGIN", STSNF _ "NOFILL";
DECLARE STRING STSNH _ "NOHYPHEN", STSNJ _ "NOJUST",
}#STSOP _ "ODD PAGE", STSPN _ "PAGE", STSPL _ "PAGE LAYOUT",
}#STSPM _ "PAGING MODE", STSPI _}""PARAGRAPH INDENTATION";
DECLARE STRING STSPS _ "PARAGRAPH SPACING",
}#STSPU _ "PARAGRAPH UNDENTATION", STSRM _ "REDUCE MARGIN",
}#STSSS _ "SINGLE SPACE", STSSP _ "SPACE",
}#STSTC _ "TAB CHARACTER", STSUN _ "UNDENT", STSUL _ "UNDERLINE";
DECLARE FIXED ARRAY NSTAB(LNCTAB) _ STSAD, STSBG, STSBR, STSCL, STSCE,
}#STSDC, STSDF, STSDS, STSEJ, STSEG, STSER, STSES, STSEM, STSFS,
}#STSFI, STSFM, STSGL, STSHE, STSHM, STSHY, STSHB, STSIN, STSIP, STSIX,
}#STSLA, STSLL, STSLI, STSMA, STSNF, STSNH, STSNJ, STSOP, STSPN,
}#STSPL, STSPM, STSPI, STSPS, STSPU, STSRM, STSSS, STSSP, STSTC,
}#STSUN, STSUL;
DECLARE FIXED ARRAY NATAB(LNCTAB) _ 'AD ', 'BG ', 'BR ', 'CL ', 'CE ',
}#'DC ', 'DF ', 'DS ', 'EJ ', 'EG ', 'ER ', 'ES ', 'EM ', 'FS ',
}#'FI ', 'FM ', 'GL ', 'HE ', 'HM ', 'HY ', 'HB ', 'IN ', 'IP ', 'IX ',
}#'LA ', 'LL ', 'LI ', 'MA ', 'NF ', 'NH ', 'NJ ', 'OP ', 'PA ',
}#'PL ', 'PM ', 'PI ', 'PS ', 'PU ', 'RM ', 'SS ', 'SP ', 'TC ',
}#'UN ', 'UL ';
DECLARE FIXED ARRAY NCTAB(LNCTAB) _ CPAD, PRBG, CPBR, CPCL, CPCE,
}#CPDC, CPDF, CPDS, CPEJ, PREG, CPER, CPES, CPEM, CPFS,
}#CPFI, CPFM, CPGL, CPHE, CPHM, CPHY, CPHB, CPIN, CPIP, CPIX,
}#CPLA, CPLL, PRLI, CPMA, CPNF, CPNH, CPNJ, CPOP, CPPN,
}#CPPL, CPPM, CPPI, CPPS, CPPU, CPRM, CPSS, CPSP, CPTC,
}#CPUN, CPUL;

* MACRO 'COMMAND' TABLES
DECLARE PARAMETER LMCTAB _ 1;
DECLARE FIXED ARRAY MSTAB(LMCTAB) _ STSEC;
DECLARE FIXED ARRAY MATAB(LMCTAB) _ 'EC ';
DECLARE FIXED ARRAY MCTAB(LMCTAB) _ CPEC;

* FORMAT 'COMMAND' TABLES
DECLARE PARAMETER LFCTAB _ 1;
DECLARE FIXED ARRAY FSTAB(LFCTAB) _ STSEF;
DECLARE FIXED ARRAY FATAB(LFCTAB) _ 'EF ';
DECLARE FIXED ARRAY FCTAB(LFCTAB) _ CPEF;


* STORAGE FOR COMMAND PROCESSORS
DECLARE CPL, CCPN, CPT, CFH, CPTI, CPTL;
DECLARE FIXED STRING $CMB(90), CPOPS;

DECLARE MACRO STERF()_ ERFLG _ ERFLG + 1;

* FLAG ROUTINES
DECLARE *OFLAG, FIELD LTYPF(0:0,2), CTYPF(0:3,5),
}'PARAMETER COMCD _ 7, SFLCD _ LTYPF(COMCD) OR CTYPF(1),
}/RFLCD _ LTYPF(COMCD) OR CTYPF(0);
DECLARE MACRO SFLAG(FLG) _ OFLAG(SFLCD, @FLG, -1);
DECLARE MACRO RFLAG(FLG) _ OFLAG(RFLCD, @FLG, 0);

* SET CELL
DECLARE MACRO VSET(CSSB, CSPR) _ $CSSB _ CSPR;

* SET-UP SUBROUTINE CALL
DECLARE MACRO CSET(CSSB,CSPR) _ CSSB(CSPR);

DECLARE MACRO LTRP(X) _ (X) > '@' AND (X) <= 'Z';
DECLARE MACRO LBRK() _ (SYPPC(EOLCH) & PRISS());


* INITIALIZE COMMAND PROCESSOR
DECLARE MACRO MKTAB(X,Y) _ (X _ MAKE(Y))[0] _ 0;

FUNCTION $ICMP(), LINK XCCP; SMB();
}'MKTAB(MNTAB, 10); MKTAB(GLTAB, 20); MKTAB(FMTAB, 5);
ICMP1: LCTAB _ LNCTAB; ATAB _ NATAB; STAB _ NSTAB; CTAB _ NCTAB; RETURN;

* FREE CPROC STORAGE FOR PASS II
FUNCTION $DCMP(); (FREE(MNTAB[CPL].LKPTR) & FREE(MNTAB[CPL]))
}/FOR CPL _ MNTAB[0] BY -1 TO 1;
}'FREE(MNTAB); FREE(SMBGC); FREE(SMBPC); RETURN;


* SKIP BLANKS IN COMMAND LINE
FUNCTION $SBLK(SBLKE); DECLARE SBLKC;
}'SBLKC _ GCI(CMB: SBLKE); GOTO SBLK1 IF SBLKC = ' ';
}'CMB.RPTR _ CMB.RPTR - 1; GOTO SBLKE;

SBLK1:}"SBLKC _ GCI(CMB: SBLKE); GOTO SBLK1 IF SBLKC = ' ';
}'CMB.RPTR _ CMB.RPTR - 1; RETURN SBLKC;


* READ NUMBER FROM COMMAND STRING
FUNCTION CPRN(); DECLARE CPRNV, CPRNS, CPRNC, CPRNT;
}'CPRNV _ 0; CPRNS _ -1; CPRNT _ CMB.RPTR;

CPRN1: GOTO CPRN1 IF (CPRNC _ GCI(CMB: CPRN5)) <= ' ';
IF CPRNC = '-' DO; CPRNS _ CPRNS + 1; CPRNC _ GCI(CMB: CPRN5); ENDIF;

CPRN2: GOTO CPRN3 IF CPRNC > '9' OR CPRNC <= '0'-1;
}'CPRNV _ CPRNV * 10 + CPRNC - '0';
}'CPRNC _ GCI(CMB: CPRN4); GOTO CPRN2;

CPRN3: CMB.RPTR _ CMB.RPTR - 1; SBLK(CPRN4);
CPRN4: SRETURN CPRNV IF CPRNS < 0 ELSE SRETURN - CPRNV;
CPRN5: CMB.RPTR _ CPRNT; RETURN;


* COMPARE ARGUMENT TO COMMAND BUFFER
FUNCTION CPSE(CPSEST); DECLARE CPSESC, CPSERP, FIXED STRING CPSETS;
}&BCOPY(CPSETS, CPSEST, 4); CPSERP _ CMB.RPTR;

CPSE1: CPSESC _ GCI(CPSETS: CPSE2);

IF CPSESC = ' ' DO; SBLK(CPSE5);
ELSE DO; GOTO CPSE5 IF GCMC(:CPSE5) # CPSESC;
ENDIF; GOTO CPSE1;

CPSE2: GOTO CPSE5 IF GCI(CMB: CPSE4) # ' '; SBLK(CPSE4);
CPSE4: SRETURN;
CPSE5: CMB.RPTR _ CPSERP; RETURN;

* GET CHARACTER FROM COMMAND STRING AND CONVERT TO
*}"UPPER CASE
FUNCTION GCMC(); DECLARE GCMCH;

}'GCMCH _ GCI(CMB: GCMC1);
}'GCMCH _ GCMCH - CSHFT IF GCMCH > '_'; SRETURN GCMCH;

GCMC1: RETURN;


* LOOK UP COMMAND WORDS AND EVALUATE PROCESSOR
FUNCTION $CPLKP();
}'CPL _ ((CMB.RPTR + 1)/3)[0];

IF (CPTL _ LENGTH(CMB)) = 2 OR CPTL > 2 AND CPL$CH3 = ' ' DO;

}'CPTI _ CPL$CH1; CPTI _ CPTI - CSHFT IF CPTI > '_';
}'CPTL _ CPL$CH2; CPTL _ CPTL - CSHFT IF CPTL > '_';
}'CPL _ CH1(CPTI) OR CH2(CPTL);

}'GOTO CPA1 IF ATAB[CPTI] = CPL FOR CPTI = LCTAB-1 BY -1 TO 0;
}'STERF() IF STAB # MSTAB; RETURN;* ABBREVIATION SCAN FAILED

CPA1:}"CMB.RPTR _ CMB.RPTR + 2; SBLK(CPA2);
CPA2:}"$CTAB[CPTI](); RETURN;

* ELSE LOOK UP NORMALLY
ELSEIF LENGTH(CMB) > 2 DO;

}#FOR CPTI _ LCTAB-1 BY -1 TO 0 DO;
}'CMB.RPTR _ CMB.BPTR; CPSE($STAB[CPTI]: CPL3:);
}'$CTAB[CPTI](); RETURN;
CPL3:}"ENDFOR;

}'STERF() IF STAB # MSTAB; RETURN;* NOT PROPER PHRASE

* FINISHED
ENDIF;

}'STERF(); RETURN;

* COMMANDS IN PASS I AND II

FUNCTION CPBR(), LINK XCCP; LBRK(); RETURN;* BREAK

FUNCTION CPES(), LINK XCCP; PRES(GCI(CMB: CPES1)); RETURN;
CPES1: STERF(); RETURN;* ESCAPE X

FUNCTION CPSH(), LINK XCCP; PRSH(GCI(CMB: CPSH1)); RETURN;* SHIFT X
CPSH1: PRSH(-1); RETURN;

FUNCTION CPTC(), LINK XCCP; PRTC(GCI(CMB: CPTC1)); RETURN;* TAB CHAR X
CPTC1: PRTC(-1); RETURN;


FUNCTION CPIX(), LINK XCCP; WCI(EOLCH, CMB: CPIX2);
}'CPCS(EOLCH, IXSCD: CPIX2);
CPIX2: RETURN;


* MACRO PROCESSOR
DECLARE *MNTAB, MNBUF, $MNWPTR, FIXED STRING $MNSTR, MNM(45);

FUNCTION CPDC(), LINK XCCP; CPMN();

}'MNPTR _ INS(@MNTAB, MNM, DELMN)[0];
}'MNPTR.LKPTR _ MNBUF _ MAKE(500);
}'SETUP(MNSTR, 3*500, MNBUF); SETW(MNSTR, 1);

}'CONEC(SYPPC, SYPPC); CONEC(SMBPC, CVCGC);
}'CONEC(GCHPC, SMBGC);

}'LCTAB _ LMCTAB; ATAB _ MATAB; STAB _ MSTAB; CTAB _MCTAB;
}'RETURN;

FUNCTION CPEC(), LINK XCCP;

}'MNSTR.WPTR _ MNWPTR;* 'DELETE' END COMMAND
}'MNBUF.CH1 _ (MNPTR _ LENGTH(MNSTR)) - 1;
}'TRUNC(MNBUF, (MNPTR + 2)/ 3);

}'CONEC(SYPPC, TOPGC); CONEC(GCHPC, CVCGC);
}'GOTO ICMP1;

FUNCTION CPCL(), LINK XCCP; CPMN();

}'MNPTR _ LKP(MNTAB, MNM: CPCL1)[0].LKPTR;
}'MNSTR.WPTR _ MNSTR.EPTR _
},(MNSTR.RPTR _ MNSTR.BPTR _ MNPTR * 3 ) + MNPTR.CH1;

}'PRCL(); RETURN;

CPCL1: STERF(); RETURN;

* SUPPORTING SUBROUTINES FOR MACROS

FUNCTION CPMN(); SETS(MNM, 0, 0);

CPMN1: MNBUF _ GCMC(:CPMN2); GOTO CPMN2 IF MNBUF = ' ';
}'WCI(MNBUF, MNM); GOTO CPMN1;

CPMN2: SBLK(CPMN3);
CPMN3: RETURN;

FUNCTION DELMN(MNPTR); RETURN FREE(MNPTR[0].LKPTR);

FUNCTION SMB(); DECLARE SMBGC, SMBPC, SMBCH;
}'SMBPC _ CNCTR(SMB1); SMBGC _ CNCTR(FTLERR); RETURN;

SMB1:}"SMBCH _ SMBGC(); SMBPC(WCI(SMBCH, MNSTR)); GOTO SMB1;


* TABLE FORMATTING COMMAND PROCESSOR
DECLARE FIXED ARRAY $CPDFF('Z' - 'A' + 1);
DECLARE *FMTAB, *DFMTP, *DFMTI, *DFMTS;

FUNCTION CPDF(), LINK XCCP; CPMN();

}'MNPTR _ INS(@FMTAB, MNM, DELFM)[0];

* GET FORMAT POSITIONING
}'CPL _ 2; CPOPS _ "CENTER"; CPSE(CPOPS: CPDF2); GOTO CPDF4;
CPDF2: CPOPS _ "LEFT"; CPSE(CPOPS: CPDF3); CPL _ 0; GOTO CPDF4;
CPDF3: CPOPS _ "RIGHT"; CPSE(CPOPS: CPDF4); CPL _ 1;

CPDF4: DFMTP[0] _ CH1(CPL); DFMTI _ 1; DFMTS _ 0;
}'CPDFF[CPTI] _ -1 FOR CPTI _ 'Z'-'A' BY -1 TO 0;

* LOOP OVER FIELD POSITION DEFINITIONS
CPDF5: CFH _ GCMC(: CPDF8); CPTI _ (0 IF CFH = 'L' ELSE
}/1 IF CFH = 'R' ELSE 2 IF CFH = 'C' ELSE
}/3 IF CFH = 'F' ELSE 4 IF CFH = 'J' ELSE (STERF() & -1));
}'STERF() IF GCMC(:CPDF7) # '(';

* LOOP OVER FIELDS
CPDF6: CFH _ GCMC(:CPDF7); (SBLK(CPDF5) & GOTO CPDF5) IF CFH = ')';
}'CPDFF[CFH - 'A'] _ CH1(-1) OR CH3(CPTI) IF
}/LTRP(CFH) AND CPDFF[CFH - 'A'] = -1 AND CPTI >= 0 ELSE
}*STERF(); GOTO CPDF6;

CPDF7: STERF();
* SET UP TO PROCESS FORMAT DEFINTION
CPDF8: LCTAB _ LFCTAB; ATAB _ FATAB; STAB _ FSTAB; CTAB _ FCTAB;
}'PRDF(); RETURN;

FUNCTION CPEF(), LINK XCCP; DFMTP.CH3 _ DFMTS;* SAVE FIELD COUNT
}'MNPTR.LKPTR _ DFMTS _ MAKE(DFMTI); BCOPY(DFMTS, DFMTP, DFMTI);
}'PRISS(); GOTO ICMP1;

FUNCTION CPFM(), LINK XCCP; CPMN(); LBRK();

}'FMTP _ LKP(FMTAB, MNM: CPFM1)[0].LKPTR; PRFM(); RETURN;

CPFM1: STERF(); RETURN;

FUNCTION DELFM(MNPTR); CPTL _ MNPTR[0].LKPTR;
}'FREE(CPTL[CPL]) FOR CPL _ CPTL.LENGF - 2 BY -1 TO 1;
}'FREE(CPTL); RETURN;




* COMMANDS IN PASS III AND IV
* FLAG ROUTINES

FUNCTION CPAD(), LINK XCCP; LBRK(); SFLAG(JUSTF); RETURN;* ADJUST

FUNCTION CPNJ(), LINK XCCP; LBRK(); RFLAG(JUSTF); RETURN;* NOJUST

FUNCTION CPFI(), LINK XCCP; LBRK(); SFLAG(FILLF);
}'PRFI(); FMTP _ -1; RETURN;* FILL

FUNCTION CPNF(), LINK XCCP; LBRK(); RFLAG(FILLF);
}'PRNF(); FMTP _ -1; RETURN;* NOFILL

FUNCTION CPDS(), LINK XCCP; LBRK(); SFLAG(DSPF); RETURN;* DOUBLE SPACE

FUNCTION CPSS(), LINK XCCP; LBRK(); RFLAG(DSPF); RETURN;* SINGLE SPACE

FUNCTION CPHY(), LINK XCCP; SFLAG(HYPF); RETURN;* HYPHENATE

FUNCTION CPNH(), LINK XCCP; RFLAG(HYPF); RETURN;* NOHYPHEN

FUNCTION CPUL(), LINK XCCP; LBRK(); SFLAG(ULNF); RETURN;* UNDERLINE


* MODE ROUTINES

FUNCTION CPCE(), LINK XCCP; LBRK(); CSET(PRCE,0); RETURN;* CENTER

FUNCTION CPMA(), LINK XCCP; LBRK(); CSET(PRMA,0); RETURN;* MARGIN

FUNCTION CPOP(), LINK XCCP; LBRK(); CSET(PROP,0); RETURN;* ODD PAGE


* ROUTINES WITH OPTIONAL SINGLE PARAMETER
FUNCTION CPEJ(), LINK XCCP1;
}'CPL _ PREJ; CCPN _ 0; GOTO CCP1;* EJECT (N/)
FUNCTION CPIN(), LINK XCCP1;
}'CPL _ PRIN; CCPN _ 5; GOTO CCP1;* INDENT (N /)
FUNCTION CPPN(), LINK XCCP1;
}'CPL _ PRPN; CCPN _ 0; GOTO CCP1;* PAGE NUMBER (N /)
FUNCTION CPIP(), LINK XCCP1;
}'CPL _ PRIP; CCPN _ 1; GOTO CCP1;* INCREMENT PAGE(N /)
FUNCTION CPSP(), LINK XCCP1;
}'CPL _ PRSP; CCPN _ 1; GOTO CCP1;* SPACE (N /)
FUNCTION CPUN(), LINK XCCP1;
}'CPL _ PRUN; CCPN _ 5;* UNDENT (N /)

CCP1: LBRK(); CCPN _ CPRN(:CCP1A);
CCP1A: CSET(CPL,CCPN); RETURN FROM XCCP1;

* ROUTINES WITH REQUIRED SINGLE PARAMETER
FUNCTION CPFS(), LINK XCCP2; LBRK();
}'CPL _ PRFS; GOTO CCP2;* FIGURE SPACING N
FUNCTION CPHB(), LINK XCCP2; CPL _ PRHB; GOTO CCP2;* HYPHENATION BREAK
FUNCTION CPPI(), LINK XCCP2; CPL _ PRPI; GOTO CCP2;* PARAGRAPH INDENTION N
FUNCTION CPPS(), LINK XCCP2; CPL _ PRPS; GOTO CCP2;* PARAGRAPH SPACING N
FUNCTION CPPU(), LINK XCCP2; CPL _ PRPU;* PARAGRAPH UNDENTION N

CCP2:}"CCPN _ CPRN(:CCP2A); CSET(CPL,CCPN); RETURN FROM XCCP2;
CCP2A: STERF(); RETURN FROM XCCP2;

* LAYOUT ROUTINES
FUNCTION CPLA(), LINK XCCP3;
}'CPT _ AMAR; CPTL _ OAMAR; GOTO CCP3;* LAYOUT L, R, T, B, W, O
FUNCTION CPLL(), LINK XCCP3;
}'CPT _ LMAR; CPTL _ OLMAR; GOTO CCP3;* LINE LAYOUT L, R
FUNCTION CPPL(), LINK XCCP3;
}'CPT _ PMAR; CPTL _ OPMAR; GOTO CCP3;* PAGE LAYOUT T, B, S
FUNCTION CPRM(), LINK XCCP3;
}'CPT _ IMAR; CPTL _ ORMAR; GOTO CCP3;* REDUCE MARGIN DL, DR
FUNCTION CPEM(), LINK XCCP3;
}'CPT _ UMAR; CPTL _ ORMAR;* EXPAND MARGIN DL, DR

CCP3:}"LBRK(); $CPT[CPTI] _ $CPTL[CPTI] FOR CPTI _ 1 TO CPT.LENGF - 1;
FOR CPTI _ 1 TO CPT.LENGF - 1 DO; GOTO CCP3A IF SBLKC = ',';
}'CCPN _ CPRN(:CCP3B); VSET(CPT[CPTI],CCPN);
}'(GCI(CMB) & SBLK(CCP3A)) IF SBLKC = ',';
CCP3A: ENDFOR;
CCP3B: CSET($CPT[0],0); RETURN FROM XCCP3;

FUNCTION CPER(); LBRK(); CSET(PRER, 0); RETURN;* END REDUCTION

* COMMANDS TAKING STRINGS OR MODE WORDS

* HEADER XXXXXXXXXXXXXXXXXXXX
FUNCTION CPHE(); WCI(EOLCH, CMB: CPHE2);

CPHE1: CPCS(EOLCH, HESCD: CPHE2);
CPHE2: RETURN;


* HEADING MODE (CENTER / FACING / MARGIN / OPPOSED)
FUNCTION CPHM(), LINK XCCP;

CPHM1: CPOPS _ "CENTER"; CPSE(CPOPS: CPHM2);
}'CSET(PRHM,1); GOTO CPHM1;

CPHM2: CPOPS _ "FACING"; CPSE(CPOPS: CPHM3);
}'CSET(PRHM,2); GOTO CPHM1;

CPHM3: CPOPS _ "MARGIN"; CPSE(CPOPS: CPHM4);
}'CSET(PRHM,3); GOTO CPHM1;

CPHM4: CPOPS _ "OPPOSED"; CPSE(CPOPS: CPHM5);
}'CSET(PRHM,4); GOTO CPHM1;

CPHM5: RETURN;


* PAGING MODE ((BOTTOM / TOP /) (CENTER / FACING / MARGIN /)
*}"(PREFIX "XXXXXXX" /)) / OFF)
FUNCTION CPPM(), LINK XCCP;

CPPMA: CPOPS _ "BOTTOM"; CPSE(CPOPS: CPPMB);
}'RFLAG(TOPGF); GOTO CPPMA;

CPPMB: CPOPS _ "CENTER"; CPSE(CPOPS: CPPMC);
}'CSET(PRPH,2);}"GOTO CPPMA;

CPPMC: CPOPS _ "FACING"; CPSE(CPOPS: CPPMD);
}'CSET(PRPH,3); GOTO CPPMA;

CPPMD: CPOPS _ "MARGIN"; CPSE(CPOPS: CPPME);
}'CSET(PRPH,1); GOTO CPPMA;

CPPME: CPOPS _ "OFF"; CPSE(CPOPS: CPPMF);
}'RFLAG(PAGF); GOTO CPPMA;

CPPMF: CPOPS _ "PREFIX"; CPSE(CPOPS: CPPMG);
}'GOTO CPPMJ IF GCI(CMB: CPPMJ) # DQCH;
}'CPCS(DQCH, PFSCD: CPPMJ); GOTO CPPMA;

CPPMG: CPOPS _ "SECTION"; CPSE(CPOPS: CPPMH);
}'GOTO CPPMJ IF GCI(CMB: CPPMJ) # DQCH;
}'CPCS(DQCH, SCSCD: CPPMJ); GOTO CPPMA;

CPPMH: CPOPS _ "SUFFIX"; CPSE(CPOPS: CPPMI);
}'GOTO CPPMJ IF GCI(CMB: CPPMJ) # DQCH;
}'CPCS(DQCH, SFSCD: CPPMJ); GOTO CPPMA;

CPPMI: CPOPS _ "TOP"; CPSE(CPOPS: CPPMJ);
}'SFLAG(TOPGF); GOTO CPPMA;

CPPMJ: RETURN;


* GLOSSARY COMMAND
DECLARE *GLTAB, STRING *HYB, ARRAY *HYPT;

FUNCTION CPGL(), LINK XCCP; CFH _ GCMC(:CPGL6);

* INITIALIZE FOR NEXT WORD
CPGL1: SETS(HYB, 0, 0); CPL _ 0;

* COLLECT NEXT WORD
CPGL2: IF LTRP(CFH) DO; WCI(CFH, HYB);
ELSEIF CFH = '-' DO; HYPT[CPL] _ LENGTH(HYB); CPL _ CPL + 1;
}'RETURN STERF() IF CPL > HYPT.LENGF;
ELSEIF CFH = ' ' DO; GOTO CPGL3;
ELSE DO; STERF(); RETURN;
ENDIF; CFH _ GCMC(:CPGL3); GOTO CPGL2;

CPGL3: INSGW(HYB, CPL);* INSERT WORD IN GLOSSARY

* LOOP TO NEXT WORD IF ANY
CPGL5: CFH _ GCMC(:CPGL6); GOTO CPGL5 IF CFH = ' '; GOTO CPGL1;
CPGL6: RETURN;

}'END;

***************}"NTP}"******************

**QSPL
}'IDENT TPROC;

* GENERAL FIELD AND PARAMETER DEFINITIONS FOR RUNOFF

DECLARE FIELD BPTR(0), RPTR(1), WPTR(2), EPTR(3);
DECLARE FIELD CH1(0:0,7), CH2(0:8,15), CH3(0:16,23);
DECLARE FIELD BLKBIT(0:16,17), BLKCNT(0:18,23);

* CHARACTER VALUE DEFINITIONS
DECLARE PARAMETER MBCH _ 135B, PBSCH _ 150B, NPCH _ 154B,
}'CRCH _ 155B, LFCH _ 152B, EOFCH _ 137B,
}'AACH _ 141B, ALCH _ 143B, UACH _ 165B, SHCH _ 163B, PSCH _ 176B,
}'CSHFT _ 40B, PSHFT _ 140B, CGTCH _ 136B, ULCH _ 100B, DQCH _ 2;

DECLARE PARAMETER BOPCH _ 201B, VSPCH _ 202B, CAPCH _ 203B,
}'EODCH _ 204B, ERRCH _ 205B, ULWCH _ 206B, ULSCH _ 207B,
}'BSPCH _ 210B, TABCH _ 211B, DSCH _ 212B, ESGCH _ 213B,
}'EOPCH _ 214B, EOLCH _ 215B;

DECLARE PARAMETER BIO _ 576B, WIO _ 560B;

*
* PASS II - RECOGNIZE TEXT
*
* THIS PASS RECOGNIZES:
*}&(1) LOGICAL LINES
*}&(2) WORD AND SENTENCE BREAKS
*}&(3) PARAGRAPH BREAKS
*}&(4) COMMANDS
* IT ALSO IMPLEMENTS UNDERLINING
*

* DECLARATIONS FOR PASS II
DECLARE *SYPGC, *SYPPC, GAM2, ST, CAPFG, ULWFG, LINC,
}'GAMC, CLCMGC, SYPMT, SYPST;
DECLARE *CNCTR, *CONEC, *MAX, *TRUNC, *CPLKP, *PRSP, *MATE, *ICNCT;* COMMAND INTERFACE
DECLARE *FILLF, *FMTP, *CMB, *MNWPTR;

DECLARE MACRO STERF()_ ERFLG _ ERFLG + 1;

* CHARACTER CLASS TESTS
DECLARE MACRO CTRL(X) _ (X > 177B);
DECLARE MACRO WCTL(X) _ (X = ULSCH OR X = ULWCH OR X = CAPCH OR X = DSCH);

DECLARE MACRO LTRM(X) _ (X = EOLCH OR X = TABCH);
DECLARE MACRO TTRM(X) _ (X = ']' OR X = ')' OR X = ']'+CSHFT OR
}'X = '&002' OR X = '&007');
DECLARE MACRO BTRM(X) _ (X = ',' OR X = '&033');
DECLARE MACRO STRM(X) _ (X = '.' OR X = ':' OR X = '?' OR X = '!');
DECLARE MACRO WTRM(X) _ (STRM(X) OR BTRM(X) OR LTRM(X) OR X = ' ');

DECLARE MACRO LTRP(X) _ (X > '@' AND X <= 'Z');
DECLARE MACRO LLTR(X) _ (X > '@'+CSHFT AND X <= 'Z'+CSHFT);

* FILE WORD BREAK
DECLARE MBRK, SBRK; DECLARE MACRO IBRK(X) _ MBRK _ SBRK _ X;
DECLARE MACRO WBRK(X) _ SYPPC(300B + X);

* DUMP BUFFER AND SET NEW LINE OR PARAGRAPH
DECLARE MACRO LBRK() _ SYPPC(EOLCH);
DECLARE MACRO PABRK() _ LBRK() & SYPPC(BOPCH);

* END OF FILE
FUNCTION EBRK(); LBRK(); SYPPC(EODCH); FTLERR();

* STATE MANIPULATION MACHINERY
DECLARE STI, FIXED ARRAY STS(8);

FUNCTION ENT(NST); STS[STI] _ ST; STI _ STI + 1; RETURN ST _ NST;
DECLARE MACRO CH(NST) _ ST _ (NST);

* INITIALIZE FOR COMMANDS
FUNCTION ICLN(); SETS(CMB, 0, 0); MNWPTR _ MNSTR.WPTR - 1;
}'CH(C0); RETURN;

FUNCTION $PRLI(), LINK XPRST;* LITERAL PROCESSOR
}'CH((F4 IF FILLF < 0 ELSE N3) IF FMTP < 0 ELSE T5); RETURN;

FUNCTION $PRISS(), LINK XPRST;
}'CH((F0 IF FILLF < 0 ELSE N0) IF FMTP < 0 ELSE T0); RETURN;
FUNCTION $PRFI(), LINK XPRST; CH(F0); RETURN;* FILL
FUNCTION $PRNF(), LINK XPRST; CH(N0); RETURN;* NOFILL
FUNCTION $PRFM(), LINK XPRST; CH(T0); RETURN;* FORMAT
FUNCTION $PRDF(), LINK XPRST; CH(P0); RETURN;* DEFINE FORMAT

* FILL-MODE LINE PROCESSOR
FUNCTION $ISYP(); STI _ 0; ST _ F0; DFMTP _ MAKE(10);
}'SYPGC _ CNCTR(FTLERR); SYPPC _ CNCTR(SCAN);
}'CLCMGC _ CNCTR(FTLERR); RETURN;

FUNCTION $DSYP(); FREE(SYPPC); FREE(SYPGC); FREE(CLCMGC); RETURN;

RPT:}#ST _ STS[STI _ STI - 1]; GOTO PP;
XIT:}#ST _ STS[STI _ STI - 1];

SCAN:}"GAM2 _ SYPGC();
PP: GOTO ST;

* F0 IS INITIAL STATE AFTER COMMANDS AND BREAKS
F0: IF GAM2 = EOLCH DO; LBRK(); GOTO SCAN;
ELSEIF GAM2 = ' ' DO; CH(F1); GOTO SCAN;
ELSEIF GAM2 = '.' DO; GOTO C0;
ELSEIF GAM2 = EODCH DO; EBRK();
ELSE DO; CH(F2); ENT(L0); GOTO PP;
ENDIF;

* BEGINNING OF PARAGRAPH
F1: IF GAM2 = EOLCH DO; LBRK(); CH(F0); GOTO SCAN;
ELSEIF GAM2 = ' ' DO; GOTO SCAN;
ELSE DO; PABRK(); CH(F2); ENT(L0); GOTO PP;
ENDIF;

* END OF LINE
F2:}"IF GAM2 = EOLCH DO; CH(F3); GOTO SCAN;
ELSE DO; STERF(); ENT(L0); GOTO SCAN;
ENDIF;

* FIRST OF NEXT LINE
F3: IF GAM2 = EOLCH DO; LBRK(); CH(F0); GOTO SCAN;
ELSEIF GAM2 = ' ' DO; CH(F1); GOTO SCAN;
ELSEIF GAM2 = '.' DO; GOTO C0;
ELSEIF GAM2 = EODCH DO; EBRK();
ELSE DO; WBRK(SBRK); CH(F2); ENT(L0); GOTO PP;
ENDIF;

* NEXT TEXT LINE MAY BEGIN WITH DOT
F4: IF GAM2 = '.' DO; CH(F2); ENT(L0); GOTO PP;
ELSE DO; CH(F0); GOTO PP;
ENDIF;

* PROCESS COMMAND LINES
C0:}$SETS(CMB, 0,0); MNWPTR _ MNSTR.WPTR - 1;
}'SYPST _ ST; CH(C1); ENT(L0); 
}'SYPMT _ MATE(SYPPC); CONEC(SYPPC, CLCMGC); ICNCT(SYPPC, SCAN);

* COROUTINE TO FILE CHARACTERS IN BUFFER
CLCM1: GAMC _ CLCMGC(); GOTO CLCM3 IF GAMC > BLKBIT(-1)-1;
}'WCI(GAMC, CMB: CLCM2); GOTO CLCM1;
CLCM2: STERF(); GOTO CLCM1;

CLCM3: WCI(' ', CMB: CLCM2) FOR GAMC _ GAMC$BLKCNT - 1 BY -1 TO 0;
}'GOTO CLCM1;

C1:}$STERF() IF GAM2 # EOLCH; CONEC(SYPPC, SYPMT);
}'CPLKP(); CH(SYPST) IF ST = C1; GOTO SCAN;


* NON-FILL PROCESSOR
N0: IF GAM2 = EOLCH DO; LBRK(); PRSP(1); GOTO SCAN;
ELSEIF GAM2 = ' ' DO; IBRK(1); CH(N1); GOTO SCAN;
ELSEIF GAM2 = '.' DO; GOTO C0;
ELSEIF GAM2 = EODCH DO; EBRK();
ELSE DO; CH(N2); ENT(L0); GOTO PP;
ENDIF;

N1: IF GAM2 = EOLCH DO; LBRK(); PRSP(1); CH(N0); GOTO SCAN;
ELSEIF GAM2 = ' ' DO; MBRK _ MBRK + 1; GOTO SCAN;
ELSE DO; WBRK(MBRK); CH(N2); ENT(L0); GOTO PP;
ENDIF;

N2: IF GAM2 = EOLCH DO; LBRK(); CH(N0); GOTO SCAN;
ELSE DO; STERF(); ENT(L0); GOTO SCAN;
ENDIF;

N3: IF GAM2 = '.' DO; CH(N2); ENT(L0); GOTO PP;
ELSE DO; CH(N0); GOTO PP;
ENDIF;

* TABLE PROCESSOR
T0:}"IF GAM2 = EOLCH DO; LBRK(); GOTO SCAN;
ELSEIF GAM2 = '.' DO; GOTO C0;
ELSEIF GAM2 = EODCH DO; EBRK();
ELSEIF GAM2 = ' ' DO; CH(T1); GOTO SCAN;
ELSEIF GAM2 = TABCH DO; SYPPC(GAM2); CH(T3); GOTO SCAN;
ELSE DO; CH(T2); ENT(L0); GOTO PP;
ENDIF;

T1: IF GAM2 = EOLCH DO; LBRK(); CH(T0); GOTO SCAN;
ELSEIF GAM2 = TABCH DO; PABRK(); SYPPC(TABCH); CH(T3); GOTO SCAN;
ELSEIF GAM2 = ' ' DO; GOTO SCAN;
ELSE DO; PABRK(); CH(T2); ENT(L0); GOTO PP;
ENDIF;

T2: IF GAM2 = EOLCH DO; CH(T4); GOTO SCAN;
ELSEIF GAM2 = TABCH DO; SYPPC(GAM2); CH(T3); GOTO SCAN;
ELSE DO; STERF(); ENT(L0); GOTO SCAN;
ENDIF;

T3: IF GAM2 = EOLCH DO; CH(T0); GOTO SCAN;
ELSEIF GAM2 = TABCH DO; SYPPC(GAM2); GOTO SCAN;
ELSE DO; CH(T2); ENT(L0); GOTO PP;
ENDIF;

T4: IF GAM2 = EOLCH DO; LBRK(); CH(T0); GOTO SCAN;
ELSEIF GAM2 = '.' DO; GOTO C0;
ELSEIF GAM2 = EODCH DO; EBRK();
ELSEIF GAM2 = ' ' DO; CH(T1); GOTO SCAN;
ELSEIF GAM2 = TABCH DO; SYPPC(GAM2); CH(T3); GOTO SCAN;
ELSE DO; WBRK(SBRK); CH(T2); ENT(L0); GOTO PP;
ENDIF;

T5: IF GAM2 = '.' DO; CH(T2); ENT(L0); GOTO PP;
ELSE DO; CH(T0); GOTO PP;
ENDIF;

*
* STATES FOR WORD PROCESSING
*

* FORCE NEXT CHARACTER TO OPPOSITE STATE
SH:}$(STERF() & GOTO SCAN) IF CTRL(GAM2) ELSE
}'GAM2 _ GAM2 - CSHFT IF GAM2 > '_' ELSE
}'GAM2 _ GAM2 + CSHFT IF GAM2 > '?';
}'GOTO RPT;

* CAPITALIZE CHARACTER IF LOWER-CASE
CP: GAM2 _ GAM2 - CSHFT IF GAM2 > 100B AND GAM2 <= 137B; GOTO RPT;

* COLLECT CHARACTER POSITION
PS0: IF GAM2 = DSCH DO; CH(PS1); ENT(CP) IF CAPFG < 0; ENT(SH); GOTO SCAN;
ELSEIF CTRL(GAM2) DO; STERF(); GOTO SCAN;
ELSE DO; CH(PS1); ENT(CP) IF CAPFG < 0; GOTO PP;
ENDIF;

PS1: IF CTRL(GAM2) DO; STERF(); GOTO SCAN;
ELSE DO; SYPPC(GAM2); CH(PS2); GOTO SCAN;
ENDIF;

PS2: IF GAM2 = BSPCH DO; CH(PS3); GOTO SCAN;
ELSE DO; GOTO RPT;
ENDIF;

PS3: IF GAM2 = DSCH DO; CH(PS4); ENT(CP) IF CAPFG < 0; ENT(SH); GOTO SCAN;
ELSEIF CTRL(GAM2) DO; STERF(); GOTO SCAN;
ELSE DO; CH(PS4); ENT(CP) IF CAPFG < 0; GOTO PP;
ENDIF;

PS4: IF CTRL(GAM2) DO; STERF(); GOTO SCAN;
ELSE DO; SYPPC(BSPCH); SYPPC(GAM2); CH(PS2); GOTO SCAN;
ENDIF;

* UNDERLINE NEXT POSITION
UL: SYPPC(BSPCH); SYPPC(ULCH); GOTO RPT;

* WORD PROCESSOR
W0: ULWFG _ CAPFG _ 0; CH(W1);

W1: IF GAM2 = ULSCH DO; CH(W3); GOTO SCAN;
ELSEIF GAM2 = ULWCH DO; ULWFG _ -1; GOTO SCAN;
ELSEIF GAM2 = CAPCH DO; CAPFG _ -1; GOTO SCAN;
ELSEIF GAM2 = DSCH DO;
ELSEIF CTRL(GAM2) DO; STERF(); GOTO SCAN;
ENDIF;
}'CH(W2); ENT(UL) IF ULWFG < 0; ENT(PS0); GOTO PP;

W2: IF WTRM(GAM2) DO; GOTO RPT;
ELSEIF GAM2 = ESGCH DO; ULWFG _ CAPFG _ 0; CH(W1); GOTO SCAN;
ELSE DO; CH(W1); GOTO PP;
ENDIF;

* ABNORMAL UNDERLINE
W3: (CAPFG _ -1 & GOTO SCAN) IF GAM2 = CAPCH;
}'CH(W4); ENT(UL); ENT(PS0); GOTO PP;

W4:}$CAPFG _ 0 IF WTRM(GAM2);
}$IF LTRM(GAM2) DO; GOTO RPT;
ELSEIF GAM2 = ' ' DO; IBRK(1); CH(W5); GOTO SCAN;
ELSEIF GAM2 = ESGCH DO; CH(W2); GOTO PP;
ELSE DO; CH(W3); GOTO PP;
ENDIF;

W5: IF LTRM(GAM2) DO; GOTO RPT;
ELSEIF GAM2 = ' ' DO; MBRK _ MBRK + 1; GOTO SCAN;
ELSEIF GAM2 = ESGCH DO; WBRK(MBRK); CH(W2); GOTO PP;
ELSE DO; WBRK(MBRK); CH(W3); GOTO PP;
ENDIF;


* LINE PROCESSOR
L0: GOTO L0C IF WCTL(GAM2) ELSE GOTO L0D IF CTRL(GAM2) ELSE GOTO L0C;

L3C:}#WBRK(1);
L0C:}#CH(L1); ENT(W0); GOTO PP;

L0D:}#STERF(); GOTO SCAN;


L1: GOTO L1A IF LTRM(GAM2) ELSE GOTO L1B IF GAM2 = ' ' ELSE
}'GOTO L1C IF STRM(GAM2) ELSE GOTO L1D IF BTRM(GAM2) ELSE GOTO L0D;

L1A:}#IBRK(1); GOTO RPT;
L1B:}#IBRK(1); CH(L5); GOTO SCAN;
L1C:}#IBRK(2); CH(L2); SYPPC(GAM2); GOTO SCAN;
L1D:}#IBRK(1); CH(L4); SYPPC(GAM2); GOTO SCAN;

L2: GOTO L2A IF LTRM(GAM2) ELSE GOTO L2B IF GAM2 = ' ' ELSE
}'GOTO L2C IF TTRM(GAM2) ELSE GOTO L0C IF WCTL(GAM2) ELSE
}'GOTO L2E IF GAM2 = BSPCH ELSE GOTO L0D IF CTRL(GAM2) ELSE
}'GOTO L1C IF STRM(GAM2) ELSE GOTO L1D IF BTRM(GAM2) ELSE
}'GOTO L0C;

L2A:}#GOTO RPT;
L2B:}#CH(L3); GOTO SCAN;
L2C:}#SYPPC(GAM2); GOTO SCAN;
L2E:}#CH(L1); ENT(W2); ENT(PS3); GOTO SCAN;

L3: GOTO L1A IF LTRM(GAM2) ELSE GOTO L4A IF GAM2 = ' ' ELSE
}'GOTO L3C IF WCTL(GAM2) ELSE GOTO L0D IF CTRL(GAM2) ELSE
}'GOTO L3C;

L4: GOTO L2A IF LTRM(GAM2) ELSE GOTO L4A IF GAM2 = ' ' ELSE
}'GOTO L4B IF WCTL(GAM2) ELSE GOTO L2E IF GAM2 = BSPCH ELSE
}'GOTO L0D IF CTRL(GAM2) ELSE GOTO L2C IF TTRM(GAM2) ELSE
}'GOTO L1D IF BTRM(GAM2) ELSE GOTO L1C IF STRM(GAM2) ELSE
}'GOTO L4B;

L4A:}#CH(L5); GOTO SCAN;
L4B:}#WBRK(0); GOTO L0C;

L5: IF LTRM(GAM2) DO; GOTO RPT;
ELSEIF GAM2 = ' ' DO; MBRK _ MBRK + 1; GOTO SCAN;
ELSEIF WCTL(GAM2) DO; WBRK(MBRK); GOTO L0C;
ELSEIF CTRL(GAM2) DO; GOTO L0D;
ELSE DO; WBRK(MBRK); GOTO L0C;
ENDIF;

* FORMAT FIELD DEFINITION PROCESSOR
DECLARE *CPDFF, $DFMTP, $DFMTI, $DFMTS,
}'DFMTL, DFMTF, DFMTJ, DFMTC, DFMTK, DFMTX, DFMTY;

* BEGINNING OF FORMAT LINE
P0:}$DFMTJ _ DFMTL _ DFMTC _ 0; DFMTF _ MAKE(100);
}'$DFMTX _ CH1(5) FOR DFMTX _ DFMTF + 99 BY -1 TO DFMTF;
}'CH(P1); ENT(P2); ENT(P3); GOTO PP;

* BEGINNING OF NEXT FORMAT LINE
P1:}$GOTO SCAN IF GAM2 = EOLCH;
IF GAM2 = '.' DO; GOTO C0;
ELSEIF DFMTI >= 10 DO; ENT(P9); GOTO SCAN;
ELSE DO; CH(P0); GOTO PP;
ENDIF;

* STORE FORMAT LINE
P2:}$DFMTP[DFMTI] _ DFMTF; TRUNC(DFMTF, DFMTJ);
}'DFMTI _ DFMTI + 1; (STERF() & FREE(DFMTF) & GOTO RPT) IF
}/DFMTI >= 10;
}'DFMTP.CH2 _ MAX(DFMTL, DFMTP.CH2); GOTO RPT;

* STORE FORMAT SEGMENT AND INCREMENT LINE LENGTH
FUNCTION SFFLD(SFFLDS, SFFLDC);
}'IF DFMTJ >= 100 DO; CH(P9); STERF(); GOTO SCAN; ENDIF;
}'DFMTF[DFMTJ] _ SFFLDS; DFMTJ _ DFMTJ + 1;
}'DFMTL _ DFMTL + SFFLDC; CH(P3); RETURN;

* BEGGINNG OF FORMAT SEGMENT
P3: IF LTRP(GAM2) DO; DFMTK _ (DFMTX _ GAM2) - 'A';
}'DFMTY _ DFMTX + CSHFT; DFMTC _ 0; CH(P8);
}'(STERF() & CPDFF[DFMTK] _ 0 & DFMTS _ DFMTS + 1)
}/IF CPDFF[DFMTK] = -1 ELSE
}*(CPDFF[DFMTK]$CH1 _ 0 & DFMTS _ DFMTS + 1)
}/IF CPDFF[DFMTK] < 0;
}'GOTO PP;
ELSEIF LLTR(GAM2) DO; GAM2 _ GAM2 - CSHFT; GOTO PP;
ELSEIF GAM2 = DQCH DO; CH(P6); GOTO SCAN;
ELSEIF GAM2 = ' ' DO; DFMTC _ 0; CH(P4); GOTO PP;
ELSEIF GAM2 = EOLCH DO; GOTO XIT;
ELSEIF CTRL(GAM2) DO; STERF(); GOTO SCAN;
ELSE DO; CH(P5); DFMTC _ GAM2; GOTO SCAN;
ENDIF;

* BLANK SEGMENT
P4:}$(DFMTC _ DFMTC + 1 & GOTO SCAN) IF GAM2 = ' ';
}'SFFLD(CH1(5) OR CH2(DFMTC), DFMTC); GOTO PP;

* LITERAL SEGMENT
P5: IF LTRP(GAM2) OR LLTR(GAM2) OR GAM2 = ' ' OR GAM2 = EOLCH DO;
}'SFFLD(CH1(6) OR CH3(DFMTC), 1); GOTO PP;
ELSEIF CTRL(GAM2) DO; STERF(); GOTO SCAN;
ELSEIF GAM2 = DQCH DO; CH(P7); GOTO SCAN;
ELSE DO; SFFLD(CH1(7) OR CH2(DFMTC) OR CH3(GAM2), 2); GOTO SCAN;
ENDIF;

* STRING SEGMENT
P6: IF CTRL(GAM2) DO; STERF(); GOTO SCAN;
ELSEIF GAM2 = DQCH DO; CH(P3); GOTO SCAN;
ELSE DO; DFMTC _ GAM2; CH(P7); GOTO SCAN;
ENDIF;

P7: IF CTRL(GAM2) DO; STERF(); GOTO SCAN;
ELSEIF GAM2 = DQCH DO; SFFLD(CH1(6) OR CH3(DFMTC), 1); GOTO SCAN;
ELSE DO; SFFLD(CH1(7) OR CH2(DFMTC) OR CH3(GAM2), 2); CH(P6); GOTO SCAN;
ENDIF;

* TEXT SEGMENT
P8:}$(DFMTC _ DFMTC + 1 & GOTO SCAN) IF GAM2 = DFMTX OR GAM2 = DFMTY;
}'SFFLD(CH1(CPDFF[DFMTK]$CH3) OR CH2(DFMTC) OR CH3(DFMTK), DFMTC);
}'GOTO PP;

* SKIP REST OF FMT LINE
P9:}$GOTO SCAN IF GAM2 # EOLCH ELSE GOTO XIT;

*
* PASS I - CONVERT FROM EXTERNAL FORMAT TO INTERNAL CHARACTER SET
*
* CVC:
*}&(1) HANDLES CASE SHIFTS
*}&(2) DELETES UNUSED CONTROL CHARACTERS
*}&(3) CONVERTS SPACE/BACKSPACE SEQUENCES TO CANONICAL FORM
*

DECLARE GAM1, LCCFG, LCLFG, SHFG, PSFG, MBC, MCHAR, SCHAR, TCHAR,
}'CVCGL, *CVCGC, *CVCPC, *MNSTR, *DIF, *ERFLG;

DECLARE FIXED STRING DTST; DECLARE PARAMETER RTOD _ 39;
DECLARE FIXED STRING ARRAY MTHST(12) _ "*ANUARY", "&&EBRUARY",
}'"-ARCH", "!PRIL", "-AY", "*UNE", "*ULY", "!UGUST",
}'"3EPTEMBER", "/CTOBER", ".OVEMBER", "$ECEMBER";

* GET CHARACTERS FROM MACRO BODY
FUNCTION GMC(); RETURN GCI(MNSTR: GMC1);
GMC1:}"CVCGL _ CVCGC; RETURN CVCGC();

* ESCAPE AND SHIFT PROCESSORS
FUNCTION $PRES(MCHAR), LINK XPRCH; RETURN;

FUNCTION $PRSH(SCHAR), LINK XPRCH; RETURN;

FUNCTION $PRTC(TCHAR), LINK XPRCH; RETURN;


FUNCTION $PRCL(); CVCGL _ GMC; RETURN;


FUNCTION $ICVP();* INITIALIZE CVC
}'PSFG _ SHFG _ LCCFG _ 0; LCLFG _ -1;
}'MCHAR _ '^'; SCHAR _ '/'; TCHAR _ '\';
}'CVCGL _ CVCGC _ CNCTR(FTLERR); CVCPC _ CNCTR(CVC1);
}'LINC _ 1; ERFLG _ -1; RETURN;

FUNCTION $DCVP(); FREE(CVCGC); FREE(CVCPC); RETURN;

CVC1: GAM1 _ CVCGL();* READ CHARACTER AND TEST
}#IF GAM1 = MCHAR DO; GAM1 _ CVCGL();* PROCESS META CHARACTER SEQUENCE

}'IF GAM1 = MCHAR OR GAM1 = SCHAR OR GAM1 = TCHAR DO;
}/GOTO CVC3;* SAVE LITERAL META CHAR

}'ELSEIF GAM1 = 'A' DO; SHFG _ 0;
}/LCLFG _ LCCFG _ -1;* SHIFT ALL UPPER CASE CHARACTERS

}'ELSEIF GAM1 = 'L' DO; SHFG _ LCCFG _ 0;
}/LCLFG _ -1;* SHIFT UPPER CASE LETTERS ONLY

}'ELSEIF GAM1 = 'U' DO; LCCFG _ LCLFG _ 0;* NO SHIFTING DESIRED
}'ELSEIF GAM1 = 'S' DO; SHFG _ -1;* NO SHIFTING FOR 'NEXT' CHARACTER

}'ELSEIF GAM1 = 'Y' DO; BRS(RTOD:: MBC);* OUTPUT DATE STRING
}*BCOPY(DTST, MTHST[MBC$CH2 - 1], 4);
}*CVCPC(GAM1 + CSHFT) FOR GAM1 _ GCI(DTST: CVC2) WHILE 1;
CVC2:}%CVCPC(' '); CVCPC(GAM1 / 10 OR 20B) IF (GAM1 _ MBC$CH3) > 9;
}/CVCPC(GAM1 MOD 10 OR 20B);
}*CVCPC(','); CVCPC(' '); CVCPC('1'); CVCPC('9');
}*CVCPC((GAM1 _ MBC$CH1)/ 10 OR 20B); CVCPC(GAM1 MOD 10 OR 20B);

}'ELSE DO;
}*CVCPC(ULWCH IF GAM1 = 'I' ELSE ULSCH IF GAM1 = '-'
}/ELSE TABCH IF GAM1 = 'T' ELSE ESGCH IF GAM1 = 'E'
}/ELSE BSPCH IF GAM1 = 'B' ELSE DSCH IF GAM1 = 'D'
}/ELSE CAPCH IF GAM1 = 'C' ELSE ERRCH);* SAVE FORMATTING CHARACTERS
}'ENDIF;
}'GOTO CVC1;

ELSEIF GAM1 = SCHAR DO; SHFG _ -1; GOTO CVC1;

ELSEIF GAM1 = TCHAR DO; CVCPC(TABCH); GOTO CVC1;
ENDIF;

CVC3: IF GAM1 <= '?' DO;* NON-SHIFTING/360 CHARACTER
}'(GAM1 _ GAM1 + PSHFT & PSFG _ 0) IF PSFG < 0;

ELSEIF GAM1 > '@' AND GAM1 <= 'Z' DO;* SHIFT LETTERS IF CALLED FOR
}'(SHFG _ 0 IF SHFG < 0 ELSE GAM1 _ GAM1 + CSHFT) IF LCLFG < 0;

ELSEIF GAM1 = MBCH DO;* EXPAND MULTIPLE BLANKS
}'CVCPC(' ') FOR GAM1 _ CVCGL() - 1 BY -1 TO 0; GOTO CVC1;

ELSEIF GAM1 > 177B DO; CVCPC(GAM1 - CSHFT); GOTO CVC1;* 360 CHARACTER
ELSEIF GAM1 > CGTCH DO;* PROCESS CONTROL CHARACTERS

}$IF GAM1 = AACH DO; SHFG _ 0; LCLFG _ LCCFG _ -1;* SHIFT ALL
}$ELSEIF GAM1 = ALCH DO; SHFG _ LCCFG _ 0; LCLFG _ -1;* SHIFT LETTERS
}$ELSEIF GAM1 = UACH DO; LCCFG _ LCLFG _ 0;* NO SHIFTING
}$ELSEIF GAM1 = SHCH DO; SHFG _ -1;* SINGLE NO-SHIFT
}$ELSEIF GAM1 = PSCH DO; PSFG _ -1;* SHIFT TO 360

}$ELSEIF GAM1 = EOFCH DO;
}'CVCPC(EOLCH); CVCPC(EODCH); FTLERR();* END-OF-FILE
}$ELSEIF GAM1 = LFCH DO;* LINE FEED
}'IF ERFLG >= 0 DO; CRLF(1);
}*SOUT("ERROR IN LINE "); IOUT(LINC); ENDIF;
}'LINC _ LINC + 1 IF CVCGL # GMC; ERFLG _ -1;
}$ELSEIF GAM1 = CRCH DO; CVCPC(EOLCH);* CARRIAGE RETURN
}$ELSEIF GAM1 = PBSCH DO; CVCPC(BSPCH);* BACKSPACE
}$ELSEIF GAM1 # NPCH DO; STERF();
}$ENDIF;
}'GOTO CVC1;

ELSEIF GAM1 <= '_' DO;* SHIFT NON-ALPHABETIC UPPER-CASE IF CALLED FOR
}'(SHFG _ 0 IF SHFG < 0 ELSE GAM1 _ GAM1 + CSHFT) IF LCCFG < 0;

ENDIF;
}'CVCPC(GAM1); GOTO CVC1;* SAVE CHAR

*
* PASS 0 - BUFFER THE INPUT FILE
*

DECLARE GCHW, GCHE, GCHF, GCHP, GCHL, *GCHPC;

FUNCTION $IGCH(); GCHPC _ CNCTR(GCH1);
}'GCHF _ MAKE(256); GCHL _ GCHF + 255; GCHE _ 0; RETURN;

FUNCTION $DGCH(); FREE(GCHPC); FREE(GCHF); RETURN;

GCH1:}"POP(BIO, DIF, GCHL - GCHF + 1,, GCHF: GCH3:);

GCH2:}"FOR GCHP _ GCHF TO GCHL DO;

}'GCHW _ $GCHP; GCHPC(GCHW$CH1); GCHPC(GCHW$CH2); GCHPC(GCHW$CH3);

ENDFOR;
}'GOTO GCH1 IF GCHE >= 0; GCHPC(EOFCH); FTLERR();

GCH3:}"SAVE(GCHL); GCHL _ GCHL + 1; GCHE _ -1; GOTO GCH2;

}'END;

* CANONICAL BUFFERING SUBROUTINES
DECLARE CCHP, MCHP, FCHP, FIELD CVCBL(0: 10, 23);
DECLARE FIXED ARRAY CVCB[400];

FUNCTION BSCH(GAM1); CCHP _ CCHP + 1;* BUFFER SPACING CHARACTER

IF CCHP > MCHP DO; HALT() IF MCHP = FCHP;
}'CVCB[CCHP] _ CH1(GAM1); MCHP _ MCHP + 1;

ELSEIF CVCB[CCHP] = 0 DO; CVCB[CCHP] _ CH1(GAM1);

ELSE DO; CVCB[FCHP] _ CVCB[CCHP]; CVCB[CCHP] _ CH1(GAM1) OR CVCBL(FCHP);
}'FCHP _ FCHP - 1; HALT() IF FCHP = MCHP;

ENDIF;
}'RETURN;

FUNCTION BCCH(GAM1);* BUFFER CONTROL CHARACTER
}'BSCH(GAM1); CCHP _ CCHP - 1; RETURN;

FUNCTION BMSP(GAM1); CCHP _ CCHP + GAM1;* BUFFER MUTIPLE SPACES

IF CCHP > MCHP DO;

}'CVCB[MCHP] _ 0 FOR MCHP _ MCHP + 1 TO CCHP;
}'MCHP _ CCHP; HALT() IF MCHP >= FCHP;

ENDIF;
}'RETURN;

FUNCTION DCB(); DECLARE DCBT;* DUMP BUFFER

FOR CCHP _ 0 TO MCHP DO; DCBT _ CVCB[CCHP];

}$IF DCBT$CVCBL = 0 DO; CVCPC(GAM1 _ DCBT$CH1);
}'CVCPC(' ') IF GAM1 > 140B-1;

}$ELSE DO;
DCB1:}"GAM1 _ DCBT$CH1;

}'IF GAM1 > 140B-1 DO; CVCPC(GAM1);
}+IF (DCBT _ DCBT$CVCBL) = 0 DO;
}/CVCPC(' '); GOTO DCB4;
}+ELSE DO; CVCB[CCHP] _ DCBT _ CVCB[DCBT]; GOTO DCB1;

}+ENDIF;
}'ENDIF;

}'FCHP _ CCHP;

DCB2:}"GOTO DCB3 IF (DCBT _ CVCB[FCHP]$CVCBL) = 0;

}'DCBT _ CVCB[DCBT]; GAM1 _ DCBT$CH1;

}'IF GAM1 > 140B-1 DO; CVCPC(GAM1);
}+CVCB[FCHP]$CVCBL _ DCBT _ DCBT$CVCBL;
}+GOTO DCB3 IF DCBT = 0 ELSE GOTO DCB2;

}'ELSE DO; FCHP _ CVCB[FCHP]$CVCBL; GOTO DCB2;

}'ENDIF;

DCB3:}"CVCPC(CVCB[FCHP _ CCHP]$CH1);

}'(CVCPC(BSPCH) & CVCPC(CVCB[FCHP]$CH1))
}/FOR FCHP _ CVCB[FCHP]$CVCBL WHILE FCHP > 0;

}$ENDIF;
DCB4: ENDFOR;

}'CCHP _ MCHP _ -1; FCHP _ 400-1; RETURN;

}'END;

********************}"NFP}"************************

**QSPL
}'IDENT FPROC;


* GENERAL FIELD AND PARAMETER DEFINITIONS FOR RUNOFF

* FIELDS FOR STRING DESCRIPTORS
DECLARE FIELD $BPTR(0), $RPTR(1), $WPTR(2), $EPTR(3);
DECLARE FIELD CH1(0:0,7),CH2(0:8,15),CH3(0:16,23);
DECLARE FIELD BLKBIT(0:16,17), BLKCNT(0:18,23);
DECLARE FIELD LENGF(-1: 10, 23), LKPNC(0: 0, 9), LKPTR(0: 10,23);

DECLARE MACRO MAKARY(X) _ MAKE(X) OR 2B7;

* CHARACTER VALUE DEFINITIONS
DECLARE PARAMETER CRCH _ 155B, LFCH _ 152B, EJCH _ 154B,
}'ULCH _ 100B, NULCH _ 140B, CSHFT _ 40B, CGTCH _ 137B;

DECLARE PARAMETER VSPCH _ 202B, EOCCH _ 203B, EODCH _ 204B,
}'BSPCH _ 210B, TABCH _ 211B, COMCH _ 213B,
}'EOPCH _ 214B, EOLCH _ 215B, BFNCH _ 216B, EFNCH _ 217B;

* EXTERNALS
DECLARE *FILLF, *FMTP, *ULNF, *JUSTF, *DSPF, *HYPF, *PAGF, *TOPGF,
}'*DIF, *DOF, *IHYFLG, *ERFLG, *GLPRF, *GLTAB, *HYB, *HYPT,
}'*RINAD, *SINAD;
DECLARE *TRUNC, *TRUNCZ, *CNCTR, *CONEC, *ICNCT, *INS, *LKP,
}'*MAX, *MIN, *INSGW;

DECLARE FIXED STRING STLFP(300), STRPTL, STCPY, IPPFS _ "P&101&107&105}"",
}'PAGST(5), PPFST(48), PSCST(30), PSFST(30), HEDST(132);
DECLARE PAGARY, PFPGC, GNLC, CFMCH, PMODE, HMODE, PAGNO, NHDCH, NPFCH, NSCCH,
}'NSFCH, LHDPOS, RHDPOS, LPGPOS, RPGPOS;
DECLARE LMODE, OPGBL, EPGBL, TPBL, PLENG, CSLOP,
}'CSPC, LWIDTH, NCOL, RLMAR, LLMAR;
DECLARE CHRCNT, CHRMAX, FRTBL, PGBL, CLJCH, NLJCH, OLJCH,
}'LJSTBL, LJSTPT, LNPTY;
DECLARE LFCNT, LINCNT, LINMAX, COLMAX, TSPC, GSPC,
}'PBB, PBI, PBJ, PBK, PBM, ARRAY PBF, PCB;
DECLARE HYCNT, HYMCT, HYPTR, HYIND, HYPFCT, HYFLG, HYBWP, HYBPT, WHPS,
}'IHYCH, IHYCNT, IHYRB, IHYWB, IHYBRP;
DECLARE FLCNT, FLPCT, FMTF, FTXT, FTXTP, FMTSP, FMTCC, FMTI, FOPL,
}'FMTC1, FMTC2, FMTC3, FOPPT, FIXED STRING FTXTS;
DECLARE IXTAB, SCTAB, INXCH, IXTBP, IXPTR, IXLPTR, IXPPTR, IXLLEN,
}'IXI, IXB, ARRAY IXF, FIXED STRING INXST(48);

DECLARE MACRO STERF()_ ERFLG _ ERFLG + 1;

DECLARE MACRO LTRP(X) _ (X) > '@' AND (X) <= 'Z';
DECLARE MACRO DGTP(X) _ (X) > '/' AND (X) <= '9';

* CONTROL FUNCTIONS FOR LINE FORMATTING
FUNCTION CPBL();
}'PGBL _ (EPGBL IF (HMODE = 2 OR PMODE = 3)
}3AND PAGNO MOD 2 = 0 ELSE OPGBL);
}'COLMAX _ (LINMAX - LINCNT)* NCOL; RETURN;

* INPUT/OUTPUT FUNCTIONS FOR PASS III

FUNCTION GNCS(); RETURN GCI(STRPTL:GNCS1);

GNCS1: GNLC _ PFPGC; RETURN PFPGC();


DECLARE FIELD FPCHB(0: 0, 0), FPCHE(0: 1, 1), FPCHG(0: 2,2),
}'FPCHL(0: 3, 8), FPCHP(0: 10, 23);
DECLARE PCHN, PCHW, PCHF, PCHP, PCHL, PCHB, PCHG, PCHCC;

FUNCTION LFILL(); PCHR(EOLCH);* CHECK FOR EMPTY BUFFER!

IF PCHN = 1 DO;
}'PCHW _ PCHW LSH 16 OR (CH2(NULCH) OR CH3(NULCH)); GOTO LFILL1;

ELSEIF PCHN = 0 DO;
}'PCHW _ PCHW LSH 8 OR CH3(NULCH); GOTO LFILL1;

ELSE DO; GOTO LFILL2;
ENDIF;

LFILL1: FTLERR() IF (PCHP _ PCHP + 1) > PCHL; $PCHP _ PCHW;

LFILL2: PCHL _ PCHP - PCHF; TRUNCZ(PCHF, PCHL + 1, PAGARY); RETURN;

FUNCTION PFILL(), LINK LPINIT;
}'LFILL(); $PCHF _ CH1(PCHL) OR CH3(PCHCC);

IF PBI >= PBF.LENGF - 2 - LFCNT DO; PCHP _ MAKARY((PBF.LENGF * 3)/ 2);
}'BCOPY(PCHP, PBF, PBI); FREE(PBF); PBF _ PCHP; ENDIF;

}'PCHB _ (FPCHB(-1) IF PCHB < 0 ELSE 0) OR
}/(FPCHG(-1) IF GSPC >= 0 OR PCHG < 0 ELSE 0);

}'(PBF[PBI] _ PCHB & PBI _ PBI + 1)
}/FOR LFCNT _ LFCNT - 1 BY -1 TO 0;

}'PBF[PBI] _ PCHB OR (0 IF ERFLG < 0 ELSE FPCHE(-1))
}/OR FPCHP(PCHF); PBI _ PBI + 1;
}'GSPC _ -1 IF (GSPC _ GSPC - 1) < 0; LFCNT _ PCHB _ 0;
}'LNPTY _ (0 IF LNPTY < 0 ELSE -1); GOTO PINIT1;

FUNCTION PINIT(), LINK LPINIT;

PINIT1: PCHP _ PCHF _ MAKE(133, PAGARY); PCHL _ PCHF + 132;
}'PCHW _ ''; PCHN _ 2; ERFLG _ -1; RETURN;


FUNCTION PLF(PCHC), LINK LPCH;

}'LFCNT _ LFCNT + PCHC;
}'(GSPC _ -1 & PCHB _ -1 IF PCHG >= 0) IF (GSPC _ GSPC - PCHC) < 0;
}'RETURN;

FUNCTION PCHR(PCHC), LINK LPCH;

}'PCHW _ PCHW LSH 8 OR PCHC; RETURN IF (PCHN _ PCHN - 1) >= 0;

}'FTLERR() IF (PCHP _ PCHP + 1) > PCHL;
}'$PCHP _ PCHW; PCHW _ 0; PCHN _ 2; RETURN;

FUNCTION PSTR(PSTRST); DECLARE FIXED STRING PSTRTS;
}'BCOPY(PSTRTS, PSTRST, 4);
PSTR1: PCHR(GCI(PSTRTS: PSTR2)); GOTO PSTR1;
PSTR2: RETURN;

* CONVERT LINE TO NO-BACKSPACE FORM AND OUTPUT IT
FUNCTION LDMP(LDMPP); DECLARE CLDCH, NLDCH, LDMPSP, LDMPI,
}'FIXED STRING STLD1, STLD2;

}'COUT(LFCH, DOF) FOR LDMPI _ LDMPP$FPCHL - 1 BY -1 TO 0;
}'(COUT('*', DOF) & COUT(CRCH, DOF)) IF LDMPP$FPCHE # 0;

}'LDMPP _ LDMPP$FPCHP; SETUP(STLD1, LDMPI _ 3*LDMPP[0], LDMPP + 1);
}'BCOPY(STLD2, STLD1, 4); SETW(STLD1, LDMPI);

LDMP1: LDMPSP _ 0; COUT(' ', DOF) FOR LDMPI _ PGBL - 1 BY -1 TO 0;

}'NLDCH _ GCI(STLD1);
LDMP2: CLDCH _ NLDCH; GOTO LDMP7 IF CLDCH = EOLCH; NLDCH _ GCI(STLD1);
LDMP3: GOTO LDMP2 IF CLDCH = NULCH; GOTO LDMP5 IF CLDCH = BSPCH;
}'GOTO LDMP4 IF CLDCH > BLKBIT(-1)-1; LDMPSP _ LDMPSP + 1;
}'COUT(CLDCH + CSHFT IF CLDCH > CGTCH ELSE CLDCH, DOF);
}'GOTO LDMP2;

LDMP4: LDMPI _ CLDCH$BLKCNT;
IF NLDCH = BSPCH DO; WCI(BLKBIT(-1) OR LDMPSP, STLD2) IF
}/(LDMPSP _ LDMPSP - 1) > 0;
}'LDMPSP _ LDMPI; NLDCH _ GCI(STLD1);
}'COUT(NLDCH, DOF) FOR LDMPI _ LDMPI - 1 BY -1 TO 0;
}'NLDCH _ GCI(STLD1); GOTO LDMP2 IF NLDCH # BSPCH; FTLERR();
ELSE DO; LDMPSP _ LDMPSP + LDMPI;
}'COUT(' ', DOF) FOR LDMPI _ LDMPI - 1 BY -1 TO 0; GOTO LDMP2;
ENDIF;

LDMP5: (FTLERR() IF LDMPSP > (77B+77B) ELSE
}+(WCI(BLKBIT(-1) OR 77B, STLD2) &
}/WCI(BLKBIT(-1) OR LDMPSP - 77B, STLD2)) IF
}3LDMPSP > 77B ELSE
}+WCI(BLKBIT(-1) OR LDMPSP, STLD2)) IF
}/(LDMPSP _ LDMPSP - 1) > 0; LDMPSP _ 0;

LDMP6: WCI(NLDCH, STLD2); NLDCH _ GCI(STLD1);
}'GOTO LDMP2 IF NLDCH # BSPCH; WCI(NLDCH, STLD2);
}'NLDCH _ GCI(STLD1); GOTO LDMP6;

LDMP7: COUT(CRCH, DOF);
IF STLD2.WPTR # STLD2.BPTR DO; WCI(EOLCH, STLD2);
}'BCOPY(STLD1, STLD2, 4); SETS(STLD2, 0, 0); GOTO LDMP1;
ENDIF;
}'COUT(LFCH, DOF); FREE(LDMPP, PAGARY); RETURN;

* DUMP HEADER LINE
FUNCTION HFILL(); LFILL(); $PCHF _ PCHL;
}'PBF[0] _ (0 IF ERFLG < 0 ELSE FPCHE(1)) OR FPCHL(LFCNT)
}/OR FPCHP(PCHF); PBB _ PBI _ 1; LINCNT _ LFCNT + 1;
}'PINIT(); RETURN;

* COMPUTE HEADING AND PAGING POSITION
FUNCTION CPHP();
}'LHDPOS _ (((LWIDTH - NHDCH)/ 2 IF HMODE = 1 ELSE
}+LWIDTH - NHDCH IF HMODE = 3 OR
}/(HMODE = 2 OR HMODE = 4 AND PMODE = 3)
}3AND PAGNO MOD 2 = 0 ELSE 0) IF NHDCH > 0 ELSE -1);
}'RHDPOS _ LHDPOS + NHDCH - 1;

}'CNS(PAGNO, PAGST); RPGPOS _ LENGTH(PAGST) + NPFCH + NSCCH + NSFCH - 1;
}'LPGPOS _ ((LWIDTH - RPGPOS)/ 2 IF PMODE = 2 ELSE
}+LWIDTH - RPGPOS IF PMODE = 1 OR
}/PMODE = 3 AND PAGNO MOD 2 = 1 ELSE 0);
}'RPGPOS _ RPGPOS + LPGPOS; RETURN;

* OUTPUT HEADING STRING
FUNCTION HOUT(); SETR(HEDST, 0);
IF LHDPOS < CHRCNT DO; STERF();* DELETE FIRST PART OF HEADER
HOUT1: CLDCH _ GCI(HEDST: HOUT5);
}'(GCI(HEDST) & GOTO HOUT1) IF CLDCH = BSPCH;
}'LHDPOS _ LHDPOS + 1; GOTO HOUT1 IF LHDPOS < CHRCNT;
ELSE DO;
}'PCHR(BLKBIT(-1) OR LHDPOS - CHRCNT); CHRCNT _ LHDPOS;
ENDIF;

HOUT2: CLDCH _ GCI(HEDST: HOUT5); GOTO HOUT4 IF CLDCH = BSPCH;
HOUT3: CHRCNT _ CHRCNT + 1; (STERF() & GOTO HOUT5)
}/IF CHRCNT >= LPGPOS AND LHDPOS < RPGPOS AND LPGPOS >= 0;
}'PCHR(CLDCH); GOTO HOUT2;

HOUT4: PCHR(CLDCH); PCHR(GCI(HEDST)); CLDCH _ GCI(HEDST: HOUT5);
}'GOTO HOUT3 IF CLDCH # BSPCH ELSE GOTO HOUT4;

HOUT5: RETURN;

* OUTPUT PAGE STRING
FUNCTION POUT(); PCHR(BLKBIT(-1) OR LPGPOS - CHRCNT); CHRCNT _ RPGPOS;
}'PSTR(PPFST); PSTR(PSCST); PSTR(PAGST); PSTR(PSFST); RETURN;

* OUTPUT TITLE AND INITIALIZE NEW PAGE
FUNCTION NEWPG();

}'LFCNT _ TPBL; PBB _ PBI _ LINCNT _ 0; GSPC _ -1;
}'LINMAX _ (-2 IF TOPGF >= 0 AND PAGF < 0 ELSE 0) + PLENG;
}'CPBL(); PBF _ MAKARY((COLMAX * 3)/ 2);

}'CPHP(); LPGPOS _ RPGPOS _ -1 IF PAGF >= 0 OR TOPGF >= 0;
IF LHDPOS >= 0 OR LPGPOS >= 0 DO; CHRCNT _ 0;
}'HOUT() IF LHDPOS >= 0 AND LHDPOS <= LPGPOS; POUT() IF LPGPOS >= 0;
}'HOUT() IF LHDPOS >= 0 AND LHDPOS > LPGPOS; HFILL(); LFCNT _ 2;
ENDIF;

}'CPBL(); RETURN;

* FUNCTIONS FOR LINE FORMATTING
FUNCTION ICCNT(ICCH); RETURN IF ICCH = EOLCH
}"ELSE (CHRCNT _ CHRCNT + ICCH$BLKCNT & LJSTPT _ LJSTPT + 1 &
}/RETURN IF CHRCNT > CHRMAX) IF ICCH > BLKBIT(-1)-1
}"ELSE CHRCNT _ CHRCNT - 1 IF ICCH = BSPCH
}"ELSE CHRCNT _ CHRCNT + 1; SRETURN;

* FIND LINE BREAK POINT, HYPHENATE, AND SET UP FOR JUSTIFICATION
FUNCTION BKPT();

}'STRPTL.WPTR _ STRPTL.EPTR _ STLFP.WPTR;
}'HYB.RPTR _ HYB.WPTR _ HYB.EPTR; HYFLG _ HYPF;
}'IHYCNT _ HYCNT _ HYPFCT _ 0; HYPTR _ -1;

}'WHPS _ WHP2; NLJCH _ GCD(STLFP); HYMCT _ CHRCNT;
}'NLJCH _ GCD(STLFP) IF NLJCH = EOLCH;
}'GOTO WHP1 IF NLJCH <= BLKBIT(-1)-1;

}'CHRCNT _ CHRCNT - NLJCH$BLKCNT; LJSTPT _ LJSTPT - 1;
}'GOTO BPT1 IF CHRCNT <= CHRMAX;
}'HYMCT _ CHRCNT; NLJCH _ GCD(STLFP: BPT2);

* GET NEXT CHAR, SKIPPING BACKSPACES, AND ADJUST CHRCNT
WHP1:}"CLJCH _ NLJCH; NLJCH _ GCD(STLFP: BPT2);
IF NLJCH = BSPCH DO; NLJCH _ GCD(STLFP); GOTO WHP1;
ELSEIF CLJCH > BLKBIT(-1)-1 DO;
}'CHRCNT _ CHRCNT - CLJCH$BLKCNT; LJSTPT _ LJSTPT - 1;
}'GOTO WHP7 IF CHRCNT <= CHRMAX;
ELSEIF CLJCH # EOLCH DO; CHRCNT _ CHRCNT - 1;
}'CLJCH _ CLJCH - CSHFT IF CLJCH > '_';
ENDIF; GOTO WHPS;

* SCAN OVER WORD TAIL
WHP2: IF LTRP(CLJCH) DO; HYBWP _ HYB.RPTR; WCD(CLJCH, HYB);
}'HYCNT _ HYCNT + 1; WHPS _ WHP3 IF CLJCH = 'S' ELSE
}*WHPS _ WHP4 IF CLJCH = 'D' ELSE
}*(WHPS _ WHP5 & HYBWP _ HYB.RPTR) IF CLJCH = 'E' ELSE
}*WHPS _ WHP5;
ELSEIF DGTP(CLJCH) DO; HYFLG _ HYFLG + 1; WHPS _ WHP1;
ENDIF; GOTO WHP1;

* STRIP OFF -S, -ES, OR -[QUOTE]S
WHP3:}"WCD(CLJCH, HYB); HYCNT _ HYCNT + 1; WHPS _ WHP5;
}'HYBWP _ (HYB.RPTR IF CLJCH = 'E' OR CLJCH = '&007' ELSE
}/HYB.RPTR + 1); GOTO WHP1;

* STRIP OFF -ED
WHP4:}"WCD(CLJCH, HYB); HYCNT _ HYCNT + 1; WHPS _ WHP5;
}'HYBWP _ HYB.RPTR IF CLJCH = 'E'; GOTO WHP1;

* SCAN BACK OVER LETTERS AND COLLECT THEM IN HYB
WHP5:}"IF LTRP(CLJCH) DO; WCD(CLJCH, HYB); HYCNT _ HYCNT + 1;
ELSEIF CLJCH = '-' OR CLJCH = '/' DO; IHYCNT _ IHYCNT + 1;
}'(HYIND _ CHRCNT & HYPTR _ STLFP.WPTR) IF HYPTR < 0 AND
}/CHRCNT < CHRMAX AND CHRCNT + 3 <= HYMCT;
ELSEIF DGTP(CLJCH) DO; HYFLG _ HYFLG + 1; WHPS _ WHP1;
ELSE DO; WHPS _ WHP6; HYPFCT _ 1;
ENDIF; GOTO WHP1;

* SCAN OVER WORD PREFIX
WHP6:}"IF LTRP(CLJCH) OR DGTP(CLJCH) DO;
}*HYFLG _ HYFLG + 1; WHPS _ WHP1;
ELSE DO; HYPFCT _ HYPFCT + 1;
ENDIF; GOTO WHP1;

* INTERACTIVE HYPHENATION PROCESSOR
IHP1:}"GOTO BPT1 IF IHYFLG < 0; IHYBRP _ HYB.RPTR;
IHP2:}"CRLF(1); SOUT("HYPHENATE: "); IHYCNT _ HYCNT; HYB.RPTR _ IHYBRP;

}'HYB.WPTR _ HYB.EPTR; SOUT(HYB); HYB.WPTR _ HYBWP;

* COLLECT WORD
IHP5:}"CRLF(1); SETS(IHYWB, 0, 0); SETS(IHYRB, 0, 0);
IHP6:}"IHYCH _ CIN(0); (GCD(IHYRB: IHP5) & COUT('^')
}/& GOTO IHP6) IF IHYCH = '&A'
}*ELSE (COUT('_') & GOTO IHP5) IF IHYCH = '&Q' ELSE
}+GOTO IHP7 IF IHYCH = '&M' ELSE
}'(COUT('&M') & IHYFLG _ -1 & GOTO IHP7) IF IHYCH = '&D';
}'WCI(IHYCH, IHYRB: IHP6); GOTO IHP6;

* IGNORE IF EMPTY, OTHERWISE ADD TO GLOSSARY
IHP7:}"COUT('&J'); GOTO BPT1 IF LENGTH(IHYRB) = 0;

}'IHYCNT _ 0; HYB.RPTR _ IHYBRP;

* CHECK WORD AGAINST BUFFER
IHP8:}"IHYCH _ GCI(IHYRB: IHP9);
IF LTRP(IHYCH) DO; WCI(IHYCH, IHYWB);
}'GOTO IHP2 IF IHYCH # GCI(HYB: IHP8);
ELSEIF IHYCH = '-' DO; IHYCH _ HYB.RPTR - IHYBRP;
}'(HYPT[IHYCNT] _ IHYCH & IHYCNT _ IHYCNT + 1) IF
}*IHYCNT <= HYPT.LENGF - 2;
ELSE DO; GOTO IHP2;
ENDIF; GOTO IHP8;

* ADD TO GLOSSARY AND LOOP
IHP9:}"GOTO IHP2 IF HYB.RPTR # HYB.WPTR; HYB.RPTR _ IHYBRP;
}'IHYCNT _ INSGW(IHYWB, IHYCNT);
}'(IHYCNT.FPCHB _ -1 & GLPRF _ GLPRF + 1) IF IHYCNT > 0;
}'GOTO WHP8;

* LOOK UP WORD IN GLOSSARY, AND CHECK FOR MAXIMAL HYPHEN POINT
WHP7:}"STLFP.WPTR _ STLFP.WPTR + 1;
}'GOTO BPT1 IF HYFLG >= 0 OR HYCNT <= 5;
}'FTLERR() IF CLJCH < BLKBIT(-1);
}'HYCNT _ CHRCNT + HYPFCT + CLJCH$BLKCNT;
}'GOTO BPT1 IF HYCNT + 3 > CHRMAX OR
}/((CHRMAX - HYCNT)* 10)/ LJSTPT <= HYBPT;
}'(GOTO HYP3 IF HYPTR >= 0 ELSE GOTO BPT1) IF IHYCNT < 0;

WHP8:}"HYB.WPTR _ HYBWP;
}'HYPTR _ LKP(GLTAB, HYB: IHP1)[0].LKPTR;* TO IHP1 IF NOT FOUND
}'GOTO HYP1 IF HYCNT + HYPTR[HYIND] < CHRMAX
}*FOR HYIND _ (HYPTR.LENGF - 1) - 1 BY -1 TO 1;
}'GOTO BPT1;* NO HYPHEN POINT IN BOUNDS

* PREPARE TO HYPHENATE
HYP1:}"HYCNT _ HYCNT + HYPTR[HYIND];
}'GOTO BPT1 IF HYCNT < CLJCH$BLKCNT + CHRCNT + 2 OR
}/HYCNT + 3 > HYMCT;
}'STRPTL.BPTR _ STRPTL.RPTR _ STLFP.WPTR;

* SCAN TO HYPHENATION POINT
HYP2:}"CLJCH _ GCI(STRPTL);
IF CLJCH > BLKBIT(-1)-1 DO; CHRCNT _ CHRCNT + CLJCH$BLKCNT;
}'LJSTPT _ LJSTPT + 1;
ELSEIF CLJCH = BSPCH DO; CHRCNT _ CHRCNT - 1;
ELSE DO; CHRCNT _ CHRCNT + 1; GOTO HYP4 IF CHRCNT > HYCNT;
ENDIF; GOTO HYP2;

* ENTER HERE FOR HYPHEN IN WORD
HYP3:}"GOTO BPT1 IF HYIND < CLJCH$BLKCNT + CHRCNT + 2;
}'STRPTL.BPTR _ STRPTL.RPTR _ STLFP.WPTR _
}*STCPY.WPTR _ (STLFP.WPTR _ HYPTR) + 2; CHRCNT _ HYIND + 1;
}'OLJCH _ EOLCH; NLJCH _ GCI(STRPTL); CLJCH _ GCI(STRPTL: HYP6);
}'GOTO HYP5;

* COPY REST OF STRING
HYP4:}"STCPY.WPTR _ (STLFP.WPTR _ STRPTL.RPTR) - 1;
}'OLJCH _ '-'; NLJCH _ EOLCH;

HYP5:}"WCI(OLJCH, STCPY); OLJCH _ NLJCH; NLJCH _ CLJCH;
}'CLJCH _ GCI(STRPTL: HYP6); GOTO HYP5;

HYP6:}"WCI(OLJCH, STCPY); WCI(NLJCH, STCPY);
}'STRPTL.WPTR _ STRPTL.EPTR _ STCPY.WPTR;


BPT1:}"LJSTBL _ CHRMAX - CHRCNT; WCI(EOLCH, STLFP: BPT3);
}'STRPTL.BPTR _ STRPTL.RPTR _ STLFP.WPTR; SRETURN;

BPT2:}"STLFP.WPTR _ STRPTL.WPTR; STERF();
BPT3:}"RETURN;

* JUSTIFICATION SUBROUTINE
FUNCTION JUST();
JUST1: CLJCH _ GCI(STLFP: JUST6);
JUST2: GOTO JUST6 IF CLJCH = EOLCH; GOTO JUST5 IF CLJCH = BSPCH;
}'GOTO JUST4 IF CLJCH > BLKBIT(-1)-1; PCHR(CLJCH);
JUST3: (PCHR(BSPCH) & PCHR(ULCH)) IF ULNF < 0; GOTO JUST1;

JUST4: IF LJSTBL > 0 DO;
}'CHRCNT _ (LJSTBL IF LNPTY < 0 ELSE LJSTBL + LJSTPT - 1)/ LJSTPT;
}'LJSTBL _ LJSTBL - CHRCNT; LJSTPT _ LJSTPT - 1;
}'PCHR(BLKBIT(-1) OR CHRCNT + CLJCH$BLKCNT);
ELSE DO; PCHR(CLJCH);
ENDIF; GOTO JUST3;

JUST5: PCHR(BSPCH); PCHR(GCI(STLFP)); CLJCH _ GCI(STLFP);
}'GOTO JUST2 IF CLJCH # BSPCH ELSE GOTO JUST5;

JUST6: RETURN;

*
* TEXT AND COMMAND INPUT PASS
*
DECLARE FIELD LTYPF(0: 0,2), CTYPF(0: 3,5), ADDRF(0: 10, 23);
DECLARE IBFF, IBFP, IBFL, IBFEF, GAM4,
}'TIPPC, TIPCH, TIPAD, DCSGC, DCSCH, DCSST, DCSCT;

DECLARE MACRO BIO(F, C, SL) _ POP(576B, F, C,, SL);
FUNCTION TIPGW(); RETURN $IBFP IF (IBFP _ IBFP + 1) < IBFL;
}'RETURN (LTYPF(7) OR CTYPF(2)) IF IBFEF < 0;
}'BIO(DIF, 256, IBFF: TIPG1); IBFP _ IBFF; RETURN $IBFF;
TIPG1: SAVE(IBFL); IBFEF _ -1; IBFP _ IBFF; RETURN $IBFF;

TIPA:}"GAM4 _ TIPGW(); TIPAD _ GAM4$ADDRF;
}'GOTO $TIP1[GAM4$LTYPF]; DECLARE FIXED ARRAY TIP1[8] _
}+TIPB, TIPC, FTLERR, TIPD, FTLERR, FTLERR, TIPE, TIPH;

* NEW FILL LINE
TIPB:}"FMTP _ -1; LMODE _ GAM4$CTYPF;
}'FRTBL _ (TIPAD - 4B4 IF TIPAD > 17777B ELSE TIPAD); GOTO TIPD;
TIPC:}"FMTP _ TIPAD;* NEW FORMAT LINE

* MAIN TEXT LOOP
TIPD:}"GAM4 _ TIPGW(); TIPCH _ GAM4$CH1; GOTO TIPA IF TIPCH = COMCH;
}'TIPPC(TIPCH); GOTO TIPA IF TIPCH = EOLCH;

}'TIPCH _ GAM4$CH2; GOTO TIPA IF TIPCH = COMCH;
}'TIPPC(TIPCH); GOTO TIPA IF TIPCH = EOLCH;

}'TIPCH _ GAM4$CH3; GOTO TIPA IF TIPCH = COMCH;
}'TIPPC(TIPCH); GOTO TIPD IF TIPCH # EOLCH ELSE GOTO TIPA;

DECLARE FIXED ARRAY DCSA(5) _ HEDST, PPFST, PSCST, PSFST, INXST;
DECLARE FIXED ARRAY DCSC(4) _ NHDCH, NPFCH, NSCCH, NSFCH;

* COMMAND STRING
TIPE:}"TIPCH _ GAM4$CTYPF; DCSST _ $DCSA[TIPCH]; SETS(DCSST, 0,0);
}'CONEC(TIPPC, DCSGC); ICNCT(TIPPC, TIPD); GOTO $TIP2[TIPCH];
}#DECLARE FIXED ARRAY TIP2[5] _ TIPF, TIPF, TIPF, TIPF, INXA;

* (SOME) HEADING STRING
TIPF:}"DCSCT _ DCSC[TIPCH]; $DCSCT _ 0;

* COLLECT STRING
DCS1:}"DCSCH _ DCSGC(); GOTO DCS3 IF DCSCH = EOLCH;
}'$DCSCT _ $DCSCT - 1 IF DCSCH = BSPCH ELSE $DCSCT _ $DCSCT + 1;
}'WCI(DCSCH, DCSST: DCS2); GOTO DCS1;
DCS2:}"STERF(); GOTO DCS1;

DCS3:}"CONEC(TIPPC, PFPGC); DCSGC(); FTLERR();

* COLLECT INDEX ENTRY AND ADD TO TABLE
INXA:}"DCSCH _ DCSGC(); (IXLLEN _ 0 & GOTO INXD) IF DCSCH = ' ';
INXB:}"GOTO INXE IF DCSCH = ',';
}'(IXTBP _ @IXTAB & GOTO INXP) IF DCSCH = EOLCH;
}'WCI(DCSCH, INXST: INXC); GOTO INXA;
INXC:}"STERF(); GOTO INXA;

INXD:}"IXLLEN _ IXLLEN + 1; GOTO INXD IF (DCSCH _ DCSGC()) = ' ';
}'WCI(BLKBIT(-1) OR BLKCNT(IXLLEN), INXST: INXC); GOTO INXB;

* WE HAVE A SECONDARY PHRASE TO COLLECT, SAVE REFERENCE
INXE:}"IXPTR _ LKP(IXTAB, INXST: INXF)[0].LKPTR; GOTO INXG;
INXF:}"IXPTR _ INS(@IXTAB, INXST, FTLERR)[0]; IXPTR.LKPTR _ MAKE(3);
}'IXPTR _ IXPTR.LKPTR; IXPTR[1] _ 1;

INXG:}"IXPPTR _ IXPTR[0]; IXPTR[0] _ IXPPTR _ MAKE(5) IF IXPPTR = 0;
}'IXTBP _ @IXPTR[0]; SETS(INXST, 0,0);

INXH:}"DCSCH _ DCSGC(); GOTO INXH IF DCSCH = ' '; WCI(DCSCH, INXST);

INXJ:}"DCSCH _ DCSGC(); (IXLLEN _ 0 & GOTO INXM) IF DCSCH = ' ';
INXK:}"GOTO INXP IF DCSCH = EOLCH;
}'WCI(DCSCH, INXST: INXL); GOTO INXJ;
INXL:}"STERF(); GOTO INXJ;

INXM:}"IXLLEN _ IXLLEN + 1; GOTO INXM IF (DCSCH _ DCSGC()) = ' ';
}'WCI(BLKBIT(-1) OR BLKCNT(IXLLEN), INXST: INXL); GOTO INXK;

* ADD PAGE REFERENCE TO IXTBP
INXP:}"IXPTR _ LKP($IXTBP, INXST: INXQ)[0]; IXLPTR _ IXPTR.LKPTR;
}'IXLLEN _ IXLPTR.LENGF;
IF IXLPTR[1] + 2 = IXLLEN DO;
}'IXPPTR _ MAKE((IXLLEN * 3)/ 2); BCOPY(IXPPTR, IXLPTR, IXLLEN);
}'FREE(IXLPTR); IXPTR.LKPTR _ IXLPTR _ IXPPTR;
ENDIF; GOTO INXR;

INXQ:}"IXPTR _ INS(IXTBP, INXST, FTLERR)[0];
}'IXPTR.LKPTR _ IXLPTR _ MAKE(3); IXLPTR[1] _ 1;

INXR:}"IXLPTR[1] _ IXPPTR _ IXLPTR[1] + 1;

IF IXI >= IXF.LENGF - 1 DO; IXLPTR _ MAKARY((IXF.LENGF RSH 1)* 6);
}'BCOPY(IXLPTR, IXF, IXI); FREE(IXF); IXF _ IXLPTR; ENDIF;

}'IXF[IXI] _ PBI + LFCNT; IXF[IXI + 1] _ CH1(IXPPTR) OR ADDRF(IXPTR);
}'IXI _ IXI + 2; GOTO DCS3;

TIPH:}"GOTO $TIP3[GAM4$CTYPF]; DECLARE FIXED ARRAY TIP3[3] _
}+TIPJ, TIPK, TIPL;

TIPJ:}"$TIPAD _ 0; GOTO TIPA;* RESET FLAG
TIPK:}"$TIPAD _ -1; GOTO TIPA;* SET FLAG

* MODE ROUTINE WITH PARAMETERS
TIPL:}"$DCPA[GAM4$CH2](GAM4$CH3); GOTO TIPA;
DECLARE FIXED ARRAY DCPA(14) _ DCED, DCPM, DCHM, DCBG, DCEG,
}'DCSP, DCLL, DCHL, DCPL, DCPG, DCOP, DCEJ, DCHB, DCIP;

FUNCTION DCHB(HYBPT); RETURN;

FUNCTION DCPM(PMODE); RETURN;
FUNCTION DCHM(HMODE); RETURN;

FUNCTION DCBG(); STERF() IF PCHG < 0 ELSE
}'(PCHB _ -1 IF GSPC < 0 & PCHG _ -1); RETURN;
FUNCTION DCEG(); PCHG _ 0; RETURN;

FUNCTION DCSP(TSPC); TIPPC(VSPCH); RETURN;

FUNCTION DCLL(LLMAR); RLMAR _ TIPGW(); RETURN;

FUNCTION DCHL(TIPCH); TIPPC(EOCCH); LWIDTH _ TIPCH;
}'GAM4 _ TIPGW(); EPGBL _ GAM4$CH1; OPGBL _ GAM4$CH3;
}'GAM4 _ TIPGW(); TIPCH _ GAM4$CH1;
}'(FREE(PCB) & PCB _ MAKARY(TIPCH + 1)) IF TIPCH # NCOL;
}'NCOL _ TIPCH; CSPC _ GAM4$CH3; CPBL(); RETURN;

FUNCTION DCPL(TIPCH); TIPPC(EOPCH); TPBL _ TIPCH;
}'GAM4 _ TIPGW(); PLENG _ GAM4$CH1; CSLOP _ GAM4$CH3; RETURN;

FUNCTION DCPG(TIPCH); TIPPC(EOPCH); PAGNO _ TIPCH; RETURN;
FUNCTION DCOP(TIPCH); TIPPC(EOPCH);
}'PAGNO _ PAGNO + 1 IF PAGNO MOD 2 = 0; RETURN;
FUNCTION DCEJ(GSPC); (TIPPC(EOPCH) & GSPC _ -1 & RETURN) IF
}+(GSPC _ GSPC - 1) < 0; PCHB _ -1 IF PCHG >= 0; RETURN;
FUNCTION DCIP(TIPCH); PAGNO _ PAGNO + TIPCH; RETURN;

FUNCTION DCED(); (TIPPC(EODCH) & FTLERR()) IF IXTAB[0] = 0;* NO INDEX

}'TIPPC(EOPCH); INXCH _ -1;
FOR IXPTR _ 1 TO IXTAB[0] DO; FMTP _ RINAD; IXLPTR _ IXTAB[IXPTR];

}'IXPPTR _ IXLPTR[1]$CH1; IXPPTR _ IXPPTR - CSHFT IF IXPPTR > '_';
}'DCSP(1) IF IXPPTR # INXCH; INXCH _ IXPPTR; DCEPI(IXLPTR);

}'IXTBP _ IXLPTR.LKPTR[0];
}#IF IXTBP > 0 DO; TIPPC(','); TIPPC(EOLCH); FMTP _ SINAD;
}'(DCEPI(IXTBP[IXPPTR]) & TIPPC(EOLCH)) FOR IXPPTR _ 1 TO IXTBP[0];
}#ELSE DO; TIPPC(EOLCH);
}#ENDIF;* IXTBP
ENDFOR;* IXPTR

}'TIPPC(EODCH); FTLERR();

* PRINT INDEX TABLE ENTRY
FUNCTION DCEPI(DCEPIT); DECLARE DCEPIP, DCEPIB;
}'DCEPS(DCEPIT); DCEPIT _ DCEPIT.LKPTR;
FOR DCEPIP _ 2 TO DCEPIT[1] DO; TIPPC(','); TIPPC(' ');
}'DCEPIB _ DCEPIT[DCEPIP]; DCEPS(DCEPIB$ADDRF) IF DCEPIB$ADDRF # 0;
}'CNS(DCEPIB$CH1, INXST); TIPPC(DCSCH) FOR DCSCH _
}/GCI(INXST: DCEPIX) WHILE 1;
DCEPIX: ENDFOR; RETURN;

* PRINT INDEX TABLE STRING
FUNCTION DCEPS(DCEPSP); DECLARE FIXED STRING DCEPST;
}'SETUP(DCEPST, DCEPSP.LKPNC, DCEPSP + 1);
}'DCEPST.WPTR _ DCEPST.EPTR;
}'TIPPC(DCSCH) FOR DCSCH _ GCI(DCEPST: DCEPS1) WHILE 1;
DCEPS1: RETURN;

*
* PAGE FORMATTING PASS
*

* INITIALIZE PFP
FUNCTION $PFP(), LINK XPFP;
}'FMTP _ FILLF _ JUSTF _ HYPF _ -1; ULNF _ DSPF _ 0;
}'NCOL _ 1; PCB _ MAKARY(2);
}'PAGNO _ 1; SCOPY(PPFST, IPPFS); NPFCH _ 6;
}'NSCCH _ NSFCH _ NHDCH _ 0; SETS(PSCST, 0,0); SETS(PSFST, 0,0);
}'PMODE _ 1; HMODE _ 4; GSPC _ TOPGF _ PAGF _ -1;
}'GLPRF _ -1; HYBPT _ 5; IHYRB _ (IHYWB _ MAKE(6)) + 2;
}'SETUP(IHYWB, 45); IHYRB.EPTR _ IHYWB.EPTR;

}'PAGARY _ 14001B; PAGARY[-1] _ SARRAY - PAGARY}"- 1; SETARRAY(0, PAGARY);
}'PFPGC _ CNCTR(FTLERR); TIPPC _ CNCTR(TIPA);
}'DCSGC _ CNCTR(FTLERR); CONEC(PFPGC, TIPPC);

}'IBFF _ MAKE(256); IBFP _ IBFL _ IBFF + 256; IBFEF _ 0;
}'IXTAB _ MAKE(5); IXF _ MAKARY(10); IXI _ 0; SCTAB _ MAKE(5);

}'GNLC _ PFPGC; PINIT();
}'SETS(STLFP, 0, 0); BCOPY(STCPY, STLFP, 4);

PFP1:}"CFMCH _ GNLC();
}'RETURN FROM XPFP IF CFMCH = EODCH ELSE
}'GOTO PFP1 IF CFMCH = EOLCH OR CFMCH = EOPCH OR CFMCH = EOCCH;

}'NEWPG(); GOTO PFP5 IF CFMCH # VSPCH;

PFP2:}"PLF(TSPC);

PFP3:}"CFMCH _ GNLC();
}'GOTO PFP2 IF CFMCH = VSPCH ELSE
},GOTO PFP3 IF CFMCH = EOLCH ELSE
},GOTO CDMP1 IF CFMCH = EODCH OR CFMCH = EOPCH OR CFMCH = EOCCH;

PFP5:}"LNPTY _ -1; GOTO TFP1 IF FMTP >= 0;

*LINE FORMATING PASS

LFP1:}"FRTBL _ FRTBL + LLMAR; CHRMAX _ RLMAR - FRTBL;
}'(STERF() & CHRMAX _ RLMAR - LLMAR) IF CHRMAX <= 0;
}'CHRCNT _ LJSTPT _ 0; SETS(STLFP, 0, 0);

LFP2:}"WCI(CFMCH, STLFP); ICCNT(CFMCH: LFP3);
}'CFMCH _ GNLC(); GOTO LFP2;

LFP3:}"GOTO LFP4 IF CHRCNT <= CHRMAX; BKPT(:LFP4);
}'GOTO LFP5 IF JUSTF < 0 AND FILLF < 0;

LFP4:}"LJSTBL _ 0;

****DELETE LAST CHAR IF BLANK AND CHECK FOR LINE OFLO
LFP5:}"(FRTBL _ (RLMAR + LLMAR - CHRCNT)/ 2 & LJSTBL _ 0) IF LMODE = 1
ELSE}#(FRTBL _ RLMAR - CHRCNT & LJSTBL _ 0) IF LMODE = 2;
}'PCHCC _ FRTBL + CHRCNT + LJSTBL;
}'PCHR(BLKBIT(-1) OR BLKCNT(FRTBL)); FRTBL _ LMODE _ 0;

}'JUST(); PFILL();

}'(GNLC _ GNCS & CFMCH _ GNLC()) IF
}/STRPTL.WPTR # STRPTL.RPTR AND FILLF < 0 ELSE
}*CFMCH _ GNLC() IF CFMCH # EOLCH;
}'(ULNF _ 0 & GOTO PFP6) IF CFMCH = EOLCH ELSE
}'LFCNT _ LFCNT + 1 IF DSPF < 0; GOTO LFP1;

DECLARE FIELD FTXCF(0: 0, 9);

* TABLE FORMATTING PASS
TFP1:}"FTXT _ MAKE(2 * FMTP[0]$CH3); CHRCNT _ FLCNT _ 0; CHRMAX _ 1D6;
}'FTXT[0] _ FTXTP _ MAKE(100); SETUP(FTXTS, 297, FTXTP + 1);

TFP2:}"IF CFMCH = TABCH DO;

}'FTXTP.FTXCF _ FMTI _ LENGTH(FTXTS); TRUNC(FTXTP, (FMTI + 5)/ 3);
}'FTXT[2 * FLCNT + 1] _ CHRCNT; CHRCNT _ 0;

}'FLCNT _ FLCNT + 1; (STERF() & GOTO TFP5) IF
}/FLCNT = (FTXT.LENGF - 1)/ 2;
}'FTXT[2 * FLCNT] _ FTXTP _ MAKE(100); SETUP(FTXTS, 297, FTXTP + 1);

ELSE DO; ICCNT(CFMCH: FOP1);

TFP3:}"WCI(CFMCH, FTXTS: TFP4);

ENDIF; CFMCH _ GNLC(); GOTO TFP2;
TFP4:}"FTXTP.FTXCF _ LENGTH(FTXTS); FTXTP.LKPTR _ FMTI _ MAKE(100);
}'FTXTP _ FMTI; SETUP(FTXTS, 297, FTXTP + 1); GOTO TFP3;

TFP5:}"CFMCH _ GNLC(); GOTO TFP5 IF CFMCH # EOLCH;

* FORMATTED OUTPUT PROCESSOR
FOP1:}"FTXTP.FTXCF _ FMTI _ LENGTH(FTXTS); TRUNC(FTXTP, (FMTI + 5)/ 3);
}'FTXT[2 * FLCNT + 1] _ CHRCNT; FLCNT _ FLCNT + 1; FOPL _ 1;

}'FMTC3 _ FMTP[0]; FMTC2 _ FMTC3$CH2; FMTC1 _ FMTC3$CH1;
}'FRTBL _ ((RLMAR + LLMAR - FMTC2)/ 2 IF FMTC1 = 2
}/ELSE RLMAR - FMTC2 IF FMTC1 = 1 ELSE LLMAR);
}'(STERF() & FRTBL _ 0) IF FRTBL < 0;

WHILE FLCNT > 0 DO; FMTF _ FMTP[FOPL];
}'PCHCC _ 0; FMTSP _ FRTBL; FLPCT _ FTXT.LENGF - 3;

FOR FMTI _ 0 TO FMTF.LENGF - 2 DO;* ITERATE OVER FORMATS

}'FMTC3 _ FMTF[FMTI]; FMTC1 _ FMTC3$CH1;
}'FMTC2 _ FMTC3$CH2; FMTC3 _ FMTC3$CH3; GOTO $FOPP[FMTC1];
DECLARE FIXED ARRAY FOPP[8] _ FOPF1, FOPF1, FOPF1, FOPV1, FOPV1,
}'FOP3, FOP4, FOP4;

* FIXED FIELD (L R C)
FOPF1: FOPPT _ FTXT[2 * FMTC3]; FLPCT _ FLPCT - 1;
IF FOPPT = 0 DO; FMTSP _ FMTSP + FMTC2;* SKIP MISSING SEGMENT

ELSE DO; CHRCNT _ FTXT[2 * FMTC3 + 1];* GET SEGMENT LENGTH
}'(STERF() & CHRCNT _ FMTC2) IF CHRCNT > FMTC2;

}'FMTCC _ ((FMTC2 - CHRCNT)/ 2 IF FMTC1 = 2 ELSE
}/FMTC2 - CHRCNT IF FMTC1 = 1 ELSE 0);

}'PCHR(BLKBIT(-1) OR BLKCNT(FMTSP + FMTCC));
}'PCHCC _ PCHCC + (FMTSP + FMTCC + CHRCNT);
}'FMTSP _ FMTC2 - CHRCNT - FMTCC;

}'CHRMAX _ CHRCNT + 1; CHRCNT _ 0;
}'FOPPT _ FOPPT$LKPTR; FTXT[2 * FMTC3] _ 0; FLCNT _ FLCNT - 1;
* LOOP OVER TEXT BLOCKS
FOPF2: SETUP(STLD1, FOPPT.FTXCF, FOPPT + 1); STLD1.WPTR _ STLD1.EPTR;

FOPF3: CLJCH _ GCI(STLD1: FOPF4); ICCNT(CLJCH: FTLERR);
}'(CHRCNT _ 0 & GOTIPCOPF4) IF CHRCNT > FMTC2;
}'PCHR(CLJCH); GOTO FOPF3;

FOPF4: FMTC3 _ FOPPT.LKPTR; FREE(FOPPT); FOPPT _ FMTC3;
}'GOTO FOPF2 IF FOPPT > 0;

ENDIF; GOTO FOP6;

* VARIABLE FIELD (F J)
FOPV1: FOPPT _ FTXT[2 * FMTC3]; FLPCT _ FLPCT - 1;
IF FOPPT = 0 DO; FMTSP _ FMTSP + FMTC2;* SKIP MISSING SEGMENT

ELSE DO; PCHR(BLKBIT(-1) OR BLKCNT(FMTSP));
}'PCHCC _ PCHCC + FMTSP;
}'CHRMAX _ FMTC2; FMTC2 _ CHRCNT _ LJSTPT _ 0;
}'SETS(STLFP, 0, 0);

* LOOP OVER TEXT BLOCKS
FOR FOPPT _ FOPPT$LKPTR, FOPPT.LKPTR WHILE FOPPT > 0 DO;
}'SETUP(STLD1, FOPPT.FTXCF, FOPPT + 1); STLD1.WPTR _ STLD1.EPTR;

FOPV2: CLJCH _ GCI(STLD1: FOPV3); FMTC2 _ FMTC2 + 1;
}'WCI(CLJCH, STLFP); ICCNT(CLJCH: FOPV4); GOTO FOPV2;

FOPV3: ENDFOR;
}'(WCI(EOLCH, STLFP) & GOTO FOPV5) IF CHRCNT <= CHRMAX;

FOPV4: BKPT(:FOPV5); GOTO FOPV6 IF FMTC1 # 4 ELSE GOTO FOPV7;
FOPV5: SETS(STRPTL, 0, 0);
FOPV6: LJSTBL _ 0;
FOPV7: FTXT[2 * FMTC3 + 1] _ FTXT[2 * FMTC3 + 1] - CHRCNT;
}'PCHCC _ PCHCC + (CHRCNT + LJSTBL);
}'FMTSP _ CHRMAX - CHRCNT - LJSTBL;
}'JUST(); CHRCNT _ FMTC2 - LENGTH(STRPTL);

FOPV8: FOPPT _ FTXT[2 * FMTC3];
}'(FLCNT _ FLCNT - 1 & FTXT[2 * FMTC3] _ 0 & GOTO FOP6)
}/IF FOPPT$LKPTR = 0;
}'FMTC2 _ FOPPT.FTXCF;
IF FMTC2 <= CHRCNT DO; FTXT[2 * FMTC3]$LKPTR _ FOPPT.LKPTR;
}'FREE(FOPPT$LKPTR); CHRCNT _ CHRCNT - FMTC2; GOTO FOPV8;
ENDIF;

}'SETUP(STLD1, FMTC2, FOPPT + 1); BCOPY(STLD2, STLD1, 4);
}'SETS(STLD1, CHRCNT, FMTC2); SCOPY(STLD2, STLD1);
}'FOPPT.FTXCF _ FMTC2 _ FMTC2 - CHRCNT;
}'TRUNC(FOPPT$LKPTR, (FMTC2 + 5)/ 3);
ENDIF; GOTO FOP6;

* MISCELLANEOUS FORMATTING
FOP3:}"FMTSP _ FMTSP + FMTC2; GOTO FOP6;* BLANKS
FOP4:}"PCHR(BLKBIT(-1) OR FMTSP); PCHCC _ PCHCC + FMTSP; FMTSP _ 0;
}'PCHR(FMTC2) IF FMTC1 = 7; PCHR(FMTC3);

FOP6: ENDFOR;* FMTI

}'PFILL(); LFCNT _ LFCNT + 1 IF DSPF < 0 AND FLCNT > 0;
}'FOPL _ FOPL + 1 IF FOPL < FMTP.LENGF - 2;

ENDFOR;* FLCNT
}'FREE(FTXT);

PFP6:}"CFMCH _ GNLC();
}'GOTO PFP6 IF CFMCH = EOLCH ELSE
}*GOTO CDMP1 IF CFMCH = EODCH OR CFMCH = EOPCH OR
}/CFMCH = EOCCH OR PBI - PBB > COLMAX ELSE GOTO PFP8;

PFP7:}"PBI _ PBI + 1; LFCNT _ CDLF;* CLEAN UP COLUMN MESS
PFP8:}"GOTO PFP2 IF CFMCH = VSPCH ELSE LFCNT _ LFCNT + 1 IF DSPF < 0;
}/GOTO PFP5;


* FUNCTION FOR DETERMINING COLUMN BREAK POINT
DECLARE CDLF, CDCL, CDCLM, PCI, PCJ, PCL, PCS, PCF, PCP, PCT, PCE;

FUNCTION CBPT(CBPI); DECLARE CBPK;
}'(CBPI _ CBPK & GOTO CBPT1) IF PBF[CBPK]$FPCHB # 0
}/FOR CBPK _ CBPI BY -1 TO CBPI - CSLOP;
}'(CBPI _ CBPI - 1 IF PBF[CBPI + 1]$FPCHB # 0) IF CBPI < PBI
}/ELSE FTLERR();* BETTER HAVE OFLO (RETURN IF BAD ASSUMPTION)

}'((CBPI _ CBPK & GOTO CBPT1) IF PBF[CBPK]$FPCHB # 0
}+FOR CBPK _ CBPI BY -1 TO PCI) IF PBF[CBPI]$FPCHG # 0;

CBPT1: SRETURN CBPI IF PBF[CBPI]$FPCHP # 0
}/FOR CBPI _ CBPI TO PBI; RETURN;

CDMP1: CDLF _ LFCNT; LFCNT _ PCS _ 0; PBI _ PBI - 1;
}'(PBM _ PBB & GOTO CDMP6) IF PBB > PBI;* COLUMNS ALREADY PACKED(?)

* SKIP OVER INITIAL BLANK LINES AT HEAD OF COLUMN
}'GOTO CDMP2 IF PBF[PBK]$FPCHP # 0 ELSE LFCNT _ LFCNT + 1
}/FOR PBK _ PBB TO PBI; FTLERR();* ?

CDMP2: PCB[0] _ PCI _ PBK; CDCL _ LINMAX - LFCNT - LINCNT;
}'(PBM _ PBB & GOTO CDMP6) IF CDCL <= 0;

* IF END OF COLUMN CONDITION
IF CFMCH = EOCCH OR CFMCH = EODCH OR CFMCH = EOPCH DO; CDCLM _ CDCL;

* ITERATIVELY FIND BEST COLUMN DIVISION
}'PCS _ PCS + 1 IF PBF[PCJ]$FPCHP # 0 FOR PCJ _ PBK TO PBI;
}'PCS _ CDCLM IF PCS > CDCLM;

}#FOR CDCL _ (PCS + NCOL - 1)/ NCOL TO CDCLM DO;* IMPROVE THIS

}'PCB[PCJ] _ PCI _ CBPT(PCI + CDCL: FTLERR)
}+FOR PCJ _ 1 TO NCOL - 1;
}'(PCB[NCOL] _ PCI _ PBI + 1 & GOTO CDMP4) IF PBI - PCI <= CDCL;

CDMP3: PCI _ PBK;
}#ENDFOR;
}'CDCL _ CDCLM;

* CHECK FOR TRUE OVERFLOW AND DIVIDE INTO COLUMNS
ELSE DO;

}'PCB[PCJ] _ PCI _ CBPT(PCI + CDCL: PFP7)
}*FOR PCJ _ 1 TO NCOL - 1;
}'GOTO PFP7 IF PBI - PCI <= CDCL;

ENDIF;
}'PCB[NCOL] _ PCI _ CBPT(PCI + CDCL: FTLERR);

CDMP4: PBM _ PCI;* PACK THE COLUMNS INTO LINES
FOR PCI _ 0 TO CDCL DO; PCL _ (LWIDTH - CSPC *(NCOL - 1))/ NCOL;

}'PCE _ -1; PCS _ 0;
}'(PCT _ PCB[PCJ] + PCI & (PCT _ PBF[PCT] &
}+PCE _ PCE + 1 IF PCT$FPCHE # 0 & PCT _ PCT$FPCHP &
}/PCS _ PCS + PCT.CH1 IF PCT > 0) IF PCT < PCB[PCJ + 1])
}*FOR PCJ _ NCOL - 1 BY -1 TO 0;* COMPUTE BLOCK LENGTH

}#IF PCS > 0 DO;
}%IF NCOL = 1 DO; PCF _ PBF[PCB[0] + PCI]$ADDRF;
}'$PCF _ PCS;* SIMULATE PACKING

}%ELSE DO; PCF _ MAKE(PCS + 1, PAGARY); PCP _ PCF + 1;
}'PCS _ (LWIDTH - NCOL *(PCL + CSPC) + CSPC)/ 2;

}'FOR PCJ _ 0 TO NCOL - 1 DO; PCT _ PCB[PCJ] + PCI;
}*IF PCT < PCB[PCJ + 1] AND (PCT _ PBF[PCT]$FPCHP) > 0 DO;

}/PCT[1]$CH1 _ PCT[1]$CH1 + PCS; PCS _ PCT.CH1 + PCT;

}/PCS.CH1 _ NULCH IF PCS.CH1 = EOLCH ELSE
}2PCS.CH2 _ NULCH IF PCS.CH2 = EOLCH ELSE PCS.CH3 _ NULCH;

}/PCS _ PCT.CH1; BCOPY(PCP, PCT + 1, PCS); $PCF _ $PCF + PCS;
}/PCP _ PCP + PCS; PCS _ PCL - PCT.CH3; FREE(PCT, PAGARY);

}*ELSE DO; PCS _ PCS + PCL;
}*ENDIF;
}'PCS _ PCS + CSPC;
}'ENDFOR;* PCJ

}'PCT _ PCF + $PCF; PCT.CH3 _ EOLCH;
}#ENDIF;* NCOL

}'PBF[PBB] _ (0 IF PCE < 0 ELSE FPCHE(-1)) OR
}/FPCHL(LFCNT) OR FPCHP(PCF);
}'LINCNT _ LINCNT + (LFCNT + 1); LFCNT _ 0; PBB _ PBB + 1;

}#ELSE DO; LFCNT _ LFCNT + 1;
}#ENDIF;* PCS
ENDFOR;* PCI

* PROCESS INDEX ENTRIES
}'PCJ _ (INS(@SCTAB, PSCST, DELSC)[0] IF NSCCH > 0 ELSE 0);
}'IXI _ IXI - 2; (GOTO CDMP5 IF IXF[IXB] >= PBM &
}+PCT _ IXF[IXB + 1] & PCT$ADDRF.LKPTR[PCT$CH1] _
}/CH1(PAGNO) OR ADDRF(PCJ)) FOR IXB _ 0 BY 2 TO IXI;

* EXIT UNLESS PAGE DUMP IS REQUIRED
CDMP5: (PBI _ PBB & CPBL() &
}+(GOTO PFP8 IF CFMCH # EOCCH ELSE GOTO PFP6))
}/IF CFMCH # EOPCH AND CFMCH # EODCH AND PBM > PBI;

CDMP6: PBK _ PBB - 1; LDMP(PBF[PBJ]) FOR PBJ _ 0 TO PBK;

}'IF TOPGF >=0 AND PAGF < 0 DO; PCL _ PBI; PBI _ 0;
}'LFCNT _ PLENG - LINCNT; CPHP(); CHRCNT _ 0;
}'POUT(); HFILL(); LDMP(PBF[0]); PBI _ PCL; ENDIF;

}'RETURN FROM XPFP IF CFMCH = EODCH AND PBM > PBI;
}'COUT(EJCH, DOF); PAGNO _ PAGNO + 1;

* EXIT IF FORCED PAGE EJECT AND 'NEXT' PAGE IS EMPTY
}'(FREE(PBF) & TRUNC(IXF, 10) & IXI _ 0 &
}*(GOTO PFP1 IF CFMCH = EOCCH OR CFMCH = EOPCH
}/ELSE FTLERR())) IF PBM > PBI;

}'PCP _ PBF; PCF _ PBM; PCL _ PBI; PCT _ IXF; PCS _ IXI; NEWPG();

}'(PBF[PBI] _ 0 & PBI _ PBI + 1) FOR LFCNT _ LFCNT - 1 BY -1 TO 0;

}'GOTO CDMP7 IF PCP[PCJ]$FPCHP # 0 FOR PCJ _ PCF TO PCL;
}'LFCNT _ 0; PCF _ PCJ; GOTO CDMP8;

CDMP7: PCF _ PCJ;
}'(PBF[PBI] _ PCP[PCJ] & PBI _ PBI + 1) FOR PCJ _ PCJ TO PCL;
}'LFCNT _ CDLF;

CDMP8: PCS _ IXI; IXI _ 0;* UPDATE REMAINING INDEX ENTRIES

}'((PCL _ IXF[PCJ] - PCF & PCL _ 0 IF PCL < 0 & IXF[IXI] _ PCL &
}+IXF[IXI + 1] _ IXF[PCJ + 1] & IXI _ IXI + 2)
}/FOR PCJ _ IXB BY 2 TO PCS) IF PCS >= 0;

}'TRUNC(IXF, MAX(IXI, 10));* THROW OUT EXTRA ENTRIES
}'FREE(PCP);* RELEASE OLD PAGE BUFFER
}'GOTO CDMP1 IF CFMCH = EOCCH OR CFMCH = EOPCH OR CFMCH = EODCH
}/ELSE GOTO PFP8;

FUNCTION DELSC(); RETURN;

* DUMP GLOSSARY
FUNCTION $DMPGL(), LINK XPFP;
}'CHRCNT _ 0; STLD2 _ ".GL "; SOUT(STLD2, DOF);

FOR PBI _ GLTAB[0] BY -1 TO 1 DO; PBJ _ GLTAB[PBI];
IF PBJ < 0 DO;* PROCESS NEW ENTRIES

}'(CRLF(1, DOF) & SOUT(STLD2, DOF) & CHRCNT _ 0)
}/IF CHRCNT > 50 ELSE COUT(' ', DOF);* FORCE NEW LINE

}'SETUP(STLD1, PBJ.LKPNC, PBJ + 1); STLD1.WPTR _ STLD1.EPTR;
}'PBJ _ PBJ.LKPTR; HYCNT _ 0; PBK _ 1; PBM _ PBJ[PBK];

DMPG1: COUT(GCI(STLD1: DMPG2), DOF); HYCNT _ HYCNT + 1;
}'(COUT('-', DOF) & PBK _ PBK + 1 &
}*PBM _ (PBJ[PBK] IF PBK < PBJ.LENGF - 1 ELSE 512))
}/IF HYCNT >= PBM; GOTO DMPG1;

DMPG2: CHRCNT _ CHRCNT + (HYCNT + PBJ.LENGF);
}'(COUT(HYCNT$CH1, DOF) & CHRCNT _ CHRCNT + 1)
}/FOR HYCNT _ PBJ[0], HYCNT LSH 8 WHILE HYCNT > 0;
ENDIF; ENDFOR; RETURN;

}'END;

*********************}"NIP}"************************

**QSPL
}'IDENT IPROC;


GO:}$GOTO INIT; GOTO DMP;

DECLARE FIELD RPTR(1), WPTR(2);
DECLARE FIELD CH1(0:0,7), CH2(0:8,15), CH3(0:16,23);

* GLOBAL ENVIRONMENT FOR RUNOFF
DECLARE $FILLF, $FMTP, $ULNF, $JUSTF, $DSPF, $HYPF, $PAGF, $TOPGF,
}'$IHYFLG, $GLPRF, $ERFLG;
DECLARE $MNTAB, $FMTAB, $GLTAB, FIXED STRING $HYB(45),
}'FIXED ARRAY $HYPT(30);
DECLARE $DIF, $DOF, DEV, $RINAD, $SINAD;
DECLARE $CVCGC, $SYPGC, $GCHPC, $CVCPC, $SYPPC, $TOPGC;

* PARAMETERS FOR CO-ROUTINE CONNECTOR
DECLARE PARAMETER LDA _ 76B5, XMA _ 62B5, STA _ 35B5,
}'BRU _ 1B5, BRR _ 51B5, IABIT _ 4B4;

* INITIALIZE CO-ROUTINE
FUNCTION $CNCTR(CN2); DECLARE CN1; CN1 _ MAKE(7);
}'CN1[0] _ (STA+5) + CN1; CN1[1] _ LDA; CN1[2] _ (XMA+5) + CN1;
}'CN1[3] _ (BRU+IABIT+6) + CN1; CN1[4] _ (BRR+5) + CN1;
}'CN1[5] _ CN2 - 1; RETURN CN1;

* CONNECT TWO CO-ROUTINES
FUNCTION $CONEC(CN1, CN2); CN1[6] _ CN2 + 4; CN2[6] _ CN1 + 4;
}'RETURN;

FUNCTION $MATE(CN1); RETURN CN1[6] - 4;
FUNCTION $ICNCT(CN1, CN2); CN1[5] _ CN2 - 1; RETURN;

FUNCTION $TRUNCZ(TRUNCL, TRUNCS, TRUNCA), LINK TRUNCX; GOTO TRNC1;
FUNCTION $TRUNC(TRUNCL, TRUNCS), LINK TRUNCX; TRUNCA _ SARRAY;
DECLARE TRUNCT, FIELD LENGF(-1: 10, 23);

TRNC1: TRUNCS _ 2 IF TRUNCS <= 1;
IF (TRUNCT _ TRUNCL.LENGF - (TRUNCS _ TRUNCS + 1)) > 2 DO;

}'TRUNCL.LENGF _ TRUNCS; TRUNCL[TRUNCS - 1] _ TRUNCT;
}'FREE(TRUNCL + TRUNCS, TRUNCA);

ENDIF;
}'RETURN;

FUNCTION $MIN(MNMXX, MNMXY); RETURN (MNMXX IF MNMXY > MNMXX ELSE MNMXY);
FUNCTION $MAX(MNMXX, MNMXY); RETURN (MNMXX IF MNMXX > MNMXY ELSE MNMXY);

DECLARE MACRO INC(X, Y) _ X _ X + (Y);

FUNCTION $LKP(LKPTB, LKPST), LINK XLKP;* BINARY LOOKUP FUNCTION
DECLARE LKPL, LKPT, LKPU, LKPKC, LKPTC, LKPCL, LKPSR;
DECLARE FIELD LKPNC(0:0,9), LKPTR(0:10,23), FIXED STRING LKPCS;

}'RETURN (LKPT _ LKPTB + 1) IF LKPTB[0] < 1;

}'LKPL _ LKPTB + 1; LKPU _ LKPTB + LKPTB[0];
}'LKPSR _ LKPST.RPTR;

LKP1:}"LKPTC _ (LKPT _ (LKPU + LKPL) RSH 1)[0];
}'LKPCL _ LKPTC.LKPNC;

}'SETUP(LKPCS, LKPCL, LKPTC+1); SETW(LKPCS, LKPCL);
}'LKPST.RPTR _ LKPSR;

LKP2:}"LKPTC _ GCI(LKPCS: LKP4); LKPKC _ GCI(LKPST: LKP3);

}'GOTO LKP3 IF LKPKC < LKPTC ELSE
}/GOTO LKP5 IF LKPKC > LKPTC ELSE GOTO LKP2;

LKP3:}"LKPU _ LKPT - 1; GOTO LKP6;* KEY < ENTRY

LKP4:}"GOTO LKP5 IF LKPST.RPTR # LKPST.WPTR;
}'XLKP _ XLKP + 1; GOTO LKP7;* KEY = ENTRY

LKP5:}"LKPL _ (LKPT _ LKPT + 1);* KEY > ENTRY

LKP6:}"GOTO LKP1 IF LKPU >= LKPL;
LKP7:}"LKPST.RPTR _ LKPSR; RETURN LKPT;

FUNCTION $INS(INSTB, LKPST, INSFN); LKP($INSTB, LKPST: INS1);
}'INSFN(LKPT); GOTO INS3;

INS1:}"IF LKPTB.LENGF - 2 = LKPTB[0] DO;
}'LKPCL _ LKPTB[0]; LKPTC _ MAKE((LKPCL * 5)/ 4 + 1);
}'BCOPY(LKPTC, LKPTB, LKPCL + 1);
}'LKPT _ LKPT + (LKPTC - LKPTB);
}'FREE(LKPTB); $INSTB _ LKPTB _ LKPTC;
ENDIF;

}'GOTO INS2 IF LKPT > (LKPU _ LKPTB + LKPTB[0]);

}'LKPTC[1] _ LKPTC[0] FOR LKPTC _ LKPU BY -1 TO LKPT;

INS2:}"LKPTB[0] _ LKPTB[0] + 1;

INS3:}"LKPCL _ LENGTH(LKPST); LKPTC _ MAKE((LKPCL + 5)/ 3);
}'SETUP(LKPCS, LKPCL, LKPTC + 1);
}'SCOPY(LKPCS, LKPST); LKPTC[0] _ LKPNC(LKPCL);
}'LKPT[0] _ LKPTC; RETURN LKPT;

* INSERT WORD IN GLOSSARY
FUNCTION $INSGW(INSGWB, INSGWI); DECLARE INSGWC, INSGWT, INSGWW;

* PREPARE WORD FOR STORAGE, STRIP -E, -S, -ES, -ED
}'INSGWT _ LENGTH(INSGWB); RETURN 0 IF INSGWT < 5;
}'INSGWW _ 0; INSGWC _ GCD(INSGWB);
}'(INSGWW _ '' IF (INSGWC _ GCD(INSGWB)) = '&007' ELSE
}*(INC(INSGWB.WPTR, 1) & INSGWW _ 'S}"') IF INSGWC # 'E'
}/ELSE INSGWW _ 'ES ') IF INSGWC = 'S' ELSE
}*(INC(INSGWB.WPTR, 2) IF GCD(INSGWB) # 'E' ELSE INSGWW _ 'ED ')
}/IF INSGWC = 'D' ELSE
}*INSGWW _ 'E}"' IF INSGWC = 'E' ELSE INC(INSGWB.WPTR, 1);

}'INSGWT _ MAKE(INSGWI + 1);* INSERT THE ENTRY IN THE GLOSSARY
}'BCOPY(INSGWT + 1, HYPT, INSGWI) IF INSGWI > 0;
}'INSGWT[1] _ 512 IF INSGWI = 0; INSGWT[0] _ INSGWW;
}'INSGWI _ INS(@GLTAB, INSGWB, DELGW); INSGWI[0].LKPTR _ INSGWT;
}'RETURN INSGWI;



FUNCTION DELGW(DELGWP); RETURN FREE(DELGWP[0].LKPTR);

* INITIALIZE FORMATS FOR INDEXING
FUNCTION IINX(); DECLARE PARAMETER IXWDTH _ 27;
}#MSG _ "RINDEX"; CN1 _ INS(@FMTAB, MSG, FTLERR)[0];
}#CN1.LKPTR _ RINAD _ MAKE(3); RINAD[0] _ CH1(2) OR CH2(IXWDTH) OR CH3(1);
}#RINAD[1] _ CN1 _ MAKE(2); CN1[0] _ CH1(3) OR CH2(IXWDTH); CN1[1] _ CH1(5);
}#RINAD[2] _ CN1 _ MAKE(2); CN1[0] _ CH1(5) OR CH2(4);
}'CN1[1] _ CH1(3) OR CH2(IXWDTH-4);

}#MSG _ "SINDEX"; CN1 _ INS(@FMTAB, MSG, FTLERR)[0];
}#CN1.LKPTR _ SINAD _ MAKE(3); SINAD[0] _ CH1(2) OR CH2(IXWDTH) OR CH3(1);
}#SINAD[1] _ CN1 _ MAKE(2); CN1[0] _ CH1(5) OR CH2(2);
}'CN1[1] _ CH1(3) OR CH2(IXWDTH-2);
}#SINAD[2] _ CN1 _ MAKE(2); CN1[0] _ CH1(5) OR CH2(4);
}'CN1[1] _ CH1(3) OR CH2(IXWDTH-4); RETURN;

* START OF PASS 1 INITIALIZE FIRST

DECLARE ICHR, RLA, RLB, RLC, FIXED STRING MSG, FNM(45);
DECLARE *DMPGL, *PFP, *IGCH, *ISYP, *ICVP, *ICMP, *ITOP, *TOP,
}'*DGCH, *DSYP, *DCVP, *DCMP, *DTOP;
DECLARE FIELD MB0(0: 0, 5), MB12(0: 6, 17);

DECLARE MACRO RYN(FE) _ ICHR _ CIN(0) &
}'((COUT('E') & COUT('S')) IF ICHR = 'Y' ELSE
}/COUT('O') IF ICHR = 'N' ELSE GOTO FE) &
}+GOTO FE IF CIN(0) # '.';

INIT:}"BRS(43:: RLA, RLC); RLB _ MB0(RLA$MB0) OR MB12(RLC$MB12);
}'RLC$MB12 _ 0; BRS(44, RLA, RLC);
}'SARRAY _ 24001B; INITIALIZE();* SET-UP ROUTINE
}'MSG _ " 3/12/71"; SOUT(MSG);

* ASSUME OUTPUT DEVICE = TELETYPE (GOOD FOR PRINTERS)
}'DEV _ 0;

* OPEN TEXT FILE AND INITIALIZE FIRST PASS
RUN1:}"MSG _ "&"RUNOFF-TXT-FILE&""; DOF _ OUTFILE(MSG, 13B6: FTLERR);
}'ICMP(); ITOP(DEV); IINX();

OPIF: MSG _ "INPUT FROM: "; CRLF(1); SOUT(MSG);
}'SETS(FNM, 0, 0); ICHR _ INNAME(FNM: OPIF);
}'GOTO OPIF IF ICHR # '.' AND ICHR # ',';
}'DIF _ INFILE(FNM: OPIF); CRLF(1);
}'IGCH(); ISYP(); ICVP();
}'CONEC(GCHPC, CVCGC); CONEC(CVCPC, SYPGC); CONEC(SYPPC, TOPGC);
}'TOP(); DGCH(); DSYP(); DCVP(); CLOSE(DIF);
}'GOTO RUN2 IF ICHR = '.';

RDMI:}"MSG _ "MORE? "; CRLF(1); SOUT(MSG); RYN(RDMI);
}'GOTO OPIF IF ICHR = 'Y';

* START PASS II
RUN2:}"DCMP(); DTOP(); CLOSE(DOF);
}'BRS(43::, RLC); BRS(44, RLB, RLC); GOTO OPOF;

OPOFE: CLOSE(DIF); CLOSE(DOF);
OPOF:}"MSG _ "OUTPUT TO: "; CRLF(1); SOUT(MSG);
}'SETS(FNM, 0, 0); ICHR _ OUTNAME(FNM:OPOF);
}'DOF _ OUTFILE(FNM, 13B6: OPOF); IHYFLG _ -1;
}'MSG _ "RUNOFF-TXT-FILE"; DIF _ INFILE(MSG: FTLERR);
}'GOTO FMT IF ICHR = '.'; GOTO OPOFE IF ICHR # ',';

RDIH:}"MSG _ "INTERACTIVE HYPHENATION? "; CRLF(1); SOUT(MSG);
}'RYN(RDIH); IHYFLG _ (0 IF ICHR = 'Y' ELSE -1);

* FORCE RUNOFF PRINTING MODE
FMT:}#CRLF(1); WOUT('**R', DOF); WOUT('UNO', DOF);
}'WOUT('FF ', DOF); WOUT('&155&152&154', DOF);

}'PFP(); CLOSE(DIF); CLOSE(DOF); EXIT() IF GLPRF < 0;

* DUMP THE GLOSSARY
DMP:}#MSG _ "/$GLOSSARY$/"; DOF _ OUTFILE(MSG, 13B6: FTLERR);
}'DMPGL(); COUT('&137', DOF); COUT('&137', DOF);
}&COUT('&137', DOF); CLOSE(DOF); EXIT();

}'END;

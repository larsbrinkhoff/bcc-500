}'COMMON GLOBALS;

}'UNKNOWN MONITOR SP'RETURN _ 116;
}'INTEGER MONITOR READ'WRITE'CM _ 255;
}'UNKNOWN UTILITY PRINT'STRING _ 45;

* STACK DEFINITIONS
}'DECLARE PARAMETER SIZE _ 400B;
}'DECLARE ARRAY STACK[SIZE];
}'DECLARE PARAMETER
}*INITIAL'SP _ @STACK[0], INITIAL'SL _ @STACK[SIZE-1];
}'DECLARE INTEGER
}*STACK'POINTER = G'[2], STACK'LIMIT = G'[3];

* VARIABLES FOR FUNCTION CALL FAILURES
}'DECLARE INTEGER CODE, NUMBER;

* STRING THINGS
}'DECLARE STRING FIELD STRING'DESC(0);
}'DECLARE FIELD CHAR'SIZE(0:2,3);
}'DECLARE FIELD BP(0), RP(1), WP(2), EP(3);

}'END;

}'PROGRAM ENTRIES;

}'INCLUDE GLOBALS;



}'FUNCTION SP'TRAP'ENTRY(), SP'ENTRY _ 0;
}'.HLT 0;

}'FUNCTION INTERRUPT'ENTRY(), SP'ENTRY _ 1;
}'.HLT 0;

}'FUNCTION INITIAL'ENTRY(), SP'ENTRY _ 2;
}'STACK'POINTER _ INITIAL'SP;
}'STACK'LIMIT _ INITIAL'SL;
}'RUN();
}'.HLT 0;

}'FUNCTION CONTINUE'ENTRY(), SP'ENTRY _ 3;
}'.HLT 0;



}'END;

}'PROGRAM RUN;

}'INCLUDE GLOBALS;

}'DECLARE PARAMETER HAS'DRUM'SPACE _ 170B + 664B3;
}'DECLARE PARAMETER READ _ 0;
}'DECLARE INTEGER DRUM'SPACE;
}'DECLARE STRING OUTPUT(60);

}'UNKNOWN FUNCTION RUN();
}'DRUM'SPACE _ READ'WRITE'CM(HAS'DRUM'SPACE, DRUM'SPACE, READ//
}*EXIT: CODE, NUMBER);
}'CNS(DRUM'SPACE, OUTPUT, 0, 10//EXIT);
}'APPEND(OUTPUT, " PAGES OF DRUM SPACE LEFT&/"//EXIT);
}'PRINT'STRING(-1, OUTPUT, 0//EXIT: CODE, NUMBER);
EXIT:}"SP'RETURN(//HALT: CODE, NUMBER);
HALT:}".HLT 0;

}'END;

}'PROGRAM CNS;

*}&THIS FUNCTION APPENDS A SINGLE PRECISION INTEGER TO A STRING
* AFTER CONVERTING THE INTEGER FROM INTERNAL REPRESENTATION TO CHAR-
* ATER REPRESENTATION.}"THIS FUNCTION FAILS IF THE BASE THE NUMBER WILL
* BE CONVERTED TO IS OUTSIDE THE ALLOWABLE RANGE OF 2 TO 36, INCLUSIVE,
* OR IF THE STRING PASSED TO IT CAN'T HOLD ALL THE CHARACTERS OF THE 
* BER.

}'INCLUDE GLOBALS;

}'DECLARE INTEGER
}*BASE,}./* THE BASE THE NUMBER WILL BE CONVERTED */
}=/*}#TO}B*/
}*CHAR,}./* THE CHARACTER TO WRITE INTO THE STRING*/
}*COUNT,}-/* JUST A COUNTER FOR FOR LOOPS}**/
}*LENGTH'TEMP,}'/* LENGTH OF THE STRING TEMP}-*/
}*NUMBER,},/* THE NUMBER TO CONVERT}1*/
}*NUMBER'OF'CHARS,}#/* BITS (18-23) OF SIGN'NUM'CHARS}(*/
}*SIGN'FLAG,})/* SET IF NEGATIVE NUMBERS ARE TO BE}%*/
}=/*}#CONVERTED SIGNED}4*/
}*SIGN'NUM'CHARS;}$/* DETERMINES IF THE NUMBER WILL BE}&*/
}=/*}#SIGNED AND HOW MANY CHARACTERS TO}#*/
}=/*}#GENERATE.}"IF IT IS 0, IT WILL BE}#*/
}=/*}#CONVERTED SIGNED AND WITHOUT PAD-}#*/
}=/*}#DING OR TRUNCATION}2*/

}'DECLARE STRING
}*TEMP (24),})/* A TEMPORARY STRING EACH DIGIT IS}&*/
}*WORKING'NAME;}&/* TO KEEP SPL HAPPY}5*/
}=/*}#WRITTEN INTO}8*/



}'UNKNOWN FUNCTION CNS(NUMBER, STRING @STRING'CREATED,
}*SIGN'NUM'CHARS, BASE), FRETURN;

}'FRETURN IF BASE < 2 OR BASE > 36;
}'WORKING'NAME _ STRING'CREATED.STRING'DESC;
}'SIGN'FLAG _ (-1 IF SIGN'NUM'CHARS >= 0 AND NUMBER < 0 ELSE 0);
}'NUMBER _ -NUMBER IF SIGN'FLAG;

* BE CLEVER AND WRITE THE STRING BACKWARDS
}'TEMP$RP _ TEMP$WP _ TEMP$EP;

}'IF NUMBER # 0 DO;
}*WHILE NUMBER # 0 DO;
}-.LDA NUMBER, LSHD -23, DIV BASE, STA NUMBER, STB CHAR;
}-WCD(CHAR + ('0' IF CHAR < 10 ELSE 'A' - 10), TEMP);
}*ENDFOR;
}'ELSE DO;
}*WCD('0', TEMP);
}'ENDIF;

}'WCD('-', TEMP) IF SIGN'FLAG;

* ALL WE NEED NOW IS HOW MANY CHARACTERS TO GENERATE
}'NUMBER'OF'CHARS _ SIGN'NUM'CHARS A' 77B;
}'LENGTH'TEMP _ LENGTH(TEMP);

* TRUNCATE CHARACTERS IF NECESSARY
}'IF NUMBER'OF'CHARS # 0 AND NUMBER'OF'CHARS < LENGTH'TEMP DO;
}*TEMP$RP _ INCDES(TEMP$EP, -NUMBER'OF'CHARS);

* OR PAD
}'ELSEIF NUMBER'OF'CHARS # 0 AND NUMBER'OF'CHARS > LENGTH'TEMP DO;
}*FOR COUNT _ LENGTH'TEMP + 1 TO NUMBER'OF'CHARS DO;
}-WCI(' ', WORKING'NAME//FRETURN);
}*ENDFOR;
}'ENDIF;

}'FOR COUNT _ 1 TO LENGTH(TEMP) DO;
}*CHAR _ GCI(TEMP);
}*WCI(CHAR, WORKING'NAME//FRETURN);
}'ENDFOR;

FINISH:STRING'CREATED.WP _ WORKING'NAME$WP;
}'RETURN;


}'END;

}'PROGRAM APPEND;

*}&THIS PROGRAM BLOCK TAKES AS ITS ARGUMENTS TWO STRINGS WHICH IT
* ATTEMPTS TO CONCATENATE TOGETHER.}"THERE ARE TWO ENTRY POINTS TO THE
* PROGRAM, SCOPY, AND APPEND.}"SCOPY IS JUST A SPECIAL CASE OF APPEND
* IN WHICH ONE STRING WILL BE COPIED TO THE BEGINNING OF THE OTHER
* STRING.
*}&I TRIED TO BE CONSISTENT AND DECLARE ALL VARIABLES EXPLICITLY,
* IN "DECLARE" STATEMENTS, BUT THERE SEEM TO BE PROBLEMS WITH DECLARING
* A STRING WHICH WILL BE AN ARGUMENT TO A FUNCTION AND LATER IN THE
* FUNCTION DEFINITION, INFORMING SPL THAT THAT STRING WILL BE CALLED
* BY WHAT I CONSIDER TO BE CALL BY NAME.

}'INCLUDE GLOBALS;

}'DECLARE STRING
}*ADDENDUM,}*/* THE STRING FROM WHICH CHARACTERS ARE}"*/
}=/*}#COPIED INTO THE FIRST ARGUMENT}&*/
*})OBJECT,},/* THE STRING TO WHICH CHARACTERS WILL}#*/
}=/*}#BE COPIED};*/
}*WORKING'NAME;}&/* TO KEEP SPL HAPPY}5*/

}'DECLARE INTEGER
}*COUNT,}-/* JUST A COUNTER FOR A FOR LOOP})*/
}*LENGTH'ADDENDUM;}#/* LENGTH OF THE STRING ADDENDUM})*/



* SCOPY - COPY THE SECOND STRING INTO THE FIRST
}'UNKNOWN FUNCTION SCOPY(STRING @OBJECT, ADDENDUM), FRETURN;
}'OBJECT.WP _ OBJECT.RP _ OBJECT.BP;



* APPEND - APPEND THE SECOND STRING TO THE FIRST
}'UNKNOWN FUNCTION APPEND(STRING @OBJECT, ADDENDUM), FRETURN;
}'WORKING'NAME _ OBJECT.STRING'DESC;
}'FRETURN IF ADDENDUM$CHAR'SIZE # WORKING'NAME$CHAR'SIZE;
}'LENGTH'ADDENDUM _ LENGTH(ADDENDUM);
}'FRETURN IF
}*LENGTH'ADDENDUM > LNGDES(WORKING'NAME$WP, WORKING'NAME$EP);

}'WCI(GCI(ADDENDUM), WORKING'NAME) FOR COUNT _ 1 TO LENGTH'ADDENDUM;

}'OBJECT.WP _ WORKING'NAME$WP;
}'RETURN;


}'END;
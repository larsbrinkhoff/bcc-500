SDEX}#IDENT
}'NOLIST EXT

BSE}$LMACRO N
$N(0)}"BSS N(1)
}'ENDM

LSUB}#MACRO D; C LSUB; NOP D(1); ENDM

LDD}$MACRO D; LDA D(1); LDB D(1)+1; ENDM

STD}$MACRO D; STA D(1); STB D(1)+1; ENDM

*}"PARAMETERS
RTIME}"EQU 4B7+10B}"LOCATION OF REAL-TIME CLOCK
NPAGES EQU 64}"MAXIMUM SIZE OF CHT
CH1ORG EQU 400B}"ORIGIN OF CHT1
CH2ORG EQU 1000B}"ORIGIN OF CHT2
CHLBIT EQU 1B6}"PRIVATE LOCK BIT IN CHT
CHLWD}"EQU 4}#WORD DISPLACEMENT FOR SAME
MAPORG EQU 200B}"RELATIVE ORIGIN OF MAP IN CONTEXT BLOCK
PMTORG EQU 300B}"RELATIVE ORIGIN OF PMT IN CONTEXT BLOCK
SAVORG EQU 2764B}"START OF SAVED STATE IN CONTEXT BLOCK
LSTATE EQU 12}"LENGTH OF STATE
CPUWA}"EQU 23B}"ADDRESS OF CPUWAIT CELL
$PGO}#EQU 12343210B}"PUT IN WAIT TO STEP PROCESSOR
CPUCB}"EQU 6}#ADDRESS FROM WHICH CPU LOADS PRT ADDRESS
PRTB}#EQU 302B}"PRT BASE CELL
NPRT}#EQU 32}"NUMBER OF PRT ENTRIES
LPRTE}"EQU 12}"LENGTH OF PRT ENTRY
DTTBUF EQU 3130B}"MESSAGE BUFFER FOR MONITOR
ILRA}#EQU 37B}"ADDRESS FROM WHICH MSCH LOADS ILR
BRKENA EQU 2406B}"BRK OPR ACTIVE IF =PGO
RTCA}#EQU 11B}"LOWER WORD OF 10-US REAL-TIME CLOCK
NBP}$EQU 16}"NUMBER OF BREAKPOINT INTERVALS
NJB}$EQU 8}#LENGTH OF JUMP BUFFER
NJSB}#EQU 8}#LENGTH OF BLL BUFFER
WAITO}"EQU 25B-1}"ADDRESS OF PROC WAIT CELLS
BRKAO}"EQU 20B-1}"ADDRESS OF PROC BRKADR CELLS
RELREQ EQU 10}"AMC 'RELEASE PAGE' REQUEST CODE
RDPREQ EQU 18}"AMC 'READ PAGE' REQUEST CODE
AMCGRQ EQU 104B}"AMC GENERAL REQUEST QUEUE
AMCARQ EQU 102B}"AMC ACTIVATE REQUEST QUEUE
ACTCELL EQU 100B}"ACTIVATE COMMUNICATION CELLS
AMCFREL EQU 110B}"AMC NODE FREELIST
AMCNFREL EQU 123B}"AMC FREELIST COUNT
* TABLE OF SAVE AREAS AND SCRATCHPAD LENGTHS
SAVTAB EQU *-1
}'DATA 2500B,2620B,2740B
LSKTAB EQU *-1
}'DATA 100B,40B,100B
* STROBE AND ZAP BITS
STRBT}"EQU *-1
}'DATA 1,2,4,10B
ZMBT}#EQU *-1
}'DATA 100B,1,2,600B
* SCRATCHPAD SAVE AREAS
SKSAVE EQU *-1
}'DATA AMCSK,UTPSK,CHIOSK
AMCSK}"BSS 120B
UTPSK}"BSS 120B
CHIOSK BSS 120B
* CPU DEVICE, STEP + PROCEED
CPDEVT DATA 4B7+10B,4B7+10B
CPSTET DATA 1,20B
CPPROT DATA 2,40B

*}"WORKING STORAGE
XCARRY BSS 1}#STORAGE FOR LSUB ROUTINE
HLSP}#BSS 1}#.
LLSP}#BSS 1}#.
LSTEMP BSS 2}#.
MSP}$BSS 1}#.
P2DGTA BSS 1}#STORAGE FOR P2DGT ROUTINE
HOURS}"BSS 1}#STORAGE FOR TOUT ROUTINE
MINS}#BSS 1}#.
SECS}#BSS 1}#.
DAYS}#BSS 1}#.
DAY}$BSS 1}#.
WDAY}#BSS 1}#.
MONTH}"BSS 1}#.
YEAR}#BSS 1}#.
LDAY}#BSS 2}#.
LHOUR}"BSS 2}#.
LMIN}#BSS 2}#.
XOTIME BSS 1}#.
XTIME}"BSS 2}#.
XTEMP}"BSS 2}#.
OPNG}#EQU *
OPCNG}"BSS 4}#BITS FOR UNEXECUTABLE OPCODES
OPRNG}"BSS 4}#BITS FOR UNEXECUTABLE OPRS
OPXNG}"BSS 1}#BITS FOR SPECIAL CASES
OPNGE}"EQU *
T}&ZRO
XSAVE}"ZRO
SCSETA BSS 1
SCSETB BSS 1
$ERRHLT DATA -100}.COUNT FOR STOPPING ON TOO MANY SWRS
$ERCNT BSS 1
$BOTH}"DATA 0}"FLAG TO INDICATE TWO CPU MODE
DAYNAM DATA 0,"SUN","MON","TUE","WED","THU","FRI","SAT"
MODAYS DATA 0,31,28,31,30,31,30,31,31,30,31,30,31
MONAME DATA 0,"JAN","FEB","MAR","APR","MAY","JUN","JUL","AUG","SEP"
}'DATA "OCT","NOV","DEC"

* POINTERS TO CENTRAL MEMORY
PCPTR}"BSE 1}#POINTER TO PC IN STATE
REGP}#EQU *
ARPTR}"BSE 1}#POINTER TO AR IN STATE
BRPTR}"BSE 1}#POINTER TO BR IN STATE
XRPTR}"BSE 1}#POINTER TO XR IN STATE
LRPTR}"BSE 1}#POINTER TO LR IN STATE
GRPTR}"BSE 1}#POINTER TO GR IN STATE
SRPTR}"BSE 1}#POINTER TO SR IN STATE
EREGP}"EQU *
CRPTR}"BSE 1}#POINTER TO CR IN STATE
DRPTR}"BSE 1}#POINTER TO DR IN STATE
NREGS}"EQU EREGP-REGP
ESPTX}"BSS 1}#POINTER TO END OF STATE (WITH INDEX BIT)
$CPWPTR DATA 4B7+23B}"POINTER TO CPUWAIT CELL FOR SELECTED CPU
$CPWPT0 DATA 4B7+23B}"PTR TO CPU0 WAIT CELL
$CPWPT1 DATA 4B7+24B}"PTR TO CPU1 WAIT CELL
PRWPTR BSS 1}#POINTER TO BROKEN PROC WAIT CELL
PRAPTR ZRO PRTB,4}"POINTER TO PRT BASE CELL
CH1PTR ZRO CH1ORG,6}"POINTER TO CHT1 (WITH INDEX BIT ON)
CH2PT0 ZRO CH2ORG+0,6}"POINTER TO CHT2+0 (DITTO)
CH2PT1 ZRO CH2ORG+1,6}"DITTO +1
CH2PT2 ZRO CH2ORG+2,6}"DITTO +2
CH2PT3 ZRO CH2ORG+3,6}"DITTO +3
CH2PT5 ZRO CH2ORG+5,6}"DITTO +5
CH2PTL ZRO CH2ORG+CHLWD,6}"DITTO +CHLWD
PMTPT0 BSS 1}#POINTER TO PMT+0 (WITH INDEX BIT)
PMTPT1 BSS 1}#DITTO +1
PMTPT2 BSS 1}#DITTO +2
PMTPT3 BSS 1}#DITTO +3
MAPPTR BSS 1}#POINTER TO MAP IN CONTEXT BLOCK (WITH INDEX BIT)
DTTPTR ZRO DTTBUF,4}"POINTER TO MESSAGE BUFFER
CBAPTR BSE 1}#POINTER TO CPU CONTEXT BLOCK ADDRESS CELL
MSPPTR BSS 1}#POINTER TO SP (WORD 2) IN CONTEXT BLOCK
ILRPTR ZRO ILRA,4}"POINTER TO ILR CELL
BRKENP DATA 4B7+BRKENA,4B7+BRKENA+1 PTRS TO BRK ENABLE CELLS
FRELBA ZRO AMCFREL,4}$AMC FREELIST HEAD,
FRELEA ZRO AMCFREL+1,4}$TAIL,
FRELCA ZRO AMCNFREL,4}%COUNT
ACTPT0 ZRO ACTCELL,4}$ACTIVATE CELL 0,
ACTPT1 ZRO ACTCELL+1,4}$1
CLOCKA ZRO RTCA,4}"POINTER TO CLOCK
* POINTERS TO THE SIMULATOR
SRGPTR ZRO SIMREG
SSAPTI ZRO* STOADDR
SSVPTR ZRO STOVAL

*}"STORAGE FOR SIMULATION
ESREG}"BES NREGS}"SAVED VALUES OF REGISTERS FOR COMPARISON
CTXBLK BSE 1}#CONTEXT BLOCK ADDRESS
PRTLOC BSE 1}#PRT ENTRY ADDRESS
SIMIN}"BSE 1}#INITIALIZE SIM IF >=0
CPUIN}"BSE 1}#INITIALIZE CPU IF >=0
CHTSE0 BSS 1}#1ST WORD OF REAL NAME FOR CHTS
CHTSE1 BSS 1}#2ND DITTO
CHTSE2 BSS 1}#3RD DITTO
CHTST}"BSS 1}#TEMPORARY WHILE COMPUTING CHT HASH CODE IN CHTS
CHTSC}"BSS 1}#COUNT OF ENTRIES EXAMINED IN CHTS
CHTSI}"BSS 1}#CORE PAGE NUMBER IN CHTS
RPPTR}"BSS 1}#POINTER TO REAL NAME IN RPAGE
RNPTR}"BSS 1}#POINTER TO REAL NAME FOR AMCREQ, WORD 0,
RNPTR1 BSS 1}%1,
RNPTR2 BSS 1}%2
TRIES}"BSS 1}#ATTEMPT COUNTER IN AMCREQ, READPAGE
AMCNODE BSS 1}"AMC REQUEST NODE FROM AMCREQ FOR PUTAMC
RELCP}"BSS 1}#CORE PAGE FOR RELCORE
RELAX}"BSS 1}#CORE PAGE IN RELALL
DIRTYT BSS 1}#TEMP. IN CDIRTY
BPCNT}"BSS 1}#-NUMBER OF BREAKPOINTS
BPELL}"BES NBP}"TABLE OF BREAKPOINT LOWER LIMITS -1
BPEUL}"BES NBP}"TABLE OF BREAKPOINT UPPER LIMITS
BPLL}#EQU BPELL-1}"END OF NORMAL LL TABLE
BPUL}#EQU BPEUL-1}"END OF NORMAL UL TABLE
BETLL}"BSS 1}#TEMPORARY BREAKPOINT LL IN BREAKPOINT COMMANDS
BETUL}"BSS 1}#DITTO UL
BECNT}"BSS 1}#DITTO BPCNT
BSWL}#BES NBP*2}"SAVED INSTRUCTION LIST
BSLL}#BES NBP*8}"SAVED LOCATION LIST (UN0, UN1, DKA, WD)
BSCNT}"BSE 1}#-SIZE OF ABOVE-1
OLDPC}"BSS 1}#PREVIOUS PC VALUE WHILE RUNNING CPU
BRKPC}"BSS 1}#IGNORE BREAK AT THIS PC
INSTCT BSS 1}#INSTRUCTION COUNT FOR DOINST
INSTYP BSS 1}#INSTRUCTION TYPE FROM CPUSIM
IRVAL}"BSS 1}#RETURN TYPE FROM DOINST
CIW}$BSS 1}#CURRENT INSTRUCTION WORD
STOAP}"BSS 1}#STOADR POINTER IN DOINST
STOVP}"BSS 1}#STOVAL POINTER IN DOINST
STOC}#BSS 1}#STORE COUNTER IN DOINST
SREGP}"BSS 1}#SIMREG POINTER IN DOINST
ICFAIL BSS 1}#<0 IF CPU ERROR IN DOINST
DTOPTR BSS 1}#POINTER TO MESSAGE IN DOINST
DTOCC}"BSS 1}#MESSAGE CHARACTER COUNT IN DOINST
JBUF}#BES NJB}"JUMP BUFFER
}'DATA -NJB}"-LENGTH OF JBUF
JBA}$ZRO *-1,2
JCNT}#BSS 1}#POINTER TO JUMP BUFFER (NEGATIVE)
JWRAP}"BSS 1}#<0 IF JBUF HAS WRAPPED AROUND
JSBUF}"BES NJSB}"BLL BUFFER
}'DATA -NJSB}"-LENGTH OF JSBUF
JSBA}#ZRO *-1,2
JSCNT}"BSS 1}#POINTER TO BLL BUFFER (NEGATIVE)
JSWRAP BSS 1}#<0 IF JSBUF HAS WRAPPED AROUND
RETFX}"BSS 1}#SAVE (X) FOR RETFIX
GOFX}#BSS 1}#SAVE (X) IN GOFIX
EWRB}#BES 5}#BUFFER FOR SYSTEM WARNING REGISTERS
WRACC}"BSS 1}#UNION OF ALL SWR'S
HFLAGS BSE 1}#FLAGS TO SPECIFY BREAK CONDITIONS
UEMODE BSE 1}#<=0 = SIM, 0 = SIM AND RUN, >=0 = RUN
ICOUNT BSE 1}#INCTRUCTION COUNTER
MMSP}#BSE 1}#MAX. MONITOR STACK POINTER
ATTNF}"BSE 1}#FLAGS FOR ATTN SIMULATION
WARNF}"BSE 1}##0 TO MONITOR SWR'S
SCHEDF BSE 1}#SAVED VALUE OF SCHEDULE MODE
STEP}#BSE 1}#0=FULL-SPEED, -1=STEP
CPUNO}"BSE 1}#CPU NUMBER
AUTOBP BSE 1}#AUTO BP ADDRESS
PROCNO BSE 1}#AUTO BP PROCESSOR NUMBER
PBADDR BSS 1}#END OF BUFFER FOR PBC
PBCNT}"BSS 1}#COUNT OF ENTRIES IN PBC
PBLOC}"BSS 1}#CURRENT INDEX IN PBC
RMAPI}"BSS 1}#VIRTUAL PAGE NUMBER IN RMAP
STKTP}"BSS 1}#CURRENT ENVIRONMENT IN STKTR
STKTB}"BSS 1}#STACK RING IN STKTR
LNGI}#BSS 1}#BIT INDEX IN OPNG IN DXLNG
LNGN}#BSS 1}#COUNT OF SYMBOLS ON LINE IN DXLNG
PMPTR}"BSS 1}#PRIVATE MEMORY POINTER FROM COPYS
MMPTR}"BSS 1}#MAIN MEMORY POINTER FROM COPYS

*}&RE-ENTRY FROM USER

*}&PRINT CONTENTS OF REGISTERS IF CHANGED.}"DOES NOT PRINT REGISTERS
*}&WHICH HAVE NOT CHANGED SINCE LAST TIME THE REGISTERS WERE PRINTED

$RETURN BRU RETTAB,2
RETTAB BRU BELL}$RUBOUT
}'BRU BREAK}#BREAKPOINT
}'BRU RCBRK}#RING CROSSING
}'BRU TOBRK}#TOO MUCH TIME
}'BRU NEBRK}#SIM + CPU DISAGREE
}'BRU ERBRK}#SIM ERROR
}'HLT *
}'BRU CBBRK}#COULD NOT FIND CTX BLOCK
*
ERBRK}"LDX INSTYP; TMF _/SEMSG; BRU BREAK1
NEBRK}"TMF NEBMSG; BRU BREAK1
TOBRK}"TMF TOBMSG; BRU BREAK1
CBBRK}"TMF CBBMSG; BRU BREAK1
RCBRK}"LDX INSTYP; TMF _/ERCMSG
BREAK1 TMF ERCMSG
$BREAK C FINDP; BRU BREAK0; C RNSET; BRU BREAK0; C RMAP
BREAK0 C PCC; BRU RSR
INSTBW C RETFIX; TMF SWRMSG; C PRWR; BRU BREAK1
INSTBQ C RETFIX; C TCR; BRU BREAK1
*
NEBMSG ASC 'SIM#CPU/'
TOBMSG ASC 'CPU HUNG UP/'
CBBMSG ASC 'COULD NOT FIND CB/'
RCMSG}"DATA RC5M,RC4M,RC3M,RC2M,RC1M
ERCMSG ASC ' AT /'
RC1M}#ASC 'RING CROSSING/'
RC2M}#ASC 'RING-DEP. TRAP/'
RC3M}#ASC 'FIXED TRAP/'
RC4M}#ASC 'SYSTEM CALL/'
RC5M}#ASC 'PRIV. OPR/'
SEMSG}"DATA SE0M,SE1M,SE2M,SE3M,SE4M,SE5M,SE6M
SE0M}#ASC 'EXU CHAIN TOO LONG/'
SE1M}#ASC 'NOT IMPLEMENTED/'
SE2M}#ASC 'TOO MANY STORES/'
SE3M}#ASC 'TABLES SNARLED/'
SE4M}#ASC 'INTERPRETED OPR/'
SE5M}#ASC 'RUBOUT/'
SE6M}#ASC 'USCL, SCHED. MODE OFF/'
SWRMSG ASC 'SWR#0:$/'
*
PCA}$LDA* PCPTR; ETR =777777B; STA LRO; LDX =-1; C _AMD
}'TCF =':'; R1
PCC}$C PCA; C TTB; LDA LRO; C ULOAD; BRU PCC1
}'C PI; BRU PCO+1
PCC1}#TCF ='?'; BRU PCO+1
$PCO}#C PCA; LDA BMD; C MS; LDX =-NREGS
PCO3}#LDA ESREG,2; SKE* EREGP,2; BRU PCO2
PCO1}#BRX PCO3; R1
PCO2}#LDA REGIST,2; LDB ENDX; LSH 18; STX XSAVE
}'C TTB; C PWD; TCF =0; LDA* EREGP,2; STA ESREG,2
}'LDX =-1; C _BMD; LDX XSAVE; BRU PCO1
}'TEXT '}#A}#B}#X}#L}#G}#S'
REGIST BSS 0


*}"SET UP POINTERS TO CONTEXT BLOCK.}"(A) = REAL ADDRESS OF PRT ENTRY

$RNSET ETR =777777B; STA PRTLOC; MRG =4B7; STA T; LDA* T; MIN T
}'LDB* T; MIN T; LDX* T; C CHTS; R1
}'CLB; LSH 11
}'ETR =777777B; MRG =6B7; STA CTXBLK
}'ADD =2-2B7; STA MSPPTR; ADD =2B7+PMTORG-2; STA PMTPT0
}'ADD =1; STA PMTPT1; ADD =1; STA PMTPT2
}'ADD =1; STA PMTPT3; ADD =MAPORG-PMTORG-3; STA MAPPTR
}'ADD =SAVORG-MAPORG-2B7; STA PCPTR; ADD =1; STA ARPTR
}'ADD =1; STA BRPTR; ADD =1; STA CRPTR
}'ADD =1; STA DRPTR; ADD =2; STA XRPTR
}'ADD =1; STA LRPTR; ADD =1; STA GRPTR
}'ADD =1; STA SRPTR; ADD =LSTATE-9+2B7; STA ESPTX
}'CLA; STA SIMIN; STA CPUIN; R2


*}"SEARCH CHT FOR ENTRY (ABX).
*}"RETURN NO-SKIP IF MISSING OR INACCESSIBLE
*}"RETURN WITH SKIP, (X) = CHT INDEX, (A) = CORE PAGE NUMBER
*}"IF FOUND

CHTS}#STA CHTSE0; STB CHTSE1; STX CHTSE2
*}"COMPUTE CHT HASH CODE AND PUT INTO X
}'LDA CHTSE0; EOR CHTSE1; STA CHTST
}'RSH 8; EOR CHTST; RSH 8; EOR CHTST
}'EOR =264B; ETR =377B; CAX
}'LDA =NPAGES; STA CHTSC; LDB =@6B7; LDA* CH1PTR; BRU CHTS2
CHTS1}"LDA* CH2PT0; SKE CHTSE0; BRU CHTS3
}'LDA* CH2PT1; SKE CHTSE1; BRU CHTS3
}'LDA* CH2PT2; SKM CHTSE2; BRU CHTS3
}'LDA* CH2PT3; SKA =36B6; R1; CXA
* SNEAKY DIVIDE BY 6 - ONLY GOOD BETWEEN 0 AND 1377B
}'STA CHTSI; RSH 2; ADD CHTSI; STA CHTSI
}'RSH 4; ADD CHTSI; ADD =6; RSH 3; STA CHTSI
* NOW MULTIPLY BY 6 AND CHECK IF EXACT
}'CLB; LSH 1; ADD CHTSI; LSH 1; STA CHTST
}'CXA; SKE CHTST; R1 (DIVISION NOT EXACT)
}'LDA* CH2PT3; RSH 11; ETR =177B
}'SKE CHTSI; R1 (CPA FIELD DID NOT MATCH); R2
CHTS3}"LDA* CH2PT5
CHTS2}"ETR =777777B; SKE =777777B; BRU *+2; R1
}'SUB =CH2ORG; SKG =NPAGES*6-1; SKG =-1; R1
}'CAX; SKR CHTSC; BRU CHTS1; R1


*}"GET AMC REQUEST NODE AND FILL IN.
*}"(X) POINTS TO UN-DKA, (A)=REQUEST CODE,
*}"LEAVE NODE ADDRESS IN AMCNODE, (X) IN RNPTR

AMCREQ CAB; STX RNPTR; LDA =10000; STA TRIES
AMCR1}"PRO 2; LDA* FRELBA; SKE =777777B; BRU AMCR2; UPR 2
}'SKR TRIES; BRU AMCR1; TMF AMCRM; BRU RSR
AMCRM}"ASC '$NO AMC NODES/'
AMCR2}"STA AMCNODE; MRG =4B7; STA T; LDA* T; STA* FRELBA
}'SKE =777777B; BRU AMCR3; LDA FRELBA; EOR =4B7; STA* FRELEA
AMCR3}"SKR* FRELCA; NOP; UPR 2
}'LDA* RNPTR; STA* T; MIN RNPTR; MIN T
}'LDA* RNPTR; STA* T; MIN RNPTR; MIN T
}'LDA* RNPTR; STA* T; MIN T; LDA =-2; ADM RNPTR
}'CLA; STA* T; MIN T; STB* T; R1

*}"PUT AMCNODE ON QUEUE.}"(X) POINTS TO QUEUE HEADER

PUTAMC CXA; MRG =4B7; STA T; PRO 2
}'LDA AMCNODE; XMA* T; CAB; MIN T
}'LDA* T; ADD =4B7+5; STA T
}'LDA AMCNODE; STA* T; ADD =4B7+5; STA T; STB* T
}'UPR 2; R1

*}"RELEASE CORE PAGE (A) TO DRUM

$RELCORE MUL =3 (6); CBA; STA RELCP; ADD =4B7+CH2ORG; CAX
}'LDA CHLWD,6; SKA =CHLBIT; BRU *+2; R1
}'LDA =RELREQ; C AMCREQ; LDX =AMCGRQ; C PUTAMC
}'LDX RELCP; LDA* CH2PTL; ETR =CHLBIT
}'CNA; ADM* CH2PTL; RQS 1; R1

*}"RELEASE CURRENT DRUM DATA PAGE, IF ANY

$RELDP LDA DRUMP; SKG =0; R1
}'C RELCORE; CLA; STA DRUMP; R1

*}"RELEASE ALL CORE PAGES HELD BY SYSDDT

$RELALL SKN DRUM; R1; CLA; STA DRUMP; STA RELAX
RELA1}"LDX RELAX; LDA* CH2PTL; SKA =CHLBIT; BRU RELA2
RELA3}"LDA RELAX; ADD =6; STA RELAX
}'SKE =NPAGES*6; BRU RELA1; R1
RELA2}"ETR =774000B; RSH 11; C RELCORE; BRU RELA3

*}"READ PAGE WITH UN-DKA AT (A) INTO CORE.
*}"NO-SKIP ON ERROR, SKIP WITH (A)=CORE PAGE ON SUCCESS

$RPAGE STA RPPTR; C RELDP; LDA RPPTR; C READPAGE; R1
}'STA DRUMP; R2

$READPAGE CAX; LDA* ACTPT0; SKE =0; BRU READP1; MIN* ACTPT0
}'LDA =RDPREQ; C AMCREQ; LDX =AMCARQ; C PUTAMC; RQS 1
READP3 LDA* ACTPT0; SKE =1; BRU READP3; SKE =0; BRU READP2
}'LDA RNPTR; ADD =1; STA RNPTR1; ADD =1; STA RNPTR2
}'LDA =1000; STA TRIES
READP4 LDA* RNPTR; LDB* RNPTR1; LDX* RNPTR2
}'C CHTS; BRU READP5; R2
READP5 SKR TRIES; BRU READP4; TMF RDPTM; R1
RDPTM}"ASC '$COULD NOT READ PAGE/'
READP1 TMF RDP1M; R1
RDP1M}"ASC '$ACT CELL # 0/'
READP2 LDA* ACTPT1; CLB; STB* ACTPT0; C TCR
}'SKG =6; SKG =3; BRU READP6; SUB =4; CAX
}'TMF _/RDPEM; R1
RDPEM}"DATA RDPE4,RDPE5,RDPE6
RDPE4}"ASC 'PAGE NOT IN DHT/'
RDPE5}"ASC 'WRONG DKA IN DHT/'
RDPE6}"ASC 'PAGE NOT ON DRUM/'
READP6 C AP10; TMF RDPQM; R1
RDPQM}"ASC ' AMC ERROR/'

*}"MARK PAGE CONTAINING ADDRESS (A) AS DIRTY

$CDIRTY ETR =@77B6; RSH 11; CLB; LSH 1; STA DIRTYT
}'LSH 1; ADD DIRTYT; CAX
}'LDA* CH2PT3; MRG =4B7; STA* CH2PT3; R1


*}"SET OR CLEAR BREAKPOINT 0
$BEE}#SKN SYL; BRU BEE1
*}"CLEAR
BEEE}#LDA =-2; STA BPLL; STA BPUL; R1
*}"SET
BEE1}#C BEI; STA BPLL; STB BPUL; R1

*}"COLLECT INTERVAL FOR BREAKPOINT
BEI}$ETR =777777B; CAB; SKN ARI; LDA ARG
}'ETR =777777B; SUB =1; R1

*}"SET GENERAL BREAKPOINT, OR LIST BREAKPOINTS
$BER}#SKN SYL; BRU BER1
*}"LIST
}'LDX BPCNT; STX BECNT; LDA BPLL; STA BPLL,2
}'LDA BPUL; STA BPUL,2; BRU BER2A
BER3}#C TTB; LDA BPLL,2; SKE =-2; BRU BER3A
}'TCF ='*'; BRU BER2
BER3A}"ADD =1; STA BETLL; C APT
}'LDA BPUL,2; SKE BETLL; BRU BER4
BER2}#BRX BER2A; R1
BER2A}"SKR BECNT; BRU BER3; C TCR
}'LDA =3; STA BECNT; BRU BER3
BER4}#TCF =','; C APT; BRU BER2
*}"SET
BER1}#C BEI; CAX; LDA BPCNT; SKG =-NBP; BRU BER5
}'XXA; SKR BPCNT; NOP
}'STA BPLL,2; STB BPUL,2; R1
BER5}#C PFULL; R1

*}"CLEAR GENERAL BREAKPOINT, OR ALL BREAKPOINTS
$BEP}#SKN SYL; BRU BEP1
*}"ALL
$BPCLR LDA =-1; STA BPCNT; BRU BEEE
*}"SPECIFIC INTERVAL.}"6 CASES
BEP1}#C BEI; STA BETLL; STB BETUL; LDX BPCNT; BRU BEP0
BEP2}#LDA BPLL,2; ADD =1; SKG BETUL; BRU BEP3
*}"LL>TUL OR UL<TLL.}"NO ACTION
BEP0}#BRX BEP2; R1
BEP3}#SKG BETLL; BRU BEP4
*}"LL<=TUL BUT LL>=TLL.}"CHECK UL AGAINST TUL
}'LDA BPUL,2; SKG BETUL; BRU BEP5
*}"UL>TUL.}"REPLACE LL BY TUL
}'LDA BETUL; STA BPLL,2; BRU BEP0
*}"UL<=TUL.}"DELETE ENTIRE INTERVAL.}"SPECIAL CHECK FOR ALL BREAKPOINTS
*}"GONE
BEP5}#CXA; MIN BPCNT; LDX BPCNT
}'LDB BPLL,2; XXA; STB BPLL,2
}'XXA; LDB BPUL,2; XXA; STB BPUL,2
}'SKE =-1; BRU BEP2; R1
*}"LL<TLL.}"CHECK UL AGAINST TLL
BEP4}#LDA BPUL,2; SKG BETLL; BRU BEP0
*}"UL>=TLL.}"NOW CHECK AGAINST TUL
}'SKG BETUL; BRU BEP6
*}"UL>TUL.}"SPLIT THE INTERVAL INTO TWO, IF POSSIBLE
}'LDA BPCNT; SKG =-NBP; BRU BEP7
}'LDB BPLL,2; XXA; STB BPLL,2; LDB BETLL; STB BPUL,2
}'XXA; SUB =1; STA BPCNT
}'LDA BETUL; STA BPLL,2; BRU BEP0
*}"UL<=TUL.}"REPLACE UL BY TLL
BEP6}#LDA BETLL; STA BPUL,2; BRU BEP0
*}"OVERFLOW
BEP7}#C PFULL; BRU BEP0


*}"DO (A) INSTRUCTIONS IN THE M1 CPU.}"CHECK FOR BREAKPOINTS.
*}"IGNORE BREAK FROM (B)

$DOIT}"STB BRKPC; SKN STEP; BRU DOCONT
DOIT1}"LDB BRKPC; LDA =@4B7; C DOINST; R1; BRU DOIT1
$DOINST STA INSTCT; STB BRKPC; BRU INSTX0
*}"DO NEXT INSTRUCTION
INSTX1 C WSHOW; LDA* PCPTR; STA OLDPC; SKG =577777B; BRU INST12
}'LDA* MSPPTR; SKG MMSP; BRU *+2; STA MMSP
*}"CHECK FOR BREAK
INST12 SKN RUBOUT; BRU INSTB0; LDA* PCPTR; LDX BPCNT
INST3}"SKG BPEUL,2; SKG BPELL,2; BRU INST4
}'SKE BRKPC; BRU INSTB1; LDX =-1; STX BRKPC
INST4}"BRX INST3; LDA =-1; STA INSTYP
}'LDA =1; SKG UEMODE; BRU INSTX3
* CALL SIMULATOR
}'LDA UEMODE; BRM CSIM; STB CIW; SKE =4; BRU INSTX3
* SPECIAL OPR DETECTED BY SIMULATOR
}'LDX =-1; BRU INSTXA
INSTX3 LDA UEMODE; SKG =-1; BRU INSTX4; SKE =1; BRU INST23
* FETCH CURRENT INSTRUCTION AND CHECK FOR SPECIAL OPR'S
}'LDA* PCPTR; ETR =777777B; LRSH 11; C RME; BRU INST23
}'CLB; LSH 11; MRG =4B7; STA T
}'LDA* PCPTR; ETR =3777B; ADM T
}'LDA* T; STA CIW; BRM CHKOP; BRU INST29; BRU INSTC0
* CHECK FOR PRO, UNPRO TO MSCH
INST29 LDA* ARPTR; SKA =10B; BRU *+2; BRU INST23
}'LDA CIW; SKE PROOP; BRU INST28
}'CMDA; ETR =@SCHBIT; XMDA; BRU INST23
INST28 SKE UNPROOP; BRU INST23
}'CMDA; MRG SCHEDF; XMDA
*}"CHECK FOR UNEXECUTABLE INSTRUCTION
INST23 LDA CIW; SKA =4B4; BRU INSTC1
}'LRSH 19; ETR =3; CAX; CLA; RSH 20
}'LDA OPCNG,2; CBX; LCY 0,2; SKA =4B7; BRU INSTC0
}'LDA CIW; EOR =77734000B; SKA =77734000B; BRU INST24
}'SKA =2000B; BRU INSTC2; LRSH 4; CAX; CLA; RSH 20
}'LDA OPRNG,2; CBX; LCY 0,2
}'SKA =4B7; BRU INSTC0; BRU INST24
INSTC2 CNA; LDB =2B7; SKA =1000B; LDB =1B7
}'SKB OPXNG; BRU INSTC0; BRU INST24
INSTC1 SKN OPXNG; BRU INST24; BRU INSTC0
INSTC0 LDA UEMODE; SKE =1; BRU INSTMS
}'LDA =-1; BRM CSIM; BRU INSTMS
* STEP CPU
INST24 SKN CPUIN; BRU *+2; BRU INST26
}'CLA; STA* CPWPTR; CLRMAP; LDA =-1; STA CPUIN
INST26 LDA =PGO; STA* CPWPTR
INSTCR EQU *
INST27 LDX =-1000; LDB* CPWPTR; SKB =-1; BRX *-2
}'LDA CIW; SKE USCLOP; BRU *+2; BRU USS0
}'SKB =-1; BRU INSTB3
* CLEAN UP AFTER INSTRUCTION
INSTX4 LDX UEMODE
INSTXA LDA CIW; SKE USCLOP; BRU INSTXT+1,2
* USCL.}"FIGURE OUT WHICH PROCESS, IF ANY, IS RUNNING
USS0}#C FINDP; BRU UNIDLE; C RNSET; BRU INSTB7
}'LDA CTXBLK; ETR =777777B; BRM CLRSIM; BRU INSTMR
INSTXT BRU INSTMS}$SIM ONLY
}'BRU INSTMC}$SIM + RUN
}'BRU INSTMR}$RUN ONLY
* STORE RESULTS OF SIMULATION
INSTMS LDA SRGPTR; STA SREGP; LDX =-LSTATE
INST21 LDA* SREGP; STA* ESPTX; MIN SREGP; BRX INST21
}'BRU INSTX2
* CHECK RESULTS OF SIMULATION
INSTMC LDA SRGPTR; STA SREGP; CLA; STA ICFAIL; LDX =-LSTATE
INST14 LDA* ESPTX; LDB ERCMSK,2; SKM* SREGP; BRU INST16
INST17 MIN SREGP; BRX INST14; LDA SSAPTI; STA STOAP
}'LDA SSVPTR; STA STOVP; LDA STOCNT; STA STOC; BRU INST18
INST19 LDA* STOAP; SKE* STOVP; BRU INST20
INST22 MIN STOAP; MIN STOVP
INST18 SKR STOC; BRU INST19
}'SKN ICFAIL; BRU INSTX2; C TCR; BRU INSTB4
VSM}$ASC ': SIM/'
VCM}$ASC ' CPU/'
* REGISTERS DISAGREE
INST16 STX ICFAIL; C TCR; TCF /ERNAME; TMF VSM
}'LDA* SREGP; C AP8; TMF VCM
}'LDA* SREGP; XMA* ESPTX; C AP8; LDX ICFAIL; BRU INST17
* MEMORY CONTENTS DISAGREE
INST20 LDX =-1; STX ICFAIL; C TCR; LDX STOAP; LDA 0,2
}'ETR =777777B; C AP8; TMF VSM
}'LDA* STOVP; C AP8; TMF VCM
}'LDA* STOVP; XMA* STOAP; C AP8; BRU INST22
* REGISTER COMPARISON MASKS
RCMSK}"DATA -1,-1,-1,-1,-1,-1B4
}'DATA -1,-1,-1,@16B,0,0
ERCMSK EQU *
* REGISTER NAME TABLE
RNAME}"TEXT '}#P}#A}#B}#C}#D}#E'
}'TEXT '}#X}#L}#G}#S}#?}#?'
ERNAME EQU *
*}"END OF INSTRUCTION
INSTMR EQU *
* CHECK FOR BRANCH
INSTX2 LDA OLDPC; ADD =1; SKE* PCPTR; BRU INST1
INST2}"LDA =-1; STA SIMIN; MIN ICOUNT
}'LDA INSTYP; SKE =5; BRU *+2; BRU INSTB0
}'SKE =4; BRU *+3; LDA =-5; STA INSTYP
}'CNA; SKG =0; BRU INSTB5
}'CAX; LDA HFLAGS; LSH 1
}'LCY 0,2; SKB =2; BRU INSTB2
INSTX0 SKR INSTCT; BRU INSTX1; R2
* EXIT CONDITIONS
INSTB2 LDX =2; BRU IDONE
INSTB1 LDX =1; BRU IDONE
INSTB0 CLX; BRU IDONE
INSTB3 LDX =3; BRU IDONE
INSTB4 LDX =4; BRU IDONE
INSTB5 LDX =5; BRU IDONE
INSTB7 LDX =7; BRU IDONE
* FIND CURRENT PROCESS
IDONE}"STX IRVAL; LDA PRTLOC; SKG =0; BRU IDONE1
}'CAX; LDA 8,6; SKA =2; BRU IDONE0
IDONE1 C FINDP; BRU UNIDLE; C RNSET; BRU IDONE4
IDONE0 LDX IRVAL; R1
IDONE4 LDX =7; R1
* CPU IDLE.}"PRINT MESSAGE AND WAIT
IBM}$ASC 'CPU IDLE../'
IEM}$ASC 'GO$/'
UNIDLE TMF IBM
UNI1}#SKN RUBOUT; BRU BELL; C FINDP; BRU UNI1
}'C RNSET; BRU IDONE4; TMF IEM
}'LDA IRVAL; SKE =3; BRU IDONE0
}'SKN STEP; BRU DOCCR; BRU INSTCR
*}"BRANCH.}"PUT IN BUFFER
INST1}"SUB =1; LDX JCNT; BRX INST5
}'LDX =-NJB; STX JWRAP
INST5}"STX JCNT; STA JBUF,2
*}"CHECK FOR BLL:}"**DEPENDS ON NUMBERING OF M1 OPCODES**
}'LDA CIW; SKG =77737777B; SKG =77735777B; SKA =4B4; BRU INST7
}'SUB =57B5; SKA =76B5; BRU INST6
INST7}"LDA OLDPC; LDX JSCNT; BRX INST8
}'LDX =-NJSB; STX JSWRAP
INST8}"STX JSCNT; STA JSBUF,2
*}"CHECK FOR RING CROSSING IF WANTED
INST6}"LDA HFLAGS; SKE =0; BRU INST6A; BRU INST2
INST6A LDA* PCPTR; LDB =4B5; SKA =4B5; LDB =6B5
}'SKM OLDPC; BRU INSTB2; BRU INST2

* RUN CPU AT FULL SPEED
DOCCR}"EQU *
DOCONT LDX =-1000
DOC3}#LDA* CPWPTR; SKE =PGO; BRU DOC1; BRX DOC3
}'STX* CPWPTR; BRU INSTB3
DOC1}#C GOFIX; CLA; C SCSET; LDA =PGO; STA* CPWPTR
DOC2}#C WSHOW; SKN RUBOUT; BRU DOC0
}'LDA* CPWPTR; SKE =0; BRU DOC2
}'C RETFIX; LDA* PCPTR; SKE BRKPC; BRU INSTB1
}'LDA =1; LDB BRKPC; C DOINST; R1; BRU DOC1
DOC0}#LDA =-1; C SCSET; BRU BELL

*}"CHECK (A) FOR BEING AN INTERPRETED OPR (CIN, COUT)
*}"RETURN NOSKIP IF NOT SPECIAL
*}"RETURN WITH SKIP IF SPECIAL

CHKOP}"ZRO; SKE CINOP; BRU CK1
CK0}$MIN CHKOP; BRR CHKOP
CK1}$SKE COUTOP; BRR CHKOP; BRU CK0

*}"CALL SIMULATOR WITH (A).}"INITIALIZE FIRST IF NEEDED

CSIM}#ZRO; STA T; SKN SIMIN; BRU *+2; BRU CSIM1
}'LDA CTXBLK; ETR =777777B; BRM CLRSIM; LDA =-1; STA SIMIN
CSIM1}"LDA SRGPTR; ADD =2B7+LSTATE; STA SREGP; LDX =-LSTATE
CSIM2}"LDA* ESPTX; STA* SREGP; BRX CSIM2
}'LDA T; BRM CPUSIM; STA INSTYP; BRR CSIM

* DISPLAY SELECTED REGISTER IN LIGHTS

* CHECK WARNING REG.S AND AMC
$WSHOW LDA WARNF; SKE =0; BRU *+2; BRU WS1
}'C RDWR; SKE =0; BRM TYPSWR
WS1}$C QCHECK; BRU INSTBQ
*}"CHECK FOR MONITOR ERROR MESSAGE
SHOW1}"LDA* DTTPTR; SKE ='HELP'; BRU SHOW
}'LDA DTTPTR; ADD =1; STA DTOPTR; C TCR
}'LDA* DTOPTR; ETR =177B; STA DTOCC
SHOW2}"LDA DTOCC; SKG =0; BRU SHOW4
}'SKA =@3; LDA =3; CNA; CAX; ADM DTOCC
}'MIN DTOPTR; LDB* DTOPTR
SHOW3}"CLA; LCY 8; COUT; BRX SHOW3; BRU SHOW2
SHOW4}"C TCR; CLA; STA* DTTPTR
$SHOW}"LDA LIGHTS; SKE =0; BRU SHOW0
}'LDA =SSRDEV; UPIN; CBA
SHOW0}"C ULOAD; R1; STA* ILRPTR
}'CAB; LDA =ILRDEV; UPOT; R1


*}"OUTPUT SWR#0 INDICATION

TYPSWR ZRO; SKN ERCNT; BRU TYPS1; TMF SWRMSG; C TOUT; C TCR
}'C PRWR; MIN ERCNT; BRR TYPSWR
TYPS1}"SKN BOTH; BRU INSTBW; LDA =-1; C SCSET; BRU BELL

*}"TYPE OUT DATE AND TIME IF LATTER HAS NOT CHANGED TOO LITTLE

TOUT}#LDA _=RTIME; STA XTIME; LDB _=RTIME+1; STB XTIME+1
}'SKN XTIME; BRU TOUT1; CBA; SKG =77777700B; BRU *+2; BRU TOUT
}'LDD XTIME; ETR =17777777B; STA XTIME
TOUT1}"LCY 3; XMA XOTIME; SUB XOTIME; SKE =0; BRU *+2; BRU TOUT12
}'LDD XTIME; DIV =4320000; RSH 23; DIV =1000; STA DAYS
}'MUL =1000; LSH 23; MUL =4320000; STD XTEMP
}'LDD XTIME; LSUB XTEMP; STD LDAY
}'DIV =1800000; RSH 23; DIV =100; STA HOURS
}'MUL =100; LSH 23; MUL =1800000; STD XTEMP
}'LDD LDAY; LSUB XTEMP; STD LHOUR
}'DIV =3000000; STA MINS
}'MUL =3000000; STD XTEMP
}'LDD LHOUR; LSUB XTEMP; STD LMIN
}'DIV =50000; STA SECS
TOUT2}"SKG =59; BRU TOUT3
}'SUB =60; STA SECS; MIN MINS; BRU TOUT2
TOUT3}"LDA MINS
TOUT4}"SKG =59; BRU TOUT5
}'SUB =60; STA MINS; MIN HOURS; BRU TOUT4
TOUT5}"LDA HOURS
TOUT6}"SKG =23; BRU TOUT7
}'SUB =24; STA HOURS; MIN DAYS; BRU TOUT6
TOUT7}"LDA DAYS; ADD =1; STA DAY
}'LDA =1; STA MONTH
}'LDA =1970; STA YEAR
TOUT8}"LDA DAY; LDX MONTH; SKG /MODAYS; BRU TOUT11
}'LDA YEAR; RSH 2; CLA; LSH 2; SKE =0; BRU TOUT9
}'LDA MONTH; SKE =2; BRU TOUT9
}'LDA DAY; SKG =29; BRU TOUT11
}'SUB =1; STA DAY
TOUT9}"LDA DAY; SUB /MODAYS; STA DAY; MIN MONTH
}'LDA MONTH; SKE =13; BRU TOUT10
}'LDA =1; STA MONTH; MIN YEAR
TOUT10 BRU TOUT8
TOUT11 LDA DAYS; ADD =5; SUB =1; CLB; RSH 23; DIV =7
}'CBA; ADD =1; STA WDAY
* OUTPUT DATE AND TIME
}'LDX WDAY; LDA /DAYNAM; C PWI; CLA; COUT
}'LDX MONTH; LDA /MONAME; C PWI; CLA; COUT
}'LDA DAY; C AP10; LDA =","; COUT; CLA; COUT
}'LDA YEAR; C AP10; CLA; COUT; COUT
}'LDA HOURS; C P2DGT; LDA =":"; COUT
}'LDA MINS; C P2DGT; LDA =":"; COUT
}'LDA SECS; C P2DGT; C TCR
TOUT12 R1

P2DGT}"SKG =9; BRU P2DGT2
P2DGT1 C AP10; R1
P2DGT2 STA P2DGTA; LDA ="0"; COUT
}'LDA P2DGTA; BRU P2DGT1

LSUB}#STD LSTEMP
}'SKR PDP; MIN _PDP; EAX _PDP; EAX _/0; MIN PDP
}'LDA /0; STA MSP; CLA; LDB /1; LSH 12; STA HLSP
}'CLA; LSH 12; STA LLSP
}'LDB LSTEMP+1; CLA; LSH 12; STA LSTEMP+1; CLA; LSH 12
}'SUB LLSP; RSH 13; CLA; LSH 1; STA XCARRY; CLA; LSH 12; XMA LSTEMP+1
}'SUB HLSP; SUB XCARRY; RSH 13; CLA; LSH 1; STA XCARRY; LSH 24
}'ADD LSTEMP+1; STA LSTEMP+1
}'LDA LSTEMP; SUB MSP; SUB XCARRY; STA LSTEMP; LDB LSTEMP+1; R1


*}"FIND CURRENTLY RUNNING PROCESS.
*}"SKIP-RETURN PRT POINTER, OR NOSKIP IF CPU IDLE

FINDP}"LDA =1; C SCSET
}'LDA =3500B; STA* PRAPTR}#*** KLUDGE ***
}'LDA* PRAPTR; ETR =777777B; ADD =4B7+8; STA T; LDX =-NPRT
FP1}$LDA* T; SKA =2; BRU FP2
}'LDA =LPRTE; ADM T; BRX FP1; R1
FP2}$LDA T; SUB =4B7+8; R2


* REPLACE BROKEN INSTRUCTIONS WHEN RETURNING FROM EXECUTION

$RETFIX STX RETFX; LDA =1; C SCSET; LDX BSCNT; BRU RETF2
RETF1}"CXB; LSH 2; CBX; LDA BSLL+3,2; STA UA
}'LDA BSLL,2; LDB BSLL+1,2; LDX BSLL+2,2; C CHTS; BRU RETF3
RETF6}"CLB; LSH 11; MRG =4B7; ADM UA
RETF4}"LDA* UA; SKE BRKOP; BRU RETF5
}'LDX BSCNT; LDA BSWL+1,2; STA* UA; LDA UA; C CDIRTY
RETF5}"LDX BSCNT; BRX *+1
RETF2}"STX BSCNT; BRX RETF1; LDX RETFX; R1
RETF3}"SKN DRUM; BRU RETF5; LDB BSCNT; LSH 26
}'ADD =BSLL+4; C RPAGE; BRU RETF5; BRU RETF6

* SAVE BROKEN INSTRUCTIONS WHEN STARTING FULL-SPEED EXECUTION

$GOFIX SKN STEP; BRU *+2; R1; LDX BPCNT; LDB =-1; STB BSCNT
GOF1}#LDA BPELL,2; ADD =1; C GOF0; LDA BPEUL,2; C GOF0
}'BRX GOF1; R1

GOF0}#SKA =77B6; R1; STX GOFX; C UUSTORE; BRU GOF0A
}'LDA UA; RSH 11; ETR =177B; MUL =3 (6); CBX
}'LDB BSCNT; LSH 26; ADD =BSLL; STA T
}'LDA* CH2PT0; STA* T; MIN T
}'LDA* CH2PT1; STA* T; MIN T
}'LDA* CH2PT2; ETR =@6B7; STA* T; MIN T
}'LDA UA; ETR =3777B; STA* T; LDX BSCNT
}'LDA* UA; SKE BRKOP; BRU *+2; BRU GOF0A
}'STA BSWL,2; CXA; SUB =1; STA BSCNT
}'LDA BRKOP; STA* UA
GOF0A}"LDB BSCNT; LDX GOFX; R1


* READ SYSTEM WARNING REGISTERS.}"LEAVE UNION IN (A)

$RDWR}"LDX =-5; CLA; STA WRACC
RDWR1}"LDA EWRA,2; UPIN; CBA; STA EWRB,2
}'ETR EWRM,2; MRG WRACC; STA WRACC; BRX RDWR1; R1
* WARNING REGISTER ADDRESSES, MASKS, AND NAMES
}'DATA 1,2,3,4,5
EWRA}#EQU *
$WRMASK DATA -1,-1,-1,-1,-1
EWRM}#EQU *
}'DATA 'A','B','C','D','E'
EWRC}#EQU *

* PRINT WARNING REGISTERS (NON-ZERO ONLY)

$RPWR}"C RDWR; C TCR
$PRWR}"LDX =-5
PRWR1}"LDA EWRB,2; SKE =0; BRU *+2; BRU PRWR2
}'TCF =' '; TCF /EWRC; TCF =' '; C AP8; C TCR
PRWR2}"BRX PRWR1; R1


*}"SET 'STEP' OR 'PROCEED'

$STECON SKE =0; LDA =-1; STA STEP
$SCSET SKN BOTH; BRU SCSET1
}'LDX =-2; C SETSC; BRX *-1; R1
SCSET1 STA SCSETA; LDA CPUNO; SUB =2; CAX; LDA SCSETA
}'C SETSC; R1
SETSC}"STA SCSETA; LDB =PGO
}'SKE =0; CLB; STB* BRKENP+2,2
}'LDB CPPROT+2,2; SKE =0; LDB CPSTET+2,2
}'LDA CPDEVT+2,2; UPOT; LDA SCSETA; R1

* SELECT CPU

$SETCPU SKA =@1; BRU SETCP1; STA CPUNO
}'ADD =4B7+CPUCB; STA CBAPTR; ADD =CPUWA-CPUCB; STA CPWPTR
}'CLA; STA BOTH; R1
SETCP1 SKE =2; BRU ILL; LDA =-1; STA BOTH; R1


*}"PRINT CIRCULAR BUFFER.}"(A) = COUNT, (B) = WRAPAROUND FLAG,
*}"(X) = END OF BUFFER+2B7 (POINTS TO -LENGTH)

PBC}$STX PBADDR; SKB =4B7; BRU PBR1
*}"NO WRAPAROUND.}"COUNT = LENGTH + (A), ORIGIN =-LENGTH
}'SUB 0,2; LDB 0,2; BRU PBR2
*}"WRAPAROUND.}"COUNT = LENGTH, ORIGIN = (A)+1
PBR1}#ADD =1; SKE =0; BRU *+2; LDA 0,2
}'CAB; LDA 0,2; CNA
PBR2}#STA PBCNT; CBX; BRU PBR3
*}"LOOP TO SEQUENCE THROUGH BUFFER
PBR4}#STX PBLOC; LDA* PBADDR; C PBCR
}'LDX PBLOC; BRX *+2; LDX* PBADDR (X=0)
PBR3}#SKR PBCNT; BRU PBR4; BRU TCR
*}"SUBROUTINE TO PRINT ADDRESS AND CONTENTS
PBCR}#C TCR; LDA* PBADDR; C APT; TCF =' '
}'LDA* PBADDR; C ULOAD; R1; BRU PI


*}"PRINT JUMP, SUBROUTINE BUFFERS

$PJB}#LDA JCNT; LDB JWRAP; LDX JBA; BRU PBC
$PJSB}"LDA JSCNT; LDB JSWRAP; LDX JSBA; BRU PBC


* CLEAR JUMP BUFFERS

$CJB}#CLA; STA JWRAP; STA JSWRAP
}'LDX JBUF; STX JCNT; LDX JSBUF; STX JSCNT; R1


* PRINT BLOCK OF REGISTERS IN VARYING FORMATS

$PREGS STA T
PREG1}"LDX T; LDA* 0,2; C _/1
}'LDX T; LDA 2,2; C PWD
}'LDA =3; ADM T; LDA* T; SKE =-1; BRU PREG1; R1


*}"RECONSTRUCT MAP FROM CHT, PMT, AND MAP IN CONTEXT BLOCK

$RMAP}"LDA =127; STA RMAPI
RMAP1}"LDX RMAPI; LDA =4B7; STA UMAP,2
}'CXA; C GMB; SKG =0; BRU RMAP2
}'LDX RMAPI; LDB =6B7; STB UMAP,2
}'C GMS; BRU RMAP2; C RMS; BRU RMAP2
}'CLB; LSH 11; LDX RMAPI; STA UMAP,2
RMAP2}"SKR RMAPI; BRU RMAP1; R1

GMB}$RSH 1; CAX; LDA* MAPPTR
}'SKB =4B7; LSH 12; LRSH 12; ETR =377B; R1
$GME}#C GMB; SKG =0; R1
GMS}$SUB =1; CLB; LSH 2; CAX
}'LDA* PMTPT3; SKA =4B3; BRU GME1; R1 (CHECK SF BIT)
GME1}#CXA; ADD PMTPT0; SUB =2B7; R2

$RME}#C GME; R1
RMS}$LDA* PMTPT0; LDB* PMTPT1; LDX* PMTPT2; BRU CHTS


*}"PRINT STACK

$STKTR SKN SYL; BRU STK2; LDA* LRPTR; LDB* PCPTR; BRU STK3
STK2}#ETR =777777B; CAB
STK3}#STA STKTP; STB STKTB
STK1}#C TCR; LDA STKTP; LDB =434B5; SKA =4B5; LDB =436B5
}'SKA =777777B; SKM STKTB; R1; C PSA
}'TCF =':'; TCF =' '; LDA STKTP; C ULOAD; BRU ILL
}'C APT; TCF =' '; LDA STKTP; ADD =1; C ULOAD; BRU ILL
}'STA STKTP; C APT; BRU STK1


*}"SELECT OR DESELECT INTERPRETED INSTRUCTION

$DXPLS C IIBA; EOR =-1; ETR 0,2; STA 0,2; R1
$DXMNS C IIBA; MRG 0,2; STA 0,2; R1

IIBA}#SKA =70077777B; BRU IIBA1; LRSH 15; BRU IIBA2
IIBA1}"SKG =77734000B+MAXOPR; SKG =77734000B-1; BRU IIBA3
}'SUB =77734000B-[OPRNG-OPCNG]*20B
IIBA2}"LRSH 4; STA T; CLA; LCY 4; CAX
}'LDA =4B7; LRSH 0,2; LDX T; EAX OPCNG,2; R1
IIBA3}"LDX =OPXNG; SKE =4B4; BRU IIBA4; LDA =4B7; R1
IIBA4}"SKE UCALOP; BRU IIBA5; LDA =2B7; R1
IIBA5}"SKE MCALOP; BRU ILL; LDA =1B7; R1

*}"DESELECT ALL

$DXZNG C TOK; CLA; LDX =OPNG-OPNGE
}'STA OPNGE,2; BRX *-1; R1

*}"LIST

$DXLNG LDA OPXNG; SKA =4B7; TMF NGM0
}'LDA OPXNG; SKA =2B7; TMF NGM1
}'LDA OPXNG; SKA =1B7; TMF NGM2
}'CLA; STA LNGN; LDA =100B+MAXOPR; STA LNGI
LNG1}#LDA LNGI; LRSH 4; CAX; LDX OPNG,2
}'CLA; LSH 4; XXA; LCY 0,2; SKA =4B7; C LNGOUT
}'SKR LNGI; BRU LNG1; C TCR; R1
NGM0}#ASC ' POP/'
NGM1}#ASC ' UCALL/'
NGM2}#ASC ' MCALL/'

LNGOUT SKR LNGN; BRU LNGO1; C TCR; LDA =9; STA LNGN
LNGO1}"TCF =' '; LDA LNGI; ADD LNGI; ADD LNGI
}'CAX; EAX OPCODE,2; BRU PSY


*}"LIST MAP

$PMAP}"SKN SYL; BRU PMAP0; CLA; STA RMAPI; C TCR
PMAP1}"LDX RMAPI; CXA; ETR =17B; EOR =17B; STA T
PMAP2}"LDA UMAP,2; SKE =4B7; BRU PMAP3
}'EAX 1,2; SKR T; BRU PMAP2
}'LDA =' ...'; C PWD
}'LDA RMAPI; MRG =17B; STA RMAPI; BRU PMAP4
PMAP3}"TCF =' '; LDX RMAPI; LDA UMAP,2; RSH 11
}'SKG =77B; TCF =' '; SKG =7; TCF =' '
}'SKG =-1; BRU PMAP5; C AP8
PMAP4}"MIN RMAPI; LDA RMAPI; SKA =17B; BRU PMAP1
}'C TCR; SKE =128; BRU PMAP1; R1
PMAP5}"EAX ='-'; SKE =-1B4; EAX ='*'; TCF /0; BRU PMAP4

PMAP0}"C ULOAD; BRU ILL; C TTB
}'LDA UA; SKA =4B7; MRG =2B7; C AP8; BRU TR


*}"SET AUTO BP ADDRESS

$SETABP ETR =3777B; STA AUTOBP; CAB
}'LDA =BPDEV; UPOT; R1

*}"SET PROCESSOR NUMBER

$SETPRN SKG =3; SKG =0; BRU ILL; STA PROCNO
}'ADD =WAITO; MRG =4B7; STA PRWPTR
}'ADD =BRKAO-WAITO+2B7; LDX SO; STA O:V,2
}'LDX PROCNO; LDA SAVTAB,2; MRG =6B7; LDX SO; STA M:V,2
}'STA SK:V,2; LDX PROCNO; ADD LSKTAB,2
}'LDX SO; STA R:V,2; ADD =7; STA OS:V,2
}'ADD =1; STA Q:V,2; ADD =1; STA Z:V,2; R1


*}"RESTART BROKEN PROCESSOR

$DXP}#LDA AUTOBP
$DXPP}"C SETABP; C TCR
}'LDA =PGO; STA* PRWPTR; LDX =-1000; CLA
}'SKE* PRWPTR; BRX *-1; SKE* PRWPTR; BRU DXP1
}'LDX SO; LDX O:V,2; LDA 0,6; C AP8; R1
DXP1}#TMF DXPM; R1
DXPM}#ASC 'RAN TOO LONG/'


*}"ZAP PROCESSOR N

$ZAPIT SKG =4; SKG =0; BRU ILL; CAX; C TOK
}'LDA =ZMDEV; LDB ZMBT,2; UPOT; R1

* MAIN-TO-PRIVATE, PRIVATE-TO-MAIN COPY

$PMCOPY C COPYS
PMC0}#LDA* PMPTR; STA* MMPTR; BRX PMC0; R1

$MPCOPY C COPYS; C TOK
MPC0}#LDA* MMPTR; STA* PMPTR; BRX MPC0; R1

* SET UP FOR MEMORY-TO-MEMORY TRANSFER
COPYS}"SKN SVF; BRU COPYS1; SKG =3; SKG =0; BRU ILL
* NO ADDRESSES.}"SAVE OR RESTORE PROCESSOR SCRATCHPAD AREA
}'CAX; LDA SKSAVE,2; ADD =2B7+120B; STA PMPTR
}'LDA SAVTAB,2; ADD =6B7+120B; STA MMPTR; LDX =-120B; R1
* ADDRESSES GIVEN.}"CHECK LEGALITY
COPYS1 SKN ARI; BRU *+2; BRU ILL
}'XMA ARG; ETR =777777B; STA MMPTR
}'LDA ARG; ETR =777777B; ADD =1; SUB MMPTR
}'SKG =0; BRU ILL; CNA; CAX; CNA
}'MRG =6B7; ADM MMPTR; EOR =4B7; STA PMPTR
* CHECK ITP ADDRESSES AGAINST SMASHING SYSDDT
}'SUB =2B7; ADD SVAL; C COPYC; LDA SVAL; C COPYC
}'LDA SVAL; ADM PMPTR; R1

* CHECK ONE ITP ADDRESS
COPYC}"SKG =37777B; SKG =237B; BRU ILL; SKG =7777B; R1
}'SUB SO; ADD SYMTAB; SKG =10B; BRU ILL; R1



****************
* APU ROUTINES *
****************


* PARAMETERS
NQBP}#EQU 16}"NUMBER OF APU BREAKPOINTS
QMGO}#EQU 662B}"MICROCODE 'GO' ADDRESS FOR APU
QBKPT}"EQU 04700045B}"APU BREAK INSTRUCTION
QBAA}#EQU 157B}"APU BASE ADDRESS CELL

* STORAGE
QBPA}#BES NQBP}"APU BREAKPOINT ADDRESSES
QBPW}#BES NQBP}"APU BREAKPOINT WORDS
QBAP}#ZRO QBAA,4}"POINTER TO APU BASE
QUA}$BSS 1}#POINTER FROM QLOAD
QA1}$BSS 1}#APU LOWER LIMIT
QA2}$BSS 1}#APU UPPER LIMIT
QPCP}#ZRO 2503B,4}"POINTER TO APU PC,
QARP}#ZRO 2505B,4}$AR,
QBRP}#ZRO 2506B,4}$BR,
QXRP}#ZRO 2507B,4}$XR
QWAP}#ZRO WAITO+1,4}"POINTER TO AMC WAIT CELL
QADRP}"ZRO BRKAO+1,4}"POINTER TO AMC O-REG. CELL
APUFLG BSS 1}#<0 IF APU COMMANDS OK
QPO}$BSS 1}#CURRENT ORIGIN OF APU PATCH SPACE


* CLEAR APU BREAKPOINT MACHINERY

$QBPCLR LDX =-NQBP; LDA =-1; LDB =QBKPT
QZAP1}"STA QBPA,2; STB QBPW,2; BRX QZAP1
}'CLA; STA APUFLG; STA QPO; R1

* CLEAN UP HANGING BREAKPOINTS

QCLEAN LDX =-NQBP; C QFIX; BRX *-1; R1

QFIX}#LDA QBPA,2; SKG =-1; R1
}'C QLOAD; SKE =QBKPT; R1
}'XMA QBPW,2; STA* QUA; R1

* CLEAR APU BREAKPOINT(S)

$QQC}#C QBPOK; BRU QCLEAN; LDX =-NQBP
QQC1}#LDA QBPA,2; ADD =1; SKG QA1; BRU QQC2
}'LDA QA2; ADD =1; SKG QBPA,2; BRU QQC2
}'C QFIX; LDA =-1; STA QBPA,2
QQC2}#BRX QQC1; R1

* CHECK IF APU OPERATION OK

QOK}$SKN APUFLG; BRU QNOK; R1
QNOK}#TMF QNOKM; BRU ILL
QNOKM}"ASC '-APU MODE/'
QBPOK}"STA QA2; SKN ARI; LDA ARG; STA QA1; C QOK
}'SKN SYL; BRU *+2; R1
}'LDA QA2; ADD =1; SKG =4B4; SKG QA1; BRU ILL
}'LDA QA1; SKG =-1; BRU ILL; R2

* SET APU BREAKPOINT(S)

$QQS}#C QBPOK; BRU ILL
QQS1}#LDA QA1; C QFB; BRU QQS2
QQS3}#MIN QA1; LDA QA1; SKG QA2; BRU QQS1; R1
QQS2}#LDA =-1; C QFB; BRU QFULL
}'LDA QA1; STA QBPA,2; BRU QQS3
QFULL}"C PFULL; BRU ILL

QFB}$LDX =-NQBP
QFB1}#SKE QBPA,2; BRU QFB2; R2
QFB2}#BRX QFB1; R1

* LIST APU BREAKPOINTS

$QQD}#C QOK; C TCR; LDX =-NQBP
QQD1}#LDA QBPA,2; SKG =-1; BRU QQD2; STX QA1
}'C TTB; C PSA; LDX QA1
QQD2}#BRX QQD1; R1

* SET UP TO LOOK AT APU

$QQV}#LDB CC; SKB =-1; BRU QQV1; LDA APUFLG; BRU STV
QQV1}#SKN SYL; SKE =0; LDA =-1; STA APUFLG
}'SKE =-1; R1; LDA =1; SKG QPO; BRU QSET
}'C QFPS; BRU ILL; STA QPO
QSET}#LDA* QBAP; MRG =6B7; STA ITPREL
}'LDA =-1; STA ITPFLG; LDA =1; BRU SETPRN

* SET ITP PATCH ORIGIN

$QQF}#NOP QPO; LDB CC; SKB =-1; SKE =-1; BRU INTERN
}'C QFPS; BRU ILL; STA QPO; R1

* WAIT FOR AMC TO STOP, PRINT STATE

QWAIT}"C SHOW; SKN RUBOUT; BRU BELL
}'LDA* QWAP; SKE =0; BRU QWAIT; BRU QCLEAN

$QQH}#C QOK
QHOLD}"C TCR; C QWAIT
QPCC}#LDA* QPCP; STA QA1; C QFB; BRU QPCC1
}'TMF QBM; BRU QPCC2
QPCC1}"TMF QPM
QPCC2}"C PSA; TCF =':'; TCF =' '; C QSET
}'LDA QA1; STA LRO; C QLOAD; C PI
}'LDA ='}"A='; C PWD; LDA =QREGS; C PREGS; R1
QBM}$ASC 'APU BREAK AT /'
QPM}$ASC 'APU PUNT AT /'
QREGS}"EQU *
}'ZRO* QARP; DATA AP8,'}"B='
}'ZRO* QBRP; DATA AP8,'}"X='
}'ZRO* QXRP; DATA AP8,0
}'DATA -1

* LOAD FROM APU LOCATION

QLOAD}"ADD* QBAP; MRG =4B7; ETR =40777777B; STA QUA
}'LDA* QUA; R1

* START APU

$QQPP}"C QQS; BRU QQP0
$QQP}#C QOK; SKN SYL; BRU ILL
QQP0}#LDA =QMGO; BRU QQG0
$QQG}#C QOK; SKN SYL; SKA =-4B4; BRU ILL
QQG0}#STA* QADRP; LDX =-NQBP
QQG1}#LDA QBPA,2; SKG =-1; BRU QQG2
}'C QLOAD; SKE =QBKPT; BRU *+2; BRU QQG2
}'STA QBPW,2; LDA =QBKPT; STA* QUA
QQG2}#BRX QQG1; LDA* QPCP; STA QA1; C QFB; BRU QQG3
* PROCEEDING THROUGH BREAKPOINT.}"MOVE INSTRUCTION TO PATCH AREA
}'C QLOAD; STA WORD; LDA QPO; SKE =0; BRU QQG2A
}'C QFPS; BRU ILL; STA QPO
QQG2A}"LDA QPO; STA QA2; C QLOAD; LDA WORD; STA* QUA
}'LDA QA1; MRG =1B5 (BRU); LDX =-7
QQG4}#ADD =1; MIN QUA; STA* QUA; BRX QQG4
* ALLOCATE PATCH PERMANENTLY IF INSTRUCTION IS MESSY
}'LDA WORD; ETR =77B5; SKE =13B5 (BRM); BRU *+2; BRU QQG5
}'ETR =76B5; SKE =66B5 (BSL,BSX); BRU QQG3
QQG5}#LDA =8; ADM QPO
QQG3}#LDA =1; STA* QWAP; BRU QHOLD

* FIND APU PATCH SPACE (ALGORITHM BY RRVT)

QFPS}#LDA =2000B-1; STA QA1; LDA =100B; STA QA2
QFPS1}"MIN QA1; LDA =10000B; SKG QA1; BRU ILL
}'LDA QA1; C QLOAD; LDB =100B; SKE =0; STB QA2
}'SKR QA2; BRU QFPS1; LDA QA1; SUB =77B; R2

* CHECK FOR APU BREAK OR PUNT

QCHECK LDA* QWAP; SKE =0; R2; C QCLEAN; BRU QPCC

}'END
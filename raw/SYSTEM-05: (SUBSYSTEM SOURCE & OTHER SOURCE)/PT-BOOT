* M1 PAPER TAPE BOOTSTRAP PROGRAM -- LOADED IN THE FIRST 100B WORDS
*}#OF LOCAL CORE ADDRESS SPACE (ACTUALLY AT 10000B OF LOCAL CORE)
*}#BY BOOTSTRAP ROM.}"THIS PGM READS IN A FOLLOWING PROGRAM INTO
*}#THE M1 AND THEN RELINQUISHES CONTROL TO IT.}"THIS PGM IS
*}#ORIGINED AT 0.

PTBOOT IDENT


*}&ORG 0B}2LOCATE AT 0 REL

WCOUNT DATA 0
ADRPTR DATA 0}2PTR FOR STORING INTO LOCAL CORE
ASSY}#DATA 0}2FOR ASSEMBLING A WORD
START}"CLB}5INITIALIZE PGM
}'CLX
}'LDA ONE}1SET UP FOR PAPER TAPE READER
}'XIOA}4ARM INTERRPUT FOR PT READER 
*}>(PT RDR IS STILL RUNNING FROM UCODE)
}'BRU MLOOP
IOPTR}"DATA 44B6+TEMPC})BITS 0 & 3 SAY NO INCREMENT & INTERRUPT

* HERE BEGINS THE MAIN LOOP OF THE BOOTSTRAP LOADER.}"IT USES LCN 0
*}#(WCOUNT) AS A COUNTER FOR A BLOCK TO BE LOADED & LCN 1 (ADRPTR)
*}#AS THE STORE ADDRESS.}"BY CLEARING THIS CELL, IT STARTS LOADING
*}#ANY BLOCK AT 0.}"BUT THE BLOCK FIRST CONTAINS THE COUNT OF THE
*}#FOLLOWING NO OF WORDS, FOLLOWED BY THE STARTING ADDRESS (-1).
*}"THUS AFTER STORES IN 0 & 1, ADRPTR IS MODIFIED TO ELSEWHERE.
*}#WHEN THE COUNT IS EXHAUSTED, THE PGM EXPECTS TO SEE A CHECKSUM
*}#AT THE END OF THE BLOCK, AFTER WHICH A NEW BLOCK MAY BEGIN.
* IF THE COUNT (FIRST WORD) OF THE NEXT BLOCK IS ZERO OR NEGATIVE,
*}#THE PROGRAM TERMINATES BY BRANCHING TO NEXTPG.

MLOOP}"STB CKSUM}/START LOADING THE BLOCK
}'STB ADRPTR}.CLEAR PTR TO SET UP FOR WORD COUNT IN 0
}'BRM GETW}0GET 4 CHARACTERS ASSEMBLED INTO A WORD
}'SKG ZERO}0CHECK FOR END OF PROGRAM (<= 0)
}'BRU NEXTPG}.ESCAPE TO NEXT PROGRAM (JUST READ IN)
S2}%STA _ADRPTR}-STORE WORD IN CORE
}'MIN ADRPTR
}'BRM GETW
}'SKR WCOUNT}.TEST FOR END OF BLOCK
}'BRU S2}2NOT DONE: LOOP BACK
}'CLA}5DONE: CHECK TO MAKE SURE CHECKSUM IS 0
}'SKE CKSUM
}'BRM STOP}"(BRU CMSG)}$IT ISN'T...ERROR.
}'BRU MLOOP (BRU P2LOOP)}"IT IS.}"START LOADING NEW BLOCK.

* SUBROUTINE TO ASSEMBLE FOUR 6-BIT CHARACTERS INTO A 24-BIT WORD.
*}#FUNCTIONS IN CONJUNCTION WITH THE INTERRUPT ROUTINE.}"IT ONLY
*}#REALLY INITIALIZES CCOUNT & THEN LOOPS.}"THE INTERRUPT ROUTINE
*}#EXITS BACK TO THIS ROUTINE (& CONTINUES LOOPING) IF CCOUNT IS NOT
*}#EXHAUSTED.}"OTHERWISE IT RETURNS THROUGH THE LINK OF THIS ROUTINE.

GETW}#ZRO
}'EAX 3}3INITIALIZE CCOUNT TO 3.
}'STX CCOUNT
}'BRU *}3WAIT.

* ERROR SUBROUTINE.}"STOPS THE PAPER TAPE READER & LOOPS.

STOP}#ZRO
}'LDB IOINT}/COUTAINS DATA TO HALT THE READER.
}'LDA PTRDR}/DEVICE ADDRESS.
}'POT
}'BRU *}%(BRR STOP)

IOINT}"DATA 2}2THIS VALUE HALTS THE PAPER TAPE READER.
BAD}$DATA 3B7}0BIT 1: RATE ERROR.}"BIT 2: NOT ON (SICK)
}'DATA IOINTR}-THIS LCN ADDRESSED BY PAPER TAPE INTERRUPT.

* PAPER TAPE INTERRUPT ROUTINE.}"COOPERATES WITH GETW (SEE ABOVE).
*}#GETS THE RAW INCOMING DATA.}"CHECKS FOR READER ERRORS.}"IGNORES
*}#CHARACTER COMPLETELY IF BIT 17 IS SET.}"COMPUTES PARITY & CHECKS
*}#AGAINST BIT 16.}"PLACES BITS 18-23 INTO ASSY ALONG WITH ANY
*}#PREVIOUS 6-BIT BYTES COLLECTED UNTIL CCOUNT IS EXHAUSTED.
*}"EXITS WITH ASSEMBLLD WORD IN A AND ALSO IN CKSUM.

IOINTR ZRO
}'LDA TEMPC}/GET NEW READER INPUT.
}'SKA BAD}1TEST FOR ANY READER ERRORS.
}'BRM STOP}"(BRU SMSG)
}'CLX}5PREPARE FOR COUNT OF ONE BITS.
IOI1}#SKA ONE}1TEST LEAST SIGNIFICANT BIT.
}'EAX 1,2}1COUNT IN X IF SET.
}'LRSH 1}2RIGHT SHIFT ONE PLACE.
}'SKE ZERO}0SEE IF WE ARE DONE (A IS COPIED INTO B)
}'BRU IOI1}0NO.}"LOOP BACK.
}'XXA}5YES.}"SEE IF COUNT IS ODD.
}'SKA ONE
}'BRM STOP}"(BRU PMSG)}$IT IS EVEN.}"WE ARE IN TROUBLE.
}'LSH 18}2GET BIT 17 INTO LOW END OF A.
}'SKA ONE}1TEST TO SEE IF THE CHARACTER IS TO BE SKIPPED.
}'BRU _IOINTR}-SKIP IT.
}'LDA ASSY}0ASSEMBLE IT WITH OTHERS.
}'LSH 6
}'STA ASSY
}'SKR CCOUNT}.TEST TO SEE IF WE HAVE ASSEMBLED 4 CHRS.
}'BRU _IOINTR}-NO.}"KEEP ASSEMBLING.
}'ADM CKSUM}/YES.}"FORM CHECKSUM.
}'BRR GETW

PTRDR}"DATA 4B7+1
ZERO}#DATA 0
ONE}$DATA 1
TEMPC}"DATA 0
CKSUM}"DATA 0
CCOUNT DATA 0

* THE SECOND PHASE OF THIS PROGRAM FOLLOWS IT ON THE TAPE.}"IT CONSISTS
*}#OF MORE CODE PLUS SOME MODIFICATIONS TO THE FIRST CODE TO MAKE IT
*}#A SMARTER & BETTER LOADER.

MSG}$MACRO D
X}&NCHR "D(1)"
}'DATA 3B7+*+1
}'RPT (Y=1,X-2)
}'DATA ["D(1$Y)"+240B]&377B
}'ENDR
}'DATA 3B7+*+1
}'ENDM

MOD1}#BRM STOP
MOD2}#BRR STOP
MOD3}#BRU SMSG
MOD4}#BRU CMSG
MOD5}#BRU PMSG
MOD6}#BRU P2LOOP
TTY}$DATA 4}2CONSTANT TO ENABLE TTY DEVICE
HUNDRD DATA 100
STINST STA /0}2CONSTANT FOR SETTING UP STORE INSTRUCTION
ADMASK DATA 37777B}-ADDRESS FIELD MASK
MODIFY LDA MOD4
}'STA S2+7}0REPLACE 'BRM STOP' WITH 'BRU CMSG'
}'LDA MOD3
}'STA IOINTR+3},REPLACE 'BRM STOP' WITH 'BRU SMSG'
}'LDA MOD5
}'STA IOI1+7}.REPLACE 'BRM STOP' WITH 'BRU PMSG'
}'LDA MOD2
}'STA STOP+4}.REPLACE 'BRU *' WITH 'BRR STOP'
}'LDA MOD1
}'STA NEXTPG+3},REPLACE 'NOP' WITH 'BRM STOP'
}'LDA MOD6
}'STA S2+8}0REPLACE 'BRU MLOOP' WITH 'BRU P2LOOP'
}'BRU START}/BEGIN MORE LOADING, THIS TIME W/ PHASE 2

NEXTPG CAX}5A CONTAINS NEW XFER ADDRESS+4B7
}'CLA
}'XIOA}4STOP INPUT MOMENTARILY
}'NOP 0}%(BRM STOP)}$THIS IS LATER CHANGED TO 'BRM STOP'
}'BRU /0}2DISPATCH.

ZILCH}"BSS 1

P2LOOP LDA ADRPTR
}'STA ZILCH
}'STB ADRPTR
}'BRM GETW
}'SKG ZERO
}'BRU NEXTPG
}'STA _ADRPTR
}'MIN ADRPTR
}'BRM GETW
}'SKR WCOUNT
}'BRU *+2
}'BRU S2+5
}'ADD ONE
}'STA _ADRPTR
}'MRG STINST
}'STA STLOCN
}'ETR ADMASK
}'SUB ZILCH
}'STA ZILCH
}'SKG HUNDRD
}'BRU *+2
}'BRM STOP
}'LDA ZILCH
}'CNA
}'CAX
}'CLA
STLOCN BSS 1}3WILL HOLD A COMPUTED INDEXED STORE
}'BRX *-1
}'LDA PTRDR}/START UP READER AGAIN
}'LDB ONE
}'POT
}'CLB
}'BRU S2+2}0RESUME LOADING
CMSG}#LDA CMCHRS}.OUTPUT "CHECK SUM ERROR"
PUNT}#STA IOPTR+2}-FOR OUTPUT ON THE TTY
}'LDA TTY
}'XIOA}4STARTS TTY
}'BRM STOP
}'BRU *}3DIES HERE
PMSG}#LDA PMCHRS}.OUTPUT "PARITY ERROR"
}'BRU PUNT
SMSG}#LDA SMCHRS}.OUTPUT "SICK SICK SICK"
}'BRU PUNT

CMCHRS MSG (CHECK SUM ERROR)
PMCHRS MSG (PARITY ERROR)
SMCHRS MSG (SICK SICK SICK)

}'END

IPLBOOT IDENT

* PROGRAM TO READ IN AN IPL DUMP TAPE INTO LOCAL CORE OF THE CTP.
*}#THIS PROGRAM IS PUNCHED ON PAPER TAPE IMMEDIATELY FOLLOWING
*}#THE BOOTSTRAP LOADER.

* THIS PROGRAM IS TO BE POSITIONED AS HIGH IN LOCAL CORE AS POSSIBLE,
*}#BUT ITS STARTING ADDRESS ON THE PAPER TAPE IS PUNCHED 10000B SMALLER
*}#DUE TO THE CONTENTS OF REL AT THE TIME THE PROGRAM BEGINS.

MSG}$MACRO D
X}&NCHR "D(1)"
}'DATA 3B7+*+1
}'RPT (Y=1,X-2)
}'DATA ["D(1$Y)"+240B]&377B
}'ENDR
}'DATA 3B7+*+1
}'ENDM

IOPTR}"EQU 10B


START}"XJ REL-10000B}+1ST 2 INSTS ARE EXECUTED WITH OLD REL
}'BRU *+1}1THIS ADJUSTS NEW REL TO BE 0 IN LOCAL CORE

}'LDA =103B}/ENABLE XMIT & RCV INTERRUPTS FOR HP
}'LDB =3400B
}'POT

}'LDA =4B7+10B},DO AN HP RESET
}'LDB =4
}'POT

}'LDX =-4}1SEND RESTART & SET MODES ON HP
}'LDA =HPSTRT+4
}'BRM SEND

}'BRM RECV}0CHECK RESPONSE
}'ETR =177B}/SAVE 7-BIT BYTE
}'SKE =167B}/MUST BE 'WRITE OK' RESPONSE
}'BRU *+2}1ELSE PUNT
}'BRU MLOOP0
}'LDA RSMSG}/TYPE OUT RESTART HP FAILED
}'BRU PUNT


* BEGIN MAIN LOOP WHICH RESULTS IN LOADING 8 PAGES INTO LOCAL CORE.

MLOOP0 CLA}5INITIALIZE MAIN LOOP: CLEAR ADDRESS PTR
}'STA ADRPTR
}'LDA =8}2SET PAGE COUNTER TO 8
}'STA PGCNT
MLOOP}"SKR PGCNT}/DECREMENT PAGE COUNT: SKIP WHEN DONE
}'BRU MLOOP1

}'LDX =-4}1TELL HP TO BACKSPACE 10 RECORDS
}'LDA =HPBACK+4
}'BRM SEND

}'BRM RECV}0CHECK RESPONSE
}'ETR =177B
}'SKE =167B}/MUST BE 'WRITE OK'
}'BRU *+2}1ELSE PUNT
}'BRU _GOLCN}.BRANCH TO LOADED SOFTWARE
}'LDA BMSG}0TYPE OUT BACKSPACE FAILED
}'BRU PUNT

MLOOP1 LDX =-5}1TELL HP TO READ ONE RECORD
}'LDA =HPGO+5
}'BRM SEND

MLOOP2 BRM RDWRD}/ASSEMBLE A WORD FROM THE HP
}'CAB
}'LDA ADRPTR}.CHECK FOR ADDRESS IN BOUNDS
}'SKG =START
}'SKG =-1
}'BRU MLOOP2}.BYPASS STORING IF OUT OF BOUNDS
}'STB _ADRPTR}-STORE WORD IN LOCAL CORE
}'MIN ADRPTR}.ADVANCE ADDRESS POINTER
}'BRU MLOOP2


* SUBROUTINE TO SEND A LIST OF COMMANDS AND PARAMETERS TO HP

SEND}#ZRO
}'ETR =37777B}-PUT END OF LIST ADDR INTO LDB INSTRUCTION
}'XMA SEND2
}'ETR =@37777B},STRIP OLD LDB INST
}'MRG SEND2
}'STA SEND2

SEND1}"LDA =2B7+20B},ADDRESS SCANNER
}'PIN
}'SKB =200B}/WAIT FOR XMIT REQUEST
}'BRU *+2
}'BRU SEND1

}'LDA =103B}/SEND ONE LIST ITEM
SEND2}"LDB /0}2ADDRESS SUPPLIED ABOVE
}'POT
}'BRX SEND1

}'BRR SEND


* SUBROUTINE TO RECEIVE A BYTE FROM THE HP

RECV}#ZRO
RECV1}"LDA =2B7+20B},ADDRESS SCANNER
}'PIN
}'SKB =400B}/WAIT FOR RECV REQUEST
}'BRU *+2
}'BRU RECV1

}'LDA =2B7+303B}+READ SCANNER
}'PIN
}'CBA}5PUT BYTE IN A FOR RETURN

}'BRR RECV


* SUBROUTINE TO ASSEMBLE A DATA WORD FROM THE HP.

RDWRD}"ZRO
}'LDX =-4}1SET UP FOR 4 BYTES (SIX BITS EACH)
}'CLB
RD1}$LSH 6
}'STA ASSY}0FOR ASSEMBLY OF THE WORD

}'BRM RECV}0GET BYTE
}'LDB =300B
}'SKM =300B}/TEST FOR DATA BYTE
}'BRU RD2}1IF NOT A DATA BYTE
}'ETR =77B}0GET 6 DATA BITS
}'MRG ASSY
}'BRX RD1}1GET NEXT CHARACTER IF NOT DONE

}'BRR RDWRD}/RETURN

RD2}$ETR =177B}/TEST FOR 'READ OK' RESPONSE
}'SKE =176B}/IF OK
}'BRU RD3}1ELSE PUNT
}'BRM RDWRD}/GET NEXT WORD
}'SKE =14B5}/MUST BE THIS QTY
}'BRU *+2}1ELSE PUNT
}'BRU MLOOP}/OK TO TRY NEXT PAGE
}'LDA IMSG}0TYPE OUT NOT IPL FORMAT
}'BRU PUNT

RD3}$LDA RMSG}0TYPE OUT READ FAILED
PUNT}#STA IOPTR+2}-SET UP OUTPUT BUFFER IN I/O CTL WORD
}'LDA =4}2TTY I/O INTERRUPT ENABLE
}'XIOA
}'BRU *}3PROGRAM DIES HERE


GOLCN}"DATA 4}2LOCATION IN WHICH TO START LOADED SOFTWARE
HPBACK DATA 4213B,4301B,4310B,4304B TAPE CTL, UNIT, NO TINES, BACKSPACE
HPGO}#DATA 4210B,4301B,4301B,4340B,4300B READ, UNIT 1, 2048 WORDS
HPSTRT DATA 4276B,4204B,4301B,4360B RESTART & SET MODES
PGCNT}"BSS 1
REL}$DATA 2B6}0NEW REL IS 0 IN LOCAL CORE
ADRPTR BSS 1
ASSY}#BSS 1
BMSG}#MSG (BACKSPACE)
IMSG}#MSG (NOT IPL)
RMSG}#MSG (BAD READ)
RSMSG}"MSG (RESTART)

}'END
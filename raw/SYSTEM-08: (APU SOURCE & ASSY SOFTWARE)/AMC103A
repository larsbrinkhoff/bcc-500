AMCCD}"IDENT;






*}"TRANSFER VECTOR CODES FOR SWAPPER

*}9REQUEST}#STARTUP}#CLEANUP
*READ PROCESS}01;
*}&CONTEXT BLOCK}31})1
*}&PAGE READ}72})2

*WRITE PROCESS}/3,1;
*}&PAGE DIRTY}@7
*}&PAGE CLEAN}@6

*DIRECT DRUM}14})4})4;

*DIRECT DISK}15})5})5;

*RESERVE PAGE}09;

*NEW PAGE}H9;

*WRITE PAGE, PAGE DIRTY}%10}37;
*WRITE PAGE, PAGE CLEAN}%10}36;

*DRUM TO DISK TSFR}*11;
*}&DRUM READ}73})3
*}&CHECK UN ON DISK}/11}(11
*}&WRITE ON DISK}210}(10

*WRITE UNIQUE NAME}*12;
*}&CHECK UN}712}(12
*}&WRITE}:14}(14

*DISK TO DRUM TSFR}*13;
*}&READ DISK}613}(13
*}&READ DRUM}617}(17

*GET FREE PAGE}.14;

*DESTROY PAGE}/15;
*}&CHECK UN ON DISK}/15}(15
*}&DESTROY ON DISK}016}(16
*}&CHECK ON DRUM}38})8

*}&READ PAGE KLUDGE}%18}(18}(18

*}"SEEK COMMAND}A19


*CWRPR}#EQU 3 WRITE PROCESS ONTO DRUM REQUEST;
*CWRPG}#EQU 10 WRITE PAGE ONTO DRUM REQUEST;
*CRDK}$EQU 11 REQUEST DRUM TO DISK TRANSFER;
$CDSDK}#EQU 3;* DRUM START FOR DRUM TO DISK TRANSFER &
*}/DRUM CLEANUP FOR DRUM TO DISK TRANSFER
CKSDKU}#EQU 11;* DISK STARTUP FOR UN=0 CHECK ON DRUM-DISK TRANSFER &
*}/DISK CLEANUP FOR UN=0 CHECK ON DRUM-DISK TRANSFER
$CKSDK}#EQU 10;* DISK STARTUP FOR DRUM-DISK TRANSFER (WRITE)
*}/DISK CLEANUP FOR DRUM-DISK TRANSFER (WRITE)
*CRWUN}#EQU 12 REQUEST TO WRITE UNIQUE NAME;
*CKSWU}#EQU 12 DISK START FOR WRITE UNIQUE NAME (UN = 0);
*}/DISK CLEANUP FOR WRITE UNIQUE NAME (UN = 0)
$CKSWU0}"EQU 14;* DISK START FOR WRITE UNIQUE NAME
*}/DISK CLEANUP FOR WRITE UNIQUE NAME
*CRKD}$EQU 13 REQUEST FOR DISK-DRUM TRANSFER;
CDSKD}$EQU 17;* DRUM START FOR DISK-DRUM TRANSFER
*}/DRUM CLEANUP FOR DISK-DRUM TRANSFER
$CKSKD}#EQU 13;* DISK START FOR DISK-DRUM TRANSFER
*}/DISK CLEANUP FOR DISK-DRUM TRANSFER
CRDDT}$EQU 4;* REQUEST FOR DIRECT DRUM TRANSFER
*CDSDDT}"EQU 4 DRUM START FOR DIRECT DRUM TRANSFER;
*}/DRUM CLEANUP FOR DIRECT DRUM TRANSFER
*CRDKI}#EQU 5 REQUEST FOR DIRECT DISK TRANSFER;
*CKSDKI}"EQU 5}"DISK START FOR DIRECT DISK TRANSFER;
*}/DISK CLEANUP FOR DIRECT DISK TRANSFER
CRRDP}$EQU 1;* REQUEST TO READ PROCESS
*CDSRCB}"EQU 1 DRUM STARTUP FOR READ CB;
*}/DRUM CLEANUP FOR READ CB
CDSRPR}#EQU 2;* DRUM START FOR READ PROCESS PAGE
*}/DRUM CLEANUP FOR READ PROCESS PAGE
*CRGFP}#EQU 14 GET FREE PAGE REQUEST;
CDNPG}"EQU 9;*}"CLEANUP CODE FOR NEW PAGE REQUEST
*CRDEST}"EQU 15 REQUEST TO DESTROY PAGE;
CDSDET}#EQU 8;* DRUM START FOR DESTROY PAGE
*CDCDET}#EQU 8;* DRUM CLEANUP FOR DESTROY PAGE
$CKSDET}"EQU 15;* DISK START FOR DESTROY PAGE (UN CHECK)
*}/DISK CLEANUP FOR DESTROY PAGE (UN CHECK)
$CKSDE0}"EQU 16;* DISK START FOR DESTROY PAGE (UN = 0)
*}/DISK CLEANUP FOR DESTROY PAGE (UN=0)
$LREQ}"EQU 21;* LAST REQUEST


*}"AMC FIELD DEFINITIONS
*}"CHT FIELDS
UN0}$FLDPK 0,0,23;*}'UNIQUE NAME
UN1}$FLDPK 1,0,23;*}'UNIQUE NAME
DKA}$FLDPK 2,2,23;*}'DISK ADDRESS
DB}%FLDPK 3,0,0;*})DIRTY BIT
DKWR}#FLDPK 3,1,1;*}'DISK WRITE IN PROGRESS
RDIP}#FLDPK 3,3,3;*}'READ IN PROGRESS
WRIP}#FLDPK 3,5,5;*}'WRITE IN PROGRESS
INCORM EQU RDIPM+DKWRM;*}&INCORE MASK
CPA}$FLDPK 3,6,12;*}'CORE PAGE ADDRESS
LOCK}#FLDPK 3,13,15;*}%PAGE LOCK
SCH}$FLDPK 3,16,23;*}&SCHEDULED COUNT
*FCLP}#DF 4,6,23;*}&FREE CORE LIST POINTER
*CLP}$DF 5,6,23;*}'COLLISION POINTER


*}"DHT FIELDS
DMA}$FLDPK 0,2,23;*}&DRUM OR DISK ADDRESS IN DHT
ONDK}#FLDPK 1,0,0;*}'CLEAN ON DISK
ONDR}#FLDPK 1,1,1;*}'PAGE HAS BEEN WRITTEN ON DRUM
WUN}$FLDPK 1,2,2;*}'WRITE UNIQUE NAME WHEN TRANSFERRIN TO DISK
DKD}$FLDPK 1,3,7;*}'DEST,KDT,KDT FIELD
DEST}#FLDPK 1,3,3;*}'PAGE BEING DESTROYED
KDT}$FLDPK 1,4,4;*}'DISK TO DRUM TRANSFER IN PROGRESS
DKT}$FLDPK 1,5,5;*}(DRUM TO DISK TRANSFER IN PROGRESS
UNDCK}"FLDPK 1,6,6;*}%CHECK UNIQUE NAME ONLY ON DISK
HDRER}"FLDPK 1,7,7;*}&HARD DRUM ERROR ON READ FOR DESTROY
*}=PAGE
UCNT}#FLDPK 1,14,23;*}$USE COUNT FIELD
UCOVF}"FLDPK 1,13,13;*})USE COUNT OVERFLOW


*}"REQUEST NODE FIELDS
*}"UNIQUE NAME AND DISK ADDRESS DEFINED BY CHT
WAKF}#FLDPK 3,0,1;*}(WAKEUP FIELD
ERRCNT FLDPK 3,2,5;*}%ERROR COUNT
EPRT}#FLDPK 3,6,23;*}&PRT POINTER TO PROCESS
ECWS}#FLDPK 4,0,5;*}'CWS INDEX
WDCNT}"DF 4,0,5;*}&WORD COUNT FOR DIRECT I/O
*PGAD}"DF 4,6,12;*}&PAGE ADDRESS FOR DIRECT I/O
LNODE}"FLDPK 4,13,13;*}$LEAVE NODE ON QUEU FOR DIRECT I/O
TIM}$DF 4,14,15;*}&TIMING FOR DIRECT I/O
DUMP}#FLDPK 4,16,16;*}%DUMP INFORMATION FOR DIRECT I/O
RCVR}#FLDPK 4,17,17;*}%RECOVER INFORMATION FOR DIRECT I/O
RCD}$FLDPK 4,18,23;*}&REQUEST CODE FOR DISPATCHERS
IDCODE FLDPK 5,0,3;*}%ID CODE FOR TSU INSTRUCTION
INSTN}"FLDPK 5,0,5;*}&TSU INSTRUCTION FOR DIRECT I/O
EQP}$FLDPK 5,6,23;*}'QUEUE POINTS


*}"DISK AND DRUM ADDRESS FIELDS
KTSUN}"DF 2,2,3;*}&DISK TSU IN NODE
DTSU}#FLDPK 0,3,4;*}'DRUM TSU
TRACK}"FLDPK 2,4,11;*}$DISK TRACK IN NODE
KBAND}"DF 2,12,17;*}#DISK BAND IN NODE
*DBAND}"FLDPK 0,10,16;*}$DRUM BAND
KSECT}"FLDPK 2,18,21;*}$DISK SECTOR IN NODE
DSECT}"FLDPK 2,17,21;*}$DRUM SECTOR
KUNIT}"DF 2,22,23;*}#DISK UNIT IN NODE
DUNIT}"FLDPK 0,22,23;*}$DRUM UNIT


*}"PRT DEFINITIONS
PRSW}#EQU 5;
PRST}#EQU 8;
$AMCW}"EQU 4B5;*}"WAKUP WORD FOR AMC

ACT}$FLDPK 2,0,0;
CBE}$DF 2,1,1;
SWERW}"FLDPK 4,0,23;*}*AMC ERROR WORD IN PRT
ERRCD}"FLDPK PRSW,0,5;*}(ERROR CODE SLOT IN PRT
DTC}$FLDPK PRSW,16,23;
PRSTW}"FLDPK PRST,0,23;
PGF}$FLDPK PRST,11,11;
WAQ}$FLDPK PRST,13,13;
CBC}$FLDPK PRST,14,14;
PDW}$FLDPK PRST,15,15;
PQ}%FLDPK PRST,16,16;
SWQ}$FLDPK PRST,17,17;
LDD}$FLDPK PRST,20,20;


*}"CWS,PMT FIELDS
NPG}$FLDPK 0,14,14;
*PMTI}#FLDPK 0,16,23;
SF}%FLDPK 3,12,12;
CCE}$FLDPK 3,13,13;
DWS}$DF 3,2,2;
HERR}#DF 3,14,14;*}4HARD ERROR
CWSIF}"FLDPK 1,0,23;
NCWSF}"FLDPK 2,0,23;
WCWSF}"FLDPK 3,0,23;
WSMSF}"FLDPK 4,0,23;
OCWSF}"FLDPK 5,0,23;
MCNTF}"FLDPK 6,12,23;


*}"AMC FAIL RETURNS TO CPU

CPWAIT EQU 1;* TELL CPU TO WAIT, COME BACK LATER
$UNER}"EQU 2;* UNIQUE NAME ALREADY EXISTS
DKINU}"EQU 3;* DISK ADDRESS IN USE
NINDHT EQU 4;* NOT IN DHT
DNCHT}"EQU 5;* DISK ADDRESS DID NOT COMPARE IN CHT
WAITWK EQU 6;* WAIT FOR WAKE-UP
DKRAS}"EQU 7;* DISK ADDRESS REASSIGNED
HERDR}"EQU 8;* HARD ERROR ON DRUM READ
PRTRBL EQU 9;* PROCESS IN TROUBLE
$HERDK EQU 10;* HARD ERROR ON DISK
$UNERK EQU 11;* UNIQUE NAME ERROR ON DISK AFTER DRUM COMPARED
SCHOVF EQU 12;* SCHEDULED COUNT OVERFLOW
$ARQOB EQU 13;* ACTIVATE REQUEST OUT OF BOUNDS
NOREQ}"EQU 14;* NO REQUEST NODE
NCHT}#EQU 15;* NO CHT ENTRY
$LPRERR EQU NCHT;
LAMCER EQU LPRERR+5;


*}"RESIDENT CORE LOCATIONS

ACTL}#EQU 100B;*}#ACTIVATE LOCATION
ACTQ}#EQU 102B;*}#ACTIVATE QUEUE
GRQ EQU 104B;*}#GENERAL REQUEST QUEUE
SWAPIN EQU 106B;*}#REQUEST QUEUE FOR SWAPPING PROCESSES
FREL}#EQU 110B;*}#FREE REQUEST ENTRY LIST
$RIPQ}"EQU 114B;*}#READ IN PROGRESS QUEUE
CTXQ}#EQU 116B;*}#CONTEXT BLOCK QUEUE
WRTQ}#EQU 120B;*}#WRITE QUEUE
NFREL}"EQU 123B;*}#NUMBER ON FREE REQUEST ENTRY LIST
$ERPROC EQU 124B;*}"ERROR PROCESS PRT POINTER
$DKCLQ EQU 126B+4;* DISK CLEANUP QUEUE
DRCLQ}"EQU 126B;*}#DRUM CLEANUP QUEUE
$DKSLB EQU 136B;*}#DISK SECTOR LIST BASE
*NKTER EQU 152B;*}#LOC. FOR COUNTING NKT ERRORS
NCTX}#EQU 153B;*}#LOC. FOR COUNTING NO. OF CB'S CONSIDERED
$NPR}#EQU 154B;*}#LOC. FOR COUNTING NO. OF PROC. SWAPPING
KCQB}#EQU 160B;*}#DISK CYLINDER QUEUE BASE
LKCQ}#EQU 161B;*}%LAST DISK CYLINDER QUEUE
DIOQ}#EQU 162B;*}#DIRECT I/O RETURN QUEUE
*STAPUFLAG EQU 164B;*}"FAST STARTUP: 0, OTHERWISE -1
NSWPG}"EQU 165B;*}#NUMBER OF SWAP PAGES IN CORE
NPGQ}#EQU 166B;*}.NEW PAGE QUEUE
RELQ}#EQU 170B;*}#QUEUE OF PAGES WHICH MAY BE RELEASED
$CNTA}"EQU 200B+LPRERR;*}#ARRAY TO COUNT STARTUPS AND ACTIVATE ERRORS
$PRERRA EQU CNTA+LREQ+LAMCER;*}"ARRAY OF COUNTS OF ERRORS REPORTED
*}@TO PROCESS
TSUD}#EQU 3100B;*}#SYSTEM TSU DUMP LOCATIONS
*PRTB}"EQU 302B;*}$LOC. FOR BASE ADDRESS OF PRT
REL}$EQU 160000B;*}+BASE ADDRESS OF AMCCD


*}"COUNTERS


*}"THE FIRST BLOCK OF COUNTERS ARE FOR COUNTING ACTIVATE ERROR RETURNS
*}"IT BEGINS AT 201B
*}"1 - WAIT CPU
*}"2 - UNIQUE NAME ALREADY EXISTS
*}"3 - DISK ADDRESS IN USE
*}"4 - NOT IN DHT
*}"5 - DISK ADDRESS DID NOT COMPARE IN CHT
*}"6 - WAIT FOR WAKE-UP
*}"7 - DISK ADDRESS REASSIGNED
* 13 - ACTIVATE REQUEST OUT OF BOUNDS
* 14 - NO REQUEST NODE
* 15 - NO CHT ENTRY
* 16 - SCHEDULED COUNT OVERFLOW


*}"THE NEXT BLOCK IS STARTUP COUNTS AND BEGINS AT 221B
*}"1 - CONTEXT BLOCK
*}"2 - PAGE READ (BOTH CONTEXT AND PROCESS PAGE)
*}"3 - DRUM READ FOR DRUM TO DISK TRANSFER
*}"4 - DIRECT DRUM TRANSFER
*}"5 - DIRECT DISK TRANSFER
*}"6 - WRITE FOR PAGE NOT ON DRUM
*}"7 - WRITE FOR DIRTY PAGE
* 10 - CHECK ON DRUM FOR DESTROY PAGE
* 11 - NEW PAGE
* 12 - WRITE ON DISK FOR DRUM TO DISK TRANSFER
* 13 - CHECK UN ON DISK FOR DRUM TO DISK TRANSFER
* 14 - CHECK UN FOR WRITE UNIQUE NAME ON DISK
* 15 - READ DISK FOR DISK TO DRUM TRANSFER
* 16 - WRITE FOR WRITE UNIQUE NAME
* 17 - CHECK UN ON DISK FOR DESTROY PAGE
* 20 - DESTROY ON DISK
* 21 - READ DRUM FOR DISK TO DRUM TRANSFER
* 22 - READ PAGE KLUDGE
* 23 - PAGE FAULT READ
* 24 - PAGE FAULT WRITE
* 25 - PAGE FAULT WAKEUP


*}"THE NEXT BLOCK OF COUNTERS ARE FOR COUNTING 'AMC' ERRORS
*}"IT BEGINS AT 246B
*}"1 - REDO WRITE FOR ALL REASONS
*}"2 - TAG FIELD ERROR
*}"3 - REGISTER LOADING VIOLATION
*}"4 - TOTAL DEVICE ERRORS
*}"5 - RETRY COMMAND


*}"THE NEXT BLOCK OF COUNTERS ARE FOR COUNTING THE NUMBER OF ERRORS
*}"SENT TO A PROCESS.}"IT BEGINS AT 245B.
*}"SEE LIST OF ERRORS FOR INDICES


*}"TSU DUMP DEFINITIONS FOR CLEANUP

TSUDMP EQU 100B-18D;* TSU REG. DUMP ON CLEANUP
$CLNQC EQU TSUDMP;* TSU CLEANUP QUEUE
TSUNC}"EQU TSUDMP+1;*}"TSU NO. IN SELECT POS.
$INSTC EQU TSUDMP+2;*}"INSTRUCTION REG.
DEVADR EQU TSUDMP+4;*}$DEVICE ADDRESS
$UN1C}"EQU TSUDMP+7;*}"CLASS CODE 1 REG.
$UN0C}"EQU TSUDMP+8;*}"CLASS CODE 0 REG.
*HUNIT}"EQU TSUDMP+9;*}$HOLDING UNIT 
$STATC EQU TSUDMP+17;* STATUS REG.


*}"VARIOUS SWAPPER PARAMETERS

$NKSECT EQU 5;*}&NUMBER OF DISK SECTOR QUEUES
MCTX}#EQU 2;*}%MAX. NO. OF CB'S TO BE CONSIDERED
NPROC}"EQU 2;*}#MAX. NO. OF PROCESSES TO BE CONSIDERED
$SZPRTE EQU 12;* SIZE OF PRT ENTRY
NDUNIT EQU 2;* NUMBER OF DRUM UNITS
ACTDU}"EQU 1;*}$LAST ACTIVE DRUM UNIT
ZRBAND EQU 5000B;*}7ZERO BAND FOR NEW PAGE REQUEST
COPYFG EQU 4B7;
STKCQ}"EQU 2B7;


*}"TSU PARAMETERS
$TSPC0 EQU 1B4;*}#POSITION COUNTER 0 OF TSU
*PCHCL EQU 1B7;*}#HOLDING REGISTER WAITING FOR CLEANUP
$TSRLV EQU 2;*;*}"REGISTER LOADING VIOLATION
$TSDTL EQU 20B;*}#DATA TRANSFER LATE
$TSCNE EQU 400B;*}"CLASS CODE NOT EQUAL
$TSCN0 EQU 100B;*}"CHECK CODE NOT ZERO
$TSDPE EQU 1000B;* DEVICE PARITY ERROR
KTSU}#EQU 4B6;*}#DISK TSU NUMBER FOR TSU SELECT REGISTER
TSCVF}"EQU 4B6;*}/TSU CYLINDER VERIFIED BIT 


*}"MACROS

CLQICR MACRO D;
}'CALL RECLQ; SCALL INCOR,FA0; PUNT; ETR =@[D()]; STA SCHD,6;
}'ENDM;


*}"MACRO GENERATES INLINE CODE TO SEARCH LIST.}"IT REQUIRES ONE 
*}"ARGUEMENT: THE SUCCESS BRANCH ADDRESS.}"IF SEARCH FAILS, NEXT
*}"INSTRUCTION IN LINE IS EXECUTED.
*}"A - FIRST NODE OF LIST (IE @HEADER-5)
*}"Z - PTR TO NODE CONTAINING DISK ADDRESS

SCHLST LMACRO D;
D(0)}#SCHL (BRU D(1));
}'ENDM;

SCHL}#LMACRO D;
D(0)}#SCALL BSCHL,T; BRU *+6; CALL TSCH,T; D(1);
}'SCALL CHTS0-1,T; BRU *+2; BRU *-4;
}'ENDM;

}'FREEZE;


*}"AMC TRANSFER VECTOR

START}"PUNT; BRU GENRQ; BRU ACTRQ;
}'BRU RDDRUM; BRU STNPG; BRU TSUCL;
}'BRU RQRD; BRU RQCB; BRU CPDKCL;
}'BRU DKSTART; BRU WRPGS;


SECTP}"DATA 23;*}1SECTOR POSITION FOR UNIT (DMRWUN ONLY)
CUNIT}"DATA 1;*}2CURRENT UNIT (DMRWUN ONLY)
SUNIT}"ZRO 0;*}3WRITE UNIT
}'VARD $TEMP,$TEMPA;
}'VARD PROC2,NRDQUE;
DKCQPT ZRO;*}"DISK CYLINDER QUEUE ROTATION POINTER
SFCNT}"ZRO;* SCHEDULED FLAG COUNT
NDRTRY ZRO;*}#NUMBER OF DRUM TRYS
WRTCNT BSS 1;
CLRSTR DATA -1;*}7BIT TABLE FOR CLEAR SECTORS
SEEKST BSS 4;*}1SEEK STARTED, ONE FLAG FOR EACH UNIT


}'IF *-START>=100B-18; REM ***}"STACK ERROR;
}'ENDF;
}'BSS 100B+START-*;*}"STORAGE FOR TSU REGISTERS FOR THE CLEANUP


*STACK AREA;
}'ZRO 6000B; BSS 8;



*}"GENERAL REQUEST AND ACTIVATE TRANSFER VECTORS

*}"VECTOR INITIALIZED FOR NORMAL AMC,}"HOWEVER BY 
*}"CHANGING FOUR CELLS, ONE CAN CONVERT TO DRUM AMC.
*}"CHANGE THE FOLLOWING TRANSFER VECTOR CELLS FOR ACTIVATE REQUESTS:
*}&ZRO RDKT,4}.TO}&ZRO DMRDKT,4
*}&ZRO RWUN,4}.TO}&ZRO DMRWUN,4
*}&ZRO RKDT,4}.TO}&ZRO DMRKDT,4
*}&ZRO RQDEST,4},TO}&ZRO DMRDST,4

$GRQTV EQU *;
$ARQTV ZRO GENRQ1,4; ZRO WRPROC,4; ZRO GENRQ1,4;
}'ZRO WRPROC,4; ZRO RDDIO,4; ZRO RDKIO,4;
$MAGRQ EQU *-ARQTV-1;*})MAX GENERAL REQ
}'ZRO PNT,4; ZRO PNT,4; ZRO PNT,4;
*}"ACTIVATE REQUESTS
$MIARQ EQU *-ARQTV-1;*})MIN ACTIVATE REQ -1;
}'ZRO RQRSP,4; ZRO RQRP,4; ZRO RDKT,4; ZRO RWUN,4;
}'ZRO RKDT,4; ZRO GETFP,4; ZRO RQDEST,4;
}'ZRO PNT,4; ZRO PNT,4; ZRO RDPG,4;
$MAARQ EQU *-ARQTV-1;*}+MAX ACTIVATE REQ


*}"TSU STARTUP TRANSFER VECTOR

$TVECDS ZRO PNT,4; ZRO GCCB,4; ZRO GCPG,4; ZRO GCDK,4;
}'ZRO DSDDT,4; ZRO KSDKI,4; ZRO GCDS,4;
}'ZRO PNT,4; ZRO PNT,4; ZRO PNT,4;
*}"DISK START
}'ZRO KSDK,4; ZRO KSCHUN,4; ZRO KSCHUN,4; ZRO KSKD,4;
}'ZRO KSWU0,4; ZRO KSCHUN,4; ZRO KSDE0,4; ZRO GCKD,4;
}'ZRO SRDPG,4;
$MAKSRQ EQU *-TVECDS-1;*}*MAX DISK START REQ


*}"TSU CLEANUP TRANSFER VECTOR

$CLTV}"ZRO PNT,4; ZRO DCCB,4; ZRO DCPRD,4; ZRO DCDK,4;
}'ZRO DCDDT,4; ZRO KCDKI,4; ZRO DCWR,4;
}'ZRO DCWR,4; ZRO DCDES,4; ZRO CLNPG,4;
*}"DISK CLEANUP
}'ZRO KCDK,4; ZRO KCDKU,4; ZRO KCWU,4; ZRO KCKD,4;
}'ZRO KCWW,4; ZRO KCDS,4; ZRO KCDSW,4; ZRO DCKD,4;
}'ZRO CRDPG,4; ZRO CSEEK,4;
$MACLRQ EQU *-CLTV-1;*},MAX CLEANUP REQ


*}"PUNT INSTRUCTION FROM THE TRANSFER VECTOR
PNT}$PUNT;


*}"TELL CPU TO WAIT, COME BACK LATER
CPWTE}"LDI CPWAIT; GOTO FRACT;
*}"UNIQUE NAME ALREADY EXISTS
UNERE}"LDI UNER; GOTO FRACT;
*}"DISK ADDRESS IN USE
DKINE}"LDI DKINU; GOTO FRACT;
*}"NOT IN DHT
$NIDHE LDI NINDHT; GOTO FRACT;
*}"DISK ADDRESS DID NOT COMPARE IN CHT
$DNCHE LDI DNCHT; GOTO FRACT;
*}"WAIT FOR WAKEUP
$CWAIT CLS EPTR;
$WAITE LDI WAITWK; GOTO FRACT;
*}"ACTIVATE REQUEST OUT OF BOUNDS
$ARQBE LDI ARQOB; GOTO FRACT;
*}"DISK ADDRESS REASSIGNED
DKRAE}"LDI DKRAS; GOTO FRACT;
*}"NO REQUEST NODE
NORQE}"LDI NOREQ; GOTO FRACT;
*}"NO CHT ENTRY
NCHTE}"LDI NCHT; GOTO FRACT;
*}"SCHEDULED COUNT OVERFLOW
SCHOVE LDI SCHOVF; GOTO FRACT;


}'REM AMCCD COMPILING;

*}"RELEASE CHT, DHT ENTRIES

$RLDCHT BSL DLCHT; NOP;
$RLDHT SCALL FDHT,Q; BVR 1; LSR3 =-1; SKB =ONDRM; SCALL CSFDPT;
}'CSX EPTR; LDA DKAD,6; CALL DDHT,Z; PUNT; BVR 1;


*}"DELETE CHT ENTRY AND PUT ON FREE LIST
*}"X = POINTER TO UNIQUE NAME AND DISK ADDRESS
*}"SKIP RETURN IF IN CHT

$DLCHT CSX EPTR;
$DCHTE SCALL INCOR,FA0; BVR 1;
*}"DISK ADDRESSES COMPARE, DELETE CHT ENTRY, ETC
$DCHT1 SKA =SCHM-1; CLRMAP;
}'LDB =77B6; SCALL DCHT+2; CALL CCHTE; CALL PPFCL; BVR 2;


*}"RELEASE PAGE
*}"ASSUMES FOR EACH PAGE IN THE PROCESS #2 THERE IS A PAGE EITHER
*}"ON A DRUM SECTOR READ LIST, OR ON THE RELQ.
RELPG}"CSS EPTR,SKT;
RELP0}"CALL RRELQ,Z; BRU RELP5; SCALL INCOR,FA0; BRU RELP3; CALL DSCH;
}'CXB; CALL PPFCL;
RELP1}"SCALL FDHT,Q; BRU RELP4; SCALL ADRD,Z; BRU RELP2;
RELP6}"CALL GFC,Q; BRU RELP0; CSS SKT,EPTR; BVR 2;
*}"NOT ON DRUM, NEW PAGE?
RELP2}"CSB EPTR; LDF RCD; SKE =CDNPG; BRU RELP4;
}'LDI NPGQ; CALL AELEQP; BRU RELP6;
*}"IN CHT?
RELP3}"CSB DKACMP; SKB =4B7; BRU RELP1;
*}"FORGET NODE
RELP4}"BSL SFOFF; NOP; SCALL FRENOD; MDC NRELQ; BRU RELP0;
*}"NO RELEASABLE PAGES
RELP5}"CSS SKT,EPTR; BVR 1;


*}"TEST PAGE DIRTY OR NOT ON DRUM
*}"SKIP IF NOT DIRTY AND ON DRUM (COMPLETELY CLEAN)
*}"DHTPT HAS TO POINT TO DHT ENTRY, CHTPT TO CHT ENTRY
$PGDOND CSX CHTPT; LDA DBD,6; SKA =DBM; BVR 1;
}'CSA DHTST; SKA =ONDRM; BVR 2; BVR 1;


*}"REMOVE ENTRIES FROM DISK CYLINDER QUEUE

CPDKCL SKEL* DKCQPT; BRU CPD1;
CPD0}#MIN DKCQPT; LDA LKCQ,4; SKL DKCQPT; RET;
CPD5}#LDA KCQB,4; STA DKCQPT; RET;
*}"FOUND A CYLINDER, COPY ALL REQUESTS OVER TO SECTOR QUEUES
CPD1}#LDA DKCQPT; SKG LKCQ,4; SKGE KCQB,4; BRU CPD5; CAX;
}'LDB 0,6; LDF KUNIT; XXA; SKN SEEKST,2; BRU CPD7; XXA; 
}'LDF EQP; STA 0,6; LDF RCD; SKNE =CDSDK; BRU CPD4;
CPD6}#CBS EPTR; SCALL QKSL;
CPD2}#ISK NKT; SNEL* DKCQPT; BRU CPD3; SFLAG COPYFG; RET;
*}"FINISHED CYLINDER QUEUE, RESET FLAG
CPD3}#CFLAG COPYFG; STZ SEEKST; STZ SEEKST+1; BRU CPD0;

*QUEUE DRUM READ FOR DRUM-DISK TRANSFER;
CPD4}#CBS EPTR; SCALL FDHT,Q; PUNT; SCALL ADRD,Z; BRU *+2; BRU CPD2;
}'CSB EPTR; CSA DHTST; SKNA =WUNM; BRU CPD6; LDI CKSDKU;
}'STF RCD; BRU CPD6;


*}"SEND SEEK INSTRUCTION
CPD7}#STX TEMPA; STB EPTR; LDA =KTSU; CALL FSTR,Q; RET;
}'CALL REFFL,Q; RET; LDX TEMPA; MDC SEEKST,2; LDX EPTR; 
}'LDA DKAD,6; ETR =KSECTM; SUB =2*KSECT1; SKG =-1;
}'ADD =NKSECT*KSECT1; STA TEMP; LDA DKAD,6; XXB; ETR =@KSECTM; 
}'MRG TEMP; STA DKAD,6;
}'LDI 19; STA RCDD,6; STX EPTR; BSL KSCHUN; PUNT; BRU RET1;


*}"RESERVE PAGE REQUEST

RQRSP}"CALL REACT,Z; BRU NORQE; SCALL INCOR,FA0; BRU NCHTE; 
}'SKA =INCORM; BRU CPWTE; ADD =1; STA SCHD,6; GOTO SRACT;



*}"GET FREE PAGE REQUEST
*}"EPTR=POINTER TO NODE

GETFP}"CALL REACT,Z; BRU NORQE; SCALL INCOR,FA0; BRU GETFP1; 
}'SKA =RDIPM; BRU CPWTE; BRU UNERE;
GETFP1 CSA DKACMP; SKNA =4B7; BRU UNERE;
}'CALL GFC,Q; BRU GETFP3; 
GETFP0 CBS CHTPT; CSB EPTR; LDF DKA; CAS DHT0;
}'CLS DHT1; LDHT2 =WUN1+UCNT1; CALL EDHT,Z; BRU GETFP2;
}'CSX CHTPT; LDI 1; SCALL ECHTE,Q; PUNT; GOTO SRACT;
GETFP2 LDI DKINU; LDB DKDD,6; SKB =DKDM; LDI CPWAIT; SCALL FRACT;
}'CSB CHTPT; CALL PPFCL; RET;
*}"RELEASE PAGE
GETFP3 BSL RELPG; BRU CPWTE; BRU GETFP0;


*}"REQUEST TO RELEASE PAGE TO DRUM
RQRP}#CALL REACT,Z; BRU NORQE; SCALL INCOR,FA0; GOTO SRACT; CALL DSCH;
}'SKA =SCHM+LOCKM; GOTO SRACT;
}'SKA =DBM; BRU RQRP1; SCALL FDHT,Q; PUNT; SKNB =ONDRM; BRU RQRP1;
}'CSB CHTPT; CALL PPFCL; GOTO SRACT;
*}"PUT ON WRITE LIST
RQRP1}"LDI WRTQ-SCHD; CSX EPTR; SCHL (GOTO SRACT);
}'CSB EPTR; LDI WRTQ; CALL SELEQP; CLS EPTR; GOTO SRACT;


*}"REQUEST TO READ A PROCESS-CB READ

RQCB}#LDI MCTX; SKG NCTX,4; RET; PRO 2; CALL RSWAP;
}'SCALL RSTS; SKA =CBCM+PQM; FRERET;
}'LDA ACTD,6; SKNA =ACTM; FRERET; LSR3 =CBCM; SCALL CSSTS;
}'CXS SR0; CSB EPTR; LDX =3; CALL BCOPY;
}'CSX EPTR; SCALL ICBTBL,Q; BRU RQCB1; STZ CWSIFD,6; 
}'CSX CHTPT; LDI 1; ADM SCHD,6;
}'CSB EPTR; LDI CTXQ; CALL AELEQP; MIN NCTX,4; RET;
RQCB1}"SCALL FDHT,Q; BRU RQCB2; SCALL ADRD,Z; BRU RQCB2; MIN NCTX,4; RET;
*}"REPORT ERROR TO PROCESS NO. 1
RQCB2}"BSL PRCER1; RET;


*}"QUEUE READS FOR A PROCESS
*}"THIS PROCEDURE IS DONE INCREMENTALLY FOR THE TOP PROCESS ON
*}"THE CONTEXT BLOCK QUEUE.

RQRD}#LDA NPR,4; SKL =NPROC; BRU RQRD11; SNEL CTXQ,4; BRU RQRD11; 
}'STZ NRDQUE; LDI -2; STA NRQ;
*}"SETUP CONTEXT BLOCK DESCRIPTOR
}'LDX CTXQ,4; SCALL ICBTBL,Q; BRU RQRD9; SKG =0; BRU IRQRD;
*}"INITIALIZED AND READY TO GO
RQRD0}"SKL NCWSFD,6; BRU RQRD10;
*}"SET SF BIT AND INITILIZE PAGE DESCRIPTOR TABLE (CWSI, CWSPT,CWSWD,
*}"PMTPT)
}'CALL ISSF; SKB =SFM; BRU RQRD3;
*}"NEW PAGE?
}'CSA CWSWD; SKA =NPGM; BRU NPAGE;
*}"IS PAGE IN CORE?
}'CSX PMTPT; SCALL INCOR,FA0; BRU RQRD1; SKA =INCORM; BRU RQRD1;
}'ADD =1; STA SCHD,6; SKP PROC2; BRU RQRD3; CXS EPTR; LDI CDSRPR;
}'CALL MNODE,T; BRU RQRD3; LDI RELQ; CALL AELEQP; BRU RQRD3;

*}"NOT IN CORE
RQRD1}"CSS PMTPT,EPTR; SCALL FDHT,Q; BRU RQRD7;
*}"MAKE NODE 
}'LDI CDSRPR; CALL MNODE,T; BRU RQRD8; SCALL ADRD,Z; BRU RQRD6;
RQRD2}"MIN NRDQUE;
*}"DO ANOTHER ONE?
RQRD3}"CSSI CWSI,AR; CSX BCWS; SKI NRQ; BRU RQRD0;
*}"FINISHED FOR NOW, UPDATE CWSI IN CONTEXT BLOCK, DRUM TRANSFER COUNT
*}"IN PRT, SET FLAG AND RET
RQRD4}"STA CWSIFD,6; LDA NRDQUE; CSX PRTPT; ADM DTCD,6; 
}'SFLAG PROCFG; RET;

*}"INITILIZATION FOR QUEUE PROCESS READS
IRQRD}"LSR3 =PQM; PRO 3; CALL CSSTS; LDI 1; STA NRDQUE;
}'CSB PRTPT; LDA NPR,4; SKGE =NPROC; LDB =-1; STB PROC2; 
}'LDI 0; CSX BCWS; SKNB =LDDM; BRU RQRD0;
*}"ALREADY LOADED, RETURN STATUS TO ORIGINAL VALUE, FORGET READ
}'CBS SR3; CALL CSSTS; BRU RQRD13;

*}"NOW THE SPECIAL CASES
*}"PAGE NOT ON DRUM FOR ADRD, FORGET READ
RQRD6}"CSA DHTST; SKNA =ONDKM; BRU NPAGE;
}'SCALL FRENOD; CALL CLSF; BRU RQRD3;

*}"NOT IN DHT, RESET DWS
RQRD7}"CALL CLSF; CSB PMTPT; LDI 0; STF DWS; BRU RQRD3;

*}"NO FREE NODE, WAIT
RQRD8}"CALL CLSF; CSA CWSI; CSX BCWS; BRU RQRD4;

*}"PROCESS SCREWED UP - TELL IT TO MOTHER
RQRD9}"BSL PRCERR; BRU RQRD13;


*}"PROCESS NOW QUEUED, DECREMENT DRUM TRANSFER COUNT, MOVE PROCESS
*}"NODE TO READ IN PROGRESS QUEUE
RQRD10 STZ CWSIFD,6; LDA NRDQUE; SUB =1; CSX PRTPT; ADM DTCD,6;
}'LDA DTCD,6; SKNA =DTCM; BRU RQRD12;
}'CALL RCTXQ; LDI RIPQ; CALL AELEQP; MIN NPR,4;
RQRD11 CFLAG PROCFG; RET;

*}"NO READS NECESSARY, SET LOADED, WAKEUP
RQRD12 LSR3 =LDDM; CALL CSSTS; CLX; CSB PRTPT; PRO 13B; CALL WAKEUP;
RQRD13 CALL RCTXQ; CFLAG PROCFG; FRERET;

*}"NEW PAGE
NPAGE}"CSX PMTPT; SCALL INCOR,FA0; BRU *+2; BRU NPAG1;
}'CSA DKACMP; SKNA =4B7; BRU NPAG1; CSS PMTPT,EPTR;
}'LDI CDNPG; CALL MNODE,T; BRU RQRD8; 
}'CSB PMTPT; LDF DKA; CAS DHT0; CLS DHT1; LDHT2 =WUN1+UCNT1;
}'CALL EDHT,Z; BRU NPAG0;
NPAG3}"LDI NPGQ; CSB EPTR; CALL AELEQP; BRU RQRD2;

*}"ALREADY IN DHT, RELEASE NODE AND SET CCE
NPAG0}"LDA ONDRD,6; SKNA =ONDKM+ONDRM; BRU NPAG3; SCALL FRENOD;
NPAG1}"CALL CLSF; MRG =CCEM; CSX PMTPT; STA CCED,6; BRU RQRD3;


}'END;
UMCCD}"IDENT;


*}"WRITE PROCESS ONTO DRUM REQUEST
*}"THIS IS AN INCREMENTAL SCAN OF A PROCESS WHICH IS ON THE FRONT OF
*}"THE GENERAL REQUEST QUEUE.

WRPROC LDI -2; STA NRQ; CBX; SCALL ICBTBL,Q; BRU WRPR12; 
}'SKG =0; BRU WRPR11;
*}"PROCESS INITIALIZED, A - CWSI, X -BCWS
WRPR0}"SKL WCWSFD,6; BRU WRPR8;
*}"CLEAR SF BIT AND INITIALIZE PAGE DESCRIPTOR TABLE (CWSI, CWSPT,
*}"CWSWD, PMTPT)
}'CALL ICSF; SKNB =SFM; BRU WRPR3;
}'CSX PMTPT; SCALL INCOR,FA0; BRU WRPR3;
*}"DECREMENT SCHED COUNT, TEST READY TO WRITE
}'SKA =SCHM; SUB =1; STA SCHD,6; SKA =LOCKM+SCHM; BRU WRPR2;
*}"PAGE MAY BE WRITTEN, SHOULD IT BE?
}'CSS PMTPT,EPTR; SKNA =DBM; BRU WRPR7;
*}"PAGE ALREADY ON WRITE LIST?
WRPR1}"LDI WRTQ-EQPD; CSX PMTPT; SCHLST WRPR2;
*}"PUT ON WRITE LIST
}'LDI CWRPR; CALL MNODE,T; BRU WRPR6; LDI WRTQ; CALL SELEQP;
*}"ALL THROGH WITH CWS, GET NEXT ONE
WRPR2}"SKP AGEFLG; BRU WRPR3;
*}"AGE CWS ENTRY
}'SCALL AGECWS; SKNA AGEMSK; SCALL XCWS; BRU WRPR4;
WRPR3}"CALL OCWS; ISK AR;
WRPR4 CSX BCWS; SKI NRQ; BRU WRPR0;
*}"FINISHED FOR NOW, UPDATE CWSI IN CONTEXT BLOCK AND RET
WRPR5}"STA 1,6; RET;

*}"SPECIAL CASES
*}"NO FREE NODES
WRPR6}"CSA CWSI; CSX BCWS; BRU WRPR5;

*}"NOT DIRTY, ON DRUM?
WRPR7}"SCALL FDHT,Q; PUNT; SKNB =ONDRM; BRU WRPR1;
*}"ON DRUM, PUT ON FREE CORE LIST
}'CSB CHTPT; CALL PPFCL; SCALL SSOT,Q; BRU WRPR2; BRU WRPR2;

*}"ALL THROUGH, QUEUE CONTEXT BLOCK, RESET PDW
WRPR8}"SOCWSI OCWSFD,6; LDI -1; CSB PRTPT; PRO 3; ZRF PDW; 
}'CALL REGRQ; LDI WRTQ; CALL SELEQP; RET;

WRPR9}"MDC AGEFLG; BRU WRPR12;

*}"PROCESS BEING QUEUED OR IS LOADED, TERMINATE WRITE
WRPR10}"CBS SR3; CALL CSSTS; CALL REGRQ; FRERET;


*}"INITIALIZE WRITE PROCESS
WRPR11 MIN MCNTFD,6; LDA MCNTFD,6; LCY 12; STZ AGEFLG; 
}'SKGE RSCD,6; BRU WRPR9; LCY 12; ETR =7777B4; STA MCNTFD,6;
}'LDA WSMSFD,6; STA AGEMSK;

*}"DECREMENT SCHEDULED COUNT ON CONTEXT BLOCK, SET DIRTY BIT
WRPR12 CBA; CSX CHTPT; SKA =SCHM; SUB =1; MRG =DBM; STA SCHD,6;
}'PRO 3; LSR3 =PDWM; CALL CSSTS; SKB =PQM+LDDM; BRU WRPR10;
}'LDI 0; SKNB =PGFM; BRU WRPR4;

*}"PAGE FAULT LOGIC
*}"THE MONITOR WILL SET BIT 11 (PGF) IN THE PROCESS STATE WORD
*}"AND BLOCK FOR A PAGE FAULT.}"THE AMC WILL LOOK AT ITS INTERNAL
*}"STATE AND DECIDE IF IT WILL READ THE PROCESS INTO CORE OR WRITE 
*}"IT OUT. CURRENTLY IT IS DECIDED TO WRITE THE PROCESS OUT IF 
*}"ANY OTHER PROCESS IS COMING INTO CORE OR THIS PROCESS IS ON THE 
*}"WAKEUP QUEUE
}'SKB =WAQM; BRU WRPR4; SKEL CTXQ,4; BRU PGFL0;
}'SKEL RIPQ,4; BRU PGFL0; BRU IRQRD;
PGFL0}"LDI 1; LEPTR GRQ,4; CALL MNODE,T; BRU PGFL1;
}'LDI SWAPIN; CALL AELEQP; LDI SWQM; CALL CSSTS; LDI 0; BRU WRPR4;
*}"NO FREE NODES, WAKEUP PROCESS & WRITE OUT
PGFL1}"CSB PRTPT; BSL WAKPR0; LDI 0; BRU WRPR4;




*}"REQUEST FOR DRUM TO DISK TRANSFER

RDKT}#CALL REACT,Z; BRU NORQE; SCALL FDHT,Q; BRU NIDHE;
}'SKB =DKDM; BRU CPWTE; SKNB =ONDKM; BRU RDKT1;
}'CSX EPTR; SCALL INCOR,FA0; BRU RDKT0; SKA =INCORM+DBM; BRU RDKT1;
*}"DO NOT TRANSFER, DECREMENT USE COUNT
}'CXS CHTPT; CSX DHTPT; LDA UCNTD,6; SKA =UCNTM; SUB =1; STA UCNTD,6;
}'SKA =UCNTM; GOTO SRACT;
*}"USE COUNT IS ZERO, DELETE?
}'CSX CHTPT; LDA SCHD,6; SKNA =SCHM+LOCKM; BSL RLDCHT; GOTO SRACT; 

*}"NOT IN CHT OR DISK ADDRESS DOES NOT COMPARE
RDKT0}"CSA DKACMP; SKNA =4B7; BRU DNCHE; 
RDKT1}"LDI CDSDK; CSB EPTR; STF RCD; SCALL QKCYL; LDA =DKTM;
SDHSTS CSX DHTPT; ADM DKTD,6; BRU CWAIT;


*}"(DRUM) REQUEST FOR DRUM TO DISK TRANSFER
DMRDKT CALL REACT,Z; BRU NORQE; SCALL FDHT,Q; BRU NIDHE; GOTO SRACT;


}'REM HALF WAY;


*}"REQUEST FOR DISK TO DRUM TRANSFER

RKDT}#CALL REACT,Z; BRU NORQE; LDA DKAD,6; 
}'CAS DHT0; CLS DHT1; LDHT2 =ONDK1+KDT1+UCNT1;
}'CALL EDHT,Z; BRU RKDT1; SCALL QKCYL; BRU CWAIT;
RKDT1}"CXS DHTPT; LDA DKDD,6; SKA =DKDM; BRU CPWTE;
}'CSX EPTR; SCALL INCOR,FA0; BRU RKDT2; SKA =INCORM; BRU RKDT3;
}'LDI 1; CSB DHTPT; ADF UCNT; GOTO SRACT;

*}"DISK ADDRESS COMPARE?
RKDT2}"CSA DKACMP; SKNA =4B7; BRU DNCHE;
RKDT3}"CSB EPTR; LDI CDSKD; STF RCD; SCALL ADRD,Z; BRU DKRAE;
}'LDA =KDTM; BRU SDHSTS;


*}"(DRUM) REQUEST FOR DISK TO DRUM TRANSFER
DMRKDT CALL REACT,Z; BRU NORQE; SCALL FDHT,Q; BRU DKRAE; GOTO SRACT;


*}"REQUEST TO DESTROY PAGE

RQDEST CALL REACT,Z; BRU NORQE; SCALL INCOR,FA0; BRU RQDE1; 
}'SKA =INCORM; BRU RQDE2; SKA =WRIPM+LOCKM; BRU CPWTE; 
}'SCALL FDHT,Q; PUNT; SKB =DKDM; BRU CPWTE; CBA; 
}'MRG =DESTM; STA DKDD,6; BSL DLCHT; PUNT;
RQDE0}"SCALL QKCYL; BRU CWAIT;
RQDE1}"CSA DKACMP; SKNA =4B7; BRU DNCHE;
RQDE2}"CSB EPTR; LDF DKA; CAS DHT0; CLS DHT1; LDHT2 =DEST1+UNDCK1;
}'CALL EDHT,Z; BRU *+2; BRU RQDE0; SCALL FDHT,Q; PUNT;
}'SKB =DKDM; BRU CPWTE; SCALL ADRD,Z; BRU CPWTE; CSB EPTR;
}'LDI CDSDET; STF RCD; LDA =DESTM; BRU SDHSTS;


*}"(DRUM) REQUEST TO DESTROY PAGE
DMRDST CALL REACT,Z; BRU NORQE; BSL RLDCHT; GOTO SRACT;


TIMS DATA 0,6*DSECT1,12*DSECT1,18*DSECT1;

*}"REQUEST FOR DIRECT DRUM I/O

RDDIO}"CALL REGRQ; LDF TIM; CAB;
RWUN5}"LDA DKAD,6; CBX; ADD TIMS,2; LDB =DSECTM; SCALL ADRD+2; RET;


TIMSK DATA 0,64,128,192;

*}"REQUEST FOR DIRECT DISK I/O

RDKIO}"CALL REGRQ; LDF TIM; CAX;
}'LDF TRACK; ADD TIMSK,2; CAB; SCALL QKCYL+2; RET;


*}"REQUEST TO WRITE UNIQUE NAME

RWUN}#CALL REACT,Z; BRU NORQE; SCALL INCOR,FA0; BRU *+2; BRU UNERE; 
}'CSA DKACMP; SKNA =4B7; BRU UNERE; CLS DHT1;
}'CSB EPTR; LDF DKA; CAS DHT0;
}'LDHT2 =WUNM; CALL EDHT,Z; BRU RWUN0; GOTO SRACT;
RWUN0}"LDA DKDD,6; SKA =DKDM; BRU CPWTE; BRU DKINE;


*}"(DRUM) REQUEST TO WRITE UNIQUE NAME

DMRWUN CALL REACT,Z; BRU NORQE; SCALL INCOR,FA0; BRU *+2; BRU UNERE; 
}&CSA DKACMP; SKNA =4B7; BRU UNERE; 
RWUN1}"LSR1 SECTP; LSR2 CUNIT; SCALL FBFDPT,FA0; BRU RWUN4; CAS DHT1;
}'CSB EPTR; LDF DKA; CAS DHT0; LDHT2 =ONDRM; CALL EDHT,Z; BRU RWUN2;
}'CSA DHT1; CLS SR3; SCALL CSFDPT; LDI WAITWK; SCALL FRACT;
}'CSX EPTR; CSA DHT1; STA DKAD,6; LDI CRDDT+RCVRM; STA RCDD,6;
}'LDA =10B*INSTN1; STA EQPD,6; CLB; SKR SECTP; BRU RWUN5;
}'LDI 23; STA SECTP; BRU RWUN5;
RWUN2}"LDA DKDD,6; SKA =DKDM; BRU CPWTE; BRU DKINE;
*}"LOOP
RWUN4}"SKR SECTP; BRU RWUN1; LDI 23; STA SECTP; 
}'SKR CUNIT; BRU RWUN1; LDI ACTDU; STA CUNIT; BRU RWUN1;


*}"GET COMMAND OFF DSRL (GENERAL)

RDDRUM CXA; CBS EPTR; SKLE =MAKSRQ; PUNT;
RDDRM0 BSL* TVECDS,2; BRU RDDRM1; LDI 1; STA NDRTRY; FRERET;
$RETSR1 EQU *-RDDRM0; LDI 1; STA NDRTRY; RET;
RDDRM1 LDS SR5,=STDRUM; SKR NDRTRY; CALL FRET; BRU RETSR1+RDDRM0;
$TRNPWT EQU *-RDDRM0; LDS SR5,=NOREAD; CALL FRET;


*}"WRITE PAGE ONTO DRUM

WRPGS}"CSX SELUNIT; CLA; CALL FSTR,Q; BRU WRPG6;
}'CAS SR1; CSS SELUNIT,SR2;
}'SCALL FBFDPT,FA0; BRU WRPG6; CAS SKT;
}'LDX WRTQ,4; CALL SPRTPT; SCALL SSOT,Q; RET;
}'LDB =WRTQ; CALL RTEQP,Z; RET; CALL REAC1;
}'SCALL INCOR,FA0; FRERET; SKA =WRIPM+SCHM+LOCKM; FRERET; STA TEMP;
}'SCALL FDHT,Q; FRERET; SKB =DESTM; FRERET; 
}'SKN TEMP; BRU WRPG7; CBA; ETR =@ONDKM; STA ONDKD,6; CNT 7;
WRPG1}"CSX CHTPT; LDA TEMP; MRG =WRIPM; ETR =@DBM; STA DBD,6;
}'CSX EPTR; SIDSEQ IDCODD,6; LDI 6; SKP TEMP; LDI 7; STA RCDD,6;
}'CSA SKT; CSB CHTPT; LDX =40B; SCALL EXEC;
}'LDI DRCLQ; CSB EPTR; CALL AELEQP; RET;

*}"INCREMENT WRITE UNIT AND TRY AGAIN
WRPG6}"ISK SELUNIT; CSA SELUNIT; 
}'SKL =3; SKR WRTCNT; SKL =NDUNIT; CLS SELUNIT;
}'SKI WRTCNT; BRU WRPGS; LDI -NDUNIT; STA WRTCNT; RET;
*}"ON DRUM
WRPG7}"SKB =ONDRM; FRERET; CNT 6; BRU WRPG1;


*}"STARTUP FOR NEW PAGE
STNPG}"CSX SELUNIT; CLA; CALL FSTR,Q; BRU STNP1; CAS SKT;
}'CAX; LDA CLRSTR; LCY 0,2; SKNA =4B7; BRU STNP1;
}'LDB =NPGQ; CALL RTEQP,Z; PUNT; CALL REAC1;
}'SCALL INCOR,FA0; BRU STNP2;
*}"ERROR, SET CCE, RESET SF, WAKE PROCESS, FREE NODE
STNP0}"BSL SFOFF; BRU *+2; STF CCE; BSL WKLD;
STNP1}"LDB =-1; RET;
*}"CHECK DISK ADDRESS NOT COMPARE FLAG
STNP2}"CSA DKACMP; SKNA =4B7; BRU STNP0;
}'SCALL FDHT,Q; BRU STNP0; SKB =DESTM; BRU STNP0;
}'CALL GFC,Q; BRU STNP4; 
STNP3}"LDA =RDIP1+SCH1; SCALL ECHTE,Q; PUNT;
}'CSA SKT; LCY 2; MRG =ZRBAND; SSELUNIT TEMP; MRG TEMP; 
}'CSX EPTR; SIDSEQ IDCODD,6; CLX; SCALL EXEC; 
}'LDI DRCLQ; CSB EPTR; CALL AELEQP; CLB; UPR 17B; RET;
*}"RELEASE PAGE?
STNP4}"CSB EPTR; LDF EPRT; SKNE PROC2; BRU STNP5;
}'BSL RELPG; BRU STNP5; BRU STNP3;
*}"PUT NODE BACK ON NPGQ, AND RETURN
STNP5}"LDI NPGQ; CSB EPTR; CALL SELEQP; BRU STNP1;


*}"GET COMMAND OFF DSRL (DRUM-DISK TRANSFER)
*}"B - NODE POINTER

$GCDK}"SCALL FDHT,Q; PUNT; SKNB =ONDRM; PUNT;
}'CSX EPTR; SCALL INCOR,FA0; BRU GCDK2; 
}'SKA =INCORM; BRU RQREAD; SKA =DBM; BRU GCDK1; 
}'CSA DHTST; SKNA =ONDKM; BRU GCDK1; SKNA =UCNTM-1; BRU GCDK0;
*}"ENTRY FOR CLEANUP ROUTINE
$DCDK0 SUB =1; 
*}"ENTRY FOR DISK-DRUM ROUTNINE
GCKD0}"ETR =@DKDM; CSX DHTPT; STA ONDKD,6; BRU KWAKP;

*}"ON DISK AND USE COUNT <=1, FORGET WRITE
GCDK0}"CSX CHTPT; LDA SCHD,6; SKA =SCHM+LOCKM; BRU RSDKD;

*}"RELEASE CHT,DHT, DO DISK WAKEUP BELOW
$KRLWK BSL RLDCHT; BRU KWAKP;

*}"DISK ADDRESS COMPARE ERROR, REPORT}"ERROR AND WAKE PROCESS, FORGET
*}"READ
KCERR LDI DNCHT;
$RDERR BSL RPERP;

*}"RESET DKD FIELD, WAKE PROCESS, FORGET READ
RSDKD}"LDI 0; CSB DHTPT; STF DKD;

*** DECREMENT NKT ***, WAKE PROCESS, FORGET READ
$KWAKP DSK NKT; BSL WAKEPR; SCALL FRENOD; BVR 1;

*}"REQUEUE NODE AND DO ANOTHER STARTUP IF ANOTHER NODE ON QUEUE
RQREAD SCALL ADRD,Z; PUNT;
DAREAD CSA EPTR; SKE 0,6; BVR 1; BVR TRNPWT;

*}"PAGE NOT ON DISK OR DIRTY, WRITE ON DISK
GCDK1}"CSB CHTPT; LDI 1; ADF SCH; CSB DHTST;
*}"ENTER TO QUEUE DK TRANSFER
$KQDKQ LDI CKSDKU; SKNB =WUNM; 
*}"ENTER TO QUEUE DK TRANSFER
$KQDKT LDI CKSDK;
*}"ENTER TO QUEUE DISK TRANSFER
$KQDKT0 CSB EPTR; STF RCD; SCALL QKSL; BVR 1;

*}"DISK ADDRESS COMPARE?
GCDK2}"CSA DKACMP; SKNA =4B7; BRU KCERR; CNT CDSDK;
*}"FALL THROUGH TO DO READ


*}"COMMON LOGIC TO DO READS FROM DRUM
*}"ENTER FREE CORE ENTRY FOR DRUM READ

$NDRRD CALL GFC,Q; BRU NDRD1; 
NDRD3}"LDA =RDIP1+SCH1; SCALL ECHTE,Q; PUNT;
}'CSX EPTR; SIDSEQ IDCODD,6; CSX DHTPT; LDA DMAD,6; CLX;
}'SCALL EXEC; LDI DRCLQ; CSB EPTR; CALL AELEQP; BVR RETSR1;
$NDRD0 SCALL SDRD,Z; PUNT; BVR TRNPWT;
NDRD1}"CSB EPTR; LDF EPRT; SKNE PROC2; BRU NDRD0;
}'BSL RELPG; BRU NDRD0; BRU NDRD3;


*}"DRUM START FOR DIRECT DRUM TRANSFER

*}"B - PTR TO NODE
$DSDDT LDF WDCNT; CAX; LDI 1; LCY 0,2; STA TEMP;
}'CBX; LDA 2,6; CAS SR2; ETR =DUNITM; STA TEMPA;
}'CSA SR2; ETR =DTSUM; CAS SR0;
}'LDF INSTN; LCY 2; MRG TEMPA; MRG =77B6; CAS SR1;
}'LDA 4,6; ETR =CPAM; CAS SR3;
}'LDA UN0D,6; LDB UN1D,6; LDX TEMP; SCALL STSUI; CNT CRDDT;
}'CSB EPTR; LDI DRCLQ; CALL AELEQP; BVR RETSR1;


*}"DISK START FOR DIRECT I/O

$KSDKI LDF WDCNT; CAX; LDI 1; LCY 0,2; STA TEMPA;
}'CBX; LDF KUNIT; STA TEMP;
}'LDF INSTN; LCY 2; MRG TEMP; MRG =77B6; CAS SR1;
}'LDA 4,6; ETR =CPAM; CAS SR3;
}'LDF KTSUN; LCY 19; CAS SR0;
}'LDF TRACK; LCY 14; STA TEMP; LDF KBAND;
}'LCY 7; ADM TEMP; LDF KSECT; LCY 2; MRG TEMP; CAS SR2;
}'LDA UN0D,6; LDB UN1D,6; LDX TEMPA; SCALL STSUI; CNT 5;
}'CSB EPTR; LDI DKCLQ; CALL AELEQP; BVR RETKS1;


*}"GET COMMAND OFF DSRL (READ FOR DESTROY PAGE)

$GCDS}"SCALL FDHT,Q; PUNT; SKNB =ONDRM; PUNT; 
}'CSX EPTR; SCALL INCOR,FA0; BRU GCDS0;
}'SKA =INCORM+WRIPM; BRU RQREAD; BSL DCHT1; PUNT; 
}'CSB EPTR; LDI CKSDET; STF RCD; SCALL QKCYL; BVR 1;
*}"DISK ADDRESS COMPARE?
GCDS0}"CSA DKACMP; SKNA =4B7; BRU *+3; CNT CDSDET; BRU NDRRD;

*}"DISK ADDRESS BAD
}'CSB CHTPT; CALL PPFCL;
GCKD1}"ISK NKT; BRU KCERR;
*}"RESET MAGIC DHT BITS, WAKE PROCESS, RETURN
$RSDKWK CSB DHTPT; LDI 0; STF DKD; BSL WAKEPR; BVR 1;


*}"GET COMMAND OFF DSRL (DISK-DRUM TRANSFER)

$GCKD}"SCALL FDHT,Q; PUNT; SKNB =ONDRM; PUNT;
}'CSX EPTR; SCALL INCOR,FA0; BRU GCKD2; 
}'SKA =INCORM; BRU RQREAD;
*}"PAGE ALREADY IN CORE, INCREMENT USE COUNT
$DCKD0 CSSI DHTST,AR; SKA =UCOVFM; PUNT; ISK NKT; BRU GCKD0;
*}"DISK ADDRESS COMPARE?
GCKD2}"CSA DKACMP; SKNA =4B7; BRU GCKD1; CNT CDSKD; BRU NDRRD;



*}"GET COMMAND, PAGE READ
$GCPG}"CBX; SCALL INCOR,FA0; BRU GCPG3; SKA =INCORM; BRU GCPG1;
}'ADD =1; STA SCHD,6;
GCPG0}"BSL WKLD; BVR 1;

*}"NOT IN CORE YET - REQUEUE
GCPG1}"SCALL FDHT,Q; BRU GCPG2; SCALL SDRD,Z; BRU GCPG2; BVR TRNPWT;
GCPG2}"BSL SFOFF; BRU GCPG0; STF CCE; BRU GCPG0;

*}"NOT IN CORE OR NOT IN CHT
GCPG3}"CSA DKACMP; SKNA =4B7; BRU GCPG2;
*}"NOT IN CORE, FIND DHT ENTRY
}'SCALL FDHT,Q; BRU GCPG4; SKNB =ONDRM; BRU GCPG2; 
}'SKB =DESTM; BRU GCPG1; CNT CDSRPR; BRU NDRRD;
GCPG4}"BSL SFOFF; BRU GCPG0; BRU GCPG0;


*}"GET COMMAND, CONTEXT BLOCK READ

$GCCB}"SKEL CTXQ,4; BRU GCCB0; 
}'CBX; SCALL ICBTBL,Q; BRU GCCB1; STZ CWSIFD,6; CBA; 
}'ADD =1; CSX CHTPT; STA SCHD,6;
}'LDI CTXQ; CSB EPTR; CALL AELEQP; CNT CRRDP; BVR RETSR1;

*}"NOT IN CORE YET, REQUEUE
GCCB0}"SCALL FDHT,Q; BRU GCCB2; SCALL ADRD,Z; BRU GCCB2; BRU DAREAD;

*}"NOT IN CORE OR NOT IN CHT
GCCB1}"CSA DKACMP; SKNA =4B7; BRU GCCB2; SKA =2B7; BRU GCCB0;
*}"NOT IN CHT
}'SCALL FDHT,Q; BRU GCCB2; SKNB =ONDRM; BRU GCCB2; 
}'SKB =DESTM; BRU GCCB0; CNT CRRDP; BRU NDRRD;

*}"CONTEXT BLOCK IN A BAD WAY, REPORT TO PROCESS 1
GCCB2}"BSL PRCERR; BVR 1;


}'END;
VMMCD}"IDENT;


*}"DRUM WRITE CLEANUP

$DCWR}"CLQICR WRIPM; SKA =DBM; BRU DCWR5; SCALL ERRCK,Q; BRU DCWR2;
}'LDA DEVADR; CLS SR3; SCALL CSFDPT; SCALL FDHT,Q; PUNT;
}'LDA DEVADR; XMA DMAD,6; 
}'SKNB =ONDRM; BRU DCWR1; LSR3 =-1; SCALL CSFDPT;
}'CSB CHTPT; CALL PPFCL; FRERET;
DCWR1}"CBA; MRG =ONDRM; STA ONDRD,6; BRU DCWR3;
*}"ERRORS
DCWR2}"BSL ERROR; BRU DCWR3; BRU DCWR4; PUNT; PUNT;
*}"HARD ERROR, RETRY
DCWR3}"BSL DCWR6; RET;
*}"TAG ERROR
DCWR4}"BSL DCWR6; BRU RSCLUP;
*}"DIRTY AGAIN
DCWR5}"BSL DCWR7; RET;
*}"SET DIRTY BIT TO PREVIOUS VALUE
DCWR6}"CSX EPTR; LDA RCDD,6; CSB CHTPT; STF DB; ECNT LPRERR+1;
*}"REQUEUE WRITE
DCWR7}"LDI WRTQ; CSB EPTR; CALL SELEQP; BVR 1;


*}"CLEANUP FOR NEW PAGE

$CLNPG CLQICR INCORM; SCALL FDHT,Q; BRU CNPG4; SKB =DESTM; BRU CNPG4;
}'CSX EPTR; LDA 0,6; STA UN0C; LDA 1,6; STA UN1C;
}'SCALL ERRCK,Q; BRU CNPG1; CSX EPTR; SCALL ICBTBL,Q; BRU DCCB2;
}'CSB EPTR; LDF ECWS; SCALL ISSF; LDI 1; CSB CWSPT; ZRF NPG;
}'BSL WKLD; RET;
*}"ERRORS
CNPG1}"BSL ERROR; BRU CNPG2; BRU CNPG3; PUNT; PUNT;
*}"HARD ERROR, RETRY
CNPG2}"LDI NPGQ; CSB EPTR; CALL SELEQP; RET;
*}"TAG ERROR
CNPG3}"LDI NPGQ; CRB EPTR; CALL SELEQP; BRU RSCLUP;
*}"NOT IN DHT OR BEING DESTROYED
CNPG4}"BSL DLCHT; BSL SFOFF; BSL WKLD; RET;


*}"DRUM CLEANUP FOR DRUM-DISK TRANSFER

$DCDK}"CLQICR INCORM; SCALL FDHT,Q; PUNT;
}'SCALL ERRCK,Q; BRU DCDK3; CSA DHTST; SKA =ONDKM; BRU DCDK2; CAB;
}'BSL KQDKQ; RET;

*}"ON DISK, DECREMENT USE COUNT, ETC.
DCDK2}"SKNA =UCNTM; BRU DCDK6; BSL DCDK0;
}'CSX CHTPT; LDA SCHD,6; SKA =SCHM; SUB =1; STA SCHD,6;
}'CXB; CALL PPFCL; RET;
*}"ERRORS
DCDK3}"BSL ERROR; BRU DRTRY; BRU DRSCL; BRU DCDK5; BRU DCDK5;
*}"HARD ERROR
}'LDI HERDR;
DCDK4}"BSL RDERR; CSX CHTPT; BSL DCHTE; PUNT; RET;
DCDK5}"LDI DKRAS; BRU DCDK4;
*}"PAGE NOT IN USE, DELETE ON DRUM
DCDK6}"BSL KRLWK; RET;


*}"DRUM CLEANUP FOR CB READ

$DCCB}"CLQICR INCORM; SCALL FDHT,Q; BRU DCCB2; SKB =DESTM; BRU DCCB1;
}'SCALL ERRCK,Q; BRU DCCB0;
}'CSX EPTR; SCALL ICBTBL; STZ CWSIFD,6;
}'LDI CTXQ; CSB EPTR; CALL AELEQP; RET;
*}"ERRORS
DCCB0}"BSL ERROR; BRU DCCB3; BRU DCCB4; NOP; NOP;
*}"HARD ERROR, REPORT TO PROCESS 1
DCCB1}"BSL DLCHT; PUNT;
DCCB2}"BSL PRCERR; RET;
*}"TRY AGAIN
DCCB3}"BSL DLCHT; PUNT; SCALL ADRD,Z; BRU DCCB2; RET;
*}"TAG ERROR
DCCB4}"BSL DLCHT; PUNT; SCALL ADRD,Z; BRU DCCB2; BRU RSCLUP;


*}"DRUM CLEANUP FOR PROCESS READ

$DCPRD CLQICR INCORM; SCALL FDHT,Q; BRU DCPR2; SKB =DESTM; BRU DCPR2;
}'SCALL ERRCK,Q; BRU DCPR1;
DCPR0}"BSL WKLD; RET;

*}"ERRORS
DCPR1}"BSL ERROR; BRU DRTRY; BRU DRSCL; BRU DCPR2; BRU DCPR2;
*}"HARD ERROR
}'BSL DLCHT; PUNT; BSL SFOFF; BRU DCPR0: STF HERR; BRU DCPR0;
*}"UN ERROR
DCPR2}"BSL DLCHT; PUNT; BSL SFOFF; BRU DCPR0; STF CCE; BRU DCPR0;


*}"DRUM CLEANUP FOR DISK-DRUM TRANSFER

$DCKD}"CLQICR INCORM; CALL DSCH; CALL PPFCL;
}'SCALL FDHT,Q; PUNT; SCALL ERRCK,Q; BRU DCKD2;
DCKD1}"BSL DCKD0; RET;
*}"ERRORS
DCKD2}"BSL ERROR; BRU DRTRY; BRU DRSCL; BRU DCKD4; BRU DCKD4;
*}"HARD ERROR, INCREMENT NKT TO BALANCE RDERR DECREMENT
}'LDI HERDK;
DCKD3}"ISK NKT; BSL RDERR; CSX CHTPT; BSL DCHTE; PUNT; RET;
DCKD4}"LDI DKRAS; BRU DCKD3;


*}"DRUM CLEANUP FOR DESTROY PAGE

$DCDES CLQICR INCORM; SCALL FDHT,Q; PUNT; BSL DLCHT; PUNT;
}'SCALL ERRCK,Q; BRU DCDS1;
*}"PUT DESTROY COMMAND ON DISK CYLINDER QUEUE
DCDS0}"CSB EPTR; LDI CKSDET; STF RCD; SCALL QKSL; RET;
*}"ERROR
DCDS1}"BSL ERROR; BRU DRTR0; BRU DRSCL0; BRU DCDS2; BRU DCDS2;
*}"HARD ERROR
}'XXB; SKB =TSUNE; BRU DCDS0; CSB DHTPT; LDI 1; STF HDRER;
}'BRU DCDS0;

*}"UN ERROR (SEE NOTE ABOVE DCKD3)
DCDS2}"ISK NKT; LDI DKRAS; BSL RDERR; RET;


*}"DISK CLEANUP FOR DIRECT I/O

$KCDKI BSL RECLQ; LDA RCVRD,6; SKNA =RCVRM; BRU KCKI0;
}'SCALL ERRCK,Q; NOP; LDA INSTC; ETR =77B6; SKE =77B6; BRU KCKI1;
}'CBA; ETR =@TSTAG; SKE =0; BRU KCKI2;
KCKI0}"DSK NKT; BRU DCDD0;
KCKI1}"CBA; MRG =TSTAG;
KCKI2}"CAB; LDA UN0C; MRG UN1C; 
}'BSL ERROR; BRU KRTRY; BRU KRSCL; BRU KCKI3; KCKI3;
*}"HARD ERROR
}'LDI HERDK; BSL RPERP; BRU KCKI0;
*}"UN ERROR
KCKI3}"LDI UNERK; BSL RPERP; BRU KCKI0;


*}"DRUM CLEANUP FOR DIRECT I/O

$DCDDT BSL RECLQ; LDA RCVRD,6; SKNA =RCVRM; BRU DCDD0;
}'SCALL ERRCK,Q; NOP; LDA INSTC; ETR =77B6; SKE =77B6; BRU DCDD3;
}'CBA; ETR =@TSTAG; SKE =0; BRU DCDD4;
DCDD0}"LDX EPTR; LDA DUMPD,6; SKNA =DUMPM; BRU DCDD1;
}'LSR0 =REL+TSUDMP; LDB =TSUD; LDX =18; CALL BCOPY; LDX EPTR;
DCDD1}"LDA LNODED,6; SKNA =LNODEM; BRU DCDD2; CXB;
}'LDA STATC; STF INSTN; RCY 6; STF WDCNT;
}'MIN NFREL,4; LDI DIOQ; PRO 2; CALL AELEQP; BSL WAKEPR; BRU RET1;
DCDD2}"BSL WAKEPR; BRU RETURN;
DCDD3}"CBA; MRG =TSTAG;
DCDD4}"CAB; LDA UN0C; MRG UN1C;
}'BSL ERROR; BRU DCDD5; BRU DCDD6; BRU DCDD7; DCDD7;
*}"HARD ERROR
}'LDI HERDR; BSL RPERP; BRU DCDD0;
*}"RETRY
DCDD5}"LDA DKAD,6; LDB =DSECTM; SCALL ADRD+2; RET;
DCDD6}"LDA DKAD,6; LDB =DSECTM; SCALL ADRD+2; BRU RSCLUP;
*}"UN ERROR
DCDD7}"LDI UNER; BSL RPERP; BRU DCDD0;


*}"DISK START-UP FOR UNIQUE NAME CHECK FOR THE FOLOWING:
*}"DRUM - DISK TRANSFER
*}"WRITE UNIQUE NAME
*}"DESTROY PAGE

$KSCHUN CLS SR3; LDB =4B7; BRU STDISK;


*}"DISK START-UP FOR DRUM-DISK TRANSFER (WRITE PAGE)

$KSDK}"CBX; SCALL INCOR,FA0; BRU KSDK0; SKA =WRIPM; BRU KSDK1;
}'SKA =INCORM; BRU KSDK0; MRG =DKWRM; STA SCHD,6;
}'SKA =SCHM-1; CLRMAP; SCALL FDHT,Q; PUNT; 
}'LSR3 =140B; SKB =WUNM; LSR3 =40B; CSB CHTPT;


*}"Q -CHT POINTER
*}"R3 - INSTRUCTION
STDISK CSX EPTR; SIDSEQ IDCODD,6; LDA DKAD,6; SCALL KEXEC; 
STDK0}"LDI DKCLQ; CSB EPTR; CALL AELEQP; RET;


*}"REQUEUE DRUM READ
KSDK0}"LDI CDSDK; CSB EPTR; STF RCD; SCALL FDHT,Q; PUNT; 
}'SCALL SDRD,Z; PUNT; RET;

*REQUEUE DISK WRITE
KSDK1}"SCALL QKSL; RET;


*}"DISK STARTUP FOR DESTROY PAGE (WRITE UN = 0)
$KSDE0 CLB;


*}"DISK STARTUP FOR WRITE UNIQUE NAME 

$KSWU0 LSR3 =40B; CSX EPTR; SIDSEQ IDCODD,6; LDA DKAD,6; STZ 0,4;
}'STZ 1,4; SCALL WUEXEC; BRU STDK0;


*}"DISK STARTUP FOR DISK-DRUM TRANSFER

$KSKD}"CBX; SCALL INCOR,FA0; BRU *+2; BRU KSDK1;
}'CSA DKACMP; SKNA =4B7; BRU KSKD2; CALL GFC,Q; BRU KSKD1;
KSKD0}"LDA =RDIPM; SCALL ECHTE,Q; PUNT; CLS SR3; CNT CKSKD; BRU STDISK;

*}"RELEASE PAGE
KSKD1}"BSL RELPG; BRU KSDK1; BRU KSKD0;

*}"DISK ADDRESS FOULED UP, DELETE CHT,DHT ETC
KSKD2}"LDI UNER; BSL RPERP; BSL KRLWK; RET;


*}"DISK CLEANUP FOR DESTROY PAGE (UN MATCH)

$KCDS CALL RECLQ; CNT CKSDET; SCALL FDHT,Q; PUNT;
}'SCALL ERRCK,Q; BRU KCDS0;
*}"UN OK, DELETE CHT ENTRY, QUEUE DELETE WRITE
}'CSX EPTR; LDI CKSDE0; STA RCDD,6; BSL DCHTE; NOP; SCALL QKSL; RET;
KCDS0}"BSL ERROR; BRU KRTRY; BSL KRSCL; BRU KCDS2; BRU KCDS3;
*}"HARD ERROR, IF UN OK AND CHECK ON DISK ONLY - DELETE PAGE
*}"OTHERWISE LEAVE DHT ALONE
}'XXB; SKB =TSUNE; BRU KCDS1; CSB DHTST; SKNB =UNDCKM; BRU DELPAG;
KCDS1}"BSL KWAKP; RET;
*}"UN IS ZERO IS WUN SET?
KCDS2}"CSB DHTST; SKNB =WUNM; BRU KCDS3;
*}"EVERYTHING OK
DELPAG BSL KRLWK; RET;

*}"WE HAVE EITHER A BAD UN OR A RESET WUN
KCDS3}"SKB =HDRERM; BRU KCDS4;

*}"DISK UN ERROR, RETURN
KUNER}"LDI UNERK;
*}"SEND ERROR, RELEASE PAGE, WAKEUP PROCESS
KERLWK BSL RPERP; BSL KRLWK; RET;
*}"DISK HARD ERROR
KHDER}"LDI HERDK; BRU KERLWK;

*}"COULD NOT READ OFF THE DRUM EITHER, REPORT UNER, LEAVE DHT,CHT ALONE
KCDS4}"LDI UNER; BSL RDERR; RET;


*}"DISK CLEANUP FOR DESTROY PAGE (WRITE UN =0)

$KCDSW CALL RECLQ; SCALL ERRCK,Q; BRU KCDW1;
*}"EVERTHING OK, NO USEFUL DATA ON DISK
KCDW0}"BSL KRLWK; RET;
KCDW1}"BSL ERROR; BRU KRTRY; BRU KRSCL; BRU KCDW0;
*}"HARD ERROR
}'SCALL FDHT,Q; PUNT; 
*}"IF CHECKED ON DISK ONLY - SEND ERROR AND DELETE PAGE
*}"OTHERWISE - SEND ERROR ONLY, ALWAYS SEND WAKEUP ETC...
}'LDI HERDK; SKB =UNDCKM; BRU KERLWK;
*}"SEND ERROR ONLY
}'BSL RDERR; RET;


*}"DISK CLEANUP FOR DISK-DRUM TRANSFER

$KCKD}"CLQICR INCORM; SCALL FDHT,Q; PUNT; SCALL ERRCK,Q; BRU KCKD0;
QWRT}#LDI WRTQ; CSB EPTR; CALL SELEQP; DSK NKT; BSL RSDKWK; RET;
KCKD0}"BSL ERROR; BRU KCKD1; BRU KCKD2; BRU KUNER; BRU KUNER; BRU KHDER;
*}"RETRY
KCKD1}"BSL DLCHT; PUNT; BRU KRTRY;
*}"TAG ERROR
KCKD2}"BSL DLCHT; PUNT; BRU KRSCL;


*}"DISK CLEANUP FOR DRUM-DISK TRANSFER (UN=0 CHECK)

$KCDKU CLQICR INCORM; CNT CKSDKU; SCALL FDHT,Q; PUNT;
}'SCALL ERRCK,Q; BRU KCDKU1;
*}"UN NAME CORRECT, QUEUE WRITE
KCDKU0 BSL KQDKT; RET;
KCDKU1 BSL ERROR; BRU KRTRY; BRU KRSCL; BRU KCDKU0; BRU KCDKU3;
*}"HARD ERROR
}'LDI HERDK;
KCDKU2 BSL RPERP;
DSCHWK CSX CHTPT; LDA SCHD,6; SKA =SCHM; SUB =1; STA SCHD,6;
KFCWT}"BSL PGDOND; BRU QWRT; CSB CHTPT; CALL PPFCL; BSL KWAKP; RET;
*}"UN ERROR
KCDKU3 LDI UNERK; BRU KCDKU2;


*}"DISK CLEANUP FOR DRUM-DISK TRANSFER (WRITE PAGE)

$KCDK}"CLQICR INCORM; SCALL FDHT,Q; PUNT; SCALL ERRCK,Q; BRU KCDK1;
}'CSA DHTST; ETR =@WUNM;
KCDK0}"SKA =UCNTM; SUB =1; CSX DHTPT; STA UCNTD,6; SKA =UCNTM; BRU DSCHWK;
*}"PAGE ALMOST FREE TO DELETE
}'CSX CHTPT; LDA SCHD,6; SKA =SCHM; SUB =1; STA SCHD,6;
}'SKA =SCHM+LOCKM; BRU KFCWT; 
}'BSL KRLWK; RET;

KCDK1}"BSL ERROR; BRU KRTRY; BRU KRSCL; BRU KCDK3; BRU KCDK3;
*}"HARD ERROR
}'LDI HERDK;
KCDK2}"BSL RPERP; CSA DHTST; BRU KCDK0;
*}"UNIQUE NAME ERROR
KCDK3}"LDI UNERK; BRU KCDK2;


*}"DISK CLEANUP FOR WRITE UNIQUE NAME (UN CHECK FOR 0)

$KCWU}"CALL RECLQ; CNT 12; SCALL FDHT,Q; PUNT; SCALL ERRCK,Q; BRU KCWU1;
KCWU0}"LDI CKSWU0; BSL KQDKT0; RET;
KCWU1}"SKE =0; BRU KCWU2; SKNB =@TSUNE; BRU KCWU0;
*}"REAL ERROR
KCWU2}"BSL ERROR; BRU KRTRY; BRU RSCLUP; PUNT; BRU KCWU3;
*}"HARD ERROR
}'LDI HERDK; BSL RDERR; RET;
*}"UN ERROR
KCWU3}"LDI UNERK; BSL RDERR; RET;


*}"DISK CLEANUP FOR WRITE UNIQUE NAME

$KCWW}"CALL RECLQ; SCALL ERRCK,Q; BRU KCWW0; BSL KRLWK; RET;
KCWW0}"BSL ERROR; BRU KRTRY; BRU KRSCL; BRU KUNER; BRU KUNER; BRU KHDER;


*}"CLEANUP FOR SEEK ROUTINE

$CSEEK}"CALL RECLQ; LDX DKAD,6; LSR4 =KTSU; CALL GETPOS;
}'SKNA =TSCVF; BRU KSCHUN; FRERET;


*}"READ PAGE KLUDGE, PUT IN SPECIFICALLY FOR SYSDDT

$RDPG}"CALL REACT,Z; BRU NORQE; SCALL INCOR,FA0; BRU RDPG0; 
}'SKA =INCORM; BRU RDPG1; ADD =1; STA SCHD,6; GOTO SRACT;
RDPG0}"CSA DKACMP; SKNA =4B7; BRU DNCHE;
RDPG1}"SCALL FDHT,Q; BRU NIDHE; SCALL ADRD,Z; BRU WAITE;
}'CLS EPTR; GOTO SRACT;


*}"START READ PAGE REQUEST

$SRDPG CBX; SCALL INCOR,FA0; BRU SRDP0; SKA =INCORM; BRU NDRD0;
}'ADD =1; STA SCHD,6; SCALL FRENOD; BVR 1;
SRDP0}"CSA DKACMP; SKNA =4B7; FRERET; SCALL FDHT,Q; PUNT; CNT 18; 
}'BRU NDRRD;


*}"CLEANUP FOR READ PAGE KLUDGE

$CRDPG CLQICR INCORM; SCALL ERRCK,Q; BRU CRDPG0; FRERET;
CRDPG0 SCALL FDHT,Q; BRU CRDPG1; 
}'BSL ERROR; BRU DRTRY; BRU DRSCL; NOP; NOP;
*}"ERROR, FORGET IT
CRDPG1 BSL DLCHT; PUNT; FRERET;


*}"GENERAL REQUEST DISPATCHER

$GENRQ CBS EPTR; SKG =MAGRQ; BRU* GRQTV,2;
$GENRQ1 CALL REGRQ; FRERET;


*}"ACTIVATE REQUEST DISPATCHER

$ACTRQ CBS EPTR; SKG =MAARQ; SKG =MIARQ; BRU *+2; BRU* ARQTV,2;
}'CALL REACT,Z; BRU NORQE; BRU ARQBE;


$KRTRY SCALL QKSL; RET;
$DRTRY BSL DLCHT; PUNT; 
$DRTR0 SCALL SDRD,Z; PUNT; RET;


*}"RESTART CLEANUP BECAUSE TSU AND AMC OUT OF SYNC
$KRSCL SCALL QKSL; BRU RSCLUP;
$DRSCL CSX EPTR; BSL DCHTE; PUNT;
$DRSCL0 SCALL SDRD,Z; PUNT;
$RSCLUP SNEL* CLNQC; RET; ECNT LPRERR+2; LDB* CLNQC; LDF RCD; CAX;


*}"CLEANUP FOR TSU'S
*}"A,X HAS REQUEST CODE
*}"B HAS POINTER TO NODE

$TSUCL CBS EPTR; SKG =MACLRQ; BRU* CLTV,2;
}'CALL RECLQ; FRERET;


*}"DISK START DISPATCHER
$DKSTART CXA; CBS EPTR; SKG =MAKSRQ; BRU* TVECDS,2; FRERET;




*}"DETERMINE CLASS OF ERROR
*}"RETURNS ARE RELATIVE TO CALL
*}"1 - RETRY
*}"2 - TAG ERROR, CATCH UP
*}"3 - UN = 0
*}"4 - UN ERROR
*}"5 - HARD ERROR

$ERROR ECNT 4; SKB =TSRLV+TSTAG; BRU ERR2;
}'SKNB =@[TSDTL+TSUNE+TSCVE]; BRU ERR1; LDA =ERRCN1; ADM ERRCND,6;
}'XXB; LDF ERRCNT; SKG =10; BVR 1; BVR 5;

*}"RETRY OR UN IS ZERO?
ERR1}#SKB =TSDTL+TSCVE; BVR 1; SKNE =0; BVR 3; 
}'LDA =ERRCN1; ADM ERRCND,6; XXB; LDF ERRCNT; SKG =1; BVR 1; BVR 4;

*}"RETRY OR TAG ERROR?
ERR2}#ECNT 3; SKB =TSRLV; BVR 1; ECNT 2; BVR 2;


*}"PROCESS WAKEUP IN NODES
*}"EPTR EXPECTED TO POINT TO NODE

$WAKEPR CSX EPTR; LDA WAKFD,6; SKNA =WAKFM; BVR 1; LDB EPRTD,6;
*}"ENTRY POINT
*}"B - PTR TO PRT ENTRY
$WAKPR0 LDX =AMCW; PRO 13B; CALL WAKEUP; BVR 1;


*}"WAKEUP PROCESS IF LOADED
*}"EPTR = POINTER TO NODE

$WKLD}"CSX EPTR; CALL SPRTPT; PRO 3; LDA DTCD,6;
}'SKA =DTCM; SUB =1; STA DTCD,6; SKNA =DTCM; BSL WKPRC;
}'CSA PRTPT; SKNE PROC2; BRU *+3; SCALL FRENOD; BVR 1;
}'LDI RELQ; CSB EPTR; CALL AELEQP; MIN NRELQ; BVR 1;


*}"WAKEUP PROCESS WHICH HAS NOW BEEN READ INTO CORE
*}"PROTECT 1 MUST BE SET

$WKPRC LSR3 =LDDM; CALL CSSTS; CSB PRTPT;
}'CLX; PRO 13B; CALL WAKEUP; 
}'LDA NRELQ; ADM NFREL,4; STZ NRELQ; 
}'LSR0 =RELQ; LSR1 =FREL; CALL CONC;
}'LDB =RIPQ; CALL RTEQP,Z; BRU *+2; CALL SETFL;
}'SKR NPR,4; BVR 1; STZ NPR,4; BVR 1;


*}"REPORT ERROR TO PROCESS
*}"A - ERROR CODE

$RPERP CAS SR5; CAX; SKG =LPRERR; MIN PRERRA,6; 
}'CSX EPTR; CALL SPRTPT; PRO 3; STF ERRCD; CSX EPTR;
}'LDA DKAD,6; STF SWERW; BVR 1;


*}"REPORT ERROR TO PROCESS #1
*}"EPTR - POINTER TO NODE
*}"GIVE PROCESS #1 THE PRT POINTER AND A PROCESS IN TROUBLE ERRCD
*}"SEND PROCESS #1 AN AMC WAKEUP
*}"FREE NODE

$PRCERR SKR NCTX,4; BRU *+2; STZ NCTX,4;
$PRCER1 CSX EPTR; CALL SPRTPT; SCALL FRENOD;
}'LDB ERPROC,4; CSA PRTPT; STF SWERW; LDI PRTRBL;
}'STF ERRCD; BSL WAKPR0; CSB PRTPT; LDI 1; STF CBE; 
$ZPRTS LDI CBCM+PQM+PGFM; ZRF PRSTW; BVR 1;


$SFOFF CSX EPTR; SCALL ICBTBL,Q; BVR 1; CSB EPTR; LDF ECWS; 
}'SCALL ICSF; CSB PMTPT; LDI -1; BVR 2;


}'END;
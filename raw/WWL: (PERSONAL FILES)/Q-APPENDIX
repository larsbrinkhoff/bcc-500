.GL}"NUM-BER GUAR-AN-TEED FUNC-TION COM-PILES BUF-FERS
.GL AR-GU-MENTS
.GL}"ORIG-IN-AL FOL-LOW-ING DE-SCRIP-TOR CHAR-AC-TERS
.GL ALLO-CATES
.DEFINE FORMAT A L(A) J(B)
AAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
.END FORMAT
.DEFINE FORMAT B L(A) L(B) J(C)
AAAAAABBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
.END FORMAT
.DEFINE FORMAT C R(A) J(B)
AAAAAAAAAAAA}"BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
.END FORMAT
.DEFINE FORMAT D R(A) J(B)
AAAAAAAAAAAA ::= BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
.END FORMAT
.CE
^CAPPENDIX /A
.SP 2
.CE
/RUNTIME /DETAILS
.SP 5
^I/STRINGS
}'/A ^CQSPL STRING DESCRIPTOR CONSISTS OF FOUR WORDS, EACH OF WHICH
IS A CHARACTER POINTER (3*<WORD ADDRESS>+0, 1, OR 2).}"/THEY ARE:
.RM 8,5
.UN 3
POINTER TO CHARACTER BEFORE FIRST CHARACTER OF SPACE ALLOCATED TO STRING.

.UN 3
READ POINTER FOR STRING.

.UN 3
WRITE POINTER FOR STRING.

.UN 3
POINTER TO LAST CHARACTER OF SPACE ALLOCATED TO STRING.
.EM 8,5
^CISD CREATES SUCH A DESCRIPTOR.
^CRSD, ^CRSR AND ^CRSW SET THE READ AND WRITE POINTERS.
/CHARACTERS ARE COUNTED FROM 0.
^CRCS READS THE CHARACTERS BETWEEN READ AND WRITE POINTERS.
^CWCS WRITES CHARACTERS BETWEEN WRITE AND END POINTERS.
^CRCB READS CHARACTERS BETWEEN WRITE AND READ POINTERS.
^CWCB WRITES CHARACTERS BETWEEN READ AND BEGINNING POINTERS.
/A VARIABLE DECLARED ^CSTRING MUST CONTAIN THE ^IADDRESS OF A DESCRIPTOR
WHEN IT IS USED IN A STRING OPERATION.
.SP 3
.UNDERLINE
/PAGING /LOGIC
}'/A VALID DRUM ADDRESS HAS BIT 3 OFF AND BIT 4 ON; BITS 0-2 ARE
IGNORED AND BITS 5-23 COMPRISE THE ACTUAL VIRTUAL ADDRESS.
^CCEA AND ^CCEI ARE USED TO TRANSLATE SUCH ADDRESSES INTO CORE ADDRESSES;
IF THE DESIRED PAGE IS NOT IN CORE, IT IS READ IN (WHICH USUALLY INVOLVES
WRITING OUT SOME OTHER PAGE).
^CCEAS AND ^CCEIS DO THE SAME, EXECPT THAT THEY ALSO SET A FLAG
ASSOCIATED WITH THE BUFFER TO ENSURE THAT THE PAGE WILL BE REWRITTEN ON
THE DRUM BEFORE A NEW ONE IS BROUGHT INTO THE BUFFER.
.EJ
.UNDERLINE
/CORE /STORAGE /ALLOCATION
}'/A BLOCK ALLOCATED BY A (FIXED) ARRAY DECLARATION OR BY A
SINGLE-ARGUMENT CALL OF ^CMAKE CONTAINS ONE MORE WORD THAN WAS REQUESTED
BY THE USER.
/THE EXTRA WORD, WHICH IS THE ONE IMMEDIATELY PRECEDING THE 0TH WORD OF
THE BLOCK, CONTAINS THE ^ITOTAL LENGTH OF THE BLOCK, INCLUDING THE EXTRA
WORD.
/THE TOP TWO BITS ARE USED BY THE STORAGE ALLOCATOR:
}'/BIT 0 IS ON IF THE BLOCK IS FREE.
}'/BIT 1 IS ON THE THE NEXT LOWER BLOCK IS FREE.
.SP
/BLOCKS ALLOCATED BY A TWO-ARGUMENT CALL OF ^CMAKE DO ^INOT HAVE THIS
EXTRA WORD.
}'/AN ARRAY BEING USED FOR STORAGE ALLOCATION (I.E., ONE SET UP BY
^CSETARRAY, OR THE ^CSARRAY ARRAY) HAS THE FOLLOWING FORM:
}'^I/WORD}1^I/CONTENTS
.RM 5,5
.SP
.FORMAT A
-1\/LENGTH + BLAG BITS.}"/SEE ABOVE.
.SP
.FORMAT A
0\/BEAD SIZE, OR 0 FOR AN ARRAY WHICH ALLOCATES VARIABLE SIZED BEADS
(OR BLOCKS).
.SP
.FORMAT A
1\/ADDRESS OF ROUTINE TO CALL WHEN FREE SPACE IS EXHAUSTED.
/THIS WORD MAY BE SET BY THE PROGRAMMER.
/THE SYSTEM DOES A ^CCALL* THROUGH IT.
.SP
.FORMAT A
2\/POINTER TO MASTER FREE LIST (OR JUST TO FREE LIST FOR ARRAYS
ALLOCATING FIXED SIZE BLOCKS).
.SP
.FORMAT A
3\/FREE SPACE TO BE ALLOCATED.
.FILL
.EM 5,5
.SP 2
}'/THE FREE LIST FOR A FIXED BLOCK SIZE ARRAY STARTS AT THE SECOND
WORD OF THE ARRAY, IS LINKED THROUGH THE FIRST WORD OF EACH FREE BLOCK,
AND TERMINATES WITH A ZERO.
.EJ
}'/THE MASTER FREE LIST FOR A VARIABLE BLOCK SIZE ARRAY USES ONE
BLOCK FOR EACH BLOCK SIZE.
/THREE WORDS OF THIS BLOCK ARE USED:
.RM 5,5
.SP
.FORMAT A
-1\/LENGTH + FLAG BITS.
.SP
.FORMAT A
0\/BACK-POINTER.}"/TERMINATES AT 0TH WORD OF ARRAY.
.SP
.FORMAT A
1\/POINTER TO SLAVE-FREE LIST FOR THIS BLOCK SIZE.
.SP
.FORMAT A
2\/POINTER TO NEXT BLOCK ON MASTER FREE LIST.
.FILL
.EM 5,5
.SP 2
}'/THE BLOCKS ON A SLAVE-FREE LIST ARE ALL OF THE SAME SIZE.
/TWO WORDS OF EACH ARE USED:
.RM 5,5
.SP
.FORMAT A
-1\/LENGTH + FLAG BITS.
.SP
.FORMAT A
0\/BACK POINTER ON SLAVE-FREE LIST.
.SP
.FORMAT A
2\/FORWARD POINTER ON SLAVE-FREE LIST, OR 0.
.FILL
.EM 5,5
.SP 2
}'/THE LAST ENTRY ON THE MASTER FREE LIST MAY BE FOR BLOCK SIZE 2.
/IN THIS CASE THE THIRD WORD IS NOT AVAILABLE, BUT IT IS NOT NEEDED,
SINCE THE MASTER FREE LIST IS SORTED BY DECREASING BLOCK SIZE, AND
THE SMALLEST POSSIBLE BLOCK SIZE IS 2.
.EJ
.UNDERLINE
^CQSPL /RUNTIME ^CPOPS
.SP 3
* ON MNEMONIC MEANS THAT ALL CENTRAL REGISTERS NOT USED TO RETURN RESULTS
ARE DESTROYED.
.SP
+ ON MNEMONIC MEANS THAT ALL CENTRAL REGISTERS ARE CLEARED.
.SP 2
^I/CODE}"^I/MNEMONIC}1^I/FUNCTION
.SP
.FORMAT B
100\}"^CCALL\/FUNCTION CALL.}"/THE DEFINITION IS JUST ^CBRM 0.
/THUS ^UF(A,B)^L COMPILES ^ULDA A; LDB B; CALL* F^L.
.FILL
.SP
.FORMAT B
101\+ ^CNSC\/NUMERIC TO STRING CONVERSION.}"(/Q) = ORIGINAL INTEGER.
(/A) = STRING DESCRIPTION ADDRESS, (/B) = RADIX, (/X) = NUMBER OF
CHARACTERS TO WRITE (-1 MEANS FREE FORMAT).
^CCNS(/A,/S) COMPILES ^ULDA S; LDB =10; LDX =-1; NSC A^L.
.FILL
.SP
.FORMAT B
102\+ ^CMSG\/PRINT STRING STARTING AT /A ON TELETYPE WITH ^CBRS 34.
/NOT OUTPUT BY COMPILER.
.FILL
.SP
.FORMAT B
103\+ ^CFIO\/OUTPUT INTEGER TO FILE.}"(/A) = FILE NUMBER; (/Q), (/B),
(/X) AS FOR ^CNSC.}"^CIOUT(/A,/F,/R,/C) COMPILES ^ULDA F; LDB R; LDX C;
FIO A^L.
.FILL
.SP
.FORMAT B
104\}"^CRERR\/RUNTIME ERROR.}"/Q (^INOT (/Q)) IS THE ERROR NUMBER.
.FILL
.SP
.FORMAT B
105\* ^CRCN\/READ CHARACTER, NO MOTION.}"(/Q) = STRING DESCRIPTOR ADDRESS.
/READS THE CHARACTER FOLLOWING THE ONE ADDRESSED BY THE DESCRIPTOR TO /A.
/THE DESCRIPTOR IS NOT CHANGED.}"/G/C(/S) COMPILES ^CRCN /S.
.FILL
.SP
.FORMAT B
106\* ^CRCS\/READ CHARACTER FROM STRING.}"(/Q) = STRING DESCRIPTOR
ADDRESS.
/READS THE CHARACTER FOLLOWING THE ONE ADDRESSED BY THE DESCRIPTOR INTO
/A, INCREMENTS THE DESCRIPTOR TO POINT TO THE CHARACTER.
/SKIPS IF STRING IS NOT EMPTY.
^CGCI(/S:/F) COMPILES ^URCS S; BRU* F^L.
.FILL
.SP
.FORMAT B
107\* ^CWCS\/WRITE CHARACTER (Q) ON STRING (A).}"/SEE ^CRCS, BUT WRITES
CHARACTER FROM /Q.
/SKIPS IF SPACE LEFT IN STRING.
^CWCI(/C,/S:/F) COMPILES ^ULDA S; WCS C; BRU* F^L.
.FILL
.SP
.FORMAT B
110\* ^CRCB\/READ CHARACTER BACKWARDS.}"/SEE ^CRCS, BUT READS THE
CHARACTER WHICH WOULD HAVE BEEN WRITTEN BY THE LAST ^CWCS.}"
^CGCD(/S:/F) COMPILES ^URCB S; BRU* F^L.
.FILL
.SP
.FORMAT B
111\* ^CWCB\/WRITE CHARACTER BACKWARDS.}"/SEE ^CRCS BUT WRITES (/Q)
INTO THE STRING SO THAT IT WILL BE READ BY A FOLLOWING ^CRCS.
^CWCD(/C,/S:/F) COMPILES ^ULDA S; WCB,C/ BRU* F^L.
.FILL
.SP
.FORMAT B
112\+ ^CRSD\/RESET STRING DESCRIPTOR.}"(/Q) = STRING DESCRIPTOR
ADDRESS, (/A) = CHARACTER NUMBER TO SET READ POINTER TO, (/B) = CHARACTER
NUMBER TO SET WRITE POINTER TO.
^CSETS(/S,/R,/W) COMPILES ^ULDA R; LDB W; RSD S^L.
.FILL
.SP
.FORMAT B
113\* ^CLNG\/LENGTH OF STRING.}"(/Q) = STRING DESCRIPTOR ADDRESS.
/NUMBER OF CHARACTERS BETWEEN BASE AND WRITE POINTERS (I.E. NUMBER
OF CHARACTERS OF USEFUL INFORMATION) RETURNED IN /A.
/T_^CLENGTH(/S) COMPILES ^ULNG S; STA T^L.
.FILL
.SP
.FORMAT B
114\+ ^CRSR\/RESET STRING READ POINTER.}"/SAME AS ^CRSD FOR READ POINTER
ONLY.}"^CSETR(/S,/R) COMPILES ^ULDA R; RSR S^L.
.FILL
.SP
.FORMAT B
115\+ ^CRSW\/RESET STRING WRITE POINTER.}"/SAME AS ^CRSR FOR WRITE
POINTER.}"^CSETW(/S,/W) COMPILES ^ULDA W; RSW S^L.
.FILL
.SP
.FORMAT B
116\+ ^CESC\/ESTABLISH STRING CONSTANT.}"(/Q) AS FOR ^CISD.
/THE WORD AFTER THE ^CESC CONTAINS A CHARACTER COUNT; THE FOLLOWING WORDS
THE CHARACTERS PACKED THREE PER WORD.
/THE STRING DESCRIPTOR IS SET TO POINT TO THIS STRING, AND CONTROL RETURNS
TO THE WORD FOLLOWING THE LAST WORD OF THE STRING.
/S_"/A/B/C/D" COMPILES ^UESC S; DATA 4; ASC 2,ABCD^L.
.FILL
.SP
.FORMAT B
117\}"^CCEA\/COMPUTE EFFECTIVE ADDRESS FOR PAGED OBJECT.}"(/Q) =
DRUM ADDRESS.}"/CORE ADDRESS OF OBJECT RETURNED IN /X.}"/A PRESERVED,
/B DESTROYED.
/THE VALIDITY OF THE CORE ADDRESS IS GUARANTEED ONLY UNTIL THE NEXT 
PAGED STORAGE ^CPOP.}"/USE ^CCEAS IF OBJECT IS TO BE MODIFIED.
/A_/P./X COMPILES ^UCEA P; LDA X.2; STA A^L.
.FILL
.SP
.FORMAT B
120\}"^CCEI\/COMPUTE EFFECTIVE ADDRESS, INDEXED.}"/SAME AS ^CCEA
EXCEPT THAT (/A) IS ADDED TO (/Q) TO GET DRUM ADDRESS.
/USE ^CCETS IF OBJECT IS TO BE MODIFIED.
/A_/P[/I] COMPILES ^ULDX I; CEI P; LDA 0,2; STA A^L.
.FILL
.SP
.FORMAT B
121\}"^CCEAS\/COMPUTE EFFECTIVE ADDRESS FOR ABOVE.}"/SAME AS ^CCEA, BUT
FOR STORING INTO OBJECT.}"/P./X_/A COMPILES ^ULDA A; CEAS P; STA X.2^L.
.FILL
.SP
.FORMAT B
122\}"^CCEIS\/COMPUTE EFFECTIVE ADDRESS, INDEXED INTO ARRAY.
/P[/I]_/A COMPILES ^ULDA A; LDX J; CEIS P; STA 0,2^L.
.FILL
.SP
.FORMAT B
123\}"^CRCAL\/RECURSIVE CALL ENTRY.}"/Q (^INOT (/Q)) GIVES NUMBER OF
CELLS TO ALLOCATE ON STACK FOR ARGUMENTS AND ^CSAVE^ED VARIABLES.
^URECURSIVE FUNCTION F(X,Y); SAVE Z^L COMPILES ^USTA RECRG1; LDA 0;
RCAL 3; LDA X; STA 2,2; LDA Y; STA 3,2; LDA Z; STA 4,2; LDA RECRG1;
STA X; STB Y^L.
.FILL
.SP
.FORMAT B
124\}"^CRRET\/RECURSIVE FUNCTION EXIT.}"/REMOVES BLOCK FROM STACK AND
RETURNS.
.FILL
.SP
.FORMAT B
125\}"^CDBLX\/DOUBLE /X REGISTER.}"/USED FOR FLOATING POINT ARRAYS.
/IF /A IS A ^CREAL ^CARRAY, THEN /B_/A[/I] COMPILES ^ULDX I; DBLX;
LDP* /A; STP B^L.
.FILL
.SP
.FORMAT B
126\}"^CROUT\/REAL OUTPUT.}"(/Q),(/Q+1) IS THE NUMBER.}"(/A) = FILE,
(/B) = FORMAT.}"^CROUT(/R,/N,/Q) COMPILES ^ULDA N; LDB Q; ROUT R^L.
.FILL
.SP
.FORMAT B
127\}"^CCRS\/CONVERT REAL TO STRING.}"(/Q),(/Q+1) IS THE NUMBER.
(/A) = STRING DESCRIPTOR ADDRESS, (/B) = FORMAT.
^CCRS(/R,/S,/Q) COMPILES ^ULDA S; LDB Q; CRS R^L.
.FILL
.EJ
.CE
^CAPPENDIX /B
.SP 3
.UNDERLINE
/RESERVED /WORDS
.SP 2
.LINE LAYOUT 15,75,3,1
^UAND

APPEND

ARRAY

BCOPY

BGET

BINARY

BPUT

BRS

BY

CIN

CLOSE

CLOSALL

CNS

CODE

COUT

CRLF

CRS

CSN

CSR

DECLARE

DO

ELSE

ELSEIF

END

ENDFOR

ENDIF

ENTRY

EOR

EXIT

EXTERNAL

FIELD

FIX

FIXED

FLOAT

FMASK

FOR

FREE

FROM

FSHIFT

FUNCTION

GC

GCD

GCI

GOTO

HALT

IDENT

IF

IIN

INCLUDE

INFILE

INITIALIZE

INNAME

INTEGER

IOUT

LCY

LENGTH

LINK

LIST

LOCAL

LOCK

LSH

MACRO

MAKE

MOD

NOLIST

NOT

OR

OUTFILE

OUTNAME

PAGED

PARAMETER

PFLUSH

PMAKE

POP

RCY

REAL

RECURSIVE

RETURN

RIN

ROUT

RSH

SAVE

SBRM

SCALAR

SCOPY

SETARRAY

SETR

SETS

SETUP

SETW

SOURCE

SOUT

SRETURN

STRING

TO

UNLOCK

WCD

WCI

WHERE

WHILE

WIN

WOUT^L
.LINE LAYOUT 15,75,1,0
.EJ
.CE
^CAPPENDIX /C
.SP 3
.UNDERLINE
/STANDARD /EXTERNAL /SYMBOLS
.SP 2
.FORMAT C
^CBSTORG\/FIRST WORD OF STORAGE AVAILABLE TO ^CINIT.
.FILL
.SP
.FORMAT C
^CEARRAY\/LAST WORD NOT USED FOR PAGE BUFFERS OR TABLES AFTER ^CINIT.
.FILL
.SP
.FORMAT C
^CERROR\/ERROR CODES LEFT HERE BY ^CINFILE AND ^COUTFILE.
.FILL
.SP
.FORMAT C
^CESTORG\/LAST WORD OF STORAGE AVAILABLE TO ^CINIT.
.FILL
.SP
.FORMAT C
^CFTYPE\/FILE TYPE LEFT HERE BY ^CINFILE AND ^COUTFILE.
.FILL
.SP
.FORMAT C
^CNPB\/NUMBER OF CORE BUFFERS FOR PAGING.}"0 = ALL AVAILABLE SPACE.
.FILL
.SP
.FORMAT C
^CNPC\/DESIRED SIZE OF DRUM ADDRESS SPACE (2^^^CNPL).
^CNPG<=2^^(19-^CNPL).}"0 = PAGING WILL NOT BE USED.
.FILL
.SP
.FORMAT C
^CNUP\/NUMBER OF UNLOCKED PAGES.
.FILL
.SP
.FORMAT C
^CPADDR\/DRUM ADDRESS OF UNLOCKED PAGE.
.FILL
.SP
.FORMAT C
^CPCAT\/CATEGORY TO BE USED BY ^CPMAKE.}"0 = DON'T CARE.
.FILL
.SP
.FORMAT C
^CPM\>=0:}"USE ^CNRH FOR PAGING LOGIC.}"4/B7: USE FILE ^/$^CQPDATA.
4/B7+/F:}"USE FILE NO. /F.}"/ANY OF THE ABOVE + 2/B7:}"RECOVER OLD STATE
FROM FILE.
.FILL
.SP
.FORMAT C
^CSARRAY\/ADDRESS OF SECOND WORD NOT USED FOR PAGE BUFFERS OR TABLES
AFTER ^CINIT.
.FILL
.EJ
.CE
^CAPPENDIX /D
.SP 3
.UNDERLINE
^CBNF /SYNTAX OF ^CQSPL
.SP
.FORMAT D
<EXPR>\<XWHR> $('& <XWHR>);
.FILL
.SP
.FORMAT D
<XWHR>_<XFORX> [^CWHERE <XFORX>];
.FILL
.SP
.FORMAT D
<XFORX>\<XCOND> $(^CFOR <XFORC> ^/ ^CWHILE <XWHILE>);
.FILL
.SP
.FORMAT D
<XFORC>\<IDENTIFIER> ('= ^/ '_) <XCOND> ([ ', <XCOND>] ^CWHILE <XCOND>
^/ [^CBY <XCOND>] ^CTO <XCOND>);
.FILL
.SP
.FORMAT D
<XWHILE>\<XCOND>;
.FILL
.SP
.FORMAT D
<XOR>\<XAND> $(^COR <XAND>);
.FILL
.SP
.FORMAT D
<XAND>\<XNOT> $((^CAND ^/ ^CEOR) <XNOT>);
.FILL
.SP
.FORMAT D
<XNOT>\[^CNOT] <XREL>;
.FILL
.SP
.FORMAT D
<XREL>\<XMOD> [('= ^/ '# ^/ '> ^/ '>= ^/ '< ^/ '<=) <XMOD>];
.FILL
.SP
.FORMAT D
<XMOD>\<XADD> $(^CMOD <XADD>);
.FILL
.SP
.FORMAT D
<XADD>\<XMUL> $(('_ ^/ '-) <XMUL>);
.FILL
.SP
.FORMAT D
<XMUL>\<XSIGN> $(('* ^/ '^/ ^/ ^CLSH ^/ ^CRSH ^/ ^CLCY ^/ ^CRCY)
<XSIGN>);
.FILL
.SP
.FORMAT D
<XSIGN>\['+ ^/ '- ^/ ^CGOTO] <XTAIL> ^/ (^CRETURN ^/ ^CSRETURN)
<XSGN17>;
.FILL
.SP
.FORMAT D
<XSGN17>\[<XOR> ', <XOR> '. <XOR> ^/ <XOR> '. <XOR> ^/ <XOR>]
[^CFROM <XTAIL>];
.FILL
.SP
.FORMAT D
<XFC>\<XTAIL> ['( <XFCN> ')];
.FILL
.SP
.FORMAT D
<XFCN>\[<EXPR> $(', <EXPR>)] [': [<FAILURE>] [': [<IDENTIFIER>]
$('. [<IDENTIFIER>])];
.FILL
.SP
.FORMAT D
<FAILURE>\<IDENTIFIER> ^/ (^CRETURN ^/ ^CSRETURN) [<XOR>];
.FILL
.SP
.FORMAT D
<XTAIL>\<XREF> $(('. ^/ '$) <GFIELD>) [<XSUBS>] ['_ <XOR>];
.FILL
.SP
.FORMAT D
<XREF>\$('$) ['@] <XPRIM> <XSUBS>;
.FILL
.SP
       COMMON SYSCALLS;

* MCALL DECLARATIONS

        MACRO ARBMC← UNKNOWN MONITOR ;
       MACRO INTMC← INTEGER MONITOR ;
       MACRO STMC← STRING MONITOR ;
       MACRO LNMC← LONG MONITOR ;
       MACRO LNLNMC← LONGLONG MONITOR ;

* CALLS TO MANIPULATE MIBS AND SIBS
        INTMC CREATE'MIB←190;
       ARBMC READ'MIBOB'INDEX←0;
       ARBMC READ'MIBOB'NAME←1;
       ARBMC SET'MIBOB'NAME←2;
       ARBMC SET'MIBOB'ACCESS←3;
       ARBMC SET'LOCK'LIST←4;
       ARBMC DELETE'MIBOB←5;
       INTMC CREATE'MIBOB←6;
       ARBMC SET'MIB'ACCESS←10;
       INTMC READ'MIB'ACCESS←11;
       ARBMC SET'MIBOB'VALUE←12;
       INTMC COPY'MIBOB←14;* UNIMPLEMENTED
       ARBMC SET'NO'CHARGE←15;*** ???
       INTMC READ'MIB'SPACE←16;
       ARBMC SET'FILE'LOCK←18;*?* UNIMPLEMENTED
       ARBMC SET'DURABILITY←28;*** ???

* OFT CALLS
        INTMC MOPEN'FILE←19;
       ARBMC MREAD'OFT←20;
       ARBMC SET'OFT'AL←21;
       INTMC MSET'OFT'CL←22;
       ARBMC SET'FILE'LENGTH←23;* IMPROVE THIS FOR UTS
       INTMC CR'FILE'PAGE←24;
       INTMC DEL'FILE'PAGE←25;
       INTMC NEXT'FILE'PAGE←26;
       ARBMC MOVE'PAGE'PMT←27;

* PMT CALLS
        INTMC ACQUIRE'PMT←50;
       ARBMC NEW'PMT'PAGE←51;
       ARBMC CLEAR'PMT←53;
       ARBMC DELETE'PMT←54;
       ARBMC SET'PMT'AL←55;
       ARBMC SET'PMT'CL←56;
       ARBMC SET'PMT'RO←57;
       ARBMC READ'PMT←58;

* WORKING SET CALLS
        ARBMC PUT'PAGE'DWS←65;
       ARBMC PUT'PAGE'CWS←66;
       INTMC DEL'PAGE'DWS←67;
       INTMC DEL'PAGE'CWS←68;
       INTMC READ'LWS←70;
       ARBMC SET'LWS←71;

* SPT CALLS
        INTMC MCREATE'SP←90;
       ARBMC MDESTROY'SP←91;
       ARBMC MREAD'SPT←95;
       ARBMC READ'SPCS←96;
       INTMC MRD'SPT'FIELD←97;
       ARBMC MST'SPT'FIELD←98;
       ARBMC READ'MAP←99;
       ARBMC SET'MAP←100;
       INTMC READ'MAP'BYTE←101;
       ARBMC SET'MAP'BYTE←102;
       INTMC READ'SPS'PARAM←106;

* SPCS CALLS
        ARBMC SP'CALL←111;
       ARBMC SP'JUMP←112;
       ARBMC SP'TRAP←113;
       ARBMC TRAP'RETURN←114;
       ARBMC SP'BRANCH←115;
       ARBMC SP'RETURN←116;
       ARBMC JUMP'RETURN←117;
       ARBMC MARK'CALL←118;
       ARBMC DELETE'CALL←119;
       ARBMC MODIFY'CALL←120;

* PROCESS CALLS
        INTMC COPY'PMT'PROC←130;
       INTMC ACTIVATE'PROC←132;
       ARBMC TRANSFER'TERM←133;
       ARBMC MAKE'DORMANT←134;
       ARBMC INIT'PROC'PAGE←135;
       ARBMC INIT'PROC'MAP←136;
       ARBMC INIT'SPT←137;
       INTMC READ'PROC'PARAM←211;

* IWS CALLS
        ARBMC SET'PROC'INT←163;
       ARBMC QUIT'BLOCK←164;
       INTMC GET'INT'NO←165;
       ARBMC READ'ICT←166;
       ARBMC ALLOW'INTS←168;
       ARBMC REFUSE'INTS←169;
       ARBMC BLOCK←170;
       ARBMC SET'ICT←172;
       ARBMC SET'ICT'CL←173;
       INTMC ACQUIRE'ICT←174;

* CHIO CALLS
        ARBMC SET'LINE'FIELD←180;
       ARBMC READ'LINE'TABLE←181;
       ARBMC READ'STRING'BRK←182;
       ARBMC WRITE'STRING←183;

* MISCELLANEOUS
        LNMC READ'CLOCK←210;

* UCALL DECLARATIONS

        MACRO ARBUC← UNKNOWN UTILITY ;
       MACRO INTUC← INTEGER UTILITY ;
       MACRO CHRUC← CHARACTER UTILITY ;
       MACRO STUC← STRING UTILITY ;
       MACRO LNUC← LONG UTILITY ;

* MISCELLANEOUS UCALLS
        ARBUC BREAK'POINT←0;*             UCALL FOR DEBUGGING PROGRAMS
       STUC ERRORMSG←1;*                RETURN SYSTEM ERROR MESSAGE
       STUC GET'PARAM←2;*               STRIP PARAMETER FROM STRING
       STUC GET'COM'LINE←3;*            GET CURRENT COMMAND LINE FROM UTS
       INTUC ABRV'LKP←4;*                LOOK UP ABBREVIATED NAME IN STARY
       INTUC CON'ABRV'LKP←5;*            CONTINUE SAME IN NEW STARY

* FILE SYSTEM CALLS
        ARBUC NAME'SEARCH←10;*            CONVERT FILE ST TO UTS NAME
       ARBUC SPECIAL'SEARCH←11;*         VARIATION OF ABOVE
       INTUC CONV'NAME←12;*              CONVERT FROM UTS TO MON FILE NAME
       ARBUC SPREAD'NAME←13;*            SPLIT FILE NAME STRING INTO COMP.
       ARBUC READ'MIBOB'VALUE←14;*       READ 'VALUE' OF MIB OBJECT
       ARBUC DELETE'FILE←15;*            DELETE FILE AND CONTENTS
       INTUC OPEN'FILE←16;*              OPEN FILE W/WO LOCKING
       ARBUC CLOSE'FILE←17;*             CLOSE AND UNLOCK FILE
       ARBUC READ'OFT←18;*               READ OFT
       INTUC READ'OFT'FIELD←19;*         READ OFT FIELD
       ARBUC SET'OFT'CL←20;*             SET OFT CONTROL LOCK
       ARBUC CONV'KEY←21;*               CONVERT DEFAULT ACCESS KEY

* EXTENDED SPS CALLS
        INTUC CREATE'SSP←30;*             CREATE SUBSIDIARY SUB-PROCESS
       INTUC CREATE'PSP←31;*             CREATE PARALLEL SUB-PROCESS
       ARBUC ATTACH←32;*                 ATTACH PI FILE TO SUB-PROCESS
       ARBUC DESTROY'SP←33;*             DESTROY SUB-PROCESSES
       ARBUC READ'SPT←34;*               READ SPT
       INTUC READ'SPT'FIELD←35;*         READ SPT FIELD
       ARBUC SET'SPT'FIELD←36;*          SET SPT FIELD
       STUC READ'SPNAME←37;*            READ SUB-PROC NAME
       ARBUC SET'SPNAME←38;*             SET SUB-PROC NAME
       INTUC SPNAME'SEARCH←39;*           LOOK UP SP NAME

* CIOS MANIPULATION
        INTUC CREATE'CIOS←40;*            CREATE CONTROL I/O STREAM
       INTUC READ'CIOS'FIELD←41;*        READ CIOS FIELD
       ARBUC SET'CIOS'FIELD←42;*         SET (SOME) CIOS FIELDS
       ARBUC SET'CIOS'INPUT←43;*         SET UP FOR INPUT
       ARBUC SET'CIOS'OUTPUT←44;*        SET UP FOR OUTPUT

* CIOS INPUT/OUTPUT
        ARBUC PRINT'STRING←45;*           WRITE STRING ON CIOS
       ARBUC PRINT'CHAR←46;*             WRITE (= BUFFER) CHAR ON CIOS
       ARBUC START'OUTPUT←47;*           DUMP OUTPUT BUFFER
       STUC READ'LINE←48;*              READ NEXT INPUT LINE
*STUC      EDIT'LINE ← 49;*              EDIT CURRENT LINE
        CHRUC READ'CHAR←50;*              READ NEXT CHARACTER
       ARBUC BLOCK'OB'EMPTY←51;*         WAIT UNTIL OUT BUFFER IS EMPTY

* USER, ACCOUNT, AND GROUP PROFILES
        STUC READ'UP'ITEM←60;*           READ ITEM FROM USER PROFILE
       STUC READ'UP'NAMES←61;*          READ NAMES OF UP ITEMS
       ARBUC SET'UP'ITEM←62;*            SET (CREATE) VALUE OF UP ITEM
       ARBUC SET'UP'ACCESS←63;*          SET ACCESS TO UP ITEM
       LNUC FIND'MIB←64;*               CONVERT USER NAME/NUMBER TO MIB ADDR
       ARBUC CREATE'UP'ENTRY←65;*        CREATE USER/UP ENTRY
       ARBUC DELETE'UP'ENTRY←66;*        DELETE USER/UP ENTRY

* PROCESSES, AND PROCESS PROFILE
        ARBUC CREATE'PROCESS←70;*         CREATE/INITIALIZE PROCESS
       STUC READ'PP'ITEM←71;*           READ ITEM FROM PROCESS PROFILE
       STUC READ'PP'NAMES←72;*          READ NAMES OF PP ITEMS

        ARBUC SET'PP'ITEM←73;*            SET (CREATE) VALUE OF PP ITEM
       COMMON DECDECS;
*
* SHORT DECLARATION MACROS FOR SPL
*

        MACRO INT← DECLARE INTEGER ;
       MACRO OCT← DECLARE OCTAL ;
       MACRO PTR← DECLARE POINTER ;
       MACRO CHR← DECLARE CHARACTER ;
       MACRO ST← DECLARE STRING ;
       MACRO LN← DECLARE LONG ;
       MACRO LNLN← DECLARE LONGLONG ;
       MACRO LB← DECLARE LABEL ;

        MACRO OCTFL← DECLARE OCTAL FIELD ;
       MACRO INTFL← DECLARE INTEGER SIGNED FIELD ;
       MACRO PTRFL← DECLARE POINTER FIELD ;
       MACRO CHRFL← DECLARE CHARACTER FIELD ;
       MACRO STFL← DECLARE STRING FIELD ;
       MACRO LNFL← DECLARE LONG FIELD ;
       MACRO ARYFL← DECLARE ARRAY FIELD ;
       MACRO FNFL← DECLARE FUNCTION FIELD ;

        MACRO INTARY← DECLARE INTEGER ARRAY ;
       MACRO OCTARY← DECLARE OCTAL ARRAY ;
       MACRO PTRARY← DECLARE POINTER ARRAY ;
       MACRO CHRARY← DECLARE CHARACTER ARRAY ;
       MACRO STARY← DECLARE STRING ARRAY ;
       MACRO LNARY← DECLARE LONG ARRAY ;
       MACRO LBARY← DECLARE LABEL ARRAY ;
       MACRO FLARY← DECLARE FIELD ARRAY ;
       MACRO FNARY← DECLARE FUNCTION ARRAY ;

        MACRO INTARY1← DECLARE INTEGER ARRAYONE ;
       MACRO PTRARY1← DECLARE POINTER ARRAYONE ;

        MACRO INTFN← DECLARE INTEGER FUNCTION ;

        MACRO ARBENT← UNKNOWN ENTRY ;
       MACRO INTENT← INTEGER ENTRY ;
       MACRO OCTENT← POINTER ENTRY ;
       MACRO PTRENT← POINTER ENTRY ;
       MACRO CHRENT← CHARACTER ENTRY ;
       MACRO STENT← STRING ENTRY ;
       MACRO LNENT← LONG ENTRY ;
       MACRO LBENT← LABEL ENTRY ;
       MACRO ARYENT← ARRAY ENTRY ;

        MACRO ARBEXT← DECLARE UNKNOWN EXTERNAL ;
       MACRO INTEXT← DECLARE INTEGER EXTERNAL ;
       MACRO OCTEXT← DECLARE OCTAL EXTERNAL ;
       MACRO PTREXT← DECLARE POINTER EXTERNAL ;
       MACRO CHREXT← DECLARE CHARACTER EXTERNAL ;
       MACRO STEXT← DECLARE STRING EXTERNAL ;
       MACRO LNEXT← DECLARE LONG EXTERNAL ;
       MACRO LBEXT← DECLARE LABEL EXTERNAL ;
       MACRO ARYEXT← DECLARE ARRAY EXTERNAL ;

        MACRO C'(X)←;* KLUDGE FOR INTERNAL COMMENTS

        MACRO LTABLE(F)←F$FLDWDSP+1;
       INTFL FLDWDSP(0:13,23);

* LENGTHS OF NAMES
        INT LMN←4,LTY←1,LFN←LMN+LTY;
       INT NBY←4,LNCH←24/NBY,NMNCH←LMN*NBY,
        NTYCH←LTY*NBY,NFNCH←LFN*NBY,NCMCH←90;

       COMMON SYS'COMMON; INCLUDE SYSCALLS;

*
* MCALLS, UCALLS, & GLOBAL CELLS
*

        DECLARE INTEGER QUIT'FLAG;* GLOBAL QUIT FLAG
       DECLARE INTEGER QUIT'FCN'FLAG;* GLOBAL QUIT FUNCTION FLAG
       DECLARE INTEGER ERMSNO;* SYSTEM ERROR NUMBER
       DECLARE CHARACTER ERCODE;* SYSTEM ERROR CODE

       COMMON MACHINE'DECS; INCLUDE DECDECS;
*
* DECLARATIONS FOR MACHINE-DEPENDENT PROGRAMMING
*

* LOW-G DEFINITIONS
        PTR STACK'PTR= G' [2],STACK'LIM= G' [3],
        RTRAP'PARAM= G' [5],RTRAP'LOC= G' [4];

* FIELDS IN BLL DESCRIPTOR
        PTRFL BRDPC(0:6,23),BRDLR(1:6,23);

* STATE DEFINTIONS
        INT PSTLOC←0,ASTLOC←1,BSTLOC←2,CSTLOC←3,DSTLOC←4,
        XSTLOC←6,LSTLOC←7,GSTLOC←8,ESTLOC←5,SSTLOC←9,
        LSTATE←10;

* FIELDS FOR TRAP DEFINITIONS
        PTRFL ADDR(0:6,23);OCTFL SP'TNO(-2),SP'TPAR(-1),
        BLL'CLASS(0:3,5),UTSE'CLASS(0:0,1),
        UTSE'SPTNO(0:1,5),UTSE'RTNO(0:2,5);

       COMMON COMDECS; INCLUDE DECDECS,SYS'COMMON;
*
* COMMON DECLARATIONS FOR CODING
*

* GENERALLY USEFUL MACROS

        MACRO NAMSET(S,L,A,B)←SETUP(S,L,A,B)&S$WP←S$EP;
       MACRO EMPTY(S)←LNGDES(S$RP,S$WP)<=0;*** WP=RP OR WP=BP?
       MACRO REPEAT← WHILE 1 DO ;
       MACRO ENDRPT← ENDFOR ;
       MACRO FDISP(F)←RUNTIME'FAILURE() IF F$FLDSTB#0 OR
        F$FLDSIZE#24 ELSE F$FLDWDSP;
       OCTFL FLDSTB(0:8,12),FLDSIZE(0:3,7);

* ERROR MACROS
        MACRO NC'PUNT←RUNTIME'FAILURE();* FOR NORMAL CALLS (EXPRESSIONS)
       MACRO LF'PUNT← VALUE NC'PUNT;* FOR LIBRARY FUNCTIONS
       MACRO SF'PUNT←LF'PUNT:ERCODE,ERMSNO;* FOR SYSTEM CALLS

* QUIT ACTION MACROS
        MACRO QUIT'PUNT(L)← VALUE GOTO L IF ERCODE='QIT' ELSE
        RUNTIME'FAILURE():ERCODE,ERMSNO;
       MACRO QUIT'PUNTX(L,X)← VALUE GOTO L IF ERCODE='QIT' ELSE
        RUNTIME'FAILURE():X,ERCODE,ERMSNO;

* PARAMETRIC CHARACTER DEFINITIONS
        CHR SCHERALD←'>' C'(/* SUB-COMMAND HERALD */),
        BELCH←303B C'(/* BELL */),NULCH←300B C'(/* NULL */),
        NLCH←307B C'(/* NEW LINE */),
        LFCH←310B C'(/* LINE FEED */),
        MBCH←200B C'(/* ZERO MULTIPLE BLANKS */),
        SQTCH←'&'' C'(/* SINGLE QUOTE */),
        DQTCH←'"' C'(/* DOUBLE QUOTE */),
        SEPCH←'-' C'(/* SEPARATOR */);

* STRING POINTER FIELDS
        OCTFL BP(0)C'(/* BEGINNING */),RP(1)C'(/* READER */),
        WP(2)C'(/* WRITER */),EP(3)C'(/* END */);
* CHARACTER FIELDS
        CHRFL CH0(0:0,7),CH1(0:8,15),CH2(0:16,23);
* BEAD LENGTH FIELD
        PTRFL LENGF(-1:6,23);

* FIELDS IN UTILITY FILE NAME
        LNFL UFNUN(0)C'(/* USER NUMBER/DISK ADDRESS */);
       OCTFL UFNEN(2)C'(/* OBJECT ENTRY-NUMBER */),
        UFNFN(3)C'(/* FILE NAME */),UFNMN(3)C'(/* MAIN NAME */),
        UFNTY(3+LMN)C'(/* TYPE WORD */);

* FIELDS FOR UNO/DKA
        OCTFL UNDKUN(0),
        UNDKDK(1);

        INT LUFN←LTABLE(UFNTY);* LENGTH OF UTILITY FILE:NAME

        INT CB'PMT←1;* PMT ADDRESS OF CONTEXT BLOCK

* DECLARATIONS OF COMMON FUNCTIONS

* SPL RUNTIME FUNCTIONS
*ARBEXT    SCOPY, APPEND, CNS, RUNTIME'FAILURE;
        LBEXT LABEL'KLUDGE;ARYEXT LBARY'KLUDGE;*, AR'DESC;
       PTREXT SBASE;INTEXT ARRAYUB,ARRAYLB;* STEXT ST'DESC;
       LNEXT LONG'ADD,LONG'SUB;INTEXT LONG'LE,LONG'LT;

* STORAGE ALLOCATOR
        PTREXT STKMAKE;*, MAKE, SETZONE;
*ARBEXT    STORINIT, SELZONE, EXTZONE, FREE, FREEZONE;

       COMMON UQNDECS; INCLUDE DECDECS;

* UNIQUE NAME FIELDS
        OCTFL UQNTY(0:0,1),UQNPMB(0:0,0),UQNLFB(0:1,1),
        UQNOWN(0:2,17),UQNHFN(0:18,23);
       OCTFL UQNLFN(1:0,12),UQNLPN(1:13,23),
        UQNSFN(1:0,15),UQNSPN(1:16,23);

       COMMON BFSDECS; INCLUDE UQNDECS;

* OBJECT TYPE-CODES
        INT SIBSFCD←0,SIBLFCD←1,SIBPRCD←2,SIBAKCD←3,
        SIBRSCD←4,SIBOWCD←5,SIBFRCD←6,
        SIBSCCD←14,SIBLKCD←15;

* ACCESS KEY FIELDS
        OCTFL ACK0(0),ACK1(1:0,7),ACKUN(1:8,23);
       INT NORM'FIL'AC←0357B;* P(NO) F(RW) O(OW) - NORMAL ACCESS

       COMMON OFTDECS; INCLUDE BFSDECS;

* FIELDS IN OFT
        OCTFL OFTUB(0:0,0),OFTRB(0:1,1),OFTWB(0:2,2),OFTXB(0:3,3),
        OFTOB(0:4,4),OFTMIX(0:6,12),
        OFTAL(0:15,23);* BETTER CHECK THIS WITH REVISION

        OCTFL OFTCL(1:15,23),
        OFTOT(2:0,3),OFTPIB(2:8,15),OFTPMIB(2:16,23);
       LNFL OFTUN(3);

        INT NOFT←16,LOFT←LTABLE(OFTUN)+1;


       COMMON SIBDECS; INCLUDE BFSDECS;
*
* DECLARATIONS FOR SIB
*

* FIELDS IN SIB NAME (SIBN)
        OCTFL SIBNOT(0:1,4),
        SIBNLN(0:10,23),
        SIBNAA(1:1,4),SIBNEN(1:10,23),
        SIBNMN(2),SIBNFN(2);
       OCTFL SIBNTY(SIBNMN$FLDWDSP+LMN),
        SIBNLL(SIBNTY$FLDWDSP+1:4,11),
        SIBNAC(SIBNLL$FLDWDSP:12,23);
       OCTFL SIBNPA(SIBNAC$FLDWDSP:12,15),
        SIBNFA(SIBNAC$FLDWDSP:16,19),
        SIBNOA(SIBNAC$FLDWDSP:20,23);

        INT LSIBN←LTABLE(SIBNOA);* LENGTH OF SIBN TABLE

* FIELDS IN SIB VALUE (SIBV)
        OCTFL SIBVOT(0:1,4),
        SIBVLN(0:10,23),
        SIBVAA(1:1,4),SIBVEN(1:10,23);
       LNFL SIBFLUN(2);
       OCTFL SIBFLLEN(4),
        SIBFLWD(5),
        SIBFLRD(6);

        LNFL SIBLKUN(2);
       OCTFL SIBLKEN(4),
        SIBLKMN(5),
        SIBLKTY(5+LMN);

        INT LSIBFL←LTABLE(SIBFLRD),LSIBLK←LTABLE(SIBLKTY),
        LSIBV←(LSIBFL IF LSIBFL>LSIBLK ELSE LSIBLK);
       INT MLSIB←(LSIBV IF LSIBV>LSIBN ELSE LSIBN);

       COMMON PMTDECS; INCLUDE UQNDECS;

* FIELDS FOR PMT ENTRY
        LNFL PMTUN(0);
       OCTFL PMTFL(2:0,0),PMTDKA(2:2,23),
        PMTRO(3:0,0),PMTAL(3:3,11),PMTCL(3:15,23);

        INT NPMT←128;* NUMBER OF PMT ENTRIES
       INT LPMT←5;* SIZE OF PMT ENTRY

* FIELDS IN APT
        OCTFL APTUH(0:0,7),
        APTPGL(0:8,11),
        APTDWS(0:12,12),
        APTCWS(0:13,13),
        APTKEEP(0:14,14),
        APTLOCK(0:15,15),
        APTPMTX(0:16,23);


       COMMON SPTDECS; INCLUDE DECDECS;

* FIELDS IN SPCS
        OCTFL SPCSNIS(0:0,0),SPCSNIC(0:1,1),
        SPCSCSP(0:2,5),SPCSPR(0:6,23),
        SPCS940M(1:0,0),SPCSR0SP(1:2,5),SPCSLR(1:6,23),
        SPCSR1SP(2:2,5),SPCSGR(2:6,23);
       LNFL SPCSIT(3);
       INT LSPCS←LTABLE(SPCSIT)+1;

        INT NSPT←8;

       COMMON ATTACHDECS; INCLUDE DECDECS;
*
* DEFINITION OF ATTACH (PI) FILE HEADER
*
        OCTFL ATFMT(0),ATNP(1),ATMAP(3),ATMNM(38),
        ATCUF(43),ATEP(44),ATEG(45);
       OCTFL BYTEC(0:12,13),BYTEP(0:16,23);

        INT FMTCODE←0;* VALUE OF CURRENT FORMAT

       COMMON ICTDECS; INCLUDE DECDECS;

* FIELDS IN ICT
        OCTFL ICTSRC(0:0,2)C'(/* SOURCE */),
        ICTACT(0:3,5)C'(/* ACTION */),
        ICTSPEC(0:6,10)C'(/* SUB-PROCESS/TRAP */),
        ICTBLK(0:11,11)C'(/* BLOCKING */),
        ICTCL(0:15,23)C'(/* CONTROL LOCK */);
       LNFL ICTTM(1);* REAL/COMPUTE TIME VALUE

        INT NICT←24,LICT←LTABLE(ICTTM)+1;

* VALUES FOR SOURCE-ACTION-BLOCK PARAMETER OF SET'ICT
        MACRO ICT'SAB(S,A,B)←S@ICTSRC V' A@ICTACT V' B@ICTBLK;
       INT ICTNULCD←ICT'SAB(0,0,0)C'(/* NULL */),
        ICTBLKCD←ICT'SAB(1,0,1)C'(/* BLOCKING */),
        ICTTRPCD←ICT'SAB(1,2,1)C'(/* TRAP */),
        ICTRTICD←ICT'SAB(2,1,1)C'(/* REAL-TIME INTERRUPR */);

       PROGRAM LABEL'KLUDGE; INCLUDE DECDECS;
*
* CONVERT SOURCE RELATIVE LABEL TO ABSOLUTE
*
        LB L;LBARY A;

        LBENT LABEL'KLUDGE(L); RETURN L;

        ARYENT LBARY'KLUDGE(A); RETURN A;

       PROGRAM LONG'COMPARE; INCLUDE DECDECS;
*
* COMPARE LONG VALUES
*
        PTR P,Q;INT N;
       DECLARE INTEGER FIELD W0(0);

        INTENT LONG'COMPARE( INTEGER @P, INTEGER @Q,N);

        RETURN 1 IF P[N]$W0#Q[N]$W0 FOR N←N-1 BY -1 TO 0;
       RETURN 0;

       PROGRAM SCOPY; INCLUDE COMDECS;
       PTR P;ST S,D;STFL A(0);

        ARBENT SCOPY( STRING @P,S), FRETURN ;
       D←P.A;P.RP←D$WP←D$RP←D$BP; GOTO L;

        ARBENT APPEND( STRING @P,S), FRETURN ;
       D←P.A;

****      CHECK STRING CHARACTER SIZES FOR COMPATABILITY
L:
        REPEAT;WCI(GCI(S// VALUE P.WP←D$WP& RETURN ),D// FRETURN );ENDRPT;

       PROGRAM ST'DESC; INCLUDE COMDECS;
       INT N,S,O;PTR P;ST X;
       STENT ST'DESC(N,P,S,O);

        P←MAKE(S*(N+24/S-1)/24) IF P=0;

        IF S=8 DO ;
           .LDA 44B6;
       ELSEIF S=6 DO ;
           .LDA 40B6;
       ELSEIF S=12 DO ;
           .LDA 50B6;
       ELSEIF S=24 DO ;
           .LDA 54B6;
       ELSE DO ;
           RUNTIME'FAILURE();
       ENDIF ;

        .IOR P;.XMA O;.LSHA 18;.IOR O;.LDX-1;.ASP;.CXA;
       .STA X$BP;.STA X$RP;.STA X$WP;.LDX N;.ASP;.STX X$EP;
       RETURN X;

       PROGRAM AR'DESC; INCLUDE COMDECS;
       INT N,S,O;PTR P;
       ARYENT AR'DESC(N,P,S,O);

        N←N-1 IF O=0;
       RUNTIME'FAILURE() IF S>63 OR S<1 OR S>3 AND N>17777B OR
        N>377777B OR N<O OR O#0 AND O#1;

        P←MAKE((N+1 IF O=0 ELSE N)*S) IF P=0;

        .LDA S;.SUB 1;.ICP 3;.BGT R' [3];.IOR 100B;.LSHA 6;.LSHA 11;
       .IOR N;.CPZ O;.BEQ R' [2];.IOR 1B7;.IOR 6B7;.CAB;
       .LDA P;.IOR 4B6;.XAB; RETURN ;

       PROGRAM CNS; INCLUDE COMDECS;
       INT N,F,R,T,I,D;PTR P;ST S,B(25);STFL A(0);

        ARBENT CNS(N, STRING @P,F,R), FRETURN ;

        S←P.A;
       FRETURN IF R<2 OR R>36;
       T←(-N IF F>=0 AND N<0 ELSE N);
       B$RP←B$WP←B$EP;I←0;
LP:    .LDA T;.LSHD-23;.DIV R;.STA T;.STB D;
       WCD(D+('0' IF D<10 ELSE 'A'-10),B);
       I←I+1; GOTO LP IF T#0;
       WCD('-',B)&I←I+1 IF F>=0 AND N<0;
       F←F A' 77B;
       IF F=0 DO ;
           F←I;
       ELSEIF F<=I DO ;
           B$RP←INCDES(B$EP,-I);
       ELSE DO ;
           WCI(' ',S// FRETURN ) FOR I←I+1 TO F;
       ENDIF ;
       WCI(D,S// FRETURN )
        FOR D←GCI(B// VALUE P.WP←S$WP& RETURN ) WHILE 1;

       PROGRAM CSN; INCLUDE COMDECS;
       PTR P;INT R,F,D,N,FLB,FLP,PW;ST S;STFL A(0);

        INTENT CSN( STRING @P,R), FRETURN ;

        FLB←FLP←0;

AGN:    S←P.A; FRETURN IF R<2 OR R>36;

        IF D←GCI(S// FRETURN )='-' OR D='+' DO ;
           F←(1 IF D='-' ELSE 0);D←GCI(S// FRETURN );
       ELSE DO ;
           F←0;
       ENDIF ;

        D←D-'0' IF D>='0' AND D<='9' ELSE
        D←D-('A'-10) IF D>='A' AND D<='Z' ELSE FRETURN ;
       FRETURN IF D>=R;N←D;

        FOR D←GCI(S//Y)REPEAT;
           D←D-'0' IF D>='0' AND D<='9' ELSE
            D←D-('A'-10) IF D>='A' AND D<='Z' ELSE GOTO X;
           GOTO X IF D>=R;N←N*R+D;
       ENDRPT;

X:      IF R<=10 AND (D←D+'A'-10='B' OR D='D') DO ;
           IF FLB DO ;
               S$RP←INCDES(S$RP,1) IF FLP;
           ELSE DO ;
               FLB←-1;
               PW←GCI(S//Z);PW←PW-'0'&FLP←-1 IF PW>='0' AND PW<='9'
                ELSE S$RP←INCDES(S$RP,-1);
Z:             R←8& GOTO AGN IF D='B' AND R#8;
               R←10& GOTO AGN IF D='D' AND R#10;
           ENDIF ;
       ELSE DO ;
           S$RP←INCDES(S$RP,-1);
       ENDIF ;
Y:     N←N*R FOR D←1 TO PW IF FLP;
       P.RP←S$RP; RETURN (-N IF F ELSE N);

       PROGRAM SBASE; INCLUDE COMDECS;
*
* FIND BASE ADDRESS OF WORD-ORIGINED STRING DESCRIPTOR
*
        ST S;

        PTRENT SBASE(S);
       .LDA S$BP;.LDX 1;.ASP;.CXA;
       .CMZ 3B6;.BNE L;.ETR 777777B; RETURN ;
L:     RUNTIME'FAILURE();

       PROGRAM ALENGTH; INCLUDE COMDECS;
*
* COMPUTE ARRAY BOUNDS
*
        PTR A;OCTFL ABW(0);
       INTENT ARRAYUB(A);
       .LDA A.ABW;.CMZ 2B6;.BNE R' [2];.ETR 17777B;
       .ETR 377777B; RETURN ;

        INTENT ARRAYLB(A);
       .LDA A.ABW;.ETR 1B7;.ASHA-21; RETURN ;

       PROGRAM LONG'ARITH; INCLUDE COMDECS;
*
* LONG ARITHMETIC/RELATIONALS
*
        LN X,Y;OCTFL W0(0),W1(1);

        LNENT LONG'ADD(X,Y);* ADD
       .LDA X$W1,ADD Y$W1,CAB;
       .LDA X$W0,ADC Y$W0; RETURN ;

        LNENT LONG'SUB(X,Y);* SUBTRACT
       .LDA X$W1,SUB Y$W1,CAB;
       .LDA X$W0,SUC Y$W0; RETURN ;

        INTENT LONG'LE(X,Y);* LESS THAN OR EQUALS
       RETURN (1 IF LONG'SUB(X,Y)$W0<=0 ELSE 0);

        INTENT LONG'LT(X,Y);* LESS THAN
       RETURN (1 IF LONG'SUB(X,Y)$W0<0 ELSE 0);

       COMMON ALLOC'DECS;

*
* SPL STORAGE ALLOCATOR
*

* THE BASIC STRUCTURE OF A STORAGE BLOCK IS AS IN THE OLD ALLOCATOR,
* I.E. THE WORD BEFORE THE 0'TH WORD OF A BLOCK CONTAINS THE LENGTH
* OF THE BLOCK (NUMBER OF INFORMATION WORDS +1), A FLAG IN BIT 0
* TO SAY THAT THE BLOCK IS FREE, AND A FLAG IN BIT 1 TO SAY THAT
* THE NEXT LOWER BLOCK IS FREE.
        DECLARE FIELD HIDDEN(-1),HSIZE(-1:6,23),HFREE(-1:0,0),
        HFTAG(-1:1,1),HZTAG(-1:2,2);
* FREE STORAGE COMES IN ZONES.  A ZONE CONSISTS OF A ZONE HEADER
* AND A CHAIN OF EXTENSIONS.  THE ZONE HEADER CONTAINS: THE BLOCK
* SIZE FOR THE ZONE (0 MEANS ALL SIZES ARE ALLOWABLE), THE OVERFLOW
* ROUTINE, THE EXTENSION LIST, AND THE FREE LIST ROVER.
        DECLARE FIELD FEXT(0),FLIST(2),FUEXT(3), FUNCTION FIELD FOVX(1);
       DECLARE PARAMETER FZHS←4;
* THE FEXT WORD IN EACH EXTENSION POINTS TO THE NEXT ONE.  THIS CHAIN,
* IS TERMINATED BY A -1.  THE FIRST TWO WORDS
* OF A FREE BLOCK ARE USED TO HOLD THE ADDRESS OF THE NEXT FREE
* BLOCK AND THE PREVIOUS FREE BLOCK.  THIS LIST IS CIRCULAR.
        DECLARE FIELD NBLK(0),PBLK(1);
* FOR FIXED-SIZE ZONES, THE ENTIRE FREE LIST AND THE HIDDEN WORDS
* ARE SET UP AT THE TIME AN EXTENSION IS CREATED.  FOR VARIABLE-SIZED
* ZONES, AN EXTENSION IS SET UP AS A SINGLE FREE BLOCK WHICH IS
* SUBDIVIDED AS THE NEED ARISES.  A FIRST-FIT STRATEGY WITH A "ROVER"
* IS USED FOR THE LATTER.  BLOCKS BELOW A MINIMUM SIZE WILL NOT BE CREATED.
        DECLARE PARAMETER MINSIZ←3;

        DECLARE INFINITY'ZONE,CURRENT'ZONE;* ZONE VARIABLES FOR ALLOCATOR

       PROGRAM STKMAKE; INCLUDE ALLOC'DECS;
       FIXED ;
*
* ALLOCATE LOCAL (STACKED) STORAGE
*
        DECLARE SP= G' [2],SL= G' [3],BLK,SIZE;

        FUNCTION STKMAKE(SIZE);

        RUNTIME'FAILURE() IF SP+SIZE>=SL;
       SP←(BLK←SP+1)+SIZE;
       BLK.HIDDEN←SIZE+1;
       BSET(BLK,0,SIZE);
       RETURN BLK;

       PROGRAM MAKE; INCLUDE ALLOC'DECS;
*
* ASSIGN BLOCK OF SIZE (A) IN ZONE (B)
*
        DECLARE BLK,ROVER,RSIZE,EBLK,ROVEC;

        FUNCTION MAKE(SIZE,ZONE);

        ZONE←CURRENT'ZONE IF ZONE=0;
       SIZE←SIZE+1;
       GOTO MAKEOV IF ZONE.FLIST<0;
* VARIABLE-SIZED ZONE
        ROVEC←ROVER←ZONE.FLIST;
MAKE1: RSIZE←ROVER.HSIZE;
       IF RSIZE<SIZE+MINSIZ AND RSIZE#SIZE DO ;
           GOTO MAKE1 IF (ROVER←ROVER.NBLK)#ROVEC
            ELSE GOTO MAKEOV;
       ENDIF ;
       EBLK←(BLK←ROVER)+ROVER.HSIZE;
       EBLK.HFTAG←0;
       IF ROVER.HSIZE=SIZE DO ;
* EXACT FIT
            BLK.HFREE←0;
           ZONE.FLIST←RFB(ROVER,ZONE);
       ELSE DO ;
* SPLIT THE BLOCK
            BLK←EBLK-SIZE;
           BLK.HIDDEN←1@HFTAG+SIZE;
           BLK[-2]←-(ROVER.HSIZE←ROVER.HSIZE-SIZE);
       ENDIF ;
* COMMON EXIT
        BSET(BLK,0,SIZE-1);
       RETURN BLK;

* OVERFLOW
MAKEOV: BLK←(ZONE.FOVX)(SIZE-1,ZONE); RETURN BLK;

       PROGRAM RFB; INCLUDE ALLOC'DECS;
       FUNCTION RFB(RBLK,ZONE);
* SUBROUTINE TO REMOVE A BLOCK FROM THE FREELIST
        IF RBLK.NBLK=RBLK DO ;
           RETURN ZONE.FLIST←-1;
       ELSE DO ;
           RBLK.NBLK.PBLK←RBLK.PBLK;
           RETURN RBLK.PBLK.NBLK←RBLK.NBLK;
       ENDIF ;

       PROGRAM FREE; INCLUDE ALLOC'DECS;
*
* RELEASE BLOCK (A) TO ZONE (B)
*
        DECLARE EXPTR,EFB,PFB;

        FUNCTION FREE(BLK,ZONE);
       EFB←BLK+BLK.HSIZE;
       ZONE←CURRENT'ZONE IF ZONE=0;
       BLK.HFREE←1;
* VARIABLE-SIZED ZONE
* CHECK FOR MERGE WITH NEXT HIGHER BLOCK
        IF EFB.HFREE DO ;
           BLK.HIDDEN←BLK.HIDDEN+EFB.HSIZE;
           RFB(EFB,ZONE);
           EFB←BLK+BLK.HSIZE;
       ENDIF ;
* CHECK FOR MERGE WITH NEXT LOWER BLOCK
        IF BLK.HFTAG DO ;
           PFB←BLK+(BLK[-2] IF BLK[-2]<0 ELSE -3);
           PFB.HIDDEN←PFB.HIDDEN+BLK.HSIZE;
           RFB(BLK←PFB,ZONE);
       ENDIF ;
* CLEAN UP
        EFB.HFTAG←1;
       EFB[-2]←-BLK.HSIZE;
       FPB(BLK,ZONE);
       RETURN ;

       PROGRAM FPB; INCLUDE ALLOC'DECS;
* SUBROUTINE TO PUT A BLOCK ON THE FREELIST
        DECLARE ZFP,ZNBP;

        FUNCTION FPB(BLK,ZONE);
       ZFP←ZONE.FLIST;
       IF ZFP<0 DO ;
           ZONE.FLIST←BLK.NBLK←BLK.PBLK←BLK;
       ELSE DO ;
           ZNBP←ZFP.NBLK;
           ZFP.NBLK←ZNBP.PBLK←BLK;
           BLK.NBLK←ZNBP;
           BLK.PBLK←ZFP;
       ENDIF ;
       RETURN ;

       PROGRAM SELZONE; INCLUDE ALLOC'DECS;

        FUNCTION SELZONE(ZONE);
       CURRENT'ZONE←ZONE; RETURN ;

       PROGRAM STORINIT; INCLUDE ALLOC'DECS;
*
* SET UP ZONES
*

        FUNCTION STORINIT(ZONE,SIZE), FRETURN ;
       (ZONE←ZONE+1).HIDDEN←SIZE;
       SETZONE(ZONE// FRETURN );
       CURRENT'ZONE←INFINITY'ZONE←ZONE; RETURN ;

       PROGRAM SETZONE; INCLUDE ALLOC'DECS;
*
* INITIALIZE ZONE
*
        DECLARE FAREA, FUNCTION DUMBFUCN←OFLOTRAP;

        FUNCTION SETZONE(ZONE), FRETURN ;
       FRETURN IF ZONE.HSIZE<FZHS+MINSIZ+4;
       ZONE.HZTAG←1;
       ZONE.FOVX←DUMBFUCN;
       ZONE.FLIST←-1;
       ZONE.FUEXT←0;
       FAREA←ZONE+(FZHS+1);
       FAREA.HIDDEN←ZONE.HSIZE-(FZHS+1);
       EXTZONE(FAREA,ZONE// VALUE RUNTIME'FAILURE());
       ZONE.FEXT←-1; RETURN ZONE;

       PROGRAM EXTZONE; INCLUDE ALLOC'DECS;
*
* ADD EXTENSION (B) TO ZONE (A)
*
        DECLARE EEXT,EXB;

        FUNCTION EXTZONE(EXT,ZONE), FRETURN ;
       FRETURN IF EXT.HSIZE<MINSIZ+2;
       EEXT←EXT+EXT.HSIZE;
       EXT.FEXT←ZONE.FEXT;
       ZONE.FEXT←EXT;
       EXB←EXT+2;
       EXB.HIDDEN←(1@HFREE-3)+EXT.HSIZE;
       (EEXT-1).HIDDEN←1@HFTAG;
       FPB(EXB,ZONE);
       RETURN ;

       PROGRAM FREEZONE; INCLUDE ALLOC'DECS;
*
* DELETE ZONE (A)
*
        DECLARE ZEPTR;

        FUNCTION FREEZONE(ZF,ZF1);
       SELZONE(INFINITY'ZONE) IF ZF=CURRENT'ZONE;
FZONE1:ZEPTR←ZF.FEXT;FREE(ZF,ZF1);
       GOTO FZONE1 IF (ZF←ZEPTR)>=0;
       RETURN ;


       COMMON USERDECS; INCLUDE COMDECS;
*
* DECLARATIONS FOR USER PROGRAMS
*
        ST OL(NCMCH);* OUTPUT BUFFER FOR USER CONSOLE OUTPUT
       LB TRAP'LABEL;* GO HERE AFTER TRAP
       PTR INITIAL'SP←3200B,NORMAL'SL←3777B;

* OUTPUT MACROS
        MACRO IOUT()←SETS(OL,0,0);
       MACRO PTCH(C)←WCI(C,OL);
       MACRO PTST(S)←APPEND(OL,S//LF'PUNT);
       MACRO PTNO(N,F,R)←CNS(N,OL,F,R//LF'PUNT);
       MACRO PTDN(N)←PTNO(N,4B7,10);
       MACRO PTON(N)←PTNO(N,4B7,8);
       MACRO PTNL()←WCI(NLCH,OL);
       MACRO PTIS(S)←SCOPY(OL,S//LF'PUNT);


       COMMON TRAP'DECS; INCLUDE MACHINE'DECS;
       INCLUDE MACHINE'DECS;

* TRAP VARIABLES
        INT TRAP'FLAG;* FLAG INDICATING WHETHER A TRAP IS BEING PROCESSED
       PTR INSTR'LOC;* PTR TO INSTR FOLLOWING ONE CAUSING ABE TRAP
       INT SAVEL;* SAVE L-REG WHILE DOING EAC IN ABE'TRAP
       INT GSAVER;INTARY GSTATE[LSTATE],SP'GSTATE[LSTATE];* GLOBAL TRAP STATES
       INT SP'LEV;* SUBPROCESS LEVEL ON ENTRY

       PROGRAM USER'ENTRIES; INCLUDE USERDECS,TRAP'DECS;
*
* ENTRY POINTS
*
        FIXED ;

        MACRO SAVE'STATE(X)←.STX X[XSTLOC],EAX X[0],STORS,MIN TRAP'FLAG;

* COME HERE AFTER TRAP MESSAGE
T'L:    JUMP'RETURN(
        READ'SPS'PARAM('CSL'//SF'PUNT)-SP'LEV-1//T'R:ERCODE,ERMSNO);
T'R:   SP'RETURN(//SF'PUNT);

* INITIAL AND 'CONTINUE' SUBPROCESS ENTRIES
        ARBENT XXXXXX(), SP'ENTRY ←2;
       ARBENT XXXXXY(), SP'ENTRY ←3;

        .LDA INITIAL'SP,XLA;
       TRAP'LABEL←T'L;TRAP'FLAG←QUIT'FCN'FLAG←QUIT'FLAG←0;
       STACK'PTR←INITIAL'SP;STACK'LIM←NORMAL'SL;
       SP'LEV←READ'SPS'PARAM('CSL'//SF'PUNT);
       SET'SPT'FIELD(-1,'TM',READ'SPT'FIELD(-1,'TCM'//SF'PUNT)
        //SF'PUNT);
       RUN'USER();RUNTIME'FAILURE();

* SP'TRAPS COME HERE
        ARBENT XXXSPT(), SP'ENTRY ←0;SAVE'STATE(SP'GSTATE);STRAP();


* RING TRAPS
        ARBENT XXXABE(), TRAP'ENTRY ←1;SAVE'STATE(GSTATE);ABE'TRAP();
       ARBENT XXXFLO(), TRAP'ENTRY ←2;SAVE'STATE(GSTATE);RTRAP(2);
       ARBENT XXXFLU(), TRAP'ENTRY ←3;SAVE'STATE(GSTATE);RTRAP(3);
       ARBENT XXXRO(), TRAP'ENTRY ←4;SAVE'STATE(GSTATE);RTRAP(4);
       ARBENT XXXIAT(), TRAP'ENTRY ←5;SAVE'STATE(GSTATE);RTRAP(5);
       ARBENT XXXUFN(), TRAP'ENTRY ←6;SAVE'STATE(GSTATE);RTRAP(6);
       ARBENT XXXFXO(), TRAP'ENTRY ←7;SAVE'STATE(GSTATE);RTRAP(7);
       ARBENT XXXDIZ(), TRAP'ENTRY ←8;SAVE'STATE(GSTATE);RTRAP(8);

* STACK OVERFLOW - WATCH OUT
        ARBENT XXXSOV(), TRAP'ENTRY ←9;STKTRAP();

       PROGRAM PUNT; INCLUDE USERDECS,TRAP'DECS;
       INCLUDE SPTDECS;
*
* MAIN TRAP/PUNT PROCESSING ROUTINE
*
        INT N,P,Q,SR;
       INT ERMSNO;CHR ERCODE;
       INT LSPCS←5;
       LB R= L' [0];
       INTARY SPCA[LSPCS],STATE[LSTATE];
       PTR SA;* POINTER TO STATE[0]
       MACRO IS'TSB'INSTR(X)←((X) A' 07740000B=04600000B);
       OCTFL UTNO(0:0,5),SPCSLR(1:6,23);
       LB FIELD LBW0(0);

        MACRO SAVE'STATE(X)←BCOPY(SA←@STATE[0],@X[0],LSTATE)&
        (TRAP'PUNT() IF TRAP'FLAG#1);
       MACRO SPT'PUNT←SPTPUNT:ERCODE,ERMSNO;

*
* ENTRY FOR RING TRAPS
*
        ARBENT RTRAP(N);
       SAVE'STATE(GSTATE);
RTPUNT:RPUNTMSG(N,RTRAP'LOC); GOTO PUNTCOM;

*
* SPECIAL ENTRY FOR 'ABE' TRAP -
* CHECK IF REFERENCE IS FOLLOWED BY TSB OPCODE
*
        ARBENT ABE'TRAP();
       SAVE'STATE(GSTATE);
       INSTR'LOC←RTRAP'LOC+1;
       IF IS'TSB'INSTR($INSTR'LOC) DO ;
           .LDX SA[XSTLOC],LDA SA[LSTLOC],XLA,STA SAVEL,EAC$INSTR'LOC;
           .LDA SAVEL,XLA,STX Q;
           R$BRDPC←Q;
           SA[PSTLOC]←@ABE'EXIT;
           R$BRDLR←SA[LSTLOC];
           SA[LSTLOC]←@R;
           TRAP'FLAG←0;
           .LDX SA,LOADS;
ABE'EXIT:  RETURN ;
       ENDIF ;
       N←1; GOTO RTPUNT;

*
* ENTRY FOR SP TRAPS
*
        ARBENT STRAP();
       SAVE'STATE(SP'GSTATE);ALLOW'INTS();N←@R.SP'TNO;Q←@R.SP'TPAR;
       READ'SPCS(0,SPCA//SPT'PUNT);R$BRDLR←SPCA[0]$SPCSLR;
       P←SPCA[0]$SPCSPR;
       GOTO SPTPUNT IF N#23;

* QUIT
QUIT:   QUIT'FLAG←1;
       /* THE FOLLOWING LINE WAS COMMENTED OUT SO THERE WOULD'NT BE   */
       /* UNDEFINED FUNCTIONS TO CAUSE TROUBLE.                       */
*      QUIT'FCN() IF QUIT'FCN'FLAG;
       SA[LSTLOC]←@R;
       SA[PSTLOC]←@QUITX;.LDX SA,LOADS;
       SET'SPT'FIELD(-1,'TM',1//SF'PUNT);
QUITX: SP'RETURN(//SPT'PUNT);


* FREE STORAGE OVERFLOW
        ARBENT OFLOTRAP(ERCODE,ERMSNO);
       R←R$BRDLR.LBW0;N←24; GOTO RTF;

* UNEXPECTED RUNTIME FAILURE
        ARBENT RUNTIME'FAILURE();N←25;
RTF:   P←R$BRDPC;Q←0;

SPTPUNT:SPUNTMSG(N,P,Q);
PUNTCOM:TRAP'FLAG←0;
       GOTO TRAP'LABEL;

* TRAP DURING STATE-SAVING
        ARBENT TRAP'PUNT();
       SPUNTMSG(26,R$BRDPC,0); GOTO PUNTCOM;


       PROGRAM STKOV'TRAP; INCLUDE USERDECS;
*
* STACK OVERFLOW TRAP PROCESSING
*
        FIXED ;

        ARBENT STKTRAP();
STKWAIT:GOTO TRAP'LABEL;


       PROGRAM UTRAP'MSG; INCLUDE USERDECS,MACHINE'DECS;
*
* PRINT USER TRAP MESSAGE
*?*  THIS ROUTINE SHOULD FRETURN, RATHER THAN PUNTING (COULD CAUSE
*?*       PUNT LOOP AND STACK OVERFLOW)
*
        ST MSG(60),CM;INT N,P,Q,T;
       CHRARY RN[10]←(6'RT0?',6'ABE',6'FLO',6'FLU',6'ROIA',
        6'IAT',6'UFN',6'FXO',6'DIZ',6'SOV');
       CHRARY SN[27]←(6'MACC',6'PRO',6'PNIM',6'PNIC',6'PI',
        6'TI',6'BLL',6'ILIM',6'PNOD',6'DWSO',6'CWSO',
        6'NEP',6'DMRD',6'NILE',6'SPCO',6'PMTO',6'DKSE',
        6'?17?',6'?18?',6'?19?',6'?20?',6'?21?',6'UTSE',
        6'QUIT',6'FSOV',6'PUNT',6'TRAP');

        ARBENT RPUNTMSG(N,P);N←-(N+1);
       ARBENT SPUNTMSG(N,P,Q);


        SETS(MSG,0,0);WCI(NLCH,MSG);
       APPEND(MSG,"USER TRAP '"//LF'PUNT);

COM:
        IF N=22 DO ;* 'UTSE' ERROR
       APPEND(MSG,"UTSE - "//LF'PUNT);
           N←(Q$UTSE'SPTNO IF T←Q$UTSE'CLASS>1 ELSE
            6 IF T=1 ELSE -(Q$UTSE'RTNO+1));
       ENDIF ;

        IF N=6 DO ;* BLL ERROR
       PUNT'WWD(MSG,6'BLL-');WCI(Q$BLL'CLASS V' '0',MSG);
       ELSE DO ;
           PUNT'WWD(MSG,SN[N] IF N>=0 ELSE RN[-(N+1)]);
       ENDIF ;
       APPEND(MSG,"' AT P: "//LF'PUNT);
       CNS(P,MSG,4B7,8//LF'PUNT);WCI('B',MSG);

        WCI(NLCH,MSG);
QT'P:  PRINT'STRING(-1,MSG,0//QUIT'PUNTX(QT'P,MSG));
       RETURN ;

       PROGRAM PUNT'WWD; INCLUDE COMDECS;
*
* APPEND 4 CHARACTER NAME TO STRING
*
        PTR P;CHR M,C;ST S;STFL A(0);CHRFL CH60(0:0,5);

        ARBENT PUNT'WWD( STRING @P,M);S←P.A;

        (WCI(C,S) IF C#' ')&M←M LSH 6
        FOR C←M$CH60 WHILE M#6'    ';
       P.WP←S$WP; RETURN ;

       PROGRAM VARIOUS; INCLUDE USERDECS;

*
* CLEAR CIOS NPUT/OUTPUT &
* TYPE NEWLINE
*

        ARBENT CLEAR'CIOS();
LP:    QUIT'FLAG←0;
       SET'CIOS'FIELD(-1,'OCC',0//SF'PUNT);
       SET'CIOS'FIELD(-1,'ICC',0//SF'PUNT);
       IOUT();
       PRINT'CHAR(-1,NLCH,QUIT'FLAG//QUIT'PUNT(LP));
       RETURN ;

*
* REMOVE QUIT CALL FROM SPCS AND UNWIND STACK
* BY NON-LOCAL GOTO
*

        ARBENT ZAP( LABEL ZLAB);
       DELETE'CALL(//SF'PUNT);
       GOTO ZLAB;
       END;

       PROGRAM COPY; INCLUDE USERDECS;
       INCLUDE BFSDECS,UQNDECS;

* THIS IS THE COPY FILE PROGRAM. IT WILL MAINTAIN THE EXACT
* STRUCTURE OF THE COPIED FILE. ONE MAY SAY:
*       COPY <IN FILE> <OUT FILE>
* OR:
*       COPY
*       FROM FILE: <IN FILE>
*       TO FILE: <OUT FILE>
* WHERE THE <OUT FILE> MUST BE QUOTED IF IT IS A NEW FILE.

        OCTFL SIBFLLEN(4);
       INT FSIZE,EMPTYP,TOTALP;
       INT NEWF;
       INT FPI,FPO;*FILE PAGE INDEX
       INT BN←1;*NUMBER OF PAGES BUFFERED
       INT I,FLENGTH;
       INT ERCODE,ERMSNO;*ERROR CODE AND MESSAGE NUMBER FOR SYS. FAILURE
       INT KEY;*ACCESS KEY
       INT USER'NO;*TSS USER NUMBER
       INT PRIVILEDGE;*SET IF USER HAS ACCESS TO MIB #2 (SYSTEM PRIVILEDGES)
       ST COMLINE(NCMCH),PARAM'ST,TEMPS(5),CSLIST(10),ACCESS;
       INTARY FA[8],WA[5];
       INT OFTI,OFTO;*OPEN FILE TABLE INDICES FOR IN AND OUT FILES
       INT MAP←32;*FIRST MAP BYTE USED FOR BUFFER PAGES
       INTARY1 PMTI[BN],PMTO[BN],AIP[BN];

        MACRO PRNT()←PRINT'STRING(-1,OL,0//QUIT'PUNTX(EXIT,OL));

        ENTRY RUN'USER();
*GET FILE NAMES AND OPEN THE FILES

        QUIT'FLAG←0;
       EMPTYP←TOTALP←0;

        /* DETERMINE IF USER HAS SYSTEM PRIVELEDGES BY LOOKING AT COMMAND */
        /* SEARCH LIST MAKING SURE IT IS '2' AND NOT '3' OR '4'.          */
        ACCESS ← "0"; /*INITIALIZE IN CASE READ'UP'ITEM CALL FAILS*/
        USER'NO ← READ'PROC'PARAM('UNO'//SF'PUNT);
        READ'UP'ITEM('UP',-1,USER'NO,TEMPS,"CSL",CSLIST,0:CSLIST//DETRMIN
                     :ERCODE,ERMSNO);
        ACCESS ← GET'PARAM(CSLIST);
        ACCESS ← GET'PARAM(CSLIST);
DETRMIN:PRIVILEDGE←1 IF (CSN(ACCESS,10//LF'PUNT)=2 OR USER'NO=1)
                     ELSE PRIVILEDGE←0;

       KEY←CONV'KEY(-1//SF'PUNT);
       SETS(COMLINE,0,0);
       GET'COM'LINE(COMLINE:COMLINE//SF'PUNT);
       PARAM'ST←GET'PARAM(COMLINE);*SKIP COPY
       IF LENGTH(COMLINE)<=0 DO ;*PROMT IF NECESSARY
       IOUT();PTST("FROM FILE:");PRNT();
           COMLINE←READ'LINE(-1,COMLINE," ",QUIT'FLAG//
            QUIT'PUNTX(QT'XIT,COMLINE));
       ENDIF ;
       PARAM'ST←GET'PARAM(COMLINE);*GET INPUT FILE NAME
       NAME'SEARCH(PARAM'ST,FA,0,'',KEY//PARERR:ERCODE,ERMSNO);
       IF (FA[0]#USER'NO AND NOT PRIVILEDGE) DO;
           PTIS("SYSTEM PRIVILEDGES REQUIRED!");
           PTNL(); PRNT(); GOTO EXIT;
       ENDIF;
       FSIZE←(1 IF FA[0]$UQNTY=SIBLFCD ELSE 0);
       OFTI←OPEN'FILE(-1,FA,'RW',KEY//PARERR:ERCODE,ERMSNO);
       READ'MIBOB'VALUE(FA,3,WA,0,KEY//SF'PUNT);
       FLENGTH←WA[0]$SIBFLLEN;
       IF LENGTH(COMLINE)<=0 DO ;*PROMT IF NECESSARY
       IOUT();PTST("TO FILE:");PRNT();
           COMLINE←READ'LINE(-1,COMLINE," ",QUIT'FLAG
            //QUIT'PUNTX(QT'XIT,COMLINE));
       ENDIF ;
       PARAM'ST←GET'PARAM(COMLINE);*GET OUTPUT FILE NAME
       NAME'SEARCH(PARAM'ST,FA,1,'',KEY//PARERR:ERCODE,ERMSNO);
       IF (FA[0]#USER'NO AND NOT PRIVILEDGE) DO;
           PTIS("SYSTEM PRIVILEDGES REQUIRED!");
           PTNL(); PRNT(); GOTO EXIT;
       ENDIF;
       CREATE'MIBOB(FA,SIBLFCD,KEY//SF'PUNT) IF FSIZE AND FA[2]=-1;
       NEWF←FA[2];
       OFTO←OPEN'FILE(-1,FA,'RW',KEY//PARERR:ERCODE,ERMSNO);
       SET'FILE'LENGTH(OFTO,FLENGTH//SF'PUNT);
       SET'MIBOB'ACCESS(FA,NORM'FIL'AC,KEY//SF'PUNT);

*SET UP BUFFER PAGES
        FOR I←1 TO BN DO ;
           PMTI[I]←ACQUIRE'PMT(-1//PARERR:ERCODE,ERMSNO);
           SET'MAP'BYTE(-1,MAP+I-1,PMTI[I]+4000B//SF'PUNT);
           PMTO[I]←ACQUIRE'PMT(-1//PARERR:ERCODE,ERMSNO);
           SET'MAP'BYTE(-1,MAP+BN+I-1,PMTO[I]//SF'PUNT);
       ENDFOR ;

* COPY ALL PAGES AND MAINTAIN THE EXACT STRUCTURE
        FPI←FPO←-1;
MORE:  GOTO EXIT IF QUIT'FLAG;
       FOR I←1 TO BN DO ;
           IF (AIP[I]←FPI←NEXT'FILE'PAGE(OFTI,FPI//SF'PUNT))#-1 DO ;
               TOTALP←TOTALP+1;
               MOVE'PAGE'PMT(OFTI,FPI,PMTI[I]//SF'PUNT);
               PUT'PAGE'CWS(PMTI[I]//SF'PUNT);
                   DEL'FILE'PAGE(OFTO,FPO//SF'PUNT)&EMPTYP←EMPTYP+1
                    WHILE (FPO←FPO+1)<FPI;
               CR'FILE'PAGE(OFTO,FPO//TEST1:ERCODE,ERMSNO);
               GOTO TEST2;

TEST1:          GOTO PARERR IF ERCODE#'FPE';

TEST2:          MOVE'PAGE'PMT(OFTO,FPO,PMTO[I]//SF'PUNT);
               PUT'PAGE'CWS(PMTO[I]//SF'PUNT);
           ENDIF ;
       ENDFOR ;
       FOR I←1 TO BN DO ;
           IF AIP[I]#-1 DO ;
               BCOPY((MAP+BN+I-1)*2048,(MAP+I-1)*2048,2048);
               CLEAR'PMT(PMTI[I]//SF'PUNT);
               CLEAR'PMT(PMTO[I]//SF'PUNT);
           ENDIF ;
       ENDFOR ;
       GOTO MORE IF FPI#-1;

        DEL'FILE'PAGE(OFTO,FPO//SF'PUNT)&EMPTYP←EMPTYP+1
        WHILE (FPO←NEXT'FILE'PAGE(OFTO,FPO//SF'PUNT))#-1;
       IOUT();PTST("LARGE") IF FSIZE ELSE PTST("SMALL");
       PTST(" FILE ");PTST("CREATED AND ") IF NEWF=-1;
       PTST("COPIED, ");
       CNS(TOTALP,OL,0,10//LF'PUNT);
       PTST(" PAGES");
       PTNL();
       PRINT'STRING(-1,OL,0//QUIT'PUNTX(EXIT,OL));

EXIT:   IF QUIT'FLAG DO ;
QT'XIT:    SET'CIOS'FIELD(-1,'ICC',0//SF'PUNT);
           SET'CIOS'FIELD(-1,'OCC',0//SF'PUNT);
           QUIT'FLAG←0;
           IOUT();PTNL();
           PTST("USER TRAP 'QUIT'");PTNL();
           PRINT'STRING(-1,OL,0//QUIT'PUNTX(EXIT,OL));
       ENDIF ;
       SP'RETURN(//SF'PUNT);

PARERR: IOUT();
       OL←ERRORMSG(ERMSNO,OL//SF'PUNT);
       PTNL();
       PRINT'STRING(-1,OL,0//SF'PUNT);
       GOTO EXIT;


       END;
* INTERIM DISK FILE SYSTEM FOR BCC 500
PFS    IDENT

* MACROS
PNO    MACRO X
X      NARG; FRGT X
       IF 'X(1$1,4)'#':'; LDA X(1); ENDF
       IF X>1; TNO X(2); ELSE; TNO =10; ENDF
       ENDM
CMD    MACRO A
       BRU A(1$1).&F
       ASC '  A(1)/'
       ENDM
PCMD   MACRO A
       BRU A(1$1).&A(1$1).&A(1$1)
       ASC '  A(1)/'
       ENDM
SKNE   MACRO X
X      NARG; FRGT X
       IF X=1; SKE X(1)
       ELSE; SKE X(1),X(2)
       ENDF
       BRU *+2
       ENDM
SKLE   MACRO X
       SKG X(1); BRU *+2
       ENDM
ORG    MACRO X
       BSS ORIGIN+X(1)-*
       ENDM
ORIGIN EQU *-240B

* PARAMETERS

AUTO   EQU -1  +1 ASSEMBLES A VERSION WHICH TAKES COMMANDS FROM A FILE
BACKOFF EQU 20*6  OFFSET FOR BACKUP INDEX BLOCK
CONVERT EQU -1 +1 CAUSES A VERSION TO BE ASSY'D WHICH LOADS OLD FORMAT
INCREMENT EQU -1  +1 ASSEMBLES COMMAND "BACKUP" IN PLACE OF "DUMP"
MAINT  EQU -1  +1 ASSEMBLES A NUMBER OF ADDITIONAL MAINTENANCE CMNDS
NSEC   EQU 5   NUMBER OF SECTORS/BAND
NBAND  EQU 20  NUMBER OF BANDS/TRACK
NORDERRS EQU 20 NUMBER OF SUCCESSIVE READ ERRORS BEFORE GIVING UP
NLU    EQU 40
SLU    EQU 341 NUMBER OF PAGES/LARGE USER
NMU    EQU 40  NUMBER OF MEDIUM USERS
NWD    EQU 4000B   LENGTH OF DATA BUFFER FOR FILE TRANSFERS
SMU    EQU 171 NUMBER OF PAGES/MEDIUM USER
NSU    EQU 57  NUMBER OF SMALL USERS
SSU    EQU 86  NUMBER OF PAGES/SMALL USER

* SUBROUTINE LINKS
XASF   BSS 1
XAVS   BSS 1
XBBB11 BSS 1
XBRS38 BSS 1
XCBE   BSS 1
XCFA   BSS 1
XCCF   BSS 1
XCDA   BSS 1
XCFC   BSS 1
XCHD   BSS 1
XCIN   BSS 1
XCLL   BSS 1
XCLS   BSS 1
XCPN   BSS 1
XCPNAM BSS 1
XDDA   BSS 1
XDELN  BSS 1
XDELNC BSS 1
XDFA   BSS 1
XDKX   BSS 1
XDTR   BSS 1
XEDA   BSS 1
XFBL   BSS 1
XFED   BSS 1
XFFN   BSS 1
XFLF   BSS 1
XFSB   BSS 1
XFON   BSS 1
XFXR   BSS 1
XGBU   BSS 1
XGCFN  BSS 1
XGDATE BSS 1
XGDFN  BSS 1
XGGN   BSS 1
XGFB   BSS 1
XGNO   BSS 1
XGNU   BSS 1
XGOFN  BSS 1
XGUN   BSS 1
XGUT   BSS 1
XGXB   BSS 1
XINIT  BSS 1
XIXR   BSS 1
XMARKN BSS 1
XNXU   BSS 1
XOFL   BSS 1
XOLF   BSS 1
XPAP   BSS 1
XPDA   BSS 1
XPFA   BSS 1
XPFP   BSS 1
XPNM   BSS 1
XPTOD  BSS 1
XPUN   BSS 1
XPKE   BSS 1
XRBT   BSS 1
XRCC   BSS 1
XRND   BSS 1
XRPR   BSS 1
XRTY   BSS 1
XRXD   BSS 1
XRXR   BSS 1
XRXU   BSS 1
XSUNP  BSS 1
XSYS   BSS 1
XTBAD  BSS 1
XTBB   BSS 1
XTDA   BSS 1
XTFB   BSS 1
XTFN   BSS 1
XTXR   BSS 1
XUPF   BSS 1
XUPU   BSS 1
XVFD   BSS 1
XVFY   BSS 1
XWCI4  BSS 1
XWNQ   BSS 1
XWNS   BSS 1
XWOCI  BSS 1
XWSL   BSS 1
XXWE   BSS 1
XZDB   BSS 1

* TEMPORARY STORAGE
ACCAT  BSS 1   TEMP STOR FOR C(V,R,W)A ROUTINES
ACCESS BSS 1   USED BY WRITE FILE COMMAND
ASFI   BSS 1   TEMP STOR FOR ASF ROUTINE
ASFL   BSS 1   TEMP STOR FOR ASF ROUTINE
B38F   BSS 1   TEMP STOR FOR BRS38
B38N   BSS 1   TEMP STOR FOR BRS38
B38R   BSS 1   TEMP STOR FOR BRS38
B38V   BSS 1   TEMP STOR FOR BRS38
BAND   BSS 1   BAND ADDRESS
BANDT  BSS 1   TEMP STOR FOR IXR ROUTINE
BBBPTR BSS 1   USED BY BACKUP COMMAND
BLKNO  BSS 1   USED BY WRITE FILE COMMAND
BRIEFF BSS 1   TEMP STOR FOR LIST COMMAND
BUSER  BSS 1   TEMP STOR FOR INITIALIZE COMMAND
CCHAR  BSS 1   COMMAND CHARACTER
CCIN   BSS 1   TEMP STOR FOR CIN ROUTINE
CDAP   BSS 1   TEMP STOR FOR CDA ROUTINE
CEPTR  BSS 1   USED FOR COMMAND RECOGNITION ROUTINE
CETAB  BSS 2   A,B TEMP STOR FOR CET POP
CETX   BSS 1   X TEMP STOR FOR CET POP
CFILE  BSS 1   TEMP STOR FOR CLS ROUTINE
CHAR   BSS 1   TEMP STOR FOR GCFN ROUTINE
CIDX   BSS 1   COMMAND INDEX
COAT   BSS 1   TEMP STOR FOR COA ROUTINE
CPNA   BSS 1   TEMP STOR FOR CPN ROUTINE
CPNAMT BSS 1   TEMP STOR FOR CPNAM ROUTINE
CPNB   BSS 1   TEMP STOR FOR CPN ROUTINE
CPNX   BSS 1   TEMP STOR FOR CPN ROUTINE
CUSER  BSS 1   TEMP STOR FOR INITIALIZE COMMAND
CWC    BSS 1   USED BY WRITE FILE COMMAND
DBADDR BSS 1   TEMP STOR FOR TBB ROUTINE
DBBRS  BSS 1   TEMP STOR FOR TBB ROUTINE
DBLOC  BSS 1   TEMP STOR FOR TBB ROUTINE
DCOUNT BSS 1   USED BY WRITE FILE COMMAND
DDAY   BSS 1   USED BY BACKUP COMMAND
DELFLG BSS 1   USED BY ABANDON FILE COMMAND
DFAP   BSS 1   TEMP STOR FOR DFA ROUTINE
DFAT   BSS 1   TEMP STOR FOR DFA ROUTINE
DIRECT BSS 1   FLAG USED BY GDFN ROUTINE
DIROK  BSS 1
DISKA  BSS 1   TEMP STOR FOR EDA ROUTINE
DKCA   BSS 1   CORE ADDRESS FOR DISK TRANSFER
DKCT   BSS 1   COUNT FOR ARM MIS-POSITION RETRIES
DKINS  BSS 1   DISK WRITE/READ INSTRUCTION
DKKA   BSS 1   DISK ADDRESS FOR DISK TRANSFER
DKNODE BSS 18  DIRECT I/O NODE FOR BRS 137
DKNTOP EQU DKNODE+18
DKTA   BSS 1   TEMPORARY STORAGE FOR DKR ROUTINE
DMO    BSS 1   USED BY BACKUP COMMAND
DPTR   BSS 1   USED BY WRITE FILE COMMAND
DTIME  BSS 1   USED BY BACKUP COMMAND
DVC    BSS 1   WORD COUNT FOR REREAD COMPARE
DVEC   BSS 1   TEMP STOR FOR DKW ROUTINE
DVP1   BSS 1   TEMP STOR FOR DKW ROUTINE
DVP2   BSS 1   TEMP STOR FOR DKW ROUTINE
DYR    BSS 1   USED BY BACKUP COMMAND
EFX    BSS 1   USED BY EF, BF, & LF COMMANDS
ERRCNT BSS 1   ERROR COUNTER FOR RRETRY ROUTINE
FDUAL  BSS 1   DUAL FILE NUMBER
FI     BSS 1   INPUT FILE
FII    BSS 1   SUBSYSTEM INPUT FILE
FILE   BSS 1   FILE NUMBER FOR TRANSFERS
FLEN   BSS 1   USED BY WRITE FILE COMMAND
FNAME  BSS 26  STRING STORAGE FOR FILE NAMES
FNPTR  BSS 1   STRING POINTER FOR FNAME
FNPTR1 BSS 1
FO     BSS 1   OUTPUT FILE
FOO    BSS 1   SUBSYSTEM OUTPUT FILE
FGROUP BSS 1   PASSWORD FOR FILE (TEMP STOR)
FLFL   BSS 1   TEMP STOR FOR FLF ROUTINE
FLFT   BSS 1   TEMP STOR FOR FLF ROUTINE
FRIEND BSS 12   FRIEND LIST FOR EQUIVALENT OWNERSHIP ACCESS
FTYPE  BSS 1   USED BY WRITE FILE COMMAND
FSBN   BSS 1   TEMP STOR FOR FSB ROUTINE
FUSER  BSS 1   FUNCTIONAL USER NUMBER
GDAY   BSS 1   USED BY GDATE
GMO    BSS 1   USED BY GDATE
GYR    BSS 1   USED BY GDATE
GCFNC  BSS 1   TEMP STOR FOR GCFN ROUTINE
GCFNT  BSS 1   TEMP STOR FOR GCFN ROUTINE
GDFNC  BSS 1   TEMP STOR FOR GDFN ROUTINE
GDFNP  BSS 1   TEMP STOR FOR WCI4 ROUTINE
GGNN   BSS 1   TEMP STOR FOR GGN ROUTINE
GROUP  BSS 1   USED BY WRITE FILE COMMAND
GUNCT  BSS 1   USER NAME CHARACTER COUNT
IOFLAG BSS 1   USED BY WRITE FILE COMMAND
IUNO   BSS 1   IMMEDIATE USER NUMBER
IXRT   BSS 1   TEMP STOR FOR IXR ROUTINE
LENGTH BSS 1   USED BY WRITE FILE COMMAND
LUNO   BSS 1   LOCKED USER NUMBER
LFLL   BSS 1   TEMP STOR FOR LIST COMMAND ROUTINE
LFT    BSS 1   TEMP STOR FOR LIST COMMAND ROUTINE
LLLT   BSS 1   USED BY $LOAD COMMAND
LOCKF  BSS 1   LOCK FILE NUMBER
MFP    BSS 1   TEMP STOR FOR MF COMMAND
MFTX   BSS 1   TEMP STOR FOR MF COMMAND
MFUNO  BSS 1   TEMP STOR FOR MF COMMAND
MSGAB  BSS 2   A,B TEMP STOR FOR MSG POP
MSGX   BSS 1   X TEMP STOR FOR MSG POP
NAME   BSS 3   FILE NAME TEMP STOR
NAME3  BSS 1   FILE NAME TEMP STOR
NBLOX  BSS 1   USED BY DUMP AND LOAD COMMANDS

       IF CONVERT
       REM     VERSION TO CONVERT OLD FORMAT
NEWCT  BSS 1   TEMP STOR FOR LOAD ROUTINE
OLDCT  BSS 1   TEMP STOR FOR LOAD ROUTINE
SAVBIT BSS 1   TEMP STOR FOR LOAD ROUTINE
WORD0  BSS 2   TEMP STOR FOR LOAD ROUTINE
WORD2  BSS 2   TEMP STOR FOR LOAD ROUTINE
       ENDF

NOROOM BSS 1   USED BY LOAD COMMAND
NUSERS BSS 1   TEMP STOR FOR INITIALIZE COMMAND
OFLP   BSS 1   TEMP STOR FOR OFL ROUTINE
OFLT   BSS 1   TEMP STOR FOR OFL ROUTINE
OFLX   BSS 1   TEMP STOR FOR OFL ROUTINE
OFPTR  BSS 1   TEMP STOR FOR OF COMMAND
OLDATA BSS 2   USED BY LOAD COMMAND
OLDLEN BSS 1   USED BY LOAD COMMAND
OLDN   BSS 4   COUNTERPART FOR NAME: CHANGE NAME COMMAND
OLFT   BSS 1   TEMP STOR FOR OLF ROUTINE
OFTYPE BSS 1   USED BY WRITE FILE COMMAND
OXBLN  BSS 1   USED BY BACKUP COMMAND
PFAB   BSS 1   TEMP STOR FOR PFA ROUTINE
PFAX   BSS 1   TEMP STOR FOR PFA ROUTINE
PFPX   BSS 1   TEMP STOR FOR PFP ROUTINE
PNMC   BSS 1   TEMP STOR FOR PNM ROUTINE
PNMP   BSS 1   TEMP STOR FOR PNM ROUTINE
PNMX   BSS 1   TEMP STOR FOR PNM ROUTINE
PUNO   BSS 1   TEMP STOR FOR PUN ROUTINE
RBTA   BSS 1   A TEMP STOR FOR RBT PROCESSOR
RBTFLG BSS 1   RUBOUT FLAG
RBTL   BSS 1   LINK WORD FOR RUBOUT INTERRUPT
RDRTRY BSS 1   TEMP STOR FOR VFD ROUTINE
RXUT   BSS 1   TEMP STOR FOR RXU ROUTINE
RWIX   BSS 1   USED BY LOAD COMMAND
RWNX   BSS 1   USED BY LOAD COMMAND
RWOX   BSS 1   USED BY LOAD COMMAND
RXB    BSS 1   TEMP STOR FOR RXR ROUTINE
RXC    BSS 1   WAIT COUNTER FOR RXR ROUTINE
SECTOR BSS 1   SECTOR ADDRESS
SECTT  BSS 1   TEMP STOR FOR IXR ROUTINE
SFT    BSS 1   TEMP STOR FOR STATUS COMMAND
SPACE  BSS 1   TEMP STOR FOR AVS ROUTINE
STPSWD BSS 1   USER PASSWORD
TBI    BSS 1   TEMP STOR FOR TBAD ROUTINE
TDAX   BSS 1   TEMP STOR FOR TDA ROUTINE
TCHX   BSS 1   X TEMP STOR FOR TCH POP
TERCH  BSS 1   TERMINAL CHARACTER
TERM   BSS 1   USED BY WRITE FILE COMMAND
TFNPTR BSS 2   STRING POINTER FOR TFN ROUTINE
TNOX   BSS 1   X TEMP STOR FOR TNO POP
TODAY  BSS 1   DATE & TIME
TRACK  BSS 1   TRACK ADDRESS
TRACKT BSS 1   TEMP STOR FOR IXR ROUTINE
UNAME  BSS 6   USER NAME STRING STORAGE
UNIT   BSS 1   UNIT ADDRESS
UNO    BSS 1   USER NUMBER
UNPTR  BSS 1   STRING POINTER FOR TEMP USE
UNPTR1 BSS 1
USER   BSS 1   COMMUNICATION BETWEEN DFA & PFA ROUTINES
USER1  BSS 1   "<" USER NUMBER
USER2  BSS 1   ">" USER NUMBER
VFT    BSS 1   TEMP STOR FOR VFD ROUTINE
VFYP   BSS 1   TEMP STOR FOR VFY ROUTINE
VFYX   BSS 1   TEMP STOR FOR VFY ROUTINE
VFYY   BSS 1   SAME
WCI4C  BSS 1   TEMP STOR FOR WCI ROUTINE
WERRC  BSS 1   WRITE ERROR COUNT FOR WRITE OPERATIONS
WMFLG  BSS 1   USED BY WF ROUTINE
WNQF   BSS 1   TEMP STOR FOR WNS ROUTINE
WNSP   BSS 1   TEMP STOR FOR WNS ROUTINE
WTRTRY BSS 1   TEMP STOR FOR VFD ROUTINE
XBLN   BSS 1   USED BY BACKUP COMMAND
XCNTR  BSS 1   USED BY LOAD COMMAND
XRADDR BSS 1   PHYSICAL ADDRESS OF INDEX BLOCK
XRBADDR BSS 1  ADDRESS OF BACKUP INDEX BLOCK
XRBASE BSS 1   LOGICAL ADDRESS OF START OF USER SPACE
XRE    BSS 6   HOLDS INDEX BLOCK ENTRY FOR INDEX BLOCK
XSIZX  BSS 1   TEMPORARY STORAGE FOR INITIALIZE INDEX BLOCK ROUTINE

* VARIOUS STORAGE AREAS

* MEMORY LAYOUT FOR THIS SUBSYSTEM IS AS FOLLOWS:
*
*      PAGE 0: TEMP STORAGE & CTAB FOR LOADING DUMPS
*      PAGE 1: LOCKS FILE, INCLUDING USER NUMBER TRANSLATION TABLE
*      PAGE 2: INDEX BLOCK
*      PAGE 3: OLD INDEX BLOCK FOR RELOADING
*      PAGE 4: REREAD COMAPRE BUFFER
*      PAGE 5: FILE DATA BUFFER
*      PAGE 6: CONSTANTS AND CODE
*      PAGE 7: CODE AND LIST OF BAD SPOTS ON DISK FILE

       ORG 4000B-SLU
ECTAB  BES SLU   CONTROL TABLE FOR LOADING PREVIOUS DUMPS

* PAGE 1 CONTAINS THE LOCKS FILE
UNOTAB EQU *   USER NUMBER TRANSLATION TABLE
IXRV   BES 3777B  ONE WORD SHORT OF A PAGE BECAUSE OF EMULATOR BUG

* PAGE 2 CONTAINS THE INDEX BLOCK
       ORG 10000B
XBL    BSS 4000B  INDEX BLOCK PAGE
EXBL   EQU *
SIZX   EQU XBL FIRST WORD CONTAINS COUNT FOR XREG

* PAGE 3 CONTAINS THE OLD INDEX BLOCK
XOBL   BSS 4000B  OLD INDEX BLOCK PAGE
EXOBL  EQU *
SIZOX  EQU XOBL FIRST WORD CONTAINS COUNT FOR XREG

* PAGE 4 IS THE REREAD COMPARE BUFFER
VB     BSS 4000B  REREAD COMPARE BUFFER

* PAGE 5 IS THE DATA BUFFER FOR FILE TRANSFERS
DB     BSS NWD
EDB    EQU DB+NWD

* VARIOUS TABLES, ETC.

* HEADER FOR MAKING SUBSYSTEM FILES
       ORG 30000B
       DATA 0,2,0
       BSS 3
       DATA 20002001B
       BSS 34B
       BSS 11B
       DATA START,0,0

*TABLE OF BASE ADDRESSES FOR VARIOUS USERS
UFILL  MACRO X; RPT X(1); DATA R;R EQU R+X(2); ENDR; ENDM
R      EQU 0

UBASE  UFILL NLU,SLU
       UFILL NMU,SMU
       UFILL NSU,SSU
MAXUNO EQU *-UBASE

* CONSTANTS

BADCNT DATA 0  COUNT OF BAD SPOTS
BADMSK DATA -1
CRLF   ASC '$/'
DISKBASE DATA 1*2↑12+1*2↑0  DISK BASE ADDRESS: TRACK 1, UNIT 1
REREAD DATA -1 TO REREAD AFTER WRITE
REWRITE DATA 0  TO REWRITE ON VERIFY
TRYLIM DATA 10 NUMBER OF RETRIES IN VFD ROUTINE

* BAND TRANSLATION, BY UNIT
       OCT
IV     MACRO Y
       RPT (X=Y(1),Y(2))
       DATA X
       ENDR
       ENDM
BANDTAB DATA U0B,U1B
EBANDTAB DATA U0BE,U1BE

U0B    IV 22,27  INCLUDES BANDS 22 THRU 27 ON UNIT 0
U0BE   EQU *

U1B    IV 1,4  EXCLUDES BANDS 0,5,25,26 FROM PFS SPACE
       IV 6,24
       IV 27,27
U1BE   EQU *
       DEC

* PROGRAMMED OPERATORS

* 'MSG' POP
MSG    OPD 100B5
MSGP   STP MSGAB; STX MSGX; CLX; EAX* 0; CXA
       LDB =-1; LDX FO; BRS 34
       LDP MSGAB; LDX MSGX; BRR 0
* 'TNO' POP
TNO    OPD 101B5
TNOP   STX TNOX; LDB* 0; LDX FO
       BRS 36; LDX TNOX; BRR 0
* 'TCH' POP
TCH    OPD 102B5
TCHP   STX TCHX; EAX* 0; XXA
       ETR =177B; CIO FO; LDA TCHX; XXA; BRR 0
* 'CET' POP
CET    OPD 103B5
CETP   STP CETAB; STX CETX; CLEAR; EAX* 0
       SKE FI; BRU CET1; CXA; LDX =-1; BRS 12
CET1   LDP CETAB; LDX CETX; BRR 0
*
TV100  BRU MSGP; BRU TNOP
TV102  BRU TCHP; BRU CETP

* UTILITY SUBROUTINES

* ACQUIRE SPACE FOR FILE
* ACQUIRE AND LABEL ALL ENTRIES FROM INDEX BLOCK
*   FOR NEW FILE.  ENTER WITH LENGTH OF FILE IN A.
*   SKIPS IF SUCCESSFUL.
ASF    ZRO XASF; STA ASFL; LDA FTYPE; MRG =1B5; STA ASFI
ASF1   LDX SIZX; SBRM GFB; SBRR ASF; LDP NAME; STP EXBL,2
       LDA NAME+2; STA EXBL+2,2; LDA ACCESS; MRG TODAY
       STA EXBL+4,2; LDA GROUP; STA EXBL+5,2
       LDA ASFL; SKG =4000B; BRU ASF2; SUB =4000B; STA ASFL
       LDA NAME+3; MRG ASFI; STA EXBL+3,2; MIN ASFI; BRU ASF1
ASF2   ADD =2B5-1; MRG NAME+3; MRG FTYPE; STA EXBL+3,2
       MIN* ASF; SBRR ASF

* COUNT AVAILABLE SPACE
AVS    ZRO XAVS; LDX SIZX; EAX 6,2; CXA; CNA; RSH 23
       DIV =6; STA SPACE
AVS1   SBRM CBE; SKR SPACE; EAX 5,2; BRX AVS1
       LDA SPACE; SBRR AVS

* READ NUMBER
BRS38  ZRO XBRS38; STB B38R
       CLA; STA B38V; LDA =4B7-1; STA B38N
       LDA B38F; SKNE =0
B38L1  SBRM CIN; SKG ='9'; SKG ='0'-1; BRU B38L2
       SUB ='0'; XMA B38V; MUL B38R; LSH 23; ADM B38V
       MIN B38N; BRU B38L1
B38L2  SKN B38N; MRG =4B7; COPY AB,A
       STA B38F; LDA B38V; SBRR BRS38

* REPLACE EMPTY SPOT BY BAD SPOT IF BAD, SKIP IF EMPTY
CBE    ZRO XCBE; CLA; SKE EXBL,2; SBRR CBE
       SBRM CDA; SBRM TBAD; BRU CBE1
       LDA =-1; STA EXBL,2; SBRR CBE
CBE1   MIN* CBE; SBRR CBE

* COMPUTE DISK ADDRESS FOR BLOCK
* OFFSETS BASE ADDRESS FOR USER BY BLOCK NUMBER.
*   RE-ENCODES AND TRANSLATES TO PHYSICALLY
*   FORMATTED ADDRESS, RETURNED IN A.
CDA    ZRO XCDA; CXA; LSH 9; RSH 9; SUB SIZX; RSH 23
       DIV =6; STA CDAP; LDA XRBASE; SBRM DDA
       LDA SECTOR; ADD CDAP; LRSH 23; DIV =NSEC
       STB SECTOR; ADD BAND; LRSH 23; DIV =NBAND
       STB BAND; ADM TRACK; SBRM EDA; SBRM TDA; SBRR CDA

* CLOSE COMMAND FILE
* MAKES SURE COMMAND FILE, IF NOT TTY, IS CLOSED.
CCF    ZRO XCCF; LDA FI; SKE =0; BRU CCF1; SBRR CCF
CCF1   SBRM CLS

       IF AUTO

       LDA =137B; CIO FO; LDA FO; SKE =1; SBRM CLS

       ENDF

       LDA FII; LDB FOO; SBRM INIT

       IF AUTO

       SBRR CCF

       ELSE

       LDX =-5; LDA =147B; CIO FO; BRX *-1; SBRR CCF

       ENDF

* CHANGE DATA FOR FILE
CHD    ZRO XCHD; LDA FUSER; SBRM RXR; BRU ERR455
       SBRM RBTF; LDX SIZX
CHD1   LDB =77B6; LDA EXBL,2; SKE OLDN; BRU CHD2
       LDA EXBL+1,2; SKE OLDN+1; BRU CHD2
       LDA EXBL+2,2; SKE OLDN+2; BRU CHD2
       LDA EXBL+3,2; SKM OLDN+3; BRU CHD2
       ETR =303777B; MRG NAME+3; STA EXBL+3,2
       LDA EXBL+4,2; ETR =@77B6; MRG ACCESS; STA EXBL+4,2
       LDA GROUP; STA EXBL+5,2; LDP NAME; STP EXBL,2
       LDA NAME+2; STA EXBL+2,2
CHD2   EAX 5,2; BRX CHD1; SBRM WXR; BRU ERR455
       SBRM RBTN; SBRR CHD

* READ CHARACTER
CIN    ZRO XCIN; CIO FI; STA CCIN

       IF AUTO; SBRR CIN; ELSE

       LDA FI; SKE FII; BRU CIN1
CIN2   LDA CCIN; SBRR CIN
CIN1   LDA CCIN; SKE =137B; BRU *+2; BRU CIN2
       SKA =300B; BRU CIN+1; CIO FO; BRU CIN2

       ENDF


* CLEAR LOCK
CLL    ZRO XCLL; SKN LUNO; BRU *+2; SBRR CLL
       LDB LUNO; LSH 24+3; CNA; CAX; LDA =1
       STA IXRV+7,2; CNA; STA LUNO; SBRR CLL

* CLOSE FILE
* TAKES FILE NUMBER IN A.  CHECKS TO SEE IF FILE IS OPEN.
*   IF SO, CLOSES IT.
CLS    ZRO XCLS; ETR =37777B; STA CFILE; BRS 110; CXA
       SKNE =0; SBRR CLS; LDA CFILE; BRS 20; SBRR CLS

* CONFIRM COMMAND
* COMMAND MUST BE TYPED UP TO THE "/", ELSE ERR.
CFC    ZRO XCFC; LDA CIDX; ADD =1; MUL =3B7
       LSH 2; STA FNPTR; ADD =100; STA FNPTR1
CFC1   GCI FNPTR; HLT; SKE ='/'; BRU CFC2
CONFRM NOP XCFC; SBRM CIN; SKE ='.'; BRU ERR455; SBRR CFC
CFC2   STA CCHAR; SBRM CIN; SKE CCHAR; BRU ERR455; BRU CFC1

* CHECK READ, WRITE, VISIBILITY, OWNERSHIP ACCESS
* CHECK FOR APPROPRIATE ACCESS.  IF OK, SKIP RETURN.
*   CHECKS GENERAL ACCESS KEY FIRST.  IF NOT OK, THEN
*   CHECKS PASSWORD ACCESS & OWNERSHIP ACCESS LAST.
CRA    ZRO XCFA; LDA =1; BRU CFA1
CWA    ZRO XCFA; LDA =2; BRU CFA1
CVA    ZRO XCFA; CLA
CFA1   STA ACCAT; LDA EXBL+4,2; LRSH 22; SKG ACCAT; BRU CFA2
CFA3   MIN* CVA; SBRR CVA
CFA2   CLA; LCY 2; SKG ACCAT; BRU CFA4
       LDA FGROUP; SKNE EXBL+5,2; BRU CFA3
CFA4   CLA; LCY 2; SKG ACCAT; SBRR CVA
COA    NOP XCFA; LDA FUSER; SKE UNO; BRU COA1
       MIN* COA; SBRR COA
COA1   STX COAT; SBRM UPF; LDX =-12; LDA UNO
COA2   SKE FRIEND+12,2; BRU COA3; MIN* COA; BRU COA4
COA3   BRX COA2
COA4   LDX COAT; SBRR COA


* CHECK PLAUSIBILITY OF NAME
CPN    ZRO XCPN; STX CPNX; EAX EXBL,2; CXA; ETR =37777B; STA CPNA
       LDA SIZX; CNA
       LDB =SLU-3; SKG =SLU*6-1
       LDB =SMU-3; SKG =SMU*6-1; LDB =SSU-3
       STB CPNB; LDA* CPNA; LRSH 18; SKE ='('
       SKG =0; SBRR CPN; LDP* CPNA; LDX =-8
       SBRM CPNAM; SBRR CPN; LDA =2; ADM CPNA; LDP* CPNA
       LDX =-5; LRSH 18; SBRM CPNAM; SBRR CPN

* THE NEXT LINE PREVENTS 940 FILES FROM ASSUMING TYPES > 5

       LDP* CPNA; CBA; ETR =7B4; SKLE =5B4; SBRR CPN
       CBA; ETR =3B5; SKLE =1B5; BRU CPN2
       CBA; ETR =3777B; SKLE CPNB; SBRR CPN
CPN1   MIN* CPN; LDX CPNX; SBRR CPN
CPN2   SKE =2B5; SBRR CPN; BRU CPN1

* CHECK STRUCTURE OF FILE NAME IN INDEX BLOCK
* SKIPS IF SUCCESSFUL.  ENTER WITH NAME TO BE CHECKED IN AB
*   AND A NEGATIVE COUNT OF THE NUMBER OF CHARACTERS IN X.
CPNAM  ZRO XCPNAM
CPNAM1 STA CPNAMT; ETR =77B; SKNE ='.'; SBRR CPNAM
       SKNE ='?'; SBRR CPNAM; LDA CPNAMT; LCY 6
       BRX CPNAM1; MIN* CPNAM; SBRR CPNAM

* DECODE DISK ADDRESS
* UNPACKS FORMATTED DISK ADDRESS INTO UNIT, TRACK
*   BAND, AND SECTOR.  ENTER WITH FORMATTED ADDRESS
*   IN A.
DDA    ZRO XDDA; STA SECTOR; ETR =3B; STA UNIT
       LDA SECTOR; RSH 12; ETR =377B; STA TRACK
       LDA SECTOR; RSH 6; ETR =77B; STA BAND
       LDA SECTOR; RSH 2; ETR =17B; STA SECTOR; SBRR DDA

* DELETE NAME
* DELETE ALL INSTANCES OF NAME FROM INDEX BLOCK
DELN   ZRO XDELN; SBRM FFN; SBRR DELN
DELN1  CLAB; STP EXBL,2; STP EXBL+2,2; STP EXBL+4,2
       SBRM FFC; SBRR DELN; BRU DELN1

* DELETE NAME COMPLEMENTED.  THIS IS FOR DELETING OLDER VERSIONS
* FROM INDEX BLOCK AFTER SUCCESSFUL WRITE OPERATIONS.
DELNC  ZRO XDELNC; LDA NAME; EOR =-1; STA NAME
       SBRM DELN; LDA NAME; EOR =-1; STA NAME; SBRR DELNC

* DECODE FILE ADDRESS
* ENTER WITH PHYSICAL (FORMATTED) DISK ADDRESS IN A.
*   CONVERTS TO USER NUMBER (IN USER) AND BLOCK NUMBER
*   IN USER SPACE (IN A ON SUCCESS RETURN).  DOES NOT
*   SKIP IF ADDRESS IS OUT OF BOUNDS.
DFA    ZRO XDFA; SBRM DDA; LDX UNIT; LDA EBANDTAB,2
       MRG =2B7; STA DFAP; SUB BANDTAB,2; STA DFAT
       CNA; CAX; LDA BAND; SKE* DFAP; BRX *-1
       CXA; ADD DFAT; ETR =37B; STA BAND; SBRM EDA
       SUB DISKBASE; STA DFAT; LDX =-MAXUNO
DFA1   SKG UBASE+MAXUNO,2; BRU DFA2; BRX DFA1; SBRR DFA
DFA2   SKE UBASE+MAXUNO,2; BRU *+2; BRX *+1
       CXA; SUB =-MAXUNO; ETR =777B; STA USER
       CAX; LDA UBASE-1,2; SBRM DDA
       LDA TRACK; STA TRACKT
       LDA BAND; STA BANDT
       LDA SECTOR; STA SECTT
       LDA DFAT; SBRM DDA
       LDA TRACK; SUB TRACKT; MUL =NBAND; LSH 23
       ADD BAND; SUB BANDT; MUL =NSEC; LSH 23
       ADD SECTOR; SUB SECTT; MIN* DFA; SBRR DFA

* DO DISK READ OR WRITE USING KLUDGE DIRECT I/O.
* (A)=CORE ADDRESS, (B)=PROPERLY FORMATTED DISK ADDRESS
* NO SKIP ON ERROR
* DKR CALLS DTR, HANDING IT READ COMMAND.  SKIPS IF
*   SUCCESSFUL.  OTHERWISE PRINTS TSU DUMP.
* DKW CALLS DTR, HANDING IT WRITE COMMAND.  IF REREAD
*   CONTAINS -1, THE BLOCK JUST WRITTEN IS READ BACK
*   INTO VB AND COMPARED WORD BY WORD WITH THE ORIGINAL
*   DATA.  IF DATA DOES NOT COMPARE, TYPES MESSAGE.
*   SKIPS IF SUCCESSFUL.  OTHERWISE PRINTS TSU DUMP.
DKR    ZRO XDKX; NOP =0; SBRM DTR; BRU DKX00; BRU DKX0
DKX00  SBRM RRETRY; BRU DKX1
DKX0   MIN* DKR; SBRR DKR

       IF AUTO

DKX1   SBRR DKR

       ELSE

DKX1   SKA =400B; BRU DKX2
DKX1A  SBRM PKE; SBRR DKR
DKX2   CLA; STA DKCT; LDA DKKA; STA DKTA
DKX3   LDA DKTA; ETR =7777B; MRG =377B4; STA DKKA
       NOP =0; SBRM DTRB; NOP; LDA DKKA; ETR =7777B; STA DKKA
       NOP =0; SBRM DTRB; NOP; LDA DKTA; STA DKKA
       NOP =0; SBRM DTRB; BRU *+2; BRU DKX0
       SKA =400B; BRU *+2; BRU DKX1A
       MIN DKCT; CAB; LDA DKCT; SKG =3; BRU DKX3; CBA; BRU DKX1A

       ENDF

DKW    ZRO XDKX; NOP =30B6; SBRM DTR; BRU DKX1
       SKN REREAD; BRU DKX0
       LDA =2B7+4000B; ADD DKCA; STA DVP1
       LDA =2B7+4000B; ADD =VB; STA DVP2
       LDA =VB; NOP =0; SBRM DTRA; BRU *+2; BRU DKW1; SBRM RRETRY

       IF AUTO; BRU DKX1; ELSE; BRU DKX4; ENDF

DKW1   LDX =-4000B; LDA =10; STA DVEC
DKX5   LDA* DVP1; SKE* DVP2

       IF AUTO; BRU DKX1; ELSE; BRU DKX6; ENDF

DKX7   BRX DKX5; LDA DVEC; SKE =10; BRU DKX1; BRU DKX0
DKX4   MSG DKRRM; BRU DKX1
DKRRM  ASC "$REREAD ERROR:/"
DKX6   STX DVC; LDA DVEC; SKE =10; BRU DKX8; MSG DKCEM
DKX8   MSG CRLF; LDA DVC; ADD =4000B; PNO :,=8; TCH ':'
       TCH ' '; PNO ←DVP1,=8; TCH ' '; PNO ←DVP2,=8
       LDX DVC; SKR DVEC; BRU DKX7; MSG DKMEM; BRU DKX1
DKCEM  ASC '$COMPARE ERROR:/'
DKMEM  ASC '$.../'

* DO 1 ACTUAL DISK TRANSFER
* ENTER AS WITH DKR & DKW ABOVE.  FORMS A DIRECT I/O
*   NODE AND DOES A BRS 137.  SKIPS IF SUCCESSFUL.
DTR    ZRO XDTR; STB DKKA
DTRA   NOP XDTR; STA DKCA
DTRB   NOP XDTR; LDX XDTR; LDA* -1,2; STA DKINS
       LDX =DKNODE-DKNTOP; CLA
DTR2   STA DKNTOP,2; BRX DTR2
       LDA DKKA; STA DKNODE; STA DKNODE+1
       MRG =1B7; STA DKNODE+2
       LDA =13000205B; STA DKNODE+4
       LDA DKINS; MRG =777777B; STA DKNODE+5
       LDA DKCA; SKA =77743777B; BRU FATAL; CAX
       LDA =DKNODE; LDB =DKNTOP-DKNODE; BRS 137
       LDA DKNODE+17; SKA =7777B; SBRR DTR
       LDA DKINS; SKE =0; BRU DTR3
       LDA DKNODE+7; SKE DKKA; BRU DTR4
DTR3   MIN* DTR; SBRR DTR
DTR4   LDA =77770400B; SBRR DTR


* ROUTINE TO DO A RE-READ IN THE EVENT OF A READ FAILURE.
RRETRY ZRO XRTY; CLA; STA ERRCNT
RRTRY0 NOP =0; SBRM DTRB; BRU RRTRY1
       MIN* RRETRY; SBRR RRETRY
RRTRY1 MIN ERRCNT; LDA ERRCNT; SKG =NORDERRS; BRU RRTRY0; SBRR RRETRY

* ENCODE DISK ADDRESS
* PUTS CONTENTS OF UNIT, TRACK, BAND, & SECTOR
*   INTO A FORMATTED DISK ADDRESS IN A.
EDA    ZRO XEDA; LDA UNIT; STA DISKA; CLB
       LDA TRACK; LSH 12; ADM DISKA
       LDA BAND; LSH 6; ADM DISKA
       LDA SECTOR; LSH 2; ADD DISKA; SBRR EDA

* FIND BLOCK BLKNO, FLAGGING IF LAST
FBL    ZRO XFBL; LDA BLKNO; SBRM FSB; BRU FBL2
FBL1   MIN* FBL; SBRR FBL
FBL2   LDA =4B7; MRG BLKNO; SBRM FSB; SBRR FBL
       LDA =4B7; ADM BLKNO; BRU FBL1

* FIND END OF DATA IN SCRATCH FILE
* ENTER WITH FILE NUMBER IN A.  RETURNS LENGTH IN A.
FED    ZRO XFED; CAX; LDB =10002B; BRS 143; SBRR FED

* FIND FILE NAME
* SEARCHES INDEX BLOCK FOR NAME STARTING AT
*   BEGINNING.  SKIP RETURNS IF SUCCESS.
*   ACCESS KEYS ARE STORED AT ACCESS.
*   PASSWORD AT GROUP.  DATE WRITTEN IS RE-
*   TURNED IN A.
FFN    ZRO XFFN; LDX SIZX
FFN1   LDA NAME
FFN2   SKE EXBL,2; BRU FFN4; LDA NAME+1
       SKE EXBL+1,2; BRU FFN3; LDA NAME+2
       SKE EXBL+2,2; BRU FFN3; LDB EXBL+3,2
       LDA =77B6; SKM NAME+3; BRU FFN3
       LDA EXBL+4,2; ETR =77B6; STA ACCESS
       LDA EXBL+5,2; STA GROUP; CBA; ETR =@77B6
       MIN* FFN; SBRR FFN
FFN3   EAX 5,2; BRX FFN1; SBRR FFN
FFN4   EAX 5,2; BRX FFN2; SBRR FFN
* ENTRY TO START FROM PRESENT INDEX
FFC    ZRO XFFN; BRU FFN3

* FIND LENGTH OF FILE
FLF    ZRO XFLF; CLA; STA FLFL
       SBRM FFN; SBRR FLF; STA FLFT; BRU FLF1
FLF2   SBRM FFC; BRU FLF3
FLF1   SKA =1B5; LDA =3777B; ETR =3777B
       ADD =1; ADM FLFL; BRU FLF2
FLF3   LDA FLFL; LDB FLFT; MIN* FLF; SBRR FLF

* FIND SPECIFIED BLOCK
* SEARCHES THE INDEX BLOCK FOR LOCATION OF SPECIFIED
*   BLOCK NUMBER OF GIVEN FILE NAME.  ENTER WITH
*   BLOCK NUMBER IN A OR NEGATIVE NUMBER FOR LAST
*   BLOCK.  SKIP RETURNS IF SUCCESSFUL, LEAVING
*   INDEX OF ENTRY IN X.
FSB    ZRO XFSB; SKG =-1; BRU FSB5
       MRG =1B5; LDB =77303777B
FSB1   MRG NAME+3; STA FSBN; LDX SIZX
FSB2   SKM EXBL+3,2; BRU FSB4; LDA NAME
       SKE EXBL,2; BRU FSB3; LDA NAME+1
       SKE EXBL+1,2; BRU FSB3; LDA NAME+2
       SKE EXBL+2,2; BRU FSB3; MIN* FSB; SBRR FSB
FSB3   LDA FSBN
FSB4   EAX 5,2; BRX FSB2; SBRR FSB
FSB5   LDA =2B5; LDB =77300000B; BRU FSB1

* FIND NAME IN OLD INDEX BLOCK
* COMPARES NAME WITH CONTENTS OF OLD INDEX BLOCK.
*   SKIPS IF SUCCESSFUL
FON    ZRO XFON; LDX SIZOX
FOC    NOP XFON; LDB =77B6
FOC1   EAX 5,2; BRX FOC2; SBRR FON
FOC2   LDA EXOBL,2; SKE NAME; BRU FOC1
       LDA EXOBL+1,2; SKE NAME+1; BRU FOC1
       LDA EXOBL+2,2; SKE NAME+2; BRU FOC1
       LDA EXOBL+3,2; SKM NAME+3; BRU FOC1
       ETR =@77B6; MIN* FON; SBRR FON

* GENERATE BASE ADDRESS FROM USER NUMBER
* ENTER WITH USER NUMBER IN A.  COMPUTES START
*   OF USER SPACE, OFFSETS BY DISKBASE
*   TRANSLATES TO DIFFERENT BAND (TO ALLOW
*   FOR POSSIBLE BAD ONES), AND CHECKS FOR
*   BAD SPOTS, INCREMENTING UNTIL 1ST ONE
*   IS NOT FOUND.  FORMATTED PHYSICAL DISK ADDRESS
*   IS RETURNED AND STORED IN XRADDR.
GBU    ZRO XGBU; STA IUNO; ETR =777B; CAX; LDA UBASE-1,2
       ADD DISKBASE; STA XRBASE; LDA =-3776B; STA SIZX; LDX SIZX
GBU1   SBRM CDA; SBRM TBAD; BRU GBU2
       EAX 5,2; BRX GBU1; HLT *
GBU2   STA XRADDR; SBRR GBU

* GET COMPLETE FILE NAME + READ INDEX
* GION ENTRY--SETS TERCH TO SEMICOLON, RESETS DIROK
* GCFN ENTRY--DOES NOT DO EITHER OF THE ABOVE
GION   ZRO XGCFN; LDA =';'; STA TERCH; CLA; STA DIROK
GCFN   NOP XGCFN
GCFN1  SBRM CIN
GCFN2  NOP XGCFN; CLB; STB FGROUP; LDB =-1; STB FUSER
GCFN3  STA CHAR; SKE ='@'; BRU GCFN6; SKN FUSER

       IF AUTO; BRU GCFN11; ELSE; BRU GCFN10; ENDF

       SBRM GUN; STA GCFNC; SBRM SUNP; BRU ERR450
       STB GCFNT; CAX
       LDA GCFNC; SKE =':'; BRU GCFN4; BRU GCFN5
GCFN4  SKE ='('

       IF AUTO; BRU GCFN11; ELSE; BRU GCFN10; ENDF; CET 3

       SBRM GGN; STA FGROUP; CET 0

       IF AUTO; ELSE; TCH ')'; ENDF

       SBRM CIN; SKE =':'

       IF AUTO; BRU GCFN11; ELSE; BRU GCFN10; ENDF

GCFN5  SKN FUSER

       IF AUTO; BRU GCFN11; ELSE; BRU GCFN10; ENDF

       STX FUSER; SBRM CIN; BRU GCFN3
GCFN6  SKE ='<'; BRU GCFN7; LDA USER1; BRU GCFN8
GCFN7  SKE ='>'; BRU GCFN9; LDA USER2
GCFN8 SKG =0; BRU GCFN12; CAX; BRU GCFN5
GCFN9  LDA FUSER; SKG =0; LDA UNO; STA FUSER
       SBRM RXU; BRU GCFN11
       LDA CHAR; SBRM GDFN

       IF AUTO; BRU GCFN11; ELSE; BRU GCFN10; ENDF; SBRR GCFN

GCFN10  MSG GCFNM
GCFN11  SBRM WOCI

       IF AUTO; BRU ERR455; ELSE; BRU GCFN1; ENDF

GCFN12 SKE =-1

       IF AUTO; BRU GCFN11; ELSE; BRU GCFN10; ENDF

       LDA UNO; SBRM RXU; BRU GCFN11
       LDA CHAR; BRU GCFN3
GCFNM  ASC ' ? /'

* GET DATE ROUTINE
GDATE  ZRO XGDATE; SBRM GNO; STA GMO
       MSG GDAYM; SBRM GNO; STA GDAY
       MSG GYRM; SBRM GNO; STA GYR
       MSG GHRM; SBRM GNO; RSH 5; LDA GDAY; RSH 5
       LDA GMO; RSH 4; LDA GYR; SUB =60; ETR =37B; LSH 14
       SBRR GDATE
GDAYM  ASC " DAY: /"
GYRM   ASC " YEAR: /"
GHRM   ASC " HOUR: /"

* GET DISK FILE NAME
* ENTER WITH 0 OR A CHARACTER IN A.  IF A CHARACTER,
*   APPEND IT TO THE NAME, OTHERWISE ACCUMULATE NAME
*   UNTIL A SPECIAL CHARACTER IS TYPED.  IF TERCH OR
*   ".", JUSTIFY NAME & SKIP RETURN TERMINAL CHARACTER.
*   IF SEMICOLON OR "?" FAIL RETURN.  IF "," FAIL
*   RETURN IF DIROK IS NEGATIVE.  ELSE READ A DECIMAL
*   NUMBER <=127 AND STORE IT IN BLKNO.  INCREMENT
*   DIRECT (NORMALLY -1), JUSTIFY NAME IF TYPED, AND
*   SKIP RETURN TERMINAL CHARACTER.
GDFN   ZRO XGDFN; COPY AX,A,B; STP NAME; STP NAME+2
       LDA =-1; STA DIRECT; LDA =4*NAME; STA GDFNC
       CXA; SKG =0
GDFN1  SBRM CIN; STA CHAR; SKNE =141B; BRU GDFN6
       SKNE TERCH; BRU GDFN5
       SKNE ='.'; BRU GDFN5
       SKNE =';'; SBRR GDFN
       SKNE =','; BRU GDFN3
       SKNE ='?'; SBRR GDFN
       SKA =300B; BRU GDFN1; LDA CHAR; SBRM WCI4; BRU GDFN2
       MIN GDFNC; BRU GDFN1

       IF AUTO

GDFN2  BRU ERR455

       ELSE

GDFN2  TCH '↑'; BRU GDFN1

       ENDF

GDFN3  SKN DIROK; BRU *+2; SBRR GDFN
       SBRM GNO; SKA =@177B; BRU ERR455; STA BLKNO; MIN DIRECT
GDFN4  LDA CHAR; MIN* GDFN; SBRR GDFN
GDFN5  LDA NAME; SKE =0; BRU GDFN4; SBRR GDFN
GDFN6  SKR GDFNC; CLA; SBRM WCI4; ZRO *; BRU GDFN2

* GET GROUP NAME
* COLLECTS PASSWORD OF ARBITRARY LENGTH, TERMINATING WITH ")"
GGN    ZRO XGGN; CLA; STA GGNN
GGN1   SBRM CIN; SKE =')'; BRU GGN2; LDA GGNN; SBRR GGN
GGN2   ADD GGNN; ADC =0; CAB
       LCY 6; STA GGNN; BRU GGN1

* GET FREE BLOCK FROM INDEX BLOCK
GFB    ZRO XGFB; BRU GFB2
GFB1   SBRM CBE; BRU GFB2; MIN* GFB; SBRR GFB
GFB2   EAX 5,2; BRX GFB1; SBRR GFB

* GET (DECIMAL) NUMBER
* READS DECIMAL NUMBER TERMINATED BY ".".  OTHERWISE
*   TYPES "?" AND RETURNS TO COMMAND PROCESSOR
GNO    ZRO XGNO; LDB =10; SBRM BRS38
       XAB; SKE ='.'; BRU ERR455; CBA; SBRR GNO

* GET USER NUMBER
GNU    ZRO XGNU; SBRM GUT; SKE ='.'; BRU ERR455; CBA; SBRR GNU

* GET OWNED FILE NAME
* DO NOT LEAVE ROUTINE UNTIL AN OWNED NAME
*   HAS BEEN TYPED.  KEEP TRYING OVER
GOFN   ZRO XGOFN; SBRM GCFN; SBRM COA; BRU GOFN1; SBRR GOFN

       IF AUTO

GOFN1  BRU ERR451

       ELSE

GOFN1  MSG GCFNM; SBRM WOCI; BRU GOFN+1

       ENDF


* GET USER NAME
* COLLECTS USER NAME UP TO 18 CHARACTERS & PLACE IN UNAME
GUN    ZRO XGUN
       CLAB; STA GUNCT; STP UNAME; STP UNAME+2; STP UNAME+4
       LDA =3*UNAME-1; STA UNPTR; STA UNPTR1
GUN1   SBRM CIN; SKE =':'; BRU *+2; SBRR GUN
       SKE ='('; BRU *+2; SBRR GUN
       MIN GUNCT; XMA GUNCT; SKG =18; BRU GUN2
       STA GUNCT

       IF AUTO; BRU ERR455; ELSE; TCH '↑'; BRU GUN1; ENDF

GUN2   XMA GUNCT; WCI UNPTR; BRU GUN1

* GET USER NUMBER AND TERMINATOR
GUT    ZRO XGUT
GUT0   LDB =10; SBRM BRS38
       XAB; SKE =4B7+'#'; BRU GUT1; BRU GUT0
GUT1   SKE =4B7+'@'; BRU GUT2; SBRM GUN
       SBRM SUNP; BRU ERR455; CAB; SBRM CIN; SBRR GUT
GUT2   XAB; SKG =MAXUNO; SKG =0; BRU ERR455; XAB; SBRR GUT

* INITIALIZE POP VECTOR AND COMMAND FILES
INIT   ZRO XINIT; STA FI; STB FO
       LSH 36; MRG FI; STA FDUAL
INIT1  NOP XINIT; LDP TV100; STP 100B
       LDP TV102; STP 102B; CLA; STA B38F

       IF AUTO; STA FILE; ENDF; SBRR INIT

* INITIALIZE USER'S INDEX RECORD
* ENTER WITH USER NUMBER IN A
* SKIP RETURN IF SUCCESSFUL
IXR    ZRO XIXR; STA SIZX; LDX =-3777B
       CLA; STA XOBL; STA EXBL,2; STA EXOBL,2; BRX *-2
       LDA SIZX; ETR =777B; CAX; LDA UBASE-1,2
       SBRM DDA; LDA TRACK; STA TRACKT
       LDA BAND; STA BANDT
       LDA SECTOR; STA SECTT
       LDA UBASE,2; SBRM DDA
       LDA TRACK; SUB TRACKT; MUL =NBAND; LSH 23
       ADD BAND; SUB BANDT; MUL =NSEC; LSH 23
       ADD SECTOR; SUB SECTT; STA IXRT; MUL =-6; LSH 23; STA XSIZX
       LDA SIZX; SBRM GBU; LDX XSIZX; STX SIZX
       EAX BACKOFF,2
IXR0   SBRM CDA; SBRM TBAD; BRU IXR01; EAX 5,2; BRX IXR0; ZRO *
IXR01  STA XRBADDR; LDX SIZX
IXR1   SBRM CDA; SKE XRADDR; BRU IXR4
IXR11  LDB IXRT; LSH 24+18; STA EXBL+1,2
IXR2   LDA =-1; STA EXBL,2
IXR3   EAX 5,2; BRX IXR1; SBRM WXR; SBRR IXR; MIN* IXR; SBRR IXR
IXR4   SKE XRBADDR; BRU *+2; BRU IXR11; SBRM TBAD; BRU IXR3; BRU IXR2

       IF AUTO; ELSE

* ADVANCE TO NEXT USER
NXU    ZRO XNXU; LDA NUSERS; SKG CUSER; SBRR NXU
       MIN CUSER; MSG NXUM; LDA CUSER; SBRM PUN; MSG CRLF
       LDA CUSER; MIN* NXU; SBRR NXU
NXUM   ASC '*** USER /'

       ENDF

* MARK CURRENT FILE NAME TO BE LEFT IN DIRECTORY DURING WRITE IN
* CASE IT FAILS.  CURRENT BLOCKS ARE THUS SAVED SO THAT CURRENT VERSION
* OF FILE IS NOT LOST.
MARKN  ZRO XMARKN; SBRM FFN; SBRR MARKN
MARKN1 LDA EXBL,2; EOR =-1; STA EXBL,2
       SBRM FFC; SBRR MARKN; BRU MARKN1

* ROUTINE TO OPEN A FILE
* ENTER WITH ADDRESS OF FILE NAME STRING POINTER IN A
*   AND 15 IN B (FOR INPUT) OR 16 (FOR OUTPUT)
*   X SHOULD CONTAIN 0 FOR SEQUENTIAL OR 4B7 FOR RANDOM
*   FAILS TO ERR.  EXITS WITH FILE NUMBER IN A
OFL     ZRO XOFL; STA OFLP; STB OFLT; STX OFLX; LDP* OFLP; STP UNPTR
        LDA =3*FNAME-1; STA FNPTR; STA FNPTR1
OFL1    GCI UNPTR; BRU OFL2; WCI FNPTR; BRU OFL1
OFL2    LDA OFLX; LDB =FNPTR; LDX =-1
        BRS* OFLT; BRU ERR455; SBRR OFL

* OPEN LOCK FILE
OLF    ZRO XOLF; LDA =OLFNP; LDB =16; LDX =4B7; SBRM OFL; STA LOCKF
       COPY AX,A; LDB =1
       BRS 101; LRSH 6; STA OLFT; BRS 43; MRG OLFT; BRS 44
       SBRR OLF
OLFNP  DATA 3*OLFNS-1,3*OLFNS-1+21
*      NAME CHANGED FROM LOCKS-PFS FOR SECURITY PURPOSES
OLFNS  ASC '#1:"X173-LOKPFS:9BIN"'

* PRINT ACCESS PARAMETER
PAP    ZRO XPAP; XXA; TCH* PAPTAB,2; CAX; SBRR PAP
PAPTAB DATA '-','N','R','W'

* PRINT DISK ADDRESS
* ENTER WITH FORMATTED DISK ADDRESS IN A
PDA    ZRO XPDA; SBRM DDA

       IF AUTO; SBRR PDA; ELSE

       TCH ' '; TCH 'U'; PNO UNIT; TCH 'T'; PNO TRACK,=8
       TCH 'B'; PNO BAND,=8; TCH 'S'; PNO SECTOR,=8; SBRR PDA

* PRINT FILE ADDRESS
* ENTER WITH PHYSICAL DISK ADDRESS (FORMATTED) IN A.
*   CONVERTS TO USER NUMBER, FILE NAME, AND PAGE NUMBER
*   IN FILE.  TYPES OUT ON OUTPUT FILE.
PFA    ZRO XPFA; SBRM DFA; BRU PFA6; STA PFAB
       LDA USER; SKE UNO; BRU PFA5
PFA1   SKE FUSER; BRU PFA4
PFA2   LDA PFAB; MUL =6; LSH 23; ADD SIZX; STA PFAX
       CAX; SBRM PNM; LDX PFAX
       LDA EXBL+3,2; SKA =2B5; BRU PFA3; MSG PFPG
       ETR =3777B; PNO :; BRU PFA3A
PFA3   MSG PFLB
PFA3A  MSG CRLF; SBRR PFA
PFA4   STA FUSER; SBRM CLL; LDA FUSER
       SBRM RXU; NOP; BRU PFA2
PFA5   SBRM PUN; TCH ':'; LDA USER; BRU PFA2
PFA6   MSG PFUM; SBRR PFA
PFUM   ASC '<UNASSIGNED>/'
PFLB   ASC ', LAST PAGE/'
PFPG   ASC ', PAGE /'

       ENDF

* PRINT FILE PARAMETERS
PFP    ZRO XPFP; STX PFPX; LDP EXBL,2; STP NAME
       LDP EXBL+2,2; STA NAME+2
       CBA; ETR =77B6; STA NAME+3
       LDA ='S'; SKB =4B5; LDA ='R'; CIO FO
       LCY 12; ETR =7; ADD ='0'; CIO FO; TCH ','
       LDA EXBL+4,2; LRSH 22; SKNE =2; BRU PFP1
       SBRM PAP; TCH ','
PFP1   LDA EXBL+4,2; LRSH 20; ETR =3; SKG =0; BRU PFP2
       TCH '('; LDA EXBL+5,2; SKE =0; BRU PFP4
PFP1A  TCH ')'; LDA EXBL+4,2; LRSH 20; ETR =3; SBRM PAP; TCH ','
PFP2   LDA EXBL+4,2; LRSH 18; ETR =3; SKNE =3; BRU PFP3
       TCH 'O'; SBRM PAP; TCH ','
PFP3   SBRM FLF; BRU ERR455; PNO :; TCH ' '; LDX PFPX
       LDA EXBL+4,2; ETR =36000B; RSH 10; PNO :; TCH '/'
       LDA EXBL+4,2; ETR =1740B; RSH 5; PNO :; TCH '/'
       LDA EXBL+4,2; ETR =74B4; RSH 14; SKG =10; ADD =16; ADD =60; PNO :
       TCH ','; LDA EXBL+4,2; ETR =37B; PNO :; TCH 'H'
       LDX PFPX; SBRR PFP
PFP4   CAB; RCY 6; LDA FUSER; SKE UNO; BRU PFP1A
PFP5   CLA; LSH 6; SKG =0; BRU PFP5
PFP6   CIO FO; SKB =-1; BRU PFP7; BRU PFP1A
PFP7   CLA; LSH 6; BRU PFP6

       IF AUTO; ELSE

* PRINT TSU DUMP AFTER ERROR
PKE    ZRO XPKE; SKA =400B; BRU PKE3; MSG PKEM1; LDA DKKA
       SBRM PDA; TCH ' '; LDA DKINS; SKE =0; BRU PKE2; MSG PKEM2
PKE1   TCH ' '; PNO DKNODE+17,=8; MSG CRLF; SBRR PKE
PKE2   MSG PKEM3; BRU PKE1
PKE3   MSG PKEM4; LDA DKINS; SKE =0; BRU PKE5
       MSG PKEM6
PKE4   LDA DKNODE+7; SBRM PDA; MSG PKEM7
       LDA DKKA; SBRM PDA; MSG CRLF; SBRR PKE
PKE5   MSG PKEM5; BRU PKE4
PKEM1   ASC "$TSU DUMP:/"
PKEM2  ASC "READ/"
PKEM3  ASC "WRITE/"
PKEM4  ASC "TRIED TO /"
PKEM5  ASC "WRITE ON/"
PKEM6  ASC "READ FROM/"
PKEM7  ASC " INSTEAD OF/"

* PRINT NAME
PNM    ZRO XPNM; STX PNMX; EAX EXBL,2
       CXA; ETR =37777B; BRU PNM0
PNA    ZRO XPNM; STX PNMX
PNM0   STA PNMP; ADD =2; STA PNMC
PNM1   LDX =-4; LDB* PNMP
PNM2   CLA; LSH 6; SKE =0; BRU PNM3; LDX PNMX; SBRR PNM
PNM3   CIO FO; BRX PNM2; MIN PNMP; LDA PNMP
       SKG PNMC; BRU PNM1; LDA* PNMP; ETR =77B6
       CAB; LDX =-4; BRU PNM2

       ENDF


* PRINT NAME FORMATTED
PNF    ZRO XPNM; EAX EXBL,2; CXA; ETR =37777B
       STA PNMP; ADD =2; STA PNMC
PNF1   LDX =-4; LDB* PNMP
PNF2   CLA; LSH 6; CIO FO; BRX PNF2
       MIN PNMP; LDA PNMP; SKG PNMC; BRU PNF1
       LDX =-2; LDA* PNMP; LCY 6; CLA; LCY 18
PNF3   CLA; LSH 6; CIO FO; BRX PNF3; SBRR PNF


* PRINT TIME OF DAY
PTOD   ZRO XPTOD; MSG CRLF; LDA =3*UNAME-1; CAB
       BRS 91; LDX FO; BRS 35; SBRR PTOD

* PRINT USER NAME
PUN    ZRO XPUN; STA PUNO; CLB; LSH 3; CNA; CAX
       LDA IXRV,2; SKE =0; BRU PUN1
       TCH '#'; PNO PUNO; SBRR PUN
PUN1   EAX IXRV,2; CXA; ETR =37777B; MUL =3; LSH 23
       SUB =1; STA UNPTR; ADD =18; STA UNPTR+1
PUN2   GCI UNPTR; SBRR PUN; SKE =0; BRU PUN3; SBRR PUN
PUN3   CIO FO; BRU PUN2

* RUBOUT PROCESSOR
* IF A RUBOUT CAUSES A PROBLEM, CALL RBTF.  THIS SETS RBTFLG TO 0
*   AND IF WHILE IN THIS STATE A RUBOUT OCCURS, PROCESSING WILL BE
*   CONTINUED UNTIL THE NEXT CALL OF RBTN.  THEN THE RUBOUT WILL HAPPEN.
RBTN   ZRO XRBT; BRS 57; LDA =-1; XMA RBTFLG
       SKE =2B7; SBRR RBTF; BRU RUB1
RBTF   ZRO XRBT; BRS 57; CLA; STA RBTFLG; SBRR RBTF
RUBOUT ZRO RBTL; STA RBTA; LDA =2B6; BRS 78
       SKN RBTFLG; BRU RBTGO
RUB1   SBRM CLL; LDX =-1; BRS 11; BRS 29; SBRM CCF
       LDA =-1; XMA CCHAR; SKE =-1; BRU CMDPRO; BRU QUIT
RBTGO  LDA =2B7; STA RBTFLG; LDA RBTA; BRU* RBTL

* RECOGNIZE AND COMPLETE COMMAND
RCC    ZRO XRCC; XXA; MRG =2B7; STA CEPTR; XXA; LDX 0,2
RCC1   SKE* CEPTR; BRX RCC1; SKE* CEPTR; SBRR RCC
       CXA; ADD CEPTR; ETR =37777B; STA CIDX

       IF AUTO; ELSE

       ADD =1; LDB =-1; LDX FO; BRS 34

       ENDF

       LDX CIDX; MIN* RCC; SBRR RCC

* READ NAME OR DOT
RND    ZRO XRND; SBRM CIN; SKE ='.'; BRU RND1; LDA UNO
RND2   STA FUSER; SBRR RND
RND1   SKE =' '; BRU ERR455

       IF AUTO; ELSE; MSG RNDM; ENDF

       SBRM GUT; SKE ='.'; BRU ERR455; CBA; BRU RND2
RNDM   ASC 'FOR USER /'

* READ INDEX RECORD FOR GIVEN USER
* ENTER WITH USER NUMBER IN A.  SETS LOCK
*   AND STORES USER NUMBER IN IUNO, GETS DISK ADDRESS
*   FROM IUNO, READS RECORD, VERIFIES THAT IT IS
*   VALID INDEX RECORD, COPIES XBL TO XOBL, CHECKS
*   IUNO WITH UNO & SETS USER1 & USER2 IF THE SAME.
*   SKIPS IF SUCCESSFUL.  TYPES VARIOUS ERROR MESSAGES &
*   DOES NOT SKIP OTHERWISE.  LEAVES LOCK SET IF SUCCESSFUL.
RXR    ZRO XRXR; SBRM WSL; SBRM GBU
*  THE FOLLOWING CODE IS TO HELP THE DISK POSITION STABLY.
*  IT IS CURRENTLY PATCHED OUT.
       IF 0; STA RXB
       MRG =377B4; CAB; LDA =XBL; NOP =0
       SBRM DTR; NOP; LDA DKKA; ETR =7777B; STA DKKA
       NOP =0; SBRM DTRB; NOP; LDA RXB
       ENDF
       CAB; LDA =XBL; SBRM DKR

       IF AUTO; BRU RXR3; ELSE; BRU RXR4; ENDF

       SBRM VFY

       IF AUTO; BRU RXR3; ELSE; BRU RXR2; ENDF

       LDX SIZX; EAX BACKOFF,2
RXR0   SBRM CDA; SBRM TBAD; BRU RXR01; EAX 5,2; BRX RXR0; ZRO *
RXR01  STA XRBADDR
       LDX =-4000B
RXR1   LDA EXBL,2; STA EXOBL,2; BRX RXR1
       SBRM UPU; SBRM UPF; MIN* RXR; SBRR RXR
RXR2   MSG RXR2M; BRU RXR3
RXR2M  ASC "$INDEX FORMAT ERROR /"
RXR3   SBRM CLL; SBRR RXR
RXR4   MSG RXR4M; BRU RXR3
RXR4M  ASC "CAN'T READ INDEX$/"

* READ INDEX AND LOCK FOR DUMP PURPOSES
* LIKE RXR EXCEPT THAT SPECIAL LOCK VALUE SIGNIFYING
*  DUMP IN PROGRESS IS SET
RXD    ZRO XRXD; SBRM RXR; SBRR RXD; MIN* RXD
       LDA LUNO; CLB; LSH 3; CNA; CAX
       LDA =-1000; STA IXRV+7,2; SBRR RXD

* READ INDEX AND UNLOCK
* LIKE RXR EXCEPT THAT LOCK IS ALWAYS LEFT UNLOCKED
RXU    ZRO XRXU; STA RXUT; CLA; STA SIZX; LDA RXUT; SBRM RXR; BRU RXU1; MIN* RXU
RXU1   SBRM CLL; SBRR RXU

* SEARCH FOR USER NAME & PASSWORD
* ROUTINE TO SEARCH USER FILE FOR USER NAME, SKIP RETURNING USER 
*   NUMBER IN A AND PASSWORD IN B IF SUCCESSFUL.  FILE CONSISTS
*   OF ONE PAGE IN THE FOLLOWING FORMAT:
*      THE LAST WORD OF THE PAGE IS IXRV (INITIAL XR VALUE).
*      THIS CELL CONTAINS -8*(NO. OF ENTRIES).  ENTRY 1 IMMEDIATELY
*      PRECEDES IXRV, ENTRY 2 STARTS 8 WORDS BEFORE THAT, ETC.
*      EACH ENTRY IS 8 WORDS LONG.  THE FIRST SIX WORDS CONTAIN
*      THE USER'S NAME AS A STRING.  WORD 6 CONTAINS THE USER
*      PASSWORD.  WORD 7 IS THE LOCK WORD FOR THE USER'S DIRECTORY.
*      A VALUE OF +1 INDICATES THAT THE DIRECTORY IS NOT LOCKED.
*      0 OR NEGATIVE INDICATES A LOCKED DIRECTORY.  A SPECIAL
*      LOCK (NEGATIVE VALUE <=-1000B) INDICATES THE DIRECTORY
*      IS LOCKED FOR DUMP PURPOSES.  VARIOUS ROUTINES CAN TYPE
*      SPECIAL DIAGNOSTICS IN THIS CASE.
SUNP   ZRO XSUNP
       LDX IXRV
SUNP1  LDA UNAME
SUNP2  SKE IXRV,2; BRU SUNP5; LDA UNAME+1
       SKE IXRV+1,2; BRU SUNP4
       LDA IXRV+2,2; SKNE =0; BRU SUNP3; SKE UNAME+2; BRU SUNP4
       LDA IXRV+3,2; SKNE =0; BRU SUNP3; SKE UNAME+3; BRU SUNP4
       LDA IXRV+4,2; SKNE =0; BRU SUNP3; SKE UNAME+4; BRU SUNP4
       LDA IXRV+5,2; SKNE =0; BRU SUNP3; SKE UNAME+5; BRU SUNP4
SUNP3  CXA; CNA; RSH 3; ETR =3777B; LDB IXRV+6,2; MIN* SUNP; SBRR SUNP
SUNP4  EAX 7,2; BRX SUNP1; SBRR SUNP
SUNP5  EAX 7,2; BRX SUNP2; SBRR SUNP


       IF AUTO; ELSE

* GET READY FOR SYSTEM COMMAND
SYS    ZRO XSYS; MSG SYSLM; SBRM GNU; STA NUSERS
       MSG SYSFM; SBRM GNU; SUB =1; STA CUSER; STA BUSER
       LDA NUSERS; SKG CUSER; BRU ERR; MSG CRLF; SBRR SYS
SYSLM  ASC '$LAST USER= /'
SYSFM  ASC '$FIRST USER= /'

       ENDF


* TEST FOR BAD SPOT
* ENTER WITH FORMATTED PHYSICAL ADDRESS IN A.
*   CHECKS BAD SPOT LIST.  SKIP IF IT FINDS 
*   A BAD SPOT FOR ADDRESS GIVEN.
TBAD   ZRO XTBAD; STX TBI; LDX BADCNT; LDB BADMSK
TBAD1  SKM EBAD,2; BRU TBAD2; MIN* TBAD; BRU TBAD3
TBAD2  BRX TBAD1
TBAD3  LDX TBI; SBRR TBAD

* READ/WRITE SUPERBLOCK FROM BUFFER
* USES IOFLAG TO DETERMINE DIRECTION OF TRANSFER--
*   POS IF WRITING, NEG IF READING.  DRIVES DKR & DKW.
*   ENTER WITH (A) = FORMATTED DISK ADDRESS AND
*   (X) = DATA BUFFER LOCATION.  SKIPS IF SUCCESSFUL.
*   TYPES DIAGNOSTICS OTHERWISE.
TBB    ZRO XTBB; STA DBADDR; STX DBLOC
       LDA =DKR; SKN IOFLAG; LDA =DKW; STA DBBRS
       LDA DBLOC; LDB DBADDR; SBRM* DBBRS

       IF AUTO; SBRR TBB; ELSE; BRU TBB1; ENDF

       MIN* TBB; SBRR TBB

       IF AUTO; ELSE

TBB1   MSG KERRM; SKN BLKNO; BRU TBB2; LDA DBADDR; SBRM PFA
       SBRR TBB
TBB2   MSG KERRB; PNO BLKNO; MSG CRLF; SBRR TBB
KERRM  ASC '$DISK ERROR, /'
KERRB  ASC 'BLOCK /'

       ENDF

* TRANSLATE DISK ADDRESS
* ENTER WITH FORMATTED DISK ADDRESS IN A.
*   UNPACKS, SELECTS LOGICAL BAND ADDRESS,
*   REPLACES WITH PHYSICAL ADDRESS FROM
*   TABLE LOOKUP, AND REPACKS, RETURNING
*   DIFFERENT FORMATTED DISK ADDRESS IN A.
TDA    ZRO XTDA; STX TDAX; SBRM DDA
       LDX UNIT; LDA BANDTAB,2; ADD BAND; CAX
       LDA 0,2; STA BAND; SBRM EDA; LDX TDAX; SBRR TDA

* TRANSFER FILE BLOCK TO/FROM BUFFER
* ENTER WITH NUMBER OF WORDS IN BLOCK TO BE TRANSFERRED.
*   IF FILE IS SEQUENTIAL, USES BIO.  IF RANDOM, DBI OR
*   DBO DEPENDING ON IOFLAG.  SKIP RETURNS ON SUCCESS.
*   ELSE TYPES DIAGNOSTIC.
TFB    ZRO XTFB; CAX; LDA BLKNO; ETR =4B7-1; MUL =2000B
       LDA FTYPE; SKA =4B6; BRU TFB2
       CXA; LDX =DB; BIO FILE; BRU TFB5
TFB1   MIN* TFB; SBRR TFB
TFB2   CXA; LDX =DB; SKN IOFLAG; BRU TFB3
       DBO FILE; BRU TFB4
TFB3   DBI FILE
TFB4   SKN FILE; BRU TFB1
TFB5   LDB FILE; SKB =4B5

       IF AUTO; SBRR TFB; ELSE; BRU *+2; ENDF

       BRU TFB1; MSG DERRM; PNO BLKNO; SBRR TFB
DERRM  ASC '$DRUM ERROR, BLOCK /'

* TYPE FILE NAME.  USED IN CONJUNCTION WITH COMMAND FILES.
TFN    ZRO XTFN; LDA FI; SKE FII; BRU *+2; SBRR TFN
       LDA TERM; SKE ='.'; SBRR TFN
       LDP FNPTR; STP TFNPTR
TFN1   GCI TFNPTR; BRU TFN2; CIO FO; BRU TFN1
TFN2   LDA ='.'; CIO FO; SBRR TFN

* WCI IN 4 CHARACTERS PER WORD ROUTINE
* USED ONLY BY GDFN ROUTINE
WCI4   ZRO XWCI4; STA WCI4C; LDA GDFNC
       SKLE =4*NAME3; SBRR WCI4
       SKG =4*NAME; LDA =4*NAME; STA GDFNC
       LRSH 2; STA GDFNP; CLA; LSH 2; SUB =4
       MUL =-6; LSH 23; CAX; LDA =77B; LDB WCI4C
       RCY 6; LCY 0,2; EOR =-1; ETR* GDFNP; STA* GDFNP
       CBA; ADM* GDFNP; MIN* WCI4; SBRR WCI4

* WRITE NAME ON FNPTR STRING
* ENTER WITH A CONTROL CONSTANT IN A.  IF 0,
*   NAME IS WRITTEN ON STRING SURROUNDED BY
*   DOUBLE QUOTES.  IF NON-ZERO, NAME
*   IS NOT SURROUNDED BY DOUBLE QUOTES.
WNS    ZRO XWNS; STA WNQF; SBRM WNQ; LDA =NAME; STA WNSP
WNS1   LDB* WNSP; LDX =-4
WNS2   CLA; LSH 6; SKE =0; BRU WNS3; SBRM WNQ; SBRR WNS
WNS3   WCI FNPTR; BRX WNS2; MIN WNSP; BRU WNS1
WNQ    ZRO XWNQ; LDA ='"'; LDB =-1
       SKB WNQF; WCI FNPTR; SBRR WNQ

* WAIT FOR OUTPUT, CLEAR INPUT
* IF INPUT FILE IS TTY, WAITS FOR OUTPUT BUFFER TO EMPTY, THEN
*   CLEARS INPUT BUFFER.  OTHERWISE CLOSES COMMAND FILE.
WOCI   ZRO XWOCI; LDA FI; SKE =0; BRU WOCI1
       LDX =-1; BRS 14; BRS 11; SBRR WOCI
WOCI1  SBRM CCF; SBRR WOCI

* WAIT AND SET LOCK
WSL    ZRO XWSL; STA LUNO; CLB; LSH 3; CNA; CAX; BRS 57
WSL1   LDA LUNO; SKR IXRV+7,2; SBRR WSL; MIN IXRV+7,2
       LDA IXRV+7,2; SKG =-1000B

       IF AUTO; BRU ERR455; ELSE; BRU WSL2; ENDF

       LDA =1000; BRS 81; BRU WSL1
WSL2   MSG WSL2M; BRU QUIT
WSL2M  ASC "$DUMP IN PROGRESS - PLEASE WAIT/"

* WRITE INDEX RECORD
* COMPARES XBL WITH XOBL.  IF IDENTICAL, THEN
*   UNPACKS USER1 & USER2 AS IN RXR.  IF DIFFERENT,
*   THEN WRITES INDEX RECORD BEFORE UNPACKING
*   USER1 & USER2.  SKIP RETURN IF SUCCESSFUL.
WXR    ZRO XTXR; LDX =-4000B
WXR1   LDA EXBL,2; SKE EXOBL,2; BRU WXR2; BRX WXR1; BRU WXR3
WXI    ZRO XTXR
WXR2   LDA =XBL; LDB XRADDR; SBRM DKW

       IF AUTO; SBRR WXR; ELSE; BRU WXR4; ENDF

WXR3   SBRM VFY; BRU WXR4
* NOW WE HAVE WRITTEN MAIN XBLOCK OK.  WE TRY NEXT THE BACKUP BLOCK.
       LDA =XBL; LDB XRBADDR; SBRM DKW

       IF AUTO; SBRR WXR; ELSE; BRU WXR5; ENDF

       SBRM VFY; BRU WXR5; MIN* WXR; SBRR WXR
WXR4   MSG WXR4M; SBRR WXR
WXR4M  ASC "$CAN'T WRITE INDEX /"
WXR5   MSG WXR5M; SBRR WXR
WXR5M  ASC "$BACKUP INDEX BAD...CALL MAINT /"

* UNPACK FRIEND LIST
* UNPACKS FRIEND LIST FROM XRE INTO
*   FRIEND TO FRIEND+11
UPF    ZRO XUPF; LDX =-6; LDB XRE+2; LDA XRE+3
UPF1   LCY 8; STA FRIEND+6,2; ETR =377B
       XMA FRIEND+6,2; BRX UPF1; LDX =-6
       LDB XRE+4; LDA XRE+5
UPF2   LCY 8; STA FRIEND+12,2; ETR =377B
       XMA FRIEND+12,2; BRX UPF2; SBRR UPF

* UNPACK USER1 + USER2
* UNPACKS USER1 (<) AND USER2 (>) OUT OF
*   INDEX BLOCK IF IUNO = UNO
UPU    ZRO XUPU; LDA IUNO; SKE UNO; SBRR UPU
       LDA XRE+1; LRSH 8; ETR =377B; STA USER1
       CLA; LCY 8; STA USER2; SBRR UPU

* VERIFY AND REWRITE DATA FOR USER
VFD    ZRO XVFD; STA FUSER
       CLA; STA RDRTRY; STA WTRTRY; LDA FUSER
       SBRM RXR; SBRR VFD; LDX SIZX
VFD1   STX VFT; LDA EXBL,2; ADD =1; SKA =@1; BRU VFD3
       LDA EXBL+1,2; SKE =0; BRU VFD3
VFD2   LDX VFT; EAX 5,2; BRX VFD1; SBRM CLL; SBRR VFD
VFD3   LDA =-1; STA IOFLAG; STA BLKNO; SBRM CDA
       LDX =DB; SBRM TBB; BRU VFD6
       SKN REWRITE; BRU VFD2
VFD4   MIN IOFLAG
VFD5   LDX VFT; SBRM CDA; LDX =DB
       SBRM TBB; BRU VFD9; BRU VFD2
VFD6   SKN REWRITE; BRU VFD2
VFD7   MIN RDRTRY; LDA RDRTRY; SKG TRYLIM; BRU VFD8
       MSG VFDM1; BRU VFD2
VFD8   LDX VFT; SBRM CDA; LDX =DB; SBRM TBB; BRU VFD7; BRU VFD4
VFD9   MIN WTRTRY; LDA WTRTRY; SKG TRYLIM; BRU VFD5
       MSG VFDM2; BRU VFD2
VFDM1  ASC "$CAN'T READ THIS RECORD/"
VFDM2  ASC "$CAN'T REWRITE THIS RECORD/"


* FIND INDEX RECORD.  SEARCH FOR XBLOCK & SKIP IF SUCCESSFUL.
* IF 1ST BLOCK IS NOT XBLOCK IT MUST BE A BAD SPOT, ELSE FAIL.
FXR    ZRO XFXR
FXR1   LDA EXBL,2; SKE =-1; SBRR FXR
       LDA EXBL+1,2; SKE =0; BRU FXR2
       EAX 5,2; BRX FXR1; SBRR FXR
FXR2   MIN* FXR; SBRR FXR


* VERIFY INDEX RECORD
VFY    ZRO XVFY; LDX SIZX; SBRM FXR; SBRR VFY
       STX VFYX; EAX EXBL+6,2; CXA; ETR =37777B; MRG =2B7
       STA VFYP; LDX =-6; LDA* VFYP; STA XRE+6,2; BRX *-2
       LDX SIZX; EAX BACKOFF,2; SBRM FXR; SBRR VFY
       LDA EXBL+1,2; STA VFYY; STX EXBL+1,2; LDX VFYX
VFY1   EAX 5,2; BRX VFY2; MIN* VFY; SBRR VFY
VFY2   LDA EXBL,2; SKG =0; SKG =-2; BRU VFY3
       LDA EXBL+1,2; SKE =0; BRU VFY4; BRU VFY1
VFY3   SBRM CPN; SBRR VFY; BRU VFY1
VFY4   CXA; LDB =77777B; SKM EXBL+1,2; SBRR VFY
       LDA VFYY; STA EXBL+1,2; BRU VFY1

       IF AUTO; ELSE

* PRINT INDEX WRITE ERROR
XWE    ZRO XXWE; MSG XWEM; LDA CUSER; SBRM PUN; SBRR XWE
XWEM   ASC 'FOR USER /'

       ENDF


* ZERO DATA BUFFER
ZDB    ZRO XZDB; LDA ="???"; LDX =-NWD
ZDB1   STA EDB,2; BRX ZDB1; LDA ="?MJ"+40100B; LDX =-NWD
ZDB2   EAX 17B,2; STA EDB,2; BRX ZDB2; SBRR ZDB

* COMMAND TABLE

       IF AUTO

CMDTAB BRU SETUNO; ASC '  @/'       ACCEPT NAME & PASSWORD
       CMD (BRIEF LIST)
       CMD (CHANGE FILE NAME )
       CMD (DELETE FILE )
       CMD (EXAMINE FILE )
       CMD (FINISHED)
       CMD (LIST)
       CMD (READ DISK FILE )
       CMD (WRITE DISK FILE )

       ELSE

CMDTAB BRU SETUNO; ASC '  @/'       ACCEPT NAME & PASSWORD
       BRU SYSCOM; ASC '  $/'       DO SYSTEM COMMAND
       BRU CCC1; DATA 137B; ASC '/' END OF COMMAND FILE
       BRU QUOTE; ASC '  "/'        GO INTO QUOTE MODE
       CMD (ABANDON FILE )
       CMD (BRIEF LIST)
       CMD (CHANGE FILE NAME )
       CMD (DELETE FILE )
       CMD (EXAMINE FILE )
       CMD (FINISHED)
       CMD (GENERAL ACCESS TO FILE )
       CMD (LIST)
       CMD (MODIFY ITEM #)
       CMD (OWNER ACCESS TO FILE )
       CMD (PASSWORD ACCESS TO FILE )
       CMD (READ DISK FILE )
       CMD (UNUSED SPACE)
       CMD (VERIFY DATA)
       CMD (WRITE DISK FILE )

       ENDF

ECDTAB DATA CMDTAB-*

* SYSTEM COMMAND TABLE

       IF AUTO; ELSE
       IF MAINT

SYSTAB PCMD (COMMANDS)

       IF INCREMENT

       PCMD (BACKUP)

       ELSE

       PCMD (DUMP)

       ENDF

       PCMD (I/NITIALIZE)
       PCMD (LOAD)
       PCMD (MOVE DISK FILE )
       PCMD (A/SSUME)
       PCMD (STATUS)
       PCMD (UNLOCK DIRECTORY FOR USER )
       PCMD (V/ERIFY)

       ELSE
SYSTAB PCMD (UNLOCK DIRECTORY FOR USER )
       PCMD (MOVE DISK FILE )
       PCMD (COMMANDS)

       ENDF

ESYTAB DATA SYSTAB-*

       ENDF

* INITIAL ENTRY

       IF AUTO

START  LDA =CFNPTR; LDB =15; CLX; SBRM OFL; STA FII
       LDA =RFNPTR; LDB =16; CLX; SBRM OFL; STA FOO
       LDA FII; LDB FOO

       ELSE

START  STA FII; STB FOO

       ENDF

       SBRM INIT
START1 LDA =-1; STA RBTFLG; LDA =RUBOUT; STA 201B
       LDA =2B6; BRS 78; SBRM RBTF
       LDA =-1; STA CCHAR; STA LUNO; SBRM OLF
       LDX =-1; BRS 123; CAX; LDA UNOTAB,2
       SKG =MAXUNO; SKG =0; LDA =-1; STA UNO
CMDPR1 LDA =-1; STA USER1; STA USER2
* COMMAND LOOP ENTRY
CMDPRO SBRM CLL; SBRM RBTN; LDA =-1; STA TERCH; STA DIROK
       LDA FILE; SBRM CLS; CLA; STA FILE

       IF AUTO; ELSE; MSG CMDM; ENDF

       CET 0; SBRM CIN; STA CCHAR
       BRS 39; AXC; LCY 8; ETR =37B; STA TODAY
       CXA; LCY 5; ETR =1740B; ADM TODAY
       CXA; LCY 2; ETR =36000B; ADM TODAY
       CXA; RCY 2; SUB =60*4B4; ETR =74B4; ADM TODAY
       LDX =ECDTAB; LDA CCHAR; SBRM RCC; BRU ERR455
       LDA UNO; STA FUSER; BRU* -1,2
CMDM   ASC '$&/'

       IF AUTO

CFNS   ASC '#1:"APFS-CMNDS:9SYM"'
RFNS   ASC '#1:"APFS-RESP:9SYM"'
CFNPTR DATA 3*CFNS-1,3*CFNS-1+20
RFNPTR DATA 3*RFNS-1,3*RFNS-1+19

       ENDF


       IF AUTO; ELSE

* SYSTEM COMMAND
SYSCOM SBRM CIN; LDX =ESYTAB; SBRM RCC; BRU ERR; BRU* -1,2



* ERROR RETURNS TO COMMAND PROCESSOR
ERR    MSG ERRM; SBRM WOCI; BRU CMDPRO
ERRM   ASC ' ?/'

       ENDF

       IF AUTO

ERR431 MSG M431; BRU QUIT
ERR450 MSG M450; BRU QUIT
ERR451 MSG M451; BRU QUIT
ERR455 MSG M455; BRU QUIT
ERR456 MSG M456; BRU QUIT
M431   ASC "431 USER OR PASW BAD$/"
M450   ASC "450 NO SUCH FILE$/"
M451   ASC "451 CAN'T ACCESS$/"
M455   ASC "455 PFS ERR$/"
M456   ASC "456 ALREADY EXISTS$/"

       ELSE

ERR431 EQU ERR
ERR450 EQU ERR
ERR451 EQU ERR
ERR455 EQU ERR
ERR456 EQU ERR

       ENDF

FATAL  MSG FATALM

       IF AUTO

CMDXX  BRU QUIT

       ELSE

CMDXX  SBRM CCF; BRU CMDPRO

       ENDF

       IF AUTO

FATALM EQU M455

       ELSE

FATALM ASC '$** INDEX CLOBBERED **$/'

       ENDF

SXERR  MSG SXERRM; BRU CMDXX

       IF AUTO

SXERRM ASC "453 NO ROOM$/"

       ELSE

SXERRM ASC '$NOT ENOUGH ROOM/'

       ENDF

       IF AUTO

QUIT200 MSG M200; BRU QUIT
M200   ASC "200 OK$/"

       ENDF

QUIT   SBRM CCF; SBRM CLL; BRS 10



* ROUTINES TO EXECUTE COMMANDS


       IF AUTO; ELSE

* $ASSUME USER IDENTITY
AAA    SBRM CFC; MSG AAAM; SBRM GNU; STA UNO; BRU CMDPR1
AAAM   ASC     '$USER /'

* ABANDON FILE
AF     SBRM GCFN; SBRM CWA
       LDA FUSER; SBRM RXR; BRU ERR; SBRM FFN; BRU ERR
       CLA; STA BLKNO; STA DELFLG; LDA =-1; STA IOFLAG
AFC    LDA BLKNO; SBRM FSB; BRU AFC1; SBRM CDA
       LDX =DB; SBRM TBB; BRU AFC2
AFC3   MIN BLKNO; SKN BLKNO; BRU AFC; SKN DELFLG; BRU CMDPRO
       SBRM DELN; SBRM WXR; BRU ERR; BRU CMDPRO
AFC1   LDA BLKNO; SKG =-1; BRU FATAL
       LDA =4B7; ADM BLKNO; BRU AFC
AFC2   LDA BLKNO; SBRM FSB; BRU FATAL
       LDA =-1; CLB; STP EXBL,2; STA DELFLG; BRU AFC3

       ENDF


* BRIEF LIST (SEE LIST)

* CHANGE FILE NAME 
CF     SBRM GOFN; LDA FUSER; SBRM RXU; BRU ERR455
       SBRM FFN; BRU ERR450; STA FTYPE; SBRM CWA; BRU ERR451
       LDP NAME; STP OLDN; LDP NAME+2; STP OLDN+2

       IF AUTO; ELSE; MSG CFM; ENDF

       CLA; SBRM GDFN; BRU ERR455; SBRM FFN; BRU CF1

       IF AUTO; ELSE; MSG CFMM; ENDF; BRU ERR455

CF1    LDA FTYPE; ETR =474B3; ADM NAME+3
       SBRM CHD

       IF AUTO; BRU QUIT200; ELSE; BRU CMDPRO; ENDF

CFM    ASC '$TO /'
CFMM   ASC ' -NOT NEW/'


       IF AUTO; ELSE

* $COMMANDS
CCC    SBRM CONFRM; MSG FRFILE
       CLEAR; LDX FDUAL; BRS 15; BRU ERR
       STA FILE; CBA; SKE ='.'; BRU ERR
       LDA FILE; STA FI; LDB FO; SBRM INIT
       CLA; STA FILE; BRU CMDPRO
CCC1   SBRM CCF; BRU CMDPRO

       IF INCREMENT;

* INCREMENTAL DUMPING PROCEDURE:  IN GOING FROM MONTH A TO MONTH B,
*   FOR EXAMPLE, NEW FILES ARE ADDED AND OLD ONES DELETED, OTHERS
*   ARE OVERWRITTEN, AND CHANGES ARE MADE TO ITEM NUMBERS IN THE INDEX
*   BLOCKS.  WHEN DUMPING AT MONTH B, WE WANT TO DUMP ONLY THOSE
*   FILES THAT HAVE BEEN WRITTEN SINCE THE LAST DUMP.  ALSO, WE
*   WANT TO LIST THE FILES BEING DUMPED, TOGETHER WITH THOSE THAT
*   HAVE DISAPPEARED.
* THE PROCEDURE IS:
*   1)  READ IN A COPY OF THE INDEX BLOCK AS IT EXISTED AT LAST DUMP.
*       THIS COPY IS KEPT ON A SPECIAL PFS USER AREA.  TWO SUCH 
*       AREAS ARE USED: ONE FOR THE SAVED BLOCKS FROM THE LAST DUMP
*       AND ONE AS A WORKING SPACE TO HOLD THE NEW BLOCKS.
*   2)  READ IN THE CURRENT INDEX BLOCK.
*   3)  SEARCH OLD INDEX BLOCK FOR A FILE NAME.  SAVE NAME & DELETE
*          IT FROM OLD INDEX BLOCK.
*   4)  SEARCH NEW INDEX BLOCK FOR SAME NAME.  IF IT IS NOT FOUND,
*          TYPE NAME OUT AS HAVING BEEN DELETED DURING THE MONTH.
*       IF IT IS FOUND, CHECK THE DATE IT WAS LAST WRITTEN.  IF
*          IT HAS NOT BEEN WRITTEN SINCE THE LAST DUMP, DELETE IT
*          FROM THE DUMP AND TYPE NAME OUT AS HAVING BEEN DELETED
*          FROM THE DUMP AND THEN DELETE THE FILE FROM THE CURRENT
*          INDEX BLOCK--OTHERWISE, LEAVE THE FILE AS IS.
*   5)  ITERATE BACK TO 3) UNTIL OLD INDEX BLOCK IS EMPTY.
*   6)  DUMP ONTO FILE CONTENTS OF MODIFIED CURRENT INDEX BLOCK.
*   7)  WRITE COPY OF CURRENT INDEX BLOCK OUT FOR NEXT MONTH'S
*          COMPARISON PURPOSES.


BBB    SBRM CONFRM; LDA =-1; STA IOFLAG
BBB1   LDA OXBLN; SKG =0; BRU BBB10; SBRM GXB
       LDA UNO; SBRM RXD; BRU ERR; MSG ONFILE
       LDA =2B6; LDX FDUAL; CLB; BRS 16; BRU ERR; STA FILE
       LDX =-4000B; LDA EDB,2; STA EXOBL,2; BRX *-2; MSG DELFM
       LDX SIZOX; EAX 6,2; STX RWOX
BBB2   LDA EXOBL,2; SKG =0; SKG =-2; BRU BBB4
BBB3   EAX 5,2; BRX BBB2; LDX =XBL; LDA =4000B; BIO FILE; BRU FATAL
       CLA; STA NBLOX
       LDA =BBB14; STA BBBPTR; SBRM BBB11
       MSG BFM; LDA =BBB15; STA BBBPTR; SBRM BBB11
       SBRM CLL; LDA UNO; SBRM RXU; BRU ERR
       CLA; STA IOFLAG
       LDX =-4000B; LDA EXBL,2; STA EDB,2; BRX *-2
       LDA XBLN; SBRM GXB; SBRM CLL; BRU LDDX
BBB4   STX RWOX; LDP EXOBL,2; STP NAME; LDP EXOBL+2,2; STA NAME+2
       CBA; ETR =77B6; STA NAME+3
BBB5   CLAB; STP EXOBL,2; STP EXOBL+2,2; STP EXOBL+4,2
       SBRM FOC; BRU BBB6; BRU BBB5
BBB6   SBRM FFN; BRU BBB9; LDA EXBL+4,2; ETR =@77B6
       LRSH 14; SKG =10; ADD =16; LSH 14
       SKG DTIME; BRU BBB8
BBB7   LDX RWOX; BRU BBB3
BBB8   SBRM DELN
BBB9   LDA =NAME; SBRM PNA; MSG CRLF; BRU BBB7
BBB10  MSG DOLDM; SBRM GNU; STA OXBLN
       MSG DNEWM; SBRM GNU; STA XBLN
       MSG DMOM; SBRM GDATE; STA DTIME; BRU BBB1
BBB11  ZRO XBBB11; LDX SIZX; EAX 6,2; STX RWIX
BBB12  LDA EXBL,2; SKG =0; SKG =-2; BRU* BBBPTR
BBB13  EAX 5,2; BRX BBB12; SBRR BBB11
BBB14  STX RWIX; SBRM CDA; LDX =DB; SBRM TBB; NOP
       LDA =4000B; LDX =DB; BIO FILE; BRU FATAL; MIN NBLOX
       LDX RWIX; BRU BBB13
BBB15  STX RWIX; LDP EXBL,2; STP NAME; LDP EXBL+2,2; STA NAME+2
       CBA; ETR =77B6; STA NAME+3; SBRM DELN
       LDA =NAME; SBRM PNA; MSG CRLF
       LDX RWIX; BRU BBB13

GXB    ZRO XGXB; SKN IOFLAG; BRU GXB2
       SBRM RXU; BRU ERR
GXB1   CLAB; STP NAME+2; LDA UNO; RSH 23
       DIV =100; ADD =20B; MRG PFSWD; STA NAME; CLA; LSH 1
       DIV =10; ADD =20B; LSH 18; STA NAME+1; LSH 18
       ADD =20B4; ADM NAME+1; LDA =-1; SBRM FSB; BRU ERR
       SBRM CDA; LDB =4000B; LDX =DB; SBRM TBB; NOP
       SBRR GXB
GXB2   SBRM RXR; BRU ERR; BRU GXB1

PFSWD  DATA 60466300B  "PFS "
DELFM  ASC "$FILES DELETED OR NOT BACKED UP ARE:$/"
BFM    ASC "$FILES BACKED UP ARE:$/"
DOLDM  ASC "$OLD INDEX BLOCK USER= /"
DNEWM  ASC "$CURRENT INDEX BLOCK USER= /"
DMOM   ASC "$LAST DUMP MONTH: /"

       ELSE

* $DUMP
DDD    SBRM CONFRM; LDA UNO; SBRM RXD; BRU ERR; MSG ONFILE
       LDA =2B6; LDX FDUAL; CLB; BRS 16; BRU ERR; STA FILE
       LDX =XBL; LDA =4000B; BIO FILE; BRU FATAL
       MSG CRLF; CLA; STA NBLOX; LDA =-1; STA IOFLAG
       LDX SIZX
DDD1   STX RWIX; LDA EXBL,2; SKG =0; SKG =-2; BRU DDD3
DDD2   LDX RWIX; EAX 5,2; BRX DDD1
LDDX   PNO NBLOX; MSG BLOXM; BRU CMDPRO
DDD3   SBRM CDA; LDX =DB; SBRM TBB; NOP
       LDA =4000B; LDX =DB; BIO FILE; BRU FATAL
       MIN NBLOX; BRU DDD2
ONFILE ASC '$ON FILE /'
BLOXM  ASC ' BLOCKS./'

       ENDF

       ENDF

* DELETE DISK FILE
DF     SBRM GOFN; SBRM RBTF; LDA FUSER; SBRM RXR; BRU ERR455
       SBRM FFN; BRU ERR450; SBRM CWA; BRU ERR451; SBRM DELN
       SBRM WXR; BRU ERR455

       IF AUTO; BRU QUIT200; ELSE; BRU CMDPRO; ENDF


* EXAMINE FILE
EF     SBRM GCFN; SBRM FFN; BRU ERR451; SBRM CVA; BRU ERR451

       IF AUTO

       STX EFX; LDA =3B6; CLB; LDX FDUAL; BRS 16; BRU ERR455
       STA FILE; STA FO; LDX EFX

       ENDF

       MSG CRLF; SBRM PFP

       IF AUTO

       LDA =137B; LDX =-2; CIO FILE; BRX *-1
       LDA FILE; BRS 20; LDA FOO; STA FO; BRU RWRET

       ELSE

       BRU CMDPRO

       ENDF


* FINISHED
FF     SBRM CONFRM

       IF AUTO; BRU QUIT200; ELSE; BRU QUIT; ENDF



       IF AUTO; ELSE

* GENERAL ACCESS TO FILE
GF     LDX =GFTAB; BRU OF0
GFTAB  DATA -1; LCY 22; DATA -1

       ENDF


* LIST AND BRIEF LIST
BF     LDA =4; BRU LF0
LF     LDA =-1
LF0    STA BRIEFF; SBRM RND; SBRM RXU; BRU ERR455

       IF AUTO

       STX EFX; LDA =3B6; CLB; LDX FDUAL; BRS 16; BRU ERR455
       STA FILE; STA FO; LDX EFX

       ENDF

       SKN BRIEFF; BRU LF4; SBRM PTOD
       MSG CRLF; SBRM AVS; PNO :; MSG LFM
LF6    LDA XRE+1; RSH 8; ETR =377B; SKG =0; BRU LF7
       TCH ','; TCH '<'; SBRM PUN
LF7    LDA XRE+1; ETR =377B; SKG =0; BRU LF8
       TCH ','; TCH '>'; SBRM PUN
LF8    SBRM UPF; LDX =-12
LF9    STX LFT; LDA FRIEND+12,2; SKG =0; BRU LF11
       MSG CRLF; TCH ' '; LDA LFT; ADD =13; PNO :
       TCH ':'; LDX LFT; LDA FRIEND+12,2; SBRM PUN
LF11   LDX LFT; BRX LF9
LF4    LDX =-6; STX LFLL
LF2    LDA EXBL+3,2; ETR =3B5; SKE =2B5; BRU LF3
       SBRM CVA; BRU LF3; STX LFT
       SKR LFLL; BRU LF5; LDA BRIEFF; STA LFLL; MSG CRLF
LF5    SBRM PNF; LDX LFT; SKN LFLL; BRU LF3; SBRM PFP
LF3    EAX -6,2; CXA; SKE SIZX; BRU LF2

       IF AUTO; LDA =137B; LDX =-2; CIO FILE; BRX *-1
       LDA FILE; BRS 20; LDA FOO; STA FO; BRU RWRET

       ELSE; BRU CMDPRO; ENDF

LFM    ASC ' BLOCKS/'


       IF AUTO; ELSE

* $LOAD
LLL    SBRM CONFRM; MSG FRFILE
       CLEAR; LDX FDUAL; BRS 15; BRU ERR
       STA FILE; XAB; SKE ='.'; BRU ERR
       LDA UNO; SBRM RXD; BRU ERR

       IF CONVERT; LDX =DB; ELSE; LDX =XOBL; ENDF

       LDA =4000B; BIO FILE; BRU FATAL

       IF CONVERT

       LDX =-4000B; CLA; STA EXOBL,2; BRX *-1
       LDA =-1000B; STA OLDCT; LDA SIZX; STA NEWCT; STA XOBL
       LDX OLDCT
LLL0A  STX OLDCT; LDP DB+1000B,2; STP WORD0
       LDP DB+2000B,2; STP WORD2
       LDX NEWCT; LDP WORD0; XAB; STA SAVBIT; ETR =@77B6
       XMA SAVBIT; ETR =77B6; XAB; STP EXOBL,2
       CLAB; STA EXOBL+2,2; CBA; MRG SAVBIT; STA EXOBL+3,2
       LDP WORD2; STP EXOBL+4,2; EAX 5,2; BRX LLL0B; BRU LLL0C
LLL0B  STX NEWCT; LDX OLDCT; EAX 1,2; BRX LLL0A

       ENDF

LLL0C  CLA; STA XCNTR; LDX XOBL
LLF1   LDA EXOBL,2; SKG =0; SKG =-2; BRU LLF11
LLF2   EAX 5,2; BRX LLF1; MSG CRLF
       CLA; STA NBLOX; STA NOROOM; STA IOFLAG; LDX XOBL
LLF3   STX RWIX; LDP EXOBL,2; SKG =0; SKG =-2; BRU LLF5
LLF4   LDX RWIX; EAX 5,2; BRX LLF3; BRU LDDX
LLF5   STP NAME; LDP EXOBL+2,2; LRSH 18; LSH 18; STP NAME+2
       CLA; STA LENGTH; LDP EXOBL+4,2; STP OLDATA; EAX -6,2
LLF6   SBRM FOC; BRU LLF7; SKA =1B5; LDA =3777B
       ETR =3777B; ADD =1; ADM LENGTH; BRU LLF6
LLF7   SBRM FLF; CLA; SKA =3777B; ADD =4000B; ETR =@3777B; STA OLDLEN
       SBRM AVS; CLB; LSH 11; ADD OLDLEN
       SUB LENGTH; SKG =-1; BRU LLF10
       LDX RWIX; LDA EXOBL+3,2; ETR =47B4; STA FTYPE
       LDP OLDATA; ETR =77B6; STA ACCESS
       EOR OLDATA; STA TODAY; STB GROUP; SBRM DELN
       LDA LENGTH; SBRM ASF; BRU FATAL; SBRM WXI; NOP
       LDA =NAME; SBRM PNA; TCH ','; PNO LENGTH; MSG CRLF
LLF8   SBRM FON; BRU LLF4; STX RWOX; CAB; ETR =3777B
       SKB =2B5; LDA =-1; SBRM FSB; BRU FATAL; STX RWNX
       LDB RWOX; LSH 9+24; RSH 9+23; DIV =6; CAX
       LDA ECTAB,2; LDB =10001B; LDX FILE; BRS 144
       LDA =4000B; LDX =DB; BIO FILE; BRU FATAL
       SKN NOROOM; BRU *+2; BRU LLF9; LDX RWNX; SBRM CDA
       LDX =DB; SBRM TBB; NOP
LLF9   LDX RWOX; CLAB; STP EXOBL,2; STP EXOBL+2,2; STP EXOBL+4,2
       MIN NBLOX; BRU LLF8
LLF10  MSG LLDELM; LDA =NAME; SBRM PNA; MSG CRLF
       LDA =-1; STA NOROOM; BRU LLF8
LLF11  STX LLLT; COPY XA,B; LSH 9; RSH 9+23; DIV =6; CAX
       MIN XCNTR; LDA XCNTR; CLB; RSH 13; STB ECTAB,2
       LDX LLLT; BRU LLF2
FRFILE ASC '$FROM FILE /'
LLDELM ASC 'NOT ENOUGH ROOM FOR /'

* MODIFY ITEM #
MF     SBRM GNO; SKG =14; SKG =0; BRU ERR; STA MFTX
       MSG MFM; SBRM CIN; SKE ='-'; BRU MF1
       SBRM CONFRM; CLA; BRU MF2
MF1    STA B38F; SBRM GNU
MF2    STA MFUNO; LDA UNO; SBRM RXR; BRU ERR
       LDX SIZX
MF3    LDA EXBL,2; SKE =-1; ZRO *
       LDA EXBL+1,2; SKE =0; BRU MF4
       EAX 5,2; BRX MF3; ZRO *
MF4    EAX EXBL,2; CXA; LDX MFTX; ADD MFAT,2
       ETR =37777B; STA MFP
       LDA* MFP; RSH* MFST,2; ETR =@377B
       MRG MFUNO; LSH* MFST,2; STA* MFP
       SBRM WXR; SBRM XWE; SBRM CLL; BRU CMDPRO
MFM    ASC '$TO USER /'
MFAT   DATA 0,2,2,2,3,3,3,4,4,4,5,5,5,1,1
MFST   DATA 0,16,8,0,16,8,0,16,8,0,16,8,0,8,0

* $MOVE DISK FILE
MMM    LDA =-1; BRU WF0

* OWNER ACCESS TO FILE
OF     LDX =OFTAB; BRU OF0
OFTAB  DATA 0; LCY 18; DATA -1
OF0    STX OFPTR; SBRM GOFN; LDA FUSER; SBRM RXU; BRU ERR
       SBRM FFN; BRU ERR; STA FTYPE; LDP NAME; STP OLDN
       LDP NAME+2; STP OLDN+2
       LDX OFPTR; SKN 2,2; BRU* 2,2; MSG OFM
OF1    SBRM CIN; LDB =-1; SKNE ='-'; CLB
       SKNE ='N'; LDB =1; SKNE ='R'; LDB =2
       SKNE ='W'; LDB =3; CBA; SKG* OFPTR; BRU OF2
       LDA =3; MIN OFPTR; EXU* OFPTR; EOR =-1; ETR ACCESS
       COPY AX,BX; STX ACCESS; LDA FTYPE; ETR =47B4; ADM NAME+3
       SBRM CONFRM; SBRM CHD; BRU CMDPRO
OFM    ASC '$IS /'
OF2    MSG OFEM; SBRM WOCI; BRU OF1
OFEM   ASC ' ? /'

* PASSWORD ACCESS TO FILE
PF     LDX =PFTAB; BRU OF0
PFTAB  DATA -1; LCY 20; DATA *+1
       MSG PFM; SBRM GGN; STA GROUP; BRU OF1
PFM    ASC '$IS (/'

* " COMMAND
QUOTE  SBRM CIN; SKNE =144B; BRU CMDPRO
       SKE =155B; BRU QUOTE; TCH 152B; TCH '"'; BRU QUOTE

       ENDF

* ACCEPT NAME & PASSWORD
SETUNO SBRM GUN

       IF AUTO; ELSE; TCH '('; CET 3; ENDF

       SBRM GGN; STA STPSWD

       IF AUTO; ELSE; CET 0; TCH ')'; ENDF

       SBRM SUNP; BRU ERR431; XAB; SKE STPSWD; BRU ERR431
       STB UNO; BRU CMDPR1


       IF AUTO; ELSE

* $INITIALIZE
* CREATES INDEX BLOCKS FOR SELECTED USERS
III    SBRM CFC; SBRM SYS
III1   MIN CUSER; LDA CUSER; SBRM IXR; SBRM XWE
       LDA CUSER; SKE NUSERS; BRU III1; BRU CMDPRO

       ENDF


* READ DISK FILE
RF     STA TERCH; SBRM GION; STA TERM; SKN DIRECT; BRU RF3
RF4    SBRM FFN; BRU ERR450; SBRM CRA; BRU ERR451; SBRM FLF; BRU ERR455
RF0    STA LENGTH; STA FLEN; STB FTYPE
       LDA =3*FNAME-1; STA FNPTR; STA FNPTR1
       LDA TERM; SKE ='.'; BRU RF2

       IF AUTO; ELSE; MSG RFM; ENDF; LDX FDUAL

RF1    LDA FTYPE; ETR =47B4; STA FTYPE
       CLB; LSH 6; MRG LENGTH; LDB =FNPTR; BRS 16; BRU ERR455; STA FILE
       SBRM TFN; LDA =-1; STA IOFLAG

       IF AUTO; ELSE; MSG CRLF; ENDF; BRU RFC

RF2    LDA =1; SBRM WNS; LDX =-1; BRU RF1
RFM    ASC '$TO /'
RF3    CLA; SKE NAME; BRU RF4
       LDA =4000B; LDB =2B4; BRU RF0
* COPY THE FILE
RFC    SBRM ZDB; SKN DIRECT; BRU RFC5
       CLA; STA BLKNO
RFC1   LDA =DB; STA DPTR; CLA; STA DCOUNT
RFC0   SBRM FBL; BRU FATAL; SBRM CDA
       LDB =4000B; SKN BLKNO; BRU RFC2
       CAB; LDA EXBL+3,2; ETR =3777B; ADD =1; XAB
RFC2   STB CWC; LDX DPTR; SBRM TBB; NOP; MIN BLKNO
       LDA CWC; ADM DPTR; ADM DCOUNT
       LDA BLKNO; SKG =-1; BRU RFC3
       LDA DCOUNT; SKE =NWD; BRU RFC0
RFC3   LDA DCOUNT; SBRM TFB; NOP
       LDA BLKNO; SKG =-1; BRU RWRET; BRU RFC1
RFC5   CLA; SKE NAME; BRU RFC4
       LDA BLKNO; SUB =200B; MUL =1; CBX
RFC6   SBRM CDA; LDB =4000B; LDX =DB; SBRM TBB; NOP
       SBRM TFB; NOP; BRU RWRET
RFC4   SBRM FBL; BRU ERR455; BRU RFC6

* RETURN FROM READ OR WRITE COMMANDS

       IF AUTO

RWRET  MSG M257

       ELSE

RWRET  PNO FLEN; MSG RWRETM

       ENDF

       IF AUTO; BRU QUIT; ELSE; BRU CMDPRO; ENDF

RWRETM ASC ' WORDS./'

       IF AUTO

M257   ASC "257 XFER COMPLETE$/"

       ENDF


       IF AUTO; ELSE;

       IF MAINT

* STATUS
SSS    SBRM RND; SBRM RXU; BRU ERR; LDX SIZX
SF1    STX SFT; MSG CRLF
       LDA SFT; SUB SIZX; ETR =37777B; RSH 23; DIV =6; PNO :
       LDX SFT; SBRM CDA; SBRM PDA; TCH ' '; LDX SFT
       LDA EXBL,2; SKE =0; BRU SF3; MSG SFUM
       LDX SFT; EAX 5,2; BRX SF2; BRU CMDPRO
SF2    SBRM CBE; BRU SF1; EAX 5,2; BRX SF2; BRU CMDPRO
SF3    SKE =-1; BRU SF5; LDA EXBL+1,2; SKE =0; BRU SF4
       MSG SFBM; BRU SF7
SF4    MSG SFIM; BRU SF7
SF5    SBRM PNM; TCH ','; LDX SFT; LDA EXBL+3,2; LDB =3B5
       SKM =1B5; BRU SF6; ETR =3777B; PNO :
       TCH ' '; BRU SF7
SF6    MSG SFEM
SF7    EAX 5,2; BRX SF1; SBRR CMDPRO
SFBM   ASC '*NG* /'
SFEM   ASC '(E) /'
SFIM   ASC '(INDEX BLK) /'
SFUM   ASC '-NU- /'

       ENDF

* UNUSED SPACE
UF     SBRM RND; SBRM RXU; BRU ERR; MSG CRLF
       SBRM AVS; PNO :; MSG UFAM; BRU CMDPRO
UFAM   ASC ' BLOCKS./'

* VERIFY DATA

       IF MAINT

VF     SBRM RND; MSG CRLF; SBRM VFD; BRU CMDPRO

       ELSE

VF     SBRM RND; MSG CRLF; SKE UNO; BRU ERR; SBRM VFD; BRU CMDPRO

       ENDF

* $UNLOCK DIRECTORY FOR USER
UUU    SBRM GUT; SKE ='.'; BRU ERR
       LDA LUNO; SKE =-1; BRU UUU1; STB LUNO
       SBRM CLL; BRU CMDPRO
UUU1   MSG UUUM; BRU CMDPRO
UUUM   ASC "*** CAN'T UNLOCK DIRECTORY ***/"

* $VERIFY
       IF MAINT

VVV    SBRM CFC; SBRM SYS
VER1   SBRM NXU; BRU CMDPRO; SBRM VFD; BRU VER1

       ENDF

       ENDF


* WRITE DISK FILE
WF     CLA
WF0    STA WMFLG
       LDA =';'; STA TERCH; SBRM GCFN; STA TERM
       LDA =-1; STA OFTYPE; SBRM FFN; BRU WF2
       ETR =47B4; STA OFTYPE; SBRM CWA; BRU ERR451

       IF AUTO; ELSE; MSG OLD; ENDF

WF1    LDA =3*FNAME-1; STA FNPTR; STA FNPTR1
       LDA TERM; SKE ='.'; BRU WF8

       IF AUTO; ELSE; MSG FROM; ENDF; LDX FDUAL

WF7    LDA =2B7; LDB =FNPTR; BRS 15; BRU ERR455
       SBRM TFN; LDA TERM; SKE ='.'; LDB ='.'; STB TERM
       CXA; LRSH 6; ETR =47B4; MRG =4B3; STA FTYPE
       SKN OFTYPE; BRU WF4
WF6    LDB =FNPTR; LDA TERM; SKE ='.'; BRU ERR455
       CLA; LDX =-1; BRS 15; BRU ERR455; STA FILE
       LDA FILE; SBRM FED; STA LENGTH; STA FLEN
       SKE =0; BRU WF5

       IF AUTO; ELSE; MSG ZER; ENDF; BRU ERR455

WF5    SKN WMFLG; BRU WF5A; MSG FLW; SBRM GDATE; STA TODAY
WF5A   SBRM RBTF; LDA FUSER; SBRM RXR; BRU ERR455
       SBRM MARKN
       LDA LENGTH; SBRM ASF; BRU WF9
WF5B   CLA; STA BLKNO; STA IOFLAG
* COPY THE FILE
WFC    CLA; STA WERRC
       LDA =NWD; STA DCOUNT; SBRM TFB; MIN WERRC; LDA =DB; STA DPTR
WFC0   LDA LENGTH; SKG =4000B; BRU WFC1
WFC1   LDA BLKNO; SBRM FSB; BRU WFC3
WFC2   SBRM CDA; LDX DPTR; SBRM TBB; MIN WERRC; MIN BLKNO
       LDA LENGTH; SUB =4000B; STA LENGTH; SKG =0; BRU WFC4
       LDA =4000B; ADM DPTR; CNA; ADD DCOUNT; STA DCOUNT
       SKG =0; BRU WFC; BRU WFC0
WFC3   LDA =4001B; SKG LENGTH; BRU FATAL
       LDA =-1; SBRM FSB; BRU FATAL; BRU WFC2
WFC4   LDA WERRC; SKE =0; BRU ERR455
       SBRM DELNC; SBRM WXR; BRU ERR455

       IF AUTO; ELSE; MSG CRLF; ENDF; SBRM RBTN

       BRU RWRET
WF2    SBRM COA; BRU ERR451; LDA =3B6; STA ACCESS
       CLA; STA GROUP

       IF AUTO; ELSE; MSG NEW; ENDF; BRU WF1

WF4    LDB =47B4; SKM OFTYPE; BRU *+2; BRU WF6

       IF AUTO; ELSE; MSG CHTYPE; ENDF; BRU WF6

WF8    CLA; SBRM WNS; LDX =-1; BRU WF7
WF9    SBRM DELN; SBRM DELNC
       LDA LENGTH; SBRM ASF; BRU SXERR; BRU WF5B
OLD    ASC ' (OLD)/'
NEW    ASC ' (NEW)/'
FROM   ASC '$FROM /'
ZER    ASC ' -ZERO LENGTH/'
CHTYPE ASC ' (TYPE CHANGE)/'
FLW    ASC '$$FILE LAST WRITTEN ON MONTH: /'

* CODE TO ASSIST IN SETTING UP PFS

* SPECIAL ENTRY TO CREATE SUBSYSTEM FILE
SAVE   CLEAR; BRS 16; ZRO 0; STA FILE
       LDA =10000B; LDX =30000B; BIO FILE; ZRO *
       LDA FILE; BRS 20; BRS 10

* SPECIAL ENTRY TO READ LIST OF BAD SPOTS
SPOTS  CLA; LDB =1; SBRM INIT
SPOT0  MSG SPOTM; CLEAR; BRS 15; BRU SPOT0; STA FILE
       CLA; STA BADCNT; STA UNIT; MSG CRLF
SPOT1  LDX =-3
SPOT1A STX CIDX
SPOT2  LDX FILE; LDB =8; BRS 38; XAB
       SKE =':'; BRU SPOT3; STB UNIT; BRU SPOT1
SPOT3  SKE =' '; BRU SPOT5
SPOT8  LDX CIDX; STB* COORDL,2; BRX SPOT1A; BRU SPOT2
SPOT5  SKE =135B; BRU SPOT4; CIO FILE; BRU SPOT8
SPOT4  SKE =155B; BRU SPOT9; LDX CIDX; STB* COORDL,2
SPOT7  SBRM EDA; SKR BADCNT; NOP
       LDX BADCNT; STA EBAD,2; BRU SPOT1
SPOT9  ETR =377B; SKE =155B; BRU SPOT6; BRU SPOT7
SPOT6  SKE =137B; BRU SPOT2; LDA FILE; BRS 20
       LDA BADCNT; CNA; PNO :; MSG BADM; BRS 10
SPOTM  ASC "$INPUT FILE: /"
BADM   ASC " ENTRIES$/"
       DATA TRACK,BAND,SECTOR
COORDL DATA 0

* SPECIAL ENTRY TO:
* SET USERBASE TABLE (CONVERT TO FORMATTED DISK ADDRESSES)
SETUB  LDX =-MAXUNO
SETUB1 CLA; STA UNIT; STA TRACK; STA BAND; STA SECTOR
       LDA UBASE+MAXUNO,2; LRSH 23; DIV =NSEC; STB SECTOR
       LRSH 23; DIV =NBAND; STB BAND; STA TRACK; SBRM EDA
       STA UBASE+MAXUNO,2; BRX SETUB1; BRS 10

* BAD SPOT LIST FOR DISK FILE
BAD    BSS 524B    SIZED TO USE ALL OF MEMORY
EBAD   EQU *

       END
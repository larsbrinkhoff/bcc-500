        COMMON SYSCALLS;

* MCALL DECLARATIONS

        MACRO ARBMC←UNKNOWN MONITOR;
        MACRO INTMC←INTEGER MONITOR;
        MACRO STMC←STRING MONITOR;
        MACRO LNMC←LONG MONITOR;
        MACRO LNLNMC←LONGLONG MONITOR;

* CALLS TO MANIPULATE MIBS AND SIBS
        INTMC CREATE'MIB←190;
        ARBMC READ'MIBOB'INDEX←0;
        ARBMC READ'MIBOB'NAME←1;
        ARBMC SET'MIBOB'NAME←2;
        ARBMC SET'MIBOB'ACCESS←3;
        ARBMC SET'LOCK'LIST←4;
        ARBMC DELETE'MIBOB←5;
        INTMC CREATE'MIBOB←6;
        ARBMC SET'MIB'ACCESS←10;
        INTMC READ'MIB'ACCESS←11;
        ARBMC SET'MIBOB'VALUE←12;
        INTMC COPY'MIBOB←14;* UNIMPLEMENTED
        ARBMC SET'NO'CHARGE←15;*** ???
        INTMC READ'MIB'SPACE←16;
        ARBMC SET'FILE'LOCK←18;*?* UNIMPLEMENTED
        ARBMC SET'DURABILITY←28;*** ???

* OFT CALLS
        INTMC MOPEN'FILE←19;
        ARBMC MREAD'OFT←20;
        ARBMC SET'OFT'AL←21;
        INTMC MSET'OFT'CL←22;
        ARBMC SET'FILE'LENGTH←23;* IMPROVE THIS FOR UTS
        INTMC CR'FILE'PAGE←24;
        INTMC DEL'FILE'PAGE←25;
        INTMC NEXT'FILE'PAGE←26;
        ARBMC MOVE'PAGE'PMT←27;

* PMT CALLS
        INTMC ACQUIRE'PMT←50;
        ARBMC NEW'PMT'PAGE←51;
        ARBMC CLEAR'PMT←53;
        ARBMC DELETE'PMT←54;
        ARBMC SET'PMT'AL←55;
        ARBMC SET'PMT'CL←56;
        ARBMC SET'PMT'RO←57;
        ARBMC READ'PMT←58;

* WORKING SET CALLS
        ARBMC PUT'PAGE'DWS←65;
        ARBMC PUT'PAGE'CWS←66;
        INTMC DEL'PAGE'DWS←67;
        INTMC DEL'PAGE'CWS←68;
        INTMC READ'LWS←70;
        ARBMC SET'LWS←71;

* SPT CALLS
        INTMC MCREATE'SP←90;
        ARBMC MDESTROY'SP←91;
        ARBMC MREAD'SPT←95;
        ARBMC READ'SPCS←96;
        INTMC MRD'SPT'FIELD←97;
        ARBMC MST'SPT'FIELD←98;
        ARBMC READ'MAP←99;
        ARBMC SET'MAP←100;
        INTMC READ'MAP'BYTE←101;
        ARBMC SET'MAP'BYTE←102;
        INTMC READ'SPS'PARAM←106;

* SPCS CALLS
        ARBMC SP'CALL←111;
        ARBMC SP'JUMP←112;
        ARBMC SP'TRAP←113;
        ARBMC TRAP'RETURN←114;
        ARBMC SP'BRANCH←115;
        ARBMC SP'RETURN←116;
        ARBMC JUMP'RETURN←117;
        ARBMC MARK'CALL←118;
        ARBMC DELETE'CALL←119;
        ARBMC MODIFY'CALL←120;

* PROCESS CALLS
        INTMC COPY'PMT'PROC←130;
        INTMC ACTIVATE'PROC←132;
        ARBMC TRANSFER'TERM←133;
        ARBMC MAKE'DORMANT←134;
        ARBMC INIT'PROC'PAGE←135;
        ARBMC INIT'PROC'MAP←136;
        ARBMC INIT'SPT←137;
        INTMC READ'PROC'PARAM←211;

* IWS CALLS
        ARBMC SET'PROC'INT←163;
        ARBMC QUIT'BLOCK←164;
        INTMC GET'INT'NO←165;
        ARBMC READ'ICT←166;
        ARBMC ALLOW'INTS←168;
        ARBMC REFUSE'INTS←169;
        ARBMC BLOCK←170;
        ARBMC SET'ICT←172;
        ARBMC SET'ICT'CL←173;
        INTMC ACQUIRE'ICT←174;

* CHIO CALLS
        ARBMC SET'LINE'FIELD←180;
        ARBMC READ'LINE'TABLE←181;
        ARBMC READ'STRING'BRK←182;
        ARBMC WRITE'STRING←183;

* MISCELLANEOUS
        LNMC READ'CLOCK←210;

* UCALL DECLARATIONS

        MACRO ARBUC←UNKNOWN UTILITY;
        MACRO INTUC←INTEGER UTILITY;
        MACRO CHRUC←CHARACTER UTILITY;
        MACRO STUC←STRING UTILITY;
        MACRO LNUC←LONG UTILITY;

* MISCELLANEOUS UCALLS
        ARBUC BREAK'POINT←0;*             UCALL FOR DEBUGGING PROGRAMS
        STUC ERRORMSG←1;*                RETURN SYSTEM ERROR MESSAGE
        STUC GET'PARAM←2;*               STRIP PARAMETER FROM STRING
        STUC GET'COM'LINE←3;*            GET CURRENT COMMAND LINE FROM UTS
        INTUC ABRV'LKP←4;*                LOOK UP ABBREVIATED NAME IN STARY
        INTUC CON'ABRV'LKP←5;*            CONTINUE SAME IN NEW STARY

* FILE SYSTEM CALLS
        ARBUC NAME'SEARCH←10;*            CONVERT FILE ST TO UTS NAME
        ARBUC SPECIAL'SEARCH←11;*         VARIATION OF ABOVE
        INTUC CONV'NAME←12;*              CONVERT FROM UTS TO MON FILE NAME
        ARBUC SPREAD'NAME←13;*            SPLIT FILE NAME STRING INTO COMP.
        ARBUC READ'MIBOB'VALUE←14;*       READ 'VALUE' OF MIB OBJECT
        ARBUC DELETE'FILE←15;*            DELETE FILE AND CONTENTS
        INTUC OPEN'FILE←16;*              OPEN FILE W/WO LOCKING
        ARBUC CLOSE'FILE←17;*             CLOSE AND UNLOCK FILE
        ARBUC READ'OFT←18;*               READ OFT
        INTUC READ'OFT'FIELD←19;*         READ OFT FIELD
        ARBUC SET'OFT'CL←20;*             SET OFT CONTROL LOCK
        ARBUC CONV'KEY←21;*               CONVERT DEFAULT ACCESS KEY

* EXTENDED SPS CALLS
        INTUC CREATE'SSP←30;*             CREATE SUBSIDIARY SUB-PROCESS
        INTUC CREATE'PSP←31;*             CREATE PARALLEL SUB-PROCESS
        ARBUC ATTACH←32;*                 ATTACH PI FILE TO SUB-PROCESS
        ARBUC DESTROY'SP←33;*             DESTROY SUB-PROCESSES
        ARBUC READ'SPT←34;*               READ SPT
        INTUC READ'SPT'FIELD←35;*         READ SPT FIELD
        ARBUC SET'SPT'FIELD←36;*          SET SPT FIELD
        STUC READ'SPNAME←37;*            READ SUB-PROC NAME
        ARBUC SET'SPNAME←38;*             SET SUB-PROC NAME
        INTUC SPNAME'SEARCH←39;*           LOOK UP SP NAME

* CIOS MANIPULATION
        INTUC CREATE'CIOS←40;*            CREATE CONTROL I/O STREAM
        INTUC READ'CIOS'FIELD←41;*        READ CIOS FIELD
        ARBUC SET'CIOS'FIELD←42;*         SET (SOME) CIOS FIELDS
        ARBUC SET'CIOS'INPUT←43;*         SET UP FOR INPUT
        ARBUC SET'CIOS'OUTPUT←44;*        SET UP FOR OUTPUT

* CIOS INPUT/OUTPUT
        ARBUC PRINT'STRING←45;*           WRITE STRING ON CIOS
        ARBUC PRINT'CHAR←46;*             WRITE (= BUFFER) CHAR ON CIOS
        ARBUC START'OUTPUT←47;*           DUMP OUTPUT BUFFER
        STUC READ'LINE←48;*              READ NEXT INPUT LINE
*STUC      EDIT'LINE ← 49;*              EDIT CURRENT LINE
        CHRUC READ'CHAR←50;*              READ NEXT CHARACTER
        ARBUC BLOCK'OB'EMPTY←51;*         WAIT UNTIL OUT BUFFER IS EMPTY

* USER, ACCOUNT, AND GROUP PROFILES
        STUC READ'UP'ITEM←60;*           READ ITEM FROM USER PROFILE
        STUC READ'UP'NAMES←61;*          READ NAMES OF UP ITEMS
        ARBUC SET'UP'ITEM←62;*            SET (CREATE) VALUE OF UP ITEM
        ARBUC SET'UP'ACCESS←63;*          SET ACCESS TO UP ITEM
        LNUC FIND'MIB←64;*               CONVERT USER NAME/NUMBER TO MIB ADDR
        ARBUC CREATE'UP'ENTRY←65;*        CREATE USER/UP ENTRY
        ARBUC DELETE'UP'ENTRY←66;*        DELETE USER/UP ENTRY

* PROCESSES, AND PROCESS PROFILE
        ARBUC CREATE'PROCESS←70;*         CREATE/INITIALIZE PROCESS
        STUC READ'PP'ITEM←71;*           READ ITEM FROM PROCESS PROFILE
        STUC READ'PP'NAMES←72;*          READ NAMES OF PP ITEMS

        ARBUC SET'PP'ITEM←73;*            SET (CREATE) VALUE OF PP ITEM

        END;

        COMMON DECDECS;
*
* SHORT DECLARATION MACROS FOR SPL
*

        MACRO INT←DECLARE INTEGER;
        MACRO OCT←DECLARE OCTAL;
        MACRO PTR←DECLARE POINTER;
        MACRO CHR←DECLARE CHARACTER;
        MACRO ST←DECLARE STRING;
        MACRO LN←DECLARE LONG;
        MACRO LNLN←DECLARE LONGLONG;
        MACRO LB←DECLARE LABEL;

        MACRO OCTFL←DECLARE OCTAL FIELD;
        MACRO INTFL←DECLARE INTEGER SIGNED FIELD;
        MACRO PTRFL←DECLARE POINTER FIELD;
        MACRO CHRFL←DECLARE CHARACTER FIELD;
        MACRO STFL←DECLARE STRING FIELD;
        MACRO LNFL←DECLARE LONG FIELD;
        MACRO ARYFL←DECLARE ARRAY FIELD;
        MACRO FNFL←DECLARE FUNCTION FIELD;

        MACRO INTARY←DECLARE INTEGER ARRAY;
        MACRO OCTARY←DECLARE OCTAL ARRAY;
        MACRO PTRARY←DECLARE POINTER ARRAY;
        MACRO CHRARY←DECLARE CHARACTER ARRAY;
        MACRO STARY←DECLARE STRING ARRAY;
        MACRO LNARY←DECLARE LONG ARRAY;
        MACRO LBARY←DECLARE LABEL ARRAY;
        MACRO FLARY←DECLARE FIELD ARRAY;
        MACRO FNARY←DECLARE FUNCTION ARRAY;

        MACRO INTARY1←DECLARE INTEGER ARRAYONE;
        MACRO PTRARY1←DECLARE POINTER ARRAYONE;

        MACRO INTFN←DECLARE INTEGER FUNCTION;

        MACRO ARBENT←UNKNOWN ENTRY;
        MACRO INTENT←INTEGER ENTRY;
        MACRO OCTENT←POINTER ENTRY;
        MACRO PTRENT←POINTER ENTRY;
        MACRO CHRENT←CHARACTER ENTRY;
        MACRO STENT←STRING ENTRY;
        MACRO LNENT←LONG ENTRY;
        MACRO LBENT←LABEL ENTRY;
        MACRO ARYENT←ARRAY ENTRY;

        MACRO ARBEXT←DECLARE UNKNOWN EXTERNAL;
        MACRO INTEXT←DECLARE INTEGER EXTERNAL;
        MACRO OCTEXT←DECLARE OCTAL EXTERNAL;
        MACRO PTREXT←DECLARE POINTER EXTERNAL;
        MACRO CHREXT←DECLARE CHARACTER EXTERNAL;
        MACRO STEXT←DECLARE STRING EXTERNAL;
        MACRO LNEXT←DECLARE LONG EXTERNAL;
        MACRO LBEXT←DECLARE LABEL EXTERNAL;
        MACRO ARYEXT←DECLARE ARRAY EXTERNAL;

        MACRO C'(X)←;* KLUDGE FOR INTERNAL COMMENTS

        MACRO LTABLE(F)←F$FLDWDSP+1;
        INTFL FLDWDSP(0:13,23);

* LENGTHS OF NAMES
        INT LMN←4,LTY←1,LFN←LMN+LTY;
        INT NBY←4,LNCH←24/NBY,NMNCH←LMN*NBY,
        NTYCH←LTY*NBY,NFNCH←LFN*NBY,NCMCH←90;

        END;

        COMMON SYS'COMMON; INCLUDE SYSCALLS;

*
* MCALLS, UCALLS, & GLOBAL CELLS
*

        DECLARE INTEGER QUIT'FLAG;* GLOBAL QUIT FLAG
        DECLARE INTEGER QUIT'FCN'FLAG;* GLOBAL QUIT FUNCTION FLAG
        DECLARE INTEGER ERMSNO;* SYSTEM ERROR NUMBER
        DECLARE CHARACTER ERCODE;* SYSTEM ERROR CODE

        END;

        COMMON MACHINE'DECS; INCLUDE DECDECS;
*
* DECLARATIONS FOR MACHINE-DEPENDENT PROGRAMMING
*

* LOW-G DEFINITIONS
        PTR STACK'PTR= G' [2],STACK'LIM= G' [3],
        RTRAP'PARAM= G' [5],RTRAP'LOC= G' [4];

* FIELDS IN BLL DESCRIPTOR
        PTRFL BRDPC(0:6,23),BRDLR(1:6,23);

* STATE DEFINTIONS
        INT PSTLOC←0,ASTLOC←1,BSTLOC←2,CSTLOC←3,DSTLOC←4,
        ESTLOC←5,XSTLOC←6,LSTLOC←7,GSTLOC←8,SSTLOC←9,
        LSTATE←10;

* FIELDS FOR TRAP DEFINITIONS
        PTRFL ADDR(0:6,23); OCTFL SP'TNO(-2),SP'TPAR(-1),
        BLL'CLASS(0:3,5),UTSE'CLASS(0:0,1),
        UTSE'SPTNO(0:1,5),UTSE'RTNO(0:2,5);

        END;

        COMMON TRAP'DECS; INCLUDE MACHINE'DECS;

* TRAP VARIABLES
        INT TRAP'FLAG;* FLAG INDICATING WHETHER A TRAP IS BEING PROCESSED
        PTR INSTR'LOC;* PTR TO INSTR FOLLOWING ONE CAUSING ABE TRAP
        INT SAVEL;* SAVE L-REG WHILE DOING EAC IN ABE'TRAP
        INT GSAVER; INTARY GSTATE[LSTATE],SP'GSTATE[LSTATE];* GLOBAL TRAP STATES
        INT SP'LEV;* SUBPROCESS LEVEL ON ENTRY
       INT THIS'SUB'PROCESS, STATUS'BITS;

        END;

        COMMON COMDECS; INCLUDE DECDECS,SYS'COMMON;
*
* COMMON DECLARATIONS FOR CODING
*

* GENERALLY USEFUL MACROS

        MACRO NAMSET(S,L,A,B)←SETUP(S,L,A,B) & S$WP←S$EP;
        MACRO EMPTY(S)←LNGDES(S$RP,S$WP)<=0;*** WP=RP OR WP=BP?
        MACRO REPEAT← WHILE 1 DO;
        MACRO ENDRPT← ENDFOR;
        MACRO FDISP(F)←RUNTIME'FAILURE() IF F$FLDSTB#0 OR
        F$FLDSIZE#24 ELSE F$FLDWDSP;
        OCTFL FLDSTB(0:8,12),FLDSIZE(0:3,7);

* ERROR MACROS
        MACRO NC'PUNT←RUNTIME'FAILURE();* FOR NORMAL CALLS (EXPRESSIONS)
        MACRO LF'PUNT← VALUE NC'PUNT;* FOR LIBRARY FUNCTIONS
        MACRO SF'PUNT←LF'PUNT:ERCODE,ERMSNO;* FOR SYSTEM CALLS

* QUIT ACTION MACROS
        MACRO QUIT'PUNT(L)← VALUE GOTO L IF ERCODE='QIT' ELSE
        RUNTIME'FAILURE():ERCODE,ERMSNO;
        MACRO QUIT'PUNTX(L,X)← VALUE GOTO L IF ERCODE='QIT' ELSE
        RUNTIME'FAILURE():X,ERCODE,ERMSNO;

* PARAMETRIC CHARACTER DEFINITIONS
        CHR SCHERALD←'>' C'(/* SUB-COMMAND HERALD */),
        BELCH←303B C'(/* BELL */),NULCH←300B C'(/* NULL */),
        NLCH←307B C'(/* NEW LINE */),
        LFCH←310B C'(/* LINE FEED */),
        MBCH←200B C'(/* ZERO MULTIPLE BLANKS */),
        SQTCH←'&'' C'(/* SINGLE QUOTE */),
        DQTCH←'"' C'(/* DOUBLE QUOTE */),
        SEPCH←'-' C'(/* SEPARATOR */);

* STRING POINTER FIELDS
        OCTFL BP(0) C'(/* BEGINNING */),RP(1) C'(/* READER */),
        WP(2) C'(/* WRITER */),EP(3) C'(/* END */);
* CHARACTER FIELDS
        CHRFL CH0(0:0,7),CH1(0:8,15),CH2(0:16,23);
* BEAD LENGTH FIELD
        PTRFL LENGF(-1:6,23);

* FIELDS IN UTILITY FILE NAME
        LNFL UFNUN(0) C'(/* USER NUMBER/DISK ADDRESS */);
        OCTFL UFNEN(2) C'(/* OBJECT ENTRY-NUMBER */),
        UFNFN(3) C'(/* FILE NAME */),UFNMN(3) C'(/* MAIN NAME */),
        UFNTY(3+LMN) C'(/* TYPE WORD */);

* FIELDS FOR UNO/DKA
        OCTFL UNDKUN(0),
        UNDKDK(1);

        INT LUFN←LTABLE(UFNTY);* LENGTH OF UTILITY FILE:NAME

        INT CB'PMT←1;* PMT ADDRESS OF CONTEXT BLOCK

* DECLARATIONS OF COMMON FUNCTIONS

* SPL RUNTIME FUNCTIONS
*ARBEXT    SCOPY, APPEND, CNS, RUNTIME'FAILURE;
        LBEXT LABEL'KLUDGE; ARYEXT LBARY'KLUDGE;*, AR'DESC;
        PTREXT SBASE; INTEXT ARRAYUB,ARRAYLB;* STEXT ST'DESC;
        LNEXT LONG'ADD,LONG'SUB; INTEXT LONG'LE,LONG'LT;

* STORAGE ALLOCATOR
        PTREXT STKMAKE;*, MAKE, SETZONE;
*ARBEXT    STORINIT, SELZONE, EXTZONE, FREE, FREEZONE;

        END;

        COMMON UQNDECS; INCLUDE DECDECS;

* UNIQUE NAME FIELDS
        OCTFL UQNTY(0:0,1),UQNPMB(0:0,0),UQNLFB(0:1,1),
        UQNOWN(0:2,17),UQNHFN(0:18,23);
        OCTFL UQNLFN(1:0,12),UQNLPN(1:13,23),
        UQNSFN(1:0,15),UQNSPN(1:16,23);

        END;

        COMMON BFSDECS; INCLUDE UQNDECS;

* OBJECT TYPE-CODES
        INT SIBSFCD←0,SIBLFCD←1,SIBPRCD←2,SIBAKCD←3,
        SIBRSCD←4,SIBOWCD←5,SIBFRCD←6,
        SIBSCCD←14,SIBLKCD←15;

* ACCESS KEY FIELDS
        OCTFL ACK0(0),ACK1(1:0,7),ACKUN(1:8,23);
        INT NORM'FIL'AC←0357B;* P(NO) F(RW) O(OW) - NORMAL ACCESS

        END;

        COMMON SIBDECS; INCLUDE BFSDECS;
*
* DECLARATIONS FOR SIB
*

* FIELDS IN SIB NAME (SIBN)
        OCTFL SIBNOT(0:1,4),
        SIBNLN(0:10,23),
        SIBNAA(1:1,4),SIBNEN(1:10,23),
        SIBNMN(2),SIBNFN(2);
        OCTFL SIBNTY(SIBNMN$FLDWDSP+LMN),
        SIBNLL(SIBNTY$FLDWDSP+1:4,11),
        SIBNAC(SIBNLL$FLDWDSP:12,23);
        OCTFL SIBNPA(SIBNAC$FLDWDSP:12,15),
        SIBNFA(SIBNAC$FLDWDSP:16,19),
        SIBNOA(SIBNAC$FLDWDSP:20,23);

        INT LSIBN←LTABLE(SIBNOA);* LENGTH OF SIBN TABLE

* FIELDS IN SIB VALUE (SIBV)
        OCTFL SIBVOT(0:1,4),
        SIBVLN(0:10,23),
        SIBVAA(1:1,4),SIBVEN(1:10,23);
        LNFL SIBFLUN(2);
        OCTFL SIBFLLEN(4),
        SIBFLWD(5),
        SIBFLRD(6);

        LNFL SIBLKUN(2);
        OCTFL SIBLKEN(4),
        SIBLKMN(5),
        SIBLKTY(5+LMN);

        INT LSIBFL←LTABLE(SIBFLRD),LSIBLK←LTABLE(SIBLKTY),
        LSIBV←(LSIBFL IF LSIBFL>LSIBLK ELSE LSIBLK);
        INT MLSIB←(LSIBV IF LSIBV>LSIBN ELSE LSIBN);

        END;

        COMMON SPTDECS; INCLUDE DECDECS;

* FIELDS IN SPCS
        OCTFL SPCSNIS(0:0,0),SPCSNIC(0:1,1),
        SPCSCSP(0:2,5),SPCSPR(0:6,23),
        SPCS940M(1:0,0),SPCSR0SP(1:2,5),SPCSLR(1:6,23),
        SPCSR1SP(2:2,5),SPCSGR(2:6,23);
        LNFL SPCSIT(3);
        INT LSPCS←LTABLE(SPCSIT)+1;

        INT NSPT←8;

        END;

        PROGRAM LABEL'KLUDGE; INCLUDE DECDECS;
*
* CONVERT SOURCE RELATIVE LABEL TO ABSOLUTE
*
        LB L; LBARY A;

        LBENT LABEL'KLUDGE(L); RETURN L;

        ARYENT LBARY'KLUDGE(A); RETURN A;

        END;

        PROGRAM LONG'COMPARE; INCLUDE DECDECS;
*
* COMPARE LONG VALUES
*
        PTR P,Q; INT N;
        DECLARE INTEGER TEST;

        INTENT LONG'COMPARE(INTEGER @P,INTEGER @Q,N);

        FOR N←N-1 BY -1 TO 0 DO;
            TEST←P[N];
            RETURN 1 IF TEST#Q[N];
        ENDFOR;
        RETURN 0;

        END;

        PROGRAM SCOPY; INCLUDE COMDECS;
        PTR P; ST S,D; STFL A(0);

        ARBENT SCOPY(STRING @P,S), FRETURN;
        D←P.A; P.RP←D$WP←D$RP←D$BP; GOTO L;

        ARBENT APPEND(STRING @P,S), FRETURN;
        D←P.A;

L:
        REPEAT; WCI(GCI(S// VALUE P.WP←D$WP & RETURN),D// FRETURN); ENDRPT;

        END;

        PROGRAM ST'DESC; INCLUDE COMDECS;
        INT N,S,O; PTR P; ST X;
        STENT ST'DESC(N,P,S,O);

        P←MAKE(S*(N+24/S-1)/24) IF P=0;

        IF S=8 DO;
            .LDA 44B6;
        ELSEIF S=6 DO;
            .LDA 40B6;
        ELSEIF S=12 DO;
            .LDA 50B6;
        ELSEIF S=24 DO;
            .LDA 54B6;
        ELSE DO;
            RUNTIME'FAILURE();
        ENDIF;

        .IOR P; .XMA O; .LSHA 18; .IOR O; .LDX-1; .ASP; .CXA;
        .STA X$BP; .STA X$RP; .STA X$WP; .LDX N; .ASP; .STX X$EP;
        RETURN X;

        END;

        PROGRAM CNS; INCLUDE COMDECS;
        INT N,F,R,T,I,D; PTR P; ST S,B(25); STFL A(0);

        ARBENT CNS(N,STRING @P,F,R), FRETURN;

        S←P.A;
        FRETURN IF R<2 OR R>36;
        T←(-N IF F>=0 AND N<0 ELSE N);
        B$RP←B$WP←B$EP; I←0;
LP:     .LDA T; .LSHD-23; .DIV R; .STA T; .STB D;
        WCD(D+('0' IF D<10 ELSE 'A'-10),B);
        I←I+1; GOTO LP IF T#0;
        WCD('-',B) & I←I+1 IF F>=0 AND N<0;
        F←F A' 77B;
        IF F=0 DO;
            F←I;
        ELSEIF F<=I DO;
            B$RP←INCDES(B$EP,-I);
        ELSE DO;
            WCI(' ',S// FRETURN) FOR I←I+1 TO F;
        ENDIF;
        WCI(D,S// FRETURN)
        FOR D←GCI(B// VALUE P.WP←S$WP & RETURN) WHILE 1;

        END;

        PROGRAM CSN; INCLUDE COMDECS;
        PTR P; INT R,F,D,N,FLB,FLP,PW; ST S; STFL A(0);

        INTENT CSN(STRING @P,R), FRETURN;

        FLB←FLP←0;

AGN:    S←P.A; FRETURN IF R<2 OR R>36;

        IF D←GCI(S// FRETURN)='-' OR D='+' DO;
            F←(1 IF D='-' ELSE 0); D←GCI(S// FRETURN);
        ELSE DO;
            F←0;
        ENDIF;

        D←D-'0' IF D>='0' AND D<='9' ELSE
        D←D-('A'-10) IF D>='A' AND D<='Z' ELSE FRETURN;
        FRETURN IF D>=R; N←D;

        FOR D←GCI(S//Y) REPEAT;
            D←D-'0' IF D>='0' AND D<='9' ELSE
            D←D-('A'-10) IF D>='A' AND D<='Z' ELSE GOTO X;
            GOTO X IF D>=R; N←N*R+D;
        ENDRPT;

X:      IF R<=10 AND (D←D+'A'-10='B' OR D='D') DO;
            IF FLB DO;
                S$RP←INCDES(S$RP,1) IF FLP;
            ELSE DO;
                FLB←-1;
                PW←GCI(S//Z); PW←PW-'0' & FLP←-1 IF PW>='0' AND PW<='9'
                ELSE S$RP←INCDES(S$RP,-1);
Z:              R←8 & GOTO AGN IF D='B' AND R#8;
                R←10 & GOTO AGN IF D='D' AND R#10;
            ENDIF;
        ELSE DO;
            S$RP←INCDES(S$RP,-1);
        ENDIF;
Y:      N←N*R FOR D←1 TO PW IF FLP;
        P.RP←S$RP; RETURN (-N IF F ELSE N);

        END;

        PROGRAM SBASE; INCLUDE COMDECS;
*
* FIND BASE ADDRESS OF WORD-ORIGINED STRING DESCRIPTOR
*
        ST S;

        PTRENT SBASE(S);
        .LDA S$BP; .LDX 1; .ASP; .CXA;
        .CMZ 3B6; .BNE L; .ETR 777777B; RETURN;
L:      RUNTIME'FAILURE();

        END;

        PROGRAM ALENGTH; INCLUDE COMDECS;
*
* COMPUTE ARRAY BOUNDS
*
        PTR A; OCTFL ABW(0);
        INTENT ARRAYUB(A);
        .LDA A.ABW; .CMZ 2B6; .BNE R' [2]; .ETR 17777B;
        .ETR 377777B; RETURN;

        INTENT ARRAYLB(A);
        .LDA A.ABW; .ETR 1B7; .ASHA-21; RETURN;

        END;

        PROGRAM LONG'ARITH; INCLUDE COMDECS;
*
* LONG ARITHMETIC/RELATIONALS
*
        LN X,Y; OCTFL W0(0),W1(1);

        LNENT LONG'ADD(X,Y);* ADD
        .LDA X$W1,ADD Y$W1,CAB;
        .LDA X$W0,ADC Y$W0; RETURN;

        LNENT LONG'SUB(X,Y);* SUBTRACT
        .LDA X$W1,SUB Y$W1,CAB;
        .LDA X$W0,SUC Y$W0; RETURN;

        INTENT LONG'LE(X,Y);* LESS THAN OR EQUALS
        RETURN (1 IF LONG'SUB(X,Y)$W0<=0 ELSE 0);

        INTENT LONG'LT(X,Y);* LESS THAN
        RETURN (1 IF LONG'SUB(X,Y)$W0<0 ELSE 0);

        END;

        COMMON ALLOC'DECS;

*
* SPL STORAGE ALLOCATOR
*

* THE BASIC STRUCTURE OF A STORAGE BLOCK IS AS IN THE OLD ALLOCATOR,
* I.E. THE WORD BEFORE THE 0'TH WORD OF A BLOCK CONTAINS THE LENGTH
* OF THE BLOCK (NUMBER OF INFORMATION WORDS +1), A FLAG IN BIT 0
* TO SAY THAT THE BLOCK IS FREE, AND A FLAG IN BIT 1 TO SAY THAT
* THE NEXT LOWER BLOCK IS FREE.
        DECLARE FIELD HIDDEN(-1),HSIZE(-1:6,23),HFREE(-1:0,0),
        HFTAG(-1:1,1),HZTAG(-1:2,2);
* FREE STORAGE COMES IN ZONES.  A ZONE CONSISTS OF A ZONE HEADER
* AND A CHAIN OF EXTENSIONS.  THE ZONE HEADER CONTAINS: THE BLOCK
* SIZE FOR THE ZONE (0 MEANS ALL SIZES ARE ALLOWABLE), THE OVERFLOW
* ROUTINE, THE EXTENSION LIST, AND THE FREE LIST ROVER.
        DECLARE FIELD FEXT(0),FLIST(2),FUNCTION FIELD FOVX(1);
        DECLARE PARAMETER FZHS←3;
* THE FEXT WORD IN EACH EXTENSION POINTS TO THE NEXT ONE.  THIS CHAIN,
* IS TERMINATED BY A -1.  THE FIRST TWO WORDS
* OF A FREE BLOCK ARE USED TO HOLD THE ADDRESS OF THE NEXT FREE
* BLOCK AND THE PREVIOUS FREE BLOCK.  THIS LIST IS CIRCULAR.
        DECLARE FIELD NBLK(0),PBLK(1);
* FOR FIXED-SIZE ZONES, THE ENTIRE FREE LIST AND THE HIDDEN WORDS
* ARE SET UP AT THE TIME AN EXTENSION IS CREATED.  FOR VARIABLE-SIZED
* ZONES, AN EXTENSION IS SET UP AS A SINGLE FREE BLOCK WHICH IS
* SUBDIVIDED AS THE NEED ARISES.  A FIRST-FIT STRATEGY WITH A "ROVER"
* IS USED FOR THE LATTER.  BLOCKS BELOW A MINIMUM SIZE WILL NOT BE CREATED.
        DECLARE PARAMETER MINSIZ←3;

        DECLARE INFINITY'ZONE,CURRENT'ZONE;* ZONE VARIABLES FOR ALLOCATOR

        END;

        PROGRAM STKMAKE; INCLUDE ALLOC'DECS;
        FIXED;
*
* ALLOCATE LOCAL (STACKED) STORAGE
*
        DECLARE SP= G' [2],SL= G' [3],BLK,SIZE;

        FUNCTION STKMAKE(SIZE);

        RUNTIME'FAILURE() IF SP+SIZE>=SL;
        SP←(BLK←SP+1)+SIZE;
        BLK.HIDDEN←SIZE+1;
        BSET(BLK,0,SIZE);
        RETURN BLK;

        END;

        PROGRAM MAKE; INCLUDE ALLOC'DECS;
*
* ASSIGN BLOCK OF SIZE (A) IN ZONE (B)
*
        DECLARE BLK,ROVER,RSIZE,EBLK,ROVEC;

        FUNCTION MAKE(SIZE,ZONE);

        ZONE←CURRENT'ZONE IF ZONE=0;
        SIZE←SIZE+1;
        SIZE←MINSIZ IF (SIZE<MINSIZ);
        GOTO MAKEOV IF ZONE.FLIST<0;
* VARIABLE-SIZED ZONE
        ROVEC←ROVER←ZONE.FLIST;
MAKE1:  RSIZE←ROVER.HSIZE;
        IF RSIZE<SIZE+MINSIZ AND RSIZE#SIZE DO;
            GOTO MAKE1 IF (ROVER←ROVER.NBLK)#ROVEC
            ELSE GOTO MAKEOV;
        ENDIF;
        EBLK←(BLK←ROVER)+ROVER.HSIZE;
        EBLK.HFTAG←0;
        IF ROVER.HSIZE=SIZE DO;
* EXACT FIT
            BLK.HFREE←0;
            ZONE.FLIST←RFB(ROVER,ZONE);
        ELSE DO;
* SPLIT THE BLOCK
            BLK←EBLK-SIZE;
            BLK.HIDDEN←1@HFTAG+SIZE;
            BLK[-2]←-RSIZE IF (RSIZE←ROVER.HSIZE←ROVER.HSIZE-SIZE)>MINSIZ;
        ENDIF;
* COMMON EXIT
        BSET(BLK,0,SIZE-1);
        RETURN BLK;

* OVERFLOW
MAKEOV: BLK←(ZONE.FOVX)(SIZE-1,ZONE); RETURN BLK;

        END;

        PROGRAM RFB; INCLUDE ALLOC'DECS;
        FUNCTION RFB(RBLK,ZONE);
* SUBROUTINE TO REMOVE A BLOCK FROM THE FREELIST
        IF RBLK.NBLK=RBLK DO;
            RETURN ZONE.FLIST←-1;
        ELSE DO;
            ZONE.FLIST←RBLK.NBLK IF ZONE.FLIST=RBLK;
            RBLK.NBLK.PBLK←RBLK.PBLK;
            RETURN RBLK.PBLK.NBLK←RBLK.NBLK;
        ENDIF;

        END;

        COMMON USERDECS; INCLUDE COMDECS;
*
* DECLARATIONS FOR USER PROGRAMS
*
        ST OL(NCMCH);* OUTPUT BUFFER FOR USER CONSOLE OUTPUT
        LB TRAP'LABEL;* GO HERE AFTER TRAP
        DECLARE INTEGER ARRAY LSTK[2000];
        DECLARE POINTER INITIAL'SP←@LSTK[0],NORMAL'SL←@LSTK[1999];

* OUTPUT MACROS
        MACRO IOUT()←SETS(OL,0,0);
        MACRO PTCH(C)←WCI(C,OL);
        MACRO PTST(S)←APPEND(OL,S//LF'PUNT);
        MACRO PTNO(N,F,R)←CNS(N,OL,F,R//LF'PUNT);
        MACRO PTDN(N)←PTNO(N,4B7,10);
        MACRO PTON(N)←PTNO(N,4B7,8);
        MACRO PTNL()←WCI(NLCH,OL);
        MACRO PTIS(S)←SCOPY(OL,S//LF'PUNT);


        END;

        PROGRAM USER'ENTRIES; INCLUDE USERDECS,TRAP'DECS;
*
* ENTRY POINTS
*
        FIXED;

        MACRO SAVE'STATE(X)←.STX X[XSTLOC],EAX X[0],STORS,MIN TRAP'FLAG;

* COME HERE AFTER TRAP MESSAGE
T'L:    JUMP'RETURN(
        READ'SPS'PARAM('CSL'//SF'PUNT)-SP'LEV-1//T'R:ERCODE,ERMSNO);
T'R:    SP'RETURN(//SF'PUNT);

* INITIAL AND 'CONTINUE' SUBPROCESS ENTRIES
        ARBENT XXXXXX(), SP'ENTRY ←2;
        ARBENT XXXXXY(), SP'ENTRY ←3;

        .LDA INITIAL'SP,XLA;
        TRAP'LABEL←T'L; TRAP'FLAG←QUIT'FCN'FLAG←QUIT'FLAG←0;
        STACK'PTR←INITIAL'SP; STACK'LIM←NORMAL'SL;
        SP'LEV←READ'SPS'PARAM('CSL'//SF'PUNT);
        SET'SPT'FIELD(-1,'TM',READ'SPT'FIELD(-1,'TCM'//SF'PUNT)
        //SF'PUNT);
       THIS'SUB'PROCESS←READ'SPS'PARAM('CSP'//SF'PUNT);
       STATUS'BITS←READ'SPT'FIELD(THIS'SUB'PROCESS, 'SB'//SF'PUNT);
       SET'SPT'FIELD(THIS'SUB'PROCESS, 'SB', (STATUS'BITS V' 3B6)//SF'PUNT);
        RUN'USER(); RUNTIME'FAILURE();

* SP'TRAPS COME HERE
        ARBENT XXXSPT(), SP'ENTRY ←0; SAVE'STATE(SP'GSTATE); STRAP();


* RING TRAPS
        ARBENT XXXABE(), TRAP'ENTRY ←1; SAVE'STATE(GSTATE); ABE'TRAP();
        ARBENT XXXFLO(), TRAP'ENTRY ←2; SAVE'STATE(GSTATE); RTRAP(2);
        ARBENT XXXFLU(), TRAP'ENTRY ←3; SAVE'STATE(GSTATE); RTRAP(3);
        ARBENT XXXRO(), TRAP'ENTRY ←4; SAVE'STATE(GSTATE); RTRAP(4);
        ARBENT XXXIAT(), TRAP'ENTRY ←5; SAVE'STATE(GSTATE); RTRAP(5);
        ARBENT XXXUFN(), TRAP'ENTRY ←6; SAVE'STATE(GSTATE); RTRAP(6);
        ARBENT XXXFXO(), TRAP'ENTRY ←7; SAVE'STATE(GSTATE); RTRAP(7);
        ARBENT XXXDIZ(), TRAP'ENTRY ←8; SAVE'STATE(GSTATE); RTRAP(8);

* STACK OVERFLOW - WATCH OUT
        ARBENT XXXSOV(), TRAP'ENTRY ←9; STKTRAP();

        END;

        PROGRAM PUNT; INCLUDE USERDECS,TRAP'DECS;
        INCLUDE SPTDECS;
*
* MAIN TRAP/PUNT PROCESSING ROUTINE
*
        INT N,P,Q,SR;
        INT LSPCS←5;
        LB R= L' [0];
        INTARY SPCA[LSPCS],STATE[LSTATE];
        PTR SA;* POINTER TO STATE[0]
        MACRO IS'TSB'INSTR(X)←((X) A' 07740000B=04600000B);
        OCTFL UTNO(0:0,5),SPCSLR(1:6,23);
        LB FIELD LBW0(0);

        MACRO SAVE'STATE(X)←BCOPY(SA←@STATE[0],@X[0],LSTATE) &
        (TRAP'PUNT() IF TRAP'FLAG#1);
        MACRO SPT'PUNT←SPTPUNT:ERCODE,ERMSNO;

*
* ENTRY FOR RING TRAPS
*
        ARBENT RTRAP(N);
        SAVE'STATE(GSTATE);
RTPUNT: RPUNTMSG(N,RTRAP'LOC); GOTO PUNTCOM;

*
* SPECIAL ENTRY FOR 'ABE' TRAP -
* CHECK IF REFERENCE IS FOLLOWED BY TSB OPCODE
*
        ARBENT ABE'TRAP();
        SAVE'STATE(GSTATE);
        INSTR'LOC←RTRAP'LOC+1;
        IF IS'TSB'INSTR($INSTR'LOC) DO;
            .LDX SA[XSTLOC],LDA SA[LSTLOC],XLA,STA SAVEL,EAC$INSTR'LOC;
            .LDA SAVEL,XLA,STX Q;
            R$BRDPC←Q;
            SA[PSTLOC]←@ABE'EXIT;
            R$BRDLR←SA[LSTLOC];
            SA[LSTLOC]←@R;
            TRAP'FLAG←0;
            .LDX SA,LOADS;
ABE'EXIT:   RETURN;
        ENDIF;
        N←1; GOTO RTPUNT;

*
* ENTRY FOR SP TRAPS
*
        ARBENT STRAP();
        SAVE'STATE(SP'GSTATE); ALLOW'INTS() IF (N←@R.SP'TNO)#23; Q←@R.SP'TPAR;
        READ'SPCS(0,SPCA//SPT'PUNT); R$BRDLR←SPCA[0]$SPCSLR;
        (@R)[-1]←P←(@R)[1];* SO UWSTK LABELS WILL WORK
        P←SPCA[0]$SPCSPR;
        GOTO SPTPUNT IF N#23;

* QUIT
QUIT:   QUIT'FLAG←1;
        TRAP'FLAG←0;
        QUIT'FCN() IF QUIT'FCN'FLAG;
        SA[LSTLOC]←@R-2;
        SET'SPT'FIELD(-1,'TM',READ'SPT'FIELD(-1,'TM'//SF'PUNT) V' 1
        //SF'PUNT);
        SA[PSTLOC]←@QUITX; .LDX SA,LOADS;
QUITX:  SP'RETURN(//SPT'PUNT);


* FREE STORAGE OVERFLOW
        ARBENT OFLOTRAP(ERCODE,ERMSNO);
        R←R$BRDLR.LBW0; N←24; GOTO RTF;

* UNEXPECTED RUNTIME FAILURE
        ARBENT RUNTIME'FAILURE(); N←25;
RTF:    P←R$BRDPC; Q←0;

SPTPUNT:SPUNTMSG(N,P,Q);
PUNTCOM:TRAP'FLAG←0;
        GOTO TRAP'LABEL;

* TRAP DURING STATE-SAVING
        ARBENT TRAP'PUNT();
        SPUNTMSG(26,R$BRDPC,0); GOTO PUNTCOM;


        END;

        PROGRAM STKOV'TRAP; INCLUDE USERDECS;
        INCLUDE TRAP'DECS;
*
* STACK OVERFLOW TRAP PROCESSING
*
        FIXED;
        INT R= L' [0];

        ARBENT STKTRAP();
        (@R).BRDLR←(@R).BRDLR.BRDLR WHILE STACK'LIM-(@R).BRDLR<100B;
        RPUNTMSG(9,RTRAP'LOC);
        TRAP'FLAG←0; GOTO TRAP'LABEL;


        END;

        PROGRAM UTRAP'MSG; INCLUDE USERDECS,MACHINE'DECS;
*
* PRINT USER TRAP MESSAGE
*?*  THIS ROUTINE SHOULD FRETURN, RATHER THAN PUNTING (COULD CAUSE
*?*       PUNT LOOP AND STACK OVERFLOW)
*
        ST MSG(60),CM; INT N,P,Q,T;
        CHRARY RN[10]←(6'RT0?',6'ABE',6'FLO',6'FLU',6'ROIA',
        6'IAT',6'UFN',6'FXO',6'DIZ',6'SOV');
        CHRARY SN[27]←(6'MACC',6'PRO',6'PNIM',6'PNIC',6'PI',
        6'TI',6'BLL',6'ILIM',6'PNOD',6'DWSO',6'CWSO',
        6'NEP',6'DMRD',6'NILE',6'SPCO',6'PMTO',6'DKSE',
        6'?17?',6'?18?',6'?19?',6'?20?',6'?21?',6'UTSE',
        6'QUIT',6'FSOV',6'PUNT',6'TRAP');

        ARBENT RPUNTMSG(N,P); N←-(N+1);
        ARBENT SPUNTMSG(N,P,Q);


        SETS(MSG,0,0); WCI(NLCH,MSG);
        APPEND(MSG,"USER TRAP '"//LF'PUNT);

COM:
        IF N=22 DO;* 'UTSE' ERROR
        APPEND(MSG,"UTSE - "//LF'PUNT);
            N←(Q$UTSE'SPTNO IF T←Q$UTSE'CLASS>1 ELSE
            6 IF T=1 ELSE -(Q$UTSE'RTNO+1));
        ENDIF;

        IF N=6 DO;* BLL ERROR
        PUNT'WWD(MSG,6'BLL-'); WCI(Q$BLL'CLASS V' '0',MSG);
        ELSE DO;
            PUNT'WWD(MSG,SN[N] IF N>=0 ELSE RN[-(N+1)]);
        ENDIF;
        APPEND(MSG,"' AT P: "//LF'PUNT);
        CNS(P,MSG,4B7,8//LF'PUNT); WCI('B',MSG);

        WCI(NLCH,MSG);
QT'P:   PRINT'STRING(-1,MSG,0//QUIT'PUNTX(QT'P,MSG));
        RETURN;

        END;

        PROGRAM PUNT'WWD; INCLUDE COMDECS;
*
* APPEND 4 CHARACTER NAME TO STRING
*
        PTR P; CHR M,C; ST S; STFL A(0); CHRFL CH60(0:0,5);

        ARBENT PUNT'WWD(STRING @P,M); S←P.A;

        (WCI(C,S) IF C#' ') & M←M LSH 6
        FOR C←M$CH60 WHILE M#6'    ';
        P.WP←S$WP; RETURN;

        END;

        PROGRAM VARIOUS; INCLUDE USERDECS;

*
* CLEAR CIOS NPUT/OUTPUT &
* TYPE NEWLINE
*

        ARBENT CLEAR'CIOS();
LP:     QUIT'FLAG←0;
        SET'CIOS'FIELD(-1,'OCC',0//SF'PUNT);
        SET'CIOS'FIELD(-1,'ICC',0//SF'PUNT);
        IOUT();
        PRINT'CHAR(-1,NLCH,QUIT'FLAG//QUIT'PUNT(LP));
        RETURN;

*
* REMOVE QUIT CALL FROM SPCS AND UNWIND STACK
* BY NON-LOCAL GOTO
*

        ARBENT ZAP(LABEL ZLAB);
        DELETE'CALL(//SF'PUNT);
        GOTO ZLAB;

        END;

        PROGRAM GET'MSG;
        INCLUDE USERDECS;

        DECLARE INTEGER I;
        DECLARE STRING S,IN(72);

        STRING ENTRY GET'MSG(S);
        SETS(IN,0,0);
LOOP:   IN←READ'LINE(-1,IN,">",QUIT'FLAG//QUIT'PUNTX(EXIT,IN));
        GOTO LOOP IF LENGTH(IN)=0;
        GOTO EXIT IF GC(IN)='%' AND LENGTH(IN)=1;
TOP:    APPEND(S,IN//TOO'LONG);
        WCI(NLCH,S//TOO'LONG);
        GOTO LOOP;
EXIT:   RETURN S;

TOO'LONG:PRINT'STRING(-1,"TOO LONG - LAST LINE TRUNCATED TO:",
        QUIT'FLAG//QUIT'PUNTX(EXIT,IN));
        IN$WP←INCDES(IN$BP,479-LENGTH(S));
        PRINT'CHAR(-1,NLCH,QUIT'FLAG//QUIT'PUNTX(EXIT,I));
        PRINT'STRING(-1,IN,QUIT'FLAG//QUIT'PUNTX(EXIT,IN));
        GOTO TOP;


        END;

        PROGRAM SEND'MAIL;
        INCLUDE USERDECS;

        DECLARE STRING MAIL(480),CNAME(72),CUNO(5),IN(72),LINE(72),
        NAME;
        DECLARE INTEGER UNO,KEY,SPACE,I;

        ENTRY MAIL'TO(NAME);

        SETS(LINE,0,0);
        IF LENGTH(NAME)=0 DO;
            NAME←READ'LINE(-1,LINE,"TO WHO?  ",QUIT'FLAG//
            QUIT'PUNTX(EXIT,LINE));
        ENDIF;
        KEY←READ'PROC'PARAM('IKY'//SF'PUNT);
        UNO←0;
        UNO←CSN(NAME,10//OK);
OK:     MAIL←READ'UP'ITEM('UP',-1,UNO,NAME,"MAIL",MAIL,KEY// VALUE
        (GOTO ILLEGAL IF ERCODE='ENF' ELSE
        GOTO CONT IF ERCODE='INF' ELSE
        RUNTIME'FAILURE()):ERCODE,ERMSNO);
        SETS(CNAME,0,0);
CONT:   CNAME←READ'LINE(-1,CNAME,"YOUR NAME?  ",QUIT'FLAG//
        QUIT'PUNTX(EXIT,CNAME));
        GOTO CONT IF LENGTH(CNAME)=0;
        CUNO←READ'UP'ITEM('UP',-1,0,CNAME,"#",CUNO,KEY//BAD:
        ERCODE,ERMSNO);
        SPACE←480-LENGTH(MAIL)-LENGTH(CNAME)-8;
        GOTO BYE IF SPACE<2;
        SETS(IN,0,0);
        CNS(SPACE,IN,3,10//LF'PUNT);
        PRINT'STRING(-1,IN,QUIT'FLAG//QUIT'PUNTX(EXIT,IN));
        PRINT'STRING(-1," CHARS AVAILABLE FOR MSG.",QUIT'FLAG//
        QUIT'PUNTX(EXIT,IN));
        PRINT'CHAR(-1,NLCH,QUIT'FLAG//QUIT'PUNTX(EXIT,I));

*   LET RECIPIENT KNOW WHO IS SENDING THE MESSAGE.
        APPEND(MAIL,"FROM "//LF'PUNT);
        APPEND(MAIL,CNAME//LF'PUNT);
        WCI(':',MAIL//LF'PUNT);
        WCI(NLCH,MAIL//LF'PUNT);

        MAIL←GET'MSG(MAIL);

        SET'UP'ITEM('UP',-1,UNO,NAME,"MAIL",MAIL,KEY//SF'PUNT);
        SET'UP'ACCESS('UP',-1,UNO,NAME,"MAIL",2,1,KEY//SF'PUNT);
        GOTO RET;

*   PROBLEM AREAS
BAD:    PRINT'STRING(-1,CNAME,QUIT'FLAG//QUIT'PUNTX(EXIT,IN));
        GOTO HOP;
ILLEGAL:PRINT'STRING(-1,NAME,QUIT'FLAG//QUIT'PUNTX(EXIT,IN));
HOP:    PRINT'STRING(-1," IS NOT A RECOGNIZED USER.",QUIT'FLAG//
        QUIT'PUNTX(EXIT,IN));
        GOTO EXIT;
BYE:    PRINT'STRING(-1,"NO SPACE AVAILABLE.",QUIT'FLAG//
        QUIT'PUNTX(EXIT,IN));

EXIT:   PRINT'CHAR(-1,NLCH,QUIT'FLAG//QUIT'PUNTX(RET,I));
RET:    RETURN;


        END;

        PROGRAM REPLACE'HEADER;
        INCLUDE USERDECS;

        DECLARE INTEGER KEY,I,UN1←1;
        DECLARE STRING HEADR(480),NAME←"";

        ENTRY HEADER();

        SETS(HEADR,0,0);
        HEADR←GET'MSG(HEADR);
        KEY←READ'PROC'PARAM('IKY'//SF'PUNT);
        SET'UP'ITEM('UP',-1,UN1,NAME,"HEADER",HEADR,KEY//SF'PUNT);
        SET'UP'ACCESS('UP',-1,UN1,NAME,"HEADER",2,1,KEY//SF'PUNT);
        RETURN;


        END;

        PROGRAM POST'NOTICE;
        INCLUDE USERDECS;

        DECLARE INTEGER KEY,UNO,MAXUNO←500;
        DECLARE STRING NOTE(480),NAME←"";

        ENTRY NOTICE();
        SETS(NOTE,0,0);
        KEY←READ'PROC'PARAM('IKY'//SF'PUNT);
        NOTE←GET'MSG(NOTE);
       SET'UP'ITEM('UP',-1,1,NAME,"NOTICE",NOTE,KEY//NEXT:ERCODE,ERMSNO);
       SET'UP'ACCESS('UP',-1,1,NAME,"NOTICE",2,1,KEY//SF'PUNT);
        FOR UNO←3 TO MAXUNO DO;
            SET'UP'ITEM('UP',-1,UNO,NAME,"NOTICE","",KEY//NEXT:ERCODE,ERMSNO);
            SET'UP'ACCESS('UP',-1,UNO,NAME,"NOTICE",2,1,KEY//SF'PUNT);
NEXT:   ENDFOR;
        RETURN;


        END;

        COMMON COMMANDS;
        DECLARE STRING ARRAY ENTRIES[4]←("MAIL","NOTICE","HEADER","FINISHED");


        END;

        PROGRAM RUN'USER;
        INCLUDE USERDECS,COMMANDS;

        DECLARE LABEL EXTERNAL LABEL'KLUDGE;
        DECLARE LABEL ARRAY COM[4]←(MAIL,NOTE,HEAD,RET);
        DECLARE STRING S(72),CMND;
        DECLARE INTEGER K,LNO,UNO;

        ENTRY RUN'USER();
        GET'COM'LINE(S:S//SF'PUNT);
        CMND←GET'PARAM(S);
        K←ABRV'LKP(CMND,ENTRIES//SF'PUNT);
        UNO←READ'PROC'PARAM('UNO'//SF'PUNT);
        LNO←READ'PROC'PARAM('TNO'//SF'PUNT);
        GOTO LABEL'KLUDGE(COM[K]) IF LNO=1 OR UNO=1;
        PRINT'STRING(-1,"MUST HAVE SYSTEM PRIVILEGES",QUIT'FLAG//
        QUIT'PUNTX(RET,S));
        PRINT'CHAR(-1,NLCH,QUIT'FLAG//QUIT'PUNTX(RET,K));
RET:    SP'RETURN(//SF'PUNT);

MAIL:   MAIL'TO(GET'PARAM(S));
        SP'RETURN(//SF'PUNT);

NOTE:   NOTICE();
        SP'RETURN(//SF'PUNT);

HEAD:   HEADER();
        SP'RETURN(//SF'PUNT);



        END;

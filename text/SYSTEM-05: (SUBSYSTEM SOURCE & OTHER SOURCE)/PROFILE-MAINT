       COMMON    SYSCALLS;

* MCALL DECLARATIONS

        MACRO     ARBMC ← UNKNOWN MONITOR;
       MACRO     INTMC ← INTEGER MONITOR;
       MACRO     STMC ← STRING MONITOR;
       MACRO     LNMC ← LONG MONITOR;
       MACRO     LNLNMC ← LONGLONG MONITOR;

* CALLS TO MANIPULATE MIBS AND SIBS
        INTMC     CREATE'MIB ← 190;
       ARBMC     READ'MIBOB'INDEX ← 0;
       ARBMC     READ'MIBOB'NAME ← 1;
       ARBMC     SET'MIBOB'NAME ← 2;
       ARBMC     SET'MIBOB'ACCESS ← 3;
       ARBMC     SET'LOCK'LIST ← 4;
       ARBMC     DELETE'MIBOB ← 5;
       INTMC     CREATE'MIBOB ← 6;
       ARBMC     SET'MIB'ACCESS ← 10;
       INTMC     READ'MIB'ACCESS ← 11;
       ARBMC     SET'MIBOB'VALUE ← 12;
       INTMC     COPY'MIBOB ← 14;* UNIMPLEMENTED
       ARBMC     SET'NO'CHARGE ← 15;*** ???
       INTMC     READ'MIB'SPACE ← 16;
       ARBMC     SET'REF'DATE ← 18;*** ???
       ARBMC     SET'DURABILITY ← 28;*** ???

* OFT CALLS
        INTMC     MOPEN'FILE ← 19;
       ARBMC     MREAD'OFT ← 20;
       ARBMC     SET'OFT'AL ← 21;
       INTMC     MSET'OFT'CL ← 22;
       ARBMC     SET'FILE'LENGTH ← 23;* IMPROVE THIS FOR UTS
       INTMC     CR'FILE'PAGE ← 24;
       INTMC     DEL'FILE'PAGE ← 25;
       INTMC     NEXT'FILE'PAGE ← 26;
       ARBMC     MOVE'PAGE'PMT ← 27;

* PMT CALLS
        INTMC     ACQUIRE'PMT ← 50;
       ARBMC     NEW'PMT'PAGE ← 51;
       ARBMC     CLEAR'PMT ← 53;
       ARBMC     DELETE'PMT ← 54;
       ARBMC     SET'PMT'AL ← 55;
       ARBMC     SET'PMT'CL ← 56;
       ARBMC     SET'PMT'RO ← 57;
       ARBMC     READ'PMT ← 58;
* WORKING SET CALLS
        ARBMC     PUT'PAGE'DWS ← 65;
       ARBMC     PUT'PAGE'CWS ← 66;
       INTMC     DEL'PAGE'DWS ← 67;
       INTMC     DEL'PAGE'CWS ← 68;
       INTMC     READ'LWS ← 70;
       ARBMC     SET'LWS ← 71;

* SPT CALLS
        INTMC     MCREATE'SP ← 90;
       ARBMC     MDESTROY'SP ← 91;
       ARBMC     MREAD'SPT ← 95;
       ARBMC     READ'SPCS ← 96;
       INTMC     MRD'SPT'FIELD ← 97;
       ARBMC     MST'SPT'FIELD ← 98;
       ARBMC     READ'MAP ← 99;
       ARBMC     SET'MAP ← 100;
       INTMC     READ'MAP'BYTE ← 101;
       ARBMC     SET'MAP'BYTE ← 102;
       INTMC     READ'SPS'PARAM ← 106;

* SPCS CALLS
        ARBMC     SP'CALL ← 111;
       ARBMC     SP'JUMP ← 112;
       ARBMC     SP'TRAP ← 113;
       ARBMC     TRAP'RETURN ← 114;
       ARBMC     SP'BRANCH ← 115;
       ARBMC     SP'RETURN ← 116;
       ARBMC     JUMP'RETURN ← 117;
       ARBMC     MARK'CALL ← 118;
       ARBMC     DELETE'CALL ← 119;
       ARBMC     MODIFY'CALL ← 120;

* PROCESS CALLS
        INTMC     COPY'PMT'PROC ← 130;
       INTMC     ACTIVATE'PROC ← 132;
       ARBMC     TRANSFER'TERM ← 133;
       ARBMC     MAKE'DORMANT ← 134;
       ARBMC     INIT'PROC'PAGE ← 135;
       ARBMC     INIT'PROC'MAP ← 136;
       ARBMC     INIT'SPT ← 137;
       INTMC     READ'PROC'PARAM ← 211;
* IWS CALLS
        ARBMC     SET'PROC'INT ← 163;
       ARBMC     QUIT'BLOCK ← 164;
       INTMC     GET'INT'NO ← 165;
       ARBMC     READ'ICT ← 166;
       ARBMC     ALLOW'INTS ← 168;
       ARBMC     REFUSE'INTS ← 169;
       ARBMC     BLOCK ← 170;
       ARBMC     SET'ICT ← 172;
       ARBMC     SET'ICT'CL ← 173;
       INTMC     ACQUIRE'ICT ← 174;

* CHIO CALLS
        ARBMC     SET'LINE'FIELD ← 180;
       ARBMC     READ'LINE'TABLE ← 181;
       ARBMC     READ'STRING'BRK ← 182;
       ARBMC     WRITE'STRING ← 183;

* MISCELLANEOUS
        LNMC      READ'CLOCK ← 210;
       INTMC     READ'PR'PARAM ← 211;*** ???
* UCALL DECLARATIONS

        MACRO     ARBUC ← UNKNOWN UTILITY;
       MACRO     INTUC ← INTEGER UTILITY;
       MACRO     CHRUC ← CHARACTER UTILITY;
       MACRO     STUC ← STRING UTILITY;
       MACRO     LNUC ← LONG UTILITY;

* MISCELLANEOUS UCALLS
        ARBUC     BREAK'POINT ← 0;*             UCALL FOR DEBUGGING PROGRAMS
       STUC      ERRORMSG ← 1;*                RETURN SYSTEM ERROR MESSAGE
       STUC      GET'PARAM ← 2;*               STRIP PARAMETER FROM STRING
       STUC      GET'COM'LINE ← 3;*            GET CURRENT COMMAND LINE FROM UTS
       INTUC     ABRV'LKP ← 4;*                LOOK UP ABBREVIATED NAME IN STARY
       INTUC     CON'ABRV'LKP ← 5;*            CONTINUE SAME IN NEW STARY

* FILE SYSTEM CALLS
        ARBUC     NAME'SEARCH ← 10;*            CONVERT FILE ST TO UTS NAME
       ARBUC     SPECIAL'SEARCH ← 11;*         VARIATION OF ABOVE
       INTUC     CONV'NAME ← 12;*              CONVERT FROM UTS TO MON FILE NAME
       ARBUC     SPREAD'NAME ← 13;*            SPLIT FILE NAME STRING INTO COMP.
       ARBUC     READ'MIBOB'VALUE ← 14;*       READ 'VALUE' OF MIB OBJECT
       ARBUC     DELETE'FILE ← 15;*            DELETE FILE AND CONTENTS
       INTUC     OPEN'FILE ← 16;*              OPEN FILE W/WO LOCKING
       ARBUC     CLOSE'FILE ← 17;*             CLOSE AND UNLOCK FILE
       ARBUC     READ'OFT ← 18;*               READ OFT
       INTUC     READ'OFT'FIELD ← 19;*         READ OFT FIELD
       ARBUC     SET'OFT'CL ← 20;*             SET OFT CONTROL LOCK
       ARBUC     CONV'KEY ← 21;*               CONVERT DEFAULT ACCESS KEY

* EXTENDED SPS CALLS
        INTUC     CREATE'SSP ← 30;*             CREATE SUBSIDIARY SUB-PROCESS
       INTUC     CREATE'PSP ← 31;*             CREATE PARALLEL SUB-PROCESS
       ARBUC     ATTACH ← 32;*                 ATTACH PI FILE TO SUB-PROCESS
       ARBUC     DESTROY'SP ← 33;*             DESTROY SUB-PROCESSES
       ARBUC     READ'SPT ← 34;*               READ SPT
       INTUC     READ'SPT'FIELD ← 35;*         READ SPT FIELD
       ARBUC     SET'SPT'FIELD ← 36;*          SET SPT FIELD
       STUC      READ'SPNAME ← 37;*            READ SUB-PROC NAME
       ARBUC     SET'SPNAME ← 38;*             SET SUB-PROC NAME
       INTUC     SPNAME'SEARCH ←39;*           LOOK UP SP NAME

* CIOS MANIPULATION
        INTUC     CREATE'CIOS ← 40;*            CREATE CONTROL I/O STREAM
       INTUC     READ'CIOS'FIELD ← 41;*        READ CIOS FIELD
       ARBUC     SET'CIOS'FIELD ← 42;*         SET (SOME) CIOS FIELDS
       ARBUC     SET'CIOS'INPUT ← 43;*         SET UP FOR INPUT
       ARBUC     SET'CIOS'OUTPUT ← 44;*        SET UP FOR OUTPUT
* CIOS INPUT/OUTPUT
        ARBUC     PRINT'STRING ← 45;*           WRITE STRING ON CIOS
       ARBUC     PRINT'CHAR ← 46;*             WRITE (= BUFFER) CHAR ON CIOS
       ARBUC     START'OUTPUT ← 47;*           DUMP OUTPUT BUFFER
       STUC      READ'LINE ← 48;*              READ NEXT INPUT LINE
*STUC      EDIT'LINE ← 49;*              EDIT CURRENT LINE
        CHRUC     READ'CHAR ← 50;*              READ NEXT CHARACTER
       ARBUC     BLOCK'OB'EMPTY ← 51;*         WAIT UNTIL OUT BUFFER IS EMPTY

* USER PROFILE
        STUC      READ'UP'ITEM ← 60;*           READ ITEM FROM USER PROFILE
       STUC      READ'UP'NAMES ← 61;*          READ NAMES OF UP ITEMS
       ARBUC     SET'UP'ITEM ← 62;*            SET (CREATE) VALUE OF UP ITEM
       ARBUC     SET'UP'ACCESS ← 63;*          SET ACCESS TO UP ITEM
       LNUC      FIND'MIB ← 64;*               CONVERT USER NAME/NUMBER TO MIB ADDR
       ARBUC     CREATE'UP'ENTRY ← 65;*        CREATE USER/UP ENTRY
       ARBUC     DELETE'UP'ENTRY ← 66;*        DELETE USER/UP ENTRY

       END;

       COMMON    DECDECS;
*
* SHORT DECLARATION MACROS FOR SPL
*

        MACRO     INT ← DECLARE INTEGER;
       MACRO     OCT ← DECLARE OCTAL;
       MACRO     PTR ← DECLARE POINTER;
       MACRO     CHR ← DECLARE CHARACTER;
       MACRO     ST  ← DECLARE STRING;
       MACRO     LN  ← DECLARE LONG;
       MACRO     LNLN ← DECLARE LONGLONG;
       MACRO     LB  ← DECLARE LABEL;

        MACRO     OCTFL ← DECLARE OCTAL FIELD;
       MACRO     INTFL ← DECLARE INTEGER SIGNED FIELD;
       MACRO     PTRFL ← DECLARE POINTER FIELD;
       MACRO     CHRFL ← DECLARE CHARACTER FIELD;
       MACRO     STFL  ← DECLARE STRING FIELD;
       MACRO     LNFL  ← DECLARE LONG FIELD;
       MACRO     FNFL  ← DECLARE FUNCTION FIELD;

        MACRO     INTARY ← DECLARE INTEGER ARRAY;
       MACRO     OCTARY ← DECLARE OCTAL ARRAY;
       MACRO     PTRARY ← DECLARE POINTER ARRAY;
       MACRO     CHRARY ← DECLARE CHARACTER ARRAY;
       MACRO     STARY  ← DECLARE STRING ARRAY;
       MACRO     LNARY  ← DECLARE LONG ARRAY;
       MACRO     LBARY  ← DECLARE LABEL ARRAY;
       MACRO     FLARY ← DECLARE FIELD ARRAY;
       MACRO     FNARY ← DECLARE FUNCTION ARRAY;

        MACRO     INTARY1 ← DECLARE INTEGER ARRAYONE;
       MACRO     PTRARY1 ← DECLARE POINTER ARRAYONE;

        MACRO     INTFN ← DECLARE INTEGER FUNCTION;

        MACRO     ARBENT ← UNKNOWN ENTRY;
       MACRO     INTENT ← INTEGER ENTRY;
       MACRO     OCTENT ← POINTER ENTRY;
       MACRO     PTRENT ← POINTER ENTRY;
       MACRO     CHRENT ← CHARACTER ENTRY;
       MACRO     STENT ← STRING ENTRY;
       MACRO     LNENT ← LONG ENTRY;
       MACRO     LBENT ← LABEL ENTRY;
       MACRO     ARYENT ← ARRAY ENTRY;
        MACRO     ARBEXT ← DECLARE UNKNOWN EXTERNAL;
       MACRO     INTEXT ← DECLARE INTEGER EXTERNAL;
       MACRO     OCTEXT ← DECLARE OCTAL EXTERNAL;
       MACRO     PTREXT ← DECLARE POINTER EXTERNAL;
       MACRO     CHREXT ← DECLARE CHARACTER EXTERNAL;
       MACRO     STEXT ← DECLARE STRING EXTERNAL;
       MACRO     LNEXT ← DECLARE LONG EXTERNAL;
       MACRO     LBEXT ← DECLARE LABEL EXTERNAL;
       MACRO     ARYEXT ← DECLARE ARRAY EXTERNAL;


        MACRO     LTABLE(F) ← F$FLDWDSP+1;
       INTFL     FLDWDSP(0: 13,23);

* LENGTHS OF NAMES
        INT       LMN ← 4, LTY ← 1, LFN ← LMN+LTY;
       INT       NBY ← 4, LNCH ← 24/NBY, NMNCH ← LMN*NBY,
        NTYCH ← LTY*NBY, NFNCH ← LFN*NBY, NCMCH ← 90;

       END;

       COMMON    MACHINE'DECS; INCLUDE DECDECS;
*
* DECLARATIONS FOR MACHINE-DEPENDENT PROGRAMMING
*

* LOW-G DEFINITIONS
        PTR       STACK'PTR = G'[2], STACK'LIM = G'[3],
        RTRAP'PARAM = G'[5], RTRAP'LOC = G'[4];

* FIELDS IN BLL DESCRIPTOR
        PTRFL     BRDPC(0: 6,23), BRDLR(1: 6,23);

* STATE DEFINTIONS
        INT       PSTLOC ← 0, ASTLOC ← 1, BSTLOC ← 2, CSTLOC ← 3, DSTLOC ← 4,
        XSTLOC ← 5, LSTLOC ← 6, GSTLOC ← 7, ESTLOC ← 8, SSTLOC ← 9,
        LSTATE ← 10;

* FIELDS FOR TRAP DEFINITIONS
        PTRFL     ADDR(0: 6,23); OCTFL SP'TNO(-2), SP'TPAR(-1),
        BLL'CLASS(0: 3,5), UTSE'CLASS(0: 0,1),
        UTSE'SPTNO(0: 1,5), UTSE'RTNO(0: 2,5);

       END;

       COMMON    COMDECS; INCLUDE DECDECS, SYSCALLS;
*
* COMMON DECLARATIONS FOR CODING
*

* GENERALLY USEFUL MACROS

        MACRO     NAMSET(S,L,A,B) ← SETUP(S,L,A,B) & S$WP ← S$EP;
       MACRO     EMPTY(S) ← LNGDES(S$RP, S$WP) <= 0;*** WP=RP OR WP=BP?
       MACRO     REPEAT ← WHILE 1 DO;
       MACRO     ENDRPT ← ENDFOR;
       MACRO     FDISP(F) ← RUNTIME'FAILURE() IF F$FLDSTB # 0 OR
        F$FLDSIZE # 24 ELSE F$FLDWDSP;
       OCTFL     FLDSTB(0: 8,12), FLDSIZE(0: 3,7);

* ERROR MACROS
        MACRO     NC'PUNT ← RUNTIME'FAILURE();* FOR NORMAL CALLS (EXPRESSIONS)
       MACRO     LF'PUNT ← VALUE NC'PUNT;* FOR LIBRARY FUNCTIONS
       MACRO     SF'PUNT ← LF'PUNT: ERCODE, ERMSNO;* FOR SYSTEM CALLS

* QUIT ACTION MACROS
        MACRO     QUIT'PUNT(L) ← VALUE GOTO L IF ERCODE = 'QIT' ELSE
        RUNTIME'FAILURE(): ERCODE, ERMSNO;
       MACRO     QUIT'PUNTX(L, X) ← VALUE GOTO L IF ERCODE = 'QIT' ELSE
        RUNTIME'FAILURE(): X, ERCODE, ERMSNO;

* PARAMETRIC CHARACTER DEFINITIONS
        CHR       SCHERALD ← '>' /* SUB-COMMAND HERALD */,
        BELCH ← 303B /* BELL */, NULCH ← 300B /* NULL */,
        NLCH ← 307B /* NEW LINE */,
        LFCH ← 310B /* LINE FEED */,
        MBCH ← 200B /* ZERO MULTIPLE BLANKS */,
        SQTCH ← '&'' /* SINGLE QUOTE */,
        DQTCH ← '"' /* DOUBLE QUOTE */,
        SEPCH ← '-' /* SEPARATOR */;

* STRING POINTER FIELDS
        OCTFL     BP(0) /* BEGINNING */, RP(1) /* READER */,
        WP(2) /* WRITER */, EP(3) /* END */;
* CHARACTER FIELDS
        CHRFL     CH0(0: 0,7), CH1(0: 8,15), CH2(0: 16,23);
* BEAD LENGTH FIELD
        PTRFL     LENGF(-1: 6, 23);
* FIELDS IN UTILITY FILE NAME
        LNFL      UFNUN(0) /* USER NUMBER/DISK ADDRESS */;
       OCTFL     UFNEN(2) /* OBJECT ENTRY-NUMBER */,
        UFNFN(3) /* FILE NAME */, UFNMN(3) /* MAIN NAME */,
        UFNTY(3+LMN) /* TYPE WORD */;

* FIELDS FOR UNO/DKA
        OCTFL     UNDKUN(0),
        UNDKDK(1);

        INT       LUFN ← LTABLE(UFNTY);* LENGTH OF UTILITY FILE:NAME

        INT       CB'PMT ← 1;* PMT ADDRESS OF CONTEXT BLOCK

* DECLARATIONS OF COMMON FUNCTIONS

* SPL RUNTIME FUNCTIONS
*ARBEXT    SCOPY, APPEND, CNS, RUNTIME'FAILURE;
        ARYEXT LBARY'KLUDGE;*, AR'DESC;
       PTREXT    SBASE; INTEXT ARRAYUB, ARRAYLB;* STEXT ST'DESC;
       LNEXT     LONG'ADD, LONG'SUB; INTEXT LONG'LE, LONG'LT;

* STORAGE ALLOCATOR
        PTREXT    STKMAKE;*, MAKE, SETZONE;
*ARBEXT    STORINIT, SELZONE, EXTZONE, FREE, FREEZONE;

       END;

       COMMON    UQNDECS; INCLUDE DECDECS;

* UNIQUE NAME FIELDS
        OCTFL     UQNTY(0: 0,1), UQNPMB(0: 0,0), UQNLFB(0: 1,1),
        UQNOWN(0: 2,17), UQNHFN(0: 18,23);
       OCTFL     UQNLFN(1: 0,12), UQNLPN(1: 13,23),
        UQNSFN(1: 0,15), UQNSPN(1: 16,23);

       END;

       COMMON    BFSDECS; INCLUDE UQNDECS;

* OBJECT TYPE-CODES
        INT       SIBSFCD ← 0, SIBLFCD ← 1, SIBPRCD ← 2, SIBAKCD ← 3,
        SIBRSCD ← 4, SIBOWCD ← 5, SIBFRCD ← 6,
        SIBSCCD ← 14, SIBLKCD ← 15;

* ACCESS KEY FIELDS
        OCTFL     ACK0(0), ACK1(1:0,7), ACKUN(1:8,23);
       INT       NORM'FIL'AC ← 0357B;* P(NO) F(RW) O(OW) - NORMAL ACCESS

       END;

       COMMON    OFTDECS; INCLUDE BFSDECS;

* FIELDS IN OFT
        OCTFL     OFTUB(0: 0,0), OFTRB(0: 1,1), OFTWB(0: 2,2), OFTXB(0: 3,3),
        OFTOB(0: 4,4), OFTMIX(0: 6,12),
        OFTAL(0: 15,23);* BETTER CHECK THIS WITH REVISION

        OCTFL     OFTCL(1: 15,23),
        OFTOT(2: 0,3), OFTPIB(2: 8,15), OFTPMIB(2: 16,23);
       LNFL      OFTUN(3);

        INT       NOFT ← 16, LOFT ← LTABLE(OFTUN)+1;

       END;

       COMMON    SIBDECS; INCLUDE BFSDECS;
*
* DECLARATIONS FOR SIB
*

* FIELDS IN SIB NAME (SIBN)
        OCTFL     SIBNOT(0: 1,4),
        SIBNLN(0: 10,23),
        SIBNAA(1: 1,4), SIBNEN(1: 10,23),
        SIBNMN(2), SIBNFN(2);
       OCTFL     SIBNTY(SIBNMN$FLDWDSP+LMN),
        SIBNLL(SIBNTY$FLDWDSP+1: 4,11),
        SIBNAC(SIBNLL$FLDWDSP: 12,23);
       OCTFL          SIBNPA(SIBNAC$FLDWDSP: 12,15),
        SIBNFA(SIBNAC$FLDWDSP: 16,19),
        SIBNOA(SIBNAC$FLDWDSP: 20,23);

        INT       LSIBN ← LTABLE(SIBNOA);* LENGTH OF SIBN TABLE

* FIELDS IN SIB VALUE (SIBV)
        OCTFL     SIBVOT(0: 1,4),
        SIBVLN(0: 10,23),
        SIBVAA(1: 1,4), SIBVEN(1: 10,23);
       LNFL      SIBFLUN(2);
       OCTFL     SIBFLLEN(4),
        SIBFLWD(5),
        SIBFLRD(6);

        LNFL      SIBLKUN(2);
       OCTFL     SIBLKEN(4),
        SIBLKMN(5),
        SIBLKTY(5+LMN);

        INT       LSIBFL ← LTABLE(SIBFLRD), LSIBLK ← LTABLE(SIBLKTY),
        LSIBV ← (LSIBFL IF LSIBFL > LSIBLK ELSE LSIBLK);
       INT       MLSIB ← (LSIBV IF LSIBV > LSIBN ELSE LSIBN);

       END;

       COMMON    PMTDECS; INCLUDE UQNDECS;

* FIELDS FOR PMT ENTRY
        LNFL      PMTUN(0);
       OCTFL     PMTFL(2: 0,0), PMTDKA(2: 2,23),
        PMTRO(3: 0,0), PMTAL(3: 3,11), PMTCL(3: 15,23);

        INT       NPMT ← 128;* NUMBER OF PMT ENTRIES
       INT       LPMT ← 5;* SIZE OF PMT ENTRY

       END;

       COMMON    SPTDECS; INCLUDE DECDECS;

* FIELDS IN SPCS
        OCTFL     SPCSNIS(0: 0,0), SPCSNIC(0: 1,1),
        SPCSCSP(0: 2,5), SPCSPR(0: 6,23),
        SPCS940M(1: 0,0), SPCSR0SP(1: 2,5), SPCSLR(1: 6,23),
        SPCSR1SP(2: 2,5), SPCSGR(2: 6,23);
       LNFL      SPCSIT(3);
       INT       LSPCS ← LTABLE(SPCSIT) + 1;

        INT       NSPT ← 8;

       END;

       COMMON    ATTACHDECS; INCLUDE DECDECS;
*
* DEFINITION OF ATTACH (PI) FILE HEADER
*
        OCTFL     ATFMT(0), ATNP(1), ATMAP(3), ATMNM(38),
        ATCUF(43), ATEP(44), ATEG(45);
       OCTFL     BYTEC(0: 12,13), BYTEP(0: 16,23);

        INT       FMTCODE ← 0;* VALUE OF CURRENT FORMAT

       END;

       COMMON    ICTDECS; INCLUDE DECDECS;

* FIELDS IN ICT
        OCTFL     ICTSRC(0: 0,2) /* SOURCE */,
        ICTACT(0: 3,5) /* ACTION */,
        ICTSPEC(0: 6,10) /* SUB-PROCESS/TRAP */,
        ICTBLK(0: 11,11) /* BLOCKING */,
        ICTCL(0: 15,23) /* CONTROL LOCK */;
       LNFL      ICTTM(1);* REAL/COMPUTE TIME VALUE

        INT       NICT ← 24, LICT ← LTABLE(ICTTM) + 1;

* VALUES FOR SOURCE-ACTION-BLOCK PARAMETER OF SET'ICT
        MACRO     ICT'SAB(S, A, B) ← S @ ICTSRC V' A @ ICTACT V' B @ ICTBLK;
       INT       ICTNULCD ← ICT'SAB(0, 0, 0) /* NULL */,
        ICTBLKCD ← ICT'SAB(1, 0, 1) /* BLOCKING */,
        ICTTRPCD ← ICT'SAB(1, 2, 1) /* TRAP */,
        ICTRTICD ← ICT'SAB(2, 1, 1) /* REAL-TIME INTERRUPR */;

       END;

       PROGRAM   LABEL'KLUDGE; INCLUDE DECDECS;
*
* CONVERT SOURCE-RELATIVE LABEL ARRAY TO ABSOLUTE
*
        LB        L; LBARY A;


        ARYENT    LBARY'KLUDGE(A); RETURN A;

       END;

       PROGRAM   LONG'COMPARE; INCLUDE DECDECS;
*
* COMPARE LONG VALUES
*
        PTR       P, Q; INT N;
       DECLARE INTEGER FIELD W0(0);

        INTENT    LONG'COMPARE(INTEGER @P, INTEGER @Q, N);

        RETURN 1 IF P[N].W0 # Q[N].W0 FOR N ← N - 1 BY -1 TO 0;
       RETURN 0;

       END;

       PROGRAM   SCOPY; INCLUDE COMDECS;
       PTR       P; ST S, D; STFL A(0);

        ARBENT    SCOPY(STRING @P, S), FRETURN;
       D ← P.A; P.RP ← D$WP ← D$RP ← D$BP; GOTO L;

        ARBENT    APPEND(STRING @P, S), FRETURN;
       D ← P.A;

****      CHECK STRING CHARACTER SIZES FOR COMPATABILITY
L:
        REPEAT;   WCI(GCI(S// VALUE P.WP ← D$WP & RETURN), D// FRETURN); ENDRPT;

       END;

       PROGRAM   ST'DESC; INCLUDE COMDECS;
       INT       N, S, O; PTR P; ST X;
       STENT     ST'DESC(N, P, S, O);

        P ← MAKE(S *(N + 24 / S - 1)/ 24) IF P = 0;

        IF S = 8 DO;
           .LDA 44B6;
       ELSEIF S = 6 DO;
           .LDA 40B6;
       ELSEIF S = 12 DO;
           .LDA 50B6;
       ELSEIF S = 24 DO;
           .LDA 54B6;
       ELSE DO;
           RUNTIME'FAILURE();
       ENDIF;

        .IOR P; .XMA O; .LSHA 18; .IOR O; .LDX -1; .ASP; .CXA;
       .STA X$BP; .STA X$RP; .STA X$WP; .LDX N; .ASP; .STX X$EP;
       RETURN X;

       END;

       PROGRAM   AR'DESC; INCLUDE COMDECS;
       INT       N, S, O; PTR P;
       ARYENT    AR'DESC(N, P, S, O);

        N ← N - 1 IF O = 0;
       RUNTIME'FAILURE() IF S > 63 OR S < 1 OR S > 3 AND N > 17777B OR
        N > 377777B OR N < O OR O # 0 AND O # 1;

        P ← MAKE((N + 1 IF O = 0 ELSE N)* S) IF P = 0;

        .LDA S; .SUB 1; .ICP 3; .BGT R'[3]; .IOR 100B; .LSHA 6; .LSHA 11;
       .IOR N; .CPZ O; .BEQ R'[2]; .IOR 1B7; .IOR 6B7; .CAB;
       .LDA P; .IOR 4B6; .XAB; RETURN;

       END;

       PROGRAM   CNS; INCLUDE COMDECS;
       INT       N, F, R, T, I, D; PTR P; ST S, B(25); STFL A(0);

        ARBENT    CNS(N, STRING @P, F, R), FRETURN;

        S ← P.A;
       FRETURN IF R < 2 OR R > 36;
       T ← (-N IF F >= 0 AND N < 0 ELSE N);
       B$RP ← B$WP ← B$EP; I ← 0;
LP:    .LDA T; .LSHD -23; .DIV R; .STA T; .STB D;
       WCD(D +('0' IF D < 10 ELSE 'A'-10), B);
       I ← I + 1; GOTO LP IF T # 0;
       WCD('-', B) & I ← I + 1 IF F >= 0 AND N < 0;
       F ← F A' 77B;
       IF F = 0 DO;
           F ← I;
       ELSEIF F <= I DO;
           B$RP ← INCDES(B$EP, -I);
       ELSE DO;
           WCI(' ', S// FRETURN) FOR I ← I + 1 TO F;
       ENDIF;
       WCI(D, S// FRETURN)
        FOR D ← GCI(B// VALUE P.WP ← S$WP & RETURN) WHILE 1;

       END;

       PROGRAM   CSN; INCLUDE COMDECS;
       PTR       P; INT R, F, D, N; ST S; STFL A(0);

        INTENT    CSN(STRING @P, R), FRETURN;

        S ← P.A; FRETURN IF R < 2 OR R > 36;

        IF D ← GCI(S// FRETURN) = '-' OR D = '+' DO;
           F ← (1 IF D = '-' ELSE 0); D ← GCI(S// FRETURN);
       ELSE DO;
           F ← 0;
       ENDIF;

        D ← D - '0' IF D >= '0' AND D <= '9' ELSE
        D ← D - ('A'-10) IF D >= 'A' AND D <= 'Z' ELSE FRETURN;
       FRETURN IF D >= R; N ← D;

        FOR D ← GCI(S// Y) REPEAT;
           D ← D - '0' IF D >= '0' AND D <= '9' ELSE
            D ← D - ('A'-10) IF D >= 'A' AND D <= 'Z' ELSE GOTO X;
           GOTO X IF D >= R; N ← N * R + D;
       ENDRPT;

X:      S$RP ← INCDES(S$RP, -1);
Y:     P.RP ← S$RP; RETURN (-N IF F ELSE N);

       END;

       PROGRAM   SBASE; INCLUDE COMDECS;
*
* FIND BASE ADDRESS OF WORD-ORIGINED STRING DESCRIPTOR
*
        ST        S;

        PTRENT    SBASE(S);
       .LDA S$BP; .LDX 1; .ASP; .CXA;
       .CMZ 3B6; .BNE L; .ETR 777777B; RETURN;
L:     RUNTIME'FAILURE();

       END;

       PROGRAM   ALENGTH; INCLUDE COMDECS;
*
* COMPUTE ARRAY BOUNDS
*
        PTR       A; OCTFL ABW(0);
       INTENT    ARRAYUB(A);
       .LDA A.ABW; .CMZ 2B6; .BNE R'[2]; .ETR 17777B;
       .ETR 377777B; RETURN;

        INTENT    ARRAYLB(A);
       .LDA A.ABW; .ETR 1B7; .ASHA -21; RETURN;

       END;

       PROGRAM   LONG'ARITH; INCLUDE COMDECS;
*
* LONG ARITHMETIC/RELATIONALS
*
        LN        X, Y; OCTFL W0(0), W1(1);

        LNENT     LONG'ADD(X, Y);* ADD
       .LDA X$W1, ADD Y$W1, CAB;
       .LDA X$W0, ADC Y$W0; RETURN;

        LNENT     LONG'SUB(X, Y);* SUBTRACT
       .LDA X$W1, SUB Y$W1, CAB;
       .LDA X$W0, SUC Y$W0; RETURN;

        INTENT    LONG'LE(X, Y);* LESS THAN OR EQUALS
       RETURN (1 IF LONG'SUB(X, Y)$W0 <= 0 ELSE 0);

        INTENT    LONG'LT(X, Y);* LESS THAN
       RETURN (1 IF LONG'SUB(X, Y)$W0 < 0 ELSE 0);

       END;

       COMMON ALLOC'DECS;

*
* SPL STORAGE ALLOCATOR
*

* THE BASIC STRUCTURE OF A STORAGE BLOCK IS AS IN THE OLD ALLOCATOR,
* I.E. THE WORD BEFORE THE 0'TH WORD OF A BLOCK CONTAINS THE LENGTH
* OF THE BLOCK (NUMBER OF INFORMATION WORDS +1), A FLAG IN BIT 0
* TO SAY THAT THE BLOCK IS FREE, AND A FLAG IN BIT 1 TO SAY THAT
* THE NEXT LOWER BLOCK IS FREE.
        DECLARE FIELD HIDDEN(-1), HSIZE(-1: 6,23), HFREE(-1: 0,0),
        HFTAG(-1: 1,1), HZTAG(-1: 2,2);
* FREE STORAGE COMES IN ZONES.  A ZONE CONSISTS OF A ZONE HEADER
* AND A CHAIN OF EXTENSIONS.  THE ZONE HEADER CONTAINS: THE BLOCK
* SIZE FOR THE ZONE (0 MEANS ALL SIZES ARE ALLOWABLE), THE OVERFLOW
* ROUTINE, THE EXTENSION LIST, AND THE FREE LIST ROVER.
        DECLARE FIELD FEXT(0), FLIST(2), FUEXT(3), FUNCTION FIELD FOVX(1);
       DECLARE PARAMETER FZHS←4;
* THE FEXT WORD IN EACH EXTENSION POINTS TO THE NEXT ONE.  THIS CHAIN,
* IS TERMINATED BY A -1.  THE FIRST TWO WORDS
* OF A FREE BLOCK ARE USED TO HOLD THE ADDRESS OF THE NEXT FREE
* BLOCK AND THE PREVIOUS FREE BLOCK.  THIS LIST IS CIRCULAR.
        DECLARE FIELD NBLK(0),PBLK(1);
* FOR FIXED-SIZE ZONES, THE ENTIRE FREE LIST AND THE HIDDEN WORDS
* ARE SET UP AT THE TIME AN EXTENSION IS CREATED.  FOR VARIABLE-SIZED
* ZONES, AN EXTENSION IS SET UP AS A SINGLE FREE BLOCK WHICH IS
* SUBDIVIDED AS THE NEED ARISES.  A FIRST-FIT STRATEGY WITH A "ROVER"
* IS USED FOR THE LATTER.  BLOCKS BELOW A MINIMUM SIZE WILL NOT BE CREATED.
        DECLARE PARAMETER MINSIZ←3;

        DECLARE INFINITY'ZONE, CURRENT'ZONE;* ZONE VARIABLES FOR ALLOCATOR

       END;

       PROGRAM   STKMAKE; INCLUDE ALLOC'DECS;
       FIXED;
*
* ALLOCATE LOCAL (STACKED) STORAGE
*
        DECLARE   SP=G'[2], SL=G'[3], BLK, SIZE;

        FUNCTION  STKMAKE(SIZE);

        RUNTIME'FAILURE() IF SP + SIZE >= SL;
       SP ← (BLK ← SP + 1) + SIZE;
       BLK.HIDDEN ← SIZE + 1;
       BSET(BLK, 0, SIZE);
       RETURN BLK;

       END;

       PROGRAM MAKE; INCLUDE ALLOC'DECS;
*
* ASSIGN BLOCK OF SIZE (A) IN ZONE (B)
*
        DECLARE BLK,ROVER,RSIZE,EBLK,ROVEC;

        FUNCTION MAKE(SIZE,ZONE);

        ZONE ← CURRENT'ZONE IF ZONE = 0;
       SIZE ← SIZE + 1;
       GOTO MAKEOV IF ZONE.FLIST<0;
* VARIABLE-SIZED ZONE
        ROVEC←ROVER←ZONE.FLIST;
MAKE1: RSIZE←ROVER.HSIZE;
       IF RSIZE<SIZE+MINSIZ AND RSIZE#SIZE DO;
           GOTO MAKE1 IF (ROVER←ROVER.NBLK)#ROVEC
            ELSE GOTO MAKEOV;
       ENDIF;
       EBLK←(BLK←ROVER)+ROVER.HSIZE;
       EBLK.HFTAG←0;
       IF ROVER.HSIZE=SIZE DO;
* EXACT FIT
            BLK.HFREE←0;
           ZONE.FLIST ← RFB(ROVER, ZONE);
       ELSE DO;
* SPLIT THE BLOCK
            BLK←EBLK-SIZE;
           BLK.HIDDEN ← 1 @ HFTAG + SIZE;
           BLK[-2]←-(ROVER.HSIZE←ROVER.HSIZE-SIZE);
       ENDIF;
* COMMON EXIT
        BSET(BLK, 0, SIZE - 1);
       RETURN BLK;

* OVERFLOW
MAKEOV: BLK ← (ZONE.FOVX)(SIZE-1,ZONE); RETURN BLK;

       END;

       PROGRAM RFB; INCLUDE ALLOC'DECS;
       FUNCTION RFB(RBLK, ZONE);
* SUBROUTINE TO REMOVE A BLOCK FROM THE FREELIST
        IF RBLK.NBLK=RBLK DO;
           RETURN ZONE.FLIST←-1;
       ELSE DO;
           RBLK.NBLK.PBLK←RBLK.PBLK;
           RETURN RBLK.PBLK.NBLK←RBLK.NBLK;
       ENDIF;

       END;

       PROGRAM FREE; INCLUDE ALLOC'DECS;
*
* RELEASE BLOCK (A) TO ZONE (B)
*
        DECLARE EXPTR,EFB,PFB;

        FUNCTION FREE(BLK,ZONE);
       EFB←BLK+BLK.HSIZE;
       ZONE ← CURRENT'ZONE IF ZONE = 0;
       BLK.HFREE←1;
* VARIABLE-SIZED ZONE
* CHECK FOR MERGE WITH NEXT HIGHER BLOCK
        IF EFB.HFREE DO;
           BLK.HIDDEN←BLK.HIDDEN+EFB.HSIZE;
           RFB(EFB, ZONE);
           EFB ← BLK + BLK.HSIZE;
       ENDIF;
* CHECK FOR MERGE WITH NEXT LOWER BLOCK
        IF BLK.HFTAG DO;
           PFB←BLK+(BLK[-2] IF BLK[-2]<0 ELSE -3);
           PFB.HIDDEN←PFB.HIDDEN+BLK.HSIZE;
           RFB(BLK ← PFB, ZONE);
       ENDIF;
* CLEAN UP
        EFB.HFTAG←1;
       EFB[-2]←-BLK.HSIZE;
       FPB(BLK, ZONE);
       RETURN;

       END;

       PROGRAM FPB; INCLUDE ALLOC'DECS;
* SUBROUTINE TO PUT A BLOCK ON THE FREELIST
        DECLARE ZFP,ZNBP;

        FUNCTION FPB(BLK, ZONE);
       ZFP←ZONE.FLIST;
       IF ZFP<0 DO;
           ZONE.FLIST←BLK.NBLK←BLK.PBLK←BLK;
       ELSE DO;
           ZNBP←ZFP.NBLK;
           ZFP.NBLK←ZNBP.PBLK←BLK;
           BLK.NBLK←ZNBP;
           BLK.PBLK←ZFP;
       ENDIF;
       RETURN;

       END;

       PROGRAM SELZONE; INCLUDE ALLOC'DECS;

        FUNCTION SELZONE(ZONE);
       CURRENT'ZONE ← ZONE; RETURN;

       END;

       PROGRAM STORINIT; INCLUDE ALLOC'DECS;
*
* SET UP ZONES
*

        FUNCTION STORINIT(ZONE, SIZE), FRETURN;
       (ZONE ← ZONE + 1).HIDDEN ← SIZE;
       SETZONE(ZONE// FRETURN);
       CURRENT'ZONE ← INFINITY'ZONE ← ZONE; RETURN;

       END;

       PROGRAM SETZONE; INCLUDE ALLOC'DECS;
*
* INITIALIZE ZONE
*
        DECLARE FAREA, FUNCTION DUMBFUCN ← OFLOTRAP;

        FUNCTION SETZONE(ZONE), FRETURN;
       FRETURN IF ZONE.HSIZE<FZHS+MINSIZ+4;
       ZONE.HZTAG ← 1;
       ZONE.FOVX ← DUMBFUCN;
       ZONE.FLIST ← -1;
       ZONE.FUEXT ← 0;
       FAREA ← ZONE + (FZHS+1);
       FAREA.HIDDEN←ZONE.HSIZE-(FZHS+1);
       EXTZONE(FAREA, ZONE// VALUE RUNTIME'FAILURE());
       ZONE.FEXT ← -1; RETURN ZONE;

       END;

       PROGRAM EXTZONE; INCLUDE ALLOC'DECS;
*
* ADD EXTENSION (B) TO ZONE (A)
*
        DECLARE EEXT,EXB;

        FUNCTION EXTZONE(EXT, ZONE), FRETURN;
       FRETURN IF EXT.HSIZE<MINSIZ+2;
       EEXT←EXT+EXT.HSIZE;
       EXT.FEXT←ZONE.FEXT;
       ZONE.FEXT←EXT;
       EXB←EXT+2;
       EXB.HIDDEN ← (1@HFREE-3) + EXT.HSIZE;
       (EEXT - 1).HIDDEN ← 1 @ HFTAG;
       FPB(EXB, ZONE);
       RETURN;

       END;

       PROGRAM FREEZONE; INCLUDE ALLOC'DECS;
*
* DELETE ZONE (A)
*
        DECLARE ZEPTR;

        FUNCTION FREEZONE(ZF,ZF1);
       SELZONE(INFINITY'ZONE) IF ZF = CURRENT'ZONE;
FZONE1:ZEPTR←ZF.FEXT; FREE(ZF,ZF1);
       GOTO FZONE1 IF (ZF←ZEPTR)>=0;
       RETURN;

       END;

       COMMON    USERDECS; INCLUDE COMDECS;
*
* DECLARATIONS FOR USER PROGRAMS
*
        ST        OL(NCMCH);* OUTPUT BUFFER FOR USER CONSOLE OUTPUT
       INTARY SP'GSTATE[10],STATE[10];
       INT       QUIT'FLAG;* GLOBAL QUIT FLAG
       PTR       INITIAL'SP ← 3200B, NORMAL'SL ← 3777B,
        STORAGE'AREA ← 400B /* CHANGE FOR PARTICULAR CASES */;
       INT TF;

* OUTPUT MACROS
        MACRO     IOUT() ← SETS(OL, 0,0);
       MACRO     PTCH(C) ← WCI(C, OL);
       MACRO     PTST(S) ← APPEND(OL, S// LF'PUNT);
       MACRO     PTNO(N, F, R) ← CNS(N, OL, F, R// LF'PUNT);
       MACRO     PTDN(N) ← PTNO(N, 4B7, 10);
       MACRO     PTON(N) ← PTNO(N, 4B7, 8);
       MACRO     PTNL() ← WCI(NLCH, OL);
       MACRO     PTIS(S) ← SCOPY(OL, S// LF'PUNT);
       MACRO     PTOL() ← PRINT'STRING(-1,OL,0//QUIT'PUNTX(QT'XIT,OL));

       END;

       PROGRAM   USER'ENTRIES; INCLUDE USERDECS, MACHINE'DECS;
*
* ENTRY POINTS
*
        MACRO SAVE'STATE(X)←.STX X[5],EAX X[0],STORS,MIN TF;
       INT ERMSNO; CHR ERCODE;
       LB R=L'[0];
       PTR SA;

        ARBENT XXXSPT(),SP'ENTRY←0;
       SAVE'STATE(SP'GSTATE);
       ALLOW'INTS();
       SA←@STATE[0]; BCOPY(SA,@SP'GSTATE[0],10);
       RUNTIME'FAILURE() IF TF#1;
       TF←0;
       RUNTIME'FAILURE() IF @R.SP'TNO#23;
       QUIT'FLAG←1;
       SA[LSTLOC]←@R;
       SA[PSTLOC]←@QUITX; .LDA SA,LOADS;
       SET'SPT'FIELD(-1,'TM',1//SF'PUNT);
QUITX: SP'RETURN(//SF'PUNT);
       ARBENT    XXXXXX(), SP'ENTRY ← 2;
       ARBENT    XXXXXY(), SP'ENTRY ← 3;

        .LDA INITIAL'SP, XLA;
       STACK'PTR ← INITIAL'SP; STACK'LIM ← NORMAL'SL;
       STORINIT(STORAGE'AREA, INITIAL'SP-STORAGE'AREA-1// LF'PUNT);
       SET'SPT'FIELD(-1,'TM',1//SF'PUNT);
       TF←QUIT'FLAG←0;
       RUN'USER(); RUNTIME'FAILURE();

       END;

       PROGRAM   FTLERR; INCLUDE USERDECS;
*
* ALLOCATOR ERROR FUNCTIONS
*
        INT       X, Y;
       INT ERMSNO; CHR ERCODE;

        FUNCTION OFLOTRAP(X,Y);
       FUNCTION RUNTIME'FAILURE();
       FUNCTION FTLERR();
       IOUT(); PTST("RUN TIME FAILURE"); PTNL();
       PRINT'STRING(-1,OL,0//LLL:ERCODE,ERMSNO);
LLL:   SP'RETURN(//SF'PUNT);

        END;

       COMMON PROFILE'MAIN; INCLUDE COMDECS;

        MACRO     SF'ERROR ← EREXIT: ERCODE,ERMSNO;


        INT   LUPLM←1,LUPTB←18;
       STARY  UPCMS[LUPLM]←(6"PROFILE-MAINTENANCE");
       STARY  UPCMTB2 [LUPTB ]←(6"CREATE-USER",6"INSTALL-USER",
        6"CREATE-ENTRY",6"EDIT-ENTRY",6"LIST-ENTRY",
        6"LIST-USERS",6"LIST-ITEM",
        6"LIST-NAMES",6"SET-ITEM",
        6"SET-ACCESS",6"CREATE-ITEM",
        6"DELETE-ITEM",6"DELETE-ENTRY",
        6"WRITE-FILE",6"FINISHED",6"HELP",
        6"LIST-PROCESS-PROFILE",6"EDIT-PROCESS-PROFILE");

       STARY HELP[33] ← (

       "CREATE-ENTRY <NAME><TSS#>  ASSUMES THAT A MIB ALREADY EXISTS FOR",
       "                    THE USER AND ONLY ESTABLISHES A PROFILE ENTRY.",
       "CREATE-ITEM <ITEM NAME><ACCESS CODE><TYPE><ITEM VALUE>  CREATES AN",
       "                    ITEM UNDER THE ENTRY IT IS CURRENTLY WORKING ON.",
       "                    ACCESS CODES: 1 MAKES ITEM ACCOUNT READABLE",
       "                                  2 MAKES ITEM USER WRITABLE",
       "                                  4 COPY INTO PROCESS PROFILE",
       "                                  3,5,7 BITWISE COMBINATION",
       "                    TYPE:         0 DECIMAL NUMBER",
       "                                  1 OCTAL NUMBER",
       "                                  6 SIX BIT CHARACTER",
       "                                  8 EIGHT BIT CHARACTER",
       "CREATE-USER <NAME>  CAUSES A MULTIPLE INDEX BLOCK AND A PROFILE",
       "                    ENTRY TO BE CREATED. IF THE NAME IS &"=N&" WHERE",
       "                    N IS A NUMBER, THEN N MIB'S WILL BE CREATED",
       "DELETE-ENTRY        DELETES THE USER ENTRY",
       "DELETE-ITEM <ITEM NAME>  DELETES THE ITEM FROM THE ENTRY",
       "EDIT-ENTRY [<NAME> OR <TSS#>]  ALL COMMANDS FOLLOWING THIS OPERATES",
       "                    ON THE PROFILE ENTRY SPECIFIED BY THE NAME OR",
       "                    TSS# UNTIL ANOTHER &"EDIT-ENTRY&" IS TYPED",
       "EDIT-PROCESS-PROFILE  NOT IMPLEMENTED",
       "INSTALL-USER <TSS#><USER NAME><PASSWORD>  ESTABLISHES A COMPLETE PROFILE",
       "                    ENTRY WITH NORMAL COMMAND && SEARCH LISTS && ACCESS",
       "FINISHED            EXITS PROFILE-MAINTENANCE",
       "LIST-ENTRY          PRINTS ALL INFO IN THE USER ENTRY",
       "LIST-ITEM <ITEM NAME>  PRINTS AOUT THE VALUE OF THE ITEM",
       "LIST-NAMES          PRINTS ALL THE ITEM NAMES IN THE ENTRY",
       "LIST-PROCESS-PROFILE  NOT IMPLEMENTED",
       "LIST-USERS          PRINTS THE ENTIRE USER PROFILE IN TSS# SEQUENCE",
       "SET-ACCESS <ITEM NAME><ACCESS CODE>  SETS THE ACCESS TO THE ITEM",
       "SET-ITEM <ITEM NAME><ACCESS CODE><VALUE1>[<VALUE2..>]  SETS ITEM",
       "                    TO THE NEW VALUE",
       "WRITE-FILE          NOT IMPLEMENTED");

       END;

       PROGRAM PMAIN; INCLUDE PROFILE'MAIN,USERDECS;

        ST  COMLINE(NCMCH:8),NAME'S(70:8),NAME'ST(70:8),USRNM(70:8),ST2(70:8),
        NAME'ST2,ST1,NAME'ST1,NAME'ST3;
       OCTFL     UPUN(0:0,15);
       INT  CHAR,K,LIMIT,NAME,COMFLG,E,P,ERMSNO,ENTNO,I;
       CHR  ERCODE;
       INT   NOFLG,ITEM,CODE,ON,OFF,UNO,PPFLG;
       ST  INP'LINE(20);

        LBARY  UPCMS2 [LUPTB ]←(CR'UP'USR,INST'USR,CR'UP'ENT,EDIT'ENT,LIST'ENT,LIST'USRS,
        LIST'ITM,LIST'NMS,SET'ITM,SET'ACC,CR'ITM,
        DEL'ITM,DEL'ENT,NOT'IMP,FIN,HELP'USR,LIST'PP,EDIT'PP);

***** TEMPORARY UNTIL UPC IS RECOMPILED WITH UPDATED SCOM
        STUC   READ'PP'ITEM ← 71;
       STUC   READ'PP'NAMES ← 72;
       ARBUC  SET'PP'ITEM ← 73;

        ENTRY RUN'USER();

       IOUT(); PTST("PROFILE-MAINT 9.16.77   'HELP' IS AVAILABLE"); PTNL(); PTOL();
        K ← READ'SPT'FIELD(-1,'UAK'//SF'PUNT);
COM'LP:
        NAME'ST1←NAME'S;
       NAME'ST2←NAME'ST;
       READ'LINE(-1,COMLINE,">",QUIT'FLAG:COMLINE//
        QUIT'PUNTX(QT'XIT,COMLINE));
       GOTO  COM'LP IF EMPTY(COMLINE);
       NAME'ST1←GET'PARAM(COMLINE);
       GOTO UPCMS2[ABRV'LKP(NAME'ST1,UPCMTB2//PARERR: ERCODE,ERMSNO)];
EREXIT:IOUT(); OL←ERRORMSG(ERMSNO,OL//SF'PUNT); GOTO LN'OUT;
*CREATE USER OR ENTRY

       /* THIS COMMAND CREATES A NEW USER. IT PROVIDES A CONVENIENT   */
       /* METHOD FOR INSTALLING USERS WITH NORMAL PARAMETERS. FOR UN- */
       /* USUAL INSTANCES REQUIRING DIFFERENT PARAMS, CREATE-ENTRY    */
       /* AND CREATE-ITEM COMMANDS MUST BE USED.                      */
INST'USR:NAME'ST1 ← GET'PARAM(COMLINE);      /* GET USER'S TSS NUMBER */
       IF LENGTH(NAME'ST1) = 0 DO;
           READ'LINE(-1,COMLINE,"USER TSS NUMBER: ",QUIT'FLAG:COMLINE
                     //QUIT'PUNTX(QT'XIT,COMLINE));
           GOTO INST'USR;
       ENDIF;
       E ← CSN(NAME'ST1//PARERR);
       NAME'ST1 ← NAME'S;
       CNS(E,NAME'ST1,0,10//PARERR);    /* RECOVER NAME'ST1 FOR LATER */

       /* CHECK TO SEE IF AN ENTRY IS ALREADY THERE */
       NAME'ST2 ← NAME'ST;
       READ'UP'ITEM('UP',-1,E,USRNM,"N",NAME'ST2,K:NAME'ST2
                    //NOSTAY:ERCODE,ERMSNO);
       IOUT(); PTST("USER "); PTST(NAME'ST2); PTST(" IS ASSIGNED TO ");
       PTST(NAME'ST1); PTNL(); PTOL();
       READ'LINE(-1,INP'LINE,"DELETE OK? ",QUIT'FLAG:INP'LINE
                 //QUIT'PUNTX(QT'XIT,INP'LINE));
       GOTO COM'LP IF GC(INP'LINE) # 'Y';
       DELETE'UP'ENTRY('UP',-1,E,USRNM,K//SF'ERROR);

NOSTAY:NAME'ST3 ← GET'PARAM(COMLINE);            /* GET THE USER NAME */
       IF LENGTH(NAME'ST3) = 0 DO;
           READ'LINE(-1,COMLINE,"USER NAME: ",QUIT'FLAG:COMLINE
                     //QUIT'PUNTX(QT'XIT,COMLINE));
           GOTO NOSTAY;
       ENDIF;
       P ← 1;    /* WE DON'T WANT A MIB CREATED */
       E ← CREATE'UP'ENTRY('UP',-1,E,NAME'ST3,P,K//SF'ERROR);

       SCOPY(NAME'ST3,"P"//LF'PUNT);
       NAME'ST2 ← NAME'ST;
       NAME'ST2 ← GET'PARAM(COMLINE);
PASSWD:IF LENGTH(NAME'ST2) = 0 DO;
           NAME'ST2 ← NAME'ST;
           READ'LINE(-1,NAME'ST2,"PASSWORD: ",QUIT'FLAG:NAME'ST2
                     //QUIT'PUNTX(QT'XIT,NAME'ST2));
           GOTO PASSWD;
       ENDIF;
       NAME'ST2$EP ← NAME'ST2$WP;
       SET'UP'ITEM('UP',-1,E,USRNM,NAME'ST3,NAME'ST2,K//SF'ERROR);
       CODE ← 3;       /* DO NOT COPY INTO PROCESS PROFILE UPON LOGIN */
       SET'UP'ACCESS('UP',-1,E,USRNM,NAME'ST3,CODE,0,K//SF'ERROR);

       /* NOW SET COMMAND SEARCH LIST */
       SCOPY(NAME'ST3,"CSL"//LF'PUNT);
       NAME'ST2 ← NAME'ST;
       SCOPY(NAME'ST2,NAME'ST1//LF'PUNT); /* SCOPY USER'S TSS #       */
       APPEND(NAME'ST2,",3"//LF'PUNT);  /* CSL IS TSS # & SYSTEM 3    */
       NAME'ST2$EP ← NAME'ST2$WP;
       SET'UP'ITEM('UP',-1,E,USRNM,NAME'ST3,NAME'ST2,K//SF'ERROR);
       CODE ← 7;           /* DO COPY INTO PROCESS PROFILE UPON LOGIN */
       SET'UP'ACCESS('UP',-1,E,USRNM,NAME'ST3,CODE,0,K//SF'ERROR);

       /* SET FILE SEARCH LIST */
       SCOPY(NAME'ST3,"FSL"//LF'PUNT);
       NAME'ST2 ← NAME'ST;
       /* USER WILL HAVE FILE ACCESS ONLY TO HIS OWN DIRECTORY        */
       SCOPY(NAME'ST2,NAME'ST1//LF'PUNT);
       NAME'ST2$EP ← NAME'ST2$WP;
       SET'UP'ITEM('UP',-1,E,USRNM,NAME'ST3,NAME'ST2,K//SF'ERROR);
       SET'UP'ACCESS('UP',-1,E,USRNM,NAME'ST3,CODE,0,K//SF'ERROR);
       GOTO COM'LP;

CR'UP'USR:P←0;
       NAME'ST1 ← GET'PARAM(COMLINE);
       GOTO CR'LOOP IF CHAR←GC(NAME'ST1)='=';
       E←0;
CR'UPI:E←NOFLG←CREATE'UP'ENTRY('UP',-1,E,NAME'ST1,P,K//SF'ERROR);
       PPFLG ← 0; GOTO INFORM IF P=0; GOTO COM'LP;
CR'LOOP: GCI(NAME'ST1//WHAT);
       LIMIT←CSN(NAME'ST1,10//WHAT);
       NAME←1;
       WHILE NAME<LIMIT DO;
           SETS(NAME'ST1);
           CNS(NAME+1,NAME'ST1,0,10//WHAT);
           P←E←0;
           NAME←CREATE'UP'ENTRY('UP',-1,E,NAME'ST1,P,K//SF'ERROR);
       ENDFOR;
       GOTO COM'LP;
WHAT:  IOUT(); PTNL(); PTST("  ???"); GOTO LN'OUT;
FIN:   SP'RETURN(//SF'PUNT);
CR'UP'ENT:P←1; NAME'ST1←GET'PARAM(COMLINE);
       NAME'ST2←GET'PARAM(COMLINE);
       E←CSN(NAME'ST2//PARERR);
       GOTO CR'UPI;
NOT'IMP:IOUT(); PTST("SORRY, NOT AVAILABLE AT THIS TIME");
       GOTO LN'OUT;
EDIT'ENT:PPFLG ← 0;
       NAME'ST1 ← GET'PARAM(COMLINE);
       IF GC(NAME'ST1)  >= '0' AND GC(NAME'ST1)  <= '9' DO;
           E ← NOFLG ← CSN(NAME'ST1//PARERR); SETS(USRNM,0,0);
       ELSE DO; NOFLG ← -1; E ← 0;
           SCOPY(USRNM,NAME'ST1//LF'PUNT);
       ENDIF;
       NAME'ST1 ← NAME'ST;
       READ'UP'ITEM('UP',-1,E,USRNM,"#",NAME'ST1,K:NAME'ST1//SF'ERROR);
       GOTO COM'LP;

EDIT'PP:PPFLG ← 1; GOTO COM'LP;
LIST'ENT:GOTO PARERR IF NOFLG = 0;
       E ← 0;
       E ← NOFLG IF NOFLG > 0;
       NAME'ST1 ← NAME'S;
       READ'UP'NAMES('UP',-1,E,USRNM,NAME'ST1,K:NAME'ST1//
        SF'ERROR);


        REPEAT;
           NAME'ST3 ← ST2;
           NAME'ST2 ← GET'PARAM(NAME'ST1);
           GOTO COM'LP IF EMPTY (NAME'ST2);
           READ'UP'ITEM('UP',-1,E,USRNM,NAME'ST2,NAME'ST3,K:NAME'ST3//
            SF'ERROR);

            IF GC(NAME'ST2) = '#' DO;
               UNO ← SBASE(NAME'ST3).UPUN;

                NAME'ST3 ← ST2;
               CNS (UNO,NAME'ST3,0,10//LF'PUNT);
           ENDIF;
           IOUT(); PTST(NAME'ST2); PTST("          "); PTST(NAME'ST3);
           PTNL(); PTOL();
           QUIT'FLAG ← 0;
       ENDRPT; GOTO COM'LP;

LIST'PP:GOTO NOT'IMP;

LIST'USRS:COMFLG ← 1;
          IOUT(); PTST("TSS #     NAME        PASSWORD    CSL   FSL");
       PTNL(); PTOL();
       FOR I ← 1 TO 128 DO;  /* 128 IS THE MAX EXPECTED NUMBER OF USERS */
           NAME'ST1 ← NAME'S;
           READ'UP'NAMES('UP',-1,I,USRNM,NAME'ST1,K:NAME'ST1
                         //CONTINUE: ERCODE, ERMSNO);
           IOUT();
           WHILE 1 DO;
               NAME'ST3 ← ST2;
               NAME'ST2 ← GET'PARAM(NAME'ST1);
               GOTO PRINT IF EMPTY(NAME'ST2);
               READ'UP'ITEM('UP',-1,I,USRNM,NAME'ST2,NAME'ST3,K:NAME'ST3
                            //SF'ERROR);
               IF GC(NAME'ST2) = '#' DO;
                   UNO ← SBASE(NAME'ST3).UPUN;
                   NAME'ST3 ← ST2;
                   CNS(UNO,NAME'ST3,0,10//LF'PUNT);
                   PTCH(' '); PTST(NAME'ST3);
               ELSEIF GC(NAME'ST2) = 'N' DO;
                   WHILE LENGTH(OL) < 6 DO;
                       PTCH(' ');
                   ENDFOR;
                   PTST(NAME'ST3);
               ELSEIF GC(NAME'ST2) = 'P' DO;
                   WHILE LENGTH(OL) < 23 DO;
                       PTCH(' ');
                   ENDFOR;
                   PTST(NAME'ST3);
               ELSEIF GC(NAME'ST2) = 'C' DO;
                   WHILE LENGTH(OL) < 34 DO;
                       PTCH(' ');
                   ENDFOR;
                   PTST(NAME'ST3);
               ELSEIF GC(NAME'ST2) = 'F' DO;
                   WHILE LENGTH(OL) < 41 DO;
                       PTCH(' ');
                   ENDFOR;
                   PTST(NAME'ST3);
               ELSE DO;
                   PTST("    "); PTST(NAME'ST2);
               ENDIF;
           ENDFOR;
PRINT:     PTNL(); PTOL();
           QUIT'FLAG ← 0;
CONTINUE:ENDFOR;
       GOTO COM'LP;

LIST'ITM:NAME'ST1 ← GET'PARAM(COMLINE);
       NAME'ST2 ← NAME'ST;
       GOTO LIST'PPITM IF PPFLG;
       GOTO PARERR IF NOFLG=0;
       IF NOFLG < 0 DO;
           E←0;
       ELSE DO; E ← NOFLG; ENDIF;
       READ'UP'ITEM('UP',-1,E,USRNM,NAME'ST1,NAME'ST2,K:NAME'ST2
        //SF'ERROR);
       IF GC(NAME'ST1) = '#' DO;
           UNO ← SBASE(NAME'ST2).UPUN;
           NAME'ST2 ← ST2;
           CNS ( UNO,NAME'ST2,0,10//LF'PUNT);
       ENDIF;
PRNTT: IOUT();
       PTST(NAME'ST2); GOTO LN'OUT;

LIST'PPITM:READ'PP'ITEM (NAME'ST1,NAME'ST2: NAME'ST2//SF'ERROR);
       GOTO PRNTT;

LIST'NMS:NAME'ST2 ←NAME'ST;
       GOTO LIST'PPNMS IF PPFLG;
       GOTO PARERR IF NOFLG=0;
       IF NOFLG<0 DO;
           E ← 0;
       ELSE DO; E ← NOFLG;
       ENDIF;
       READ'UP'NAMES('UP',-1,E,USRNM,NAME'ST2,K:NAME'ST2
        //SF'ERROR);
       GOTO PRNTT;*NOT GOOD ENOUGH REVISE LATER
LIST'PPNMS:READ'PP'NAMES(NAME'ST2:NAME'ST2//SF'ERROR);
       GOTO PRNTT;

SET'ITM:NAME'ST1 ← GET'PARAM(COMLINE);
       NAME'ST2 ← GET'PARAM(COMLINE);
       NAME'ST2←NAME'ST;
       GET'VALUE(NAME'ST2,COMLINE:NAME'ST2,COMLINE);
       ST1 ← ST2;
       GOTO SET'PPITM IF PPFLG;
       GOTO PARERR IF NOFLG=0;
       IF NOFLG < 0 DO;
           E ← 0;
       ELSE DO; E←NOFLG;
       ENDIF;
       READ'UP'ITEM('UP',-1,E,USRNM,NAME'ST1,ST1,K:ST1
        //SF'ERROR);
       NAME'ST2$EP ← NAME'ST2$WP;
       SET'UP'ITEM('UP',-1,E,USRNM,NAME'ST1,NAME'ST2,K//SF'ERROR);
       GOTO COM'LP;
SET'PPITM:READ'PP'ITEM(NAME'ST1,ST1:ST1//SF'ERROR);
       SET'PP'ITEM(NAME'ST1,NAME'ST2//SF'ERROR);
       GOTO COM'LP;
SET'ACC:GOTO PARERR IF NOFLG=0 OR PPFLG;
       IF NOFLG<0 DO;
           E ← 0;
       ELSE DO; E ← NOFLG;
       ENDIF;
       NAME'ST1 ← GET'PARAM(COMLINE);
       NAME'ST2 ← GET'PARAM(COMLINE);
       CODE←CSN(NAME'ST2//LF'PUNT);
       GOTO PARERR IF CODE < 0 OR CODE > 7;
       ON←CODE;OFF←7-CODE;
       SET'UP'ACCESS('UP',-1,E,USRNM,NAME'ST1,ON,OFF,K//SF'ERROR);
       GOTO COM'LP;
CR'ITM:GOTO PARERR IF NOFLG=0 OR PPFLG;*?* ADD PP CODE
       IF NOFLG < 0 DO;
           E ← 0;
       ELSE DO; E←NOFLG;
       ENDIF;

        NAME'ST1 ← GET'PARAM(COMLINE);*N
       NAME'ST2 ← GET'PARAM(COMLINE);
       CODE←CSN(NAME'ST2//LF'PUNT);
       ST1 ← GET'PARAM(COMLINE);
       ST1←ST2;
*FIND IF ITEM EXISTS

        NAME'ST2 ← NAME'ST;
       GET'VALUE(NAME'ST2,COMLINE:NAME'ST2,COMLINE);
       READ'UP'ITEM('UP',-1,E,USRNM,NAME'ST1,ST1,K:ST1
        //OK:ERCODE,ERMSNO);
       GOTO EREXIT;*?
OK:    NAME'ST2$EP ← NAME'ST2$WP;SET'UP'ITEM('UP',-1,E,USRNM,NAME'ST1,NAME'ST2,K//SF'ERROR);
       SET'UP'ACCESS('UP',-1,E,USRNM,NAME'ST1,CODE,0,K//SF'ERROR);
       GOTO COM'LP;
DEL'ITM:GOTO PARERR IF NOFLG=0;
       IF NOFLG < 0 DO;   E ← 0;   ELSE DO; E ← NOFLG; ENDIF;
       NAME'ST1 ← GET'PARAM(COMLINE);
       SET'UP'ACCESS('UP',-1,E,USRNM,NAME'ST1,ON,-1,K//SF'ERROR);
       GOTO COM'LP;
DEL'ENT:GOTO PARERR IF NOFLG =0;
       E ← 0;
       E←NOFLG IF NOFLG > 0;
       DELETE'UP'ENTRY('UP',-1,E,USRNM,K//SF'ERROR);
       GOTO COM'LP;
HELP'USR:FOR I ← 0 TO 32 DO;
           IOUT(); PTST(HELP[I]); PTNL(); PTOL();
       ENDFOR;
       GOTO COM'LP;

PARERR:IOUT(); PTCH(SQTCH);PTST(NAME'ST1);PTCH(SQTCH);
       PTST(" IS UNRECOGNIZABLE");

LN'OUT: PTNL(); PTOL();
EXIT:  QUIT'FLAG←0; GOTO COM'LP;
QT'XIT:GOTO FIN IF NOT COMFLG;
       QUIT'FLAG←0;
       SET'CIOS'FIELD(-1,'OCC',0//SF'PUNT);
       SET'CIOS'FIELD(-1,'ICC',0//SF'PUNT);
       PRINT'CHAR(-1,NLCH,0//QUIT'PUNT(QT'XIT));
       GOTO COM'LP;

INFORM: IOUT();
       PTNL();
       WCI(' ',OL);
       PTDN(E);
       GOTO LN'OUT;

       END;

       PROGRAM GET'VALUE;
       INCLUDE PROFILE'MAIN;
       ST     STOUT, STIN;
       STENT  GET'VALUE(STOUT, STIN);
LP:    GOTO XIT IF EMPTY(STIN);
       APPEND(STOUT, GET'PARAM(STIN)//XIT);
       WCI(',', STOUT// XIT) & GOTO LP IF NOT EMPTY(STIN);
XIT:   RETURN (STOUT, STIN);

        END;
        PROGRAM MISC'BRSS;
        INCLUDE EMDECS;

         FUNCTION BRS145();
* RETURNS CWS IN A, OCWS IN B, MCWS IN X
         SAVEDA←READ'LWS('CWS'//SYSERR);
        SAVEDB←READ'LWS('OCW'//SYSERR);
        SAVEDX←READ'LWS('MCW'//SYSERR);
        RETURN;

         FUNCTION BRS146();
* SETS OCWS FROM B
         XCH'WS'SIZE(SAVEDB,READ'LWS('ODW'//SYSERR):SAVEDA,SAVEDB);
        RETURN;

        FUNCTION BRS147();
* RETURNS DWS IN A, ODWS IN B, MDWS IN X
        SAVEDA←READ'LWS('DWS'//SYSERR);
        SAVEDB←READ'LWS('ODW'//SYSERR);
        SAVEDX←READ'LWS('MDW'//SYSERR);
        RETURN;

        FUNCTION BRS148();
* SETS ODWS FROM B
        XCH'WS'SIZE(READ'LWS('OCW'//SYSERR),SAVEDB:SAVEDA,SAVEDB);
        RETURN;

        FUNCTION BRS149();
* READS NUMBER OF PAGE FAULTS INTO A
        SAVEDA←READ'PROC'PARAM('PFC'//SYSERR);
        RETURN;

        END;

        PROGRAM MISC'AUX'FNS;
        INCLUDE EMDECS;

        DECLARE INTEGER
            MAX'CWS,
            MAX'DWS,
            NEW'CWS,
            NEW'DWS,
            OLD'CWS,
            OLD'DWS;

        FUNCTION XCH'WS'SIZE(NEW'CWS,NEW'DWS);
* GET MAXIMUM ALLOWABLE SIZES
        MAX'CWS←READ'LWS('MCW'//SYSERR);
        MAX'DWS←READ'LWS('MDW'//SYSERR);
* GET CURRENT SIZES
        OLD'CWS←READ'LWS('OCW'//SYSERR);
        OLD'DWS←READ'LWS('ODW'//SYSERR);
* DO NOTHING IF ARGUMENTS ARE ZERO
        RETURN(OLD'CWS,OLD'DWS) IF NEW'CWS=0 OR NEW'DWS=0;
* LIMIT NEW SIZES TO THE MAXIMA
        NEW'CWS←(NEW'CWS IF NEW'CWS<=MAX'CWS ELSE MAX'CWS);
        NEW'DWS←(NEW'DWS IF NEW'DWS<=MAX'DWS ELSE MAX'DWS);
* REDUCE WORKING SET SIZES IF NECESSARY
        DEL'PAGE'CWS(-1//SYSERR) WHILE NEW'CWS<READ'LWS('CWS'//SYSERR);
        DEL'PAGE'DWS(-1//SYSERR) WHILE NEW'DWS<READ'LWS('DWS'//SYSERR);
* CHANGE OVERFLOW SIZES
        IF NEW'CWS>=OLD'CWS DO;
            SET'LWS('ODW',NEW'DWS//SYSERR);
            SET'LWS('OCW',NEW'CWS//SYSERR);
        ELSE DO;
            SET'LWS('OCW',NEW'CWS//SYSERR);
            SET'LWS('ODW',NEW'DWS//SYSERR);
        ENDIF;
        RETURN(OLD'CWS,OLD'DWS);

        END;

        PROGRAM STRG'COMP'POPS;
        INCLUDE POPVARS;
        SET'LE;
        JUMP'LE;

         ENTRY SKSE'(), DOSYSPOP(63B);
        I←SAVEDB-SAVEDA;
        IF I#SPEA.W1-SPEA.W0 DO;
            POPRET;
        ENDIF;
        IF COMPARE'STRINGS(I,SAVEDA,SPEA.W0)=0 DO;
            SKIP;
        ENDIF;
        POPRET;

         ENTRY SKSG'(), DOSYSPOP(62B);
        I←SAVEDB-SAVEDA; J←SPEA.W1-SPEA.W0; A'LONGER←0;
        IF I>J DO;
            I←J; A'LONGER←1;
        ENDIF;
        J←COMPARE'STRINGS(I,SAVEDA,SPEA.W0);
        IF J>0 OR J=0 AND A'LONGER DO;
            SKIP;
        ENDIF;
        POPRET;
        END;

        PROGRAM TTY'MISC'ECHO;
        INCLUDE EMDECS;
        DI I,J,K;
        MONITOR READ'INFO←211;


         FUNCTION BRS12();
* P7-2,7-7 ARGUMENT:  A=ECHO ROUTINE (0-ALL BREAK, 1-PUNC BREAK,
*                       2-CONTROL BREAK, 3-ALL BREAK AND NO ECHO) OR
*                       4B7+TERMINAL CHAR FOR 8-LEVEL MODE.
*            X=TELETYPE NUMBER
* RESULT:  SET THE BREAK AND ECHO STRATEGIES AND 8-LEVEL MODE
* ACCORDING TO THE ARGUMENTS
         CHECK'TTY'NO(SAVEDX);
        IF SAVEDA$TTY'8LEVEL'FLAG=0 DO;
            SAVEDA←SAVEDA A' 3;
            NEW'ECHO←SAVEDA;
        ELSE DO;
* ENTER 8-LEVEL MODE FOR INPUT.  SET ECHO STRATEGY OFF AND BREAK
* STRATEGY TO NEVER AND QUIT TO THE TERMINATING CHARACTER
             OLD'ECHO←-1;
            SET'ECHO(0,'NEV',1,SAVEDA$ADDR8);
        ENDIF;
        RETURN;

         FUNCTION BRS40();
* P7.2 ARGUMENTS:  X=TELETYPE NUMBER
* RESULT:  A=ARGUMENT TO BRS 12 PLUS BITS FOR 8-LEVEL, AS INDICATED
* IN DECLARATIONS.
         CHECK'TTY'NO(SAVEDX);
        SAVEDA←0;
        IF TTYIN'8 DO;
            SAVEDA$TTY'8LEVEL'FLAG←1;
            SAVEDA$ADDR14←TTYIN'8;
        ELSE DO;
            SAVEDA$ADDR14←NEW'ECHO;
        ENDIF;
        RETURN;

         FUNCTION BRS85();
* P7.7 ARGUMENT:  X=TELETYPE NUMBER
* RESULTS:  SETS TRANSPARENT OUTPUT MODE
         I←1;
BRS856: CHECK'TTY'NO(SAVEDX);
        IF OLD'TRO#I DO;
            SET'CIOS'FIELD(-1,'TRO',I//SYSERR);
            OLD'TRO←I;
        ENDIF;
        TTYOUT'8←I;
        RETURN;

         FUNCTION BRS86();
* P7.7 ARGUMENT:  X=TELETYPE NUMBER
* RESULTS:  CLEARS TRANSPARENT OUTPUT MODE
         I←0; GOTO BRS856;

         FUNCTION BRS123();
* P13.2 ARGUMENT:  X=TELETYPE NUMBER
* RESULT:  A=USER NUMBER, B=729, X=TELETYPE NUMBER
         CHECK'TTY'NO(SAVEDX);
        SAVEDA←READ'INFO('UNO'//SYSERR);
        SAVEDB←READ'INFO('PRT'//SYSERR);
        SAVEDX←READ'INFO('TNO'//SYSERR);
        RETURN;

         FUNCTION SET'ECHO'MODE(EM);
        IF OLD'ECHO#EM DO;
            SET'ECHO(EM#3,BWS'TABLE[EM],0,QUIT'CHAR);
            OLD'ECHO←EM;
        ENDIF;
        RETURN;
        FUNCTION SET'ECHO(EST,BWS,TRI,QIT);
        IF OLD'EST#EST DO;
            SET'CIOS'FIELD(-1,'EST',EST//SYSERR);
            OLD'EST←EST;
        ENDIF;
        IF OLD'BWS#BWS DO;
            SET'CIOS'FIELD(-1,'BWS',BWS//SYSERR);
            OLD'BWS←BWS;
        ENDIF;
        IF OLD'TRI#TRI DO;
            SET'CIOS'FIELD(-1,'TRI',TRI//SYSERR);
            OLD'TRI←TRI;
        ENDIF;
        IF OLD'TRO#0 DO;
            SET'CIOS'FIELD(-1,'TRO',0//SYSERR);
            OLD'TRO←0;
        ENDIF;
*   IF OLD'QIT#QIT DO;
*FIX    SET'CIOS'FIELD(-1,'QIT',QIT//SYSERR);
*      OLD'QIT←QIT;
*   ENDIF;
         TTYOUT'8←0;
        TTYIN'8←(0 IF TRI=0 ELSE QIT);
        RETURN;
        END;

        PROGRAM SB'AUX'FCNS;
        INCLUDE EMDECS;
        DI I,J,K,L,M,N,STRING S1;


         STRING FUNCTION APPEND'CHAR(S1,I);
* THIS FUNCTION READS A CHARACTER FROM DF'INPUT AND APPENDS IT TO S1.
* IT ALSO INCREMENTS I.W1. IT RETURNS S1. TRAP IF S1 OVERFLOWS
         J←CHAR'READ(DF'INPUT);
        WCI(J,S1// VALUE TRAP); I.W1←I.W1+1;
        RETURN S1;

         FUNCTION WRITE'STRING(STRING S1);
* WRITES A STRING ONTO FILE DF'OUTPUT
W'S:     CHAR'WRITE(GCI(S1// RETURN),DF'OUTPUT); QUIT() IF QUIT'FLAG#0; GOTO W'S;

         FUNCTION COMPARE'STRINGS(L,M,N);
        FOR I←1 TO L DO;
            J←M+I; MAKE'STRING'IAW(J,J);
            K←N+I; MAKE'STRING'IAW(K,K);
            J←(J←$J)-$K;
            RETURN J IF J#0;
        ENDFOR;
        RETURN 0;
        END;

        PROGRAM NAMING'BRSS;
        INCLUDE EMDECS;
        DI I,J,T,F,DO'SCP;
        DF MAY'SET'READ(0:7,7);
        DF MAY'DO'SCP(0:2,2),R'FILE'BITS(0:0,7);
        DF BIT'1(0:1,1),TYPE'940(0:21,23);

         FUNCTION BRS15();
* P12.6 SEE THE DISCUSSION THERE, EXCEPT THAT BIT 2 OF A IS IGNORED
         T←COLLECT'NAME(0// RETURN);
BRS1518:I←READ'ACCESS;
BRS15689:IF SAVEDA$DONT'OPEN=0 DO;
            IF T<0 DO;
                F←OPEN'940'FILE(I// RETURN);
                T←F.FILE'LENGTH;
            ELSE DO;
                SAVEDA←T;
                T←0;
            ENDIF;
        ELSE DO;
            T←0;
        ENDIF;
        FOR I←7,I-1 WHILE I>0 AND TYPE'NAME[I]#(MIB'ADDRESS.MIB'TYPE) DO;
        ENDFOR;
        SAVEDX←NON'SEQ'MEDIUM+I@FILE'TYPE+T;
        SKIP; RETURN;

         FUNCTION BRS16();
* P12.9 SEE THE DISCUSSION THERE, EXCEPT THAT BITS 0 AND 2 ARE IGNORED.
         MIB'ADDRESS.MIB'TYPE←TYPE'NAME[SAVEDA$FILE'TYPE];
        T←COLLECT'NAME(1// RETURN);
BRS1619:I←(RW'ACCESS IF SAVEDA$RANDOM'FILE ELSE WRITE'ACCESS);
        GOTO BRS15689;

         FUNCTION BRS18();
        T←COLLECT'SCRATCHN(0// RETURN); GOTO BRS1518;

         FUNCTION BRS19();
        MIB'ADDRESS.MIB'TYPE←0;
        T←COLLECT'SCRATCHN(1// RETURN); GOTO BRS1619;

         FUNCTION BRS63();
        T←COLLECT'NAME(0// RETURN);
BRS6365:DELETE'FILE(MIB'OBJECT'NAME,-1//SYSERR);
        SKIP; RETURN;

         FUNCTION BRS65();
        T←COLLECT'SCRATCHN(1// RETURN);
        GOTO BRS6365;

         FUNCTION BRS60();
* THIS OPERATION IS NOT IMPLEMENTED
         TRAP;

         FUNCTION BRS48();
* THIS OPERATION IS NOT IMPLEMENTED
         TRAP;
        FUNCTION BRS92();
* TYMESHARE FILE-OPENING BRS: OPEN FOR INPUT, GET NAME FROM SPEC. FILE.
        SAVEDB←0;
BRS924: I←READ'ACCESS;
        J←0;
        DO'SCP←1 IF (DO'SCP←SAVEDA$MAY'DO'SCP OR SAVEDA$MAY'SET'READ)=0;
BRS923: SAVEDX←SAVEDA$ADDR14;
        IF T←COLLECT'NAME(J//RETURN)<0 DO;
           F←OPEN'940'FILE(I//RETURN);
           T←F.FILE'LENGTH;
           F.POS'OK←DO'SCP;
        ELSE DO;
           SAVEDA←T;
           T←0;
        ENDIF;
        FOR I←7,I-1 WHILE I>0 AND TYPE'NAME[I]#(MIB'ADDRESS.MIB'TYPE) DO;
        ENDFOR;
        SAVEDB←I;
        SAVEDX←T*3;
        SKIP; RETURN;

        FUNCTION BRS93();
* TYMESHARE FILE-OPENING BRS: OPEN FOR OUTPUT, GET NAME FROM SPEC. FILE.
        SAVEDB←0;
BRS935: MIB'ADDRESS.MIB'TYPE←TYPE'NAME[SAVEDX$TYPE'940];
        I←(RW'ACCESS IF SAVEDA$R'FILE'BITS ELSE WRITE'ACCESS);
        J←1;
        DO'SCP←SAVEDA$MAY'DO'SCP;
        GOTO BRS923;

        FUNCTION BRS94();
* TYMESHARE FILE-OPENING BRS: OPEN FOR INPUT, GET NAME FROM STRING.
        SAVEDB$BIT'1←1;
        GOTO BRS924;

        FUNCTION BRS95();
* TYMESHARE FILE-OPENING BRS: OPEN FOR OUTPUT, GET NAME FROM STRING.
        SAVEDB$BIT'1←1;
        GOTO BRS935;

        END;

        PROGRAM NAMING'AUX'FCNS;
        INCLUDE EMDECS;
        DI I,F,KEY,TYPE,ACC,ARRAY MIB'VALUE[8];

         FUNCTION OPEN'940'FILE(ACCESS), FRETURN;
* OBTAINS A FILE TABLE ENTRY AND SETS IT UP FOR THE FILE WHOSE MONITOR
* MIB NAME IS MIB'OBJECT'NAME.  OPENS THE FILE WITH THE SPECIFIED
* ACCESS USING A UTILITY CALL WHICH FOLLOWS     .  FAILS WITH -2 IN
* SAVEDX IF THERE IS NO MORE ROOM IN FILE'TABLE.  RETURNS THE ADDRESS
* OF THE FILE TABLE ENTRY AND LEAVES THE 940 FILE NUMBER IN SAVEDA.
         FOR I←MIN'FILE TO MAX'FILE DO;
            F←@FILE'TABLE[I];
            IF F.FT'ENTRY'ACTIVE=0 DO;
* GOT OFT ENTRY.  OPEN THE FILE
                 OPEN'FILE'FCN(F,ACCESS,I// FRETURN);
                SAVEDA←I;
                RETURN F;
            ENDIF;
        ENDFOR;
* NO ROOM IN OFT
         SAVEDX←-2;
        FRETURN;

         FUNCTION OPEN'FILE'FCN(F,ACCESS,I), FRETURN;
OPEN:   F.M1'FILE'NO←OPEN'FILE(-1,MIB'OBJECT'NAME,
        'RO' IF ACCESS=READ'ACCESS ELSE 'RW',-1//CHECK:ERRSPEC);
        IF F=@NRH'FT'ENTRY[0] DO;
            FOR I←0 TO NO'NRH'BUFS DO;
                NPPMT(NRH'BUF'BYTE[I]←ACQPMT(-1//SYSERR)//SYSERR);
                SET'MAP'BYTE(-1,NRH'BUF'BASE+I,NRH'BUF'BYTE[I]//SYSERR);
                NRH'PAGE'IN'BUF[I]←-1;
            ENDFOR;
            NEXT'NRH'BUF←NO'NRH'BUFS;
            F.BUFFER'BYTE←NRH'BUF'BYTE[0];
        ELSE DO;
            NPPMT(F.BUFFER'BYTE←ACQPMT(-1//SYSERR)//SYSERR);
            F.BUFFER'PAGE←BUFFER'BASE-MIN'FILE+I;
            SET'MAP'BYTE(-1,F.BUFFER'PAGE,F.BUFFER'BYTE//SYSERR);
        ENDIF;
        F.SEQ'PTR←F.END'SEQ'PTR←ZERO'24STR'IAW;
        F.PAGE'IN'BUFFER←-1;
        CONV'NAME(MIB'OBJECT'NAME,MIB'VALUE,-1:KEY,TYPE,ACC//SYSERR);
        READ'MIBOB'VALUE(MIB'VALUE,1,MIB'VALUE,2,KEY//SYSERR);
* CONVERT FROM M1 LENGTH TO 940 LENGTH
         I←MIB'VALUE[2]-4000B+1;
        F.FILE'LENGTH←(0 IF I<0 ELSE I);
        F.IS'INPUT'FILE←(ACCESS=READ'ACCESS);
        F.IS'OUTPUT'FILE←(ACCESS#READ'ACCESS);
        READ'OFT'ENTRY(F.M1'FILE'NO,MIB'VALUE//SYSERR);
        F.FILE'RW'CAPS←MIB'VALUE[0]$OFT'RW'BITS;
        F.POS'OK←(ACCESS#WRITE'ACCESS);
        F.FT'ENTRY'ACTIVE←1;
        RETURN;
CHECK:  IF ERRCODE='NAE' AND MIB'OBJECT'NAME[2]#0 DO;
            MIB'OBJECT'NAME[2]←0;
            GOTO OPEN;
        ENDIF;
        FRETURN;
        END;

        PROGRAM LECCOM;
        INCLUDE EMDECS;
        DI REWRITE'NAME,SP940,I,CT,STRING S1(40),S2,S3;
        DECLARE ARRAY FILE'NAME'CHARS[4]←(034045B,177743B,177777B,177740B);
        DF FNCW(0:16,19),FNCB(0:20,23),NO'TERM'CHAR(0:2,2);
        DF ADDR16(0:8,23),BIT'1(0:1,1);

         FUNCTION COLLECT'NAME(NEW'NAME'OK), FRETURN;
* TAKES THE STATE DELIVERED BY 940 SYSTEM CALLS WHICH PASS A FILE-NAME
* AS PARAMETER AND CALLS THE UTILITY TO COLLECT THE REST OF THE NAME.
* PASSES THE COMPLETED NAME BACK TO THE 940 PROGRAM AND RETURNS THE
* MONITOR NAME FOR THE FILE IN MIB'OBJECT'NAME.  FAILS IF NO FILE IS
* FOUND CORRESPONDING TO THE NAME, LEAVING THE ERROR CODE (1) IN
* SAVEDX.  LEAVES 0 WITH A MESSAGE ON ANY OTHER SYSTEM ERROR.
         REWRITE'NAME←0;
        SETUP'DUAL'FILE(SAVEDX);
        IF SAVEDB#0 DO;
* SETUP STRING FOR FILE NAME ACCORDING TO INFORMATION PROVIDED BY THE
* USER
           IF SAVEDB$BIT'1=0 DO;
* USE BERKELEY CONVENTION UNLESS THIS BIT IS SET.  THEN USE TYMESHARE'S.
              SP940←SAVEDB$ADDR14; SP940.W1←SP940.W0 IF SAVEDB<0;
              S2←C940SP(SP940.W0,SP940.W1);
           ELSE DO;            * TYMESHARE CASE: SP IN AB
              S2←C940SP(SAVEDA$ADDR16,SAVEDB$ADDR16);
           ENDIF;
        ELSE DO;
            SETS(S1); S2←S1;
        ENDIF;
* COLLECT FILE NAME BY READING CHARACTERS UNTIL SOMETHING TURNS UP
* WHICH IS NOT A LEGITIMATE PART OF A FILE NAME.  LEGITIMATE
* CHARACTERS ARE LETTERS, DIGITS,>,#,:,@,-,$,*,/,?,".
* THE TERMINATOR IS LEFT IN SAVEDB.
         SAVE'ECHO←NEW'ECHO;
        I←GCD(S2// VALUE -1); WCI(I,S2// VALUE TRAP) IF I>=0;
        IF I='"' DO;
        ELSEIF SAVEDX=-1 OR (SAVEDB#0 AND SAVEDA$NO'TERM'CHAR) DO;
            IF NEW'NAME'OK DO;
                COPY'USER(S1,S2:S1,S2//BADNAME);
                WCI('"',S1//BADNAME);
                APPEND(S1,S2//BADNAME);
                WCI('"',S1//BADNAME);
                S2←S1;
            ENDIF;
        ELSE DO;
            CT←0;
            NEW'ECHO←0 IF DF'INPUT=0;
GETNAME'LOOP:I←CHAR'READ(DF'INPUT);
            IF I='A'+100B DO;
                IF CT<=0 DO;
                    CHAR'WRITE('G'+100B,DF'OUTPUT);
                ELSE DO;
                    CT←CT-1;
                    CHAR'WRITE('↑',DF'OUTPUT);
                    GCD(S2// VALUE -1);
                ENDIF;
            ELSEIF I='Q'+100B DO;
                CHAR'WRITE('←',DF'OUTPUT);
                FOR I←1 TO CT DO;
                    GCD(S2// VALUE -1);
                ENDFOR;
                CT←0;
            ELSEIF I$FNCW<4 AND FILE'NAME'CHARS[I$FNCW] LSH (8+I$FNCB)<0 DO;
                CT←CT+1;
                WCI(I,S2//BADNAME);
            ELSE DO;
                SP940.W1←SP940.W1+CT IF SAVEDB;
                REWRITE'NAME←SAVEDB;
* NAME IS FULLY COLLECTED
                 SAVEDB←I; GOTO GOTNAME;
            ENDIF;
            GOTO GETNAME'LOOP;
        ENDIF;
* NOW PASS THE NAME ON TO THE UTILITY
GOTNAME: S3←S2;
        I←LENGTH(S3);
        IF (I=2 OR (I=4 AND GCI(S3//FINDNAME)='"' AND
         GCD(S3//FINDNAME)='"'))
         AND GCI(S3//FINDNAME)='*' DO;
            IF (I←GCI(S3//FINDNAME))='T' DO;
                RETURN (1 IF NEW'NAME'OK ELSE 0);
            ELSEIF I='N' DO;
                RETURN 2;
            ENDIF;
        ENDIF;
FINDNAME:S3←S2;
        IF GCD(S3// VALUE 0)='"' DO;
            REWRITE'NAME←0;
        ELSE DO;
            NEW'NAME'OK←0;
        ENDIF;
        NAME'SEARCH(S2,MIB'OBJECT'NAME,NEW'NAME'OK,
         (MIB'ADDRESS.MIB'TYPE)$W0 IF NEW'NAME'OK ELSE 0,-1//NO'NAME:ERRSPEC);
        IF REWRITE'NAME DO;
            COPY'USER(S1,S2:S1,S2//BADNAME);
            SETS(MIB'NAME'STRING,0,16);
            WCI(I,S1//BADNAME) WHILE (I←GCI(MIB'NAME'STRING// VALUE 0))#0;
            WHILE GCI(S2//DO'REWRITE)#':' DO; ENDFOR;
            WCI(':',S1//BADNAME);
            APPEND(S1,S2//BADNAME);
DO'REWRITE: SETS(S2);
            SCOPY(S2,S1//BADNAME);
            SP940.W1←SP940.W0+LENGTH(S2);
        ENDIF;
        NEW'ECHO←SAVE'ECHO; SAVE'ECHO←-1; RETURN -1;
* TREAT ALL ERRORS AS BADNAMES FOR THE MOMENT
NO'NAME: GOTO BADNAME;
* NAME WAS NOT SUCCESSFULLY RECOGNIZED.  REPORT THE ERROR
BADNAME: NEW'ECHO←SAVE'ECHO; SAVE'ECHO←-1; SAVEDX←1; FRETURN;

         FUNCTION COLLECT'SCRATCHN(NEW'NAME'OK);
* DOES THE WORK OF COLLECT'NAME FOR A NAME '/III/'.
         REWRITE'NAME←0;
        SAVE'ECHO←NEW'ECHO;
        SETS(S1); S2←S1;
        WCI('"',S2); WCI('/',S2); WCI(SAVEDX/100+'0',S2);
        WCI((SAVEDX/10) MOD 10 +'0',S2); WCI(SAVEDX MOD 10 +'0',S2);
        WCI('/',S2); WCI('"',S2);
        GOTO FINDNAME;
        END;

        PROGRAM LECCOM'AUX'FCNS2;
        INCLUDE EMDECS;

         DECLARE STRING S1;
        DI I;

         FUNCTION COPY'USER(STRING NEW'NAME, OLD'NAME), FRETURN;
        SETS(NEW'NAME);
        S1←OLD'NAME;
        I←GCI(S1//EXIT'COPY);
        IF I='@' OR I='#' DO;
COPY'ANOTHER:I←GCI(OLD'NAME// FRETURN);
            WCI(I,NEW'NAME// FRETURN);
            GOTO COPY'ANOTHER IF I#':';
        ENDIF;
EXIT'COPY:RETURN (NEW'NAME,OLD'NAME);
        END;

        PROGRAM FLTNG'OPNS;
        INCLUDE POPVARS;
        SET'LE;
        JUMP'LE;

* FLOATING ADDITION
        ENTRY FAD(), DOSYSPOP(56B);
        IJ←$SPEA;
        FL'ADDN(SAVEDAB,IJ,SAVEDSR:SAVEDAB,SAVEDSR);
POP'RETURN: POPRET;

        ENTRY FFAD(), DOSYSPOP(52B);
* THIS IS A TYMESHARE SYSPOP
        IJ←$SPEA;
        FL'ADDN(FL'ACC,IJ,SAVEDSR:FL'ACC,SAVEDSR);
        GOTO POP'RETURN;

* FLOATING SUBTRACTION
        ENTRY FSB(), DOSYSPOP(55B);
        IJ←$SPEA;
        FL'SUBN(SAVEDAB,IJ,SAVEDSR:SAVEDAB,SAVEDSR);
        GOTO POP'RETURN;

        ENTRY FFSB(), DOSYSPOP(06B);
* THIS IS A TYMESHARE SYSPOP
        IJ←$SPEA;
        FL'SUBN(FL'ACC,IJ,SAVEDSR:FL'ACC,SAVEDSR);
        GOTO POP'RETURN;

        ENTRY FFSI(), DOSYSPOP(07B);
* THIS IS A TYMESHARE SYSPOP
        GH←$SPEA;
        FL'SUBN(GH,FL'ACC,SAVEDSR:FL'ACC,SAVEDSR);
        GOTO POP'RETURN;

* FLOATING MULTIPLICATION
        ENTRY FMP(), DOSYSPOP(54B);
        IJ←$SPEA;
        FL'MPCN(SAVEDAB,IJ,SAVEDSR:SAVEDAB,SAVEDSR);
        GOTO POP'RETURN;

        ENTRY FFMP(), DOSYSPOP(72B);
* THIS IS A TYMESHARE SYSPOP
        IJ←$SPEA;
        FL'MPCN(FL'ACC,IJ,SAVEDSR:FL'ACC,SAVEDSR);
        GOTO POP'RETURN;

* FLOATING DIVISION
        ENTRY FDV(), DOSYSPOP(53B);
        IJ←$SPEA;
        FL'DVSN(SAVEDAB,IJ,SAVEDSR:SAVEDAB,SAVEDSR);
        GOTO POP'RETURN;

        ENTRY FFDV(), DOSYSPOP(46B);
* THIS IS A TYMESHARE SYSPOP
        IJ←$SPEA;
        FL'DVSN(FL'ACC,IJ,SAVEDSR:FL'ACC,SAVEDSR);
        GOTO POP'RETURN;

        ENTRY FFDI(), DOSYSPOP(47B);
* THIS IS A TYMESHARE SYSPOP
        GH←$SPEA;
        FL'DVSN(GH,FL'ACC,SAVEDSR:FL'ACC,SAVEDSR);
        GOTO POP'RETURN;

* FLOATING LOAD AND STORE
        ENTRY LDFM(), DOSYSPOP(27B);
* THIS IS A TYMESHARE SYSPOP
        SAVEDAB←FL'ACC←$SPEA;
        GOTO POP'RETURN;

        ENTRY STFM(), DOSYSPOP(30B);
* THIS IS A TYMESHARE SYSPOP
        $SPEA←SAVEDAB←FL'ACC;
        GOTO POP'RETURN;

        END;

        PROGRAM FLOATING'FCNS;
        INCLUDE POPVARS;
        DI STATUS;

* FLOATING ADDITION
        FUNCTION FL'ADDN(GH,IJ,STATUS);
        RETURN (IJ,STATUS) IF G=0 ELSE RETURN (GH,STATUS) IF I=0;
        ZE←J$EXPT-H$EXPT;
        IF ZE<0 DO;
           ZE←-48 IF ZE<-48;
           .LDD IJ, ASHD ZE, XAB, ETR -1000B;
           .ADD H, XAB, ADC G;
        ELSE DO;
           ZE←48 IF ZE>48;
           ZE←-ZE;
           .LDD GH, ASHD ZE, XAB, ETR -1000B;
           .ADD J, XAB, ADC I;
        ENDIF;
        .STB K;
FADST:  .TSB TOV'BIT, BNE FADOF, STD IJ;
FADOR:  J$EXPT←0;
        .LDD IJ, LLT, ADX -1, STX ZE;
        .CPZ ZE, BLT FZERO, ASHD ZE, STD GH;
        H$EXPT←K←K$EXPT-ZE;
        GOTO FZERO IF K<-400B;
        RETURN (GH,STATUS);
FADOF:  .ASHD -1, EOR 4B7, STD IJ;
        K←K$EXPT+1;
        GOTO FADOR IF K<400B ELSE GOTO FDVO;

* FLOATING SUBTRACTION
        FUNCTION FL'SUBN(GH,IJ,STATUS);
        H←400B IF G=0;
        RETURN (GH,STATUS) IF I=0;
        ZE←J$EXPT-H$EXPT;
        IF ZE<0 DO;
           ZE←-48 IF ZE<-48;
           K←H;
           .LDD IJ, ASHD ZE, XAB, ETR -1000B;
           .XMA H, SUB H, XAB, XMA G, SUC G;
        ELSE DO;
           ZE←48 IF ZE>48;
           ZE←-ZE;
           K←J;
           .LDD GH, ASHD ZE, XAB, IOR 777B;
           .SUB J, XAB, SUC I;
        ENDIF;
        GOTO FADST;

* FLOATING MULTIPLICATION
        FUNCTION FL'MPCN(GH,IJ,STATUS);
        ZE ← H$EXPT+J$EXPT;
        .LDA H, ETR -1000B, LSHA -2, MUL I, STA ZM;
        .LDA J, ETR -1000B, IOR 400B, LSHA -2, MUL G;
        .ADD ZM, MUL 2, STB ZM;
        .XMA G, MUL I, XAB, ADD ZM, XAB, ADC G;
        .STD GH, CMZ 37777777B, BNE FLEND;
        .LDA H, ETR -1000B, BNE FLEND;
        .CPZ G, BNE FMP4B7;
FZERO:  RETURN (LONGZERO,STATUS);
FMP4B7: .LDD GH, ASHD -1, STD GH, MIN ZE;
* FLOATING POINT CLEANUP.  FRACTION IN GH, GARBAGE IN EXPT
* ACTUAL EXPONENT IN ZE
FLEND:   H$EXPT ← 0;
        .LDD GH, LLT, ADX -1, STX ZM;
        .ASHD ZM, STD GH, LDA ZE, SUB ZM, STA ZE;
        .ADD 400B, CMZ -1000B, BNE FOFL;
        H$EXPT ← ZE;
        RETURN (GH,STATUS);

* FLOATING OVERFLOW OR UNDERFLOW
FOFL:    .BLT FZERO;
FDVO:   RETURN(HUGE,SAVEDSR V' OV'BIT);

* FLOATING DIVISION
        FUNCTION FL'DVSN(GH,IJ,STATUS);
        ZE ← H$EXPT-J$EXPT+2;
        .LDD GH, ASHD -11, ASHD 9;
        .DIV I, TSB TOV'BIT, BNE FDVO;
        .STA ZM, LSHD 24, ASHD -1, STA G;
        .LDA J, ETR -1000B, ZOB, CYD -2, CNA,
         MUL ZM, ADD G, DIV I, MUL 2, ADD ZM,
         STD GH, BNE FLEND;
        RETURN (GH,STATUS);
        END;

        PROGRAM FLOATING'BRSS;
        INCLUDE POPVARS;

* FLOATING NEGATE BRS
         FUNCTION BRS21();
        ZE←SAVEDB$EXPT; SAVEDB$EXPT←0;
        .LDD SAVEDAB, XAB, EOR -1, ADD 1;
        .XAB, EOR -1, ADC 0, STD SAVEDAB;
        .ICP 4B7, BEQ BRS21B;
        .ICP 6B7, BEQ BRS21C;
BRS21A: SAVEDB$EXPT←ZE; RETURN;
BRS21B: .CPZ SAVEDB, BNE BRS21A;
        SAVEDA←2B7; ZE←ZE+1;
        GOTO BRS21A IF ZE<=255;
        SAVEDAB←HUGE;
        SAVEDSR←SAVEDSR V' OV'BIT;
        RETURN;
BRS21C: .CPZ SAVEDB, BNE BRS21A;
        SAVEDA←4B7; ZE←ZE-1;
        GOTO BRS21A IF ZE>=-256;
        SAVEDAB←LONGZERO;
        RETURN;

* FIX A FLOATING POINT NUMBER.  PLACES BINARY POINT BETWEEN A AND B.
         FUNCTION BRS50();
        ZE←SAVEDB$EXPT-23; SAVEDB$EXPT←0;
        .LDD SAVEDAB, ASHD ZE, STD SAVEDAB;
        RETURN;

* FLOAT AN INTEGER IN A.
         FUNCTION BRS51();
        .LDA SAVEDA, ZOB, ASHD -15;
        .LLT, ADX -1, STX ZM;
        .ASHD ZM, STD SAVEDAB, LDA 38, SUB ZM, STA ZE;
        IF SAVEDA=0 DO;
            SAVEDAB←LONGZERO;
        ELSE DO;
            SAVEDB$EXPT←ZE;
        ENDIF;
        RETURN;

         FUNCTION BRS52();
        TRAP;

         FUNCTION BRS53();
        TRAP;


        END;

        PROGRAM HASH'BRSS;
        INCLUDE EMDECS;
        DECLARE STRING S2,S3,INTEGER HASH'CODE,I,J,K,L,M,N,START'TABLE,
         END'TABLE,S1;

         FUNCTION BRS5();
* P14.4 ARGUMENTS:  AB=STRING POINTER, X=ADDRESS OF HASH TABLE
* DESCRIPTOR
* RESULT:  IF STRING IS FOUND IN TABLE, SKIP RETURN WITH
* A=VALUE, B=ADDRESS IN TABLE.  OTHERWISE NO SKIP AND NO CHANGE.
         I←SAVEDX$ADDR14; START'TABLE←I.ADDR14;
        END'TABLE←I.W1$ADDR14;
        S2←C940SP(SAVEDA,SAVEDB); S1←SAVEDB-SAVEDA;
* COMPUTE HASH CODE; (8*LENGTH+FIRST 12 BITS OF STRING+SECOND 12 BITS OF
* STRING+LAST 12 BITS+NEXT-TO-LAST 12 BITS) MOD TABLE LENGTH,
* THEN DECREASE TO AN EVEN MULTIPLE OF 3
         HASH'CODE←S1 LSH 3;
        SETUP(S3,3,@J);
L1:     WCI(GCI(S2// VALUE 0),S3//L2); GOTO L1;
L2:     HASH'CODE←HASH'CODE+(J$FIRST'HALF+J$SECOND'HALF);
        SETW(S3); SETR(S2);
L3:     WCD(GCD(S2// VALUE 0),S3//L4); GOTO L3;
L4:     HASH'CODE←HASH'CODE+(J$FIRST'HALF+J$SECOND'HALF);
        HASH'CODE←HASH'CODE MOD (END'TABLE-START'TABLE);
        HASH'CODE←((HASH'CODE/3)*3+START'TABLE)$ADDR14;
* NOW SEARCH THE TABLE FOR A MATCH OR EMPTY (0) WORD OR LOOP
         N←K←-1;
        FOR J←HASH'CODE,K WHILE K#HASH'CODE DO;
            K←J+3; K←START'TABLE IF K>=END'TABLE;
* CHECK FOR EMPTY ENTRY
             IF $J=0 DO;
* YES
                 I[2]←(J IF N=-1 ELSE N); RETURN;
* NO. CHECK FOR DELETED ENTRY
             ELSEIF $J=-1 DO;
                N←J IF N=-1;
            ELSE DO;
                L←J.SPTR'940;
                IF S1=J.SPTR'940'1-L DO;
                    GOTO L5 IF COMPARE'STRINGS(S1,SAVEDA,L)=0;
                ENDIF;
            ENDIF;
        ENDFOR;
* CYCLED AROUND TABLE
         I[2]←N; RETURN;
* FOUND ENTRY
L5:      SAVEDB←J; SAVEDA←J[2]; SKIP; RETURN;

         FUNCTION BRS6();
* P14.5 ARGUMENTS:  AS FOR BRS5
* RESULT: INSERTS STRING IN TABLE
         I←SAVEDX$ADDR14;
        TRAP IF I[2]=-1; I←I[2]$ADDR14;
        I.W0←SAVEDA; I.W1←SAVEDB; SAVEDA←I[2];
        SAVEDB←I;
        RETURN;
        END;

        PROGRAM XBRS37'SCAN;
        INCLUDE EMDECS;
        DI I,J,K,L;

         FUNCTION BRS37'SCAN (START'TABLE,END'TABLE,STRING S1), FRETURN;
* THIS FUNCTION SCANS THE TABLE WHICH STARTS AT START'TABLE AND
* ENDS AT END'TABLE. IT LOOKS FOR AN ENTRY WHOSE HEAD MATCHES S1. IF
* NO SUCH ENTRY EXISTS, THE FUNCTION FRETURNS. OTHERWISE IT RETURNS THE
* ADDRESS OF THE ENTRY AND A FLAG WHICH IS ON IF THE ENTRY MATCHES S1
* EXACTLY.
         L←LENGTH(S1);
        FOR I←START'TABLE BY 3 TO END'TABLE-1 DO;
            IF I.W0#0 AND (K←I.SPTR'940'1-I.SPTR'940)>=L DO;
* ENTRY IS NOT EMPTY AND ITS LENGTH IS AT LEAST THAT OF S1
                 J←I.SPTR'940;
                GOTO BRS37'SCAN'MATCH IF
                 COMPARE'STRINGS(L,3*S1$ADDR18+S1$CPOS,J)=0;
            ENDIF;
        ENDFOR;
        FRETURN;
BRS37'SCAN'MATCH:RETURN (I,K=L);
        END;

        PROGRAM XBRS37;
        INCLUDE EMDECS;
        DI I,J,K,START'TABLE,END'TABLE;
        DECLARE STRING S1,S2;

         FUNCTION BRS37();
* P14.5 ARGUMENTS:  A=DUAL FILE NO., B=STRING POINTER ADDRESS, X=
* TABLE ADDRESS
* RESULT:  COMPLEX
         SETUP'DUAL'FILE(SAVEDA); I←SAVEDX$ADDR14;
        START'TABLE←I.ADDR14; END'TABLE←I.W1$ADDR14;
        J←SAVEDB$ADDR14;
        J.W1←J.W0 IF SAVEDB<0;
        S1←C940SP(J.W0,J.W1);
        S2←S1;
        IF SAVEDA=-1 OR LENGTH(S2)=1 AND GCI(S2// VALUE 0)='&'' DO;
            IF SAVEDA#-1 DO;
                SETS(S1,0,0);
                WHILE (K←GCD(S1←APPEND'CHAR(S1,J)// VALUE 0))#'&'' DO;
                    WCI(K,S1// VALUE 0);
                ENDFOR;
            ENDIF;
            BRS37'SCAN(START'TABLE,END'TABLE,S1:START'TABLE,K
             //BRS37'NOMATCH);
            GOTO BRS37'MATCH IF K;
            BRS37'SCAN(START'TABLE+3,END'TABLE,S1:I,I//BRS37'MATCH);
            GOTO BRS37'NOMATCH;
        ELSEIF COMND'MODE='BEG' DO;
BRS37'BEGLOOP:BRS37'SCAN(START'TABLE, END'TABLE,S1:START'TABLE,K//
            BRS37'NOMATCH);
            IF K DO;
BRS37'MATCH:    SAVEDA←START'TABLE; SAVEDB←START'TABLE[2]; SKIP; RETURN;
            ELSE DO;
                S1←APPEND'CHAR(S1,J); GOTO BRS37'BEGLOOP;
            ENDIF;
        ELSE DO;
BRS37'EXPLOOP:BRS37'SCAN(START'TABLE,END'TABLE,S1:START'TABLE,K//
            BRS37'NOMATCH);
            BRS37'SCAN(START'TABLE+3,END'TABLE,S1:I,I//BRS37'PARTMATCH);
            S1←APPEND'CHAR(S1,J); GOTO BRS37'EXPLOOP;
BRS37'PARTMATCH:GOTO BRS37'MATCH IF K;
            S2←C940SP(START'TABLE.W0,START'TABLE.W1);
            S2$W1←INCDES(S2$W1,LENGTH(S1));
            WRITE'STRING(S2); GOTO BRS37'MATCH;
        ENDIF;
BRS37'NOMATCH:SAVEDA←J[0]; SAVEDB←J[1]; RETURN;
        END;

        PROGRAM TIME'BRSS;
        INCLUDE EMDECS;
        DI I,J,K,L,H,M,S,LONG LL,STRING S1,S2;
        DECLARE ARRAY DAYS'IN'MONTH[12]←(31,28,31,30,31,30,31,31,30,31,
         30,31);
        DECLARE FIELD ARRAY DATE'BYTES[6]←(SB1,SB2,SB0,SB3,SB4,SB5);
        DECLARE ARRAY DATE'SEP[6]←('/','/',' ',-1,':',-1);


* MACRO TO DIVIDE AB BY D, LEAVING A DOUBLE-PRECISION QUOTIENT
         MACRO DOUBLE'DIVIDE(D)←.DIV D, STA I, LSHD 24, DIV D, LSHD -23, LDA I;

         MACRO REDUCE (L,D,R)←.LDD L, STB I, LSHD -23, DIV D, XMA I, XAB,
         DIV D, STB R, LSHD -23, LDA I, STD L;

         FUNCTION BRS42();
* P6.1 ARGUMENTS: NONE
* RESULT:  CLOCK IN A IN 60THS/SEC
         LL←READ'TIME(0);
        SAVEDA←CONV'TIME'60(LL); RETURN;

         FUNCTION BRS88();
* P6.1 ARGUMENTS:  NONE
* RESULT:  COMPUTE TIME IN A IN 60THS/SEC
         LL←READ'TIME(1); SAVEDA←CONV'TIME'60(LL);
        RETURN;

         FUNCTION BRS39();
* P6.1 ARGUMENT:  NONE
* RESULT: DATE/TIME IN AB YEAR-MONTH-DAY-HOUR-MI-SEC IN 6 8-BIT BYTES.
         SETUP(S1,6,@SAVEDAB);
        GET'DATE(S1); RETURN;

         FUNCTION GET'DATE(S1);
* READ THE REAL-TIME CLOCK
* FROM THE MONITOR AND CONVERT IT TO BE IN SECONDS (STILL DOUBLE
* PRECISION) BY DOING A DOUBLE-PRECISION DIVIDE BY 10↑5.
         LL←READ'TIME(0);
* LL IS (T IN 10 MICROS)/2↑47. WE THEREFORE DIVIDE BY 10↑5/2 TO GET THE
* EFFECT OF SCALING BY 2↑46.
         REDUCE(LL,50000,J);

* NOW WE PROCEED TO EXTRACT YEAR, MONTH, DAY, HOUR, MIN, SECOND
* INTO A STRING OF 8-BIT CHARACTERS WHICH IS WRITTEN INTO THE 6-CHARACTER
* STRING S1.  LL IS THE TIME IN SECONDS/2↑46.
* THIS IS DONE BY REPEATED DIVISION BY THE APPROPRIATE RADIX
         REDUCE(LL,60,J); S←J;
        REDUCE(LL,60,J); M←J;
        REDUCE(LL,24,J); H←J;
* NOW DOWN TO SINGLE-PRECISION DAYS.
         .LDD LL; .LSHD 23; .STA I;
* NOW OBTAIN THE YEAR AND DAY OF YEAR BY REPEATEDLY SUBTRACTING
* 365. WHEN AFTER A LEAP YEAR, SUBTRACT 366.  THE ORIGIN IS JAN. 1,
* 1970.
         J←70; K←365;
        FOR I←I,I-K WHILE I>=K DO;
            J←J+1; K←(366 IF J MOD 4=1 ELSE 365);
        ENDFOR;
        WCI(J,S1// VALUE 0);
* I IS DAY IN YEAR, J IS YEAR (MOD 100). SCAN ARRAY OF DAYS IN MONTH
* TO GET MONTH AND DAY. NOTE SPECIAL TWITCH FOR LEAP YEAR
         L←DAYS'IN'MONTH[0];
        FOR K←1,K+1 WHILE I>=L DO;
            I←I-L; L←DAYS'IN'MONTH[K]; L←L+1 IF K=1 AND J MOD 4=0;
        ENDFOR;
        WCI(K,S1// VALUE 0); WCI(I+1,S1// VALUE 0);
        WCI(H,S1// VALUE 0); WCI(M,S1// VALUE 0); WCI(S,S1// VALUE 0);
        RETURN;


         FUNCTION CONV'TIME'60(LONG LL);
        .LDD LL;
* THIS NUMBER, READ AS A FRACTION, IS (THE TIME IN 10 MICROS)/ 2↑47.
* WE WANT AN INTEGER IN UNITS OF 1/60 SEC. SO WE MUST MULTIPLY BY 60/
* 10↑5 = 6/10↑4. BECAUSE THE RESULT MUST BE TAKEN CORRECTLY MOD 2↑24
* WE MUST BE CAREFUL. A DOUBLE-PRECISION DIVIDE BY 10↑4/6
* IS ROUGHLY WHAT WE  WANT. ACTUALLY THE DIVISION IS BY THE FRAC-
* TION (10↑4/6)*2↑-11 TO YIELD (THE TIME IN 1/60 SEC)/2↑36. THIS
* FRACTION IS 32025252B.
         DOUBLE'DIVIDE (32025252B);

* IF WE THEN MULTIPLY THE QUOTIENT BY 2↑36 WE GET THE DESIRED
* RESULT AS AN INTEGER (A0=15B).
         .LSHD 36-23, .STA I;
        RETURN I;

         FUNCTION BRS91();
* P13.1 ARGUMENT:  AB=STRING POINTER
* RESULT:  APPEND THE CURRENT DATE AND TIME IN THE FORM
* MM/DD/YY HHMM:SS.  AB IS UPDATED
         S1←C940SP(SAVEDA,SAVEDB);
        SETUP(S2,6,@LL);
        GET'DATE(S2);
        FOR I←0 TO 5 DO;
            J←LL$(DATE'BYTES[I]);
            WCI('0' + J/10,S1// VALUE 0); WCI('0' + (J MOD 10),S1// VALUE 0);
            WCI(DATE'SEP[I],S1// VALUE 0) IF DATE'SEP[I]>=0;
        ENDFOR;
        SAVEDB←SAVEDB+16; RETURN;
        END;

        PROGRAM DISMISS'BRSS;
        INCLUDE EMDECS;
        DI I;

         FUNCTION BRS45();
* P2.2 ARGUMENTS: NONE
* RESULT: RUNNING'PROCESS IS PUT ON THE END OF THE EXECUTION QUEUE.
* THEN, IF THERE IS NOTHING ELSE ON THE EXECUTION QUEUE, THE PROCESS
* IS BLOCKED FOR 500 MS.  THEN CONTROL GOES TO RUN'NEXT'FORK.
         I←RUNNING'FORK; RUNNING'FORK←0;
        PUTEXQ(I);
        WAIT(500) IF I=EXECUTIONQ;
        SAVEDP←SAVEDP+1;
        GOTO RUN'NEXT'FORK;

         FUNCTION BRS57();
* P2.2 ARGUMENTS: NONE
* RESULT:  THIS OPERATION IS PRESENTLY IMPLEMENTED AS A NOP
         RETURN;

         FUNCTION BRS81();
        WAIT(SAVEDA);
        RETURN;

         FUNCTION BRS109();
* P5.1 ARGUMENTS:  NONE
* RESULT:  DISMISS THIS FORK
         QUEUE'FORK();
        GOTO RUN'NEXT'FORK;
        END;

        PROGRAM INTCELL;
        INCLUDE EMDECS;
        DI I,LONG REAL'TIME,LL;
        DF SOURCE(0:0,2),BLKOK(0:11,11);
        DP RTSOURCE←2;

         FUNCTION WAIT(INTERVAL);
        IF EXECUTIONQ=0 DO;
* BLOCK THE PROCESS FOR THE SPECIFIED INTERVAL (IN MS)
* FIRST ACQUIRE AN INTERRUPT CELL
             I←ACQICT(-1//SYSERR);
* OBTAIN THE REAL TIME IN 10 US UNITS
             REAL'TIME←READ'TIME(0);
* AND ADD INTERVAL
             .LDA INTERVAL, MUL 100/2, STD LL;
            .LDA REAL'TIME$W1, ADD LL$W1, STA REAL'TIME$W1, LDA REAL'TIME,
             ADC LL$W0, STA REAL'TIME;
*  SET THE CELL UP AS A REAL-TIMER.
             SETICT(I,RTSOURCE@SOURCE+1@BLKOK,0,REAL'TIME//SYSERR);
* BLOCK UNTIL THE TIMER GOES OFF
             BLOCK(4B7 RSH I//SYSERR);
* RELEASE THE CELL
             SCLICT(I,0//SYSERR);
        ELSE DO;
            QUEUE'FORK();
            GOTO RUN'NEXT'FORK;
        ENDIF;
        RETURN;
        END;

        PROGRAM FORK'AUX'FCNS1;
        INCLUDE EMDECS;
        DI I,J,K,FORK;

* RETURN THE FORK NODE WITH PANIC TABLE GIVEN AS ARGUMENT.
* FAIL IF THERE IS NONE.
         FUNCTION FIND'PT(PT,FORK), FRETURN;
        FRETURN IF FORK=0;
        I←FORK.FN'SON;
        FRETURN IF I=0;
        PT←PT$ADDR14;
        FOR J←1 TO NFORKS DO;
            RETURN I IF I.FN'PANICTABLE=PT;
            I←I.FN'BROTHER;
            FRETURN IF I=FORK.FN'SON;
        ENDFOR;
        EMTRAP(13);

* SETUP THE MAP FOR FORK AS THE MAP OF THE LOWER 16K OF THE ADDRESS
* SPACE.  SYSTEM TRAP ON ANY MONITOR FAILURE
         FUNCTION PUT'IN'MAP(FORK);
        RETURN IF FORK=FORK'IN'MAP; FORK'IN'MAP←0;
        J←@(FORK.FN'MAP);
        FOR I←0 TO 7 DO;
            K←J.(MAP'BYTE[I]);
            SET'MAP'BYTE(-1,I,PMT'940[K]$PMT'M1//SYSERR);
        ENDFOR;
        FORK'IN'MAP←FORK; RETURN;

* PUT FORK ON EXECUTION QUEUE IF IT IS NOT THERE OR RUNNING
         FUNCTION PUTEXQ(FORK);
        FORK.FN'STATUS←-1;
        SCANQ(FORK:I,J);
        RETURN IF FORK=RUNNING'FORK OR I#0;
        J.W0←FORK;
        FORK.FN'PTR←0;
        RETURN;

* PUT RUNNING'FORK ON EXECUTIONQ
         FUNCTION QUEUE'FORK();
        SAVE'STATE(RUNNING'FORK);
        I←RUNNING'FORK;
        RUNNING'FORK←0;
        PUTEXQ(I);
        RETURN;

         FUNCTION SAVE'STATE(FORK);
        RETURN IF FORK=0;
        FORK.FN'PCTR←SAVEDP;
        FORK.FN'AR←SAVEDA;
        FORK.FN'BR←SAVEDB;
        FORK.FN'XR←SAVEDX;
        RETURN;

         FUNCTION RESTORE'STATE(FORK);
        SAVEDP←FORK.FN'PCTR;
        SAVEDA←FORK.FN'AR;
        SAVEDB←FORK.FN'BR;
        SAVEDX←FORK.FN'XR;
*SET TO 940 MODE
         SAVEDSR←1B3;
        RETURN;

         FUNCTION FIX'WORKING'SET(LONG NEW'MAP,LONG OLD'MAP);
        FOR I←0 TO 7 DO;
            J←NEW'MAP$(MAP'BYTE[I]);
            K←OLD'MAP$(MAP'BYTE[I]);
            IF J#K AND J#0 DO;
                PPCWS(PMT'940[J]$PMT'M1//SYSERR);
            ENDIF;
        ENDFOR;
        RETURN;
        END;

        PROGRAM FORK'AUX'FCNS2;
        INCLUDE EMDECS;
        DI I,J,K;

         FUNCTION SCANQ(FORK);
*SCANS THE EXECUTION QUEUE AND RETURNS PREVIOS POINTER AND POINTER
*POINTER IS 0 IF NOT FOUND AND PREVIOUS POINTER POINTS TO THE END
         J←@EXECUTIONQ;
SCAN1:  I←J.W0;
        RETURN (I,J) IF I=FORK OR I=0;
        J←@(I.FN'PTR);
        GOTO SCAN1;
        END;

        PROGRAM FORK'BRSS;
        INCLUDE EMDECS;
        DI I,J,FORK;
        DECLARE EXTERNAL READ'FORK,DELETE'FORK,FIND'PT;

         FUNCTION BRS9();
* P 3.1 ARGUMENTS:  A = PANIC TABLE ADDRESS+BITS FOR CREATE'FORK
* RESULT:  CREATES SON OF RUNNING'FORK WITH SPECIFIED PANIC TABLE
         CREATE'FORK(RUNNING'FORK,SAVEDA$ADDR14,SAVEDA,0,0);
        RETURN;

         FUNCTION BRS10();
* P 3.6 ARGUMENTS:  NONE
* RESULT: RUNNING'FORK DESTROYED.  CONTROL TO RUN'NEXT'FORK
         RUNNING'FORK.FN'STATUS←0;
        SAVE'STATE(RUNNING'FORK);
        DELETE'FORK(RUNNING'FORK);
        GOTO RUN'NEXT'FORK;

         FUNCTION BRS30();
* P 3.3 ARGUMENT:  PANIC TABLE
* RESULT:  READS PANIC TABLE FOR SPECIFIED FORK
         READ'FORK(FIND'PT(SAVEDA,RUNNING'FORK// VALUE TRAP));
RESET'MAP:PUT'IN'MAP(RUNNING'FORK); RETURN;

         FUNCTION BRS31();
* P 3.3 ARGUMENT:  PANIC TABLE
* RESULT: IF DESIGNATED FORK IS RUNNING, MAKE RUNNING'FORK ITS WAITING'
* FORK AND BLOCK RUNNING'FORK.  OTHERWISE DO RFK AND RETURN STATUS IN X.
         FORK←FIND'PT(SAVEDA,RUNNING'FORK// RETURN);
        IF FORK.FN'STATUS<0 DO;
            RUNNING'FORK.FN'WAIT'ON'SON←1;
            RUNNING'FORK.FN'WAITING'SON←FORK;
            GOTO RUN'NEXT'FORK;
        ELSE DO;
            READ'FORK(FORK); SAVEDX←FORK.FN'STATUS; GOTO RESET'MAP;
        ENDIF;

         FUNCTION BRS32();
* P 3.3 ARGUMENTS:  PANIC TABLE
* RESULT:  DELETE THE FORK ADDRESSED
         FORK←FIND'PT(SAVEDA,RUNNING'FORK// VALUE TRAP);
        SAVEDX←FORK.FN'STATUS;
        DELETE'FORK(FORK);
        GOTO RESET'MAP;

         FUNCTION BRS49();
* P 4.2 ARGUMENTS: NONE
* RESULT:  INTERRUPT MASK FOR RUNNING'FORK TO A
         SAVEDA←RUNNING'FORK.FN'INTMASK; RETURN;

         FUNCTION BRS71();
* SKIP IF EXECUTIVE  NOP
         RETURN;

         FUNCTION BRS73();
        RETURN IF SAVEDA<=0;
        RUNNING'FORK.FN'STATUS←0;
        SAVE'STATE(RUNNING'FORK);
        FORK←RUNNING'FORK;
        FOR I←1 TO SAVEDA DO;
            GOTO RUN'NEXT'FORK IF FORK=0;
            DELETE'FORK(FORK);
            FORK←FORK.FN'FATHER;* OK TO DO THIS STILL
        ENDFOR;
        GOTO RUN'NEXT'FORK;

         FUNCTION BRS78();
* P 4.1 ARGUMENTS:  SETTING FOR INTERRUPT MASK IN SAVEDA
* RESULT:  NONE
         RUNNING'FORK.FN'INTMASK←SAVEDA; RETURN;

         FUNCTION BRS79();
* P 4.1 ARGUMENTS:  INTERRUPT TO GENERATE IN A
* RESULT: SKIP IF INTERRUPT GENERATED
         TRAP IF SAVEDA>20 OR SAVEDA<5;
        SKIP IF INTERRUPT(RUNNING'FORK,SAVEDA,RUNNING'FORK)#0;
        GOTO RESET'MAP;

         FUNCTION BRS90();
* P 3.6 ARGUMENTS:  NONE
* RESULT:  DECLARE CURRENT FORK AS RUBOUT TARGET
         RUBOUT'TARGET←RUNNING'FORK; RETURN;

         FUNCTION BRS106();
* P 3.3 ARGUMENTS:  NONE
* RESULT:  DISMISS UNTIL SOME SON QUITS.  NOP IF THERE ARE NO SONS,
* OTHERWISE MAKE THE RUNNING FORK THE WAITING FORK FOR ALL SONS AND
* BLOCK
         RETURN IF RUNNING'FORK.FN'SON=0;
        RUNNING'FORK.FN'WAIT'ON'ANY←1;
        GOTO RUN'NEXT'FORK;


         FUNCTION SCAN'SONS(FUNCTION OP);
* APPLY THE SPECIFIED OPERATION TO EACH SON OF RUNNING'FORK.  RETURN
* 0 IF THERE ARE NONE, OTHERWISE 1
         RETURN 0 IF FORK←RUNNING'FORK.FN'SON=0;
        J←0;
        FOR I←FORK,J WHILE J#FORK DO;
            J←I.FN'BROTHER;
            OP(I);
        ENDFOR;
        RETURN 1;

         FUNCTION BRS107();
* P 3.3 ARGUMENTS:  NONE
* RESULT:  READ ALL SONS OF RUNNING'FORK
         SCAN'SONS(READ'FORK); GOTO RESET'MAP;

         FUNCTION BRS108();
* P 3.3 ARGUMENTS:  NONE
* RESULT:  DELETE ALL SONS OF RUNNING'FORK
         SCAN'SONS(DELETE'FORK); GOTO RESET'MAP;
        END;

        PROGRAM CFORK;
        INCLUDE EMDECS;
        DI FORK;
* THE BITS ARE THE ONES GIVEN TO BRS 9 IN THE TOP OF A:

         FUNCTION CREATE'FORK(FATHER,PAN'TAB,BITS,CWS'SIZE,DWS'SIZE);
* FIRST CHECK FOR UNIQUE PANIC TABLE
         TRAP IF FIND'PT(PAN'TAB,FATHER// VALUE 0)#0;
* OBTAIN A FORK NODE
         TRAP IF FN'FREELIST=0;
        FORK←FN'FREELIST; FN'FREELIST←FN'FREELIST.FN'PTR;
        FORK.FN'PTR←0;
* INITIALIZE IT FROM PANIC TABLE
         FORK.FN'AR←PAN'TAB.PT'AR;
        FORK.FN'BR←PAN'TAB.PT'BR;
        FORK.FN'XR←PAN'TAB.PT'XR;
        FORK.FN'PCTR←PAN'TAB.PT'PCTR;
        CHECK'MAP(PAN'TAB.PT'MAP) IF BITS$SETRELPT;
        FORK.FN'MAP←(PAN'TAB.PT'MAP IF BITS$SETRELPT ELSE
         RUNNING'FORK.FN'MAP);
        FORK.FN'INTMASK←(PAN'TAB.PT'INTMASK IF BITS$SETINTMASK
         ELSE 0);
* SET UP OTHER FIELDS IN FORK NODE AND SET PANIC TABLE STATUS
* FIELD
         PAN'TAB.PT'STATUS←-1;
        FORK.FN'LOCALMEM←BITS $ LOCALMEM;
        FORK.FN'NONEWMEM←BITS $ FIXEDMEM;
        FORK.FN'EPHMEM←BITS $ EPHMEM;
        FORK.FN'PANICTABLE←PAN'TAB;
        FORK.FN'WAITING←0;
        FORK.FN'CWS←CWS'SIZE;
        FORK.FN'DWS←DWS'SIZE;
* ADD NEW FORK TO TREE STRUCTURE
         IF FATHER#0 DO;
            IF FATHER.FN'SON=0 DO;
                FATHER.FN'SON←FORK; FORK.FN'BROTHER←FORK;
            ELSE DO;
                FORK.FN'BROTHER←FATHER.FN'SON.FN'BROTHER;
                FATHER.FN'SON.FN'BROTHER←FORK;
            ENDIF;
        ELSE DO;
            FORK.FN'BROTHER←FORK;
        ENDIF;
        FORK.FN'FATHER←FATHER;
        FORK.FN'SON←0;
* AND PUT IT ON EXECUTION QUEUE
         PUTEXQ(FORK);
* PROPAGATE RUBOUT IF NECESSARY
         RUBOUT'TARGET←FORK IF RUBOUT'TARGET=FATHER AND BITS$PROP'RUBOUT;
        RETURN;
        END;

        PROGRAM RFORK;
        INCLUDE EMDECS;
        DI PT;

* READ FORK STATE INTO ITS PANIC TABLE.  MAY CHANGE FORK'IN'MAP
* THIS IS THE 940 SYSTEM'S RFK

         FUNCTION READ'FORK(FORK);

         PUT'IN'MAP(FORK.FN'FATHER);
        PT←FORK.FN'PANICTABLE;
        PT.PT'PCTR←FORK.FN'PCTR;
        PT.PT'AR←FORK.FN'AR;
        PT.PT'BR←FORK.FN'BR;
        PT.PT'XR←FORK.FN'XR;
        PT.PT'STATUS←FORK.FN'STATUS;
        PT.PT'MAP←FORK.FN'MAP;
        RETURN;
        END;

        PROGRAM IFORK;
        INCLUDE EMDECS;
        DI I,J,T,INTERRUPTMASK;

* INTERRUPT FORK, PROPAGATING THE INTERRUPT IF NECESSARY. RETURN
* THE INTERRUPTED FORK IF SUCCESSFUL, 0 OTHERWISE.  IN SCANNING
* THE BROTHER CHAIN, AVOID SOURCE.
* MAY CHANGE FORK'IN'MAP

         FUNCTION INTERRUPT(FORK,INTERRUPTNO,SOURCE);
        INTERRUPTMASK←INT0BIT RSH INTERRUPTNO;
* FIRST TRY FORK AND ITS BROTHERS
         J←0;
        FOR I←FORK, J WHILE J#FORK DO;
            J←I.FN'BROTHER;
            IF I#SOURCE AND I.FN'INTMASK A' INTERRUPTMASK#0 DO;
* SHOULD CAUSE INTERRUPT IN FORK I.  SIMULATE SBRM*INTERRUPTNO + 200B.
* ASSUME OVERFLOW NOT PRESERVED.
* NOTE:  940 INDIRECT ADDRESSING IS NOT SIMULATED. I.E., INDIRECTION
* IS CARRIED TO JUST ONE LEVEL, WITH NO INDEXING.
DOINT:           I.FN'INTMASK←I.FN'INTMASK E' INTERRUPTMASK;
                PUT'IN'MAP(I);
                J←(INTERRUPTNO+200B).ADDR14; T←J.ADDR14;
                IF I=RUNNING'FORK DO;
                    $T←SAVEDP; SAVEDP←J+1;
                ELSE DO;
                    $T←I.FN'PCTR; I.FN'PCTR←J+1;
                ENDIF;
                PUTEXQ(I);
                RETURN I;
            ENDIF;
        ENDFOR;
* THEN TRY FATHERS
         FOR I←FORK.FN'FATHER,I.FN'FATHER WHILE I#0 DO;
            GOTO DOINT IF I.FN'INTMASK A' INTERRUPTMASK#0;
        ENDFOR;
        RETURN 0;
        END;

        PROGRAM DFORK;
        INCLUDE EMDECS;
        DI I,J,PREBROTHER,FATHER;

* DELETE FORK. CORRESPONDS TO THE 940 SYSTEM DFK, MAY CHANGE FORK'IN'MAP

         FUNCTION DELETE'FORK(FORK);
* DELETE SONS
         DELETE'FORK(FORK.FN'SON) WHILE FORK.FN'SON#0;
* CHECK FOR TOP LEVEL FORK AND EXIT IF ATTEMPT TO DELETE
         FATHER←FORK.FN'FATHER;
        RETURN IF FATHER=0;
* READ BACK PANIC TABLE
         READ'FORK(FORK);
* GENERATE INTERRUPT 3 IF REQUIRED
         INTERRUPT(FATHER,3,0)
         IF FATHER.FN'INTMASK$INTERRUPT3;
* DEAL WITH WAITING FORK, IF ANY
         IF FATHER.FN'WAIT'ON'ANY DO;
            FATHER.FN'AR←FORK.FN'PANICTABLE;
            GOTO CONT'WAIT'FORK;
        ELSEIF FATHER.FN'WAIT'ON'SON AND FATHER.FN'WAITING'SON=FORK DO;
            FATHER.FN'XR←FORK.FN'STATUS;
CONT'WAIT'FORK:PUTEXQ(FATHER);
            FATHER.FN'WAITING←0;
            FATHER.FN'PCTR←FATHER.FN'PCTR+1;
        ENDIF;
* PATCH BROTHER CHAIN AROUND NODE BEING DELETED AND FIX FATHER'S
* SON POINTER
         PREBROTHER←0;
        PREBROTHER←I FOR I←FORK.FN'BROTHER,I.FN'BROTHER WHILE I#FORK;
        IF PREBROTHER #0 DO;
            PREBROTHER.FN'BROTHER←FORK.FN'BROTHER;
        ENDIF;
        FATHER.FN'SON←PREBROTHER;
* MOVE RUBOUT TARGET TO FATHER IF NECESSARY
         RUBOUT'TARGET←FATHER IF RUBOUT'TARGET=FORK;
* REMOVE NODE FROM EXECUTION QUEUE IF NECESSARY
         SCANQ(FORK:I,J);
        IF I#0 DO;
            FORK.FN'PANICTABLE.PT'STATUS←0;
            J.W0←FORK.FN'PTR;
            FORK.FN'PTR←0;
        ENDIF;
* TRANSFER MEMORY TO FATHER OR RELEASE IT IF FORK IS EPHEMERAL
         FOR I←NCMEM+1 TO NPMTBYTES-1 DO;
            IF BYTE'OWNER[I]=FORK DO;
                IF FORK.FN'EPHMEM DO;
                    RELEASE'BYTE(I);
                ELSE DO;
                    BYTE'OWNER[I]←FATHER;
                ENDIF;
            ENDIF;
        ENDFOR;
* RETURN NODE TO FREELIST
         FORK.FN'PTR←FN'FREELIST;
        FN'FREELIST←FORK;
        RETURN;
        END;

        PROGRAM EMINIT;
        INCLUDE EMDECS;
        INCLUDE CCPDECS;
* EMULATOR INITIALIZATION AND ERROR RECOVERY
         DI I,J,T,USER'NO,STRING S1(80),S2,S3(16),S4(40);
        DP NO'EM'ENTRIES←2;
        DECLARE LABEL ARRAY EM'ENTRY'LABELS[NO'EM'ENTRIES]←
         (RECOVER,EMULATOR);
        DECLARE LONGLONG ARRAY EM'ENTRIES[NO'EM'ENTRIES]←
         ((6'RECO',6'VER-',6'940 ',0),(6'EMUL',6'ATOR',6'-VER',6'SION'));
        DP NO'EM'CONTS←3;
        DECLARE LABEL ARRAY EM'CONT'LABELS[NO'EM'CONTS]←
         (CONTINUE,DUMP,NRH);
        DECLARE LONGLONG ARRAY EM'CONTS[NO'EM'CONTS]←
         ((6'CONT',6'INUE',0,0),(6'DUMP',6'-940',0,0),(6'NRH-',6'940 ',0,0));
        DI NEXT'PAGE,PAGE'ENTRY,PAGE'INDEX;
        DF PAGE'SH(0:0,0),PAGE'RO(0:2,2),PAGE'BYTE(0:18,23);
        DI SAVE'BYTE,SAVE'FILE'NO,SAVE'PTR;
        DECLARE INTEGER EXTERNAL NAME'SCAN;
        DECLARE STRING EM'DATE←"9/22/70 - 4&307";
        UTILITY COMP'COM'LINE←6;

XRUN'NEXT'FORK:RESTORE'STACK; GOTO XXRUN'NEXT'FORK;

         FUNCTION EMSTART();
        STORE'STACK;
* SETUP L AND G FOR 940 STATE
         SAVEDL←@SAVE'LE[0]; SAVEDG←40000B;
        RUN'NEXT'FORK←XRUN'NEXT'FORK;
        BSET(@PMT'940[0],0,NPMTBYTES);
        USER'MAP←LONGZERO;
        SETUP(MIB'NAME'STRING,16,MIB'ADDRESS+MIB'NAME$FIELD'DISP,6);
        EM'SUBPROCESS←READ'SPS'PARAM('CSP'//SYSERR);
*FIX     QUIT'CHAR←READ'CIOS'FIELD(-1,'QIT'//SYSERR);
         CLEAR'TABLES();
*READ COMMAND LINE
         NRH'FILE←NO'SUB'FILES←0;
        COMMAND'FILE'NO←0; TOUT'FILE'NO←1;
        SCOPY(NRH'NAME,"NRH"// VALUE 0);
        COMP'COM'LINE(S1:S1,USER'NO//SYSERR);
        S2←GET'PARAM(S1);
        GOTO EM'ENTRY'LABELS[NAME'SCAN(S2,EM'ENTRIES,NO'EM'ENTRIES
         //READ'SUB)];

         FUNCTION CLEAR'TABLES();
        NO'NRH'BUFS←3;
        ERROR'STATE←M1'MODE←0;
        SAVE'ECHO←M1'TABLE←-1;
        NEW'ECHO←0; OLD'ECHO←OLD'EST←OLD'BWS←OLD'TRI←OLD'TRO←-1;
        SET'ECHO'MODE(0);
* CLEAR OUT ASSORTED TABLES
         BSET(@FORK'NODES[1],0,FORK'NODE'SIZE*(NFORKS-1));
        RUBOUT'TARGET←FORK'IN'MAP←0;
        FORK'NODES[I]$FN'PTR←@FORK'NODES[I+1] FOR I←0 TO NFORKS-2;
        FN'FREELIST←@FORK'NODES[0]; EXECUTIONQ←0;
        BSET(@BYTE'OWNER[0],0,NPMTBYTES);
        BSET(@FILE'TABLE[0],0,(MAX'FILE+1)*L'FT'ENTRY);
        RUNNING'FORK←QUIT'FLAG←CR'FLAG←MB'FLAG←TTYIN'8←TTYOUT'8←0;
*X*          CCPIO←CCP'TELETYPE←43210765B;
         SET'SPT'FIELD(-1,'TM',TRAP'BITS//SYSERR);
        RETURN;

*LOAD AND RUN A SUBSYSTEM
READ'SUB:SETS(TOPMOST'NAME);
        SETS(S4); WCI('#',S4// VALUE 0);
        CNS(USER'NO,S4,4B7,10// VALUE 0);
        WCI(':',S4// VALUE 0);
        APPEND(S4,S2// VALUE 0);
        S2←S4;
        SCOPY(TOPMOST'NAME,S2// VALUE 0);
        GET'FILE(S2,SUBSYSTEM'FILE,0,'RO'// VALUE DSYSERR);
        READ'SUBSYSTEM(:PANIC'MAP,START'ADDRESS,SUB'SYS'CWS,SUB'SYS'DWS);
        PANIC'TABLE.PT'PCTR←START'ADDRESS$ADDR14;
RUNIT:  S2←GET'PARAM(S1);
        SCOPY(NRH'NAME,S2// VALUE 0) IF LENGTH(S2)>0;
        DELPMT(BUF'BYTE//SYSERR);
        CLOSE'FILE(BUF'FILE'NO//SYSERR);
START:  PANIC'TABLE.PT'AR←0;
        PANIC'TABLE.PT'BR←1;
        PANIC'TABLE.PT'XR←-1;
        PANIC'TABLE.PT'INTMASK←0;
        TOPMOST'FORK←FN'FREELIST;
        FOR I←0 TO NPMTBYTES-1 DO;
            BYTE'OWNER[I]←TOPMOST'FORK IF PMT'940[I]#0;
        ENDFOR;
        BSET(@FORK'NODES[0],0,FORK'NODE'SIZE);
        FORK'NODES[0]$FN'PTR←@FORK'NODES[1];
        CREATE'FORK(0,PANIC'TABLE,1@LOCALMEM+1@SETRELPT,
          SUB'SYS'CWS,SUB'SYS'DWS);
        RUBOUT'TARGET←TOPMOST'FORK;
        GOTO XXRUN'NEXT'FORK;

*RECOVER COMMAND
RECOVER: S2←GET'PARAM(S1);
        IF LENGTH(S2)=0 DO;
            SETS(S1);
            S1←READ'LINE(-1,S1,"FROM ",QUIT'FLAG//REC'QUIT:S1,ERRSPEC);
            S2←GET'PARAM(S1);
            IF LENGTH(S2)=0 DO;
REC'QUIT:       RETURN;
            ENDIF;
        ENDIF;
        GET'FILE(S2,DUMP'FILE,0,'RO'// VALUE DSYSERR);
        EMTRAP(14) IF GET'WORD()#11106B;
        EMTRAP(14) IF (START'ADDRESS←GET'WORD())=-1;
        PANIC'TABLE.PT'PCTR←START'ADDRESS$ADDR14+1;
        NEXT'PAGE←0;
        EMTRAP(14) IF GET'WORD()#'(';
        EMTRAP(14) IF GET'WORD()#')';
        EMTRAP(14) IF GET'WORD()#'/';
*COLLECT NAME
         SETS(TOPMOST'NAME);
        WCI(I,TOPMOST'NAME// VALUE 0) WHILE (I←GET'WORD())#-1;
        WCI('?',TOPMOST'NAME// VALUE 0) IF LENGTH(TOPMOST'NAME)=0;
        SET'SP'NAME(-1,TOPMOST'NAME//SYSERR);
*SKIP OVER MACHINE SIZE
MACH'SIZE:GET'WORD();
*READ PROGRAM AND SUBSYSTEM MAPS
         USER'MAP$W0←GET'WORD();
        USER'MAP$W1←GET'WORD();
        PANIC'TABLE.PT'MAP$W0←GET'WORD();
        PANIC'TABLE.PT'MAP$W1←GET'WORD();
*MAIN LOOP TO READ PAGES
         WHILE (PAGE'ENTRY←GET'WORD())#0 DO;
            IF PAGE'ENTRY$PAGE'SH DO;
                PAGE'INDEX←GET'WORD();
                SETS(S3);
                WCI(I,S3// VALUE 0) WHILE (I←GET'WORD())#-1;
*MUST SAVE BUFFER INFORMATION IN CASE IT IS DESTROYED
*BY A COPY PAGE OPERATION
                 SAVE'BYTE←BUF'BYTE;
                SAVE'FILE'NO←BUF'FILE'NO;
                SAVE'PTR←BUF'PTR;
                GET'FILE(S3,SUBSYSTEM'FILE,0,'RO'// VALUE DSYSERR);
                I←PAGE'ENTRY$PAGE'BYTE;
                READ'SUB'PAGE(PAGE'INDEX,I);
                SPMTRO(PMT'940[I]$PMT'M1,1//SYSERR) IF PAGE'ENTRY$PAGE'RO;
                DELPMT(BUF'BYTE//SYSERR);
                CLOSE'FILE(BUF'FILE'NO//SYSERR);
                BUF'BYTE←SAVE'BYTE;
                BUF'FILE'NO←SAVE'FILE'NO;
                BUF'PTR←SAVE'PTR;
                SET'MAP'BYTE(-1,BUF'PAGE,BUF'BYTE//SYSERR);
            ELSE DO;
                NEXT'PAGE←NEXT'PAGE+1;
                I←PAGE'ENTRY$PAGE'BYTE;
                COPY'PAGE(BUF'FILE'NO,NEXT'PAGE,I);
                SPMTRO(PMT'940[I]$PMT'M1,1//SYSERR) IF PAGE'ENTRY$PAGE'RO;
            ENDIF;
        ENDFOR;
        GOTO RUNIT;

*THIS IS A DUMMY LABEL
EMULATOR:PRINT'STRING(-1,EM'DATE,QUIT'FLAG// RETURN :S2,ERRSPEC);
        RETURN;

*CONTINUE LOGIC
         FUNCTION EJ();
        CLEAR'TABLES();
        S1←GET'COM'LINE(S1//SYSERR);
        S2←GET'PARAM(S1);
        GOTO EM'CONT'LABELS[NAME'SCAN(S2,EM'CONTS,NO'EM'CONTS//
         VALUE EMTRAP(15))];

*DECLARE NRH FILE AND CONTINUE
NRH:     S2←GET'PARAM(S1);
        BRS7();
        SCOPY(NRH'NAME,S2// VALUE 0) IF LENGTH(S2)>0;

*CONTINUE COMMAND
CONTINUE:PANIC'MAP←TOPMOST'FORK.FN'MAP;
        PANIC'TABLE.PT'PCTR←START'ADDRESS+1;
        GOTO START;

*DUMP COMMAND
DUMP:    NEXT'PAGE←0;
        S2←GET'PARAM(S1);
        IF LENGTH(S2)=0 DO;
            S1←READ'LINE(-1,S1,"ON ",QUIT'FLAG//EXIT'CRLF:S1,ERRSPEC);
            S2←GET'PARAM(S1);
            IF LENGTH(S2)=0 DO;
DUMP'QUIT:      SP'RETURN(//SYSERR);
            ENDIF;
        ENDIF;
        GET'FILE(S2,DUMP'FILE,1,'RW'// VALUE DSYSERR);
        PUT'WORD(11106B);
        PUT'WORD(START'ADDRESS);
        PUT'WORD('(');
        PUT'WORD(')');
        PUT'WORD('/');
        I←0;
        SETR(TOPMOST'NAME);
        PUT'WORD(I←GCI(TOPMOST'NAME// VALUE -1)) WHILE I>=0;
        PUT'WORD(40B);
        PUT'WORD(USER'MAP$W0);
        PUT'WORD(USER'MAP$W1);
        PUT'WORD(TOPMOST'FORK.FN'MAP$W0);
        PUT'WORD(TOPMOST'FORK.FN'MAP$W1);
        FOR I←NCMEM+1 TO NPMTBYTES-1 DO;
            IF PMT'940[I]#0 DO;
                J←I;
                J$PAGE'RO←1 IF RPMTRO(PMT'940[I]$PMT'M1)=1;
                J$PAGE'SH←1 IF PMT'940[I]$IS'SUB'BYTE;
                PUT'WORD(J);
                IF J$PAGE'SH DO;
                    PUT'WORD(PMT'940[I]$SUB'PAGE);
                    WRITE'SUB'NAME(PMT'940[I]$SUB'NAME);
                ELSE DO;
                    NEXT'PAGE←NEXT'PAGE+1;
                    OUTPUT'PAGE(NEXT'PAGE,PMT'940[I]$PMT'M1);
                ENDIF;
            ENDIF;
        ENDFOR;
        PUT'WORD(0);
        OUTPUT'PAGE(0,BUF'BYTE);
        SAVE'BYTE←ACQPMT(-1//SYSERR); NPPMT(SAVE'BYTE//SYSERR);
        SET'MAP'BYTE(-1,COPY'FROM'PAGE,SAVE'BYTE//SYSERR);
        NEXT'PAGE←NEXT'PAGE+1;
        COPY'FROM'ADD[0]$W0←COPY'FROM'ADD[1]$W0←EOFWORD;
        OUTPUT'PAGE(NEXT'PAGE,SAVE'BYTE);
        DELPMT(SAVE'BYTE//SYSERR);
        FOR NEXT'PAGE←NEXT'FILE'PAGE(BUF'FILE'NO,NEXT'PAGE//SYSERR)
         WHILE NEXT'PAGE#-1 DO;
            DELETE'FILE'PAGE(BUF'FILE'NO,NEXT'PAGE//SYSERR);
        ENDFOR;
        CLOSE'FILE(BUF'FILE'NO//SYSERR);
        SP'RETURN(//SYSERR);

* 'SCHEDULER' FOR FORK STRUCTURE.  CONTROL COMES HERE WHEN A FORK
* BLOCKS (IN THE SENSE OF THE EMULATOR, I.E. BRS10,BRS31 ETC).  THE TOP
* FORK ON THE EXECUTION QUEUE IS TAKEN OFF AND STARTED.  IF THE QUEUE
* IS EMPTY, CONTROL RETURNS TO THE CALLER OF THE EMULATOR

XXRUN'NEXT'FORK:SAVE'STATE(RUNNING'FORK);
        IF EXECUTIONQ=0 DO;
*X*              IF CCPIO=5 DO;
*X*                  CCP'EXIT();
*X*              ELSE DO;
             BRS17();
            CLOSE'940'FILE(NRH'FILE) IF NRH'FILE#0;
            NRH'FILE←RUNNING'FORK←0;
EXIT'CRLF:  XCH'WS'SIZE(SUB'SYS'CWS,SUB'SYS'DWS
              :SUB'SYS'CWS,SUB'SYS'DWS);
        PRINT'CHAR(-1,FE'NEWLINE,0//EXIT'QUIT:I,ERRSPEC);
            SP'RETURN(//SYSERR);
EXIT'QUIT:  DSYSERR IF ERRCODE#'QIT';
            QUIT'FLAG←-1;
            GOTO EXIT'CRLF;
*X*              ENDIF;
         ENDIF;
        RUNNING'FORK←EXECUTIONQ; EXECUTIONQ←EXECUTIONQ.FN'PTR;
        RUNNING'FORK.FN'PTR←0;
        RESTORE'STATE(RUNNING'FORK);
        RUNNING'FORK.FN'WAITING←0;
        XCH'WS'SIZE(SUB'SYS'CWS,SUB'SYS'DWS:SUB'SYS'CWS,SUB'SYS'DWS);
        FIX'WORKING'SET(RUNNING'FORK.FN'MAP,
         FORK'IN'MAP.FN'MAP IF FORK'IN'MAP#0 ELSE LONGZERO);
        PUT'IN'MAP(RUNNING'FORK);
        ERROR'STATE←0;
        QUIT();
        .EAX SAVEDP, LOADS;
        END;

        PROGRAM STARTUP'FCNS1;
        INCLUDE EMDECS;
        DI I,J,K,L,BYTE,BYTE'M1'OLD,BYTE'M1'NEW,LONG RESULT'MAP;
        DECLARE ARRAY PMTARRAY[5];
        DF PMTROBIT(3:0,0);

         FUNCTION GET'WORD();
*GETS THE NEXT WORD FROM THE BUFFER PAGE
         EMTRAP(16) IF BUF'PTR>3777B;
        BUF'PTR←BUF'PTR+1;
        RETURN BUF'ADDRESS[BUF'PTR-1]$W0;

         FUNCTION COPY'PAGE (FILE'NUM,PAGE'NO,BYTE'940);
*GETS A COPY OF A SUBSYSTEM PAGE
*AND FIXES UP THE 940 PMT
         GET'MAP'BYTE(BYTE'940:BYTE'940,BYTE'M1'OLD);
        PUT'PAGE'IN'PMT(FILE'NUM,PAGE'NO,BYTE'M1'OLD//SYSERR);
        SET'MAP'BYTE(-1,COPY'FROM'PAGE,BYTE'M1'OLD//SYSERR);
        BYTE'M1'NEW←ACQPMT(-1//SYSERR);
        NPPMT(BYTE'M1'NEW//SYSERR);
        SET'MAP'BYTE(-1,COPY'TO'PAGE,BYTE'M1'NEW//SYSERR);
        BCOPY(COPY'TO'ADD,COPY'FROM'ADD,4000B);
        DELPMT(BYTE'M1'OLD//SYSERR);
        SET'MAP'BYTE(-1,COPY'TO'PAGE,0//SYSERR);
        PMT'940[BYTE'940]←BYTE'M1'NEW;
        RETURN BYTE'940;

         FUNCTION READ'SUB'PAGE(PAGE'NO,BYTE'NO);
*READS A SUBSYSTEM PAGE FROM A FILE
         I←BUF'ADDRESS[PIF'FILE'INDEX+PAGE'NO/2];
        I←I LSH 12 IF (PAGE'NO A' 1);
        J←I$CD'BITS;
        K←I$FILE'IND'BITS;
        IF J=1 DO;
*SETUP A READ-ONLY PAGE
*SAVE INDEX TO SUBSYSTEM NAME
*SAVE SUBSYSTEM PAGE NUMBER
             GET'MAP'BYTE(BYTE'NO:J,L);
            PMT'940[J]$IS'SUB'BYTE←1;
            PMT'940[J]$SUB'NAME←CUR'NAME'INDEX;
            PMT'940[J]$SUB'PAGE←PAGE'NO;
            PUT'PAGE'IN'PMT(BUF'FILE'NO,K,L//SYSERR);
            SPMTRO(L,1//SYSERR);
        ELSEIF J=2 DO;
*CREATE A PAGE
             GET'MAP'BYTE(BYTE'NO:J,L);
            NPPMT(BYTE'NO//SYSERR);
        ELSEIF J=3 DO;
*GET A COPY OF THE PAGE
             J←COPY'PAGE(BUF'FILE'NO,K,BYTE'NO);
        ENDIF;
*ELSE J=0 AND DON'T CREATE A PAGE
*RETURN THE 940 PMT INDEX OF THE PAGE
         RETURN J;


         FUNCTION GET'FILE(STRING NAME,INTEGER TYPE,NEW'NAME'OK,ACCESS)
         , FRETURN;
*SEARCHES FOR FILE GIVEN BY NAME
*CHECKS THE TYPE AND OPENS THE FILE
*SETS UP THE BUFFER PAGE WITH PAGE 0
*OF THE FILE
*IF GETTING A SUBSYSTEM THE LIST OF OPEN SUBSYSTEM FILES IS
*SCANNED AND A NEW ENTRY IS MADE IF NECESSARY
         CHECK'SUB'NAME(NAME) IF TYPE = SUBSYSTEM'FILE;
        NAME'SEARCH(NAME,MIB'OBJECT'NAME,NEW'NAME'OK,TYPE,-1//
         FRETURN :ERRSPEC);
        BUF'FILE'NO←OPEN'FILE(-1,MIB'OBJECT'NAME,ACCESS,-1//SYSERR);
        BUF'BYTE←ACQPMT(-1//SYSERR);
        IF NEW'NAME'OK AND NEXT'FILE'PAGE(BUF'FILE'NO,-1//SYSERR)#0 DO;
            CREATE'FILE'PAGE(BUF'FILE'NO,0//SYSERR);
        ENDIF;
        PUT'PAGE'IN'PMT(BUF'FILE'NO,0,BUF'BYTE//SYSERR);
        SET'MAP'BYTE(-1,BUF'PAGE,BUF'BYTE//SYSERR);
        BUF'PTR←0;
        RETURN;

         FUNCTION NAME'SCAN(STRING S1,LONGLONG ARRAY NAMES,
         INTEGER NO'NAMES), FRETURN;
*FINDS INDEX OF NAME IN ARRAY ELSE FRETURN
         FOR I←0 TO NO'NAMES-1 DO;
            SETR(S1);
            FOR J←0 TO 15 DO;
                GOTO NEXT'NAME IF GCI(S1// VALUE 0)#
                 NAMES[I]$ (CHAR[J]);
            ENDFOR;
            CUR'NAME'INDEX←I;
            RETURN I;
NEXT'NAME:ENDFOR;
        CUR'NAME'INDEX←NO'NAMES;
        FRETURN;

         FUNCTION CHECK'SUB'NAME(NAME);
*CHECKS FOR A NEW SUBSYSTEM NAME AND ENTERS IT IF NECESSARY
         NAME'SCAN(NAME,SUB'FILE'NAMES,NO'SUB'FILES//NEW'SUB);
        RETURN;
NEW'SUB:EMTRAP(17) IF NO'SUB'FILES>3;
        SETR(NAME);
        SUB'FILE'NAMES[NO'SUB'FILES]$(CHAR[I])←GCI(NAME// VALUE 0)
         FOR I←0 TO 15;
        NO'SUB'FILES←NO'SUB'FILES+1;
        RETURN;

         FUNCTION PUT'WORD(L);
*PUTS THE VALUE IN THE NEXT WORD OF THE BUFFER PAGE
         EMTRAP(16) IF BUF'PTR>3777B;
        BUF'ADDRESS[BUF'PTR]$W0←L;
        BUF'PTR←BUF'PTR+1;
        RETURN;

         FUNCTION WRITE'SUB'NAME(L);
*WRITES THE SUBSYSTEM FILE'S NAME ONTO THE BUFFER FILE
         FOR I←0 TO 15 DO;
            J←SUB'FILE'NAMES[L]$(CHAR[I]);
            GOTO DONE'WRITE'SUB IF J=0;
            PUT'WORD(J);
        ENDFOR;
DONE'WRITE'SUB:PUT'WORD(-1);
        RETURN;

         FUNCTION OUTPUT'PAGE(PAGE'NO,BYTE'M1'OLD);
* OUTPUTS TO THE BUFFER FILE ON PAGE NUMBER PAGE'NO FROM
* PMT BYTE BYTE'M1'OLD
         IF NEXT'FILE'PAGE(BUF'FILE'NO,PAGE'NO-1//SYSERR)#PAGE'NO DO;
            CREATE'FILE'PAGE(BUF'FILE'NO,PAGE'NO//SYSERR);
        ENDIF;
        SET'MAP'BYTE(-1,COPY'FROM'PAGE,BYTE'M1'OLD//SYSERR);
        BYTE'M1'NEW←ACQPMT(-1//SYSERR);
        PUT'PAGE'IN'PMT(BUF'FILE'NO,PAGE'NO,BYTE'M1'NEW//SYSERR);
        SET'MAP'BYTE(-1,COPY'TO'PAGE,BYTE'M1'NEW//SYSERR);
        BCOPY(COPY'TO'ADD,COPY'FROM'ADD,4000B);
        SET'MAP'BYTE(-1,COPY'FROM'PAGE,0//SYSERR);
        DELPMT(BYTE'M1'NEW//SYSERR);
        RETURN;

*READS PMT READ ONLY BIT
         FUNCTION RPMTRO(BYTE'NO);
        READ'PMT(BYTE'NO,PMTARRAY//SYSERR);
        RETURN PMTARRAY[0]$PMTROBIT;
        END;

        PROGRAM STARTUP'FCNS2;
        INCLUDE EMDECS;
        DI I,J,K,L,BYTE,BYTE'M1'OLD,BYTE'M1'NEW,LONG RESULT'MAP;

         FUNCTION GET'MAP'BYTE(IND);
*ACQUIRES A M1 PMT INDEX
*AND ASSIGNS IT TO 940 PMT INDEX IND
*IF IND IS 0 THE 940 PMT INDEX IS ASSIGNED
         BYTE←ACQPMT(-1//SYSERR);
        IF IND=0 DO;
            FOR IND←NCMEM+1 TO NPMTBYTES-1 DO;
                GOTO GOT'BYTE IF PMT'940[IND]=0;
            ENDFOR;
            EMTRAP(18);
        ENDIF;
GOT'BYTE:PMT'940[IND]←BYTE;
*BYTE OWNER MUST ALSO BE SETUP (ELSEWHERE)
         RETURN (IND,BYTE);

         FUNCTION READ'SUBSYSTEM();
*SETS UP PMT FOR A SUBSYSTEM
*RETURNS MAP AND STARTING ADDRESS
         RESULT'MAP$(MAP'BYTE[I])←READ'SUB'PAGE(I,0) FOR I←0 TO 7;
        RETURN (RESULT'MAP,BUF'ADDRESS[ENTRY'POINT]$W0,
          BUF'ADDRESS[ENTRY'POINT+1]$W0,BUF'ADDRESS[ENTRY'POINT+2]$W0);
        END;

        PROGRAM CCP'CTL;
        INCLUDE EMDECS;
        INCLUDE CCPDECS;
        DECLARE STRING XCCP'INPUT;

*X** CONTROL COMES HERE WHEN THE UTILITY CALLS FOR CIOS SERVICE.
*X*          FUNCTION CIOS'INREQ(),SP'ENTRY←4;
*X** INPUT REQUEST FROM CIOS
*X*          PENDING'CIOS'REQ←CIOS'INPUT'REQ; GOTO CIOS'REQUEST;
*X*
*X*          FUNCTION CIOS'OUT'REQ(),SP'ENTRY←5;
*X** OUTPUT REQUEST FROM CIOS
*X*          PENDING'CIOS'REQ←CIOS'OUTPUT'REQ;
*X*CIOS'REQUEST:CIOS'OUTPUT'READ←0;
*X** MAIN LOOP FOR CCP LOGIC
*X*          CCP'UNHANG(@HANGING'STO);
*X*          IF CCP'INPUT$W2#CCP'INPUT$W3 DO;
*X*              CCP'UNHANG(@HANGING'STI);
*X*          ELSEIF CCP'INPUT$W0=CCP'INPUT$W1 DO;
*X*              CCP'UNHANG(@HANGING'WIR);
*X*          ENDIF;
*X*          GOTO RUN'NEXT'FORK;
*X*
*X*          FUNCTION CCP'EXIT();
*X*          IF PENDING'CIOS'REQ=CIOS'OUTPUT'REQ AND CIOS'OUTPUT'READ=1 DO;
*X*              SP'RETURN(//SYSERR);
*X*          ELSEIF PENDING'CIOS'REQ=CIOS'INPUT'REQ AND CCP'INPUT$W1#CCP'INPUT
*X*          $W2 DO;
*X** RETURN INPUT
*X*              XCCP'INPUT←CCP'INPUT; SETS(CCP'INPUT);
*X*              RET'CIOS'INPUT(XCCP'INPUT,CCP'CIOS//SYSERR);
*X*          ELSE DO;
*X** NOTHING TO DO.
*X*              CCPTRAP(1);
*X*          ENDIF;
*X*
*X*          FUNCTION CCP'HANG(I);
*X*          CCPTRAP(2) IF $I#0; $I←RUNNING'FORK;
*X*          GOTO RUN'NEXT'FORK;
*X*
*X*          FUNCTION CCP'UNHANG(I);
*X*          RETURN IF $I=0; PUTEXQ(I); $I←0;
*X*          RETURN;
        END;

        PROGRAM CCP'IO'POPS;
        INCLUDE POPVARS;
        INCLUDE CCPDECS;
        SET'LE;
        JUMP'LE;

*X*          FUNCTION STI'(),DOSYSPOP(36B);
*X** P7.7 ARGUMENT:  ADDRESSES THE CCP TELETYPE, A=CHARACTER TO SEND
*X** THERE
*X** RESULT:  THE CHARACTER IS PUT IN THE CCP INPUT BUFFER IF IT IS
*X** NOT FULL.  OTHERWISE, THE FORK IS HUNG.
*X*          TRAP IF SPEA.W0#CCP'TELETYPE;
*X*          IF CCPIO=5 DO;
*X** NORMAL OPERATION.
*X*              WCI(SAVEDA,CCP'INPUT//STI'BUFFER'FULL); POPRET;
*X*STI'BUFFER'FULL:CCP'HANG(@HANGING'STI);
*X*          ELSEIF CCPIO=0 DO;
*X** WAITING FOR STI OF 137
*X*              CCPTRAP(3) IF SAVEDA#137B;
*X*              CCPIO←1; SCOPY(CCP'OUTPUT,"&M&JENTER "//CCPTRAP(4)); POPRET;
*X*          ELSEIF CCPIO=2 DO;
*X*              WCI(SAVEDA,CCP'OUTPUT//CCPTRAP(4));
*X*              CCPIO←3; APPEND(CCP'OUTPUT,"&M&JPASSWORD "//CCPTRAP(4)); POPRET;
*X*          ELSEIF CCPIO=4 DO;
*X*              IF SAVEDA#'.' DO;
*X*                  POPRET;
*X*              ENDIF;
*X*              CCPIO←5; APPEND(CCP'OUTPUT,"OK&M&J@"//CCPTRAP(4));
*X*              QUEUE'FORK(); RECURSE'CP(CCP'CIOS);
*X*              GOTO RUN'NEXT'FORK;
*X*          ELSE DO;
*X*              CCPTRAP(5);
*X*          ENDIF;
*X*
*X*
*X*          FUNCTION STO'(),DOSYSPOP(34B);
*X** P7.7 ARGUMENT:  ADDRESSES THE CCP TELETYPE
*X** RESULT:  A=CHARACTER RETURNED IF THERE IS OUTPUT TO BE HAD.
*X** OTHERWISE HANG THE FORK.
*X*          TRAP IF SPEA.W0#CCP'TELETYPE;
*X*STO'LOOP: SAVEDA←GCI(CCP'OUTPUT//STO'BUFFER'EMPTY); POPRET;
*X*STO'BUFFER'EMPTY:SETS(CCP'OUTPUT); TRAP IF CCPIO<5; CIOS'OUTPUT'READ←1;
*X*          READ'CIOS'OUTPUT(CCP'OUTPUT,CCP'CIOS//SYSERR);
*X*          GOTO STO'LOOP IF CCP'OUTPUT$W1#CCP'OUTPUT$W2;
*X*          CCP'HANG(@HANGING'STO);
        END;

        PROGRAM CCP'BRSS;
        INCLUDE EMDECS;
        INCLUDE CCPDECS;

*X*          FUNCTION BRS138();
*X** P7.5 ARGUMENT:  X=CCP TELETYPE NUMBER
*X** RESULT:  HANG UNLESS THERE IS AN INPUT REQUEST PENDING AND NOTHING
*X** IN THE INPUT BUFFER.
*X*          TRAP IF SAVEDX#CCP'TELETYPE;
*X*          RETURN IF PENDING'CIOS'REQ=CIOS'INPUT'REQ AND CCP'INPUT$W1=CCP'INPUT
*X*          $W2;
*X*          TRAP IF CCPIO<5;
*X*          CCP'HANG(@HANGING'WIR);
*X*
*X*          FUNCTION BRS139();
*X** P7.7 ARGUMENT:  X=CCP TELETYPE NUMBER
*X** RESULT:  TRAP IF X IS WRONG, OTHERWISE NOP
*X*          TRAP IF SAVEDX#CCP'TELETYPE; RETURN;
*X*
*X*          FUNCTION BRS27();
*X** P7.3 ARGUMENT:  A=TELETYPE TO ATTACH
*X** RESULT:  IF THERE IS ALREADY A TELETYPE ATTACHED, OR IF A<0, TRAP.
*X** OTHERWISE MAKE A THE CCP TELETYPE AND CREATE A CONTROL I/O STREAM,
*X** PROPERLY INITIALIZED, FOR IT.
*X*          TRAP IF CCP'TELETYPE>=0 OR SAVEDA<0;
*X*          CCP'CIOS←CREATE'CIOS(-1//SYSERR);
*X*          SET'CIOS'FIELD(CCP'CIOS,'EST',1//SYSERR);
*X*          SET'CIOS'FIELD(CCP'CIOS,'BWS',3//SYSERR);
*X*          SET'CIOS'INPUT(CCP'CIOS,'SPE',EM'SUBPROCESS@SCIOS'SP+4,0//SYSERR);
*X*          SET'CIOS'OUTPUT(CCP'CIOS,'SPE',EM'SUBPROCESS@SCIOS'SP+5,0//SYSERR);
*X*          CCP'TELETYPE←SAVEDA;
*X*          CCPIO←0;
*X*          HANGING'STI←HANGING'STO←HANGING'WIR←PENDING'CIOS'REQ←0;
*X*          SETS(CCP'INPUT); SETS(CCP'OUTPUT);
*X*          SKIP; RETURN;
*X*
*X*          FUNCTION BRS28();
*X** P7.3 ARGUMENT:  A=TELETYPE TO RELEASE
*X** RESULT:  TRAP IF A#CCP'TELETYPE.  OTHERWISE SHUT DOWN ANY RECURSION
*X** OF THE UTILITY AND DESTROY THE CIOS.  NOTE THAT WHEN THE UTILITY
*X** IS UNRECURSED CONTROL RETURNS TO THE ROUTINE WHICH RECURSED IT.
*X*          TRAP IF SAVEDA#CCP'TELETYPE;
*X*          SET'CIOS'FIELD(CCP'CIOS,'CL',0//SYSERR);
*X*          CCP'CIOS←CCP'TELETYPE←43210765B;
*X*          RETURN IF CCPIO#5;
*X*          QUEUE'FORK(); UNRECURSE'CP();
        END;

        PROGRAM EM'ERRORS;
        INCLUDE EMDECS;
        INCLUDE ERROR'MESSAGES;
        DECLARE STRING S1(80);
        DECLARE I,J;

         FUNCTION QUIT();
        RETURN IF QUIT'FLAG=0;
        IF SAVE'ECHO>=0 DO;
            NEW'ECHO←SAVE'ECHO;
            SAVE'ECHO←-1;
        ENDIF;
        QUIT'FLAG←0;
        EMTRAP(11) IF RUBOUT'TARGET=0;
        I←(INTERRUPT(RUBOUT'TARGET,1,0) IF
         RUBOUT'TARGET.FN'INTMASK$INTERRUPT1 ELSE 0);
        IF I=0 DO;
            RUNNING'FORK.FN'STATUS←0;
            SAVE'STATE(RUNNING'FORK);
            DELETE'FORK(RUNNING'FORK);
        ELSEIF I#RUNNING'FORK DO;
            SAVE'STATE(RUNNING'FORK);
            QUEUE'FORK();
        ELSE DO;
CONT'RUNNING:PUT'IN'MAP(RUNNING'FORK);
            QUIT();
            RESTORE'STACK;
            .EAX SAVEDP, LOADS;
        ENDIF;
        GOTO RUN'NEXT'FORK;

         FUNCTION MEM'TRAP'FCN();
        J←2; GOTO T'I;

         FUNCTION TRAP'INST();
* DOES INSTRUCTION TRAP LOGIC
         J←1;
T'I:    RUNNING'FORK.FN'STATUS←J;
        I←INTERRUPT(RUNNING'FORK,2,0);
        IF I=0 DO;
            SAVE'STATE(RUNNING'FORK);
            DELETE'FORK(RUNNING'FORK);
            PRINT'LOC(J,0) IF EXECUTIONQ=0;
        ELSEIF I#RUNNING'FORK DO;
            EMTRAP(11) IF RUNNING'FORK=0;
            SAVE'STATE(RUNNING'FORK);
            DELETE'FORK(RUNNING'FORK);
        ELSE DO;
            GOTO CONT'RUNNING;
        ENDIF;
        GOTO RUN'NEXT'FORK;

         FUNCTION SYSTEM'ERROR();
* PRINTS SYSTEM ERROR MESSAGES
         SP'RETURN(//SYSERR) IF ERROR'STATE>=2;
        ERROR'STATE←ERROR'STATE+1;
        SETS(S1);
        S1←ERROR'MSG(ERRNUMBER,S1//SYSERR);
        WCI(FE'NEWLINE,S1// VALUE 0);
SYSERR'MSG:PRINT'STRING(-1,S1,0//SYSERR'QUIT:S1,ERRSPEC);
        .LDA L' [0], STA I;
        PRINT'LOC(0,I);
        GOTO RUN'NEXT'FORK;
SYSERR'QUIT:EMTRAP(11) IF ERRCODE#'QIT';
        QUIT'FLAG←-1;
        GOTO SYSERR'MSG;

* EMULATOR ERRORS COME HERE
         FUNCTION EMTRAP(I);
        SP'RETURN(//SYSERR) IF ERROR'STATE>=2;
        ERROR'STATE←ERROR'STATE+1;
        SETS(S1);
        SCOPY(S1,ERROR'MESSAGE[I]// VALUE 0);
        WCI(FE'NEWLINE,S1// VALUE 0);
EM'ERR'PRINT:PRINT'STRING(-1,S1,0//EM'ERR'QUIT:S1,ERRSPEC);
        PRINT'LOC(0,RING'P);
        GOTO RUN'NEXT'FORK;
EM'ERR'QUIT:DSYSERR IF ERRCODE#'QIT';
        QUIT'FLAG←-1;
        GOTO EM'ERR'PRINT;

         FUNCTION CCPTRAP(I);
* CCP TRAPS COME HERE
*
*
*
         PRINT'LOC(0,0);
        GOTO RUN'NEXT'FORK;

         FUNCTION PRINT'LOC(I,V);
        SETS(S1);
        APPEND(S1,ATIM[I]// RETURN);
        CNS(SAVEDP,S1,4B7,8// RETURN);
        IF V#0 DO;
            WCI(' ',S1// RETURN);
            CNS(V,S1,4B7,8// RETURN);
        ENDIF;
        WCI(FE'NEWLINE,S1// RETURN);
PRINT'LOC'OUT:PRINT'STRING(-1,S1,0//PRINT'LOC'QUIT:S1,ERRSPEC);
        RETURN;
PRINT'LOC'QUIT:QUIT'FLAG←-1;
        GOTO PRINT'LOC'OUT;
        END;

        PROGRAM EMENTRY;
        INCLUDE EMDECS;
        DI NO= L' [0],PAR= L' [1];

*TRAP ENTRY POINT
         FUNCTION ET(), SP'ENTRY ←0;
*SAVE STATE FOR TRAP
         .STX TX, EAX TP, STORS;
        TRAP'LOGIC(NO,PAR);

*EMULATOR ENTRY
         FUNCTION EE(), SP'ENTRY ←2;
*SETUP STACK
         $40002B←42000B;
        $40003B←43777B;
        EI();

*EMULATOR CONTINUE
         FUNCTION EC(), SP'ENTRY ←3;
*SETUP STACK
         $40002B←42000B;
        $40003B←43777B;
        EJ();

         FUNCTION E4(), SP'ENTRY ←4;
        .STX RX, LDX 4, BRU SP'ENTRY'LOGIC;

         FUNCTION E5(), SP'ENTRY ←5;
        .STX RX, LDX 5, BRU SP'ENTRY'LOGIC;

         FUNCTION E6(), SP'ENTRY ←6;
        .STX RX, LDX 6, BRU SP'ENTRY'LOGIC;

         FUNCTION E7(), SP'ENTRY ←7;
        .STX RX, LDX 7, BRU SP'ENTRY'LOGIC;

         FUNCTION E8(), SP'ENTRY ←8;
        .STX RX, LDX 8, BRU SP'ENTRY'LOGIC;

         FUNCTION E9(), SP'ENTRY ←9;
        .STX RX, LDX 9, BRU SP'ENTRY'LOGIC;

SP'ENTRY'LOGIC:.STX RP, EAX RP, STORS;
        IF M1'MODE DO;
            M1'TABLE.M1'TRAP'NO←-1;
            M1'TABLE.M1'TRAP'PAR←RP;
            RP←M1'TABLE.M1'TRAP'ADD;
            .EAX RP, LOADS;
        ENDIF;
        EMTRAP(11);
        END;

        PROGRAM TRAP'LOGIC;
        INCLUDE EMDECS;
*TRAP SAVED STATE
         MACRO LTSS←TSS;
        MACRO TRAPP←LTSS[0];
        MACRO TRAPX←LTSS[6];
        MACRO TRAPSR←LTSS[9];
        DI I,J,K,BYTE;
        DF SP'PCTR(0:6,23),SP'LR(1:6,23),SP'GR(2:6,23),SP'SPNO(0:2,5);
        DECLARE ARRAY SPCA[5];
        MACRO TRAPSYSERR←TRAP'SYSERR:ERRCODE,ERRNUMBER;
        DP BRU'OP←1,BRR'OP←51B,BRX'OP←41B;
        DF OPCODE(0:2,8);

*TRAP LOGIC
         FUNCTION TRAP'LOGIC(TRAP'NO,TRAP'PAR);
        READ'SPCS(0,SPCA//TRAPSYSERR);
        TRAPP←SPCA[0]$SP'PCTR;
        IF M1'MODE DO;
            I←SPCA[0]$SP'SPNO;
            READ'SPCS(-1,SPCA//TRAPSYSERR);
            IF TRAP'NO=QUIT'TRAP'NO AND TRAPP>=4B4 AND
             I=SPCA[0]$SP'SPNO DO;
                QUIT'FLAG←-1;
                GOTO TRAP'RET;
            ENDIF;
            M1'TABLE.M1'TRAP'PAR←TRAP'PAR;
            M1'TABLE.M1'TRAP'NO←TRAP'NO;
            TRAPP←M1'TABLE.M1'TRAP'ADD;
            GOTO LOADIT;
        ENDIF;
*FIXUP SAVED STATE IF TRAP WITHIN 940 PROGRAM
         IF TRAPP<4B4 DO;
            BCOPY(@SS[0],@LTSS[0],7);
            SAVEDSR←TRAPSR V' M940;
        ENDIF;
        BYTE←TRAP'PAR$PAGE'NUMBER;
* INSTRUCTION TRAP
         IF TRAP'NO=TI'TRAP'NO DO;
            GOTO TRAP'EM'ERROR IF TRAPP>=4B4;
            I←@INST'PANIC;
* READONLY PAGE TRAP
         ELSEIF TRAP'NO=PRO'TRAP'NO DO;
            GOTO TRAP'EM'ERROR IF TRAP'PAR>=4B4;
NO'PAGE:    I←@MEM'PANIC;
*EMPTY PAGE TRAP
         ELSEIF TRAP'NO=PNIM'TRAP'NO DO;
            GOTO FIND'PAGE IF TRAP'PAR<4B4;
*ACQUIRE PAGE IF IT IS EMULATOR (NOT NECESSARY?)
             K←ACQPMT(-1//TRAPSYSERR);
            NPPMT(K//TRAPSYSERR);
            SET'MAP'BYTE(-1,BYTE,K//TRAPSYSERR);
            GOTO TRAP'RET;
        ELSEIF TRAP'NO=QUIT'TRAP'NO DO;
            QUIT'FLAG←-1;
            GOTO TRAP'RET IF TRAPP>=4B4 ELSE I←@QUIT'TRAP;
        ELSE DO;
            GOTO TRAP'EM'ERROR;
        ENDIF;
MOD'RET:MODIFY'CALL(0,I,SPCA[0]$SP'LR,SPCA[0]$SP'GR,0//TRAPSYSERR);
TRAP'RET:SET'SPT'FIELD(-1,'TM',TRAP'BITS//TRAPSYSERR);
        TRAPP←@TRAP'LOGIC'RET;
LOADIT: .CLA, SUB 2, STA G' [2];
        .LDX 0, EAX $(LTSS$W0), LOADS;
TRAP'LOGIC'RET:SP'RETURN(//TRAPSYSERR);

TRAP'SYSERR:I←@TRAP'SERROR;
        GOTO MOD'RET;

TRAP'EM'ERROR:I←@TRAP'ERROR;
        GOTO MOD'RET;

*SPECIAL RETURN POINTS FROM TRAP LOGIC
TRAP'SERROR:DSYSERR;
TRAP'ERROR:EMTRAP(12);
MEM'PANIC:MEM'TRAP'FCN();
INST'PANIC:TRAP;
QUIT'TRAP:QUIT();

* TRIES TO FIND A PAGE FOR A PNIM TRAP
FIND'PAGE:I←FORK'IN'MAP;
TEST'LOCAL:GOTO TEST'BRANCH IF I.FN'LOCALMEM;
        I←I.FN'FATHER;
        GOTO NO'PAGE IF I.FN'NONEWMEM;
        K←I.FN'MAP$(MAP'BYTE[BYTE]);
        IF K#0 DO;
            FOR J←FORK'IN'MAP,J.FN'FATHER WHILE J#I DO;
                J.FN'MAP$(MAP'BYTE[BYTE])←K;
                SET'MAP'BYTE(-1,BYTE,K//TRAPSYSERR);
            ENDFOR;
            EMTRAP(18);
        ENDIF;
        GOTO TEST'LOCAL;
TEST'BRANCH:GOTO NO'PAGE IF TRAPP<4B4 AND FORK'IN'MAP.FN'MAP$
        (MAP'BYTE[TRAPP$PAGE'NUMBER])=0;
        GOTO NO'PAGE IF TRAPP=TRAP'PAR;
        K←ACQPMT(-1//TRAPSYSERR);
        NPPMT(K//TRAPSYSERR);
        FOR J←NCMEM+1 TO NPMTBYTES-1 DO;
            IF PMT'940[J]=0 DO;
                PMT'940[J]←K;
                SET'MAP'BYTE(-1,BYTE,K//TRAPSYSERR);
                BYTE'OWNER[J]←FORK'IN'MAP;
                FOR K←FORK'IN'MAP,K.FN'FATHER WHILE 1 DO;
                    K.FN'MAP$(MAP'BYTE[BYTE])←J;
                    GOTO TRAP'RET IF K=I;
                ENDFOR;
            ENDIF;
        ENDFOR;
        GOTO TRAP'EM'ERROR;
        END;

        PROGRAM RING'TRAPS;
        INCLUDE POPVARS;
        SET'LE;
        JUMP'LE;

         FUNCTION RING'TRAP'1(), TRAP'ENTRY ←1;
        .STX RX, LDX 1, BRU RING'TRAP'LOGIC;

         FUNCTION RING'TRAP'2(), TRAP'ENTRY ←2;
        .STX RX, LDX 2, BRU RING'TRAP'LOGIC;

         FUNCTION RING'TRAP'3(), TRAP'ENTRY ←3;
        .STX RX, LDX 3, BRU RING'TRAP'LOGIC;

         FUNCTION RING'TRAP'4(), TRAP'ENTRY ←4;
        .STX RX, LDX 4, BRU RING'TRAP'LOGIC;

         FUNCTION RING'TRAP'5(), TRAP'ENTRY ←5;
        .STX RX, LDX 5, BRU RING'TRAP'LOGIC;

         FUNCTION RING'TRAP'6(), TRAP'ENTRY ←6;
        .STX RX, LDX 6, BRU RING'TRAP'LOGIC;

         FUNCTION RING'TRAP'7(), TRAP'ENTRY ←7;
        .STX RX, LDX 7, BRU RING'TRAP'LOGIC;

         FUNCTION RING'TRAP'8(), TRAP'ENTRY ←8;
        .STX RX, LDX 8, BRU RING'TRAP'LOGIC;

         FUNCTION RING'TRAP'9(), TRAP'ENTRY ←9;
        .STX RX, LDX 9, BRU RING'TRAP'LOGIC;

         FUNCTION RING'TRAP'10(), TRAP'ENTRY ←10;
        .STX RX, LDX 10, BRU RING'TRAP'LOGIC;

RING'TRAP'LOGIC:.STX RP, EAX RP, STORS;
        IF M1'MODE AND ((1 RSH RP) A' M1'RING'BITS) DO;
            M1'TABLE.M1'RING'P←RING'P;
            M1'TABLE.M1'RING'PAR←RING'PAR;
            M1'TABLE.M1'RING'NO←RP;
            RP←M1'TABLE.M1'RING'ADD;
        ENDIF;
        IF RP=5 DO;
            TRAP IF RING'P=SYSPOP'BRU'ADD;
        ELSEIF RP=9 DO;
            RESTORE'STACK;
        ENDIF;
        EMTRAP(RP);
        END;

        PROGRAM M1'MODE;
        INCLUDE EMDECS;
        DI I;
        DECLARE ARRAY DIRIO;
        MONITOR DISK'IO←200B;

         FUNCTION M1'INIT();
        M1'RING'BITS←SAVEDA;
        M1'TRAP'MASK←SAVEDB;
        M1'TABLE←SAVEDX$ADDR14;
        RETURN;

         FUNCTION M1'START();
        TRAP IF M1'TABLE<0;
        BCOPY(@RSS[0],@SS[0],10);
        SET'SPT'FIELD(-1,'TM',M1'TRAP'MASK//SYSERR);
        RP←RP+1;
        RS← RS A' (N' M940);
        IF QUIT'FLAG DO;
            SET'SPT'FIELD(-1,'TM',TRAP'BITS//SYSERR);
            QUIT();
        ENDIF;
        M1'MODE←1;
        RESTORE'STACK;
        .EAX RP, LOADS;

         FUNCTION DIRECT'IO();
        DIRIO$W0←SAVEDB-1+6B7;
        DIRIO$W1←SAVEDA;
        TRAP IF SAVEDX>34000B OR SAVEDX<0 OR SAVEDA<0 OR SAVEDB<=0 OR
         SAVEDA+SAVEDB>4B4;
        DISK'IO(DIRIO,SAVEDX);
        RETURN;

         FUNCTION READ'USER();
        TRAP IF SAVEDX<4B4 OR SAVEDX>4B5-2;
        SAVEDA←SAVEDX.W0;
        SAVEDB←SAVEDX.W1;
        SAVEDX←SAVEDX+2;
        RETURN;
        END;

        PROGRAM EXIT'M1;
        INCLUDE EMDECS;

         FUNCTION EXIT'M1'MODE(I), POP ←0;
        .STX SAVEDX, EAX SAVEDP, STORS;
        SAVEDL←@SAVE'LE[0];
        SAVEDSR←SAVEDSR V' M940;
*USE RETURN TO FIND P
         .LDA L' [0], SUB 1, STA SAVEDP;
        M1'MODE←0;
        SET'SPT'FIELD(-1,'TM',TRAP'BITS//SYSERR);
*UNWIND STACK
         .LDA EMSP, STA G' [2];
        POPRET;
        END;

        PROGRAM DEBUG;
        INCLUDE EMDECS;
        UTILITY SET'COM'LINE←7;

         FUNCTION DEBUG(STRING COM'LINE);
        SET'COM'LINE(COM'LINE);
        EE();
        RETURN;

       COMMON GLOBALS;

       UNKNOWN MONITOR SP'RETURN ← 116;
       UNKNOWN UTILITY PRINT'STRING ← 45;
       INTEGER UTILITY SYS'TIME'NUM ← 80;

* STACK DEFINITIONS
       DECLARE PARAMETER SIZE ← 400B;
       DECLARE ARRAY STACK[SIZE];
       DECLARE PARAMETER
          INITIAL'SP ← @STACK[0], INITIAL'SL ← @STACK[SIZE-1];
       DECLARE INTEGER
          STACK'POINTER = G'[2], STACK'LIMIT = G'[3];

* VARIABLES FOR FUNCTION CALL FAILURES
       DECLARE INTEGER CODE, NUMBER;

* STRING THINGS
       DECLARE STRING FIELD STRING'DESC(0);
       DECLARE FIELD CHAR'SIZE(0:2,3);
       DECLARE FIELD BP(0), RP(1), WP(2), EP(3);

       END;

       PROGRAM ENTRIES;

       INCLUDE GLOBALS;



       FUNCTION SP'TRAP'ENTRY(), SP'ENTRY ← 0;
       .HLT 0;

       FUNCTION INTERRUPT'ENTRY(), SP'ENTRY ← 1;
       .HLT 0;

       FUNCTION INITIAL'ENTRY(), SP'ENTRY ← 2;
       STACK'POINTER ← INITIAL'SP;
       STACK'LIMIT ← INITIAL'SL;
       DATE();
       .HLT 0;

       FUNCTION CONTINUE'ENTRY(), SP'ENTRY ← 3;
       .HLT 0;



       END;

       COMMON DATE'DECS;

       DECLARE STRING ARRAYONE STRING'MON[12] ←
           ("JANUARY","FEBRUARY","MARCH","APRIL","MAY","JUNE","JULY",
            "AUGUST","SEPTEMBER","OCTOBER","NOVEMBER","DECEMBER");

       DECLARE STRING ARRAYONE STRING'WEEK[7] ←
           ("SUNDAY","MONDAY","TUESDAY","WEDNESDAY","THURSDAY",
            "FRIDAY","SATURDAY");


       END;

       PROGRAM DATE;

*THIS PROGRAM SIMPLY PRINTS THE CURRENT DATE AND TIME OF THE SYSTEM

       INCLUDE GLOBALS,DATE'DECS;
       DECLARE INTEGER
           YEAR,
           MONTH,
           WDAY,
           MDAY,
           SYS'HOUR,
           CPU'HOUR,
           MIN,
           SEC;

       DECLARE LONG REAL'TIME;
       DECLARE STRING ST(45), AMPM(2), CRLF ← "&M&J";

FUNCTION DATE();

       SETS(ST);
       SETS(AMPM);

       SYS'TIME'NUM(:YEAR,MONTH,WDAY,MDAY,SYS'HOUR,MIN,SEC);

       APPEND(ST,STRING'WEEK[WDAY]//EXIT);
       APPEND(ST,"  "//EXIT);
       APPEND(ST,STRING'MON[MONTH]//EXIT);
       WCI(' ',ST//EXIT);
       CNS(MDAY,ST//EXIT);
       APPEND(ST,", "//EXIT);
       CNS(YEAR,ST//EXIT);
       APPEND(ST,"  "//EXIT);

       IF SYS'HOUR => 12 DO;
           SYS'HOUR ← SYS'HOUR - 12 IF SYS'HOUR > 12;
           SCOPY(AMPM,"PM"//EXIT);
       ELSE DO;
           SYS'HOUR ← 12 IF SYS'HOUR=0;
           SCOPY(AMPM,"AM"//EXIT);
       ENDIF;

       CNS(SYS'HOUR,ST//EXIT);
       WCI(':',ST//EXIT);
       WCI('0',ST) IF MIN < 10;
       CNS(MIN,ST//EXIT);
       WCI(':',ST//EXIT);
       WCI('0',ST) IF SEC < 10;
       CNS(SEC,ST//EXIT);
       WCI(' ',ST//EXIT);
       APPEND(ST,AMPM//EXIT);
       APPEND(ST,CRLF//EXIT);

       PRINT'STRING(-1,ST,0//EXIT: CODE, NUMBER);

EXIT:  SP'RETURN(//HALT: CODE, NUMBER);
HALT:  .HLT 0;

END;

       PROGRAM CNS;

*      THIS FUNCTION APPENDS A SINGLE PRECISION INTEGER TO A STRING
* AFTER CONVERTING THE INTEGER FROM INTERNAL REPRESENTATION TO CHAR-
* ATER REPRESENTATION.  THIS FUNCTION FAILS IF THE BASE THE NUMBER WILL
* BE CONVERTED TO IS OUTSIDE THE ALLOWABLE RANGE OF 2 TO 36, INCLUSIVE,
* OR IF THE STRING PASSED TO IT CAN'T HOLD ALL THE CHARACTERS OF THE 
* BER.

       INCLUDE GLOBALS;

       DECLARE INTEGER
          BASE,              /* THE BASE THE NUMBER WILL BE CONVERTED */
                             /*   TO                                  */
          CHAR,              /* THE CHARACTER TO WRITE INTO THE STRING*/
          COUNT,             /* JUST A COUNTER FOR FOR LOOPS          */
          LENGTH'TEMP,       /* LENGTH OF THE STRING TEMP             */
          NUMBER,            /* THE NUMBER TO CONVERT                 */
          NUMBER'OF'CHARS,   /* BITS (18-23) OF SIGN'NUM'CHARS        */
          SIGN'FLAG,         /* SET IF NEGATIVE NUMBERS ARE TO BE     */
                             /*   CONVERTED SIGNED                    */
          SIGN'NUM'CHARS;    /* DETERMINES IF THE NUMBER WILL BE      */
                             /*   SIGNED AND HOW MANY CHARACTERS TO   */
                             /*   GENERATE.  IF IT IS 0, IT WILL BE   */
                             /*   CONVERTED SIGNED AND WITHOUT PAD-   */
                             /*   DING OR TRUNCATION                  */

       DECLARE STRING
          TEMP (24),         /* A TEMPORARY STRING EACH DIGIT IS      */
          WORKING'NAME;      /* TO KEEP SPL HAPPY                     */
                             /*   WRITTEN INTO                        */



       UNKNOWN FUNCTION CNS(NUMBER, STRING @STRING'CREATED,
          SIGN'NUM'CHARS, BASE), FRETURN;

       FRETURN IF BASE < 2 OR BASE > 36;
       WORKING'NAME ← STRING'CREATED.STRING'DESC;
       SIGN'FLAG ← (-1 IF SIGN'NUM'CHARS >= 0 AND NUMBER < 0 ELSE 0);
       NUMBER ← -NUMBER IF SIGN'FLAG;

* BE CLEVER AND WRITE THE STRING BACKWARDS
       TEMP$RP ← TEMP$WP ← TEMP$EP;

       IF NUMBER # 0 DO;
          WHILE NUMBER # 0 DO;
             .LDA NUMBER, LSHD -23, DIV BASE, STA NUMBER, STB CHAR;
             WCD(CHAR + ('0' IF CHAR < 10 ELSE 'A' - 10), TEMP);
          ENDFOR;
       ELSE DO;
          WCD('0', TEMP);
       ENDIF;

       WCD('-', TEMP) IF SIGN'FLAG;

* ALL WE NEED NOW IS HOW MANY CHARACTERS TO GENERATE
       NUMBER'OF'CHARS ← SIGN'NUM'CHARS A' 77B;
       LENGTH'TEMP ← LENGTH(TEMP);

* TRUNCATE CHARACTERS IF NECESSARY
       IF NUMBER'OF'CHARS # 0 AND NUMBER'OF'CHARS < LENGTH'TEMP DO;
          TEMP$RP ← INCDES(TEMP$EP, -NUMBER'OF'CHARS);

* OR PAD
       ELSEIF NUMBER'OF'CHARS # 0 AND NUMBER'OF'CHARS > LENGTH'TEMP DO;
          FOR COUNT ← LENGTH'TEMP + 1 TO NUMBER'OF'CHARS DO;
             WCI(' ', WORKING'NAME//FRETURN);
          ENDFOR;
       ENDIF;

       FOR COUNT ← 1 TO LENGTH(TEMP) DO;
          CHAR ← GCI(TEMP);
          WCI(CHAR, WORKING'NAME//FRETURN);
       ENDFOR;

FINISH:STRING'CREATED.WP ← WORKING'NAME$WP;
       RETURN;


       END;

       PROGRAM APPEND;

*      THIS PROGRAM BLOCK TAKES AS ITS ARGUMENTS TWO STRINGS WHICH IT
* ATTEMPTS TO CONCATENATE TOGETHER.  THERE ARE TWO ENTRY POINTS TO THE
* PROGRAM, SCOPY, AND APPEND.  SCOPY IS JUST A SPECIAL CASE OF APPEND
* IN WHICH ONE STRING WILL BE COPIED TO THE BEGINNING OF THE OTHER
* STRING.
*      I TRIED TO BE CONSISTENT AND DECLARE ALL VARIABLES EXPLICITLY,
* IN "DECLARE" STATEMENTS, BUT THERE SEEM TO BE PROBLEMS WITH DECLARING
* A STRING WHICH WILL BE AN ARGUMENT TO A FUNCTION AND LATER IN THE
* FUNCTION DEFINITION, INFORMING SPL THAT THAT STRING WILL BE CALLED
* BY WHAT I CONSIDER TO BE CALL BY NAME.

       INCLUDE GLOBALS;

       DECLARE STRING
          ADDENDUM,          /* THE STRING FROM WHICH CHARACTERS ARE  */
                             /*   COPIED INTO THE FIRST ARGUMENT      */
*         OBJECT,            /* THE STRING TO WHICH CHARACTERS WILL   */
                             /*   BE COPIED                           */
          WORKING'NAME;      /* TO KEEP SPL HAPPY                     */

       DECLARE INTEGER
          COUNT,             /* JUST A COUNTER FOR A FOR LOOP         */
          LENGTH'ADDENDUM;   /* LENGTH OF THE STRING ADDENDUM         */



* SCOPY - COPY THE SECOND STRING INTO THE FIRST
       UNKNOWN FUNCTION SCOPY(STRING @OBJECT, ADDENDUM), FRETURN;
       OBJECT.WP ← OBJECT.RP ← OBJECT.BP;



* APPEND - APPEND THE SECOND STRING TO THE FIRST
       UNKNOWN FUNCTION APPEND(STRING @OBJECT, ADDENDUM), FRETURN;
       WORKING'NAME ← OBJECT.STRING'DESC;
       FRETURN IF ADDENDUM$CHAR'SIZE # WORKING'NAME$CHAR'SIZE;
       LENGTH'ADDENDUM ← LENGTH(ADDENDUM);
       FRETURN IF
          LENGTH'ADDENDUM > LNGDES(WORKING'NAME$WP, WORKING'NAME$EP);

       WCI(GCI(ADDENDUM), WORKING'NAME) FOR COUNT ← 1 TO LENGTH'ADDENDUM;

       OBJECT.WP ← WORKING'NAME$WP;
       RETURN;


       END;
       PROGRAM SYSTEM'VERSION;

       STRING MONITOR MON'VERSION ← 254;

       DECLARE STRING UTIL'VERSION←"U:A12",   /* CHANGE W/ EACH NEW VERS. */
                      S,T(20);


       STRING ENTRY SYS'VERSION(S), UTILITY ← 9;

       SCOPY(S,UTIL'VERSION//NEXT);
       WCI('/',S//NEXT);
NEXT:  MON'VERSION(T:T);
       APPEND(S,T//RET);
RET:   RETURN S;

       END;

        COMMON SYSCALLS;

* MCALL DECLARATIONS

         MACRO ARBMC ← UNKNOWN MONITOR;
        MACRO INTMC ← INTEGER MONITOR;
        MACRO STMC ← STRING MONITOR;
        MACRO LNMC ← LONG MONITOR;
        MACRO LNLNMC ← LONGLONG MONITOR;

* CALLS TO MANIPULATE MIBS AND SIBS
         INTMC CREATE'MIB ← 190;
        ARBMC READ'MIBOB'INDEX ← 0;
        ARBMC READ'MIBOB'NAME ← 1;
        ARBMC SET'MIBOB'NAME ← 2;
        ARBMC SET'MIBOB'ACCESS ← 3;
        ARBMC SET'LOCK'LIST ← 4;
        ARBMC DELETE'MIBOB ← 5;
        INTMC CREATE'MIBOB ← 6;
        ARBMC SET'MIB'ACCESS ← 10;
        INTMC READ'MIB'ACCESS ← 11;
        ARBMC SET'MIBOB'VALUE ← 12;
        INTMC COPY'MIBOB ← 14;
        ARBMC SET'NO'CHARGE ← 15;*** ???
        INTMC READ'MIB'SPACE ← 16;
        ARBMC SET'FILE'LOCK ← 18;*?* UNIMPLEMENTED
        ARBMC SET'DURABILITY ← 28;*** ???

* OFT CALLS
         INTMC MOPEN'FILE ← 19;
        ARBMC MREAD'OFT ← 20;
        ARBMC SET'OFT'AL ← 21;
        INTMC MSET'OFT'CL ← 22;
        ARBMC SET'FILE'LENGTH ← 23;* IMPROVE THIS FOR UTS
        INTMC CR'FILE'PAGE ← 24;
        INTMC DEL'FILE'PAGE ← 25;
        INTMC NEXT'FILE'PAGE ← 26;
        ARBMC MOVE'PAGE'PMT ← 27;

* PMT CALLS
         INTMC ACQUIRE'PMT ← 50;
        ARBMC NEW'PMT'PAGE ← 51;
        ARBMC CLEAR'PMT ← 53;
        ARBMC DELETE'PMT ← 54;
        ARBMC SET'PMT'AL ← 55;
        ARBMC SET'PMT'CL ← 56;
        ARBMC SET'PMT'RO ← 57;
        ARBMC READ'PMT ← 58;

* WORKING SET CALLS
         ARBMC PUT'PAGE'DWS ← 65;
        ARBMC PUT'PAGE'CWS ← 66;
        INTMC DEL'PAGE'DWS ← 67;
        INTMC DEL'PAGE'CWS ← 68;
        INTMC READ'LWS ← 70;
        ARBMC SET'LWS ← 71;

* SPT CALLS
         INTMC MCREATE'SP ← 90;
        ARBMC MDESTROY'SP ← 91;
        ARBMC MREAD'SPT ← 95;
        ARBMC READ'SPCS ← 96;
        INTMC MRD'SPT'FIELD ← 97;
        ARBMC MST'SPT'FIELD ← 98;
        ARBMC READ'MAP ← 99;
        ARBMC SET'MAP ← 100;
        INTMC READ'MAP'BYTE ← 101;
        ARBMC SET'MAP'BYTE ← 102;
        INTMC READ'SPS'PARAM ← 106;

* SPCS CALLS
         ARBMC SP'CALL ← 111;
        ARBMC SP'JUMP ← 112;
        ARBMC SP'TRAP ← 113;
        ARBMC TRAP'RETURN ← 114;
        ARBMC SP'BRANCH ← 115;
        ARBMC SP'RETURN ← 116;
        ARBMC JUMP'RETURN ← 117;
        ARBMC MARK'CALL ← 118;
        ARBMC DELETE'CALL ← 119;
        ARBMC MODIFY'CALL ← 120;

* PROCESS CALLS
         INTMC COPY'PMT'PROC ← 130;
        INTMC ACTIVATE'PROC ← 132;
        ARBMC TRANSFER'TERM ← 133;
        ARBMC MAKE'DORMANT ← 134;
        ARBMC INIT'PROC'PAGE ← 135;
        ARBMC INIT'PROC'MAP ← 136;
        ARBMC INIT'SPT ← 137;
        INTMC READ'PROC'PARAM ← 211;
* RESOURCE CALLS
         ARBMC MOVE'DISK'RES←149;

* IWS CALLS
         ARBMC SET'PROC'INT ← 163;
        ARBMC QUIT'BLOCK ← 164;
        INTMC GET'INT'NO ← 165;
        ARBMC READ'ICT ← 166;
        ARBMC ALLOW'INTS ← 168;
        ARBMC REFUSE'INTS ← 169;
        ARBMC BLOCK ← 170;
        ARBMC SET'ICT ← 172;
        ARBMC SET'ICT'CL ← 173;
        INTMC ACQUIRE'ICT ← 174;

* CHIO CALLS
         ARBMC SET'LINE'FIELD ← 180;
        ARBMC READ'LINE'TABLE ← 181;
        ARBMC READ'STRING'BRK ← 182;
        ARBMC WRITE'STRING ← 183;

* MISCELLANEOUS
         LNMC READ'CLOCK ← 210;

* UCALL DECLARATIONS

         MACRO ARBUC ← UNKNOWN UTILITY;
        MACRO INTUC ← INTEGER UTILITY;
        MACRO CHRUC ← CHARACTER UTILITY;
        MACRO STUC ← STRING UTILITY;
        MACRO LNUC ← LONG UTILITY;

* MISCELLANEOUS UCALLS
         ARBUC BREAK'POINT ← 0;*             UCALL FOR DEBUGGING PROGRAMS
        STUC ERRORMSG ← 1;*                RETURN SYSTEM ERROR MESSAGE
        STUC GET'PARAM ← 2;*               STRIP PARAMETER FROM STRING
        STUC GET'COM'LINE ← 3;*            GET CURRENT COMMAND LINE FROM UTS
        INTUC ABRV'LKP ← 4;*                LOOK UP ABBREVIATED NAME IN STARY
        INTUC CON'ABRV'LKP ← 5;*            CONTINUE SAME IN NEW STARY
        ARBUC GET'CMP'COMLINE←6;*           GET COMPLETE COMLINE

* FILE SYSTEM CALLS
         ARBUC NAME'SEARCH ← 10;*            CONVERT FILE ST TO UTS NAME
        ARBUC SPECIAL'SEARCH ← 11;*         VARIATION OF ABOVE
        INTUC CONV'NAME ← 12;*              CONVERT FROM UTS TO MON FILE NAME
        ARBUC SPREAD'NAME ← 13;*            SPLIT FILE NAME STRING INTO COMP.
        ARBUC READ'MIBOB'VALUE ← 14;*       READ 'VALUE' OF MIB OBJECT
        ARBUC DELETE'FILE ← 15;*            DELETE FILE AND CONTENTS
        INTUC OPEN'FILE ← 16;*              OPEN FILE W/WO LOCKING
        ARBUC CLOSE'FILE ← 17;*             CLOSE AND UNLOCK FILE
        ARBUC READ'OFT ← 18;*               READ OFT
        INTUC READ'OFT'FIELD ← 19;*         READ OFT FIELD
        ARBUC SET'OFT'CL ← 20;*             SET OFT CONTROL LOCK
        ARBUC CONV'KEY ← 21;*               CONVERT DEFAULT ACCESS KEY

* EXTENDED SPS CALLS
         INTUC CREATE'SSP ← 30;*             CREATE SUBSIDIARY SUB-PROCESS
        INTUC CREATE'PSP ← 31;*             CREATE PARALLEL SUB-PROCESS
        ARBUC ATTACH ← 32;*                 ATTACH PI FILE TO SUB-PROCESS
        ARBUC DESTROY'SP ← 33;*             DESTROY SUB-PROCESSES
        ARBUC READ'SPT ← 34;*               READ SPT
        INTUC READ'SPT'FIELD ← 35;*         READ SPT FIELD
        ARBUC SET'SPT'FIELD ← 36;*          SET SPT FIELD
        STUC READ'SPNAME ← 37;*            READ SUB-PROC NAME
        ARBUC SET'SPNAME ← 38;*             SET SUB-PROC NAME
        INTUC SPNAME'SEARCH ←39;*           LOOK UP SP NAME

* CIOS MANIPULATION
         INTUC CREATE'CIOS ← 40;*            CREATE CONTROL I/O STREAM
        INTUC READ'CIOS'FIELD ← 41;*        READ CIOS FIELD
        ARBUC SET'CIOS'FIELD ← 42;*         SET (SOME) CIOS FIELDS
        ARBUC SET'CIOS'INPUT ← 43;*         SET UP FOR INPUT
        ARBUC SET'CIOS'OUTPUT ← 44;*        SET UP FOR OUTPUT

* CIOS INPUT/OUTPUT
         ARBUC PRINT'STRING ← 45;*           WRITE STRING ON CIOS
        ARBUC PRINT'CHAR ← 46;*             WRITE (= BUFFER) CHAR ON CIOS
        ARBUC START'OUTPUT ← 47;*           DUMP OUTPUT BUFFER
        STUC READ'LINE ← 48;*              READ NEXT INPUT LINE
        STUC EDIT'LINE ← 49;*              EDIT CURRENT LINE
        CHRUC READ'CHAR ← 50;*              READ NEXT CHARACTER
        ARBUC BLOCK'OB'EMPTY ← 51;*         WAIT UNTIL OUT BUFFER IS EMPTY

* USER, ACCOUNT, AND GROUP PROFILES
         STUC READ'UP'ITEM ← 60;*           READ ITEM FROM USER PROFILE
        STUC READ'UP'NAMES ← 61;*          READ NAMES OF UP ITEMS
        ARBUC SET'UP'ITEM ← 62;*            SET (CREATE) VALUE OF UP ITEM
        ARBUC SET'UP'ACCESS ← 63;*          SET ACCESS TO UP ITEM
        LNUC FIND'MIB ← 64;*               CONVERT USER NAME/NUMBER TO MIB ADDR
        ARBUC CREATE'UP'ENTRY ← 65;*        CREATE USER/UP ENTRY
        ARBUC DELETE'UP'ENTRY ← 66;*        DELETE USER/UP ENTRY

* PROCESSES, AND PROCESS PROFILE
         ARBUC CREATE'PROCESS ← 70;*         CREATE/INITIALIZE PROCESS
        STUC READ'PP'ITEM ← 71;*           READ ITEM FROM PROCESS PROFILE
        STUC READ'PP'NAMES ← 72;*          READ NAMES OF PP ITEMS
        ARBUC SET'PP'ITEM ← 73;*            SET (CREATE) VALUE OF PP ITEM
        ARBUC DESTRY'THIS'PROC ← 74;*       DESTROY THIS PROCESS
* TIME STUFF
         INTUC SYS'TIME'NUM←80;*             NUMERICAL SYSTEM TIMES
        INTUC ANY'TIME'NUM←81;*            NUMERICAL SPECIFIC TIMES
        STUC ANY'TIME'CHR←82;*             CHARACTER SPECIFIC TIMES
        END;

        COMMON DECDECS;
*
* SHORT DECLARATION MACROS FOR SPL
*

         MACRO INT ← DECLARE INTEGER;
        MACRO OCT ← DECLARE OCTAL;
        MACRO PTR ← DECLARE POINTER;
        MACRO CHR ← DECLARE CHARACTER;
        MACRO   ST ← DECLARE STRING;
        MACRO   LN ← DECLARE LONG;
        MACRO LNLN ← DECLARE LONGLONG;
        MACRO   LB ← DECLARE LABEL;

         MACRO OCTFL ← DECLARE OCTAL FIELD;
        MACRO INTFL ← DECLARE INTEGER SIGNED FIELD;
        MACRO PTRFL ← DECLARE POINTER FIELD;
        MACRO CHRFL ← DECLARE CHARACTER FIELD;
        MACRO   STFL ← DECLARE STRING FIELD;
        MACRO   LNFL ← DECLARE LONG FIELD;
        MACRO ARYFL ← DECLARE ARRAY FIELD;
        MACRO   FNFL ← DECLARE FUNCTION FIELD;

         MACRO INTARY ← DECLARE INTEGER ARRAY;
        MACRO OCTARY ← DECLARE OCTAL ARRAY;
        MACRO PTRARY ← DECLARE POINTER ARRAY;
        MACRO CHRARY ← DECLARE CHARACTER ARRAY;
        MACRO   STARY ← DECLARE STRING ARRAY;
        MACRO   LNARY ← DECLARE LONG ARRAY;
        MACRO   LBARY ← DECLARE LABEL ARRAY;
        MACRO FLARY ← DECLARE FIELD ARRAY;
        MACRO FNARY ← DECLARE FUNCTION ARRAY;

         MACRO INTARY1 ← DECLARE INTEGER ARRAYONE;
        MACRO PTRARY1 ← DECLARE POINTER ARRAYONE;

         MACRO INTFN ← DECLARE INTEGER FUNCTION;

         MACRO ARBENT ← UNKNOWN ENTRY;
        MACRO INTENT ← INTEGER ENTRY;
        MACRO OCTENT ← POINTER ENTRY;
        MACRO PTRENT ← POINTER ENTRY;
        MACRO CHRENT ← CHARACTER ENTRY;
        MACRO STENT ← STRING ENTRY;
        MACRO LNENT ← LONG ENTRY;
        MACRO LBENT ← LABEL ENTRY;
        MACRO ARYENT ← ARRAY ENTRY;

         MACRO ARBEXT ← DECLARE UNKNOWN EXTERNAL;
        MACRO INTEXT ← DECLARE INTEGER EXTERNAL;
        MACRO OCTEXT ← DECLARE OCTAL EXTERNAL;
        MACRO PTREXT ← DECLARE POINTER EXTERNAL;
        MACRO CHREXT ← DECLARE CHARACTER EXTERNAL;
        MACRO STEXT ← DECLARE STRING EXTERNAL;
        MACRO LNEXT ← DECLARE LONG EXTERNAL;
        MACRO LBEXT ← DECLARE LABEL EXTERNAL;
        MACRO ARYEXT ← DECLARE ARRAY EXTERNAL;


         MACRO LTABLE(F) ← F$FLDWDSP+1;
        INTFL FLDWDSP(0: 13,23);

* LENGTHS OF NAMES
         INT LMN ← 4, LTY ← 1, LFN ← LMN+LTY;
        INT NBY ← 4, LNCH ← 24/NBY, NMNCH ← LMN*NBY,
         NTYCH ← LTY*NBY, NFNCH ← LFN*NBY, NCMCH ← 90;
        END;

        COMMON MACHINE'DECS; INCLUDE DECDECS;
*
* DECLARATIONS FOR MACHINE-DEPENDENT PROGRAMMING
*

* LOW-G DEFINITIONS
         PTR STACK'PTR = G' [2], STACK'LIM = G' [3],
         RTRAP'PARAM = G' [5], RTRAP'LOC = G' [4];

* FIELDS IN BLL DESCRIPTOR
         PTRFL BRDPC(0: 6,23), BRDLR(1: 6,23);

* STATE DEFINTIONS
         INT PSTLOC ← 0, ASTLOC ← 1, BSTLOC ← 2, CSTLOC ← 3, DSTLOC ← 4,
         XSTLOC ← 6, LSTLOC ← 7, GSTLOC ← 8, ESTLOC ← 5, SSTLOC ← 9,
         LSTATE ← 10;

* FIELDS FOR TRAP DEFINITIONS
         PTRFL ADDR(0: 6,23); OCTFL SP'TNO(-2), SP'TPAR(-1),
        BLL'CLASS(0: 3,5), UTSE'CLASS(0: 0,1),
         UTSE'SPTNO(0: 1,5), UTSE'RTNO(0: 2,5);
        END;

        COMMON COMDECS; INCLUDE DECDECS, SYSCALLS;
*
* COMMON DECLARATIONS FOR CODING
*

* GENERALLY USEFUL MACROS

         MACRO NAMSET(S,L,A,B) ← SETUP(S,L,A,B) & S$WP ← S$EP;
        MACRO EMPTY(S) ← LNGDES(S$RP, S$WP) <= 0;*** WP=RP OR WP=BP?
        MACRO REPEAT ← WHILE 1 DO;
        MACRO ENDRPT ← ENDFOR;
        MACRO FDISP(F) ← RUNTIME'FAILURE() IF F$FLDSTB # 0 OR
         F$FLDSIZE # 24 ELSE F$FLDWDSP;
        OCTFL FLDSTB(0: 8,12), FLDSIZE(0: 3,7);

* ERROR MACROS
         MACRO NC'PUNT ← RUNTIME'FAILURE();* FOR NORMAL CALLS (EXPRESSIONS)
        MACRO LF'PUNT ← VALUE NC'PUNT;* FOR LIBRARY FUNCTIONS
        MACRO SF'PUNT ← LF'PUNT: ERCODE, ERMSNO;* FOR SYSTEM CALLS

* QUIT ACTION MACROS
         MACRO QUIT'PUNT(L) ← VALUE GOTO L IF ERCODE = 'QIT' ELSE
         RUNTIME'FAILURE(): ERCODE, ERMSNO;
        MACRO QUIT'PUNTX(L, X) ← VALUE GOTO L IF ERCODE = 'QIT' ELSE
         RUNTIME'FAILURE(): X, ERCODE, ERMSNO;

* PARAMETRIC CHARACTER DEFINITIONS
         CHR SCHERALD ← '>' /* SUB-COMMAND HERALD */,
         BELCH ← 303B /* BELL */, NULCH ← 300B /* NULL */,
         NLCH ← 307B /* NEW LINE */,
         LFCH ← 310B /* LINE FEED */,
         MBCH ← 200B /* ZERO MULTIPLE BLANKS */,
         SQTCH ← '&'' /* SINGLE QUOTE */,
         DQTCH ← '"' /* DOUBLE QUOTE */,
         SEPCH ← '-' /* SEPARATOR */;

* STRING POINTER FIELDS
         OCTFL BP(0) /* BEGINNING */, RP(1) /* READER */,
         WP(2) /* WRITER */, EP(3) /* END */;
* CHARACTER FIELDS
         CHRFL CH0(0: 0,7), CH1(0: 8,15), CH2(0: 16,23);
* BEAD LENGTH FIELD
         PTRFL LENGF(-1: 6, 23);

* FIELDS IN UTILITY FILE NAME
         LNFL UFNUN(0) /* USER NUMBER/DISK ADDRESS */;
        OCTFL UFNEN(2) /* OBJECT ENTRY-NUMBER */,
         UFNFN(3) /* FILE NAME */, UFNMN(3) /* MAIN NAME */,
         UFNTY(3+LMN) /* TYPE WORD */;

* FIELDS FOR UNO/DKA
         OCTFL UNDKUN(0),
         UNDKDK(1);

         INT LUFN ← LTABLE(UFNTY);* LENGTH OF UTILITY FILE:NAME

         INT CB'PMT ← 1;* PMT ADDRESS OF CONTEXT BLOCK

* DECLARATIONS OF COMMON FUNCTIONS

* SPL RUNTIME FUNCTIONS
*ARBEXT    SCOPY, APPEND, CNS, RUNTIME'FAILURE;
         ARYEXT LBARY'KLUDGE;*, AR'DESC;
        PTREXT SBASE; INTEXT ARRAYUB, ARRAYLB;* STEXT ST'DESC;
        LNEXT LONG'ADD, LONG'SUB; INTEXT LONG'LE, LONG'LT;

* STORAGE ALLOCATOR
         PTREXT STKMAKE;*, MAKE, SETZONE;
*ARBEXT    STORINIT, SELZONE, EXTZONE, FREE, FREEZONE;
        END;

        COMMON UQNDECS; INCLUDE DECDECS;

* UNIQUE NAME FIELDS
         OCTFL UQNTY(0: 0,1), UQNPMB(0: 0,0), UQNLFB(0: 1,1),
         UQNOWN(0: 2,17), UQNHFN(0: 18,23);
        OCTFL UQNLFN(1: 0,12), UQNLPN(1: 13,23),
         UQNSFN(1: 0,15), UQNSPN(1: 16,23);
        END;

        COMMON BFSDECS; INCLUDE UQNDECS;

* OBJECT TYPE-CODES
         INT SIBSFCD ← 0, SIBLFCD ← 1, SIBPRCD ← 2, SIBAKCD ← 3,
         SIBRSCD ← 4, SIBOWCD ← 5, SIBFRCD ← 6,
         SIBSCCD ← 14, SIBLKCD ← 15;

* ACCESS KEY FIELDS
         OCTFL ACK0(0), ACK1(1:0,7), ACKUN(1:8,23);
        INT NORM'FIL'AC ← 0357B;* P(NO) F(RW) O(OW) - NORMAL ACCESS
        END;

        COMMON OFTDECS; INCLUDE BFSDECS;

* FIELDS IN OFT
         OCTFL OFTUB(0: 0,0), OFTRB(0: 1,1), OFTWB(0: 2,2), OFTXB(0: 3,3),
         OFTOB(0: 4,4), OFTMIX(0: 6,12),
         OFTAL(0: 15,23);* BETTER CHECK THIS WITH REVISION

         OCTFL OFTCL(1: 15,23),
         OFTOT(2: 0,3), OFTPIB(2: 8,15), OFTPMIB(2: 16,23);
        LNFL OFTUN(3);

         INT NOFT ← 16, LOFT ← LTABLE(OFTUN)+1;
        END;

        COMMON SIBDECS; INCLUDE BFSDECS;
*
* DECLARATIONS FOR SIB
*

* FIELDS IN SIB NAME (SIBN)
         OCTFL SIBNOT(0: 1,4),
         SIBNLN(0: 10,23),
         SIBNAA(1: 1,4), SIBNEN(1: 10,23),
         SIBNMN(2), SIBNFN(2);
        OCTFL SIBNTY(SIBNMN$FLDWDSP+LMN),
         SIBNLL(SIBNTY$FLDWDSP+1: 4,11),
         SIBNAC(SIBNLL$FLDWDSP: 12,23);
        OCTFL SIBNPA(SIBNAC$FLDWDSP: 12,15),
         SIBNFA(SIBNAC$FLDWDSP: 16,19),
         SIBNOA(SIBNAC$FLDWDSP: 20,23);

         INT LSIBN ← LTABLE(SIBNOA);* LENGTH OF SIBN TABLE

* FIELDS IN SIB VALUE (SIBV)
         OCTFL SIBVOT(0: 1,4),
         SIBVLN(0: 10,23),
         SIBVAA(1: 1,4), SIBVEN(1: 10,23);
        LNFL SIBFLUN(2);
        OCTFL SIBFLLEN(4),
         SIBFLWD(5),
         SIBFLRD(6);

         LNFL SIBLKUN(2);
        OCTFL SIBLKEN(4),
         SIBLKMN(5),
         SIBLKTY(5+LMN);

         INT LSIBFL ← LTABLE(SIBFLRD), LSIBLK ← LTABLE(SIBLKTY),
         LSIBV ← (LSIBFL IF LSIBFL > LSIBLK ELSE LSIBLK);
        INT MLSIB ← (LSIBV IF LSIBV > LSIBN ELSE LSIBN);
        END;

        COMMON PMTDECS; INCLUDE UQNDECS;

* FIELDS FOR PMT ENTRY
         LNFL PMTUN(0);
        OCTFL PMTFL(2: 0,0), PMTDKA(2: 2,23),
         PMTRO(3: 0,0), PMTAL(3: 3,11), PMTCL(3: 15,23);

         INT NPMT ← 128;* NUMBER OF PMT ENTRIES
        INT LPMT ← 5;* SIZE OF PMT ENTRY
        END;

        COMMON SPTDECS; INCLUDE DECDECS;

* FIELDS IN SPCS
         OCTFL SPCSNIS(0: 0,0), SPCSNIC(0: 1,1),
         SPCSCSP(0: 2,5), SPCSPR(0: 6,23),
         SPCS940M(1: 0,0), SPCSR0SP(1: 2,5), SPCSLR(1: 6,23),
         SPCSR1SP(2: 2,5), SPCSGR(2: 6,23);
        LNFL SPCSIT(3);
        INT LSPCS ← LTABLE(SPCSIT) + 1;

         INT NSPT ← 8;
        END;

        COMMON ATTACHDECS; INCLUDE DECDECS;
*
* DEFINITION OF ATTACH (PI) FILE HEADER
*
         OCTFL ATFMT(0), ATNP(1), ATMAP(3), ATMNM(38),
         ATCUF(43), ATEP(44), ATEG(45);
        OCTFL BYTEC(0: 12,13), BYTEP(0: 16,23);

         INT FMTCODE ← 0;* VALUE OF CURRENT FORMAT
        END;

        COMMON ICTDECS; INCLUDE DECDECS;

* FIELDS IN ICT
         OCTFL ICTSRC(0: 0,2) /* SOURCE */,
         ICTACT(0: 3,5) /* ACTION */,
         ICTSPEC(0: 6,10) /* SUB-PROCESS/TRAP */,
         ICTBLK(0: 11,11) /* BLOCKING */,
         ICTCL(0: 15,23) /* CONTROL LOCK */;
        LNFL ICTTM(1);* REAL/COMPUTE TIME VALUE

         INT NICT ← 24, LICT ← LTABLE(ICTTM) + 1, QT'ICT;

* VALUES FOR SOURCE-ACTION-BLOCK PARAMETER OF SET'ICT
         MACRO ICT'SAB(S, A, B) ← S @ ICTSRC V' A @ ICTACT V' B @ ICTBLK;
        INT ICTNULCD ← ICT'SAB(0, 0, 0) /* NULL */,
         ICTBLKCD ← ICT'SAB(1, 0, 1) /* BLOCKING */,
         ICTTRPCD ← ICT'SAB(1, 2, 1) /* TRAP */,
         ICTRTICD ← ICT'SAB(2, 1, 1) /* REAL-TIME INTERRUPR */;
        END;

        COMMON ALLOC'DECS;

*
* SPL STORAGE ALLOCATOR
*

* THE BASIC STRUCTURE OF A STORAGE BLOCK IS AS IN THE OLD ALLOCATOR,
* I.E. THE WORD BEFORE THE 0'TH WORD OF A BLOCK CONTAINS THE LENGTH
* OF THE BLOCK (NUMBER OF INFORMATION WORDS +1), A FLAG IN BIT 0
* TO SAY THAT THE BLOCK IS FREE, AND A FLAG IN BIT 1 TO SAY THAT
* THE NEXT LOWER BLOCK IS FREE.
         DECLARE FIELD HIDDEN(-1), HSIZE(-1: 6,23), HFREE(-1: 0,0),
         HFTAG(-1: 1,1), HZTAG(-1: 2,2);
* FREE STORAGE COMES IN ZONES.  A ZONE CONSISTS OF A ZONE HEADER
* AND A CHAIN OF EXTENSIONS.  THE ZONE HEADER CONTAINS: THE BLOCK
* SIZE FOR THE ZONE (0 MEANS ALL SIZES ARE ALLOWABLE), THE OVERFLOW
* ROUTINE, THE EXTENSION LIST, AND THE FREE LIST ROVER.
         DECLARE FIELD FEXT(0), FLIST(2), FUNCTION FIELD FOVX(1);
        DECLARE PARAMETER FZHS←3;
* THE FEXT WORD IN EACH EXTENSION POINTS TO THE NEXT ONE.  THIS CHAIN,
* IS TERMINATED BY A -1.  THE FIRST TWO WORDS
* OF A FREE BLOCK ARE USED TO HOLD THE ADDRESS OF THE NEXT FREE
* BLOCK AND THE PREVIOUS FREE BLOCK.  THIS LIST IS CIRCULAR.
         DECLARE FIELD NBLK(0),PBLK(1);
* FOR FIXED-SIZE ZONES, THE ENTIRE FREE LIST AND THE HIDDEN WORDS
* ARE SET UP AT THE TIME AN EXTENSION IS CREATED.  FOR VARIABLE-SIZED
* ZONES, AN EXTENSION IS SET UP AS A SINGLE FREE BLOCK WHICH IS
* SUBDIVIDED AS THE NEED ARISES.  A FIRST-FIT STRATEGY WITH A "ROVER"
* IS USED FOR THE LATTER.  BLOCKS BELOW A MINIMUM SIZE WILL NOT BE CREATED.
         DECLARE PARAMETER MINSIZ←3;

         DECLARE INFINITY'ZONE, CURRENT'ZONE;* ZONE VARIABLES FOR ALLOCATOR
        END;

        COMMON UCALLDECS; INCLUDE COMDECS;
*
* DECLARATIONS USED IN UCALLS
*
         MACRO UC(U) ←, UTILITY ← U;
        MACRO UCF(U) ←, FRETURN , UTILITY ← U;
        MACRO TFR ← FRETURN (ERCODE, ERMSNO): ERCODE, ERMSNO;
        MACRO FRS(X,Y,Z) ← MACRO X ← FRETURN (Y, -Z);
        MACRO ERS(X,Y,Z) ← MACRO X ← ERCODE ← Y & ERMSNO ← -Z;
        MACRO READ'CSP() ← READ'SPS'PARAM('CSP'// SF'PUNT);
        MACRO READ'KEY(S) ← MRD'SPT'FIELD(S, 'KEY'// SF'PUNT);

* MACHINE DEFINITIONS
         PTR UTS'RING ← 400000B, UTS'G ← 403000B, USER'G = G' [14B];
        PTR INITIAL'SP ← 406000B, NORMAL'SL ← 407777B,
         INITIAL'FS ← 403600B;
* DECLARATION FOR ENTER MESSAGE
         INT LINIT'MSG ← 30; PTR INIT'MSG ← 404000B - LINIT'MSG;

* ASSIGNMENTS FOR FIXED-USAGE PAGES
         INT LAST'PAGE ← 40B; OCTFL PAGE'FL(0: 6,12);
        INT UP'PAGE ← LAST'PAGE - 1;
        PTR UP'PTR ← UP'PAGE @ PAGE'FL V' UTS'RING;
        INT ATF'PAGE ← UP'PAGE - 1;
        PTR ATF'PTR ← ATF'PAGE @ PAGE'FL V' UTS'RING;
        INT ATP'PAGE ← ATF'PAGE - 1;
        PTR ATP'PTR ← ATP'PAGE @ PAGE'FL V' UTS'RING;
        INT ERMSG'PAGE ← 12;
        PTR ERMSG'PTR ← ERMSG'PAGE @ PAGE'FL V' UTS'RING;
        INT F'FREE'PAGE ← 16, L'FREE'PAGE ← ATP'PAGE - 1,
         FS'PAGE ← 1;

*
* FLUID AND STATIC STORAGE FOR THE UTILITY
*
         LB PUNT'POINT;* UNWIND TO CURRENT UCALL/MARKUC
        INT USP;* UTILITY SUB-PROCESS NUMBER
        INT USPNM;* UTILITY SUB-PROCESS NAME
        INT RCLVL;* CURRENT INCARNATION NUMBER
        PTR UCALL'SP;* SAVED SP FROM COMMAND PROCESSOR
        PTR CP'SP;* SAVED L OF COMMAND PROCESSOR
        INT ATF'PMT;* PMT ENTRY FOR FILE PAGE IN ATTACH
        INT PROC'OWNER;* USER NUMBER OF PROCESS OWNER
        INT INITINS;* INITIAL EDITOR MODE
        INT UTS'KEY;* UTILITY (SYSTEM) OWNER KEY (USE WITH CAUTION)
        INT USER'KEY;* KEY FOR PROCESS OWNER
        INT A'FRIEND;* ACCOUNT FRIEND
        INT G'FRIEND;* GROUP FRIEND

         PTR RT'QUEUE;* POINTER TO REAL-TIME QUEUE
        INT UTS'RTIMER ← 17;* UTS REAL-TIME INTERRUPT

         ST SAVED'LINE;* SAVED COMMAND LINE

         INTARY COM'SRLIS;* COMMAND SEARCH LIST
        INTARY FIL'SRLIS;* FILE SEARCH LIST

* TRAP VARIABLES
         INT QUIT'FLAG;* FLAG FOR QUIT TRAP
        INT ERROR'FLAG;* FLAG TO COM PROC FOR ERROR RETURN



*
* UTILITY FAILURE RETURNS (MACRO DEFS)
*

         FRS (FR'CIXOB, 'CII', 1);* ILLEGAL CIOS INDEX
        FRS (FR'CTFUL, 'CIF', 2);* CIOS TABLE FULL OR ENTRY IN USE
        FRS (FR'CFLNM, 'ARG', 3);* ILLEGAL CIOS FIELD NAME
        FRS (FR'CNCTL, 'CIC', 4);* CIOS NOT CONTROLLED
        FRS (FR'CISCL, 'DAT', 5);* ILLEGAL VALUE FOR CIOS CONTROL LOCK
        FRS (FR'CNACC, 'CIA', 6);* CIOS NOT ACCESSABLE
        FRS (FR'CISLN, 'DAT', 7);* ILLEGAL VALUE FOR CIOS LENGTH
        FRS (FR'CISBW, 'DAT', 8);* ILLEGAL VALUE FOR BRK/WAKUP CODE
        FRS (FR'ILNAM, 'ILN', 9);* ILLEGAL NAME FOR PARTIAL SEARCH
        FRS (FR'CLFUL, 'FUL', 10);* COMMAND STRING TOO SHORT
        FRS (FR'NNFND, 'NNF', 11);* FILE NAME NOT FOUND
        FRS (FR'NMAMB, 'NAM', 12);* FILE NAME AMBIGUOUS
        FRS (FR'TPAMB, 'TAM', 13);* FILE TYPE NOT SPECIFIED OR AMBIG
        FRS (FR'IPUNO, 'IUN', 14);* ILLEGAL USER NUMBER FOR 'NXT' SEARCH
        FRS (FR'ENDSR, 'END', 15);* END OF 'NXT' SEARCH
        FRS (FR'SYNER, 'SYN', 16);* FILE NAME SYNTAX ERROR
        FRS (FR'NMLEN, 'NTL', 17);* FILE MAIN:NAME TOO LONG
        FRS (FR'EMFUL, 'FUL', 18);* ERROR MESSAGE STRING TOO SHORT
        ERS (ER'CNINP, 'NIP', 19);* UNIMPLEMENTED CIOS FEATURE
        FRS (FR'CNINP, 'NIP', 19);
        FRS (FR'SPFUL, 'SPF', 20);* SUB-PROCESS TABLE/ENTRY FULL
        FRS (FR'SIXOB, 'SPI', 21);* SUB-PROCESS INDEX OUT-OF-BOUNDS
        FRS (FR'SNOWN, 'SPO', 22);* SUB-PORCESS NOT OWNED
        FRS (FR'SNCTL, 'SPC', 23);* SUB-PROCESS NOT CONTROLLED
        FRS (FR'ILSCD, 'ICD', 24);* ILLEGAL SPECIAL SEARCH CODE
        FRS (FR'UPENF, 'ENF', 25);* UP ENTRY NOT FOUND
        FRS (FR'UPINF, 'INF', 26);* UP ITEM NOT FOUND
        FRS (FR'UPVTL, 'VTL', 27);* UP VALUE TOO LONG
        FRS (FR'UPACD, 'ACD', 28);* UP ACCESS DENIED
        FRS (FR'UPEOF, 'EOF', 29);* NO MORE FILE SPACE
        FRS (FR'UPEST, 'EST', 30);* ENTRY ALREADY EXISTS
        FRS (FR'SFLNM, 'FLD', 31);* ? CHECK SPT
        FRS (FR'SNUTC, 'NUT', 32);* NOT UTILITY SP
        FRS (FR'SLFUL, 'FUL', 33);* OUTPUT STRING FULL
        ERS (ER'SNLEN, 'LEN', 34);* INPUT STRING TOO LONG
        FRS (FR'SNLEN, 'LEN', 34);
        ERS (ER'SNIMP, 'NIP', 35);* NOT IMPLEMENTED OR ILLEGAL HEADER
        FRS (FR'ILEMN, 'EMN', 36);* ILLEGAL ERROR MESSAGE NUMBER
        FRS (FR'FOPCD, 'ICD', 37);* ILLEGAL OPEN CODE
        FRS (FR'FNACC, 'ONA', 38);* INSUFFICIENT ACCESS TO OBJECT
        ERS (ER'FILIU, 'INU', 39);* FILE IN USE

         FRS (FR'FIXOB, 'OFI', 40);* OFT INDEX OUT-OF-BOUNDS
        FRS (FR'FNCTL, 'UCL', 41);* ILLEGAL ATTEMPT TO SET OFT CL
        FRS (FR'SNFIL, 'WRT', 42);* NOT A FILE
        ERS (ER'UTQIT, 'QIT', 43);* QUIT OCCURRED WHILE BLOCKED
        FRS (FR'UTQIT, 'QIT', 43);
        FRS (FR'CISBF, 'DAT', 44);* NON-ZERO BUFFER COUNT
        FRS (FR'ACKLO, 'FUL', 45);* ACCESS KEY LIST OVERFLOW
        FRS (FR'PPVTL, 'FUL', 46);* PROCESS PROFILE VALUE STRING TOO SHORT
        FRS (FR'PPINF, 'NNF', 47);* PROCESS PROFILE NAME NOT FOUND
        FRS (FR'ILUNO, 'IUN', 48);* ILLEGAL USER NUMBER IN SEARCH LIST
        FRS (FR'SRLTL, 'FUL', 49);* SEARCH LIST INPUT TOO LONG
        FRS (FR'SRSYN, 'SYN', 50);* USER NUMBER NOT INTEGER
        END;

        COMMON UCALLD'KLUDGE;
        INCLUDE DECDECS;

         INT SAVED'USER;
        END;

        COMMON UTS'SPTAB; INCLUDE SPTDECS;
*
* DECLARATIONS FOR THE UTILITY SPT
*
         OCTFL USPTCIOS(0: 0,5);* DEFAULT CIOS NUMBER
        OCTFL USPTRCL(0: 6,11);* RECURSION LEVEL FOR RESET
        OCTFL USPTOL(0: 12,23);* (UTILITY) OWNER LOCK
        OCTFL USPTCAK(1: 0,11);* COMMAND (PROGRAM) ACCESS KEY
        OCTFL USPTUAK(1: 12,23);* USER (PROCESS) ACCESS KEY
        LNFL USPTUQNM(1);* UNIQUE NAME OF ATTACHED FILE
        OCTFL USPTNAME(3);* MAIN-NAME OF FILE (** FOR REFERENCE ONLY**)
        INT LUSPT ← LTABLE(USPTNAME) + LMN;* LENGTH OF USPT ENTRY

         PTRARY1 USPT[NSPT];* SUB-PROCESS POINTER TABLE

         INT NORMAL'TCM ← -1;
        END;

        COMMON UTS'OFTAB; INCLUDE OFTDECS;
*
* DECLARATIONS FOR THE UTILITY SPT
*
         OCTFL UOFTAC(0: 0,1) /* CODE FOR OPEN ACTION */,
         UOFTOT(0: 3,6) /* TYPE OF OBJECT */,
         UOFTCL(0: 12,23) /* CONTROL LOCK FOR UTS */;

         INT RO'ACT ← 12B, LOCK'ACT ← 07B, SEARCHFL;
        FNFL EVENTFN(3); OCTFL EVENTFL(4);
        ARBEXT EXTEND'FILE'LOCK; INTEXT CLOSE'SEARCH;
        OCTFL RL(0: 0,11), WL(0: 12,23);

         INTARY1 UOFT[NOFT];* UTS OFT
        END;

        COMMON CIOS'TAB; INCLUDE DECDECS;
*
*  DECLARATIONS FOR CONTROL INPUT/OUTPUT STREAMS
*

         OCTFL CIOSCL(0: 0,11), CIOSAL(0: 12,23),
         CIOSPOS(1: 0,11), CIOSLEN(1: 12,23);
        OCTFL CIOSOPTION(2), CIOSECH(2: 0,0),
         CIOSTRI(2: 1,1), CIOSTRO(2: 2,2),
         CIOSIPT(2: 6,8), CIOSOPT(2: 9,11), CIOSTOP(2: 11,11),
         CIOSSFN(2: 12,17), CIOSOFN(2: 18,23);
        INTFL CIOSIPN(3: 0,11), CIOSOPN(3: 12,23);
        STFL CIOSIB(4), CIOSOB(8);

         INT NCIOS ← 8, LCIOS ← LTABLE(CIOSOB)+3,
         MNLEN ← 20, NRMLEN ← 72, MXLEN ← 132;

         CHR S1CH ← 37B;

         OCTFL H2B(0: 16,17), MBCNT(0: 18,23);
        MACRO MBP(C) ← (C$H2B = 2);
        MACRO CTLP(C) ← (C$H2B = 3);
        MACRO FR'QUIT(X) ← FRETURN (X, 'QIT', -43);*** REFERS TO DEF ON P 3
        MACRO TFRQ(X) ← FRETURN (X, ERCODE, ERMSNO): ERCODE, ERMSNO;

         PTRARY1 CIOSTB[NCIOS];
        ST CIOSIL, CIOSOL; INT CIOSN, CIOSS; PTR CIOSP;
        END;

        COMMON REAL'NAMES; INCLUDE UCALLDECS;
*
* REAL NAME TABLE
*
         MACRO RNTE(A, B)←(A+100B,0,0,0,B);

*?*       OUT OF DATE (NIMPORT)
*INTARY    RNT[7: 5] ← (RNTE(2,16), RNTE(3,17), RNTE(4,18),
*          RNTE(5,19),RNTE(6,20),RNTE(7,21),RNTE(8,27),(-1,0,0,0,0));
*PTR       RNTP=G'[7]←@RNT[0];

* ATTACH FILE HEADER FOR TAPE
         INTARY ATF'HDR[46:,ATF'PTR] ←
         (0,13,0,60010000B,20022003B,20042005B,20062007B,20102011B,
         0,20122013B);
        INTARY ATF'HDR[44] ← (403012B, 403000B);
        END;

        COMMON RTIDECS; INCLUDE ICTDECS;
*
* FIELDS FOR EVENT SCHEDULING
*
         PTRFL RTQNX(0);* POINTER TO NEXT QUEUE SLOT
        LNFL RTQTM(1);* TIME FOR EVENT TO OCCUR
        FNFL RTQFN(3);* FUNCTION TO CALL AT ELAPSED TIME
        END;

        COMMON CP'COM'NAMES; INCLUDE DECDECS;

* NAMES OF BUILT-IN COMMANDS
         INT LCOMNM←8;
        STARY COM'NM[LCOMNM] ← (6"CONTINUE", 6"SAVE-CURRENT",
         6"RELEASE", 6"RESET",6"HELP", 6"FINISHED", 6"QUIT",6"&"");
        END;

        COMMON CP'VERSION; INCLUDE DECDECS;

         INT MOD'NO;* MODIFICATION NUMBER
        INT MOD'VAL = MOD'NO ← 0;*** KLUDGE
        END;

        COMMON TRAP'DECS; INCLUDE MACHINE'DECS;

* TRAP VARIABLES
         INT TRAP'FLAG;* FLAG INDICATING WHETHER A TRAP IS BEING PROCESSED
        PTR BLL'WORD;* G-REL PTR TO BLL DESCRIPTOR IN TRAP LOGIC
        PTR BLL'SAVEL;* G-REL SAVE LOC FOR L-REG IN BLL TRAP LOGIC
        INT GSX, GSAVER; INTARY GSTATE[LSTATE];* GLOBAL TRAP STATE
        END;

        COMMON NAME'SEARCH'V; INCLUDE COMDECS;
*
* THIS SECTION OF THE UTILITY IS RESPONSIBLE FOR ALL MIB SEARCHES.
*  IT IS COMPOSED OF THREE MAJOR ROUTINES - THE DRIVER, NAME'SEARCH,
*  THE SYNTAX CHECKER AND SCAN INITIALIZER, SPREAD'NAME, AND THE
*  DIRECTORY (MIB) SCANNER, DIR'SCAN.
* THE DRIVER AND THE OTHER TWO ROUTINES ACT AS COROUTINES, THE STATE
*  OF THE SCAN BEING SAVED IN THE FOLLOWING COMMON VARIABLES
*
         INT SRFLG;* INDEX IN SEARCH LIST, OR NEGATIVE FOR SINGLE DIRECTORY
        INT LSRLIS;* LENGTH OF SEARCH LIST
        INTARY SRLIST;* SEARCH LIST
        LN UNDK;* CURRENT FILE DIRECTORY (MIB)
        INT UNO = @(UNDK$UNDKUN);* USER NUMBER ONLY
        INT ENTNO;* CURRENT ENTRY NUMBER

         INT KEY;* ACCESS KEY FOR SEARCH
        END;

        COMMON UPCOM; INCLUDE UCALLDECS,ATTACHDECS,COMDECS;

*  COMMON FOR USER PROFILE FUNCTIONS

         OCTFL FREEBIT(0:0,0),ENTLLEN(0:2,12),ENTPLEN(0:13,23);


         OCTFL UPAC(0:0,2),NMLEN(0:3,6),VLEN(0:7,15);
        PTR FWA ← UP'PTR+6;
        OCTFL CPAC(0:0,0), UWAC(0:1,1), ARAC(0:2,2);

         OCTFL UNO(1:0,15);* USER NUMBER
        OCTFL NAMFLD(0:16,23);


         MACRO CALNEWPT(ARROW)←(ARROW.NMLEN+ARROW.VLEN+4)/3+ARROW;
*  MACRO TO CALCULATE LOCATION OF NEXT NAME

         OCTFL UPPG(-6:0,2),UPLLEN(-6:3,23), UPSONO(-5),
         UPGONO(-4),UPAONO(-3),UPLOCK(-2),UPTIMER(-1);
        INT PROFILE'OWNER,PROFILE'TYPE;
        END;

        COMMON PPCOM; INCLUDE UCALLDECS;
*
* FIXED PROCESS PROFILE NAMES AND OPERATIONS
*
         INT LPPN ← 3;
        CHRARY PPNAME[LPPN] ← ('FSL', 'CSL', 'ED');
        FNARY PPREAD[LPPN] ← (READ'FIL'SRLIS, READ'COM'SRLIS,
         READ'EDIT'CONV);
        FNARY PPSET[LPPN] ← (SET'FIL'SRLIS, SET'COM'SRLIS,
         SET'EDIT'CONV);

*?*       ADD POINTER TO GENERAL AREA LATER

        END;

        PROGRAM LBARY'KLUDGE; INCLUDE DECDECS;
*
* CONVERT SOURCE-RELATIVE LABEL ARRAY TO ABSOLUTE
*
         LBARY A;

         ARYENT LBARY'KLUDGE(A); RETURN A;
        END;

        PROGRAM LONG'COMPARE; INCLUDE DECDECS;
*
* COMPARE LONG VALUES
*
         PTR P, Q; INT N;
        DECLARE INTEGER FIELD W0(0);

         INTENT LONG'COMPARE(INTEGER @P, INTEGER @Q, N);

         RETURN 1 IF P[N].W0 # Q[N].W0 FOR N ← N - 1 BY -1 TO 0;
        RETURN 0;
        END;

        PROGRAM SCOPY; INCLUDE COMDECS;
        PTR P; ST S, D; STFL A(0);

         ARBENT SCOPY(STRING @P, S), FRETURN;
        D ← P.A; P.RP ← D$WP ← D$RP ← D$BP; GOTO L;

         ARBENT APPEND(STRING @P, S), FRETURN;
        D ← P.A;

L:
        REPEAT;    WCI(GCI(S// VALUE P.WP ← D$WP & RETURN), D// FRETURN); ENDRPT;
        END;

        PROGRAM ST'DESC; INCLUDE COMDECS;
        INT N, S, O; PTR P; ST X;
        STENT ST'DESC(N, P, S, O);

         P ← MAKE(S *(N + 24 / S - 1)/ 24) IF P = 0;

         IF S = 8 DO;
            .LDA 44B6;
        ELSEIF S = 6 DO;
            .LDA 40B6;
        ELSEIF S = 12 DO;
            .LDA 50B6;
        ELSEIF S = 24 DO;
            .LDA 54B6;
        ELSE DO;
            RUNTIME'FAILURE();
        ENDIF;

         .IOR P; .XMA O; .LSHA 18; .IOR O; .LDX -1; .ASP; .CXA;
        .STA X$BP; .STA X$RP; .STA X$WP; .LDX N; .ASP; .STX X$EP;
        RETURN X;
        END;

        PROGRAM SBASE; INCLUDE COMDECS;
*
* FIND BASE ADDRESS OF WORD-ORIGINED STRING DESCRIPTOR
*
         ST S;

         PTRENT SBASE(S);
        .LDA S$BP; .LDX 1; .ASP; .CXA;
        .CMZ 3B6; .BNE L; .ETR 777777B; RETURN;
L:      RUNTIME'FAILURE();
        END;

        PROGRAM STKMAKE; INCLUDE ALLOC'DECS;
        FIXED;
*
* ALLOCATE LOCAL (STACKED) STORAGE
*
         DECLARE SP= G' [2], SL= G' [3], BLK, SIZE;

         FUNCTION STKMAKE(SIZE);

         RUNTIME'FAILURE() IF SP + SIZE >= SL;
        SP ← (BLK ← SP + 1) + SIZE;
        BLK.HIDDEN ← SIZE + 1;
        BSET(BLK, 0, SIZE);
        RETURN BLK;
        END;

        PROGRAM MARK'UCALL; INCLUDE UCALLDECS, MACHINE'DECS;
*
* FUNCTION TO MARK A UCALL ON SPCS
*
         PTR P; LB R = L' [0];
        INT ERMSNO; CHR ERCODE;

         ARBENT MARK'UCALL();
        P ← R$BRDPC;
        MARK'CALL(P, R$BRDLR,
         USER'G IF P < UTS'RING ELSE UTS'G// SF'PUNT);
        RETURN;

* SPECIAL ENTRY TO AVOID PROPAGATING 'QUIT'S
         ARBENT UNMARK'UCALL'Q();
        DELETE'CALL(// SF'PUNT); RETURN;

* NORMAL UNMARKING CALL
         ARBENT UNMARK'UCALL();
        DELETE'CALL(// SF'PUNT);
        IF QUIT'FLAG DO;
* QUIT OCCURRED DURING PROCESSING
             QUIT'FLAG ← 0; .SRS 201B;* SET XUTIL BIT IN STATE
            SET'PROC'INT(-1, GET'INT'NO('QT'// SF'PUNT)// SF'PUNT);
        ENDIF;
        RETURN;
        END;

        PROGRAM CIOS'TFNS; INCLUDE UCALLDECS, UTS'SPTAB, CIOS'TAB;
*
* FUNCTIONS TO TEST ARGUMENT LEGALITY
*

         INT N, P, S, ERCODE, ERMSNO;

         ARBENT TEST'CIOSN(N), FRETURN;* TEST CIOS INDEX
        S ← READ'CSP();
        N ← USPT[S].USPTCIOS IF N < 0;
        P ← CIOSTB[N] IF N <= NCIOS AND N > 0 ELSE FRETURN;
***TEMPORARY KLUDGE TO PERMIT CHANGES OF UTTY (AS IN DETACHING)
        P.CIOSIPN←P.CIOSOPN←READ'PROC'PARAM('TNO'//SF'PUNT) RSH 1;
        RETURN (N, S, P) IF P # 0 ELSE FRETURN;
        END;

        PROGRAM CIOS'KLUDGE'1; INCLUDE UCALLDECS, CIOS'TAB;
        INT N, P, S, ERCODE, ERMSNO;

         ARBENT TEST'CIOSC(P, S), FRETURN;* TEST CONTROL
        FRETURN IF READ'KEY(S) A' P.CIOSCL = 0 ELSE RETURN;

         ARBENT TEST'CIOSA(P, S), FRETURN;
        FRETURN IF READ'KEY(S) A'
         (P.CIOSCL V' P.CIOSAL) = 0 ELSE RETURN;

         ARBENT SEL'CIOS(N), FRETURN;
        TEST'CIOSN(N: CIOSN, CIOSS, CIOSP// FR'CIXOB);
        TEST'CIOSA(CIOSP, CIOSS// FR'CNACC);
        CIOSIL ← CIOSP.CIOSIB; CIOSOL ← CIOSP.CIOSOB; RETURN;
        END;

        PROGRAM CIOS'OUTPUT; INCLUDE UCALLDECS, CIOS'TAB;
*
* CONTROL OUTPUT PROGRAMS
*
         INT QF, N, ERMSNO; CHR C, ERCODE; ST L;

* PRINT STRING FOR USER
         ARBENT EPRT'ST(N, L, QF) UCF(45);
        FR'QUIT(L) IF QF; SEL'CIOS(N// TFRQ(L));
        IPRT'ST(L// FR'QUIT(L): L); RETURN;

* PRINT CHARACTER FOR USER
         ARBENT EPRT'CH(N, C, QF) UCF(46);
        FR'QUIT(C) IF QF; SEL'CIOS(N// TFRQ(C));
        IPRT'CH(C// VALUE FR'QUIT(NULCH));
        RETURN;

* DUMP BUFFER FOR USER
         ARBENT EDUMP'BUF(N, QF) UCF(47);
        FR'UTQIT IF QF; SEL'CIOS(N// TFR);
        SEL'CIOS(N// TFR);
        IDUMP'BUF(// FR'UTQIT);
        RETURN;
        END;

        PROGRAM CIOS'INTOUT; INCLUDE UCALLDECS, CIOS'TAB;
        CHR C; ST L;

* INTERNAL STRING PRINTING ROUTINE
         ARBENT IPRT'ST(L), FRETURN;
        IPRT'CH(C// FRETURN L) FOR C ← GCI(L// RETURN) WHILE 1;

* INTERNAL CHARACTER PRINTING ROUTINE
         ARBENT IPRT'CH(C), FRETURN;
        RETURN IF C = NULCH; WCI(C, CIOSOL// LF'PUNT);
        IDUMP'BUF(// FRETURN) IF C = NLCH
         OR CIOSOL$WP = CIOSOL$EP ELSE
         CIOSP.CIOSOB$WP ← CIOSOL$WP;
*?* REALLOCATE OUTPUT LINE SOMEDAY
         RETURN;
        END;

        PROGRAM CIOS'WRITE; INCLUDE UCALLDECS, CIOS'TAB;
*
* WRITE OUT BUFFER
*
         DECLARE ARRAY STATUS[7];
        DECLARE FIELD DEVICE(0:18,23);
        DECLARE PADDING,PAD'DEVICE;

         INT N, QF, ERMSNO, F, B, MBC, CIOR, W;
        CHR C, K, ERCODE; ST L,OLDSTRING;

* DUMP CIOS OUTPUT BUFFER, FAIL ON 'QUIT'
         ARBENT IDUMP'BUF(), FRETURN;
        RETURN IF CIOSOL$RP = CIOSOL$WP;
        IF CIOSP.CIOSOPT = 1 DO;
            READ'LINE'TABLE(CIOSP.CIOSOPN LSH 1 + 1, STATUS
              //SF'PUNT);
            PAD'DEVICE ← (1 IF STATUS[0]$DEVICE = 1 ELSE 0);
            B ← LENGTH(CIOSOL); B ← 32 IF B < 32;
            SETUP(L, B, STKMAKE((B + 2)/ 3));
            CIOR ← CIOSOL$RP;
CONV:       MBC ← 0;
            FOR C ← GCI(CIOSOL// WRITE) REPEAT;
                W ← L$WP;
* CONVERT CHARACTER TO TELETYPE CODE WITH EVEN PARITY
                 IF C = NLCH DO;
                    WCI(215B, L// BACK);
                    WCI(S1CH, L// BACK); WCI(52B, L// BACK);
                    IF PAD'DEVICE DO;
                        FOR PADDING ← 1 TO 6 DO;
                            WCI(S1CH, L// BACK); WCI(40B, L// BACK);
                        ENDFOR;
                    ENDIF;
                ELSEIF C = 355B DO;
                    WCI(215B, L// BACK);
                    IF PAD'DEVICE DO;
                        FOR PADDING ← 1 TO 6 DO;
                            WCI(S1CH, L// BACK); WCI(40B, L// BACK);
                        ENDFOR;
                    ENDIF;
                ELSEIF C = LFCH DO;
                    WCI(S1CH, L// BACK); WCI(52B, L// BACK);
                ELSEIF C = BELCH DO;
                    WCI(207B, L// BACK);
                ELSEIF MBP(C) DO;
                    WCI(240B,L// BACK1) FOR MBC ←
                     C$MBCNT, MBC - 1 WHILE MBC > 0;
                ELSE DO;
                    K ← (C A' 37B IF CTLP(C) ELSE C + 40B);
                    .LDA K, ZOB, COB, STX N;* COMPUTE PARITY
                    K ← K E' 200B IF N A' 1;
                    IF K < 40B DO;
                        WCI(S1CH, L// BACK); WCI(K V' 40B, L// BACK);
                    ELSE DO;
                        WCI(K, L// BACK);
                    ENDIF;
                ENDIF;
            ENDRPT;

* INTERNAL BUFFER FULL, WRITE ON TELETYPE
BACK:        WCD(C, CIOSOL); L$WP ← W;
WRITE:      MBC ← 0;
BACK1:      WSTRING(CIOSP.CIOSOPN LSH 1 + 1, L: L, B);

             IF B DO;
* INTERRUPTED BY 'QUIT'. FIGURE OUT HOW MUCH WASN'T PRINTED
                 L$WP ← L$RP; L$RP ← L$BP;
                CIOSOL$RP ← CIOR;
                WHILE B ← LENGTH(L) DO;
                    C ← GCI(CIOSOL);
                    IF C = NLCH DO;
                        WCD(LFCH, CIOSOL) IF B = 1; L$RP ← L$WP;
                    ELSEIF MBP(C) DO;
                        IF C$MBCNT > B DO;
                            L$RP ← L$WP; WCD(MBCH+MBC, CIOSOL);
                        ELSE DO;
                            L$RP ← INCDES(L$RP, C$MBCNT);
                        ENDIF;
                    ELSE DO;
                        GCI(L) IF GCI(L) = S1CH;
                    ENDIF;
                ENDFOR;
                C←GCI(CIOSOL//LLL) IF CIOSOL$RP=CIOSOL$BP;
LLL:            OLDSTRING←CIOSOL; SETS(CIOSOL,0,0);
                SCOPY(CIOSOL,OLDSTRING//LF'PUNT);
                CIOSP.CIOSOB ← CIOSOL;
                FRETURN;
            ENDIF;
            SETS(L, 0,0); WCD(MBCH + MBC, CIOSOL) IF MBC;
            GOTO CONV IF CIOSOL$RP # CIOSOL$WP;
            F ← 1;
        ELSE DO;
            F ← (C ← GCD(CIOSOL) = NLCH);
            WCI(C, CIOSOL);
        ENDIF;
        SETS(CIOSOL, 0,0) IF F ELSE CIOSOL$RP ← CIOSOL$WP;
        CIOSP.CIOSOB ← CIOSOL; RETURN;
        END;

        PROGRAM WSTRING; INCLUDE UCALLDECS;
*
* WRITE A STRING, ABORT ON 'QUIT'
*
         INT ERMSNO, LNO, N,NCHRS; CHR ERCODE;
        ST S;

         ARBENT WSTRING(LNO, S);
CAL1:   WRITE'STRING(LNO, -1, S: S, N// TRY1:ERCODE,ERMSNO);
        RETURN (S, N) IF N = 0; MARK'UCALL();
LP:     QUIT'BLOCK(4B7 RSH GET'INT'NO('CHI'// SF'PUNT),
        QUIT'FLAG// SF'PUNT);
        IF QUIT'FLAG DO;
            GOTO RET IF S$BP#S$RP; NCHRS←3;
CAL2:       WRITE'STRING(LNO,NCHRS,S:S,NCHRS//TRY2:ERCODE,ERMSNO);
            GOTO LP IF NCHRS;
        ELSE DO;
CAL3:       WRITE'STRING(LNO, -1, S: S, N//TRY3:ERCODE,ERMSNO);
            GOTO LP IF N;
        ENDIF;
RET:    UNMARK'UCALL'Q(); QUIT'FLAG ← 0; RETURN (S, N);

TRY1:   LNO←TRY'NEW'LINE(LNO) & GOTO CAL1;
TRY2:   LNO←TRY'NEW'LINE(LNO) & GOTO CAL2;
TRY3:   LNO←TRY'NEW'LINE(LNO) & GOTO CAL3;

        END;

        PROGRAM CIOS'INPUT; INCLUDE UCALLDECS, CIOS'TAB;
*
* READ CHARACTER NON-DESTRUCTIVELY, FAIL ON 'QUIT'
*
         INT B, ERMSNO, M; CHR CH, ERCODE; ST IS;

         CHRENT IRD'CH(), FRETURN;
XIT:    RETURN GCI(CIOSIL// READ);
READ:   SETS(CIOSIL, 0,0); CIOSP.CIOSIB ← CIOSIL; M ← 0;
LP:     READ'STRING'BRK(CIOSP.CIOSIPN LSH 1, -1, 0, CIOSIL:
        IS, B// TRY:ERCODE,ERMSNO);
        IF EMPTY(IS) DO;
            MARK'UCALL() & M ← 1 IF M = 0;
            QUIT'BLOCK(4B7 RSH GET'INT'NO('CHI'// SF'PUNT),
             QUIT'FLAG// SF'PUNT);
            GOTO LP IF QUIT'FLAG = 0;
            UNMARK'UCALL'Q(); QUIT'FLAG ← 0; FRETURN;
        ENDIF;
        UNMARK'UCALL() IF M;
* CONVERT STRING TO INTERNAL CODE.
* STRING ALWAYS SHRINKS, SO NO EXTRA SPACE REQUIRED
         FOR CH ← GCI(IS// XCONV) REPEAT;
            CH ← (GCI(IS// LF'PUNT) A' 37B IF CH = S1CH ELSE
             CH A' 177B);
            IF CH < 40B DO;
                WCI(340B V' CH, CIOSIL) IF CH # 13B
                 AND CH # 0;* QUIT, NULL
            ELSE DO;
                WCI(CH A' 77B IF CH > 140B AND CH < 173B ELSE CH - 40B,
                 CIOSIL) IF CH # 177B;* RUBOUT (DEL)
            ENDIF;
        ENDRPT;
XCONV:  CIOSP.CIOSIB$WP ← CIOSIL$WP; GOTO XIT;

TRY:    CIOSP.CIOSIPN←TRY'NEW'LINE(CIOSP.CIOSIPN) & GOTO LP;

        END;

        PROGRAM CIOS'READ; INCLUDE UCALLDECS, CIOS'TAB;
*
* READ CHARACTER FOR USER
*
         INT N, QF, ERMSNO,F; CHR CH, ERCODE;

         CHRENT ERD'CHAR(N, QF) UCF(50);
        F←0; GOTO BEG;
        CHRENT NON'RD'CHAR(N,QF) UCF(52); F←1;
BEG:    FR'UTQIT IF QF; SEL'CIOS(N// TFR);
        IDUMP'BUF(// FR'UTQIT) IF CIOSOL$RP # CIOSOL$WP;
        CH ← GCI(CIOSIL// VALUE IRD'CH(// FR'UTQIT));
        WCD(CH,CIOSIL) IF F;
        IF CH = '&M' V' 200B DO;* ECHO LF AFTER CR
        IF F=0 DO;
                IPRT'CH(LFCH// FR'UTQIT);
            IDUMP'BUF(// QIT); ENDIF;   CH ← NLCH;
        ELSEIF CH = '&J' V' 200B DO;* CONVERT LF
        CH ← LFCH;
        ENDIF;
RET:    CIOSP.CIOSIB$RP ← CIOSIL$RP;
        RETURN CH;

QIT:     WCD(NLCH, CIOSIL); CIOSP.CIOSIB$RP ← CIOSIL$RP; FR'UTQIT;
        END;

        PROGRAM ALENGTH; INCLUDE COMDECS;
*
* COMPUTE ARRAY BOUNDS
*
         PTR A; OCTFL ABW(0);
        INTENT ARRAYUB(A);
        .LDA A.ABW; .CMZ 2B6; .BNE R' [2]; .ETR 17777B;
        .ETR 377777B; RETURN;

         INTENT ARRAYLB(A);
        .LDA A.ABW; .ETR 1B7; .ASHA -21; RETURN;
        END;

        PROGRAM CODE'LKP; INCLUDE COMDECS;
*
* SUBROUTINE TO CONVERT FROM SYMBOLIC CODE TO FIELD NUMBER
*  INCLUDES OFFSET FACTOR (TO BE EXPLAINED)
*
         INT C, S, I, L; INTARY N;

         INTENT CODE'LKP(C, N, S), FRETURN;

         RETURN C IF C <= L + S AND C >= 0 WHERE L ← ARRAYUB(@N);
        RETURN I + S IF N[I] = C FOR I ← 0 TO L;
        FRETURN IF S = 0 ELSE RETURN C;
        END;

        PROGRAM LINE'EDIT; INCLUDE CIOS'TAB, UCALLDECS;
*
* LINE COLLECTOR
*

         INT EST,EDFLAG,INSF, QF, CT, TRP, TWP, BK, ERMSNO; CHR CH, ERCODE;
        LBARY JP; ST H, NL, WS, OL;

* 940 COMPATIBLE EDIT VECTOR
         LBARY JP9[32] ← (GETCH, CHKILL, TMPASS, CHCPY, CPFIN, SWINS,
         NCFIN, GRAPHIC, CPLIN, TAB);
        LBARY JP9[10] ← (LFCTL, UDFCH, GRAPHIC, TMFIN, UDFCH, STCPX,
         STSKX, LNKILL, UDFCH, CHSKP, RTYPE);
        LBARY JP9[21] ← (CPTAB, UDFCH, WDKILL, STSKI, REDIT, STCPI,
         UDFCH, UDFCH, UDFCH, UDFCH, UDFCH);

         STENT ERD'LINE(N, NL, H, QF) UCF(48);
        SETS(NL, 0,0);
        OL←ST'DESC(CT←LNGDES(NL$BP,NL$EP),STKMAKE((CT+2)/3),8,0);
        EDFLAG←0; INSF←INITINS; GOTO EDIT0;

         STENT EED'LINE(N,OL,NL,INSF,H,QF) UCF(49);
        EDFLAG←1;
EDIT0:  SET'CIOS'FIELD(N, 'BWS', 'CTL'//EDFAIL:ERCODE,ERMSNO);
        EST←READ'CIOS'FIELD(N,'EST'//SF'PUNT);
        SEL'CIOS(N// SF'PUNT); JP ← LBARY'KLUDGE(JP9);
        (ER'CNINP & GOTO EDFAIL) IF CIOSP.CIOSIPT # 1;

*** CONVERT TO 'ESCAPED' FORM
         IF EDFLAG DO;
            OL←EDIT'CONV(OL,OL//OVFAIL); NL←EDIT'CONV(NL,NL//OVFAIL);
        ENDIF;
        GOTO EEDIT;

BEDIT:   IPRT'CH(NLCH// QEXIT);
        SETS(NL,0,0); INSF←INITINS; SETR(OL,0);
EEDIT:  IPRT'ST(H// QEXIT);

GETDP:   IDUMP'BUF(// QEXIT);
GETCH:  CH ← IRD'CH(// QEXIT);
        GOTO JP[CH-340B] IF CTLP(CH);

GRAPHIC: WCI(CH, NL// OVFLO); GOTO GETCH IF INSF;
        GCI(OL// GETCH); GOTO GETCH;

LFCTL:   CH ← LFCH; GOTO GRAPHIC;
UDFCH:  TAB: CPTAB:
BADCH:  IPRT'CH(BELCH// QEXIT); GOTO GETDP;* ILLEGAL CHARACTER
BADCK:  GOTO QEXIT IF QF ELSE GOTO BADCH;
OVFLO:  GOTO BADCH;*?* TEMPORARY

* BACKSPACE AND DELETE FUNCTIONS

* CHARACTER
CHKILL:  GOTO BADCH IF EMPTY(NL); NL$WP ← INCDES(NL$WP, -1);
        OL$RP ← INCDES(OL$RP, -1); IPRT'CH('↑'// QEXIT); GOTO GETDP;

* WORD
WDKILL:
WKSKB:  CH ← GCD(NL// WKXIT); GOTO WKSKB IF CH = ' ';
WKSKC:  CH ← GCD(NL// WKXIT); GOTO WKSKC IF CH # ' ';
        NL$WP ← INCDES(NL$WP, 1); IPRT'CH('\'// QEXIT); GOTO GETDP;
WKXIT:  IPRT'CH('\'// QEXIT); IPRT'CH(NLCH// QEXIT); GOTO GETCH;

* LINE
LNKILL:  IPRT'CH('←'// QEXIT); GOTO BEDIT;


* COPY FUNCTIONS
CHCPY:   CH ← GCI(OL// BADCH);* COPY NEXT CHARACTER
        WCI(CH, NL// OVFLO); IPRT'CH(CH// QEXIT); GOTO GETDP;

STCPI:   TRP ← CHECK'TH(OL,EST// BADCK: QF); GOTO STCPY;* COPY THROUGH, AND
STCPX:  TRP ← CHECK'TO(OL,EST// BADCK: QF);* COPY TO CHARACTER

STCPY:   TWP ← OL$WP; OL$WP ← TRP;
        APPEND(NL, OL// OVFLO); IPRT'ST(OL// QEXIT);   OL$RP ← TRP;
        OL$WP ← TWP; GOTO GETDP;

* SKIP FUNCTIONS
CHSKP:   GCI(OL// BADCH); IPRT'CH('%'// QEXIT); GOTO GETDP;* SKIP NEXT CHAR

STSKI:   TRP ← CHECK'TH(OL,EST// BADCK: QF); GOTO STSKP;* SKIP THROUGH, AND
STSKX:  TRP ← CHECK'TO(OL,EST// BADCK: QF);* SKIP TO CHARACTER

STSKP:   BK ← LNGDES(OL$RP, TRP); OL$RP ← TRP;
        IPRT'CH('%'// QEXIT) FOR BK ← BK - 1 BY -1 TO 0; GOTO GETDP;

*LINE TERMINATION
*    PASS TERMINATION CHARACTER BACK TO CALLER.
TMPASS:  IPRT'CH(NLCH//QEXIT)   IF LENGTH(NL) # 0;
        WCI(CH,NL//OVFLO);
        GOTO FIN;
CPFIN:  H ← OL; GOTO XXFIN;
NCFIN:  SETS(H, 0,0);
XXFIN:  APPEND(NL, OL// OVFLO); IPRT'ST(H//QEXIT);
        IPRT'CH(NLCH// QEXIT); GOTO FIN;
TMFIN:  IPRT'CH(LFCH// QEXIT); IDUMP'BUF(// QEXIT);
FIN:    CIOSP.CIOSOB$RP ← CIOSP.CIOSOB$WP ← CIOSOL$BP;
        CIOSP.CIOSIB$RP ← CIOSP.CIOSIB$WP ← CIOSIL$BP;
        RETURN NL IF QF = 0 ELSE FRETURN (NL,ERCODE,ERMSNO) IF EDFLAG=0
         ELSE FRETURN (OL,NL,INSF,ERCODE,ERMSNO);

QEXIT:   ER'UTQIT;
EDFAIL: QF←1; GOTO FIN;
OVFAIL: ER'SNLEN; GOTO EDFAIL;

* RE-EDIT
REDIT:   APPEND(NL,OL//OVFLO);     SCOPY(OL,NL//OVFLO);
        GOTO BEDIT;

*** PUT IN TAB CODE HERE (TAB & CPTAB)

* MISCELLANEOUS

* SWITCH INSERTION MODE
SWINS:   INSF ← -1 & IPRT'CH('<'// QEXIT) IF INSF = 0 ELSE
        INSF ← 0 & IPRT'CH('>'// QEXIT); GOTO GETDP;

* RE-TYPE LINE
RTYPE:   IPRT'CH(NLCH// QEXIT); IPRT'CH(MBCH + LNGDES(OL$RP, OL$WP) +
        LNGDES(H$RP, H$WP)// QEXIT);
        IPRT'ST(OL// QEXIT); IPRT'CH(NLCH// QEXIT);
        IPRT'ST(H// QEXIT); IPRT'ST(NL// QEXIT); GOTO GETDP;

* COPY TO END
CPLIN:   APPEND(NL, OL// OVFLO); WS ← OL; OL$RP ← OL$WP;
        IPRT'ST(WS// QEXIT); GOTO GETDP;
        END;

        PROGRAM LE'CHECK; INCLUDE UCALLDECS, CIOS'TAB;
*
* FIND NEXT OCCURENCE OF CHARACTER
*

         INT EST,TOF, CH, FRP, ERCODE, ERMSNO; ST LIN;

         ARBENT CHECK'TO(LIN,EST), FRETURN; TOF ← -1; GOTO START;
        ARBENT CHECK'TH(LIN,EST), FRETURN; TOF ← 0;

START:   GCI(LIN// FRETURN 0) IF TOF # 0;
        SET'CIOS'FIELD(CIOSN, 'BWS', 'ALL'// SF'PUNT);
        SET'CIOS'FIELD(CIOSN, 'EST', 0// SF'PUNT);
        CH ← IRD'CH(// FRETURN 1);
        SET'CIOS'FIELD(CIOSN, 'BWS', 'CTL'// SF'PUNT);
        SET'CIOS'FIELD(CIOSN, 'EST', EST// SF'PUNT);
        GOTO XIT IF CH = GCI(LIN// FRETURN 0) WHILE 1;
XIT:    RETURN INCDES(LIN$RP, TOF);
        END;

        PROGRAM EDIT'CONV;
        INCLUDE UCALLDECS,CIOS'TAB;

*
* CONVERT LINE TO ESCAPED FORM, PRESERVING RP
*
         ST OL,NL,WS; INT WSR,NLR,CT; CHR CH;

         STENT EDIT'CONV(OL,NL), FRETURN;

         WS←ST'DESC(CT←LNGDES(OL$BP,OL$WP),STKMAKE((CT+2)/3),8,0);
        WSR←INCDES(WS$BP,LNGDES(OL$BP,OL$RP));
        SETR(OL,0); SCOPY(WS,OL// FRETURN);
        NLR←NL$BP; SETW(NL,0);
        FOR CH←GCI(WS//ENDC) REPEAT;
            WCI(CH,NL// FRETURN) IF NOT MBP(CH) ELSE
             (WCI(' ',NL// FRETURN) FOR CT←1 TO CH$MBCNT);
            NLR←NL$WP IF WS$RP=WSR;
        ENDRPT;
ENDC:   NL$RP←NLR;
        RETURN NL;
        END;

        PROGRAM CIOS'FIELDS; INCLUDE CIOS'TAB, UCALLDECS;
*
* FUNCTIONS TO MANIPULATE CONTROL INPUT/OUTPUT STREAMS
*

* DECLARATIONS
         INT N, I, FN, V, SP, P, LNO, ERMSNO; CHR ERCODE;
        INTARY LA[7]; PTR LP; ST IS(2);
        OCTFL FL, BSF(0: 0,11), WSF(0: 12,23);
        OCTFL BWSF(0: 2,3), DVTF(0: 18,23), QITF(1: 16,23), ESCF(1: 8,15),
         ICCF(6: 12,23), OCCF(6: 12,23), IWCF(6: 0,11), OWCF(6: 0,11),
         ESTF(0: 10,10);

         INT NCFL ← 13, NMFL ← 4, NBFL ← 2, NLFL ← NMFL +2*NBFL,
         NCFN ← NCFL+NLFL;
        CHRARY CIOSTFN[NCFN] ← ('CL', 'AL', 'POS', 'LEN',
         'EST', 'TRI', 'TRO',
         'IPT', 'OPT', 'SFN', 'OFN', 'IPN', 'OPN',
         'BWS', 'DVT', 'QIT', 'ESC',
         'ICC', 'IWC', 'OCC', 'OWC');

         LBARY RD'ENT[NCFN] ← (RD'FLD, RD'FLD, RD'FLD, RD'FLD,
         RD'FLD, RD'FLD, RD'FLD,
         RD'IPT, RD'OPT, RD'FLD, RD'FLD, RD'FLD, RD'FLD,
         RD'LIN, RD'LIN, RD'LIN, RD'LIN, RD'LIN, RD'LIN,
         RD'LIN, RD'LIN);
        LBARY ST'ENT[NCFN] ← (ST'CL, ST'AL, ST'FAIL, ST'LEN,
         ST'EST, ST'RET, ST'RET,
         ST'FAIL, ST'FAIL, ST'FAIL, ST'FAIL, ST'FAIL, ST'FAIL,
         ST'BWS, ST'LIN, ST'LIN, ST'LIN, ST'EIB, ST'LIN, ST'EOB, ST'LIN);

         FLARY CIOSTFL[NCFL] ← (CIOSCL, CIOSAL, CIOSPOS, CIOSLEN,
         CIOSECH, CIOSTRI, CIOSTRO,
         CIOSIPT, CIOSOPT, CIOSSFN, CIOSOFN, CIOSIPN, CIOSOPN);
        FLARY LINFL[NLFL] ← (BWSF, DVTF, QITF, ESCF, ICCF, OCCF, IWCF,
         OWCF);* LINE TABLE FIELDS

         CHRARY BWS[4] ← ('NEV', 'CTL', 'PUN', 'ALL');
        CHRARY CST[8] ← ('???', 'SDT', 'QIT', 'ESC', '???', 'WKC', '???',
         'WKC');

         CHRARY IPT[5] ← ('NUL', 'TRM', 'FIL', 'TSF', 'SPE');
        CHRARY OPT[5] ← ('NUL', 'TRM', 'FIL', 'TOF', 'SPE');

* READ CIOS FIELD
         INTENT ERD'CIOS'FIELD(N, FN) UCF(41);
        TEST'CIOSN(N: N, SP, P// FR'CIXOB);
        GOTO RD'ENT[FN ← CODE'LKP(FN, CIOSTFN, 0// FR'CFLNM)];

RD'FLD:  RETURN (P.FL WHERE FL ← CIOSTFL[FN]);* CL, AL, POS, LEN,
*                                                EST, SFN, OFN, IPN, OPN

RD'LIN:  FN ← FN - NCFL;* READ 'DEVICE' FIELD (BWS, DVT, QIT, ESC)
        LNO ← P.CIOSOPN LSH 1 + (0 IF FN < NMFL+NBFL ELSE 1);
        IF P.CIOSTOP # 0 DO;* TERMINAL

         READ'LINE'TABLE(LNO, LA// SF'PUNT); LP ← @LA[0];
            RETURN BWS[LP.BWSF] IF FN = 0;* 'BWS'
            IF FN = NMFL DO;
                I ← LP.ICCF; V ← LNGDES(P.CIOSIB$RP, P.CIOSIB$WP);
                RETURN V+I IF I = 0 OR V > 0;
* NOTHING IN INTERNAL BUFFER, SOMETHING IN CHIO BUFFER -
*   IF CHIO STARTS WITH QUIT, THEN 'BUFFER EMPTY'
                 READ'STRING'BRK(LNO, 1, 1, IS: IS, ERCODE// SF'PUNT);
                RETURN (0 IF (GCD(IS) - LP.QITF) A' 177B = 0 ELSE V+I);
            ENDIF;
            RETURN (LNGDES(P.CIOSOB$RP, P.CIOSOB$WP) + LP.OCCF
             IF FN = NMFL+NBFL ELSE (LP.FL WHERE FL ← LINFL[FN]));

         ELSE DO;* NOT TERMINAL
        RETURN ('ALL' IF FN = 0 ELSE -1);
        ENDIF;

RD'IPT:  RETURN IPT[P.CIOSIPT];
RD'OPT: RETURN OPT[P.CIOSOPT];

* SET CIOS FIELD
         ARBENT EST'CIOS'FIELD(N, FN, V) UCF(42);
        TEST'CIOSN(N: N, SP, P// FR'CIXOB);
        TEST'CIOSA(P, SP// FR'CNACC);
        GOTO ST'ENT[FN ← CODE'LKP(FN, CIOSTFN, 0// ST'FAIL)];
ST'FAIL:FR'CFLNM;* NAME NOT VALID

* CONTROL LOCK
ST'CL:   TEST'CIOSC(P, SP// FR'CNCTL);* CONTROL?
        FR'CISCL IF (P.CIOSCL E' V) A' N' READ'KEY(SP) # 0;
        P.CIOSCL ← V; DESTROY'CIOS(N) IF V = 0; RETURN;

* ACCESS LOCK
ST'AL:   P.CIOSAL ← V; RETURN;

ST'EST:  P.CIOSECH ← V;
        SET'LINE'FIELD(P.CIOSOPN LSH 1, 'EST', 1 IF V ELSE 0// SF'PUNT)
         IF P.CIOSTOP # 0;
ST'RET: RETURN;

ST'LEN:  FR'CISLN IF MNLEN > V OR MXLEN < V OR P.CIOSPOS # 0;* DATA?
        P.CIOSLEN ← V; RETURN;

* BREAK STRATEGY
ST'BWS:  RETURN IF P.CIOSTOP = 0;
        V ← CODE'LKP(V, BWS, 0// FR'CISBW);
        SET'LINE'FIELD(P.CIOSOPN LSH 1, 'BWS', V @ BSF V' V @ WSF//
         SF'PUNT);
        RETURN;

ST'LIN:  LNO ← P.CIOSIPN LSH 1 + (0 IF FN < NMFL+NBFL ELSE 1);
        MARK'UCALL();
        SET'LINE'FIELD(LNO, CST[FN-NCFL], V//
         SF'PUNT) IF P.CIOSTOP # 0;
        UNMARK'UCALL(); RETURN;

* EMPTY INPUT BUFFER
ST'EIB:  RETURN IF P.CIOSTOP = 0 ELSE FR'CISBF IF V # 0;
        LNO ← P.CIOSIPN LSH 1;
        CIOSIL ← P.CIOSIB; P.CIOSIB$WP ← P.CIOSIB$RP ← CIOSIL$BP;
        READ'LINE'TABLE(LNO, LA// SF'PUNT); LP ← @LA[0];
        V ← LP.ESTF; SET'LINE'FIELD(LNO, 'EST', 0// SF'PUNT);
        REPEAT;
            SETS(CIOSIL,0,0);
            READ'STRING'BRK(LNO, -1, 0, CIOSIL: CIOSIL, I// SF'PUNT);
            IF EMPTY(CIOSIL) OR (GCD(CIOSIL) - LP.QITF) A' 177B = 0 DO;
                SET'LINE'FIELD(LNO, 'EST', V// SF'PUNT); RETURN;
            ENDIF;
        ENDRPT;

* EMPTY OUTPUT BUFFER
ST'EOB:  RETURN IF P.CIOSTOP = 0 ELSE FR'CISBF IF V # 0;
        LNO ← P.CIOSOPN LSH 1 + 1;
        CIOSOL ← P.CIOSOB; P.CIOSOB$WP ← P.CIOSOB$RP ← CIOSOL$BP;
        REPEAT;
            SETS(CIOSOL,0,0);
            READ'STRING'BRK(LNO, -1, 0, CIOSOL: CIOSOL, V// SF'PUNT);
            RETURN IF EMPTY(CIOSOL);
        ENDRPT;
        END;

        PROGRAM BLOCK'OB'EMPTY; INCLUDE UCALLDECS, CIOS'TAB;
*
* WAIT FOR OUTPUT BUFFER TO EMPTY
*
         INT N, QF, LNO, W, ERMSNO; CHR ERCODE;
        INTARY LA[7]; PTR LP;
        OCTFL OCCF(6: 12,23), OWCF(6: 0,11);

         ARBENT EBLK'OBE(N, QF) UCF(51);
        FR'UTQIT IF QF; SEL'CIOS(N// TFR);
        IDUMP'BUF(// FR'UTQIT); RETURN IF CIOSP.CIOSTOP = 0;
        LNO ← CIOSP.CIOSOPN LSH 1 + 1;
        READ'LINE'TABLE(LNO, LA// SF'PUNT); LP ← @LA[0];
        RETURN IF LP.OCCF = 0 ELSE W ← LP.OWCF;
        SET'LINE'FIELD(LNO, 'WKC', 0// SF'PUNT);
        MARK'UCALL();
BL:     GOTO AVOID;*?* BLOCKING
        QUIT'BLOCK(4B7 RSH GET'INT'NO('CHI'// SF'PUNT),
         QUIT'FLAG// SF'PUNT);
AVOID:  GOTO RET IF QUIT'FLAG;
        READ'LINE'TABLE(LNO, LA// SF'PUNT);
        GOTO BL IF LP.OCCF # 0;
RET:    UNMARK'UCALL'Q(); SET'LINE'FIELD(LNO, 'WKC', W// SF'PUNT);
        QUIT'FLAG ← 0 & FR'UTQIT IF QUIT'FLAG ELSE RETURN;
        END;

        PROGRAM READ'EDIT'CONV; INCLUDE UCALLDECS;
*
* READ EDIT CONVENTIONS
*
         ST V;

         STENT READ'EDIT'CONV(V), FRETURN;
        WCI((INITINS # 0) + '0', V// FRETURN); RETURN V;
        END;

        PROGRAM SET'EDIT'CONV; INCLUDE UCALLDECS;
*
* SET EDIT CONVENTIONS
*
         ST V;
        FRS(FR'ILECV,'ECV',51);

         ARBENT SET'EDIT'CONV(V), FRETURN;
        INITINS ← (1 IF CSN(V, 10// FR'ILECV) ELSE 0); RETURN;
        END;

        PROGRAM PP'SEARCH; INCLUDE PPCOM;
*
* LOOK UP FIXED NAME OR FAIL
*
         ST N; CHR C;

         INTENT PP'SEARCH(N), FRETURN;

         FRETURN IF LNGDES(N$RP, N$WP) > 3;
        C ← 0; C ← C LSH 8 V' GCI(N// LKP) WHILE 1;
LKP:    RETURN CODE'LKP(C, PPNAME, 0// FRETURN);
        END;

        PROGRAM READ'PP'ITEM; INCLUDE PPCOM;
*
* READ ITEM FROM PROCESS PROFILE
*
         ST N, V; INT I;

         STENT ERD'PP'ITM(N, V) UCF(71);

         I ← PP'SEARCH(N// GEN);
        V ← (PPREAD[I])(V// FR'PPVTL);
        RETURN V;

*?*       DO FINDN ON GENERAL AREA HERE, ETC
GEN:     FR'PPINF;
        END;

        PROGRAM READ'PP'NAMES; INCLUDE PPCOM;
*
* READ NAMES OF PROCESS PROFILE ITEMS
*
         ST V; INT I; CHR C, W;

         STENT ERD'PP'NM(V) UCF(72);

         FOR I ← LPPN-1 BY -1 TO 0 DO;
            WCI(C, V// ABORT) IF C ← (W ← PPNAME[I])$CH0 # ' ';
            WCI(C, V// ABORT) IF C ← W$CH1 # ' ';
            WCI(C, V// ABORT) IF C ← W$CH2 # ' ';
            WCI(',', V// ABORT) IF I > 0;
        ENDFOR;

*?* ADD CODE TO APPEND [',' GENERAL ITEM NAME] TO V
         RETURN V;

ABORT:   FR'PPVTL;

        END;

        PROGRAM LONG'ARITH; INCLUDE COMDECS;
*
* LONG ARITHMETIC/RELATIONALS
*
         LN X, Y; OCTFL W0(0), W1(1);

         LNENT LONG'ADD(X, Y);* ADD
        .LDA X$W1, ADD Y$W1, CAB;
        .LDA X$W0, ADC Y$W0; RETURN;

         LNENT LONG'SUB(X, Y);* SUBTRACT
        .LDA X$W1, SUB Y$W1, CAB;
        .LDA X$W0, SUC Y$W0; RETURN;

         INTENT LONG'LE(X, Y);* LESS THAN OR EQUALS
        RETURN (1 IF LONG'SUB(X, Y)$W0 <= 0 ELSE 0);

         INTENT LONG'LT(X, Y);* LESS THAN
        RETURN (1 IF LONG'SUB(X, Y)$W0 < 0 ELSE 0);
        END;

        PROGRAM MAKE; INCLUDE ALLOC'DECS;
*
* ASSIGN BLOCK OF SIZE (A) IN ZONE (B)
*
         DECLARE BLK,ROVER,RSIZE,EBLK,ROVEC;

         FUNCTION MAKE(SIZE,ZONE);

         ZONE ← CURRENT'ZONE IF ZONE = 0;
        SIZE ← SIZE + 1;
        SIZE←MINSIZ IF SIZE<MINSIZ;
        GOTO MAKEOV IF ZONE.FLIST<0;
* VARIABLE-SIZED ZONE
         ROVEC←ROVER←ZONE.FLIST;
MAKE1:  RSIZE←ROVER.HSIZE;
        IF RSIZE<SIZE+MINSIZ AND RSIZE#SIZE DO;
            GOTO MAKE1 IF (ROVER←ROVER.NBLK)#ROVEC
             ELSE GOTO MAKEOV;
        ENDIF;
        EBLK←(BLK←ROVER)+ROVER.HSIZE;
        EBLK.HFTAG←0;
        IF ROVER.HSIZE=SIZE DO;
* EXACT FIT
             BLK.HFREE←0;
            ZONE.FLIST ← RFB(ROVER, ZONE);
        ELSE DO;
* SPLIT THE BLOCK
             BLK←EBLK-SIZE;
            BLK.HIDDEN ← 1 @ HFTAG + SIZE;
            BLK[-2]←-RSIZE IF (RSIZE←ROVER.HSIZE←ROVER.HSIZE-SIZE)>MINSIZ;
        ENDIF;
* COMMON EXIT
         BSET(BLK, 0, SIZE - 1);
        RETURN BLK;

* OVERFLOW
MAKEOV:  BLK ← (ZONE.FOVX)(SIZE-1,ZONE); RETURN BLK;
        END;

        PROGRAM RFB; INCLUDE ALLOC'DECS;
        FUNCTION RFB(RBLK, ZONE);
* SUBROUTINE TO REMOVE A BLOCK FROM THE FREELIST
         IF RBLK.NBLK=RBLK DO;
            RETURN ZONE.FLIST←-1;
        ELSE DO;
            ZONE.FLIST←RBLK.NBLK IF RBLK=ZONE.FLIST;
            RBLK.NBLK.PBLK←RBLK.PBLK;
            RETURN RBLK.PBLK.NBLK←RBLK.NBLK;
        ENDIF;
        END;

        PROGRAM FREE; INCLUDE ALLOC'DECS;
*
* RELEASE BLOCK (A) TO ZONE (B)
*
         DECLARE EXPTR,EFB,PFB;

         FUNCTION FREE(BLK,ZONE);
        EFB←BLK+BLK.HSIZE;
        ZONE ← CURRENT'ZONE IF ZONE = 0;
        BLK.HFREE←1;
* VARIABLE-SIZED ZONE
* CHECK FOR MERGE WITH NEXT HIGHER BLOCK
         IF EFB.HFREE DO;
            BLK.HIDDEN←BLK.HIDDEN+EFB.HSIZE;
            RFB(EFB, ZONE);
            EFB ← BLK + BLK.HSIZE;
        ENDIF;
* CHECK FOR MERGE WITH NEXT LOWER BLOCK
         IF BLK.HFTAG DO;
            PFB←BLK+(BLK[-2] IF BLK[-2]<0 ELSE -3);
            PFB.HIDDEN←PFB.HIDDEN+BLK.HSIZE;
            RFB(BLK ← PFB, ZONE);
        ENDIF;
* CLEAN UP
         EFB.HFTAG←1;
        EFB[-2]←-BLK.HSIZE IF BLK.HSIZE>MINSIZ;
        FPB(BLK, ZONE);
        RETURN;
        END;

        PROGRAM FPB; INCLUDE ALLOC'DECS;
* SUBROUTINE TO PUT A BLOCK ON THE FREELIST
         DECLARE ZFP,ZNBP;

         FUNCTION FPB(BLK, ZONE);
        ZFP←ZONE.FLIST;
        IF ZFP<0 DO;
            ZONE.FLIST←BLK.NBLK←BLK.PBLK←BLK;
        ELSE DO;
            ZNBP←ZFP.NBLK;
            ZFP.NBLK←ZNBP.PBLK←BLK;
            BLK.NBLK←ZNBP;
            BLK.PBLK←ZFP;
        ENDIF;
        RETURN;
        END;

        PROGRAM SELZONE; INCLUDE ALLOC'DECS;

         FUNCTION SELZONE(ZONE);
        CURRENT'ZONE ← ZONE; RETURN;
        END;

        PROGRAM PROC'RTI; INCLUDE UCALLDECS, RTIDECS;
*
* PROCESS PENDING REAL-TIME EVENTS (CALLED FROM INTERRUPT ROUTINE,
*     SCHEDULER, AND DELETE ROUTINE)
*
         PTR P; LN NULT ← (0, 0); CHR ERCODE; INT ERMSNO;

         ARBENT PROC'RTI();

         WHILE LONG'LE(READ'CLOCK('RTI'), RT'QUEUE.RTQTM) DO;
            P ← RT'QUEUE; RT'QUEUE ← RT'QUEUE.RTQNX;
            (P.RTQFN)(P);* CALL EVENT PROCESSOR
        ENDFOR;

         SET'ICT(UTS'RTIMER, ICTRTICD, USP, RT'QUEUE.RTQTM//
         SF'PUNT) IF RT'QUEUE ELSE
         SET'ICT(UTS'RTIMER, ICTNULCD, USP, NULT// SF'PUNT);
        RETURN;
        END;

        PROGRAM SCHED'EVENT; INCLUDE UCALLDECS, RTIDECS;
*
* SCHEDULE AN EVENT TO OCCUR AT TIME T
*
         LN T; PTR P, Q, N;
        INT ERMSNO; CHR ERCODE;

         ARBENT SCHED'EVENT(T, P);
        MARK'UCALL(); REFUSE'INTS(2000,100//SF'PUNT);

         GOTO S IF LONG'LT(T, N.RTQTM) FOR Q ← @RT'QUEUE,
         N WHILE N ← Q.RTQNX > 0;
S:      P.RTQNX ← N; Q.RTQNX ← P; P.RTQTM ← T;
        PROC'RTI(); ALLOW'INTS(); UNMARK'UCALL(); RETURN;
        END;

        PROGRAM DELETE'EVENT; INCLUDE UCALLDECS, RTIDECS;
*
* DELETE PENDING EVENT
*
         INTFN F; PTR P, Q;
        INT ERMSNO; CHR ERCODE;

         ARBENT DELETE'EVENT(F);
        MARK'UCALL(); REFUSE'INTS(2000,100//SF'PUNT);
        Q.RTQNX ← P.RTQNX & FREE(P) IF F(P) FOR Q ← @RT'QUEUE,
         P WHILE P ← Q.RTQNX > 0;
        PROC'RTI(); ALLOW'INTS(); UNMARK'UCALL(); RETURN;
        END;

        PROGRAM REAL'INTERVAL; INCLUDE COMDECS;
*
* ADD INTEGER DELAY IN MS TO CURRENT REAL TIME
*
         INT D; LN T; OCTFL W0(0), W1(1);

         LNENT REAL'INTERVAL(D);
        T ← READ'CLOCK('RTI');
        .LDA D, MUL 10000, ASHD -1, XAB;
        .ADD T$W1, XAB, ADC T$W0; RETURN;
        END;

        COMMON DATE'ARRAYS;
        DECLARE STRING ARRAYONE MONTHS[12]←("JAN","FEB","MAR","APR",
         "MAY","JUN","JUL","AUG","SEP","OCT","NOV","DEC");
        DECLARE STRING ARRAYONE WKDAYS[7]←("SUN","MON","TUE","WED",
         "THU","FRI","SAT");
        END;

        PROGRAM GET'DATE'TIME;
        INCLUDE COMDECS;
        INCLUDE DATE'ARRAYS;
        INCLUDE UCALLDECS;

         DECLARE INTEGER YR,MO,WD,MD,HR,MN,SC;
        DECLARE STRING DATE'STR(16),TIME'STR(8);

         FUNCTION GET'DATE'TIME(LONG TREAL,STRING DATE'TIME) UCF(82);
        SETS(DATE'STR); SETS(TIME'STR);
        CONVERT'TIME(TREAL:YR,MO,WD,MD,HR,MN,SC);
        APPEND(DATE'STR,WKDAYS[WD]//GDTL1);
        APPEND(DATE'STR,"  "//GDTL1);
        CNS(MD,DATE'STR,0//GDTL1);
        APPEND(DATE'STR," "//GDTL1);
        APPEND(DATE'STR,MONTHS[MO]//GDTL1);
        APPEND(DATE'STR," "//GDTL1);
        CNS(YR,DATE'STR,0//GDTL1);
        APPEND(TIME'STR,"0"//GDTL2) IF HR<10;
        CNS(HR,TIME'STR,0//GDTL2);
        APPEND(TIME'STR,(":0" IF MN<10 ELSE ":")//GDTL2);
        CNS(MN,TIME'STR,0//GDTL2);
        APPEND(TIME'STR,(":0" IF SC<10 ELSE ":")//GDTL2);
        CNS(SC,TIME'STR,0//GDTL2);
        APPEND(DATE'TIME,DATE'STR// FRETURN);
        APPEND(DATE'TIME,"   "// FRETURN);
        APPEND(DATE'TIME,TIME'STR// FRETURN);
        RETURN DATE'TIME;
GDTL1:  RUNTIME'FAILURE();
GDTL2:  RUNTIME'FAILURE();
        END;

        PROGRAM READ'LOCL'TIME;
        INCLUDE COMDECS;
        INCLUDE UCALLDECS;

         DECLARE INTEGER YEAR,MONTH,WDAY,DAY,HOUR,MIN,SEC;
        DECLARE PARAMETER YEAR0←1970,MONTH0←1,WDAY0←5,DAY0←1,
         HOUR0←0,MIN0←0,SEC0←0;
        DECLARE ARRAYONE MONTH'DAYS[12]←
         (31,28,31,30,31,30,31,31,30,31,30,31);
        DECLARE LONG TREAL,T0←(0,0);

         FUNCTION READ'LOCL'TIME() UC(80);
        TREAL←READ'CLOCK(0);
        GOTO RLTL0;
        ENTRY CONVERT'TIME(LONG TREAL) UC(81);
RLTL0:  TIME'SINCE'T0(TREAL,T0:DAY,HOUR,MIN,SEC);
        SEC←SEC+SEC0;
RLTL1:  IF SEC>=60 DO;
            SEC←SEC-60; MIN←MIN+1;
            GOTO RLTL1;
        ENDIF;
        MIN←MIN+MIN0;
RLTL2:  IF MIN>=60 DO;
            MIN←MIN-60; HOUR←HOUR+1;
            GOTO RLTL2;
        ENDIF;
        HOUR←HOUR+HOUR0;
RLTL3:  IF HOUR>=24 DO;
            HOUR←HOUR-24; DAY←DAY+1;
            GOTO RLTL3;
        ENDIF;
        WDAY←WDAY0+DAY; DAY←DAY+DAY0;
        MONTH←MONTH0; YEAR←YEAR0;
RLTL4:  IF DAY>MONTH'DAYS[MONTH] DO;
            IF (YEAR MOD 4) =0 AND MONTH=2 DO;
                DAY←DAY-1 IF DAY>29 ELSE GOTO RLTL5;
            ENDIF;
            DAY←DAY-MONTH'DAYS[MONTH]; MONTH←MONTH+1;
            IF MONTH=13 DO;
                MONTH←1; YEAR←YEAR+1;
            ENDIF;
            GOTO RLTL4;
        ENDIF;
RLTL5:  WDAY←((WDAY-1) MOD 7) +1;
        RETURN (YEAR,MONTH,WDAY,DAY,HOUR,MIN,SEC);
        END;

        PROGRAM TIME'SINCE'T0;
        INCLUDE COMDECS;

         DECLARE INTEGER DAYS,HOURS,MINS,SECS;
        DECLARE LONG LDAY,LHOUR,LMIN,TEMP,TIME;
        DECLARE FIELD XXX(0:0,1);

         FUNCTION TIME'SINCE'T0(LONG REALT,TIME0);
        TIME0$XXX←REALT$XXX←0;
        LONG'SUB(REALT,TIME0:TIME);
        .LDD TIME, .DIV 4320000, .ASHD -23, .DIV 1000, .STA DAYS;
        .MUL 1000, .ASHD 23, .MUL 4320000, .STD TEMP;
        LONG'SUB(TIME,TEMP:LDAY);
        .LDD LDAY, .DIV 1800000, .ASHD -23, .DIV 100, .STA HOURS;
        .MUL 100, .ASHD 23, .MUL 1800000, .STD TEMP;
        LONG'SUB(LDAY,TEMP:LHOUR);
        .LDD LHOUR, .DIV 3000000, .STA MINS;
        .MUL 3000000, .STD TEMP;
        LONG'SUB(LHOUR,TEMP:LMIN);
        .LDD LMIN, .DIV 50000, .STA SECS;
        RETURN (DAYS,HOURS,MINS,SECS);
        END;

        PROGRAM SPT'FIELDS; INCLUDE UCALLDECS, UTS'SPTAB, UTS'OFTAB;
*
* FUNCTIONS TO MANIPULATE USPT AND SPT
*
         INT N, C, V, I, ERMSNO; CHR FN, ERCODE; PTR P;
        OCTFL FL; INTARY OA[LOFT];

         INT NMFN ← 15, NUFN ← 5, NSFN ← NMFN + NUFN;
        CHRARY USPTFN[NUFN] ← ('CIO', 'RCL', 'OL', 'CAK', 'UAK');
        FLARY USPTFL[NUFN] ← (USPTCIOS, USPTRCL, USPTOL, USPTCAK, USPTUAK);
        LBARY ST'ENT[NUFN] ← (ST'CIOS, ST'FAIL, ST'OL, ST'DAK, ST'DAK);

         INTENT ERD'SPT'FIELD(N, FN) UCF(35);
        TEST'SPTN(N: N, P, C// TFR);
        FN ← CODE'LKP(FN, USPTFN, NMFN// FR'SFLNM);
        RETURN (MRD'SPT'FIELD(N, FN// TFR) IF FN >= NSFN OR FN < NMFN
         ELSE (P.FL WHERE FL ← USPTFL[FN - NMFN]) IF P # 0 ELSE 0);

         ARBENT EST'SPT'FIELD(N, FN, V) UCF(36);*?* FTH?
        TEST'SPTC(N: N, P, C// TFR);
        FN ← CODE'LKP(FN, USPTFN, NMFN// ST'FAIL);
        (GOTO ST'ENT[FN - NMFN] IF P # 0 ELSE FR'SNUTC)
         IF FN < NSFN AND NOT FN < NMFN;
        MST'SPT'FIELD(N, FN, V// TFR); RETURN;

ST'FAIL: FR'SFLNM;* NON-EXISTENT NAME OR NON-SETTABLE FIELD

* DEFAULT CIOS
ST'CIOS: P.USPTCIOS ← V; RETURN;

* OWNER LOCK
ST'OL:   TEST'SPTO(N:N, P, C// TFR); P.USPTOL ← V; RETURN;

* DEFAULT ACCESS KEY
ST'DAK:  MREAD'OFT(V, OA// TFR); I ← @OA[0].OFTAL;
        FR'FNACC IF (UOFT[V] V' I) A' (1 LSH C) = 0 ELSE
         SET'OFT'AL(V, I V' (1 LSH N)// SF'PUNT);
        P.FL ← V WHERE FL ← USPTFL[FN - NMFN]; RETURN;
        END;

        PROGRAM SPT'TFNS; INCLUDE UCALLDECS, UTS'SPTAB;
*
* CHECK SUB-PROCESS NUMBER
*
         INT N, C, M, F, ERMSNO; CHR ERCODE; PTR P;

         ARBENT TEST'SPTO(N), FRETURN; F ← 1; GOTO TEST;
        ARBENT TEST'SPTC(N), FRETURN; F ← 2; GOTO TEST;
        ARBENT TEST'SPTN(N), FRETURN; F ← 0;

TEST:    C ← READ'CSP(); N ← C IF N < 0;
        P ← USPT[N] IF N <= NSPT AND N > 0 ELSE FR'SIXOB;
        GOTO XIT IF F = 0;

         M ← READ'KEY(C);
        GOTO XIT IF M A' (P.USPTOL IF P ELSE
         MRD'SPT'FIELD(N, 'OL'// SF'PUNT)) # 0;
        FR'SNOWN IF F = 1;
        FR'SNCTL IF M A' MRD'SPT'FIELD(N, 'CL'// SF'PUNT) = 0;

XIT:     RETURN (N, P, C);
        END;

        PROGRAM CONV'NAME; INCLUDE UCALLDECS, SIBDECS;
*
* CONVERT FROM UTILITY FILE NAME TO BASIC NAME
*

         INT K, T, ERMSNO; CHR ERCODE;
        INTARY IA, OA, IA'[LUFN], OA'[LUFN+2]; PTR IP', OP';

         ARBENT ECV'NM(IA, OA, K) UCF(12);

         IP' ← @IA'[0]; OP' ← @OA'[0];
        K ← CONV'KEY(K// TFR); BCOPY(IP', @IA[0], LUFN);
L:      READ'MIBOB'NAME(IA', LSIBN-2, OA', 0, K// TFR);
        IF T ← OP'.SIBNOT = SIBLKCD DO;
            READ'MIBOB'NAME(IA', LUFN, OA',
             (LSIBN-2) + OP'.SIBNLL, K// SF'PUNT);
            BCOPY(IP', @(OP'.SIBLKUN), LUFN); GOTO L;
        ELSE DO;
            BCOPY(@OA[0], IP', LUFN);
        ENDIF;
        RETURN (K, T, OP'.SIBNAA);
        END;

        PROGRAM CONV'KEY; INCLUDE UCALLDECS, UTS'SPTAB, OFTDECS;
*
* CONVERT UTILITY ACCESS KEY TO BASIC KEY
*
         INT K, T, I, J, M, ERMSNO; CHR ERCODE; PTR XADK;
        INTARY A[LOFT], L[4]; PTR P;
        MACRO ADD'KEY ← .BSX ADK;

         INTENT ECV'KEY(K) UCF(21); GOTO AROUND;* THE FRETURN PROBLEM!!!

ADK:     .STX XADK;
        GOTO ADKX IF L[J] = T FOR J ← I + 1 TO 3;
        FR'ACKLO IF I < 0; L[I] ← T; I ← I - 1;
ADKX:   .BRU $XADK;

AROUND:  J ← READ'CSP();
        IF K < 0 DO;
            P ← USPT[J];
            K ← ((P.USPTUAK IF K = -1 ELSE
             K ← P.USPTCAK IF K = -2 ELSE 0) IF P ELSE 0);
        ENDIF;

         I ← 3; M ← READ'KEY(J);
        FOR T ← K A' 77B WHILE K # 0 DO;
            K ← K RSH 6;
            IF T # 0 DO;
                MREAD'OFT(T, A// NXT: ERCODE, ERMSNO);
                IF (P.OFTUB WHERE P ← @A[0]) AND P.OFTOT = SIBAKCD AND
                 (P.OFTCL V' P.OFTAL) A' M # 0 DO;
                    ADD'KEY;
                    IF P.ACK0 = 0 AND P.ACK1 = 0 AND P.ACKUN = PROC'OWNER DO;
                        IF T ← A'FRIEND # 0 DO; ADD'KEY; ENDIF;
                        IF T ← G'FRIEND # 0 DO; ADD'KEY; ENDIF;
                    ENDIF;
                ENDIF;
NXT:
            ENDIF;
        ENDFOR;

         K ← 0; K ← K LSH 6 V' L[J] FOR J ← I + 1 TO 3;
        RETURN K;
        END;

        PROGRAM FIND'FILE;
        INCLUDE UCALLDECS, OFTDECS, SIBDECS, PMTDECS;
*
* FIND FILE NAME FROM OFT ENTRY
*
         INT I, K, T, ERMSNO; CHR ERCODE; LN UNDK;
        INTARY FA, OA[LOFT], SA[LSIBN], PA[LPMT]; PTR FP, OP;

         ARBENT FIND'FILE(I, FA, K), FRETURN;

         MREAD'OFT(I, OA// TFR);
        T ← OP.OFTMIX WHERE OP ← @OA[0];
        READ'PMT(OP.OFTPMIB, PA// SF'PUNT);
        UNDK$UNDKUN ← OP.OFTUN$UQNOWN;
        READ'MIBOB'INDEX(UNDK, LSIBN-2, SA, T, UTS'KEY// TFR);
        BCOPY(@(FP.UFNFN), @(@SA[0].SIBNFN), LFN) WHERE
         FP ← @FA[0];
        FP.UFNUN ← UNDK; FP.UFNEN ← T; RETURN;
        END;

        PROGRAM FILE'LOCK'FCNS; INCLUDE UCALLDECS, UTS'OFTAB, RTIDECS;

         INT I, K, LC, RT, WT, ERCODE; PTR P; CHR ERMSNO;
        INTARY FA; LN TM; INTFL W0(0);

* EXTEND LOCKING TIME ON FILE
         ARBENT EXTEND'FILE'LOCK(P);
        FIND'FILE(I, FA, UTS'KEY// SF'PUNT) WHERE I ← P.EVENTFL;
        SET'FILE'LOCK(FA,
         'XWL' IF (LOCK'ACT RSH UOFT[I]$UOFTAC) A' 1 ELSE 'XRL',
         TM$W0 + 2, UTS'KEY: LC, RT, WT// SF'PUNT) WHERE
         TM ← REAL'INTERVAL(30*60000);
        SCHED'EVENT(TM, P); RETURN;

* FUNCTIONAL FOR CLOSING FILE (CALLED FROM DELETE'EVENT)
         ARBENT CLOSE'SEARCH(P);
        RETURN (1 IF P.EVENTFN = EXTEND'FILE'LOCK AND
         P.EVENTFL = SEARCHFL ELSE 0);
        END;

        PROGRAM OPEN'FILE; INCLUDE UCALLDECS, UTS'OFTAB;
*
* OPEN FILE (WITH LINK CONVERSION)
*

         INT OFI, ACC, KEY, T, OT, LC, RT, WT, ERMSNO; CHR ERCODE;
        INTARY FNA, OFA[LUFN]; LN TM; INTFL W0(0);
        CHRARY NM[5] ← ('RW', 'RO', 'OW', 'RU', 'WU');
        INTARY VL[5] ← (14B, 10B, 15B, 10B, 14B);

         INTENT EOPN'FL(OFI, FNA, ACC, KEY) UCF(16);

         IF @FNA[0].UFNEN < 0 DO;* CREATE SMALL FILE
        CREATE'MIBOB(FNA, SIBSFCD, KEY ← CONV'KEY(KEY// TFR)// VALUE
         (GOTO NCR IF ERCODE = 'NAE' ELSE FRETURN (ERCODE, ERMSNO)):
         ERCODE, ERMSNO);
            SET'MIBOB'ACCESS(FNA, NORM'FIL'AC, KEY// SF'PUNT);
            BCOPY(@OFA[0], @FNA[0], LUFN);
            OT ← SIBSFCD; T ← 17B; GOTO OPN;
        ENDIF;

NCR:     CONV'NAME(FNA, OFA, KEY: KEY, OT, T// TFR); GOTO OPN;

         INTENT UOPEN'FILE(OFI, FNA, ACC, OT, T, KEY), FRETURN;
        BCOPY(@OFA[0], @FNA[0], LUFN);

OPN:     ACC ← CODE'LKP(ACC, NM, 0// FR'FOPCD);
        FR'FNACC IF VL[ACC] A' N' T # 0;
        T ← (RO'ACT RSH ACC) A' 1;

         IF OT <= SIBLFCD DO;
            GOTO NXT;**** REMOVE EVENTUALLY
            SET'FILE'LOCK(OFA, 'IWL' IF T ELSE 'IRL', TM$W0, KEY:
             LC, RT, WT// SF'PUNT) WHERE TM ← REAL'INTERVAL(30*60000);
            ER'FILIU & GOTO ABORT IF (LOCK'ACT RSH ACC) A' 1 AND
             (T AND LC # 0 OR LC$WL # 0);
NXT:
        ENDIF;
        OFI ← MOPEN'FILE(OFI, OFA, T, KEY// ABORT: ERCODE, ERMSNO);
        IF OT <= SIBLFCD DO;
            GOTO XIT;**** REMOVE EVENTUALLY
            T ← MAKE(5); T.EVENTFN ← EXTEND'FILE'LOCK;
            T.EVENTFL ← OFI; SCHED'EVENT(TM, T);
XIT:
        ENDIF;

         UOFT[OFI] ← ACC @ UOFTAC V' OT @ UOFTOT V' T @ UOFTCL WHERE
         T ← 1 LSH READ'CSP();
        SET'OFT'AL(OFI, T// SF'PUNT);
        MARK'UCALL(); MSET'OFT'CL(OFI, USPNM// SF'PUNT);
        UNMARK'UCALL(); RETURN OFI;

ABORT:   GOTO OUT;*  TEMP FIX .  MUST FIX FOR OT>1
        IF OT <= SIBLFCD DO;
            SET'FILE'LOCK(OFA, 'DWL' IF T ELSE 'DRL', 0, KEY:
             LC, RT, WT// SF'PUNT);
OUT:        FRETURN (ERCODE, ERMSNO);
        ENDIF;
        END;

        PROGRAM SET'OFT'CL; INCLUDE UCALLDECS, UTS'OFTAB;
*
* SET (UTILITY) FILE CONTROL LOCK AND CLOSE FILE IF NECESSARY
*
         INT I, V, T, LC, RT, WT, ERMSNO; CHR ERCODE;
        INTARY FA[LUFN];

         ARBENT ESET'OCL(I, V) UCF(20);

         FR'FIXOB IF I <= 0 OR I > NOFT;
        FR'FNCTL IF UOFT[I]$UOFTCL A' READ'KEY(READ'CSP()) = 0;

         ARBENT USET'OCL(I, V), FRETURN;

         IF UOFT[I]$UOFTCL ← V = 0 DO;
            MARK'UCALL();
            IF UOFT[I]$UOFTOT <= SIBLFCD DO;
                GOTO NXT;**** REMOVE EVENTUALLY
                DELETE'EVENT(CLOSE'SEARCH) WHERE SEARCHFL ← I;
                FIND'FILE(I, FA, UTS'KEY// SF'PUNT);
                SET'FILE'LOCK(FA, 'DWL' IF (RO'ACT RSH T) A' 1 ELSE 'DRL',
                 UTS'KEY:      LC, RT, WT// SF'PUNT);
NXT:
            ENDIF;
            UOFT[I] ← 0;
            MSET'OFT'CL(I, 0// SF'PUNT);
            UNMARK'UCALL();
        ENDIF;
        RETURN;
        END;

        PROGRAM CLOSE'FILE; INCLUDE UCALLDECS, UTS'OFTAB;
*
* PROGRAM TO REMOVE CALLER'S CONTROL OF A FILE
*
         INT I, M, N, T, ERMSNO; CHR ERCODE;

         ARBENT ECLS'FL(I) UCF(17);
        M ← N'(N ← 1 LSH READ'CSP());
        IF I >= 0 DO;
            USET'OCL(I, UOFT[I]$UOFTCL A' M// TFR);
        ELSE DO;
            FOR I ← 1 TO NOFT DO;
                USET'OCL(I, T A' M// SF'PUNT)
                 IF (T ← UOFT[I]$UOFTCL) A' N # 0;
            ENDFOR;
        ENDIF;
        RETURN;
        END;

        PROGRAM ABRV'LKP; INCLUDE UCALLDECS;
*
* LOOK-UP NAME IN TABLE
*

         ST INPST, VALST, NXTST; STARY TABLE;
        INT ENTNO, VAL, ERCODE;

         INTENT EAB'LKP(INPST, TABLE) UCF(4);

INIT:
        FOR ENTNO ← ARRAYUB(@TABLE) BY -1 TO ARRAYLB(@TABLE) DO;
            NXTST ← TABLE[ENTNO];
            MATCH(INPST, NXTST// INFL); GOTO MTCH;
INFL:
        ENDFOR;    FR'NNFND;

MTCH:    VALST ← NXTST; VAL ← ENTNO; GOTO CONT;

         INTENT ECAB'LKP(INPST, VALST, TABLE) UCF(5);
        GOTO INIT IF EMPTY(VALST);
        VAL ← -1; ENTNO ← ARRAYUB(@TABLE)+1;

CONT:
        FOR ENTNO ← ENTNO - 1 BY -1 TO ARRAYLB(@TABLE) DO;
            NXTST ← TABLE[ENTNO]; MATCH(INPST, NXTST// MTFL);
            GOTO MTCH IF AMBIG(INPST, VALST, NXTST// AMBG) # 0;
MTFL:
        ENDFOR;    RETURN VAL;

AMBG:
        FOR ENTNO ← ENTNO - 1 BY -1 TO ARRAYLB(@TABLE) DO;
            NXTST ← TABLE[ENTNO]; MATCH(INPST, NXTST// AMFL);
            GOTO MTCH IF AMBIG(INPST, VALST, NXTST// AMFL) # 0;
AMFL:
        ENDFOR;    FR'NMAMB;
        END;

        PROGRAM MATCH'FNS; INCLUDE UCALLDECS;
*
* STRING COMPARISON FUNCTIONS
*
* THESE ARE THE HEART OF THE ABBREVIATION LOOK-UP
*

         ST SRCST, TABST, NXTST; INT CHAR;

* ALWAYS MATCH FUNCTION
         ARBENT NULL'TEST(SRCST, TABST), FRETURN; RETURN;

* PARTIAL MATCH FUNCTION
         ARBENT MATCH(SRCST, TABST), FRETURN;

         FRETURN IF EMPTY(TABST) OR GC(TABST) = ' ';

MTC1:    CHAR ← GCI(SRCST// RETURN);
        GOTO MTC4 IF CHAR = SEPCH ELSE RETURN IF CHAR = ' ';
        GOTO MTC1 IF GCI(TABST// FRETURN) = CHAR ELSE FRETURN;

* LOOK FOR MATCHING '-'
MTC4:    GOTO MTC1 IF GCI(TABST// FRETURN) = SEPCH ELSE GOTO MTC4;

* EXACT MATCH FUNCTION
         ARBENT EQUAL(SRCST, TABST), FRETURN;

EQL1:    CHAR ← GCI(SRCST// EQL2); GOTO EQL2 IF CHAR = ' ';
        FRETURN IF GCI(TABST// FRETURN) # CHAR ELSE GOTO EQL1;

EQL2:    FRETURN IF GCI(TABST// RETURN) # ' ' ELSE RETURN;

* PARTIAL MATCH, AND CHECK FOR AMBIGUITY
         INTENT AMBIG(SRCST, TABST, NXTST), FRETURN;

         GOTO AMB1B IF EMPTY(NXTST) OR GC(NXTST) = ' ';

AMB1A:   GOTO AMB1D IF CHAR ← GCI(SRCST// AMB1D) = ' ';
        GOTO AMB2A IF CHAR = SEPCH;
        NC'PUNT IF GCI(TABST// LF'PUNT) # CHAR;
        GOTO AMB1B IF GCI(NXTST// AMB1B) # CHAR ELSE GOTO AMB1A;

AMB1B:   RETURN 0;* OLD ENTRY BETTER

* END OF SOURCE STRING
AMB1D:   GOTO AMB1G IF GCI(TABST// AMB1E) # ' ';

* EXACT MATCH OLD
AMB1E:   GOTO AMB1B IF GCI(NXTST// AMB1F) # ' ';
AMB1F:  FRETURN;* AMBIGUOUS

* PARTIAL MATCH OLD
AMB1G:   GOTO AMB1F IF GCI(NXTST// AMB1H) # ' ';
AMB1H:  RETURN -1;* NEW BETTER

* CHECK SEPARATION
AMB2A:   GOTO AMB2B IF GCI(TABST// LF'PUNT) # SEPCH;
* EXACT IN OLD
         GOTO AMB1B IF GCI(NXTST// AMB1B) # SEPCH ELSE GOTO AMB1A;

* INEXACT OLD, HOW ABOUT NEW?
AMB2B:   GOTO AMB2B IF GCI(TABST// LF'PUNT) # SEPCH;
        GOTO AMB2D IF GCI(NXTST// AMB1B) = SEPCH;

* NEITHER EXACT
AMB2C:   GOTO AMB2C IF GCI(NXTST// AMB1B) # SEPCH ELSE GOTO AMB1A;

* NEW EXACT, OLD PARTIAL
AMB2D:   CHAR ← GCI(SRCST// AMB1H); GOTO AMB2E IF CHAR = SEPCH;
        NC'PUNT IF GCI(TABST// LF'PUNT) # CHAR;
        GOTO AMB1B IF GCI(NXTST// AMB1B) # CHAR ELSE GOTO AMB2D;

AMB2E:   GOTO AMB2E IF GCI(TABST// LF'PUNT) # SEPCH;
AMB2F:  GOTO AMB2F IF GCI(NXTST// AMB1B) # SEPCH ELSE GOTO AMB2D;

******    BUT WHAT ABOUT "XYZ" VS "XYZ-PDQ" WHERE "X" IS INPUT?
        END;

        PROGRAM CTP'TST; INCLUDE COMDECS;
*
* TEST FOR COMMAND TYPES
*
         INT T, V;

         INTENT CTP'TST(T, V);
        RETURN (1 IF ((V=6'TCMD' OR V=6'PCMD' OR V=6'PIF ') AND
                      (T=6'    ' OR T=V)) ELSE 0);


        END;

        PROGRAM NAME'SEARCH; INCLUDE UCALLDECS, SIBDECS, NAME'SEARCH'V;
*
* THIS PROGRAM CONTAINS THE DRIVERS FOR ALL VARIANTS OF THE DIRECTORY
*  SEARCH.  THE ANALYSIS IS QUITE HAIRY AND WILL NOT BE DESCRIBED HERE.
*  THE BASIC LOOKUP PROCEDURE IS SIMILAR TO THE ABRV'LKP CALL.  THE
*  OPTIONS ARE GOVERNED BY SEVERAL STATE FLAGS.
*

         INT CF;* COMMAND-SEARCH FLAG
        INT PF;* PARTIAL-NAME SEARCH FLAG
        INT NF;* NEW-NAME FLAG
        INT QF;* QUOTED-NAME FLAG

         ST FS;* FILE STRING PARAMETER
        CHR TP;* TYPE PARAMETER
        INTARY FA; PTR FP;* ARRAY (& POINTER) FOR FILE NAME
        INT K;* ACCESS KEY PARAMETER

         ST MS;* MAIN-NAME STRING
        ST NS;* NEW MAIN-NAME
        ST VS;* (CURRENT) VALUE OF MAIN-NAME
        INTFN TFN;* TEST FUNCTION FOR NEXT'SEARCH

         INTARY SA[LSIBN]; PTR SP;* STORAGE FOR SIB ENTRY
        INT ERMSNO; CHR ERCODE;

* KLUDGE FOR SPL
         INTEXT MATCH, EQUAL, NULL'TEST;

* SPECIAL NAME LOOK-UP
         ENTRY ESP'SEARCH(FS, FA, CF, K) UCF(11);
        TP ← 6'    '; GOTO NEXT'SR IF CF = 'NXT'; NF ← 0;
        PF ← 1 & GOTO NX1 IF CF = 'PAR';
        FR'ILSCD IF CF # 'COM';
        SRLIST ← COM'SRLIS; CF ← 1; PF ← 0; GOTO NX2;

* NORMAL NAME LOOK-UP
         ENTRY ENM'SEARCH(FS, FA, NF, TP, K) UCF(10); PF ← 0;
NX1:    CF ← 0; SRLIST ← FIL'SRLIS;

* SPREAD THE NAME, CHECK SYNTAX, AND INITIALIZE THE SEARCH
NX2:     SPREAD'NAME(FS, TP, K: UNDK, MS, TP, QF// TFR);
        FP ← FA[LUFN-1]; FP ← FA[0];* CHECK ARRAY BOUNDS
        FP ← @FA[0]; SP ← @SA[0];
        GOTO QT'SR IF QF;* NAME QUOTED?
        GOTO USNX1 IF NOT PF;* NOT PARTIAL?

* DETERMINE TYPE OF PARTIAL SEARCH
         GOTO PTY'SR IF EMPTY(MS);* NO MAIN NAME?
        PF ← 0 IF TP # 6'    ';* FULL NAME PRESENT?

* SEARCH FOR FIRST MATCH
USNX1:   DSCN(MATCH, SA, MS: NS// FR'NNFND);* NO MATCH IF FAILS
        GOTO USNX1 IF CF AND NOT CTP'TST(TP, SP.SIBNTY);

* FOUND BEST MATCH (SO FAR)
USFND:   BCOPY(@(FP.UFNFN), @(SP.SIBNFN), LMN IF PF ELSE LFN);
        FP.UFNTY ← 6'    ' IF PF;
        FP.UFNEN ← SP.SIBNEN; FP.UFNUN ← UNDK;
        NAMSET(VS, NMNCH, @(FP.UFNMN), LNCH);
        EQUAL(MS, VS// USNX2);* EXACT MATCH?

* TRY FOR RETURN
         RETURN IF CF OR PF OR FP.UFNTY = TP;

* LOOK FOR NEXT MATCH
USNX2:   DSCN(MATCH, SA, MS: NS// USXIT);* END ON FAILURE
        GOTO USNX2 IF CF AND NOT CTP'TST(TP, SP.SIBNTY);
        EQUAL(VS, NS// USNX3);* CHECK POSSIBLE AMBIGUITY
        FR'TPAMB IF CF OR NOT PF AND TP = 6'    ' ELSE
         GOTO USNX2 IF PF OR TP # SP.SIBNTY ELSE GOTO USFND;
USNX3:  GOTO USFND IF AMBIG(MS, VS, NS// USAMB) ELSE
        GOTO USNX2;

* END OF SEARCH
USXIT:   RETURN IF CF OR PF OR TP = 6'    ' OR TP = FP.UFNTY;
        FR'NNFND IF NOT NF;
        FP.UFNEN ← -1; FP.UFNTY ← TP; RETURN;

* INPUT CURRENTLY AMBIGUOUS
USAMB:   DSCN(MATCH, SA, MS: NS// FR'NMAMB);* AMBIGUOUS IF FAILURE
        GOTO USAMB IF CF AND NOT CTP'TST(TP, SP.SIBNTY);
        GOTO USFND IF AMBIG(MS, VS, NS// USAMB);
        GOTO USAMB;

* SEARCH FOR TYPE ONLY
PTY'SR:  FR'ILNAM IF TP = 6'    ';* MUST HAVE TYPE
TSNXT:  DSCN(NULL'TEST, SA, MS: NS// FR'NNFND);
        GOTO TSNXT IF TP # SP.SIBNTY;
        BSET(@(FP.UFNFN), 0, LMN); FP.UFNTY ← TP;
        FP.UFNEN ← SP.SIBNEN; FP.UFNUN ← UNDK; RETURN;

* QUOTED NAME LOOK-UP
QT'SR:   (GOTO QTNXT IF (CF OR PF) ELSE FR'TPAMB) IF TP = 6'    ';
* MUST (NOW) BE ABLE TO FIND NAME WITH BFS
         SETUP(NS, NMNCH, @(FP.UFNMN), LNCH); SCOPY(NS, MS// LF'PUNT);
        REPEAT; WCI(' ', NS// QTMNF); ENDRPT;
QTMNF:  FP.UFNTY ← TP; FP.UFNUN ← UNDK;
        READ'MIBOB'NAME(FA, 0, SA, 0, KEY// QTNNF: ERCODE, ERMSNO);
QTXIT:  FP.UFNEN ← SP.SIBNEN; RETURN;* FOUND EXISTING NAME

* EXIT NOT HAVING SCORED
QTNNF:   FR'NNFND IF NOT NF; FP.UFNEN ← -1; RETURN;

* LOOK UP PARTIAL/COMMAND NAME
QTNXT:   DSCN(EQUAL, SA, MS: NS// FR'NNFND);
        GOTO QTNXT IF CF AND NOT CTP'TST(TP, SP.SIBNTY);
        BCOPY(@(FP.UFNFN), @(SP.SIBNFN), LFN);
        FP.UFNEN ← SP.SIBNEN; FP.UFNUN ← UNDK; RETURN;

* SEARCH FOR NEXT NAME WHICH MATCHES
NEXT'SR: SRLIST ← FIL'SRLIS;
        SPREAD'NAME(FS, TP, K: UNDK, MS, TP, QF// TFR);

         FP ← FA[LUFN-1]; FP ← FA[0];
        FP ← @FA[0]; SP ← @SA[0];
        ENTNO ← FP.UFNEN;
* SET-UP/RESTORE SCAN STATE
         IF SRFLG >= 0 DO;
            IF ENTNO >= 0 DO;
                UNO ← FP.UFNUN$UNDKUN;
                FOR SRFLG ← 0 TO LSRLIS-1 DO;
                    IF UNO = SRLIST[SRFLG] DO;
                        SRFLG ← SRFLG + 1;
                        GOTO NSTST;
                    ENDIF;
                ENDFOR;
                FR'IPUNO;* ILLEGAL USER NUMBER
            ELSE DO;
                SRFLG ← 0; ENTNO ← -1;
            ENDIF;
        ENDIF;

* SET UP MATCH/EQUAL AS SCAN TEST FUNCTION
NSTST:   TFN ← (EQUAL IF QF AND NOT EMPTY(MS) ELSE MATCH);

* SCAN TO NEXT MATCH
NSNXT:   DSCN(TFN, SA, MS: NS// FR'ENDSR);* FAILURE ENDS SEARCHING
        (GOTO NSNXT IF SP.SIBNTY # TP) IF TP # 6'    ';
        BCOPY(@(FP.UFNFN), @(SP.SIBNFN), LFN);
        FP.UFNEN ← SP.SIBNEN; FP.UFNUN ← UNDK; RETURN;
        END;

        PROGRAM SPREAD'NAME; INCLUDE UCALLDECS, NAME'SEARCH'V;
*
* GET FILE:NAME (CHECKS SYNTAX AND 'SPREADS' NAME)
*

         INT K, Q, MQ, ERMSNO; CHR TY, C, ERCODE;
        ST FS, TS, MS;
        MACRO ICH(C) ← (C >= 'A' AND C <= 'Z' OR C = '$' OR C = '*' OR
         C ='/' OR C ='?');
        MACRO MCH(C) ← (ICH(C) OR C >= '0' AND C <= '9');

         ENTRY ESPR'NM(FS, TY, K) UCF(13);
        KEY ← CONV'KEY(K// TFR); UNDK$UNDKDK ← SRFLG ← Q ← MQ ← 0;
        GOTO CK'UN IF C ← GCI(FS// NUL'IP) = '@';
        GOTO CK'IQT IF C # '#'; UNO ← CSN(FS, 10// SYN'ER);
        GOTO SYN'ER IF C ← GCI(FS// SYN'ER) # ':' ELSE GOTO UN'XIT;

* COLLECT AND LOOK-UP USER NAME
CK'UN:   MS$BP ← MS$RP ← FS$RP;
        C ← GCI(FS// SYN'ER); GOTO SYN'ER IF NOT MCH(C);
COL'UN: C ← GCI(FS// SYN'ER);
        C ← GCI(FS// SYN'ER) IF C = SEPCH;
        GOTO COL'UN IF MCH(C) ELSE GOTO SYN'ER IF C # ':';
        MS$WP ← MS$EP ← INCDES(FS$RP, -1);
        TS ← ST'DESC(2, @UNO, 8, 1); UNO ← 0;
        READ'UP'ITEM('UP', -1, 0, MS, "#", TS, KEY// TFR);
UN'XIT: SRFLG ← -1; C ← GCI(FS// NUL'IP);

CK'IQT:  GOTO INIT'MN IF C # DQTCH;
* NAME IS QUOTED
         Q ← MQ ←  -1; C ← GCI(FS// SYN'ER);* NAME IS QUOTED

* COLLECT MAIN:NAME
INIT'MN: MS$BP ← INCDES(FS$RP, -1);* SAVE START OF MAIN:NAME
        GOTO SYN'ER IF NOT ICH(C);
COL'MN: C ← GCI(FS// END'IP);
        C ← GCI(FS// END'IP) IF C = SEPCH;* GOT HYPHEN
        GOTO CK'FQT IF MQ AND C = DQTCH ELSE
         GOTO COL'MN IF MCH(C);
        MS$EP ← INCDES(FS$RP, -1); GOTO CK'TYP;

* CHECK IF MATCHING QUOTE
CK'FQT:  MQ ← 0; MS$EP ← INCDES(FS$RP, -1);
        C ← GCI(FS// EXIT);

* CHECK FOR TYPE FIELD
CK'TYP:  GOTO SYN'ER IF C # ':'; SETUP(TS, NTYCH, @TY, LNCH);

* COLLECT TYPE
COL'TY:  C ← GCI(FS// END'TY);
        GOTO CK'TQT IF MQ AND C = DQTCH ELSE
         GOTO SYN'ER IF NOT MCH(C);
        WCI(C, TS// LEN'ER); GOTO COL'TY;
CK'TQT: MQ ← 0; GCI(FS// END'TY); GOTO SYN'ER;
END'TY: REPEAT; WCI(' ', TS// EXIT); ENDFOR;

* END OF STRING
END'IP:  MS$EP ← FS$WP; GOTO EXIT IF NOT MQ;
* SYNTAX ERROR
SYN'ER:  FR'SYNER;

* EMPTY NAME
NUL'IP:  MS$BP ← MS$EP ← FS$WP;

EXIT:    MS$RP ← MS$BP; MS$WP ← MS$EP;
        GOTO LEN'ER IF LENGTH(MS) > NMNCH;
        TY ← 6'    ' IF TY = 6'*   ';* LOOK FOR '*:*'
        (MS$WP ← MS$EP ← MS$BP IF GC(MS) = '*')
         IF LENGTH(MS) = 1;
        UNO ← SRLIST[0] & SRFLG ← (-1 IF Q ELSE 1) &
         LSRLIS ← ARRAYUB(@SRLIST) + 1 IF SRFLG >= 0;
        ENTNO ← -1; RETURN (UNDK, MS, TY, Q);

LEN'ER:  FR'NMLEN;
        END;

        PROGRAM DSCN; INCLUDE UCALLDECS, SIBDECS, NAME'SEARCH'V;
*
*  SCAN TO NEXT DIRECTORY ENTRY MATCHING ARGUMENTS
*
* THIS ROUTINE USES THE SEARCH VARIABLES TO DETERMINE WHERE TO
*  START (OR PICK UP) THE SCAN.  IT IMPLEMENTS THE ACCOUNT- AND GROUP-
*  FRIEND MECHANISM.
*
         INTFN TF;* TESTING FUNCTION FOR ENTRY
        INTARY SA; PTR SP;* ARRAY (POINTER) FOR SIB NAME ENTRY
        ST MS;* MAIN-NAME STRING
        ST NS;* DESCRIPTOR FOR SA MAIN-NAME
        CHR ERCODE; INT ERMSNO;

         STENT DSCN(TF, SA, MS), FRETURN; SP ← @SA[0];

LOOP:
        FOR ENTNO ← ENTNO + 1 REPEAT;

* READ WITH NORMAL KEY
             READ'MIBOB'INDEX(UNDK, LSIBN-2, SA, ENTNO, KEY// VALUE
             (GOTO NXDIR IF ERCODE = 'MOB' ELSE
             GOTO NXENT): ERCODE, ERMSNO);

* CHECK ENTRY FOR 'MATCH'
TEST:        NAMSET(NS, NMNCH, @(SP.SIBNMN), LNCH);
            TF(MS, NS// NXENT); RETURN NS;

NXENT:
        ENDRPT;

* GO TO NEXT DIRECTORY ON SEARCH LIST OR TERMINATE SEARCH
NXDIR:   FRETURN IF SRFLG < 0 OR SRFLG >= LSRLIS;
        UNO ← SRLIST[SRFLG]; SRFLG ← SRFLG + 1;
        ENTNO ← -1; GOTO LOOP;

        END;

        PROGRAM CNS; INCLUDE COMDECS;
        INT N, F, R, T, I, D; PTR P; ST S, B(25); STFL A(0);

         ARBENT CNS(N, STRING @P, F, R), FRETURN;

         S ← P.A;
        FRETURN IF R < 2 OR R > 36;
        T ← (-N IF F >= 0 AND N < 0 ELSE N);
        B$RP ← B$WP ← B$EP; I ← 0;
LP:     .LDA T; .LSHD -23; .DIV R; .STA T; .STB D;
        WCD(D +('0' IF D < 10 ELSE 'A'-10), B);
        I ← I + 1; GOTO LP IF T # 0;
        WCD('-', B) & I ← I + 1 IF F >= 0 AND N < 0;
        F ← F A' 77B;
        IF F = 0 DO;
            F ← I;
        ELSEIF F <= I DO;
            B$RP ← INCDES(B$EP, -I);
        ELSE DO;
            WCI(' ', S// FRETURN) FOR I ← I + 1 TO F;
        ENDIF;
        WCI(D, S// FRETURN)
         FOR D ← GCI(B// VALUE P.WP ← S$WP & RETURN) WHILE 1;
        END;

        PROGRAM CSN; INCLUDE COMDECS;
        PTR P; INT R, F, D, N; ST S; STFL A(0);

         INTENT CSN(STRING @P, R), FRETURN;

         S ← P.A; FRETURN IF R < 2 OR R > 36;

         IF D ← GCI(S// FRETURN) = '-' OR D = '+' DO;
            F ← (1 IF D = '-' ELSE 0); D ← GCI(S// FRETURN);
        ELSE DO;
            F ← 0;
        ENDIF;

         D ← D - '0' IF D >= '0' AND D <= '9' ELSE
         D ← D - ('A'-10) IF D >= 'A' AND D <= 'Z' ELSE FRETURN;
        FRETURN IF D >= R; N ← D;

         FOR D ← GCI(S// Y) REPEAT;
            D ← D - '0' IF D >= '0' AND D <= '9' ELSE
             D ← D - ('A'-10) IF D >= 'A' AND D <= 'Z' ELSE GOTO X;
            GOTO X IF D >= R; N ← N * R + D;
        ENDRPT;

X:       S$RP ← INCDES(S$RP, -1);
Y:      P.RP ← S$RP; RETURN (-N IF F ELSE N);
        END;

COMMON UTILITY'ERR'MSGS;

       DECLARE STRING ARRAY UMSG[54] ←

  ("CIOS INDEX?",                          "CIOS TABLE FULL",
   "INVALID CIOS FIELD NAME",              "CIOS NOT CONTROLLED",
   "UNACCEPTABLE CONTROL LOCK VALUE",      "CIOS NOT ACCESSABLE",
   "ILLEGAL LENGTH SETTING",               "ILLEGAL BREAK/WAKEUP CODE",
   "ILLEGAL NAME FOR PARTIAL SEARCH",      "COMMAND STRING TOO SHORT",
   "FILE NAME NOT FOUND",                  "FILE NAME AMBIGUOUS",
   "FILE TYPE NOT SPECIFIED OR AMBIGUOUS", "ILLEGAL USER NUMBER FOR 'NXT' SEARCH",
   "END OF 'NXT' SEARCH",                  "FILE NAME SYNTAX ERROR",
   "FILE MAIN:NAME TOO LONG",              "ERROR MESSAGE STRING TOO SHORT",
   "UNIMPLEMENTED CIOS FEATURE",           "SUB-PROCESS TABLE FULL",
   "SUB-PROCESS INDEX OUT OF BOUNDS",      "SUB-PROCESS NOT OWNED",
   "SUB-PROCESS NOT CONTROLLED",           "ILLEGAL SPECIAL SEARCH CODE",
   "USER-PROFILE ENTRY NOT FOUND",         "USER-PROFILE ITEM NOT FOUND",
   "USER-PROFILE VALUE TOO LONG",          "USER-PROFILE ACCESS DENIED",
   "NO MORE SPACE IN USER-PROFILE",        "DUPLICATE USER-PROFILE ENTRY",
   "ILLEGAL SUB-PROCESS FIELD NAME",       "NOT UTILITY SUB-PROCESS",
   "NAME STRING TOO SHORT",                "ILLEGAL SUB-PROCESS NAME STRING",
   "ILLEGAL ATTACH FILE HEADER",           "ILLEGAL ERROR MESSAGE NUMBER",
   "ILLEGAL OPEN FILE CODE",               "INSUFFICIENT ACCESS TO OBJECT",
   "FILE IN USE",                          "OFT INDEX OUT OF BOUNDS",
   "SUB-PROCESS DOES'NT CONTROL OFT ENTRY","ATTACHED OBJECT NOT A FILE",
   "INTERRUPTED IN UTILITY",               "NON-ZERO BUFFER-SET COUNT",
   "ACCESS KEY LIST OVERFLOW",             "PROCESS PROFILE VALUE STRING TOO SHORT",
   "PROCESS PROFILE NAME NOT FOUND",       "ILLEGAL USER NUMBER IN SEARCH LIST",
   "SEARCH LIST INPUT TOO LONG",           "USER NUMBER NOT INTEGER",
   "ILLEGAL EDIT CONVENTION",              "ILLEGAL PROFILE TYPE",
   "PROFILE ITEM NAME INVALID",            "NO NAME SUPPLIED FOR CREATE USER/ENTRY");


END;

        PROGRAM ERRORMSG;
*
* COPY ERROR MESSAGE TO STRING
*
         INCLUDE UTILITY'ERR'MSGS, UCALLDECS;
         INT CODE; ST MSG;

         STENT EERRORMSG(CODE, MSG) UCF(1);

         IF CODE < 0 DO;
            FR'ILEMN IF CODE ← - CODE > 54;
            APPEND(MSG, UMSG[CODE-1]// FR'EMFUL);
         ELSE DO;
            FR'ILEMN IF CODE > 200;* CHECK AGAINST CODE FOR NUMBER
            APPEND(MSG, "MONITOR ERROR "// FR'EMFUL);
            CNS(CODE, MSG, 4B7, 10// FR'EMFUL);
         ENDIF;
         RETURN MSG;
 
        END;

        PROGRAM GET'PARAM; INCLUDE UCALLDECS;
*
* GET NEXT PARAMETER
*
         ST L, P; PTR A; INT C; STFL B(0);

         STENT EGET'PARAM(STRING @A) UC(2);

         L ← A.B;*?* MUST RINGCHECK A

* SCAN OVER INITIAL BLANKS
IBLP:    C ← GCI(L// EINIS); GOTO IBLP IF C = ' ';
        P$BP ← INCDES(L$RP, -1);
        (P$EP ← P$BP & GOTO FTRM)
         IF C = ',';* NULL PARAMETER

* SCAN OVER PARAMETER
PRLP:    C ← GCI(L// EPARS);
        GOTO PRLP IF C # ' ' AND C # ',';
        P$EP ← INCDES(L$RP, -1);
        GOTO FTRM IF C = ',';

* ELIMINATE BLANKS
ITRM:    C ← GCI(L// EXIT);
        GOTO ITRM IF C = ' ' ELSE GOTO EPAR IF C # ',';

* ELIMINATE TRAILING BLANKS
FTRM:    GOTO FTRM IF GCI(L// EXIT) = ' ';

* END OF COMPLETE PARAMETER
EPAR:    L$RP ← INCDES(L$RP, -1);
EXIT:   P$RP ← P$BP; P$WP ← P$EP;
        A.RP ← L$RP; RETURN P;
* END OF  STRING
EINIS:   P$BP ← L$RP;
EPARS:  P$EP ← L$RP; GOTO EXIT;
        END;

        PROGRAM GET'COMLINE; INCLUDE UCALLDECS;
* COPY SAVED COMMAND LINE TO USER
         ST L;

         STENT EGET'CLINE(L) UCF(3);* GET COMMAND LINE FROM CP
        SETS(L, 0,0);
        WCI(GCI(SAVED'LINE// RETURN L), L// FR'CLFUL) WHILE 1;
        END;

        PROGRAM GET'CMPCOMLINE;
        INCLUDE UCALLDECS, UCALLD'KLUDGE;
* COPY SAVED COMMAND LINE AND SAVED USER NUMBER TO USER
         ST L; INT ERMSNO; CHR ERCODE;
        ARBENT EGET'CCLINE(L) UCF(6);
        RETURN (GET'COM'LINE(L// TFR), SAVED'USER);
        END;

        PROGRAM ST'CMLNE;
        INCLUDE UCALLDECS,UCALLD'KLUDGE;
*
* ROGER'S CALL TO SET COMLINE
*
*

         ST L; INT T;

         ARBENT ESET'COMLINE(L) UC(7);

         SETS(SAVED'LINE,0,0);
        IF LENGTH(L)>LNGDES(SAVED'LINE$BP,SAVED'LINE$EP) DO;
            FREE(SBASE(SAVED'LINE));
            SAVED'LINE←ST'DESC(T,MAKE((T+2)/3,0),8,0) WHERE T←LENGTH(L);
        ENDIF;
        WCI(GCI(L// RETURN),SAVED'LINE//LF'PUNT) WHILE 1;


        ARBENT ESET'SAVED'USER(T) UC(8);

        SAVED'USER←T IF T>0;
        RETURN;

        END;

        PROGRAM GETSPN; INCLUDE COMDECS;
*
* LOOK UP SUB-PROCESS NAME/NUMBER OR RETURN DEFAULT VALUE
*
         PTR P; INT S, ERMSNO; CHR ERCODE; ST N, L; STFL A(0);

         INTENT GETSPN(STRING @P, S), FRETURN;

         N ← GET'PARAM(L) WHERE L ← P.A; P.RP ← L$RP;
        RETURN SPNAME'SEARCH(N// DEFAULT: ERCODE, ERMSNO);

DEFAULT: RETURN S IF S > 0;
        SCOPY(L, "ILLEGAL SUB-PROCESS NAME OR NUMBER"// LF'PUNT);
        WCI(NLCH, L);
WRITE:  PRINT'STRING(-1, L, 0// QUIT'PUNTX(WRITE, L)); FRETURN;
        END;

        PROGRAM SPRESET; INCLUDE UCALLDECS, SPTDECS;
*
* DESTROY ALL SUB-PROCESSES AT CURRENT RECURSION LEVEL
*
         INT I, R, ERMSNO; CHR ERCODE;

         ARBENT SPRESET(R), FRETURN;
        (DESTROY'SP(I// TFR) IF READ'SPT'FIELD(I, 'OL'// SF'PUNT) AND
         READ'SPT'FIELD(I, 'RCL'// SF'PUNT) >= R) FOR I ← 1 TO NSPT;
        RETURN;
        END;

        PROGRAM CREATE'SP; INCLUDE UCALLDECS, UTS'SPTAB;
*
* CREATE SUBSIDIARY/PARALLEL SUB-PROCESS
*
         INT N, S, C, M, F, V, L, ERMSNO; PTR P; CHR ERCODE;

         INTENT ECR'PSP(N) UCF(31); S ← 0; GOTO START;

         INTENT ECR'SSP(N) UCF(30); S ← 1;

START:   C ← READ'CSP(); M ← 1 LSH C;
        FR'SNUTC IF USPT[C] = 0;
        MARK'UCALL();
        MCREATE'SP(N, 0: N// ABORT: ERCODE, ERMSNO);
        F ← (C IF S ELSE MRD'SPT'FIELD(C, 'FTH'// SF'PUNT));

         MST'SPT'FIELD(N, 'FTH', F// SF'PUNT);
        USPT[N] ← P ← MAKE(LUSPT, 0); P.USPTRCL ← RCLVL;
        MST'SPT'FIELD(N, 'CL',
         (P.USPTOL ← M V' 1 LSH F) V' 1 LSH N// SF'PUNT);

         IF V ← USPT[C].USPTCIOS # 0 AND
         ((L ← READ'CIOS'FIELD(V, 'AL'// SF'PUNT)) V'
         READ'CIOS'FIELD(V, 'CL'// SF'PUNT)) A' M # 0 DO;
            SET'CIOS'FIELD(V, 'AL', L V' 1 LSH N// SF'PUNT);
            P.USPTCIOS ← V;
        ENDIF;

         MST'SPT'FIELD(N, 'TCM',
         MRD'SPT'FIELD(C, 'TCM'// SF'PUNT) A'
         NORMAL'TCM// SF'PUNT);

         MST'SPT'FIELD(L, 'KEY',
         MRD'SPT'FIELD(L, 'CTR'// SF'PUNT)// SF'PUNT) IF
         USPT[L] # 0 FOR L ← 1 TO NSPT;

         UNMARK'UCALL();
        RETURN N;

ABORT:   UNMARK'UCALL();
        FRETURN (ERCODE, ERMSNO);
        END;

        PROGRAM ATTACH; INCLUDE UCALLDECS, SIBDECS, ATTACHDECS;
*
* ATTACH A PROGRAM IMAGE FILE TO A SUB-PROCESS
*?* MAYBE IT SHOULD INCREMENTALLY MODIFY THE MAP??
*
         INT S, K, FI, KI, M, CD, FB, SB, N, ERMSNO;
        CHR ERCODE; PTR FP, KP; ST FMS(64: 12), SMS, WS;
        INTARY FA, KA[LUFN], BN[LFN+1] ← (0, 6'OWNE', 6'R   ', 6'    ',
         6'   ', 6'KEY ');

         INTENT EAT'CH(S, FA, K) UCF(32);

         TEST'SPTC(S: S, KP, M// TFR); FR'SNUTC IF KP = 0;
        M ← 1 LSH S; FP ← @FA[0]; SMS ← FMS;

         CONV'NAME(FA, KA, K: K, CD, FB// ABORTD: ERCODE, ERMSNO);
        FR'SNFIL IF CD > SIBLFCD;

* IF CONV'NAME SUCCEEDS, CALLER MUST HAVE SOME ACCESS TO FILE - PROCEED
         MARK'UCALL();
        UOPEN'FILE(-1, KA, 'RO', CD, FB, UTS'KEY: FI// ABORTC:
         ERCODE, ERMSNO);
        MOVE'PAGE'PMT(FI, 0, ATF'PMT// ABORTB: ERCODE, ERMSNO);

         GOTO ABORTA IF ATF'PTR.ATFMT # FMTCODE OR
         ATF'PTR.ATMNM # 0;

         IF ATF'PTR.ATCUF # 0 DO;
            KP ← @KA[0]; BCOPY(@(KP.UFNEN), @BN[0], LFN+1);
            MOPEN'FILE(-1, KA, 1, UTS'KEY: KI// SET'EP: ERCODE, ERMSNO);
***       IS THIS ↑ THE RIGHT EXIT?
             SET'OFT'CL(KI, M// SF'PUNT);
            SET'SPT'FIELD(S, 'CAK', KI// SF'PUNT);
        ENDIF;

SET'EP:  N←ATF'PTR.ATEP; SET'SPT'FIELD(S, 'EP', N// SF'PUNT);
        N←ATF'PTR.ATEG; SET'SPT'FIELD(S, 'EG', N// SF'PUNT);

         NAMSET(WS, 64, @(ATF'PTR.ATMAP), 12); CD ← WS$WP;
        CD ← WS$WP WHILE FB ← GCD(WS// ABORTA) = 0;
MAP'CPY:WS$WP ← CD; SCOPY(FMS, WS// LF'PUNT);
        CLEAR'PMT(ATF'PMT// SF'PUNT);

         FOR FB ← GCI(FMS// MAP'SET) REPEAT;
            CD ← FB$BYTEC; FB ← FB$BYTEP;
            IF CD = 0 DO;* EMPTY PAGE
            SB ← 0;
            ELSE DO;
                ACQUIRE'PMT(-1: SB// ABORTB: ERCODE, ERMSNO);
                SET'PMT'CL(SB, M// SF'PUNT);
                IF CD = 1 DO;* SHARED PAGE
                MOVE'PAGE'PMT(FI, FB, SB// ABORTB: ERCODE, ERMSNO);
                ELSE DO;* NEW PAGE
                NEW'PMT'PAGE(SB// ABORTB: ERCODE, ERMSNO);
                    IF CD = 3 DO;* COPY PAGE
                    MOVE'PAGE'PMT(FI, FB, ATF'PMT// ABORTB: ERCODE, ERMSNO);
                        SET'MAP'BYTE(USP, ATP'PAGE, SB// SF'PUNT);
                        BCOPY(ATP'PTR, ATF'PTR, 4000B);
                        CLEAR'PMT(ATF'PMT// SF'PUNT);
                    ENDIF;
                ENDIF;
            ENDIF;
            WCI(SB, SMS// LF'PUNT);
        ENDRPT;

MAP'SET: SET'MAP(S, SMS// SF'PUNT);
        CLOSE'FILE(FI// SF'PUNT);
        SET'MAP'BYTE(USP, ATP'PAGE, 0// SF'PUNT);
        UNMARK'UCALL(); RETURN;

ABORTA:  ER'SNIMP;
ABORTB: CLOSE'FILE(FI// SF'PUNT);
ABORTC: UNMARK'UCALL();
ABORTD: CLEAR'PMT(ATF'PMT// SF'PUNT);
        SET'MAP'BYTE(USP, ATP'PAGE, 0// SF'PUNT);
        FRETURN (ERCODE, ERMSNO);
        END;

        PROGRAM DESTROY'SP;
        INCLUDE UCALLDECS, CIOS'TAB, UTS'SPTAB, UTS'OFTAB;
*
* DESTROY SUB-PROCESS AND ALL TOTALLY OWNED SUB-PROCESSES
*
         INT S, C, N, M, I, ERMSNO; CHR ERCODE; PTR P;

         ARBENT EDES'SP(S) UCF(33);

         TEST'SPTO(S: S, P, C// TFR); MARK'UCALL();

TRY:     N ← S;
CHECK:  M ← 1 LSH N;

         N ← I & GOTO CHECK IF (P.USPTOL IF P ← USPT[I] # 0 ELSE
         MRD'SPT'FIELD(I, 'OL'// SF'PUNT)) = M FOR I ← 1 TO NSPT;

         M ← N' M;

         FOR I ← 1 TO NCIOS DO;
            IF P ← CIOSTB[I] # 0 DO;
                P.CIOSAL ← P.CIOSAL A' M;
                DESTROY'CIOS(I) IF P.CIOSCL ← P.CIOSCL A' M = 0;
            ENDIF;
        ENDFOR;

         FOR I ← 1 TO NOFT DO;
            IF P ← UOFT[I]$UOFTCL # 0 DO;
                SET'OFT'CL(I, P A' M// SF'PUNT);
            ENDIF;
        ENDFOR;

         IF P ← USPT[N] # 0 DO;
            FREE(P, 0); USPT[N] ← 0;
        ENDIF;

         (NC'PUNT IF P.USPTOL ← P.USPTOL A' M = 0)
         IF P ← USPT[I] # 0 FOR I ← 1 TO NSPT;

         MDESTROY'SP(N// ABORT: ERCODE, ERMSNO);
        GOTO TRY IF N # S;
        UNMARK'UCALL();
        RETURN;

ABORT:   UNMARK'UCALL();
        FRETURN (ERCODE, ERMSNO);
        END;

        PROGRAM SPT'NAMES; INCLUDE UCALLDECS, UTS'SPTAB;
*
* READ/SET SPT NAME
*
         INT S, N, ERMSNO; CHR C, ERCODE; PTR P;
        ST NM, L;

         STENT ERD'SPNM(S, NM) UCF(37);

         TEST'SPTN(S: S, P, N// TFR);
        RETURN NM IF P = 0;
        NAMSET(L, NMNCH, @(P.USPTNAME), LNCH);
        WCI(C, NM// FR'SLFUL) FOR
         C ← GCI(L// RETURN NM) WHILE C # ' '; RETURN NM;

         ARBENT EST'SPNM(S, NM) UCF(38);

         TEST'SPTC(S: S, P, N// TFR);
        FR'SNUTC IF P = 0;
        SETUP(L, NMNCH, @(P.USPTNAME), LNCH);
        WCI(C, L// FR'SNLEN) FOR
         C ← GCI(NM// XIT) WHILE C # ' ';
***             CHECK C FOR VALIDITY

XIT:     WCI(' ', L// RETURN) WHILE 1;
        END;

        PROGRAM SPT'LOOKUP; INCLUDE UCALLDECS, UTS'SPTAB;
*
* LOOK UP SUB-PROCESS NAME
*
         ST IS, NS, VS; INT I, V; PTR P;

         INTENT ESP'LKP(IS) UCF(39);

         V ← CSN(IS, 10// INIT);
        FR'SIXOB IF V <= 1 OR V > NSPT ELSE RETURN V;

INIT:    FR'NNFND IF EMPTY (IS);
        FOR I ← NSPT BY -1 TO 1 DO;
            IF P ← USPT[I] # 0 DO;
                NAMSET(NS, NMNCH, @(P.USPTNAME), LNCH);
                MATCH(IS, NS// INFL); GOTO MTCH;
            ENDIF;
INFL:
        ENDFOR;
        FR'NNFND;

MTCH:    VS ← NS; V ← I;
        FOR I ← I - 1 BY -1 TO 1 DO;
            IF P ← USPT[I] # 0 DO;
                NAMSET(NS, NMNCH, @(P.USPTNAME), LNCH);
                MATCH(IS, NS// MTFL);
                GOTO MTCH IF AMBIG(IS, VS, NS// AMBG);
            ENDIF;
MTFL:
        ENDFOR;
        RETURN V;

AMBG:
        FOR I ← I - 1 BY -1 TO 1 DO;
            IF P ← USPT[I] # 0 DO;
                NAMSET(NS, NMNCH, @(P.USPTNAME), LNCH);
                MATCH(IS, NS// AMFL);
                GOTO MTCH IF AMBIG(IS, VS, NS// AMFL);
            ENDIF;
AMFL:
        ENDFOR;
        FR'NMAMB;
        END;

        PROGRAM READ'SRLIS; INCLUDE UCALLDECS;
*
* READ SEARCH LISTS
*
         ST V; INT I, L; INTARY SRLIS;

         STENT READ'COM'SRLIS(V), FRETURN;
        SRLIS ← COM'SRLIS; GOTO READ;

         STENT READ'FIL'SRLIS(V), FRETURN;
        SRLIS ← FIL'SRLIS;
READ:
        FOR I ← 0 TO L ← ARRAYUB(@SRLIS) DO;
            CNS(SRLIS[I], V, 0, 10// FRETURN);
            WCI(',', V// FRETURN) IF I < L;
        ENDFOR;
        RETURN V;
        END;

        PROGRAM SET'SRLIS; INCLUDE UCALLDECS;
*
* SET SEARCH LISTS
*
         ST V; INT L, MLSRLIS ← 20; PTR SRPTR;
        INTARY SRLIS, TSL[MLSRLIS]; ARYFL A(0);

         ARBENT SET'COM'SRLIS(V), FRETURN;
        SRPTR ← @COM'SRLIS; GOTO SET;

         ARBENT SET'FIL'SRLIS(V), FRETURN;
        SRPTR ← @FIL'SRLIS;

SET:
        FOR L ← 0 TO MLSRLIS-1 DO;
            TSL[L] ← CSN(V, 10// ABORT);
            GOTO ABORT IF GCI(V// EXEC) # ',';
*?*       FR'ILUNO IF CHECK'USER'NUMBER(TSL[L]);* VALID ?!!!
         ENDFOR;
        FR'SRLTL;* TOO MANY ENTRIES

ABORT:   FR'SRSYN;* ILLEGAL SYNTAX

EXEC:
        IF ARRAYUB(SRPTR) # L DO;
            FREE(@((SRPTR.A)[0]));
            SRPTR.A ← SRLIS ← AR'DESC(L + 1);
        ELSE DO;
            SRLIS ← SRPTR.A;
        ENDIF;
        SRLIS[L] ← TSL[L] FOR L ← L BY -1 TO 0;
        RETURN;
        END;

        PROGRAM READ'MIBOB'VALUE; INCLUDE UCALLDECS, SIBDECS;
*
* READ VALUE-PART OF MIB OBJECT
*
         INT N, I, K, ERMSNO; CHR ERCODE;
        INTARY IA, OA, TA[LSIBN];

         ENTRY ERD'MVAL(IA, N, OA, I, K) UCF(14);

         READ'MIBOB'NAME(IA, LSIBN-2, TA, 0, K// TFR);
        READ'MIBOB'NAME(IA, N, OA,
         (LSIBN-2) + @TA[0].SIBNLL + I, K// TFR);
        RETURN;
        END;

        PROGRAM DELETE'FILE; INCLUDE UCALLDECS, SIBDECS;
*
* DELETE A FILE OR OTHER MIB OBJECT
*
         INT K, P, I, ERMSNO; CHR ERCODE; INTARY VA[MLSIB], FA;

         ENTRY EDEL'FILE(FA, K) UCF(15);

         K ← CONV'KEY(K// TFR);
        READ'MIBOB'NAME(FA, LSIBN-2, VA, 0, K// TFR);

         IF @VA[0].SIBNOT <= SIBLFCD DO;
            I ← OPEN'FILE(-1, FA, 'OW', K// TFR);
            DEL'FILE'PAGE(I, P: ERCODE// SF'PUNT) FOR P ← 0,
             NEXT'FILE'PAGE(I, P// SF'PUNT) WHILE P >= 0;
            CLOSE'FILE(I// TFR);
        ENDIF;

         DELETE'MIBOB(FA, K// TFR); RETURN;
        END;

        PROGRAM READ'UP'ITEM;   INCLUDE UPCOM;
*  FUNCTION TO APPEND STRING WITH NAMED VALUE
*  READ'UP'ITEM


         ST S,N,V;
        INT E,K,USRNO,USR,GARB,ERMSNO,WHOSE;
        PTR POINT;
        ST ST1;
        CHR ERCODE,UPTYPE;

*
         STENT ERD'UP'ITM(UPTYPE,WHOSE,E,S,N,V,K) UCF(60);


*  E>0 IS USER NUMBER
*  E=0 IS USER NAME IN S
*  S   IS NAME (USR) IF ANY
*  N   IS NAME OF VALUE
*  V   IS VALUE
*
         FR'UPACD IF UPTYPE#'UP';
        LOCK'UP'R();

*                        FIND UP ENTRY IF ANY
         UPSRCH(E,S:POINT,USRNO// VALUE UNLOCK'UP'R() & FR'UPENF);

*                        USRNO SHOULD CONTAIN USER # FOR THE FOUND ENTRY
*                        WHETHER NAME OR NUMBER IS ASKED FOR
*                        FRETURN IF ENTRY NOT FOUND

*                        NOW SEARCH FOR NAME N


         FINDN(POINT,N:POINT,ST1// VALUE UNLOCK'UP'R() & FR'UPINF:GARB);

*                         CHECK TO SEE IF ITEM IS AR
         UNLOCK'UP'R() &
         FR'UPACD IF PROC'OWNER#USRNO AND NOT POINT.ARAC AND PROC'OWNER#FWA.UPSONO
         AND PROC'OWNER # FWA.UPGONO AND PROC'OWNER # FWA.UPAONO;
        APPEND(V,ST1// VALUE UNLOCK'UP'R() & FR'UPVTL);
*                         VALUE HAS BEEN APPENDED
         UNLOCK'UP'R();
        RETURN V;
        END;

        PROGRAM READ'UP'NAMES;   INCLUDE UPCOM;

         PTR ENTEND,POINT;
        INT E,K,USRNO,USR,ERMSNO;   CHR ERCODE; ST S,V,ST1; INT FLG;


         STENT ERD'UP'NM(UPTYPE,WHOSE,E,S,V,K) UCF(61);

*                         READ ACCESS AND STORE IN USE

         FR'UPACD IF UPTYPE#'UP';

*                         FIND UP ENTRY
         LOCK'UP'R();
        UPSRCH(E,S:POINT,USRNO// VALUE UNLOCK'UP'R() & FR'UPENF);
        ENTEND←POINT+POINT.ENTLLEN;
        POINT←POINT+1;
*                         GET NAMES IF ACCESS IS AR
LOOP2:   FLG←0;
        GOTO DONE IF PROC'OWNER#USRNO AND NOT POINT.ARAC AND PROC'OWNER # FWA.UPSONO
         AND PROC'OWNER # FWA.UPGONO AND PROC'OWNER # FWA.UPAONO;
        FLG←1;
        ST1←ST'DESC(POINT.NMLEN,POINT,8,2);
        ST1$WP ← ST1$EP;
*                         APPEND NAME
         APPEND(V,ST1// VALUE UNLOCK'UP'R() & FR'UPVTL);
DONE:   POINT←CALNEWPT(POINT);
        UNLOCK'UP'R() & RETURN V IF POINT>=ENTEND;
*                         APPEND COMMA
         WCI(',',V// VALUE UNLOCK'UP'R() & FR'UPVTL) IF FLG=1;
        GOTO LOOP2;
        END;

        PROGRAM SET'UP'ITEM;   INCLUDE UPCOM;

*                         SET ITEM TO VALUE V OR ELSE ADD ITEM

         INT E,K,NSIZE,VSIZE,ERMSNO,UPPLEN ← 2042;   CHR ERCODE; ST TS1,ST1,S,N,V;
        PTR SPOINT,POINT, IPOINT; INT TEM2, TEM3, TEM4, TEM5, FLAG,USR ,USRNO,TEMP;
        ENTRY EST'UP'ITM(UPTYPE,WHOSE,E,S,N,V,K) UCF(62);
*                         READ ACCESS KEY AND STORE INTO USR
         FR'UPENF IF EMPTY(N);

         LOCK'UP'W();
RETRY:  UPSRCH(E,S:POINT,USRNO// VALUE UNLOCK'UP'W() & FR'UPENF);

*                         SET UP ACCESS
         CKAC (PROC'OWNER,USRNO// VALUE UNLOCK'UP'W() & FR'UPACD);
*                         LOOK FOR N
         IPOINT←POINT; TS1←N; FLAG←0;
        FINDN(IPOINT,N:IPOINT,ST1//ADDENT:IPOINT);
        ST1$WP ← ST1$RP;
*                         N HAS BEEN FOUND

         UNLOCK'UP'W() & FR'UPACD IF IPOINT.UWAC =0
         AND PROC'OWNER = USRNO AND PROC'OWNER # FWA.UPSONO;
*  NOT USER WRITABLE
*                         FRETURN IF NOT USER WRITABLE
*                         FIND LENGTH OF STRING BEFORE STORING
         GOTO REDO IF (LNGDES(V$RP,V$WP)#IPOINT.VLEN);
*                         ELSE APPEND
         APPEND(ST1,V// VALUE UNLOCK'UP'W() & FR'UPVTL);
        UNLOCK'UP'W();
        RETURN;
*                     CHECK TO SEE IF THERE IS ENOUGH ROOM AT END OF
*              ENTRY AFTER ELIMINATING OLD ENTRY BUT SAVING ACCESS
REDO:    FLAG←IPOINT.UPAC;
        SPOINT←CALNEWPT(IPOINT);
        TEMP←POINT.ENTLLEN-(SPOINT-IPOINT);* LENGTH OF ENT-LEN OF ITEM
*                     I E NEW LENGTH
         TEM2←(POINT.ENTLLEN+POINT)-SPOINT;
*                         TEMP HAS NO OF WORDS ELIMINATED
*                         NO. OF WORDS TO COPY
         BCOPY(IPOINT,SPOINT,TEM2);
*                         ITEM IS NOW ELINIMATED.
         POINT.ENTLLEN←TEMP;
ADDENT: NSIZE←LNGDES(N$RP,N$WP);*NO OF CHARS
        VSIZE←LNGDES(V$RP,V$WP);*NO OF CHARS
        TEMP←(VSIZE+NSIZE+4)/3;*NO OF WORDS
        GOTO ADDEND IF (POINT.ENTPLEN-POINT.ENTLLEN)<TEMP;*MUST PUT PROFILE AT END
BACKIN: IPOINT←POINT+POINT.ENTLLEN;
        POINT.ENTLLEN←POINT.ENTLLEN+TEMP;
        IPOINT.UPAC←FLAG IF FLAG # 0 ELSE IPOINT.UWAC←1;
        IPOINT.NMLEN←NSIZE;
        IPOINT.VLEN←VSIZE;
        ST1←ST'DESC((IPOINT.NMLEN+IPOINT.VLEN),IPOINT,8,2);
        APPEND(ST1,N//LF'PUNT);
        APPEND(ST1,V//LF'PUNT);
        UNLOCK'UP'W();
        RETURN;
ADDEND: TEM3←POINT.ENTPLEN;
        TEM4←POINT.ENTLLEN+TEMP;
RTN:    GOTO CANT IF UPPLEN-FWA.UPLLEN<TEM4;
*                     TEM3 HAS LENGTH OF OLD UP (ENTPLEN)
*                     TEM4 HAS LENGTH OF NEW UP(ENTLLEN)
         TEM5←POINT.ENTPLEN;
        TEM2←POINT.ENTLLEN;
        BCOPY((FWA+FWA.UPLLEN),POINT,TEM2);* PUT UP AT END OF FILE
*                     MOVE ENTRY TO END OF FILE AND CLOSE HOLE
         POINT.FREEBIT←  POINT.ENTLLEN←1;
        POINT←FWA+FWA.UPLLEN;
        FWA.UPLLEN←FWA.UPLLEN+TEM4;*OLD FILE LEN LESS PHY LEN
*                                       OF OLD UP+LEN OF UP WITH NEW
         POINT.ENTPLEN←TEM4; POINT.ENTLLEN ← TEM2;
        GOTO BACKIN;
CANT:   PACKUP(); GOTO RETRY;
*                     EXPAND FILE IF MORE ROOM IS NEEDED
*                     IF THERE IS ENOUGH ROOM AT END IS NO GOOD ENOUGH
        END;

        PROGRAM SET'UP'ACCESS;   INCLUDE UPCOM;
        INT E,ON,OFF,K, GARB, ERMSNO,TEMP,USRNO,USR; CHR ERCODE; OCTFL UW(0:1,1);

         ST S,N,ST1; PTR TPTR,TPTR2, POINT;

         ENTRY EST'UP'ACC(UPTYPE,WHOSE,E,S,N,ON,OFF,K) UCF(63);

*                         READ ACCESS IT RETURNS USR
         FR'UPACD IF UPTYPE#'UP';
        LOCK'UP'W();
        UPSRCH(E,S:POINT,USRNO// VALUE UNLOCK'UP'W() & FR'UPENF);
        TPTR←POINT;
        FINDN(TPTR,N:TPTR,ST1// VALUE UNLOCK'UP'W() & FR'UPINF: GARB);
*                     ST1 WILL CONTAIN STRING DESCRIPTOR FOR VALUE IF FOUND
         CKAC (PROC'OWNER,USRNO// VALUE UNLOCK'UP'W() & FR'UPACD);
*                     MAKE BETTER ACCESS CHECK LATER
         IF OFF>=0 DO;
            TPTR.UPAC←TPTR.UPAC V' ON;
            TEMP←TPTR.UPAC;
            TPTR.UPAC←(TPTR.UPAC E' OFF) A' TEMP;
        ELSE DO;
            TPTR2←CALNEWPT(TPTR);
            BCOPY (TPTR,TPTR2,(POINT+POINT.ENTLLEN-TPTR2));
*                            ITEM TO BE DELETED
             POINT.ENTLLEN←POINT.ENTLLEN-(TPTR2-TPTR);
        ENDIF;
        UNLOCK'UP'W();
        RETURN;
        END;

        PROGRAM CREATE'UP'ENTRY;   INCLUDE SIBDECS ,  UPCOM;

         ST S, ST1,V(1);
        INT E,K,USRNO,USR,ELEN,MIBAD, TEMP,
         P, GROUP, ACCOUNT, UPPLEN←2048,FILEEND;
        INTARY FN[LUFN],FLN[LUFN];
        PTR POINT;

         LN UNDK1,UNDK2;

         INT ERMSNO; CHR ERCODE;
*      E IS USER NUMBER IF ANY
*      S IS NAME
*      K IS KEY
*      P=0 SAYS USER
*      P=1 SAYS ENTRY
*      THIS ROUTINE CREATES A UP ENTRY
*      IF 'USER' OBTAIN MIB (THIS IS A PRIVILEGED TRANSACTION)
*      IF 'ENTRY' THAN AN ENTRY IS CREATE AND THE PREEXISTING DKA
*      IS USED
         OCTFL DAD (1), WD0(0);*DISK ADDRESS
        ENTRY ECR'UP'ENTRY (UPTYPE,WHOSE,E,S,P,K) UCF(65);
*READ ACCESS
*CHECK FOR SPECIAL PRIVILEGES
         FR'UPACD IF UPTYPE#'UP';
        FR'UPEST IF EMPTY(S);
        LOCK'UP'W();
        FILEEND ← FWA.UPLLEN+FWA;
        IF P=1 DO;
            GOTO INVAL IF E <= 0;
            UPSRCH(E,S:POINT,USRNO//UP'CR);
INVAL:      UNLOCK'UP'W() & FR'UPEST;*ENTRY ALREADY EXISTS
        ENDIF;
        UPSRCH (0,S:POINT,USRNO//UP'CR);
        GOTO INVAL;
UP'CR:  ELEN ← 3 +((LNGDES(S$RP,S$WP)+5)/3);
*       D =    A         B                 C
*
*       A IS LENGTH OF 1ST WORD AND USER NUMBER AND MIB
*       B IS LENGTH OF NAME STRING
*       C IS DESCRIPTION WORD FOR NAME STRING
*       D IS LENGTH OF NEW ENTRY (MINIMUM)
*CHECK TO SEE IF NO CONFLICTS IN USER NUMBER
*      CALL ROUTINE TO CHECK USER NUMBER
*      FILE 'UNMIBDKA' MUST BE OPENED AND READ
*      IF USER NUMBER IF THERE IT WILL RETURN

*      P = 0 CREATE MIB
*      P = 1 GET DKA
         FOR POINT ← FWA, POINT+POINT.ENTPLEN WHILE POINT < FILEEND DO;
            GOTO FILL IF POINT.FREEBIT = 1 AND ELEN <= POINT.ENTPLEN;
        ENDFOR;
        PACKUP () IF (UPPLEN-FWA.UPLLEN) < ELEN+8;
        UNLOCK'UP'W() & FR'UPEOF IF (UPPLEN-FWA.UPLLEN)<ELEN+8;
        POINT ← FILEEND ← FWA.UPLLEN + FWA; POINT.FREEBIT ← 0;

FILL:    IF P= 0 DO;
            E←FIND'USRNO()+1;
            FN[0]←E;
            FN[1] ← FWA.UPAONO;
            FN[2] ← FWA.UPGONO;
            FN[3] ← FWA.UPSONO;
            MARK'UCALL();

             CREATE'MIB(FN//SF'PUNT);

             FN[0]← E; FN[3] ← 6'OWNE';
            FN[4] ← 6'R   '; FN[7] ← 6'KEY ';
            FN[2] ← FN[5] ← FN[6] ← FN[1] ← 0;

             CREATE'MIBOB(FN,23B,UTS'KEY//SF'PUNT);
            SET'MIBOB'ACCESS(FN,217B,UTS'KEY//SF'PUNT);

             FN[7] ← 6'SPCL'; FN[2] ← 0;

             CREATE'MIBOB(FN,5,UTS'KEY//SF'PUNT);
            SET'MIBOB'ACCESS(FN,217B,UTS'KEY//SF'PUNT);

             FN[3] ← 6'FRIE'; FN[4] ← 6'ND  ';
            FN[2] ← 0;

             CREATE'MIBOB(FN,6,UTS'KEY//SF'PUNT);
            SET'MIBOB'ACCESS(FN,217B,UTS'KEY//SF'PUNT);
            UNDK1$WD0 ← FWA.UPSONO;
            UNDK2$WD0 ← E;
            MOVE'DISK'RES(UNDK1,UNDK2,1000,UTS'KEY//SF'PUNT);

             FLN[0]←FWA.UPSONO;
            FN[3]←FLN[3]←6'GROU';
            FN[4]←FLN[4]←6'P.FR';
            FN[5]←FLN[5]←6'IEND';
            FN[7]←FLN[7]←6'KEY ';
            FLN[1]←FLN[2]←FLN[6]←0;
            COPY'MIBOB(FLN,FN,0,UTS'KEY,UTS'KEY//ON:ERCODE,ERMSNO);
            FN[3]←FLN[3]←6'ACCO';
            FN[4]←FLN[4]←6'UNT-';
            FN[6]←FLN[5]←6'FRIE';
            FN[6]←FLN[6]←6'ND  ';
            COPY'MIBOB(FLN,FN,0,UTS'KEY,UTS'KEY//ON:ERCODE,ERMSNO);
ON:         UNMARK'UCALL();
        ENDIF;

         IF POINT.FREEBIT = 0 DO;
            POINT.ENTPLEN ← ELEN + 8;
            FWA.UPLLEN ← FWA.UPLLEN + ELEN + 8;
        ENDIF;

         POINT.ENTLLEN ← ELEN; POINT.FREEBIT ← 0;
        POINT ← POINT + 1;
        POINT.CPAC ← POINT.ARAC ← POINT.NMLEN ← 1;
        POINT.UWAC ← 0;
        POINT.NAMFLD ← '#'; POINT.VLEN ← 2;
        POINT.UNO ← E;
        POINT ← POINT + 2;
*
*      STORE NAME STRING
         POINT.ARAC ← POINT.CPAC ← POINT.NMLEN ← 1;
        POINT.UWAC ← 0;
        POINT.NAMFLD ← 'N';
        TEMP ← POINT.VLEN ← LNGDES(S$RP,S$WP);
        ST1 ← ST'DESC(TEMP,POINT + 1,8,0);
        APPEND (ST1,S//LF'PUNT);
*ENTRY CREATED (SEE ABT SD FILED LATER);
         UNLOCK'UP'W();
        RETURN E;
        END;

        PROGRAM DL'UP'ENTR;   INCLUDE SIBDECS ,UPCOM;
        ST S,ST1;
        INT E,K,USRNO;
        PTR POINT;

         ENTRY EDL'UP'ENTR(UPTYPE,WHOSE,E,S,K) UCF(66);
*READ ACCESS AND CHECK

         FR'UPACD IF UPTYPE#'UP';
        LOCK'UP'W();
        UPSRCH(E,S: POINT, USRNO// VALUE UNLOCK'UP'W() & FR'UPENF);
        POINT.FREEBIT ← 1;
*MUST RETURN RESOURCES AND DELETE FILES AND PROCESSES STILL
*REMAINING.  SEE RAINER ABOUT THIS AT A LATER DATE
         UNLOCK'UP'W();
        RETURN;
        END;

        PROGRAM MISSUBS;   INCLUDE UPCOM;
        PTR POINT, SPOINT;
        ST JST1,JST2,S,ST1;
        INT USR,USRNO,MB;
        INT UPLEN, PAR1,  ENTEND, TUSER, FLAG,E,ERMSNO, TEMP,FILEEND;
        CHR ERCODE,CH;


         INTENT COMPARE(JST1,JST2);




         FOR TEMP←GCI(JST1//ENDST1) WHILE 1 DO;
            GOTO NOGD IF TEMP#GCI(JST2//NOGD);
        ENDFOR;
*                         ERROR IF LOOP COMPLETES
         NC'PUNT;
ENDST1: GCI(JST2//GOOD);
NOGD:   RETURN 0;
GOOD:   RETURN 1;

         ENTRY PACKUP();
        FILEEND ← FWA + FWA.UPLLEN;
        FOR POINT ← FWA, POINT+POINT.ENTPLEN WHILE POINT < FILEEND DO;
            IF POINT.FREEBIT = 1 DO;
                FWA.UPLLEN ← FWA.UPLLEN-POINT.ENTPLEN;
                BCOPY (POINT,POINT+POINT.ENTPLEN,FILEEND-(POINT+
                 POINT.ENTPLEN));
                FILEEND ← FWA + FWA.UPLLEN;
            ENDIF;
        ENDFOR;
        RETURN;


         ENTRY CKAC (USR,USRNO), FRETURN;

         FRETURN IF USR # USRNO AND
         USR # FWA.UPSONO AND
         USR # FWA.UPGONO AND
         USR # FWA.UPAONO
         ELSE RETURN;
        END;

        PROGRAM UPSEARCH; INCLUDE UPCOM;
        INT E,TUSER,FLAG,ENTEND,TEMP,ERMSNO,FILEEND;
        ST S,ST1;
        CHR ERCODE,CH;
        PTR POINT,SPOINT;

*                         FRETURN IF NAME OR NUMBER IS NOT FOUND
*                       
         ENTRY UPSRCH(E,S), FRETURN;
*                         E IS USR#IF ANY
*                         S IS THE NAME
         CH←('N' IF E=0 ELSE '#');
        FILEEND ← FWA + FWA.UPLLEN;
        FOR POINT ← FWA,POINT+POINT.ENTPLEN WHILE POINT<FILEEND DO;
            IF POINT.FREEBIT=0 DO;
                ENTEND←POINT.ENTLLEN+POINT;
                TUSER←0;
                FLAG←0;
                FOR SPOINT←POINT+1,CALNEWPT(SPOINT) WHILE SPOINT<ENTEND DO;
                    IF SPOINT.NMLEN=1 DO;
                        IF SPOINT.NAMFLD='#' DO;
                            TUSER←SPOINT.UNO;
                            GOTO NEW'ENT IF CH = '#' AND E # TUSER;
                            RETURN (POINT,TUSER) IF E= TUSER OR FLAG=1;
                        ELSEIF (SPOINT.NAMFLD = CH) DO;
                            ST1←ST'DESC(SPOINT.VLEN,SPOINT+1,8,0);
                            ST1$WP ← ST1$EP;
                            RETURN (POINT,TUSER) IF (FLAG←COMPARE(S,ST1) = 1)
                             AND TUSER # 0;
                            GOTO NEW'ENT IF FLAG=0;
                        ENDIF;
                    ENDIF;
                ENDFOR;
                NC'PUNT;
            ENDIF;
NEW'ENT:
        ENDFOR;
        FRETURN;




         ENTRY FINDN(SPOINT,S), FRETURN;
        ENTEND←SPOINT.ENTLLEN+SPOINT;
        FOR SPOINT←SPOINT+1,CALNEWPT(SPOINT) WHILE SPOINT<ENTEND DO;
            ST1←ST'DESC(SPOINT.NMLEN,SPOINT,8,2);
            ST1$WP ← ST1$EP;
            IF COMPARE(ST1,S) DO;
                TEMP←S$BP←S$RP←ST1$EP;
                S$WP←S$EP←INCDES(TEMP,SPOINT.VLEN);
                RETURN (SPOINT,S);
            ENDIF;
        ENDFOR; FRETURN SPOINT;
        END;

        PROGRAM FIND'USR'NO; INCLUDE UPCOM;
        INT USRNO,ENTEND,FILEEND;
        PTR POINT,SPOINT;

         ENTRY FIND'USRNO();
        USRNO←0;
        FILEEND←FWA.UPLLEN+FWA;
        FOR POINT←FWA,POINT+POINT.ENTPLEN WHILE POINT<FILEEND DO;
            IF POINT.FREEBIT=0 DO;
                ENTEND←POINT.ENTLLEN+POINT;
                FOR SPOINT←POINT+1, CALNEWPT(SPOINT)
                 WHILE SPOINT<ENTEND DO;
                    IF SPOINT.NAMFLD='#' DO;
                        USRNO←SPOINT.UNO IF SPOINT.UNO>USRNO;
                        GOTO NEXT;
                    ENDIF;
                ENDFOR;
            ENDIF;
NEXT:   ENDFOR;
        RETURN USRNO;
        END;

        PROGRAM PRO'INIT; INCLUDE UPCOM;
        INT USRNO,PO,UP'PMT,ERMSNO,OFT,PAGENO,USNO;
        INTARY FN[LUFN];
        CHR ERCODE; ST S;
        PTR POINT;
        ENTRY PRO'INIT();
        IF PO←READ'PROC'PARAM('ANO'//SF'PUNT)=0 DO;
            PO←READ'PROC'PARAM('GNO'//SF'PUNT);
            PO←1 IF PO=0;
        ENDIF;
        FN[0]←PO;
        FN[1]←0;
        FN[2]←0;
        FN[3]←6'X631';
        FN[4]←6'-USE';
        FN[5]←6'RP  ';
        FN[6]←0;
        FN[7]←6'BIN ';
        OFT←MOPEN'FILE(-1,FN,0,UTS'KEY//NAMER:ERCODE,ERMSNO);
        UP'PMT←ACQUIRE'PMT(-1//SF'PUNT);
        SET'MAP'BYTE(USP,UP'PAGE,UP'PMT//SF'PUNT);
        FOR PAGENO←0 TO 1 DO;
            MOVE'PAGE'PMT(OFT,PAGENO,UP'PMT//SF'PUNT);
            LOCK'UP'R();
* FILE HAS READ THING SET
* NOW FIND USER NUMBER
             UPSRCH(READ'PROC'PARAM('UNO'//SF'PUNT),S:POINT,USNO//NOT'THERE);
            SET'PP(POINT);
            UNLOCK'UP'R(); MSET'OFT'CL(OFT,0//SF'PUNT);
            PROFILE'TYPE←'UP'; PROFILE'OWNER←PO;
            RETURN;
NOT'THERE:  UNLOCK'UP'R();
            CLEAR'PMT(UP'PMT//SF'PUNT);
        ENDFOR;
NAMER:  NC'PUNT;
NOT'FND:UNLOCK'UP'R();
        NC'PUNT;
        END;

        PROGRAM SET'PP; INCLUDE UPCOM;
        INT TEMP,ENTEND,ERMSNO;
        CHR ERCODE;
        PTR POINT;
        ST NAME,SVALUE;
        ENTRY SET'PP(POINT);
        ENTEND←POINT.ENTLLEN+POINT;
        FOR POINT←POINT+1, CALNEWPT(POINT) WHILE POINT<ENTEND DO;
            IF POINT.CPAC#0 DO;
                NAME←ST'DESC(POINT.NMLEN,POINT,8,2);
                NAME$WP←NAME$EP;
                TEMP←SVALUE$BP←SVALUE$RP←NAME$EP;
                SVALUE$WP←SVALUE$EP←INCDES(TEMP,POINT.VLEN);
                SET'PP'ITEM(NAME,SVALUE//LOOP:ERCODE,ERMSNO);
            ENDIF;
LOOP:   ENDFOR;
        RETURN;
        END;

        PROGRAM LOCK'UP'; INCLUDE UPCOM;
        LN LONTIM;
        INT TIME,I;
        OCTFL WD0(0);


         ENTRY LOCK'UP'R();


HERE:    LONTIM←READ'CLOCK('RTC');
        TIME←LONTIM$WD0;
        FOR I←0 BY 1 TO 10000 DO;
            GOTO OUT IF (FWA.UPLOCK>-1) OR (FWA.UPTIMER<=TIME);
        ENDFOR; GOTO HERE;
OUT:    FWA.UPLOCK←FWA.UPLOCK+1 IF FWA.UPLOCK > -1
        ELSE FWA.UPLOCK ← 1;
        FWA.UPTIMER←TIME+2;
        RETURN;


         ENTRY UNLOCK'UP'R();


         FWA.UPLOCK←FWA.UPLOCK-1 IF FWA.UPLOCK>0;
        RETURN;


         ENTRY LOCK'UP'W();


LOOP:    LONTIM←READ'CLOCK('RTC');
        TIME←LONTIM$WD0;
        FOR I←0 BY 1 TO 10000 DO;
            GOTO ENDLP IF FWA.UPLOCK # 0 AND FWA.UPTIMER>TIME;
            FWA.UPLOCK←-1 IF FWA.UPLOCK=0 OR TIME>=FWA.UPTIMER;
            FWA.UPTIMER←TIME+2 & RETURN IF FWA.UPLOCK=-1;
ENDLP:  ENDFOR;
        GOTO LOOP;


         ENTRY UNLOCK'UP'W();
        IF FWA.UPLOCK = -1 DO;


             FWA.UPLOCK←FWA.UPTIMER←0;
        ENDIF;
        RETURN;
        END;

        PROGRAM CREATE'PROCESS;   INCLUDE UPCOM,ATTACHDECS;

         INT UNDKA;
        ST UNM ← 6"UTILITY         ",USEUTS(16:6);

         INTARY UFN[LUFN];
        INTARY PN,PG;
        INTARY MESAGE[30],MES;

         INT POFT,ERMSNO,I,RING←1,SB,UOFT,PMT',FB;
        INT UN,DK,CD,N;

         CHR ERCODE;


         ST FMS(32: 12),SMS(32: 12),WS,MESSTR;

         INT UEP←403012B,UG←403000B;

         ENTRY ECR'PROC(PN,MESSTR,K) UCF(70);

*PN    =PROCESS NAME IN FILE NAME ARRAY FORMAT

*UFN   =UTILITY FILE NAME
*PNSTR =PROCESS NAME STRING
*MESSTR=MESSAGE STRING

*WORRY ABOUT CONVERTING KEY
*FILE MUST ALREADY BE CREATED

         I←0; ERCODE←'NUT'; ERMSNO←32;
        MOPEN'FILE(-1,PN,1,K:POFT//TFR);
        N←FWA.UPSONO;
        SETS(USEUTS,0,0);
        READ'UP'ITEM('UP',-1,PN[0],"","UTILITY-NAME",USEUTS,
         UTS'KEY:USEUTS//NONE:ERCODE,ERMSNO);
        GOTO OPEN;
NONE:   SCOPY(USEUTS,UNM//ER1);
OPEN:   CONV'FNAME(N,UNDKA,USEUTS,6'PIF ',UFN);
        MARK'UCALL();
        MOPEN'FILE(-1,UFN,1,UTS'KEY:UOFT//ER1:ERCODE,ERMSNO);

         MOVE'PAGE'PMT(UOFT,0,ATF'PMT//ER2:ERCODE,ERMSNO);


         NAMSET(WS,32,@(ATF'PTR.ATMAP),12);
        SCOPY(FMS,WS//LF'PUNT);
        CLEAR'PMT(ATF'PMT//SF'PUNT);
        INIT'SPT(POFT,RING,K//SF'PUNT);

         ACQUIRE'PMT(-1:SB//ER2:ERCODE,ERMSNO);
        SET'MAP'BYTE(-1,ATP'PAGE,SB//ER3:ERCODE,ERMSNO);

         FB←GCI(FMS//ER3);
        FB←FB$BYTEP;

         MOVE'PAGE'PMT(UOFT,FB,SB//ER3:ERCODE,ERMSNO);
        PG ← AR'DESC (1000B,ATP'PTR+3000B);

         INIT'PROC'PAGE(POFT,PMT'←CB'PMT,3000B,1000B,PG//ER3:
         ERCODE,ERMSNO);
        WS←ST'DESC(90,@MESAGE[0],8,0);
        WCI(LENGTH(MESSTR),WS//LF'PUNT);
        APPEND(WS,MESSTR//LF'PUNT);
        INIT'PROC'PAGE(POFT,PMT'←CB'PMT,2018,30,MESAGE//ER3:
         ERCODE,ERMSNO);
        WCI(PMT',SMS//LF'PUNT);
        CLEAR'PMT(SB//SF'PUNT);

         FOR FB←GCI(FMS//DONE) REPEAT;
            CD←FB$BYTEC; FB←FB$BYTEP;
            IF CD=0 DO;
                PMT'←0;
            ELSE DO;
                IF CD= 1 DO;
                    MOVE'PAGE'PMT(UOFT,FB,SB//ER3:ERCODE,ERMSNO);

                     COPY'PMT'PROC(POFT,SB:PMT'//ER3:ERCODE,ERMSNO);
                ELSE DO;
                    CR'FILE'PAGE(POFT,SB:PMT'//ER3:ERCODE,ERMSNO);
                    IF CD = 3 DO;
                        MOVE'PAGE'PMT(UOFT,FB,ATF'PMT//ER3:ERCODE, ERMSNO);
                        BCOPY(ATP'PTR,ATF'PTR,4000B);
                        CLEAR'PMT(ATF'PMT//SF'PUNT);
                    ENDIF;
                ENDIF;
            ENDIF;
            WCI(PMT',SMS//LF'PUNT);
            CLEAR'PMT(SB//SF'PUNT) IF PMT'#0;
        ENDRPT;
DONE:   DELETE'PMT(SB//SF'PUNT);
        INIT'PROC'MAP(POFT,SMS//ER5:ERCODE,ERMSNO);
        MSET'OFT'CL(POFT,0//SF'PUNT);
        MSET'OFT'CL(UOFT,0//SF'PUNT);
        UNMARK'UCALL();
        RETURN;*CALLING PROCESS MUST ACTIVATE NEW PROCESS

ERROR2:  CLEAR'PMT(ATF'PMT//SF'PUNT);

ER5:     DELETE'PMT(SB//SF'PUNT);
        GOTO ER2;
ER3:    CLEAR'PMT(ATF'PMT//SF'PUNT);

ER2:     MSET'OFT'CL(UOFT,0//SF'PUNT);
ER1:    MSET'OFT'CL(POFT,0//SF'PUNT);
        UNMARK'UCALL();
ER0:    FRETURN (ERCODE,ERMSNO);
        END;

        PROGRAM DECT'PROC; INCLUDE COMDECS, SIBDECS, PMTDECS;
        INCLUDE UCALLDECS;

         INT I,ERMSNO,PROCTP;
        INTARY FN[LUFN],FLN[LUFN],PMTE[LPMT];
        LN UNDK← (-1,0);
        OCTFL WD0(0);
        CHR ERCODE;
        ST OL(72);

         ENTRY DEST'THIS'PROC() UC(74);
        READ'PMT(1,PMTE//CANT:ERCODE,ERMSNO);
        FOR I←0, I+1 REPEAT;
            READ'MIBOB'INDEX(UNDK,6,FN,I,UTS'KEY//
             VALUE (GOTO CANT IF ERCODE='MOB' ELSE
             GOTO NXENT):ERCODE,ERMSNO);
            PROCTP←FN[6];
            IF FN[0]$SIBNOT=SIBPRCD DO;
                BCOPY (@FLN[3],@FN[2],5);
                FLN[2] ← FN[1];
                FLN[0] ← UNDK$WD0;
                READ'MIBOB'NAME(FLN,3,FN,6
                 +@FN[0].SIBNLL,UTS'KEY//CANT:ERCODE,ERMSNO);
                GOTO GET'OUT IF PMTE[0] = FN[2] AND PMTE[1] = FN[3]
                 AND @PMTE[0].PMTDKA = @FN[2].PMTDKA;
            ENDIF;
NXENT:  ENDFOR;
        GOTO CANT;
GET'OUT:FLN[7]←6'DEST';
        BCOPY(@FN[0],@FLN[0],7);
        FN[7]←PROCTP;
        I←0;
RENAME: SET'MIBOB'NAME(FN,FLN,UTS'KEY//FIX'NAME:ERCODE,ERMSNO);
CANT:   FLN[2]←0;
        MAKE'DORMANT(FLN,-1//MALFUNCTION:ERCODE,ERMSNO);
MALFUNCTION:OL ← ERRORMSG(ERMSNO,OL//CANT:ERCODE,ERMSNO);
        PRINT'STRING(-1,OL,0//QUIT'PUNTX(CANT,OL));
        START'OUTPUT(-1,0//CANT:ERCODE,ERMSNO);
        QUIT'BLOCK(4B7 RSH GET'INT'NO('CHI'//CANT:ERCODE,ERMSNO),
         QUIT'FLAG//CANT:ERCODE,ERMSNO);
        GOTO CANT;
        RETURN;
FIX'NAME:IF I = 0 DO;
            FLN[4] ← FLN[4]+40B;
        ELSE DO;
            FLN[4] ← FLN[4] + 1;
        ENDIF;
        I ← I+1;
        GOTO RENAME;
        END;

        PROGRAM CV'FNAME; INCLUDE COMDECS;

         INT TP,STRT←0;
        INTARY PN;

         ST NAME'ST,WS;

         INT UN,DK;

         ENTRY CONV'FNAME(UN,DK,NAME'ST,TP,PN);
        BSET(@PN[0],0,LUFN);
        WS←ST'DESC(16,@PN[3],6,0);
        SCOPY(WS,NAME'ST//LF'PUNT);
        PN[STRT]←UN;
        PN[STRT+1]←DK;
        PN[STRT+7]←TP;
        RETURN;
        END;

        PROGRAM SET'PP'ITEM; INCLUDE PPCOM;
*
* SET PROCESS PROFILE ITEM
*
         ST N, V; INT I, ERMSNO; CHR ERCODE;

         ARBENT ESET'PP'ITM(N, V) UCF(73);

         I ← PP'SEARCH(N// GEN);
        (PPSET[I])(V// TFR); RETURN;

*?*       DO FINDN ON GENERAL AREA HERE OR CREATE ENTRY, ETC
GEN:     FR'PPINF;

        END;

        PROGRAM UTS'ENTRIES; INCLUDE UCALLDECS, TRAP'DECS;
*
* UTS INITIALIZATION
*
         FIXED;

         CHR ERCODE; INT ERMSNO;
        INTARY FNC[LUFN]←(0,0,0);
        OCTFL W0(0);***** KLUDGE USED FOR EAX $STATE
        MACRO SAVE'STATE ← .STX GSX, BSX SAVES;

SAVES:   .STX GSAVER, LDX 0, EAX $(GSTATE$W0), STORS;
        TRAP'PUNT() IF TRAP'FLAG; TRAP'FLAG ← 1;
        GSTATE[XSTLOC] ← GSX; .BRU $GSAVER;

         ARBENT XXXXXX(), SP'ENTRY ← 2;

         .LDA INITIAL'FS, XLA; TRAP'FLAG ← 0;
        STACK'PTR ← INITIAL'FS; STACK'LIM ← INIT'MSG-1;
        STACK'INIT(// ABORT);

         UCALL'SP ← STACK'PTR ← INITIAL'SP; STACK'LIM ← NORMAL'SL;

         UTS'INIT();
        INIT'CP();
ABORT:  MAKE'DORMANT(FNC,-1//ABORT:ERCODE,ERMSNO);
ABORT1: GOTO ABORT1;

* SP'TRAPS COME HERE
         ARBENT XXXSPT(), SP'ENTRY ← 0; SAVE'STATE; STRAP();

* USER/UTILITY CAUSED RING TRAPS
         ARBENT XXXABE(), TRAP'ENTRY ← 1; SAVE'STATE; RTRAP1(1);
        ARBENT XXXRO(),   TRAP'ENTRY ← 4; SAVE'STATE; RTRAP1(4);
        ARBENT XXXIAT(), TRAP'ENTRY ← 5; SAVE'STATE; RTRAP1(5);
        ARBENT XXXBLL(), TRAP'ENTRY ← 10; SAVE'STATE; RTRAP'BLL(10);

* MACHINE ERRORS
         ARBENT XXXFLO(), TRAP'ENTRY ← 2; SAVE'STATE; RTRAP2(2);
        ARBENT XXXFLU(), TRAP'ENTRY ← 3; SAVE'STATE; RTRAP2(3);
        ARBENT XXXUFN(), TRAP'ENTRY ← 6; SAVE'STATE; RTRAP2(6);
        ARBENT XXXFXO(), TRAP'ENTRY ← 7; SAVE'STATE; RTRAP2(7);
        ARBENT XXXDIZ(), TRAP'ENTRY ← 8; SAVE'STATE; RTRAP2(8);

* STACK OVERFLOW - WATCH OUT
         ARBENT XXXSOV(), TRAP'ENTRY ← 9; STKTRAP();
        END;

        PROGRAM PUNT; INCLUDE UCALLDECS, TRAP'DECS, SPTDECS;
*
* MAIN TRAP/PUNT PROCESSING ROUTINE
*
         OCTFL W0(0);****** KLUDGE USED FOR EAX $STATE
        DECLARE LABEL FIELD L0(0);
        INT I, N, L, LNO, P, Q, SPCO, SX, SL, EAC'IR, SR, ERMSNO;
        CHR ERCODE; LB R = L' [0];
        INTARY SPCA[LSPCS], STATE[LSTATE];
        INT BLL'OP ← 57B, BLLN'OP ← 60B;
        OCTFL UTNO(0: 0,5), POP'BIT(0: 9,9), OP'CODE(0: 3,8);
        LBARY LTRAP[24] ← (MACC, TEST, TEST, SPTPUNT, SPTPUNT,
         SPTPUNT, BLLE, TEST, SPTPUNT, SPTPUNT,
         SPTPUNT, SPTPUNT, SPTPUNT, SPTPUNT, SPTPUNT,
         SPTPUNT, SPTPUNT, SPTPUNT, SPTPUNT, SPTPUNT,
         SPTPUNT, SPTPUNT, UTSE, QUIT);

         MACRO SAVE'STATE ← .BSX SAVES;
        MACRO SPT'PUNT ← SPTPUNT: ERCODE, ERMSNO;

* SAVE STATE
SAVES:   .STX SR; BCOPY(@STATE[0], @GSTATE[0], LSTATE);
        SPCO ← @SPCA[0]; SL ← STATE[LSTLOC]; STATE[LSTLOC] ← @R;
        TRAP'FLAG ← 0; ALLOW'INTS(); .BRU $SR;

*
* ENTRY FOR 'SOFT' RTRAPS
*
         ARBENT RTRAP1(N);* MAY BE USER CAUSED TRAP
        SAVE'STATE;
        IF (Q ← P ← RTRAP'PARAM$ADDR) >= UTS'RING DO;
            P ← P +1 IF N = 1;* ABE
            GOTO RTPUNT IF P.ADDR >= UTS'RING;
        ENDIF;
* USER DID CAUSE TRAP.  CONVERT TO SP TRAP AND REFLECT
         MARK'CALL(UTS'RING, STATE[LSTLOC], UTS'G// SPT'PUNT);
        Q$UTNO ← N; N ← 22; GOTO REFLECT;

         ARBENT RTRAP'BLL(N);
        SAVE'STATE;
        Q ← RTRAP'PARAM;
        P ← RTRAP'LOC;
        MARK'CALL(UTS'RING, STATE[LSTLOC], UTS'G// SF'PUNT);
        N ← -(N+1) & GOTO BLLE IF P >= UTS'RING;
        Q$UTNO ← N;     N ← 22;     GOTO REFLECT;

*
* ENTRY FOR 'HARD' RTRAPS
*
         ARBENT RTRAP2(N);*** UTILITY INVOKED ERROR
        SAVE'STATE;
RTPUNT: RPUNTMSG(N, RTRAP'LOC); GOTO PUNTCOM;

*
* ENTRY FOR SP TRAPS
*
         ARBENT STRAP();
        SAVE'STATE; N ← @R.SP'TNO; Q ← @R.SP'TPAR;
        READ'SPCS(0, SPCA// SPT'PUNT); SL ← R$BRDLR ← SPCO.SPCSLR;
        GOTO LTRAP[N] IF P ← SPCO.SPCSPR >= UTS'RING;

* UNARMED TRAP IN USER PROGRAM
UNWIND:  SPTRPMSG(N,P,Q);
        FOR L ← 0, L+1 REPEAT;
            READ'SPCS(L, SPCA//SPT'PUNT);
            IF SPCO.SPCSLR = CP'SP DO;
                ERROR'FLAG ← 1; STACK'PTR ← UCALL'SP;
                JUMP'RETURN(L// SPT'PUNT);
            ENDIF;
        ENDFOR;

* PRO, PNIM, ILIM
TEST:    GOTO SPTPUNT IF Q$ADDR >= UTS'RING;
* MACC
MACC:    Q$UTNO ← 40B V' N; N ← 22; GOTO REFLECT;

* BLL - TEST FOR TRAP/PUNT
BLLE:    GOTO SPTPUNT IF Q$BLL'CLASS = 7;
* FIND THE DESCRIPTOR
         IF P.POP'BIT DO;
            BLL'WORD ← 1B7;* HLT $G'[0]
            EAC'IR ← P.OP'CODE;
        ELSEIF P.OP'CODE = BLL'OP OR P.OP'CODE = BLLN'OP DO;
            BLL'WORD ← P; EAC'IR ← STATE[XSTLOC];
        ELSE DO;* SYSTEM CALL
        GOTO SPTPUNT;
        ENDIF;
        .LDA SL, LDX EAC'IR, XLA, STA BLL'SAVEL;
        .EAC $BLL'WORD, LDA BLL'SAVEL, XLA, STX SX;
* SX POINTS TO THE BLL (RETURN) DESCRIPTOR
         GOTO SPTPUNT IF SX.BRDPC >= UTS'RING;
        N ← 22; Q$UTNO ← 20B V' Q$BLL'CLASS;

* REFLECT TRAP TO USER AS 'UTSE' TRAP
REFLECT: READ'SPCS(1, SPCA// SPT'PUNT);

         IF SPCO.SPCSPR >= UTS'RING AND SPCO.SPCSLR # CP'SP DO;
* TRAP OCCURRED DURING MARKED UCALL
* STRIP STACK BACK TO UCALL FRAME
             DELETE'CALL(// SPT'PUNT); GOTO REFLECT;
        ENDIF;

* TRAP OCCCURRED DURING UNMARKED UCALL
* FIX UP TOP ENTRY ON SPCS
         MODIFY'CALL(0, UCALL'SP.BRDPC, UCALL'SP.BRDLR, USER'G,
         0// SPT'PUNT);
        STACK'PTR ← UCALL'SP; STATE[PSTLOC] ← @RET;
        .LDX 0, EAX $(STATE$W0), LOADS;
RET:    TRAP'RETURN(N, Q// SPT'PUNT);

* QUIT
QUIT:   QUIT'FLAG ← 1; REFUSE'INTS(2000,100//SPT'PUNT);
        SET'SPT'FIELD(-1,'TM',READ'SPT'FIELD(-1,'TM'//SF'PUNT) V' 1//SF'PUNT);
        STATE[PSTLOC] ← @QUITX;
        STACK'PTR ← @R-2;
        .LDX 0,EAX $(STATE$W0),LOADS;
QUITX:  SP'RETURN(// SPT'PUNT);

* FREE STORAGE OVERFLOW
         ARBENT OFLOTRAP(ERCODE, ERMSNO);
        R ← (R$BRDLR).L0; N ← 24; GOTO RTF;

* UNEXPECTED RUNTIME FAILURE
         ARBENT RUNTIME'FAILURE(); N ← 25;
RTF:    P ← R$BRDPC; Q ← 0; MARK'UCALL();

UTSE:
SPTPUNT:SPUNTMSG(N, P, Q);
PUNTCOM:
        UTS'REINIT();

* TRAP DURING STATE-SAVING
         ARBENT TRAP'PUNT();
        SPUNTMSG(26, R$BRDPC, 0); UTS'REINIT();

* FAILURE MAY BE DUE TO A NEW TERMINAL LINE.  TRY IT FIRST.
        ARBENT TRY'NEW'LINE(LNO);
        RETURN I IF (I←READ'PROC'PARAM('TNO'//SF'PUNT) RSH 1)#LNO;
        N←25 & GOTO RTF;

        END;

        PROGRAM STKOV'TRAP; INCLUDE UCALLDECS, TRAP'DECS, SPTDECS;
*
* STACK OVERFLOW TRAP PROCESSING
*
         FIXED;
        INTARY FNC[LUFN]←(0,0,0);
        INT T, ERMSNO; INTARY SPCA[LSPCS]; CHR ERCODE;
        LB NXT'KLUDGE ← NXT;

         ARBENT STKTRAP();
STKWAIT:UTS'REINIT();

* KLUDGE UTILITY RE-INITIALIZATION
         ARBENT UTS'REINIT();
RETRY:  T ← READ'SPS'PARAM('CSL'// ABORT: ERCODE, ERMSNO) - 1;
        READ'SPCS(T, SPCA// ABORT: ERCODE, ERMSNO);
        MODIFY'CALL(T, @NXT, @SPCA[0].SPCSLR, UTS'G, 0// ABORT:
         ERCODE, ERMSNO);
        JUMP'RETURN(T// ABORT: ERCODE, ERMSNO);
NXT:    STACK'LIM ← NORMAL'SL; STACK'PTR ← INITIAL'SP;
        TRAP'FLAG ← 0; REINIT'CP();
ABORT:  BLOCK(2B5//ABORT1:ERCODE,ERMSNO);
        GOTO RETRY;
ABORT1: MAKE'DORMANT(FNC,-1//ABORT:ERCODE,ERMSNO);
ABORT2: GOTO ABORT2;
        END;

        PROGRAM UTRAP'MSG; INCLUDE UCALLDECS, MACHINE'DECS;
*
* PRINT USER TRAP MESSAGE
*?*  THIS ROUTINE SHOULD FRETURN, RATHER THAN PUNTING (COULD CAUSE
*?*       PUNT LOOP AND STACK OVERFLOW)
*
         ST MSG(60), CM; INT N, P, Q, T, F, ERMSNO; CHR ERCODE;
        CHRARY RN[11] ← (6'RT0?', 6'ABE', 6'FLO', 6'FLU', 6'ROIA',
         6'IAT', 6'UFN', 6'FXO', 6'DIZ', 6'SOV', 6'BLL-');
        CHRARY SN[27] ← (6'MACC', 6'PRO', 6'PNIM', 6'PNIC', 6'PI',
         6'TI', 6'BLL', 6'ILIM', 6'PNOD', 6'DWSO', 6'CWSO',
         6'NEP', 6'DMRD', 6'NILE', 6'SPCO', 6'PMTO', 6'DKSE',
         6'?17?', 6'?18?', 6'?19?', 6'?20?', 6'?21?', 6'UTSE',
         6'QUIT', 6'FSOV', 6'PUNT', 6'TRAP');

         ARBENT RPUNTMSG(N, P); N ← -(N + 1);
        ARBENT SPUNTMSG(N, P, Q);

         PUNT'WCR(MSG); MSG$RP ← MSG$WP;
        APPEND(MSG, "UTILITY PUNT '"// LF'PUNT); F ← 0; GOTO COM;

         ARBENT SPTRPMSG(N, P, Q);

         SETS(MSG, 0,0); WCI(NLCH, MSG);
        APPEND(MSG, "USER TRAP '"// LF'PUNT); F ← 1;

COM:
        IF N = 22 DO;
            APPEND(MSG, "UTSE - "// LF'PUNT);
            N ← (Q$UTSE'SPTNO IF T ← Q$UTSE'CLASS > 1 ELSE
             6 IF T = 1 ELSE -(Q$UTSE'RTNO+1));
        ENDIF;

         IF N = 6 DO;
            PUNT'WWD(MSG, 6'BLL-'); WCI(Q$BLL'CLASS V' '0', MSG);
        ELSE DO;
            PUNT'WWD(MSG, SN[N] IF N >= 0 ELSE RN[-(N+1)]);
        ENDIF;
        IF N = -11 DO;
            WCI(Q$BLL'CLASS V' '0', MSG);
        ENDIF;
        APPEND(MSG, "' AT P: "// LF'PUNT);
        CNS(P, MSG, 4B7, 8// LF'PUNT); WCI('B', MSG);

         IF F DO;* NORMAL MESSAGE
        WCI(NLCH,MSG);
QT'P:       PRINT'STRING(-1, MSG, 0// QUIT'PUNTX(QT'P, MSG));
            RETURN;
        ELSE DO;* PUNT MESSAGE
        T ← READ'PROC'PARAM('TNO'// SF'PUNT) V' 1;
            CM ← MSG; MSG$WP ← MSG$RP;
            WCI(F + 40B, MSG) FOR F ← GCI(CM// XIT) WHILE 1;
XIT:        PUNT'WCR(MSG);
OUT:        WRITE'STRING(T, -1, MSG: MSG, F// FAIL:ERCODE,ERMSNO);
            GOTO OUT IF F ELSE RETURN;
FAIL:       RETURN IF ERCODE = 'LNO' OR ERCODE = 'LAC';
            RUNTIME'FAILURE();
        ENDIF;
        END;

        PROGRAM PUNT'WWD; INCLUDE COMDECS, CIOS'TAB;
*
* APPEND 4 CHARACTER NAME TO STRING
*
         PTR P; CHR M, C; ST S; STFL A(0); CHRFL CH60(0: 0,5);

         ARBENT PUNT'WWD(STRING @P, M); S ← P.A;

         (WCI(C, S) IF C # ' ') & M ← M LSH 6
         FOR C ← M$CH60 WHILE M # 6'    ';
        P.WP ← S$WP; RETURN;

         ARBENT PUNT'WCR(STRING @ P); S ← P.A;
        WCI(S1CH, S); WCI(200B V' '&M', S);
        WCI(S1CH, S); WCI(200B V' '&J', S);
        P.WP ← S$WP; RETURN;
        END;

        PROGRAM CP;
        INCLUDE UCALLDECS, MACHINE'DECS, SIBDECS, CP'COM'NAMES, CP'VERSION;
        INCLUDE UCALLD'KLUDGE,COMDECS, ICTDECS, OFTDECS;
*
* COMMAND PROCESSOR
*

         INT PS, TS, I, T, QF, ERCODE, ERMSNO;
        INTARY FA[LUFN], FB[LUFN], WA[LOFT];
        ST L(NCMCH), OL(NCMCH), N;*?* DYNAMICALLY ALLOCATE L ON STACK!
        LN NULL'UNDK ← (0,0);

         LBARY COM'LB[LCOMNM] ← (CON, SVC, REL, RES,HEL, FIN, QIT,QOT);

         ARBENT INIT'CP();
        UCALL'SP ← STACK'PTR; CP'SP ← INITIAL'SP; QF ← 0;
        SET'SPNAME(-1,"UTILITY:PIF"//SF'PUNT);
        IF LENGTH(SAVED'LINE) = 0 DO;
            SET'ICT(QT'ICT,ICTTRPCD,23,NULL'UNDK//SF'PUNT);
        ENDIF;

* COPY SAVED'LINE (ENTER MESSAGE) TO L AND PROCESS
         SCOPY(L,SAVED'LINE//LF'PUNT);
        FREE(SBASE(SAVED'LINE)) IF LENGTH(SAVED'LINE) # 0;
        SAVED'LINE ← "";
        PS←-1;
        GOTO COM'LKP;

* RE-INITIALIZATION ENTRY
         ARBENT REINIT'CP();
        UCALL'SP ← STACK'PTR; CP'SP ← INITIAL'SP; QF ← 0;
        SETS(L, 0,0); WCI(NLCH, L);
        APPEND(L, "PROCEED WITH CAUTION"// LF'PUNT); CP'PRT(L);

COM'IN:  PS ← -1;

* MAIN COMMAND LOOP
COM'LP:  SETS(L,0,0);
        EED'LINE(-1,OL,L,0,"@",QF:L//QT'CHECK:OL,L,I,ERCODE,ERMSNO);
COM'LKP:GOTO COM'LP IF EMPTY(L); GOTO QOT IF GC(L)='"';
        SCOPY(OL,L//LF'PUNT);    N ← GET'PARAM(L);

* LOOK UP NAME
         SPECIAL'SEARCH(N, FA, 'COM', -1// NAM'ER:
         ERCODE, ERMSNO); GOTO QT'XIT IF QF;

         CONV'NAME(FA, FB, -1: I, T, I// ERXIT: ERCODE, ERMSNO);
        IF T = SIBSCCD DO;

* PROCESS BUILT-IN COMMAND
             NAMSET(N, NMNCH, @(@FB[0].UFNMN), LNCH);
            FOR I ← 0 TO LCOMNM-1 DO;
                EQUAL(N, COM'NM[I]// NEXT);
                GOTO COM'LB[I];
NEXT:
            ENDFOR;
            SCOPY(L, "UNIMPLEMENTED BUILT-IN COMMAND"// LF'PUNT);
            GOTO ER'PRT;
        ENDIF;

         IF @FA[0].UFNTY # 6'TCMD' DO;
            DESTROY'SP(PS// SF'PUNT) IF PS > 0;
            PS ← -1;
        ENDIF;

* PREPARE TO EXECUTE
         CREATE'SSP(-1: TS// SF'PUNT);
*EM*      SET'SPT'FIELD(TS, 'EP', 40012B// SF'PUNT);
*EM*      SET'SPT'FIELD(TS, 'EG', 40000B// SF'PUNT);
         NAMSET(N, NMNCH, @(@FA[0].UFNMN), LNCH);
        SET'SPNAME(TS, N// SF'PUNT);
        ATTACH(TS, FA, -1// ERDEL: ERCODE, ERMSNO);

         SAVED'LINE ← ST'DESC(T, MAKE((T + 2)/ 3, 0), 8, 0)
         WHERE T ← LNGDES(L$RP, L$WP) + (NMNCH+1);
        READ'SPNAME(TS, SAVED'LINE: SAVED'LINE// ERXIT:
         ERCODE, ERMSNO);
        WCI(',', SAVED'LINE); APPEND(SAVED'LINE, L// LF'PUNT);
        SAVED'USER ← @FA[0].UFNUN$UNDKUN;

*   ALLOW COMMAND SUBPROCESS ACCESS TO USER KEY.
         MREAD'OFT(USER'KEY, WA//SF'PUNT);
        SET'OFT'AL(USER'KEY, 1 LSH TS V' WA$OFTAL//SF'PUNT);

         SET'SPT'FIELD(TS, 'UAK', USER'KEY// SF'PUNT);*?* TEMP
        GOTO QT'REL IF QF; SP'CALL(TS, 2// SF'PUNT);

         IF STACK'PTR # UCALL'SP DO;*?* CHECK POTENTIAL PROB WITH UTS
        SCOPY(L, "UTILITY ERROR - STACK POINTER IS "// LF'PUNT);
            CNS(STACK'PTR, L, 4B7, 8// LF'PUNT);
            APPEND(L, "B, NOT "// LF'PUNT);
            CNS(UCALL'SP, L, 4B7, 8// LF'PUNT);
            WCI('B', L); CP'PRT(L); STACK'PTR ← UCALL'SP;
        ENDIF;


         FREE(SBASE(SAVED'LINE), 0); SAVED'LINE ← "";
        DESTROY'SP(TS// SF'PUNT) IF
         @FA[0].UFNTY = 6'TCMD' ELSE PS ← TS;
        GOTO COM'LP;

NAM'ER:  L$RP ← N$RP; L$WP ← N$WP;
        APPEND(L, " IS UNRECOGNIZABLE"// LF'PUNT);
ER'PRT: WCI(NLCH, L);
        PRINT'STRING(-1, L, QF// QUIT'PUNTX(QT'PRT, L)); GOTO COM'LP;

QT'REL:  DESTROY'SP(TS// SF'PUNT); GOTO QT'XIT;
QT'RD:  PRINT'CHAR(-1, NLCH, 0// QUIT'PUNTX(QT'RD, I));
        GOTO QT'XIT;
QT'PRT: PRINT'STRING(-1, L, 0// QUIT'PUNTX(QT'PRT, L));
QT'XIT: QF ← 0; BLOCK'OB'EMPTY(-1, QF// QUIT'PUNT(QT'XIT));
        SET'CIOS'FIELD(-1, 'ICC', 0// SF'PUNT); GOTO COM'LP;
QT'CHECK:GOTO QT'RD IF ERCODE = 'QIT' ELSE RUNTIME'FAILURE();

ERDEL:   DESTROY'SP(TS// SF'PUNT);
ERXIT:  SETS(L, 0,0); ERRORMSG(ERMSNO, L: L// SF'PUNT);
        GOTO ER'PRT;


*
* BUILT-IN COMMANDS
*

* SAVE-CURRENT
SVC:
        IF PS >= 0 DO;
            SETS(L, 0,0); READ'SPNAME(PS, L: L// SF'PUNT);
            APPEND(L, " IS "// LF'PUNT); CNS(PS, L, 4B7, 10// LF'PUNT);
            PS ← -1;
        ELSE DO;
            SCOPY(L, "NO CURRENT COMMAND"// LF'PUNT);
        ENDIF;
        WCI(NLCH, L); PRINT'STRING(-1, L, QF// QUIT'PUNTX(QT'PRT, L));
        GOTO COM'LP;

* CONTINUE [SUB:PROC]
CON:     TS ← GETSPN(L, PS// QT'XIT);
        SAVED'LINE ← ST'DESC(T, MAKE(((T + 2)/ 3), 0), 8, 0)
         WHERE T ← LNGDES(L$RP, L$WP) + (NMNCH+1);
        NAMSET(N, NMNCH, @(@FA[0].UFNMN), LNCH);
        WCI(T, SAVED'LINE) WHILE T ← GCI(N// CON'NXT) # ' ';
CON'NXT:WCI(',', SAVED'LINE); APPEND(SAVED'LINE, L// LF'PUNT);
        SAVED'USER ← @FA[0].UFNUN$UNDKUN;
        SETS(L, 0,0); READ'SPNAME(TS, L: L// SF'PUNT); WCI(NLCH, L);
CON'QT: PRINT'STRING(-1, L, QF// QUIT'PUNTX(CON'QT, L));
        SP'CALL(TS, 3// SF'PUNT);
        FREE(SBASE(SAVED'LINE), 0); SAVED'LINE ← "";
        GOTO COM'LP;

* RELEASE [SUB:PROC]
REL:     TS ← GETSPN(L, PS// QT'XIT);
        SETS(L, 0,0); READ'SPNAME(TS, L: L// SF'PUNT); WCI(NLCH, L);
        DESTROY'SP(TS// ERXIT: ERCODE, ERMSNO); PS ← -1 IF PS = TS;
        PRINT'STRING(-1, L, QF// QUIT'PUNTX(QT'PRT, L)); GOTO COM'LP;

* RESET
RES:     SPRESET(RCLVL// SF'PUNT); GOTO COM'IN;

* FINISHED
FIN:     GOTO RCER IF RCLVL <= 1;
        SPRESET(RCLVL// SF'PUNT);
        SP'RETURN(// SF'PUNT);

RCER:    PRINT'STRING(-1, "ILLEGAL AT TOP-LEVEL"// SF'PUNT);
        PRINT'CHAR(-1, NLCH// SF'PUNT); GOTO COM'LP;

* QUIT
QIT:     GOTO RCER IF RCLVL <= 1;
        SPRESET(RCLVL// SF'PUNT);
*          PRINT'STRING(-1, "EXECUTION ABORTED -- MAY NOT BE ABLE TO CONTINUE"// SF'PUNT);
*          PRINT'CHAR(-1, NLCH// SF'PUNT);
*FOR I ← 0, I + 1 REPEAT;
*          READ'SPCS(I, SPCSA// SF'PUNT);
*          JUMP'RETURN(I// SF'PUNT)
*             IF SPCSP.SPCSNM = USP;
*ENDRPT;

*HELP
HEL:     FOR I←0 TO LCOMNM-1 DO;
            SETS(OL,0,0); APPEND(OL,COM'NM[I]//LLLL);
            WCI(NLCH,OL//LLLL);
LLLL:       PRINT'STRING(-1,OL,0//QUIT'PUNTX(COM'LP,OL));
        ENDFOR;
        GOTO COM'LP;

*QUOTE
QOT:     READ'LINE(-1,L,"&"",QF:L//QUIT'PUNTX(QT'RD,L)) WHILE 1;
        END;

        PROGRAM CP'PRT; INCLUDE COMDECS;
* PRINT LINE FOR CP
         ST L; INT ERMSNO; CHR ERCODE;

         ARBENT CP'PRT(L); WCI(NLCH, L);
R:      PRINT'STRING(-1, L, 0// QUIT'PUNTX(R, L)); RETURN;
        END;

        PROGRAM AR'DESC; INCLUDE COMDECS;
        INT N, S, O; PTR P;
        ARYENT AR'DESC(N, P, S, O);

         N ← N - 1 IF O = 0;
        RUNTIME'FAILURE() IF S > 63 OR S < 1 OR S > 3 AND N > 17777B OR
         N > 377777B OR N < O OR O # 0 AND O # 1;

         P ← MAKE((N + 1 IF O = 0 ELSE N)* S) IF P = 0;

         .LDA S; .SUB 1; .ICP 3; .BGT R' [3]; .IOR 100B; .LSHA 6; .LSHA 11;
        .IOR N; .CPZ O; .BEQ R' [2]; .IOR 1B7; .IOR 6B7; .CAB;
        .LDA P; .IOR 4B6; .XAB; RETURN;
        END;

        PROGRAM STORINIT; INCLUDE ALLOC'DECS;
*
* SET UP ZONES
*

         FUNCTION STORINIT(ZONE, SIZE), FRETURN;
        (ZONE ← ZONE + 1).HIDDEN ← SIZE;
        SETZONE(ZONE// FRETURN);
        CURRENT'ZONE ← INFINITY'ZONE ← ZONE; RETURN;
        END;

        PROGRAM SETZONE; INCLUDE ALLOC'DECS;
*
* INITIALIZE ZONE
*
         DECLARE FAREA,EXTERNAL OFLOTRAP;

         FUNCTION SETZONE(ZONE), FRETURN;
        FRETURN IF ZONE.HSIZE<FZHS+MINSIZ+4;
        ZONE.HZTAG ← 1;
        ZONE.FOVX ←OFLOTRAP;
        ZONE.FLIST ← -1;
        ZONE.FEXT←-1;
        FAREA ← ZONE + (FZHS+1);
        FAREA.HIDDEN←ZONE.HSIZE-(FZHS+1);
        EXTZONE(FAREA, ZONE// VALUE RUNTIME'FAILURE());
        RETURN ZONE;
        END;

        PROGRAM EXTZONE; INCLUDE ALLOC'DECS;
*
* ADD EXTENSION (B) TO ZONE (A)
*
         DECLARE EEXT,EXB;

         FUNCTION EXTZONE(EXT, ZONE), FRETURN;
        FRETURN IF EXT.HSIZE<MINSIZ+2;
        EEXT←EXT+EXT.HSIZE;
        EXT.FEXT←ZONE.FEXT;
        ZONE.FEXT←EXT;
        EXB←EXT+2;
        EXB.HIDDEN ← (1@HFREE-3) + EXT.HSIZE;
        (EEXT - 1).HIDDEN ← 1 @ HFTAG;
        FPB(EXB, ZONE);
        RETURN;
        END;

        PROGRAM FREEZONE; INCLUDE ALLOC'DECS;
*
* DELETE ZONE (A)
*
         DECLARE ZEPTR;

         FUNCTION FREEZONE(ZF,ZF1);
        SELZONE(INFINITY'ZONE) IF ZF = CURRENT'ZONE;
FZONE1: ZEPTR←ZF.FEXT; FREE(ZF,ZF1);
        GOTO FZONE1 IF (ZF←ZEPTR)>=0;
        RETURN;

        END;

        PROGRAM CIOS'INIT; INCLUDE CIOS'TAB, UCALLDECS;
*
* FUNCTIONS TO MANIPULATE CONTROL INPUT/OUTPUT STREAMS
*

* DECLARATIONS
         INT N, I, FN, V, SP, P,ERCODE, ERMSNO;

         CHRARY IPT[5] ← ('NUL', 'TRM', 'FIL', 'TSF', 'SPE');
        CHRARY OPT[5] ← ('NUL', 'TRM', 'FIL', 'TOF', 'SPE');

         LBARY ST'IPT[5] ← (STI'NUL, STI'TRM, ST'FAIL, ST'FAIL, ST'FAIL);
        LBARY ST'OPT[5] ← (STO'NUL, STO'TRM, ST'FAIL, ST'FAIL, ST'FAIL);

* CREATE CIOS
         INTENT ECREATE'CIOS(N) UCF(40);

         IF N < 0 DO;* LOOK FOR FREE ENTRY
            GOTO CR'FND IF CIOSTB[N] = 0 FOR N ← NCIOS BY -1 TO 1;
            FR'CTFUL;* TABLE FULL
        ELSE DO;
            FR'CTFUL IF N > NCIOS OR N < 1 OR CIOSTB[N] # 0;* ENTRY IN USE
        ENDIF;

* SET UP ENTRY
CR'FND:  CIOSTB[N] ← P ← MAKE(LCIOS, 0);
        P.CIOSCL ← 1 LSH READ'CSP();
        P.CIOSAL ← P.CIOSOPTION ← P.CIOSPOS ← 0;
        P.CIOSLEN ← NRMLEN;
        P.CIOSIB ← P.CIOSOB ← ST'DESC(0, 1, 8, 1); RETURN N;

* SET CIOS INPUT
         ARBENT EST'CIOS'IP(N, FN, V, FIL) UCF(43);

         TEST'CIOSN(N: N, SP, P// FR'CIXOB);
        TEST'CIOSC(P, SP// FR'CNCTL);
        GOTO ST'IPT[FN ← CODE'LKP(FN, IPT, 0// ST'FAIL)];

STI'NUL: FREE(I) IF I ← SBASE(P.CIOSIB) # 0;
        GOTO STI'XIT;

STI'TRM: P.CIOSIB ← ST'DESC(21, MAKE(7, 0), 8, 0)
        IF P.CIOSIB$EP = P.CIOSIB$BP;*** EFFIECIENCY
        P.CIOSIPN ← V;

STI'XIT: P.CIOSIPT ← FN; RETURN;
ST'FAIL:FR'CFLNM;* NAME NOT VALID

* SET CIOS OUTPUT
         ARBENT EST'CIOS'OP(N, FN, V, FIL) UCF(44);

         TEST'CIOSN(N: N, SP, P// FR'CIXOB);
        TEST'CIOSC(P, SP// FR'CNCTL);
        GOTO ST'OPT[FN ← CODE'LKP(FN, OPT, 0// ST'FAIL)];

STO'NUL: FREE(I) IF I ← SBASE(P.CIOSOB) # 0;
        GOTO STO'XIT;

STO'TRM: P.CIOSOB ← ST'DESC(21, MAKE(7, 0), 8, 0)
        IF P.CIOSOB$EP = P.CIOSOB$BP;*** EFFICIENCY
        P.CIOSOPN ← V;

STO'XIT: P.CIOSOPT ← FN; RETURN;
        END;

        PROGRAM DESTROY'CIOS; INCLUDE UCALLDECS, CIOS'TAB;
*
* DESTROY A CIOS
*
         INT N, P, Q;
        ARBENT DESTROY'CIOS(N);

         P ← CIOSTB[N]; NC'PUNT IF P = 0;
        FREE(Q) IF Q ← SBASE(P.CIOSOB) # 0;
        FREE(Q) IF Q ← SBASE(P.CIOSIB) # 0;
        FREE(P); CIOSTB[N] ← 0; RETURN;
        END;

        PROGRAM STACK'INIT; INCLUDE UCALLDECS;
*
* ACQUIRE PAGE FOR FREE STORAGE AND STACK SPACE
*
         INT T, ERMSNO; CHR ERCODE;

         ARBENT STACK'INIT(), FRETURN;

         T ← ACQUIRE'PMT(-1// FRETURN : ERCODE, ERMSNO);
        NEW'PMT'PAGE(T// FRETURN : ERCODE, ERMSNO);
        SET'MAP'BYTE(-1, FS'PAGE, T// FRETURN : ERCODE, ERMSNO);
        RETURN;
        END;

        PROGRAM UTS'INIT;
*
* UTS INITIALIZATION
*
         INCLUDE UCALLDECS, ICTDECS, CIOS'TAB, UTS'SPTAB, UTS'OFTAB;

         INT I, ERMSNO; CHR ERCODE; PTR P; ST C, L; INTARY F[LUFN];
        LN DUMMY'UNDK ← (-1, 0), NULL'UNDK ← (0,0);
        CHRARY OWK[LFN+1] ← (0, 6'OWNE', 6'R   ', 0, 0, 6'KEY ');
        CHRARY AFK[LFN+1] ← (0, 6'A-FR', 6'IEND', 0, 0, 6'KEY ');
        CHRARY GFK[LFN+1] ← (0, 6'G-FR', 6'IEND', 0, 0, 6'KEY ');

         ARBENT UTS'INIT();

* SAVE ENTER MESSAGE AWAY UNTIL FREE STORAGE IS INITIALIZED
         NAMSET(C, LINIT'MSG*3, INIT'MSG, 8);
        C$WP ← INCDES(C$RP, I) IF I ← GCI(C) < LINIT'MSG*3 ELSE
         NC'PUNT;
        IF I > 0 DO;
            L ← ST'DESC(I, STKMAKE((I + 2)/ 3), 8, 0);
            SCOPY(L, C// LF'PUNT);
        ELSE DO;
BEG:        L ← "";
        ENDIF;

* INITIALIZE FREE STORAGE AREA
         STORINIT(INITIAL'FS, INITIAL'SP-INITIAL'FS// LF'PUNT);

* INITIALIZE 'EXTENDED MONITOR' TABLES
         CIOSTB[I] ← 0 FOR I ← 1 TO NCIOS;
        USPT[I] ← 0 FOR I ← 1 TO NSPT;
        UOFT[I] ← 0 FOR I ← 1 TO NOFT;

* INITIALIZE SPT[1]
         USP ← READ'CSP(); USPT[USP] ← P ← MAKE(LUSPT, 0);
        P.USPTOL ← USPNM ← 1 LSH USP; P.USPTRCL ← 0; RCLVL ← 1;
        SET'SPT'FIELD(-1,'TM',READ'SPT'FIELD(-1,'TCM'//SF'PUNT) V'
         READ'SPT'FIELD(-1,'TM'//SF'PUNT)//SF'PUNT);
        SET'SPT'FIELD(-1,'SB',READ'SPT'FIELD(-1,'SCB'//SF'PUNT) V'
         READ'SPT'FIELD(-1,'SB'//SF'PUNT)//SF'PUNT);

* CREATE MAIN CIOS
         SET'SPT'FIELD(-1, 'CIO', CREATE'CIOS(-1// SF'PUNT)//
         SF'PUNT);
        I ← READ'PROC'PARAM('TNO'// SF'PUNT) RSH 1;
        SET'CIOS'OUTPUT(-1, 'TRM', I, 0// SF'PUNT);
        SET'CIOS'INPUT(-1, 'TRM', I, 0// SF'PUNT);
        SET'CIOS'FIELD(-1, 'EST', 1// SF'PUNT);
        SET'CIOS'FIELD(-1, 'BWS', 'CTL'// SF'PUNT);

* ACQUIRE INTERRUPT CELLS AND UTS TIMER
         I ← ACQUIRE'ICT(GET'INT'NO('CHI'// SF'PUNT)// SF'PUNT);
        SET'ICT(I, ICTBLKCD, 0, NULL'UNDK// SF'PUNT);
        QT'ICT ← ACQUIRE'ICT(GET'INT'NO('QT'// SF'PUNT)// SF'PUNT);
        SET'ICT(QT'ICT, ICTNULCD, 23, NULL'UNDK// SF'PUNT);
        I ← ACQUIRE'ICT(GET'INT'NO('ES'// SF'PUNT)// SF'PUNT);
        SET'ICT(I, ICTNULCD, USP, NULL'UNDK// SF'PUNT);*** CHEAT!
        I ← ACQUIRE'ICT(UTS'RTIMER// SF'PUNT);
        SET'ICT(UTS'RTIMER, ICTNULCD, USP, NULL'UNDK// SF'PUNT);
        RT'QUEUE ← 0;

* SET UP PAGE FOR ATTACHING FILES
         SET'MAP'BYTE(USP, ATF'PAGE, ATF'PMT ←
         ACQUIRE'PMT(-1// SF'PUNT)// SF'PUNT);

         PROC'OWNER ← READ'PROC'PARAM('UNO'// SF'PUNT);
        UTS'KEY ← READ'PROC'PARAM('IKY'// SF'PUNT);

         P ← @F[0]; P.UFNUN ← DUMMY'UNDK;* FIND VALUE FROM UNMIBDKA
        BCOPY(@(P.UFNEN), @OWK[0], LFN+1);
        USER'KEY ← OPEN'FILE(-1, F, 'RO', UTS'KEY// SF'PUNT);

         G'FRIEND ← A'FRIEND ← 0;
        BCOPY(@(P.UFNEN), @AFK[0], LFN+1);* ACCT OWNER?
        A'FRIEND ← OPEN'FILE(-1, F, 'RO', USER'KEY// SET'DK:
         ERCODE, ERMSNO);
        BCOPY(@(P.UFNEN), @GFK[0], LFN+1);* DITTO FOR GROUP OWNER
        G'FRIEND ← OPEN'FILE(-1, F, 'RO', USER'KEY// SET'DK:
         ERCODE, ERMSNO);

* NOTE THAT CAK(USP) IS LEFT 0 SO THAT UTS'KEY MUST BE USED EXPLICITLY
SET'DK:  SET'SPT'FIELD(USP, 'UAK', USER'KEY// SF'PUNT);

* MAKE UP DUMMY SEARCH LISTS TO BE OVER-RIDDEN BY PRO'INIT
         FIL'SRLIS ← AR'DESC(1, MAKE(1, 0), 1, 0);
        FIL'SRLIS[0] ← -1;
        COM'SRLIS ← AR'DESC(1, MAKE(1, 0), 1, 0);
        COM'SRLIS[0] ← -1;*?* KLUDGE FOR USER 1 OR GROUP-OWNER

         PRO'INIT();* ACTIVATE PROFILE MACHINERY

* NOW PUT THE ENTER MESSAGE INTO SAVED'LINE
         IF I ← LENGTH(L) > 0 DO;
            SAVED'LINE ← ST'DESC(I, MAKE((I + 2)/ 3), 8, 0);
            SCOPY(SAVED'LINE, L// LF'PUNT);
        ELSE DO;
            SAVED'LINE ← "";
        ENDIF;

         RETURN;

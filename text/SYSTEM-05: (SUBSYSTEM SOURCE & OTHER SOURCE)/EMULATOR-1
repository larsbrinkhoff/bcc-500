        COMMON EMDECS;
*
* 940 SYSTEM EMULATOR, GENERAL ORGANIZATION

* THE FUNCTION OF THIS PROGRAM IS TO PROVIDE AN ENVIRONMENT WITHIN
* WHICH PROGRAMS WRITTEN TO RUN WITHOUT EXECUTIVITY ON THE BCC VERSION
* OF THE 940 SYSTEM CAN EXECUTE ON THE M1.  TO THIS END ALL BRSS AND
* OTHER SYSPOPS ARE EMULATED WITH THE FOLLOWING EXCEPTIONS
*    1)  THOSE REQUIRING EXECUTIVITY
*    2)  ATTACH AND RELEASE TELETYPE, IST, OST AND CIO TO TELETYPES
*        OTHER THAN THE CONTROLLING ONE, LINKING
*    3)  THE PARALLEL EXECUTION OF FORKS.  A FORK ONCE STARTED CON-
*        TINUES TO RUN UNTIL IT RETURNS OR TRAPS OR THE USER HITS
*        QUIT.
*    4)  THE COPY, SAVE, PLACE, DUMP AND RECOVER BRSS
*    5)  BRS 57 IS IMPLEMENTED AS NOP
*    6)  BRS 48, 60 ARE NOT IMPLEMENTED
*    7)  FILE NAMING FOLLOWS M1 CONVENTIONS, NOT 940
*    8)  THE FORMAT OF BRS 100 FILES IS QUITE DIFFERENT
*    9)  EPHEMERAL MEMORY IS SOMEWHAT DIFFERENT
*   10)  THE 'NO TERMINATING CHARACTER' OPTION FOR FILE NAMING IS NOT
*        IMPLEMENTED

* THE COMMAND LANGUAGE PROCESSING DONE BY THE 940 EXEC IS NOT EMULATED.

* EACH SYSPOP IS HANDLED BY ITS OWN SPL FUNCTION.  IT TAKES ITS
* ARGUMENTS FROM THE STORED STATE, EXPLICITLY CHANGES ANY REGISTERS
* WHICH MUST BE CHANGED IN THE STORED STATE, AND RETURNS BY DOING
* A LOADS OF THE STATE.
* BECAUSE THE HARDWARE FOR A SYSPOP EXECUTION DOES NOT CHANGE L AND
* BECAUSE IT STORES THE STATE AT L[3], ALL SYSPOPS HAVE THE SAME LOCAL
* ENVIRONMENT.  THIS IMPLIES THAT A SYSPOP MAY NOT
*      HAVE ANY LOCAL VARIABLES
*      PASS AN FRETURN OR LABEL TO ANOTHER FUNCTION (BECAUSE L'[2]
*         IS NOT SET UP).
* OF COURSE IT MAY CALL AN ORDINARY FUNCTION WHICH DOES NOT SUFFER
* FROM THESE LIABILITIES.  THE CALLED FUNCTION MAY STILL RETURN TO
* THE 940 WITH LOADS PROVIDED ITS ENVIRONMENT IS FIXED.

* THE FUNCTION FOR BRS USES THE EFFECTIVE ADDRESS (I.E., THE BRS NUMBER)
* TO INDEX A TABLE OF PARAMETERLESS FUNCTIONS WHICH IMPLEMENT THE BRS,
* USING THE SAME PHILOSOPHY AS THE SYSPOPS ABOUT ARGUMENTS AND RESULTS.
* A BRS FUNCTION IS EXPECTED TO RETURN TO THE BRS SYSPOP, WHICH WILL
* THEN EXIT WITH A LOADS.
* IT IS POSSIBLE FOR A BRS
* FUNCTION TO EXIT BY A GOTO, FOR EXAMPLE TO RUN'NEXT'FORK.


* GLOBAL MACROS
         MACRO DF←DECLARE FIELD;
        MACRO DI←DECLARE;
        MACRO DP←DECLARE;


* MACRO TO FIXUP SYSPOPS
         MACRO DOSYSPOP(XX)← TRAP'ENTRY ←XX+20B;
* MISCELLANEOUS CONSTANTS

         DECLARE LONG LONGZERO←(0,0), LONGLONG LONGLONGZERO←(0,0,0,0);

         DF SIGN(0:0,0),W0(0),W1(1),W2(2),W3(3);
        DF FIELD'DISP(0:13,23);

         DECLARE NRH'BASE'ADDRESS←26*20000B;
        DECLARE PAGE'SIZE←4000B;
        DECLARE ZERO'8STR'IAW←44B6,TWO'8STR'IAW←46B6,ZERO'24STR'IAW←54B6;
* FIELD DESCRIPTORS FOR THE FIRST 6 BYTES OF A STRING
         DF SB0(0:0,7),SB1(0:8,15),SB2(0:16,23),SB3(1:0,7),SB4(1:8,15),
         SB5(1:16,23);

         DF FIRST'HALF(0:0,11),SECOND'HALF(0:12,23);
        DF ADDR14(0:10,23),ADDR18(0:6,23),ADDR8(0:16,23);
        DF SPTR'940(0:6,23),SPTR'940'1(1:6,23);
        DF CSIZE(0:2,3),CPOS(0:4,5);
        DP CSIZE8←1,CSIZE24←3;
        DF PAGE'NUMBER(0:0,12),WORD'ADDRESS(0:13,23);
        DP USER'NUMBER←7,LINE'NUMBER←11;
        DP READ'ACCESS←0,WRITE'ACCESS←1,RW'ACCESS←2;
        DI DF'INPUT;
        DI DF'OUTPUT;
        DF DF'IN(0:12,23),DF'OUT(0:0,11);

* WE NEED TWO FUNCTIONS TO WHICH CONTROL GOES
* AFTER ILLEGAL INSTRUCTIONS TRAPS.
         MACRO TRAP←TRAP'INST();
* AND AFTER UNANTICIPATED FRETURNS FROM SYSTEM ERRORS
         MACRO DSYSERR←SYSTEM'ERROR();
        MACRO SYSERR← VALUE DSYSERR:ERRSPEC;
        MACRO ERRSPEC←ERRCODE,ERRNUMBER;

         DECLARE ERRCODE,ERRNUMBER;

*NEED TO RESET THE LREG AND STACK POINTER WHEN RETURN TO THE EI FUNCTION
         DI EMLREG,EMSP;
        MACRO RESTORE'STACK←.LDA EMLREG, XLA, LDA EMSP, STA G' [2];
        MACRO STORE'STACK←.CLA, STA EMLREG, LDA G' [2], STA EMSP;

* MACRO TO STORE INTO I A STRING IAW WHICH POINTS TO THE ATH CHARACTER
* OF STORAGE.
* NOTE THAT BOTH ARGUMENTS MUST BE ACCEPTABLE MACHINE ADDRESSES

         MACRO MAKE'STRING'IAW(A,I)←.LDA ZERO'8STR'IAW, LDX A, ASP,
         STX I;

* SIZES OF THINGS
         DECLARE NFORKS←10;
        DECLARE NPMTBYTES←64;

* DECLARATIONS FOR THE SAVED STATE OF THE 940
* THE EXTRA SPACE IN SAVE'LE AFTER THE END OF THE STATE IS
* FOR LOCAL VARIABLES GENERATED BY THE COMPILER IN PROGRAMS
* WHICH DO SYSPOPS
*SYSPOP'ENT'ADD CONTAINS THE ADDRESS OF SYSPOP'ENTRY
*SYSPOP'BRU'ADD CONTAINS THE ADDRESS OF THE SYSPOP BRANCH INSTRUCTION
         DI SYSPOP'ENT'ADD;
        DI SYSPOP'BRU'ADD;
        DECLARE ARRAY SAVE'LE[20];
        DECLARE ARRAY SS[10:,@SAVE'LE[3]];

         DI SAVEDP=SS[0],SAVEDA=SS[1],SAVEDB=SS[2],SAVEDC=SS[3],
         SAVEDD=SS[4],SAVEDE=SS[5],SAVEDX=SS[6],SAVEDL=SS[7],
         SAVEDG=SS[8],SAVEDSR=SS[9];
        DECLARE LONG SAVEDAB=SS[1];

* C, D, E ARE IRRELEVANT TO THE 940.  C & D ARE THUS USED TO HOLD
*      TYMESHARE'S FLOATING ACCUMULATOR.

        DECLARE LONG FL'ACC=SS[3];

* L AND G MUST BE PROPERLY INITIALIZED (TO @SS[0]-3 AND 40000B
* RESPECTIVELY).  SINCE THEY ARE NEVER ALTERED BY THE 940 THEY NEED
* NO FURTHER ATTENTION

* RETURN FROM A SYSPOP
         DECLARE EXTERNAL QUIT;
        MACRO POPRET←.MIN SAVEDP, CPZ QUIT'FLAG, BNE R' [3],
         EAX SAVEDP, LOADS, BLLN QUIT;

* SKIP-RETURN FROM A SYSPOP
         MACRO POPSKIPRET←.MIN SAVEDP, POPRET;

* THE EFFECTIVE ADDRESS OF A SYSPOP IS THE PARAMETER OF THE TRAP
* THIS MUST BE CHANGED FOR THE NEW SYSPOP LOGIC
         DI SPEA= G' [5];
* LOCATION OF RING TRAP P AND PARAMETER
         DI RING'P= G' [4];
        DI RING'PAR= G' [5];

* A BRS OR SYSPOP CAN SKIP ON RETURN
         MACRO SKIP←SAVEDP←SAVEDP+1;

* EMULATION OF TELETYPES

* THE ONLY TELETYPES EMULATED ARE ONE CONTROLLING TELETYPE FOR THE RE-
* GULAR OPERATIONS, AND ONE DUMMY TELETYPE FOR SNOBOL JOB CONTROL.
* THE LATTER IS CREATED BY BRS 27 (ATTACH). THIS BRS IS ONLY LEGAL
* FOR THIS PURPOSE. IT ACCEPTS ANY TELETYPE NUMBER AND MAKES A NOTE OF
* IT. THE ONLY THINGS WHICH CAN LEGALLY BE DONE TO THIS TELETYPE AT
* THIS POINT ARE
*   BRS 139 (DISABLE OUTPUT) WHICH IS IGNORED
*   STI A RUBOUT.
* THE STI PUTS IT IN A MODE WHERE THE FOLLOWING THINGS ARE LEGAL
*   STI,STO, BRS 138(WIR), BRS 28 (RELEASE)
* NONE OF THESE OPERATIONS IS LEGAL ON THE CONTROLLING TELETYPE.
* OPERATIONS WHICH ARE LEGAL ON THE CONTROLLING TELETYPE ARE
*   CIO,TCI,TCO
*   BRS 11-14,29,40,85,86,123.
* THE OPERATIONS OST AND IST ARE NOT LEGAL. CIO'S WITH FILE NUMBERS OF
* 2000+TTY NO OR 3000+TTY NO ARE NOT LEGAL. THE LINK BRSS ARE NOT LEGAL

* CONTROLLING TELETYPE OPERATIONS ARE ALWAYS DONE TO THE DEFAULT CONTROL
* I/O STREAM


* THE HANDLING OF CARRIAGE RETURN, LINE FEED AND MULTIPLE BLANK
* ARE A LITTLE TRICKY. ON INPUT, RECEIPT OF A NEW LINE YIELDS A
* CARRIAGE RETURN AND SETS CR'FLAG←1, WHICH CAUSES AN IMMEDIATE OUT-
* PUT OF LINE FEED TO BE IGNORED.
* ON OUTPUT
*   CARRIAGE RETURN SETS CR'FLAG←2
*   LINE FEED WITH CR'FLAG=2 TRANSMITS A NEWLINE
*   ANY OTHER CHARACTER WITH CR'FLAG=2, OR A REQUEST FOR INPUT,
*   TRANSMITS A CARRAIGE RETURN OR
*   ENOUGH BACKSPACES TO PUT THE CARRIAGE AT THE BEGINNING
*   OF THE LINE
*   LINE FEED BY ITSELF TRANSMITS THE LINE-FEED FORMAT EFFECTOR

         DI CR'FLAG,MB'FLAG;
        DI TTYIN'8, TTYOUT'8;

         DF TTY'8LEVEL'FLAG(0:0,0),TTY'8IN'FLAG(0:3,3),TTY'8OUT'FLAG(0:4,4);
        DP FE'LINEFEED←310B,FE'NEWLINE←307B;

* EMULATION OF FORKS

* EACH FORK IS REPRESENTED BY A FORK NODE, WHICH IS A 14 WORD OBJECT
* CONTAINING EVERYTHING IT IS NECESSARY TO KNOW ABOUT THE FORK:
*   A, B, X AND P
*   FATHER, SON AND BROTHER NODES, 0 FOR NULL
*   (THE BROTHER CHAIN IS CIRCULAR)
*   INTERRUPT MASK
*   MEMORY ASSIGNMENT BITS, AS IN THE 940
*   PANIC TABLE ADDRESS
*   STATUS, AS IN THE 940
*   A FORK TO WAKEUP IF THIS ONE IS DESTROYED, USED TO IMPLEMENT BRS
*      31 ETC.  0 FOR NONE.
*   TWO WORDS OF MAP, AS IN THE 940
*   A LINK IN THE EXECUTION QUEUE OF FORKS WHICH CAN RUN.  THESE ARE
*      ALLOWED TO RUN TO COMPLETION ON A FIRST-COME, FIRST-SERVED
*      BASIS.  THIS FIELD IS 0 IF THE FORK IS NOT ON THE QUEUE.

* DECLARATION FOR FORK NODES
* CENTRAL REGISTERS
         DF FN'AR(0),FN'BR(1),FN'XR(2),FN'PCTR(3:10,23);
* FATHER, SON AND BROTHER POINTERS
         DF FN'FATHER(8),FN'SON(9),FN'BROTHER(10);
* INTERRUPT MASK
         DF FN'INTMASK(4:4,23);
* INTERRUPT 1 CORRESPONDS TO BIT 4, 2 TO BIT 5 ETC.
         DP INT0BIT←4B6;
* INTERRUPT 1 IS
         DF INTERRUPT1(0:4,4);
* INTERRUPT 3 IS
         DF INTERRUPT3(0:6,6);
* MEMORY ASSIGNMENT CONTROL
         DF FN'LOCALMEM(4:0,0),FN'NONEWMEM(4:1,1),FN'EPHMEM(4:2,2);
* PANIC TABLE ADDRESS
         DF FN'PANICTABLE(5:6,23);
* STATUS: -2=DISMISSED FOR I/O, -1=RUNNING, 0=KILLED FOR RUBOUT,
* 1=KILLED FOR ILLEGAL INSTRUCTION, 2=KILLED FOR MEMORY TRAP
         DECLARE SIGNED FIELD FN'STATUS(5:0,2);
* WAITING FOR SON TO BE DESTROYED
         DF FN'WAITING(11),FN'WAIT'ON'ANY(11:0,0),FN'WAIT'ON'SON(11:1,1),
         FN'WAITING'SON(11:6,23);
* MAP
         DECLARE LONG FIELD FN'MAP(6);
* WORKING SET SIZES (FOR SUBSYSTEMS)
         DF FN'CWS(12:0,11),FN'DWS(12:12,23);
* QUEUE POINTER
         DF FN'PTR(13);
* TOTAL SIZE
         DECLARE FORK'NODE'SIZE←14;
        DECLARE ARRAY FORK'NODES[NFORKS:FORK'NODE'SIZE];

         DF SETRELPT(0:1,1),PROP'RUBOUT(0:2,2),FIXEDMEM(0:3,3),
         LOCALMEM(0:4,4),EPHMEM(0:5,5),SETINTMASK(0:6,6);

* DECLARATIONS FOR PANIC TABLE
         DF PT'PCTR(0),PT'AR(1),PT'BR(2),PT'XR(3);
        DECLARE LONG FIELD PT'MAP(4); DF PT'STATUS(6);
        DF PT'INTMASK(7);

* ARRAY OF FIELD DESCRIPTORS FOR MAP BYTES
         DF MB0(0:0,5),MB1(0:6,11),MB2(0:12,17),MB3(0:18,23),
         MB4(1:0,5),MB5(1:6,11),MB6(1:12,17),MB7(1:18,23),
         MB8(2:0,5),MB9(2:6,11),MB10(2:12,17),MB11(2:18,23),
         MB12(3:0,5),MB13(3:6,11),MB14(3:12,17),MB15(3:18,23);
        DECLARE FIELD ARRAY MAP'BYTE[8]←(MB0,MB1,MB2,MB3,MB4,MB5,MB6,MB7);
        DECLARE FIELD ARRAY CHAR[16]←
         (MB0,MB1,MB2,MB3,MB4,MB5,MB6,MB7,MB8,MB9,MB10,MB11,
         MB12,MB13,MB14,MB15);

         DECLARE LONG USER'MAP;


* VARIABLES CONNECTED WITH FORKS
         DI QUIT'FLAG,RUNNING'FORK,RUBOUT'TARGET,FORK'IN'MAP;

         DI FN'FREELIST;
        DI EXECUTIONQ;

* GLOBAL CELL TO HOLD A LABEL ON THE SCHEDULER
         DECLARE LABEL RUN'NEXT'FORK;


* EMULATION OF MEMORY
* EACH 940 PMT BYTE HAS A CORRESPONDING M1 PMT BYTE.
* THE 940 BYTE NUMBER INDEXES INTO THE ARRAY
* PMT'940 TO GET THE M1 BYTE NUMBER
* THE MAP OF A FORK IS STORED AS 2 WORDS (8 6-BIT BYTES) IN ITS
* NODE.  MEMORY ACQUISITION IS HANDLED BY FIELDING THE TRAP AND
* TAKING APPROPRIATE ACTION DEPENDING ON THE STATUS BITS OF THE
* RUNNING FORK.          
* A FORK MAP IS CHECKED AND CONSIDERED TO BE LEGAL.  WHEN A BYTE
* IS RELEASED IT IS REMOVED FROM ALL FORK MAPS.

* A TABLE CALLED BYTE'OWNER RECORDS THE FORK RESPONSIBLE FOR THE
* ACQUISITION OF EACH BYTE.  RESPONSIBILITY IS TRANSFERRED TO THE FATHER
* IF THE FORK IS DESTROYED AND DOES NOT HAVE EPHEMERAL MEMORY

* THE NRH IS EMULATED BY PAGES ON A FILE CALLED <PROCESS NAME>:NRH
* THIS TEMPORARY FILE IS (CREATED AND) OPENED BY BRS 126 IF NECESSARY.
* ITS FILE NUMBER, IF IT IS OPEN, IS KEPT IN NRH'FILE, WHICH IS ZERO
* OTHERWISE. A BRS 7 DELETES THIS FILE.
* USER RELABELING (BRS 116/117) IS MAINTAINED.  IT IS CHECKED BEFORE
* BEING SET.

         DECLARE ARRAY BYTE'OWNER[NPMTBYTES];
        DI NRH'FILE;
        DECLARE STRING NRH'NAME(16);

* EMULATION OF FILE NAMING
* 940 FILE NAMES ARE EMULATED DIRECTLY WITH M1 FILE NAMES.  THIS MEANS
* THAT THEY ARE LIMITED TO 16 CHARACTERS.  THE UTILITY'S NAME-COLLECTION
* APPARATUS IS USED TO COLLECT A NAME.  THIS MEANS THAT M1 CONVENTIONS
* WILL APPLY TO NAMES COLLECTED FROM THE TELETYPE.  IN CASES WHERE
* A PROGRAM CONSTRUCTS A COMPLETE NAME, WHETHER QUOTED OR NOT, THE 940
* AND M1 CONVENTIONS AGREE, SO THAT THERE SHOULD BE NO DIFFICULTY.
* 940 FILE TYPES ARE CODED INTO M1 FILE TYPES AS FOLLOWS:
*      5 = '5SYM'    (SPECIAL KLUDGE TO ENABLE PFS TO HANDLE M1 SYMBOLIC FILES)
*      4 = '9DMP'
*      3 = '9SYM'
*      2 = '9BIN'
*      1 = '9SAV'
*      0 = '9SUB'
*      6-7 = '9TY6' - '9TY7'
* INFORMATION ABOUT RANDOMNESS IS NOT PRESERVED, AND A FILE IS ALWAYS
* REPORTED AS SEQUENTIAL OR RANDOM, WHICHEVER THE BRS REQUESTS.
* THE NAMES *T AND *N WILL BE INTERPRETED AS THE TELETYPE AND NOTHING
* RESPECTIVELY.
* THE 'NO TERMINATING CHARACTER' FEATURE IS NOT IMPLEMENTED.

         DP NON'SEQ'MEDIUM←2B7;
        DF FILE'TYPE(0:3,5),RANDOM'FILE(0:0,0);
        DF DONT'OPEN(0:1,1);
        DECLARE ARRAY TYPE'NAME[8]←(6'9SUB',6'9SAV',6'9BIN',6'9SYM',
         6'9DMP',6'5SYM',6'9TY6',6'9TY7');

* DECLARATIONS RELATED TO MIB

* THE 8-WORD NAME WHICH IS AN ARGUMENT OF MOST FILE SYSTEM CALLS IS
         DECLARE FIELD MIB'UNO(0),MIB'DKA(1),LONG FIELD MIB'UNDK(0),
         INTEGER FIELD MIB'E (2), LONGLONG FIELD MIB'NAME (3),
         INTEGER FIELD MIB'TYPE (7);
* WE NEED A PLACE TO  BUILD ONE OF THESE
         DECLARE ARRAY MIB'OBJECT'NAME [8];
* AND A POINTER TO THIS ARRAY
         DECLARE POINTER MIB'ADDRESS←@MIB'OBJECT'NAME[0];
* WE ALSO NEED A STRING POINTER TO THE NAME.
* NOTE THAT THESE ARE 6-BIT BYTES.
         DECLARE STRING MIB'NAME'STRING;

*THIS STILL NEEDS TO BE INITIALIZED
         DECLARE STRING PROCESS'NAME (16:6);

         DF PAGEBITS(0:10,12),BYTENO(0:18,23);
        DF LOCK'LIST'LENGTH(0:2,5);
        DF OFT'RW'BITS(0:1,2);

* EMULATION OF FILE SYSTEM

* DRUM FILES, NOTHING (FILE 2) AND THE TELETYPE (FILES 0 AND 1) ARE
* EMULATED. THE OPERATIONS EMULATED ARE
*   CIO,WIO,BIO
*   DWI,DWO,DBI,DBO

*   BRS 17,20
*   BRS 66 (DELETE CONTENTS)
*   BRS 110 (READ DEVICE AND UNIT)
*   BRS 115 (SKIP IF NO FILES OPEN)
*   BRS 130 (READ DRUM ASG)
*   BRS 143, 144

* FILES ARE KEPT TRACK OF IN A FILE TABLE INDEXED BY FILE NUMBER.   FILE
* NUMBERS START AT 3 AND END AT 15.  EACH FILE HAS AN M1 FILE NUMBER
* AND A PMT BYTE AND MAP SLOT FOR A BUFFER.
* THE MAP SLOT, I.E., THE CORE ADDRESS OF THE BUFFER, IS GIVEN
* BY (BUFFER'BASE+FILE NUMBER -3)*PAGE'SIZE.  CORE FROM 200000B TO
* 260000B IS THUS RESERVED FOR FILE BUFFERS.
         DP BUFFER'BASE←200000B/PAGE'SIZE;
* THE ADDRESS OF THE PAGE NOW IN THE BUFFER IS KEPT, TOGETHER
* WITH A READ/WRITE POINTER FOR THE BUFFER AND A FLAG WHICH TELLS
* WHETHER IT IS IN CHARACTER OR WORD MODE. A LENGTH FOR THE 940 FILE
* IS KEPT AND USED TO RESET THE M1 LENGTH WHEN THE FILE IS CLOSED.
* THE 940 LENGTH CAN BE SET BY THE USER AND IS SET WHEN A SEQUENTIAL
* OUTPUT FILE IS CLOSED. THREE BITS SPECIFY READ/WRITE/POSITION
* AUTHORITY.  THE 940 SYSTEMS DATA BLOCK SIZE AND USER WORDS ARE NOT
* IMPLEMENTED.
* THE SEQUENTIAL POINTER IS TO THE LAST WORD TOUCHED.
* CONVENTION:  INSIDE THE ROUTINES WHICH HANDLE FILES, A FILE
* IS NORMALLY REPRESENTED BY THE ADDRESS OF ITS FILE TABLE ENTRY.
* THIS IS COMPUTED FROM THE FILE NUMBER BY THE SYSPOPS AND BRS'S
* BEFORE ANY ROUTINES WHICH DO REAL WORK ARE CALLED.
* CONVENTION: RP AND WP POINT TO THE LAST CHARACTER DEALT WITH,
* NOT TO THE NEXT CHARACTER.  THIS MEANS THAT ON SEQUENTIAL
* OPERATIONS THE ISD COMES BEFORE THE LOAD/STORE SO THAT NO
* TROUBLE OCCURS ON PAGE BOUNDARIES.  BECAUSE THIS IS THE OPPOSITE
* OF THE 940 CONVENTION, CARE MUST BE TAKEN WHENEVER PASSING
* THE SEQUENTIAL POINTER BETWEEN THE EMULATOR AND THE 940 PROGRAM.


* DECLARATIONS FOR FILE TABLE
         DECLARE MIN'FILE←3,MAX'FILE←15,L'FT'ENTRY←7;
        DECLARE ARRAY FILE'TABLE [MAX'FILE+1:L'FT'ENTRY];
        DECLARE CHARACTER ARRAY FILE'DEV'NAME[MIN'FILE]←('CSI','CSO','NON');
        DF M1'FILE'NO(0),BUFFER'BYTE(1);
        DF BUFFER'PAGE(2:6,23),PAGE'IN'BUFFER(3);
        DF FILE'LENGTH(4);
* NOTE THAT WE ALLOW TWO WORDS FOR THE STRING DESCRIPTOR USED
* AS A BUFFER POINTER, AND OPERATE ON IT WITH MACHINE INSTRUCTIONS.
         DF SEQ'PTR(5),SEQ'PTR'LWA(5:6,23),
         SEQ'PTR'CSIZE(5:2,3),SEQ'PTR'CPOS(5:4,5);
        DF END'SEQ'PTR(6);
        DF END'PTR'CSIZE(6:2,3);
        DF IS'INPUT'FILE(2:0,0),IS'OUTPUT'FILE(2:1,1),IS'SEQ'FILE
         (2:0,1);
        DF READ'OK(2:2,2),WRITE'OK(2:3,3),POS'OK(2:4,4),
         FILE'CAPS(2:2,4),FILE'RW'CAPS(2:2,3);
        DF FT'ENTRY'ACTIVE(2:5,5);

         DF FILE'NO(0:20,23);
        DF EOFBIT(0:7,7),ERRBIT(0:6,6),ABENDBIT(0:0,0);
        DP EOFWORD←137B+400B*(137B+400B*137B);
        DP EOFCHAR←137B,CARRIAGE'RETURN←155B,LINE'FEED←152B;

* FILE TABLE ENTRY FOR NRH
         DECLARE ARRAY NRH'FT'ENTRY[L'FT'ENTRY];

* COMMAND AND TOUT FILE NUMBERS.  THESE NUMBERS ARE INITIALIZED TO
*    0 AND 1 RESPECTIVELY.  THEY ARE USED TO GUIDE THE EMULATOR I/O
*    FROM/TO FILES OTHER THAN THE TERMINAL WHEN SO SET UP BY BRS'S.
         DECLARE COMMAND'FILE'NO,TOUT'FILE'NO;

* FIELDS FOR BRS143/144
         DF THINGY'TYPE(0:0,11),ATTRIBUTE(0:12,23);
        DF SEQ'PTR'CHAR'POS(0:0,1);

*
*STARTUP DECLARATIONS
*NEED TO CHANGE THE ORGANIZATION TO NOT ASSUME THAT THE UPPERMOST
*FORK IS ALWAYS A SUBSYSTEM

*A SUBSYSTEM FILE HAS THE FORMAT OF A PROGRAM IMAGE FILE (ATTACH FILE)
         DP SUBSYSTEM'FILE←6'9SUB',DUMP'FILE←6'9DMP';
*THE DUMMY PANIC TABLE IS USED TO STARTUP THE TOPMOST FORK
         DECLARE ARRAY DUMMY'PT[8];
        DP PANIC'TABLE←@DUMMY'PT[0];
        DECLARE LONG PANIC'MAP=DUMMY'PT[4];
*SAVE STARTING ADDRESS OF UPPERMOST FORK FOR DUMP AND CONTINUE
         DI START'ADDRESS,SUB'SYS'CWS,SUB'SYS'DWS;
*NEED SOME PAGES FOR BUFFERING
         DI BUF'BYTE,BUF'FILE'NO,BUF'PTR;
        DP BUF'PAGE←BUFFER'BASE+MAX'FILE-MIN'FILE+1;
        DP BUF'ADDRESS←BUF'PAGE*4000B;
        DP COPY'FROM'PAGE←BUF'PAGE+1,COPY'FROM'ADD←COPY'FROM'PAGE*4000B;
        DP COPY'TO'PAGE←COPY'FROM'PAGE+1,COPY'TO'ADD←COPY'TO'PAGE*4000B;
        DP NRH'BUF'BASE←COPY'TO'PAGE+1;
        DI NO'NRH'BUFS,NEXT'NRH'BUF;
        DECLARE ARRAY NRH'BUF'BYTE[8],NRH'PAGE'IN'BUF[8];
        DECLARE LONGLONG ARRAY SUB'FILE'NAMES[4];
        DI NO'SUB'FILES;
        DP NCMEM←0;                    * NO SMT IN THIS MACHINE!!!!
*PMT'940 CONTAINS THE M1 BYTES ASSOCIATED WITH A 940 BYTE INDEX
         DECLARE ARRAY PMT'940[NPMTBYTES];
*NEED TO KEEP TRACK OF A PAGE WHICH COMES FROM A SUBSYSTEM FILE
         DF IS'SUB'BYTE(0:0,0),SUB'NAME(0:1,7),SUB'PAGE(0:8,15);
        DF PMT'M1(0:16,23);
        DP PIF'FILE'INDEX←3,ENTRY'POINT←44;
        DF CD'BITS(0:0,1),FILE'IND'BITS(0:6,11);
        DI CUR'NAME'INDEX;
        DI TOPMOST'FORK;
        DECLARE STRING TOPMOST'NAME(16);
        DI QUIT'CHAR;
        DI EM'SUBPROCESS;
        DI ERROR'STATE;
        DECLARE STRING ARRAY ATIM[3]←("AT ","I>>","M>>");

*TRAP VARIABLES
         DECLARE ARRAY TSS[10];
        DI TP=TSS[0],TX=TSS[6];
        DECLARE TI'TRAP'NO←5,PRO'TRAP'NO←1,PNIM'TRAP'NO←2,QUIT'TRAP'NO←23;
        DECLARE TI'TRAP'BIT←1B6,PRO'TRAP'BIT←2B7,PNIM'TRAP'BIT←1B7,
         QUIT'TRAP'BIT←1;
        DECLARE TRAP'BITS←TI'TRAP'BIT+PRO'TRAP'BIT+PNIM'TRAP'BIT+
         QUIT'TRAP'BIT;
        DI M940←1B3;
*M1 MODE
         DECLARE ARRAY RSS[10];
        DI RP=RSS[0],RX=RSS[6],RS=RSS[9];
        DF M1'TRAP'ADD(0:10,23);
        DF M1'TRAP'NO(1);
        DF M1'TRAP'PAR(2);
        DF M1'RING'ADD(3);
        DF M1'RING'P(4);
        DF M1'RING'PAR(5);
        DF M1'RING'NO(6);
        DI M1'RING'BITS,M1'TRAP'MASK,M1'TABLE,M1'MODE;

*FLOATING POINT DECLARATIONS
         DECLARE SIGNED FIELD EXPT(0:15,23);
        DECLARE LONG HUGE←(37777777B,77777377B);
        DI ZM,ZE;
        DP OV'BIT←2,TOV'BIT←4;

*ECHO DECS
         DI NEW'ECHO,OLD'ECHO,OLD'EST,OLD'BWS,OLD'TRI,OLD'TRO,SAVE'ECHO;
        DECLARE ARRAY BWS'TABLE[4]←('ALL','PUN','CTL','ALL');

* THINGS TO BE DEFINED OR INITIALIZED OR OTHERWISE STRANGE
         DECLARE LONG USER'UNDK;
        DP NULLCH←300B;
        DI COMND'MODE;
        DF SCIOS'SP;

*** THESE NEED TO BE RENAMED
         MONITOR READ'MIB'ENTRY←1;
        MONITOR DELETE'MIB'ENTRY←5;
        MONITOR READ'OFT'ENTRY←20;
        MONITOR SET'OFT'CL←22;
        MONITOR SET'FILE'LENGTH←23;
        MONITOR CREATE'FILE'PAGE←24;
        MONITOR DELETE'FILE'PAGE←25;
        MONITOR NEXT'FILE'PAGE←26;
        MONITOR PUT'PAGE'IN'PMT←27;
        MONITOR ACQPMT←50;
        MONITOR NPPMT←51;
        MONITOR CLRPMT←53;
        MONITOR DELPMT←54;
        MONITOR SPMTRO←57;
        MONITOR READ'PMT←58;
        MONITOR PPCWS←66;
        MONITOR DEL'PAGE'DWS←67;
        MONITOR DEL'PAGE'CWS←68;
        MONITOR READ'LWS←70;
        MONITOR SET'LWS←71;
        MONITOR READ'SPCS←96;
        MONITOR SET'SPT'FIELD←98;
        MONITOR SET'MAP'BYTE←102;
        MONITOR READ'SPS'PARAM←106;
        MONITOR SP'RETURN←116;
        MONITOR MODIFY'CALL←120;
        MONITOR ALLOW'INTS←168;
        MONITOR REFUSE'INTS←169;
        MONITOR BLOCK←170;
        MONITOR SETICT←172;
        MONITOR SCLICT←173;
        MONITOR ACQICT←174;
        LONG MONITOR READ'TIME←210;
        MONITOR READ'PROC'PARAM←211;

         UTILITY BREAK←0;
        UTILITY CONV'NAME←12;
        UTILITY READ'MIBOB'VALUE←14;
        UTILITY SET'CIOS'FIELD←42;
        UTILITY READ'CIOS'FIELD←41;
        UTILITY READ'CHAR←50;
        UTILITY PRINT'CHAR←46;
        UTILITY WAIT'OB'EMPTY←51;
        UTILITY RET'CIOS'INPUT←255;
        UTILITY RECURSE'CP←254;
        UTILITY UNRECURSE'CP←253;
        UTILITY READ'CIOS'OUTPUT←252;
        UTILITY CREATE'CIOS←40;
        UTILITY SET'CIOS'INPUT←43;
        UTILITY SET'CIOS'OUTPUT←44;
        UTILITY DELETE'FILE←15;
        UTILITY NAME'SEARCH←10;
        UTILITY START'OUTPUT←47;
        STRING UTILITY READ'LINE←48;
        UTILITY OPEN'FILE←16;
        UTILITY CLOSE'FILE←17;
        STRING UTILITY GET'PARAM←2;
        UTILITY PRINT'STRING←45;
        STRING UTILITY ERROR'MSG←1;
        STRING UTILITY GET'COM'LINE←3;
        UTILITY SET'SP'NAME←38;
        END;

        COMMON NEW'GLOBALS;
        INCLUDE EMDECS;
        DF END'PTR'CPOS(6:4,5);
        END;

        COMMON POPVARS;
* THESE VARIABLES TAKE THE PLACE OF THE LOCAL ENVIRONMENT WHICH SYSPOPS
* ARE NOT PERMITTED TO HAVE
         INCLUDE EMDECS;
* KLUDGE TO PLACE COMPILER TEMPS PAST THE STORED STATE IN THE
* LOCAL ENVIRONMENT
         MACRO SET'LE← FIXED , ORIGIN @SS[0]-3;
        MACRO JUMP'LE←DECLARE Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q8,Q9,Q10,Q11,Q12,Q13;
        DECLARE LONG GH,IJ;
        DI G=GH$W0,H=GH$W1,I=IJ$W0,J=IJ$W1,K,F,CNT;
        DI A'LONGER;
        END;

        COMMON ERROR'MESSAGES;
        INCLUDE EMDECS;

         DECLARE STRING ARRAY ERROR'MESSAGE[30]←(
         "NOT IMPLEMENTED",
         "ARRAY BOUNDS ERROR",
         "FLO",
         "FLU",
         "RO",
         "IATRP",
         "UFN",
         "FLXO",
         "DIZ",
         "STKOV",
         "BLL",
         "SYSTEM ERROR",
         "SYSTEM ERROR IN TRAP LOGIC",
         "ILLEGAL PANIC TABLE",
         "BAD RECOVER FILE",
         "BAD COMMAND",
         "BAD FIRST PAGE IN FILE",
         "TOO MANY SUBSYSTEMS",
         "PMT FULL",
         "ERROR 19",
         "ERROR 20",
         "ERROR 21",
         "ERROR 22",
         "ERROR 23",
         "ERROR 24",
         "ERROR 25",
         "ERROR 26",
         "ERROR 27",
         "ERROR 28",
         "ERROR 29");
         END;

        COMMON REAL'NAMES;
* FOR MACHINE SIMULATION
         DECLARE ARRAY EM'HEADER[46:,174000B]←
         (0,7,0,0,0,0,0,60010000B,0,0,2002B,20032004B,20052006B,20070000B);
        DECLARE ARRAY EM'HEADER[44]←(40012B,40000B);
*          MACRO RNTE(X,Y)←(X,0,0,0,Y);
*         DECLARE ARRAY RNT[15:5]←(RNTE(31,32),RNTE(8,33),RNTE(15,34),
*         RNTE(16,35),RNTE(17,36),RNTE(18,37),RNTE(19,38),RNTE(30,40),
*         RNTE(6,41),RNTE(7,42),RNTE(60,23),RNTE(61,24),RNTE(62,25),
*         RNTE(63,26),(-1,0,0,0,0));
*         DECLARE RNTP=G'[7]←@RNT[0];
         END;

        COMMON CCPDECS;

*X** EMULATION OF CCP STUFF
*X** BRS 27,28,138,139 AND STI,STO ARE EMULATED FOR ONE ATTACHED TELETYPE
*X** SO THAT CCP AND ITS SNOBOL EQUIVALENT CAN RUN.  THE EMULATION USES
*X** THE UTILITY'S CONTROL I/O STREAMS IN THE FOLLOWING WAY.
*X**     1)  BRS 27 CREATES A CIOS WHICH IS SET UP TO TAKE ITS INPUT FROM,
*X** AND DELIVER ITS OUTPUT TO, THE SUBPROCESS IN WHICH THE EMULATOR IS
*X** RUNNING.  A FLAG CALLED CCPIO, WHICH IS NORMALLY SET TO -1, IS SET TO
*X** 0.  THIS MAKES STI OF 137 AND BRS 28 LEGAL.  ALL OTHER ACTIVITY ON
*X** THIS TELETYPE REMAINS ILLEGAL.
*X**     2)  WHEN STI OF 137 IS EXECUTED, CCPIO BECOMES 1 AND EMULATION
*X** OF THE 940S ENTER DIALOGUE IS INITIATED.  SUBSEQUENT STO'S WILL GET
*X** CR LF "ENTER ".  CCPIO THEN CHANGES TO 2 AND SUBSEQUENT STI'S ABSORB
*X** CHARACTERS UP TO A ".".  DURING THIS PERIOD STO'S WILL GET THE
*X** CHARACTERS INPUT SO FAR.  CCPIO THEN CHANGES TO 3 AND STO'S WILL GET
*X** THE REMAINING INPUT CHARACTERS AND CR LF "PASSWORD ".  CCPIO CHANGES
*X** TO 4 AND STI'S ABSORB CHARACTERS UP TO ANOTHER ".".  CCPIO CHANGES
*X** TO 5 AND THE STRING "OK" CR LF IS QUEUED FOR STO.  THE ENTER DIALOGUE
*X** IS NOW COMPLETE.
*X**     3)  AT THIS POINT THE UTILITY IS CALLED TO SET UP A RECURSION OF
*X** THE COMMAND PROCESSOR WHICH WILL BE GIVEN THE NEW CIOS AS ITS INPUT.
*X** WHEN THIS RECURSION NEEDS INPUT OR HAS OUTPUT TO DELIVER, IT WILL
*X** MAKE A SUB-PROCESS CALL ON THE EMULATOR.  AT THIS POINT
*X**     4)  WE ARE IN THE NORMAL STATE FOR HANDLING CCP I/O.  THE GENERAL
*X** PHILOSOPHY IS TO RUN THE 940 FORKS UNTIL NONE CAN RUN AND THEN TO
*X** GIVE CONTROL BACK TO THE UTILITY, PROVIDED THE SERVICE
*X** IT REQUESTED IS COMPLETE.  IF IT IS NOT, WE HAVE A DEADLOCK AND AN
*X** ERROR IS SIGNALED VIA THE CCPTRAP FUNCTION.  THE CODE AT CIOS'REQUEST
*X** MAKES IT FAIRLY CLEAR HOW THE VARIOUS POSSIBILITIES ARE EXPLORED.
*X** A GROUP OF STATE VARIABLES DECLARED BELOW KEEPS TRACK OF WHAT IS
*X** GOING ON.  NOTE THAT A CERTAIN AMOUNT OF 'PARALLELISM' IN 940
*X** EXECUTION IS ADMITTED HERE:  FORKS WHICH EXECUTE STI, STO OR BRS 138
*X** WHICH CANNOT BE SERVICED ARE HUNG, I.E., THEIR STATE IS REMEMBERED.
*X** THEY ARE UNHUNG WHEN SERVICE BECOMES POSSIBLE.
*X**     5)  BRS 28 DESTROYS THE CIOS AND UNRECURSES THE COMMAND PROCESSOR
*X*
*X*          DI HANGING'STI,HANGING'STO,HANGING'WIR;
*X*          DI PENDING'CIOS'REQ; DP CIOS'INPUT'REQ←1,CIOS'OUTPUT'REQ←2;
*X*          DI CIOS'OUTPUT'READ;
*X*          DI CCP'TELETYPE;
*X*          DI CCP'CIOS;
*X*          DI CCPIO;
*X*          DECLARE STRING CCP'INPUT(500),CCP'OUTPUT(100);

        PROGRAM EMINT;
        INCLUDE EMDECS;
SYSPOP'ENTRY:.STA SPEA, ADX 20B;
SYSPOP'BRU:.BRU $ G' [6];

         FUNCTION EI();
*BRU INDIRECT THROUGH SYSPOP'ENT'ADD TO GET TO SYSPOP'ENTRY
         SAVE'LE[2]←150B5+@SYSPOP'ENT'ADD-40000B;
        SYSPOP'ENT'ADD←@SYSPOP'ENTRY;
        SYSPOP'BRU'ADD←@SYSPOP'BRU;
        EMSTART();
        SP'RETURN(//SYSERR);
        END;

        PROGRAM BRSMUX;
        INCLUDE POPVARS;
        SET'LE;
        JUMP'LE;
        DECLARE EXTERNAL TRAP'INST;

*BRS DISPATCHER
         DECLARE FUNCTION ARRAY BRSFCNS[190]←
         (READ'USER,TRAP'INST,TRAP'INST,TRAP'INST,BRS4,
         BRS5,BRS6,BRS7,TRAP'INST,BRS9,
         BRS10,BRS11,BRS12,BRS13,BRS14,
         BRS15,BRS16,BRS17,BRS18,BRS19,
         BRS20,BRS21,TRAP'INST,TRAP'INST,TRAP'INST,
         TRAP'INST,TRAP'INST,TRAP'INST,TRAP'INST,BRS29,
         BRS30,BRS31,BRS32,BRS33,BRS34,
         BRS35,BRS36,BRS37,BRS38,BRS39,
         BRS40,TRAP'INST,BRS42,BRS43,BRS44,
         BRS45,TRAP'INST,TRAP'INST,BRS48,BRS49,
         BRS50,BRS51,BRS52,BRS53,TRAP'INST,
         TRAP'INST,TRAP'INST,BRS57,TRAP'INST,BRS59,
         BRS60,TRAP'INST,TRAP'INST,BRS63,TRAP'INST,
         BRS65,BRS66,BRS67,TRAP'INST,TRAP'INST,
         BRS70,BRS71,TRAP'INST,BRS73,TRAP'INST);
        DECLARE FUNCTION ARRAY BRSFCNS[75]←
         (TRAP'INST,TRAP'INST,BRS77,BRS78,BRS79,
         BRS80,BRS81,TRAP'INST,TRAP'INST,TRAP'INST,
         BRS85,BRS86,TRAP'INST,BRS88,TRAP'INST,
         BRS90,BRS91,BRS92,BRS93,BRS94,
         BRS95,TRAP'INST,TRAP'INST,TRAP'INST,TRAP'INST,
         BRS100,PLACE'FILE'PAGES,TRAP'INST,TRAP'INST,TRAP'INST,
         TRAP'INST,BRS106,BRS107,BRS108,BRS109,
         BRS110,TRAP'INST,TRAP'INST,BRS113,BRS114,
         BRS115,BRS116,BRS117,TRAP'INST,TRAP'INST,
         BRS120,BRS121,TRAP'INST,BRS123,BRS124,
         BRS125,BRS126,BRS127,TRAP'INST,TRAP'INST,
         BRS130,TRAP'INST,TRAP'INST,TRAP'INST,TRAP'INST,
         M1'INIT,M1'START,DIRECT'IO,TRAP'INST,TRAP'INST,
         TRAP'INST,TRAP'INST,BRS142,BRS143,BRS144,
         BRS145,BRS146,BRS147,BRS148,BRS149);
         DECLARE FUNCTION ARRAY BRSFCNS[150]←
         (TRAP'INST,BRS151,TRAP'INST,BRS153,TRAP'INST,
         TRAP'INST,TRAP'INST,TRAP'INST,TRAP'INST,TRAP'INST,
         TRAP'INST,TRAP'INST,TRAP'INST,TRAP'INST,TRAP'INST,
         TRAP'INST,TRAP'INST,TRAP'INST,TRAP'INST,TRAP'INST,
         TRAP'INST,TRAP'INST,TRAP'INST,TRAP'INST,TRAP'INST,
         TRAP'INST,TRAP'INST,TRAP'INST,TRAP'INST,TRAP'INST,
         TRAP'INST,BRS181);

         FUNCTION BRS'(), DOSYSPOP(73B);
        TRAP IF SPEA>181;
        (BRSFCNS[SPEA])();
        POPRET;
        END;

        PROGRAM MISC'POPS;
        INCLUDE POPVARS;
        SET'LE;
        JUMP'LE;
        ENTRY SBRR'(),DOSYSPOP(71B);
        SAVEDSR←SAVEDSR V' 2 IF ((SPEA.ADDR14.W0) A' 4B7) # 0;
        POPRET;

         ENTRY SBRM'(), DOSYSPOP(70B);
        IF (SAVEDSR A' 2) # 0 DO;
            (SPEA.ADDR14.W0)←SAVEDP V' 432B5;
        ELSE DO;
            (SPEA.ADDR14.W0)←SAVEDP V' 032B5;
        ENDIF;
        SAVEDP←SPEA; POPRET;

         ENTRY STP'(),DOSYSPOP(67B);
        $SPEA←SAVEDAB; POPRET;

         ENTRY LDP'(),DOSYSPOP(66B);
        SAVEDAB←$SPEA; POPRET;

         ENTRY GCI'(),DOSYSPOP(65B);
        IF SPEA.W0>=SPEA.W1 DO;
            POPRET;
        ENDIF;
        SPEA.W0←SPEA.W0+1;
        MAKE'STRING'IAW(SPEA.W0,I);
        SAVEDA←$I; POPSKIPRET;

         ENTRY WCH'(),DOSYSPOP(64B);
        IF SPEA.W0<SPEA.W1 DO;
            SPEA.W0←SPEA.W0+1; MAKE'STRING'IAW(SPEA.W0,I); $I←SAVEDA;
            POPRET;
        ELSE DO;
            SAVEDB←SAVEDP; SAVEDP←(SPEA+2)$ADDR14-1; POPRET;
        ENDIF;


         ENTRY WCI'(),DOSYSPOP(57B);
        SPEA.W1←SPEA.W1+1;
        MAKE'STRING'IAW(SPEA.W1,I); $I←SAVEDA; POPRET;

         ENTRY GCD'(),DOSYSPOP(37B);
        IF SPEA.W0>=SPEA.W1 DO;
            POPRET;
        ENDIF;
        MAKE'STRING'IAW(SPEA.W1,I); SAVEDA←$I;
        SPEA.W1←SPEA.W1-1; POPSKIPRET;

         ENTRY WCD'(),DOSYSPOP(35B);
        MAKE'STRING'IAW(SPEA.W0,I); $I←SAVEDA;
        SPEA.W0←SPEA.W0-1; POPRET;

         ENTRY BKPT'(),DOSYSPOP(33B);
        BRS10();* EXITS TO RUN'NEXT'FORK
        END;

        PROGRAM TTY'POPS;
        INCLUDE POPVARS;
        SET'LE;
        JUMP'LE;

         ENTRY TCO'(),DOSYSPOP(75B);
        TTY'OUTPUT(SPEA.W0); POPRET;

         ENTRY TCI'(),DOSYSPOP(74B);
        SPEA.W0←SAVEDA←TTY'INPUT(); POPRET;
        END;

        PROGRAM TTY'FCNS;
        INCLUDE EMDECS;
        DI I,J,K;

         FUNCTION BRS11();
* P7.5 ARGUMENTS:  X=TELETYPE NUMBER
* RESULT:  READ ALL CHARACTERS IN THE INPUT AND DISCARD THEM
         CHECK'TTY'NO(SAVEDX);
        SET'CIOS'FIELD(-1,'ICC',0//SYSERR);
        RETURN;

         FUNCTION BRS13();
* P7.5 ARGUMENT:  X=TELETYPE NUMBER
* RESULT:  SKIP IF INPUT BUFFER EMPTY
         CHECK'TTY'NO(SAVEDX);
        START'OUTPUT(-1,QUIT'FLAG//BRS13'QUIT:ERRSPEC);
        SKIP IF READ'CIOS'FIELD(-1,'ICC'//SYSERR)=0; RETURN;
BRS13'QUIT:DSYSERR IF ERRCODE#'QIT';
        QUIT'FLAG←-1;
        QUIT();

         FUNCTION BRS14();
* P7.5 ARGUMENT:  X=TELETYPE NUMBER
* RESULT:  BLOCK UNTIL OUTPUT BUFFER EMPTY
         CHECK'TTY'NO(SAVEDX);
        WAIT'OB'EMPTY(-1,QUIT'FLAG//WOBE'QUIT:ERRSPEC);
        RETURN;
WOBE'QUIT:DSYSERR IF ERRCODE#'QIT';
        QUIT'FLAG←-1;
        RETURN;

         FUNCTION BRS29();
* P7.5 ARGUMENT:  X=TELETYPE NUMBER
* RESULT:  EMPTIES OUTPUT BUFFER
         CHECK'TTY'NO(SAVEDX);
        SET'CIOS'FIELD(-1,'OCC',0//SYSERR);
        RETURN;
        END;

        PROGRAM TTY'IO;
        INCLUDE EMDECS;
        DI I,J,K,CT;
        FUNCTION TTY'INPUT();
* CHECK TO SEE IF THERE IS AN ACTIVE COMMAND FILE OPEN.
        IF COMMAND'FILE'NO#0 DO;
           I←CWIO(COMMAND'FILE'NO,0,CSIZE8);
           TTY'OUTPUT(I);
        ELSE DO;
* READ ONE CHARACTER FROM THE TELETYPE AND RETURN IT
           IF TTYIN'8=0 DO;
              SET'ECHO'MODE(NEW'ECHO);
* TAKE CARE OF CARRIAGE RETURN
              FIXUP'PENDING'CR() IF CR'FLAG=2;
              CR'FLAG←0;
              I←READ'CHAR(-1,QUIT'FLAG//TTY'IN'QUIT:ERRSPEC);
* CHECK FOR NL AND LF
              IF I=FE'NEWLINE DO;
                  I←155B; CR'FLAG←1;
              ELSEIF I=FE'LINEFEED DO;
                  I←152B;
              ENDIF;
              TTY'OUTPUT(I) IF TOUT'FILE'NO>2;
              RETURN I A' 177B;
          ELSE DO;
              I←READ'CHAR(-1,QUIT'FLAG//TTY'IN'QUIT:ERRSPEC);
              IF I#TTYIN'8 DO;
                 TTY'OUTPUT(I) IF TOUT'FILE'NO>2;
                 RETURN;
              ENDIF;
              NEW'ECHO←0;
          ENDIF;
        ENDIF;
        TTY'OUTPUT(I) IF (TOUT'FILE'NO>2 AND COMMAND'FILE'NO=0);
        RETURN I;
TTY'IN'QUIT:DSYSERR IF ERRCODE#'QIT';
        QUIT'FLAG←-1;
        QUIT();

        FUNCTION TTY'OUTPUT(I);
* SEE IF THERE IS A TOUT FILE OPEN.
        IF TOUT'FILE'NO#1 DO;
           CWIO(TOUT'FILE'NO,I,CSIZE8);
           RETURN I;
        ELSE DO;
          K←I; I←I A' 177B; CT←0;
* WRITE THE CHARACTER I ON THE TELETYPE
           GOTO L0 IF TTYOUT'8;
          IF CR'FLAG=1 DO;
              GOTO L1 IF I=152B;
              RETURN K IF I=155B;
          ENDIF;
          IF CR'FLAG=2 DO;
              IF I=152B DO;
                  I←FE'NEWLINE;
                  GOTO L0;
              ELSE DO;
                  FIXUP'PENDING'CR();
              ENDIF;
          ENDIF;
          IF MB'FLAG DO;
              CT←I A' 377B;
MORE:         I←(277B IF CT>77B ELSE 200B+CT);
              CT←CT-77B;
          ELSEIF I=155B DO;
              CR'FLAG←2; RETURN K;
          ELSEIF I=152B DO;
              I←FE'LINEFEED;
          ELSEIF I=135B DO;
              MB'FLAG←1; RETURN K;
          ELSEIF I>=140B DO;
              I←I V' 200B;
          ENDIF;
L0:       PRINT'CHAR(-1,I,0//L0'QUIT:I,ERRSPEC);
          GOTO MORE IF CT>0;
L1:       CR'FLAG←MB'FLAG←0; RETURN K;
L0'QUIT:  DSYSERR IF ERRCODE#'QIT';
          QUIT'FLAG←-1;
          GOTO L0;
        ENDIF;

         FUNCTION CHECK'TTY'NO(I);
        RETURN IF (I=-1 OR I=LINE'NUMBER);
        TRAP;

         FUNCTION FIXUP'PENDING'CR();
        I←355B;
FIX'CR: PRINT'CHAR(-1,I,0//FIX'CR'QUIT:I,ERRSPEC);
        START'OUTPUT(-1,0//FIX'CR'QUIT:ERRSPEC);
        RETURN;
FIX'CR'QUIT:DSYSERR IF ERRCODE#'QIT';
        QUIT'FLAG←-1;
        GOTO FIX'CR;
        END;

        PROGRAM CWIO'FCNS;
        INCLUDE EMDECS;
        DI I,J;
        DECLARE EXTERNAL TTY'INPUT,TTY'OUTPUT;

* TAKE CARE OF C/WIO FOR FILES AND CALL THE PROPER ROUTINES TO DO
* IT FOR TELETYPES.  THIS FUNCTION IS AN INTERNAL VERSION OF THE CIO/
* WIO POPS.  IT EXISTS FOR THE CONVENIENCE OF THE FILE'OPENING AND
* BRS37 OPERATION.

         FUNCTION CWIO(F,DATA,CHAR'SIZE);
        GOTO NOT'FILE IF F<=2;
* FOR DRUM FILE. CHECK IT
         CHECK'S'ACCESS(F,CHAR'SIZE:F,I);
        IF I=0 DO;
* INPUT
WIO'RRETRY:  .ISD F.SEQ'PTR, BEQ WIO'RFAIL;
            DATA←$(F.SEQ'PTR);
            RETURN DATA;
* READ FAILED.  IS THIS END-OF-FILE
WIO'RFAIL:   IF J←GET'SEQ'PTR(F,0)=F.FILE'LENGTH DO;
* YES
                 SPEA.EOFBIT←SPEA.ABENDBIT←1;
                INTERRUPT(RUNNING'FORK,4,0);
                PUT'IN'MAP(RUNNING'FORK);
                RETURN (EOFWORD IF F.SEQ'PTR'CSIZE#CSIZE8 ELSE EOFCHAR);
            ENDIF;
* NOT END-OF-FILE.  MOVE TO NEXT BLOCK
             GET'BLOCK(F,J,1,0);
            GOTO WIO'RRETRY;
        ELSE DO;
* OUTPUT
WIO'WRETRY:  .ISD F.SEQ'PTR; .BEQ WIO'WFAIL;
            $(F.SEQ'PTR)←DATA; RETURN DATA;
* WRITE FAILED.  MOVE TO NEXT BLOCK
WIO'WFAIL:   J←GET'SEQ'PTR(F,0);
WIO'NPRETRY:GET'BLOCK(F,J,1,1);
            GOTO WIO'WRETRY;
        ENDIF;
NOT'FILE:RETURN DATA IF F=2;
* TELETYPE I/O.
         TRAP IF CHAR'SIZE#CSIZE8;
        RETURN (TTY'INPUT() IF F=0 ELSE TTY'OUTPUT(DATA));

         FUNCTION CHAR'READ(F);
        RETURN CWIO(F,I,CSIZE8);

         FUNCTION CHAR'WRITE(DATA,F);
        CWIO(F,DATA,CSIZE8);
        RETURN;
        END;

        PROGRAM C'PEEK;
        INCLUDE EMDECS;
        DI I,J,CHAR,DATA,P'COUNTER,TEMP,TEMP1;

        FUNCTION C'PEEK(F,CHAR,P'COUNTER);

* SIMILAR TO C/WIO ABOVE.  EXISTS FOR TYMESHARE'S CIT POP ONLY.

* ILLEGAL EXCEPT FOR DRUM FILES
        TRAP IF F<=2;
        CHECK'S'ACCESS(F,CSIZE8:F,I);

* ALSO ILLEGAL UNLESS THE FILE IS OPEN FOR INPUT
        TRAP IF I#0;

* MAY HAVE TO BACK UP IN THE FILE.  SAVE OLD VALUE OF POINTER
C'P'RETRY: TEMP←F.SEQ'PTR; TEMP1←F.END'SEQ'PTR;

* GET NEXT CHAR OF FILE.  MAY FAIL IF EOF OR END OF BUFFER
        .ISD F.SEQ'PTR, BEQ C'P'FAIL;
        DATA←$(F.SEQ'PTR);
        IF DATA=CHAR DO;
           RETURN (DATA,P'COUNTER+1);
        ELSE DO;
           F.SEQ'PTR←TEMP; F.END'SEQ'PTR←TEMP1;
           RETURN (DATA,P'COUNTER);
        ENDIF;

* CAN'T GET NEXT CHAR.  MUST SEE WHAT'S WRONG
C'P'FAIL: IF J←GET'SEQ'PTR(F,0)=F.FILE'LENGTH DO;  * EOF CASE
           DATA←EOFCHAR;
           IF DATA=CHAR DO;
              SPEA.EOFBIT←SPEA.ABENDBIT←1;
              INTERRUPT(RUNNING'FORK,4,0);
              PUT'IN'MAP(RUNNING'FORK);
              RETURN (DATA,P'COUNTER+1);
           ELSE DO;
              F.SEQ'PTR←TEMP; F.END'SEQ'PTR←TEMP1;
              RETURN (DATA,P'COUNTER);
           ENDIF;

* IF NOT EOF, THEN NO ROOM IN PRESENT BUFFER.  GET ANOTHER BLOCK
        ELSE DO;
           GET'BLOCK(F,J,1,0);
           GOTO C'P'RETRY;
        ENDIF;


        END;

        PROGRAM FILE'POPS;
        INCLUDE POPVARS;
        SET'LE;
        JUMP'LE;

         FUNCTION CIO'(),DOSYSPOP(61B);
        SAVEDA←CWIO(SPEA.FILE'NO,SAVEDA,CSIZE8);
POP'RETURN:  POPRET;

         FUNCTION WIO'(),DOSYSPOP(60B);
* P9.5 ARGUMENTS:  ADDRESSES FILE, A=DATA IF OUTPUT
* RESULT:  A IS WRITTEN TO FILE ON OUTPUT, LOADED FROM FILE ON INPUT
         SAVEDA←CWIO(SPEA.FILE'NO,SAVEDA,CSIZE24);
        GOTO POP'RETURN;

         ENTRY BIO'(),DOSYSPOP(76B);
* P9.5 ARGUMENTS: X=CORE ADDRESS, A=COUNT, ADDRESSES FILE NUMBER
* RESULTS:  TRANSFERS DATA, UPDATES A AND X, REPORTS ABENDS IN FILE
* NUMBER, SKIPS IF NO ABENDS
         GOTO NO'BIO IF SPEA.FILE'NO=2;
        CHECK'S'ACCESS(SPEA.W0,CSIZE24:F,I);
        SPEA.EOFBIT←SPEA.ABENDBIT←0;
* IF INPUT, CHECK FOR END-OF-FILE DURING TRANSFER
         CNT←SAVEDA; J←GET'SEQ'PTR(F,0);
        IF I=0 AND J+CNT>F.FILE'LENGTH DO;
            SPEA.EOFBIT←SPEA.ABENDBIT←1;
            CNT←F.FILE'LENGTH-J;
        ENDIF;
* NOW DO TRANSFER
         BLOCK'TRANSFER(F,J,SAVEDX,CNT,I);
* UPDATE REGISTERS

* AND UPDATE SEQUENTIAL POINTER
         FIX'SEQ'PTR(F,J+CNT,I);
NO'BIO: SAVEDA←SAVEDX←SAVEDX+CNT;
        IF SPEA.ABENDBIT=0 DO;
            POPSKIPRET;
        ELSE DO;
            INTERRUP\(RUNNING'FORK,4,0);
            PUT'IN'MAP(RUNNING'FORK);
            GOTO POP'RETURN;
        ENDIF;

         ENTRY DWI'(),DOSYSPOP(44B);
* P10.1 ARGUMENTS:  DRUM ADDRESS IN B, FILE ADDRESSED
* RESULT:  WORD AT ADDRESS B IN FILE IS LEFT IN A.
         F←CHECK'R'ACCESS(SPEA.W0);
        GET'BLOCK(F,SAVEDB,1,0);
        SAVEDA←$(F.SEQ'PTR+1);
        GOTO POP'RETURN;

         ENTRY DWO'(),DOSYSPOP(45B);
* P10.1 ARGUMENTS:  DRUM ADDRESS IN B, WORD IN A
* RESULT:  A IS STORED INTO ADDRESS B OF FILE
         F←CHECK'R'ACCESS(SPEA.W0);
DWO'RETRY:GET'BLOCK(F,SAVEDB,1,1);
        $(F.SEQ'PTR+1)←SAVEDA;
        GOTO POP'RETURN;

         ENTRY DBI'(),DOSYSPOP(42B);
* P10.1 ARGUMENTS:  X=CORE ADDRESS, B=FILE ADDRESS, A=COUNT, ADDRESS FILE
* RESULTS:  ABX UPDATED, DATA TRANSFERRED, ABENDS REPORTED IN FILE
* NUMBER
         I←0;
DBIO:   F←CHECK'R'ACCESS(SPEA.W0);
        BLOCK'TRANSFER(F,SAVEDB,SAVEDX,SAVEDA,I);
        SAVEDX←SAVEDX+SAVEDA; SAVEDB←SAVEDB+SAVEDA;
        SAVEDA←0;
        FIX'SEQ'PTR(F,SAVEDB,I);
        GOTO POP'RETURN;

         ENTRY DBO'(),DOSYSPOP(43B);
* P10.1 SEE DBI
         I←1; GOTO DBIO;

         ENTRY RSP'(),DOSYSPOP(25B);
* THIS IS A TYMESHARE SYSPOP
         TYMESHARE'RSP(SPEA.FILE'NO);
         GOTO POP'RETURN;

         ENTRY SSP'(),DOSYSPOP(26B);
* THIS IS A TYMESHARE SYSPOP
         TYMESHARE'SSP(SPEA.FILE'NO);
         GOTO POP'RETURN;

         ENTRY RCP'(),DOSYSPOP(31B);
* THIS IS A TYMESHARE SYSPOP
         TYMESHARE'RCP(SPEA.FILE'NO);
         GOTO POP'RETURN;

         ENTRY SCP'(),DOSYSPOP(32B);
* THIS IS A TYMESHARE SYSPOP
         TYMESHARE'SCP(SPEA.FILE'NO);
         GOTO POP'RETURN;

         ENTRY PCE'(),DOSYSPOP(05B);
* THIS IS A TYMESHARE SYSPOP
         TYMESHARE'PCE(SPEA.FILE'NO);
         GOTO POP'RETURN;

         ENTRY CIT'(),DOSYSPOP(11B);
* THIS IS A TYMESHARE SYSPOP
         C'PEEK(SPEA.FILE'NO,SAVEDA,SAVEDP:SAVEDA,SAVEDP);
         GOTO POP'RETURN;

         END;

         PROGRAM MISC'TYME'POPS;
         INCLUDE POPVARS;
         SET'LE;
         JUMP'LE;

         ENTRY SPTR'(),DOSYSPOP(14B);
* THIS IS A TYMESHARE SYSPOP
         SAVEDA←SAVEDB←3*SPEA-1;
POP'RETURN: POPRET;

         ENTRY SKP'(),DOSYSPOP(12B);
* THIS IS A TYMESHARE SYSPOP
         SAVEDP←SAVEDP+1 IF $SPEA>=0;
         GOTO POP'RETURN;

         ENTRY SKL'(),DOSYSPOP(13B);
* THIS IS A TYMESHARE SYSPOP
         SAVEDP←SAVEDP+1 IF SAVEDA<$SPEA;
         GOTO POP'RETURN;

         ENTRY SNE'(),DOSYSPOP(10B);
* THIS IS A TYMESHARE SYSPOP
         SAVEDP←SAVEDP+1 IF SAVEDA#$SPEA;
         GOTO POP'RETURN;

         END;

         PROGRAM TYMESHARE'FNS;
         INCLUDE EMDECS; INCLUDE NEW'GLOBALS;
         DECLARE PARAMETER MAX'FILE'LNGTH←1B6;
         DECLARE FIELD CPOS(0:0,1),WPART(0:2,23);
         DECLARE FIELD FILE'OPTIONS(0:1,8),CURSOR(0:1,23);
         DECLARE I,J,K,F;

         FUNCTION TYMESHARE'RSP(F);
* CALLED BY RSP SYSPOP.  ADDRESSES FILE NUMBER.
* RESULT:   A= ADDRESS OF HIGHEST LCN WRITTEN +1
*           B= TOTAL PHYSICAL SIZE IN CHARACTERS
*           X= REMAINING QUOTA
         TRAP IF F<0;
         SAVEDA←0 & RETURN IF F<=2;
         F←FT'ADDR(F);
         I←GET'SEQ'PTR(F,1);
         SAVEDA←I$WPART*3+I$CPOS;
         SAVEDB←(F.FILE'LENGTH)*3;
         SAVEDX←MAX'FILE'LNGTH*3-SAVEDB;
         RETURN;

         FUNCTION TYMESHARE'SSP(F);
* CALLED BY SSP SYSPOP.  ADDRESSES FILE NUMBER.
* SUPPOSED TO SET A MAXIMUM LENGTH ON A FILE.  IN THIS SYSTEM IT
* DOES LITTLE EXCEPT TO TRUNCATE THE FILE IF THE LENGTH SPECIFIED IS
* SHORTER THAN THE CURRENT LENGTH.  DOES A SKIP RETURN NORMALLY.  WILL
* DO A NON-SKIP RETURN IF THE LENGTH SPECIFIED (IN CHARACTERS) IS LONGER
* THAN THE MAXIMUM LENGTH OF A SMALL FILE.  TRAPS ON OBVIOUS THINGS.
         TRAP IF F<=2;
         F←FT'ADDR(F);
         I←GET'SEQ'PTR(F,1);
         I←I$WPART*3+I$CPOS;           * I IS NOW CURRENT LENGTH IN CHARS
         IF SAVEDA>3*MAX'FILE'LNGTH DO;
            SAVEDA←3*MAX'FILE'LNGTH;
            SAVEDX←1;
            RETURN;
         ELSE DO;
            SAVEDP←SAVEDP+1;           * CAUSES SKIP RETURN
            RETURN IF SAVEDA>=I;       * IN THIS CASE IT DOES NOTHING
* OTHERWISE THE SPECIFIED LENGTH IS SHORTER: TRUNCATE THE FILE.
            TRUNCATE'FILE(F,(F.FILE'LENGTH←SAVEDA/3+1)$PAGE'NUMBER);
            RETURN;
         ENDIF;

         FUNCTION TYMESHARE'RCP(F);
* CALLED BY RCP SYSPOP.  ADDRESSES FILE NUMBER.
* RESULTS:   A=  READ/WRITE IN BIT 0
*                CURRENT CURSOR POSITION IN BITS 1-23
*            X=  0 OR RANDOM FILE OPTIONS IN BITS 1-8
         TRAP IF F<0;
         SAVEDA←0 & RETURN IF F<=2;
         F←FT'ADDR(F);
         I←GET'SEQ'PTR(F,1);
         SAVEDA←(I$WPART*3+I$CPOS) V' (4B7 IF F.IS'OUTPUT'FILE);
         SAVEDX$FILE'OPTIONS←0;
         RETURN;

         FUNCTION TYMESHARE'SCP(F);
* CALLED BY SCP SYSPOP.  ADDRESSES FILE NUMBER.
* ARGUMENTS:  A=  READ/WRITE IN BIT 0
*                 NEW CURSOR POSN IN BITS 1-23
* RESULTS:    SKIP RETURN IF SUCCESSFUL
*             X=  1 IF CANNOT SET R/W MODE
*                 2 IF CURSOR IS OUT OF RANGE OR POSN OK IS OFF
         SAVEDX←1 & RETURN IF F<=2;
         F←FT'ADDR(F);
         I←SAVEDA$SIGN;
         IF I=0 DO;
             SAVEDX←1 & RETURN IF F.READ'OK=0;
         ELSE DO;
             SAVEDX←1 & RETURN IF F.WRITE'OK=0;
         ENDIF;
         I←SAVEDA$CURSOR/3;
         J←SAVEDA$CURSOR MOD 3;
         SAVEDX←2 & RETURN IF (F.POS'OK=0 OR I>F.FILE'LENGTH);
MOVE'IT: SAVEDP←SAVEDP+1;              * DO A SKIP RETURN
         GET'BLOCK(F,I,1,F.WRITE'OK);
         IF J#0 DO;
             F.SEQ'PTR'CPOS←J-1;
             F.END'PTR'CPOS←2;
             F.SEQ'PTR'CSIZE←F.END'PTR'CSIZE←CSIZE8;
             F.SEQ'PTR'LWA←F.SEQ'PTR'LWA+1;
         ENDIF;
         RETURN;

         FUNCTION TYMESHARE'PCE(F);
* ERASES THE FILE FROM THE CURRENT CURSOR POSITION TO THAT SPECIFIED
* BY A REGISTER.  TYMESHARE'S VERSION WILL LEAVE THE FILE LENGTH ALONE AND
* PUT ZEROS IN THE FILE IF A IS LESS THAN THE EOF POSITION.  THIS MAKES NO
* SENSE IN THIS SYSTEM.  THUS THE FILE IS MERELY TRUNCATED TO THE CURRENT
* POSITION.  THERE ARE A NUMBER OF NON-SKIP FAILURE RETURNS (SEE BELOW).
         TRAP IF F<=2;
         F←FT'ADDR(F);
         I←GET'SEQ'PTR(F,1);
         IF F.IS'OUTPUT'FILE=0 DO;
            SAVEDX←1 & RETURN;         * MUST BE AN OUTPUT FILE
         ELSEIF F.POS'OK=0 DO;
            SAVEDX←2 & RETURN;         * MUST BE ABLE TO POSITION CURSOR
         ELSEIF SAVEDA<(I←I$WPART*3+I$CPOS) DO;
            SAVEDX←3 & RETURN;         * CANNOT ERASE IN FRONT OF CURSOR
         ELSEIF SAVEDA>F.FILE'LENGTH*3 DO;
            SAVEDX←4 & RETURN;         * CANNOT ERASE AFTER END POINT
         ELSE DO;
            TRUNCATE'FILE(F,(F.FILE'LENGTH←SAVEDA/3+1)$PAGE'NUMBER);
            I←SAVEDA$CURSOR/3;
            J←SAVEDA$CURSOR MOD 3;
            GOTO MOVE'IT;
         ENDIF;

         END;

         PROGRAM MISC'TYME'BRSS;
         INCLUDE EMDECS;
         DECLARE I,J;

         FUNCTION BRS113();
* TYMESHARE FUNCTION TO DISABLE INTERRUPTS.  WORKS ONLY FOR MAXTIM.
         REFUSE'INTS(11999,100//CAN'T);  *  MAXTIM=12000
         RETURN;
CAN'T:   TRAP;

         FUNCTION BRS114();
* TYMESHARE FUNCTION TO ENABLE INTERRUPTS.
         ALLOW'INTS();
         RETURN;

         FUNCTION BRS70();
* TYMESHARE FUNCTION TO COUNT FREE PP. IN PMT.
         I←0;
         FOR J←NCMEM+1 TO NPMTBYTES-1 DO;
            I←I+1 IF PMT'940[J]=0;
         ENDFOR;
         SAVEDA←I;
         RETURN;

         FUNCTION BRS142();
* TYMESHARE FUNCTION TO DO EXECUTIVE COMMAND.  JUST DOES A NON-SKIP
*    FAILURE RETURN.
         RETURN;

         END;

        COMMON DECDECS;
*BELOW HERE ARE FUNCTIONS TO REPLACE SPL BUILT-IN FUNCTIONS WHICH
*DO NOT EXISTS YET
*
* SHORT DECLARATION MACROS FOR SPL
*

         MACRO INT ← DECLARE INTEGER;
        MACRO PTR ← DECLARE POINTER;
        MACRO CHR ← DECLARE CHARACTER;
        MACRO   ST ← DECLARE STRING;
        MACRO   LN ← DECLARE LONG;
        MACRO LNLN ← DECLARE LONGLONG;
        MACRO   LB ← DECLARE LABEL;

         MACRO UINFL ← DECLARE INTEGER FIELD;
        MACRO SINFL ← DECLARE INTEGER SIGNED FIELD;
        MACRO PTRFL ← DECLARE POINTER FIELD;
        MACRO CHRFL ← DECLARE CHARACTER FIELD;
        MACRO   STFL ← DECLARE STRING FIELD;
        MACRO   LNFL ← DECLARE LONG FIELD;
        MACRO   FNFL ← DECLARE FUNCTION FIELD;

         MACRO INTARY ← DECLARE INTEGER ARRAY;
        MACRO PTRARY ← DECLARE POINTER ARRAY;
        MACRO CHRARY ← DECLARE CHARACTER ARRAY;
        MACRO   STARY ← DECLARE STRING ARRAY;
        MACRO   LNARY ← DECLARE LONG ARRAY;
        MACRO   LBARY ← DECLARE LABEL ARRAY;
        MACRO FLARY ← DECLARE FIELD ARRAY;
        MACRO FNARY ← DECLARE FUNCTION ARRAY;

         MACRO INTARY1 ← DECLARE INTEGER ARRAYONE;
        MACRO PTRARY1 ← DECLARE POINTER ARRAYONE;

         MACRO INTFN ← DECLARE INTEGER FUNCTION;

         MACRO ARBENT ← UNKNOWN ENTRY;
        MACRO INTENT ← INTEGER ENTRY;
        MACRO PTRENT ← POINTER ENTRY;
        MACRO CHRENT ← CHARACTER ENTRY;
        MACRO STENT ← STRING ENTRY;
        MACRO LNENT ← LONG ENTRY;
        MACRO ARYENT ← ARRAY ENTRY;

         MACRO ARBEXT ← DECLARE UNKNOWN EXTERNAL;
        MACRO INTEXT ← DECLARE INTEGER EXTERNAL;
        MACRO PTREXT ← DECLARE POINTER EXTERNAL;
        MACRO CHREXT ← DECLARE CHARACTER EXTERNAL;
        MACRO STEXT ← DECLARE STRING EXTERNAL;
        MACRO LNEXT ← DECLARE LONG EXTERNAL;
        MACRO ARYEXT ← DECLARE ARRAY EXTERNAL;

         MACRO C'(X)←;* KLUDGE FOR INTERNAL COMMENTS

         MACRO LTABLE(F) ← F$FLDWDSP+1;
        SINFL FLDWDSP(0: 13,23);

* LENGTHS OF NAMES
         INT LMN ← 4, LTY ← 1, LFN ← LMN+LTY;
        INT NBY ← 4, LNCH ← 24/NBY, NMNCH ← LMN*NBY,
         NTYCH ← LTY*NBY, NFNCH ← LFN*NBY, NCMCH ← 80;
         END;

        COMMON COMDECS; INCLUDE DECDECS;
*
* COMMON DECLARATIONS FOR CODING
*

* GENERALLY USEFUL MACROS

         MACRO PTDN(N) ← PTNO(N, 4B7, 10);
        MACRO PTON(N) ← PTNO(N, 4B7, 8);
        MACRO NAMSET(S,L,A,B) ← SETUP(S,L,A,B) & S$WP ← S$EP;
        MACRO EMPTY(S) ← LNGDES(S$RP, S$WP) <= 0;*** WP=RP OR WP=BP?
        MACRO REPEAT ← WHILE 1 DO;
        MACRO ENDRPT ← ENDFOR;
        MACRO FDISP(F) ← RUNTIME'FAILURE() IF F$FLDSTB # 0 AND
         F$FLDSIZE # 24 ELSE F$FLDWDSP;
        UINFL FLDSTB(0: 8,12), FLDSIZE(0: 3,7);

* ERROR MACROS
         MACRO NC'PUNT ← RUNTIME'FAILURE();* FOR NORMAL CALLS (EXPRESSIONS)
        MACRO LF'PUNT ← VALUE NC'PUNT;* FOR LIBRARY FUNCTIONS
        MACRO SF'PUNT ← LF'PUNT: ERCODE, ERMSNO;* FOR SYSTEM CALLS

* PARAMETRIC CHARACTER DEFINITIONS
         CHR SCHERALD ← '>' C'(/* SUB-COMMAND HERALD */),
         BELCH ← '&G' C'(/* BELL */), NULCH ← 300B C'(/* NULL */),
         NLCH ← 301B C'(/* NEW LINE */),
         SQTCH ← '&'' C'(/* SINGLE QUOTE */),
         DQTCH ← '"' C'(/* DOUBLE QUOTE */),
         SEPCH ← '-' C'(/* SEPARATOR */);

* STRING POINTER FIELDS
         UINFL BP(0) C'(/* BEGINNING */), RP(1) C'(/* READER */),
         WP(2) C'(/* WRITER */), EP(3) C'(/* END */);
* CHARACTER FIELDS
         UINFL CH0(0: 0,7), CH1(0: 8,15), CH2(0: 16,23);
* BEAD LENGTH FIELD
         UINFL LENGF(-1: 6, 23);
        END;

        PROGRAM SCOPY; INCLUDE COMDECS;
        PTR P; ST S, D; STFL A(0);

         ARBENT SCOPY(STRING @P, S), FRETURN;
        D ← P.A; P.RP←D$WP←D$RP←D$BP; GOTO L;

         ARBENT APPEND(STRING @P, S), FRETURN;
        D ← P.A;

****      CHECK STRING CHARACTER SIZES FOR COMPATABILITY
L:
        REPEAT;    WCI(GCI(S// VALUE P.WP ← D$WP & RETURN), D// FRETURN); ENDRPT;
        END;

        PROGRAM CNS; INCLUDE COMDECS;
        INT N, F, R, T, I, D; PTR P; ST S, B(25); STFL A(0);

         ARBENT CNS(N, STRING @P, F, R), FRETURN;

         S ← P.A;
        FRETURN IF R < 2 OR R > 36;
        T ← (-N IF F >= 0 AND N < 0 ELSE N);
        B$RP ← B$WP ← B$EP; I ← 0;
LP:     .LDA T; .LSHD -23; .DIV R; .STA T; .STB D;
        WCD(D +('0' IF D < 10 ELSE 'A'-10), B);
        I ← I + 1; GOTO LP IF T # 0;
        WCD('-', B) & I ← I + 1 IF F >= 0 AND N < 0;
        F ← F A' 77B;
        IF F = 0 DO;
            F ← I;
        ELSEIF F <= I DO;
            B$RP ← INCDES(B$EP, -I);
        ELSE DO;
            WCI(' ', S// FRETURN) FOR I ← I + 1 TO F;
        ENDIF;
        WCI(D, S// FRETURN)
         FOR D ← GCI(B// VALUE P.WP ← S$WP & RETURN) WHILE 1;
        END;

        PROGRAM LONG'COMPARE; INCLUDE DECDECS;
*
* COMPARE LONG VALUES
*
         PTR P, Q; INT N; UINFL W0(0);

         INTENT LONG'COMPARE(INTEGER @P, INTEGER @Q, N);

         RETURN 1 IF P[N]$W0 # Q[N] FOR N ← N - 1 BY -1 TO 0;
        RETURN 0;
        END;

        PROGRAM XIOBRSS;
        INCLUDE EMDECS;
        DI I,J,K,STRING S1,BUFFER(30);

         STRING FUNCTION C940SP(I,J);
* THIS FUNCTION CONVERTS THE 940 STRING POINTER GIVEN IN ITS ARGUMENTS
* TO A M1 STRING DESCRIPTOR (WITH BP=RP, EP=40000B+ZERO'8STR'IAW)
* WHICH IT RETURNS AS VALUE. ONLY 18 BITS OF THE 940 POINTER ARE
* EXAMINED, AND THE WORD ADDRESSES ARE TAKEN MOD 16K.
         I←I$SPTR'940;
        MAKE'STRING'IAW(I,I); I$ADDR18←I$ADDR14; S1$W0←S1$W1←I;
        J←J$SPTR'940;
        MAKE'STRING'IAW(J,J); J$ADDR18←J$ADDR14; S1$W2←J;
        S1$W3←40000B+ZERO'8STR'IAW; RETURN S1;

         FUNCTION BRS33();
* P14.4 ARGUMENTS:  A=STRING POINTER ADDRESS, B=TERMINAL CHARACTER,
* X=FILE
* RESULT:  READS CHARACTERS FROM THE FILE INTO THE STRING UNTIL THE
* TERMINAL CHARACTER IS READ.  IT IS NOT WRITTEN, AND THE POINTER TO
* THE ENLARGED STRING IS LEFT.
         I←SAVEDA$ADDR14; I.W1←I.W0 IF SAVEDA<0;
        S1← C940SP(I.W0,I.W1);
        J←0;
        FOR K←CHAR'READ(SAVEDX) WHILE K#SAVEDB DO;
            WCI(K,S1// VALUE TRAP);
            J←J+1;
        ENDFOR;
        SAVEDA←I.W0; SAVEDB←I.W1+J; RETURN;


         FUNCTION BRS34();
* P14.4 ARGUMENTS:  A=WORD ADDRESS, B=COUNT OR -1, X=FILE NUMBER
* RESULT:  ABX UNCHANGED.  OUTPUT THE SPECIFIED NUMBER OF CHARACTERS
* (OR UNTIL A $ IF B=-1; IN THIS CASE INTERPRET / AS NEWLINE).
         SETUP(S1,SAVEDB IF J←SAVEDB>=0 ELSE 10000,SAVEDA$ADDR14);
        S1$W2←S1$W3;
BRS34L: I←GCI(S1// RETURN);
        IF J <0 DO;
            RETURN IF I='/';
            IF I='$' DO;
                CHAR'WRITE(CARRIAGE'RETURN,SAVEDX);
                I←LINE'FEED;
            ENDIF;
        ENDIF;
        CHAR'WRITE (I,SAVEDX); QUIT() IF QUIT'FLAG#0; GOTO BRS34L;
        QUIT() IF QUIT'FLAG#0;


         FUNCTION BRS35();
* P14.4 ARGUMENTS:  AB=STRING POINTER, X=FILE NUMBER.
* RESULT:  OUTPUT THE STRING
         S1←C940SP(SAVEDA,SAVEDB); J←0; GOTO BRS34L;

         FUNCTION BRS36();
* P13.1 ARGUMENTS:  A=NUMBER TO OUTPUT, B=RADIX (+SIGN BIT FLAG),
* X=FILE NUMBER.  RADIX MUST BE <=16 AND >=2.
* RESULT:  A IS OUTPUT IN THE SPECIFIED RADIX, UNSIGNED UNLESS
* B<0.
         I←SAVEDB$ADDR14;
        TRAP IF (I<2 OR I>16);
        SETS(BUFFER);
        CNS(SAVEDA,BUFFER,N' SAVEDB A' 1@SIGN,I// VALUE TRAP);
        S1←BUFFER; J←0; GOTO BRS34L;

         FUNCTION BRS38();
* P13.1 ARGUMENTS:  B=RADIX (MUST BE <=16), X=FILE
* RESULTS:  A=NUMBER READ (POSSIBLY SIGNED), B=TERMINAL CHARACTER
* (+4B7 IF NO NUMERIC CHARACTERS WERE READ).
         TRAP IF (SAVEDB$ADDR14<2 OR SAVEDB$ADDR14>16);
        K←0;
        I←CHAR'READ(SAVEDX);
        IF I='+' OR I='-' DO;
            K←1 IF I='-';
            I←CHAR'READ(SAVEDX);
        ENDIF;
        SAVEDA←0; J←0;
        WHILE I>='0' AND I<'0'+SAVEDB$ADDR14 DO;
            SAVEDA←SAVEDA*SAVEDB$ADDR14+I-'0'; J←J+1;
            I←CHAR'READ(SAVEDX);
        ENDFOR;
        SAVEDA←-SAVEDA IF K;
        SAVEDB←I; SAVEDB$SIGN←1 IF J=0; RETURN;
        END;

        PROGRAM FILE'BRSS;
        INCLUDE EMDECS;
        DI I,F;

         FUNCTION BRS17();
* P9.4 ARGUMENTS:  NONE
* RESULT:  CLOSE ALL FILES
         FOR I←MIN'FILE TO MAX'FILE DO;
            CLOSE'940'FILE(@FILE'TABLE[I]);
        ENDFOR;
        BSET(@FILE'TABLE[0],0,(MAX'FILE+1)*L'FT'ENTRY);
        RETURN;

         FUNCTION BRS20();
* P9.4 ARGUMENTS:  A=FILE NUMBER
* RESULT:  CLOSE THIS FILE
         RETURN IF F←SAVEDA$FILE'NO<MIN'FILE; F←@FILE'TABLE[F];
        CLOSE'940'FILE(F);
        RETURN;

         FUNCTION BRS66();
* P9.6 ARGUMENT:  A=FILE NUMBER
* RESULT:  THE CONTENTS OF A IS DELETED IF THERE IS WRITE ACCESS TO IT
         TRAP IF (F←FT'ADDR(SAVEDA)).WRITE'OK=0;
        CLEAR'FILE(F);
        F.FILE'LENGTH←0 IF F.IS'OUTPUT'FILE;
        RETURN;

         FUNCTION BRS110();
* P9.8 ARGUMENT:  A=FILE NUMBER
* RESULT:  X AND A AS INDICATED
         F←@FILE'TABLE[SAVEDA$FILE'NO];
        IF F.FT'ENTRY'ACTIVE=0 DO;
            SAVEDA←SAVEDX←0;
        ELSEIF SAVEDA$FILE'NO<MIN'FILE DO;
            SAVEDA←0;
            SAVEDX←FILE'DEV'NAME[SAVEDA$FILE'NO];
        ELSE DO;
            SAVEDA←927;
            SAVEDX←'FIL';
        ENDIF;
        RETURN;

         FUNCTION BRS115();
* P X.X ARGUMENTS:  NONE
* RESULT:  SKIPS IF NO FILES OPEN
         FOR I←MIN'FILE TO MAX'FILE DO;
            RETURN IF FILE'TABLE[I]$FT'ENTRY'ACTIVE;
        ENDFOR;
        SKIP; RETURN;

        FUNCTION BRS77();
* TYMESHARE FUNCTION TO CLOSE PRESENT TOUT FILE AND REPLACE W/ NEW
*    NUMBER IN A.  RETURNS OLD TOUT FILE NUMBER.
        TRAP IF (SAVEDA<2 AND SAVEDA#1);
        CLOSE'940'FILE(@FILE'TABLE[F]) IF F←TOUT'FILE'NO>2;
        TOUT'FILE'NO←SAVEDA;
        SAVEDA←F;
        RETURN;

        FUNCTION BRS151();
* TYMESHARE FUNCTION TO CLOSE PRESENT COMMANDS FILE IF >2 AND REPLACE
*    WITH NEW FILE NUMBER FROM A.
        TRAP IF (SAVEDA<2 AND SAVEDA#0);
        CLOSE'940'FILE(@FILE'TABLE[F]) IF F←COMMAND'FILE'NO>2;
        COMMAND'FILE'NO←SAVEDA;
        RETURN;

        FUNCTION BRS181();
* TYMESHARE FUNCTION TO CLOSE ANY OPEN COMMAND AND TOUT FILES.
        CLOSE'940'FILE(@FILE'TABLE[F]) IF F←COMMAND'FILE'NO>2;
        CLOSE'940'FILE(@FILE'TABLE[F]) IF F←TOUT'FILE'NO>2;
        COMMAND'FILE'NO←SAVEDA←0;
        TOUT'FILE'NO←SAVEDB←1;
        RETURN;

        FUNCTION BRS153();
* TYMESHARE FUNCTION TO CLOSE ANY OPEN FILES EXCEPT COMMAND AND TOUT
*    FILES.
        FOR I←MIN'FILE TO MAX'FILE DO;
           IF (I#COMMAND'FILE'NO AND I#TOUT'FILE'NO) DO;
              CLOSE'940'FILE(@FILE'TABLE[I]);
              BSET(@FILE'TABLE[I],0,L'FT'ENTRY);
           ENDIF;
        ENDFOR;
        RETURN;

        FUNCTION BRS67();
* IMPLEMENTED TO SUPPLANT BRS OF SAME NO. IN XFORTRAN FOR TYMESHARE.
*   TYMESHARE'S READS ARBITRARY INFO FROM CONTEXT BLOCK.
*   THIS ONE JUST READS COMMAND & TOUT FILE NOS. INTO AB.
        SAVEDA←COMMAND'FILE'NO;
        SAVEDB←TOUT'FILE'NO;
        RETURN;

        END;

        PROGRAM FILE'AUX'FCNS1;
        INCLUDE EMDECS;
        DI I,J;

         FUNCTION TRUNCATE'FILE(F,I);
* DELETE ALL DATA BLOCKS IN FILE
         FOR I←NEXT'FILE'PAGE(F.M1'FILE'NO,I//SYSERR) WHILE I#-1 DO;
            DELETE'FILE'PAGE(F.M1'FILE'NO,I//SYSERR);
        ENDFOR;
        RETURN;

         FUNCTION CLEAR'FILE(F);
        TRUNCATE'FILE(F,-1);
        F.PAGE'IN'BUFFER←-1; F.SEQ'PTR'LWA←(F.BUFFER'PAGE)@PAGE'NUMBER
        +(PAGE'SIZE-1);
        RETURN;

         FUNCTION CLOSE'940'FILE(F);
* CLOSE THE FILE WITH FT ENTRY J.  RELEASE ITS BUFFER BYTE
         RETURN IF F.FT'ENTRY'ACTIVE=0;
        IF F=NRH'FILE DO;
            FOR I←0 TO NO'NRH'BUFS DO;
                DELPMT(NRH'BUF'BYTE[I]//SYSERR);
            ENDFOR;
        ELSE DO;
            DELPMT(F.BUFFER'BYTE//SYSERR);
        ENDIF;
        IF F.WRITE'OK DO; * FILE IS AN OUTPUT FILE;
            IF F.POS'OK DO; * FILE IS RANDOM;
                I←F.FILE'LENGTH;
                I←0 IF I<0; J←I$PAGE'NUMBER;
                IF NEXT'FILE'PAGE (F.M1'FILE'NO,J-1//SYSERR)#J DO;
                    CREATE'FILE'PAGE(F.M1'FILE'NO,J//SYSERR)
                      IF I$WORD'ADDRESS#0;
                ENDIF;
            ELSE DO; * FILE IS SEQUENTIAL;
                F.FILE'LENGTH←GET'SEQ'PTR(F,0);
                TRUNCATE'FILE(F,F.PAGE'IN'BUFFER);
                I←F.FILE'LENGTH;
                I←0 IF I<0; J←I$PAGE'NUMBER;
            ENDIF;
* SET LOWER 11 BITS OF M1 LENGTH FROM 940 LENGTH
            SET'FILE'LENGTH(F.M1'FILE'NO,I-1//SYSERR);
        ENDIF;
        CLOSE'FILE(F.M1'FILE'NO//SYSERR);
        F.FT'ENTRY'ACTIVE←0; RETURN;

         FUNCTION CHECK'R'ACCESS(F);
* CHECK RANDOM ACCESS FOR FILE NUMBER IN F AND RETURN POINTER TO FILE
* TABLE ENTRY, TRAP ON ERRORS.
         TRAP IF (F←FT'ADDR(F)).POS'OK=0; RETURN F;

         FUNCTION FT'ADDR(F);
        F←@FILE'TABLE[F$FILE'NO];
        TRAP IF F.FT'ENTRY'ACTIVE=0 ELSE RETURN F;


         FUNCTION GET'SEQ'PTR(F,CPOSF);
* RETURN CURRENT SEQUENTIAL WORD POINTER TO F
         RETURN 0 IF F.PAGE'IN'BUFFER=-1;
        I←(F.PAGE'IN'BUFFER-F.BUFFER'PAGE)@PAGE'NUMBER+F.SEQ'PTR'LWA+1;
        IF CPOSF=1 AND F.SEQ'PTR'CSIZE=CSIZE8 AND (J←F.SEQ'PTR'CPOS#2) DO;
            I$SEQ'PTR'CHAR'POS←J+1;
            I←I-1;
        ENDIF;
        RETURN I;

         FUNCTION BRS144'WORD();
* RETURNS THE 'NEXT' WORD DEFINED BY A AND B
* IF B<0, RETURN $A AND INCREMENT A
* OTHERWISE, RETURN A
         IF SAVEDB<0 DO;
            I←SAVEDA$ADDR14; SAVEDA←SAVEDA+1; RETURN I.W0;
        ELSE DO;
            RETURN SAVEDA;
        ENDIF;

         FUNCTION BRS143'WORD(J);
* INVERT THE OPERATION OF BRS144'WORD
         IF SAVEDB<0 DO;
            I←SAVEDA$ADDR14; SAVEDA←SAVEDA+1; $I←J; RETURN;
        ELSE DO;
            SAVEDA←J; RETURN;
        ENDIF;

         FUNCTION CHECK'BRS1434();
        TRAP IF SAVEDB$THINGY'TYPE#1 OR SAVEDB$ATTRIBUTE<1 OR SAVEDB
         $ATTRIBUTE>8;
        RETURN FT'ADDR(SAVEDX);

         FUNCTION SETUP'DUAL'FILE(DF'NO);
        DF'INPUT←DF'NO$DF'IN;
        DF'OUTPUT←(1 IF DF'NO=0 ELSE DF'NO$DF'OUT);
        RETURN;
        END;

        PROGRAM FILE'AUX'FCNS2;
        INCLUDE EMDECS; INCLUDE NEW'GLOBALS;

         FUNCTION CHECK'S'ACCESS(F,CHAR'SIZE);
* CHECK SEQUENTIAL ACCESS.  RETURN POINTER TO FT ENTRY AND WRITE'FLAG
* SET CHARACTER SIZE APPROPRIATELY
         F←FT'ADDR(F);
        TRAP IF F.IS'SEQ'FILE=0;
        IF F.SEQ'PTR'CSIZE#CHAR'SIZE DO;
            IF F.SEQ'PTR'CSIZE=CSIZE8 DO;
                WHILE F.SEQ'PTR'CPOS<2 DO;
                    .ISD F.SEQ'PTR;
                    $(F.SEQ'PTR)←NULLCH;
                ENDFOR;
            ENDIF;
            F.SEQ'PTR'CSIZE←F.END'PTR'CSIZE←CHAR'SIZE;
            F.SEQ'PTR'CPOS←F.END'PTR'CPOS←3-CHAR'SIZE;
        ENDIF;
        RETURN (F,F.IS'OUTPUT'FILE);
        END;

        PROGRAM FILE'BLOCK'FCNS;
        INCLUDE EMDECS;
        DI I,J,K;

         FUNCTION GET'BLOCK(F,I,SPF,CPF);
* GET THE PAGE OF F CONTAINING THE WORD ADDRESSED BY I INTO THE
* BUFFER. IF PAGE DOESN'T EXIST, MAKE IT IF CPF=1 ELSE TRAP.  
* SET THE SEQUENTIAL POINTER TO I IF SPF=1 (CHAR SIZE=24 UNLESS IT WAS
* 8 BEFORE).  TRAP IF I>FILE LENGTH.
         TRAP IF CPF=0 AND F.READ'OK=0 OR CPF=1 AND F.WRITE'OK=0;
        IF CPF=0 AND (F.WRITE'OK=0 OR F.POS'OK=0) DO;
            TRAP IF I>=F.FILE'LENGTH;
        ELSE DO;
            F.FILE'LENGTH←(I$PAGE'NUMBER+1)@PAGE'NUMBER IF
             F.FILE'LENGTH$PAGE'NUMBER<=I$PAGE'NUMBER;
        ENDIF;
        J←I$PAGE'NUMBER;
        IF F=NRH'FILE DO;
            FOR K←0 TO NO'NRH'BUFS DO;
                IF NRH'PAGE'IN'BUF[K]=J DO;
                    F.BUFFER'BYTE←NRH'BUF'BYTE[K];
                    F.BUFFER'PAGE←NRH'BUF'BASE+K;
                    F.PAGE'IN'BUFFER←J;
                    GOTO GOT'PAGE;
                ENDIF;
            ENDFOR;
            NEXT'NRH'BUF←(NEXT'NRH'BUF+1 IF NEXT'NRH'BUF<NO'NRH'BUFS
             ELSE 0);
            F.BUFFER'BYTE←NRH'BUF'BYTE[NEXT'NRH'BUF];
            F.BUFFER'PAGE←NRH'BUF'BASE+NEXT'NRH'BUF;
            F.PAGE'IN'BUFFER←-1;
            NRH'PAGE'IN'BUF[NEXT'NRH'BUF]←J;
        ENDIF;
        IF F.PAGE'IN'BUFFER#J DO;
* NEED TO CHANGE BUFFER CONTENTS.  CHECK THAT REQUIRED FILE PAGE
* EXISTS
             IF NEXT'FILE'PAGE(F.M1'FILE'NO,J-1//SYSERR)#J DO;
                TRAP IF CPF=0 AND (F.WRITE'OK=0 OR F.POS'OK=0);
* CREATE THE PAGE
                 CREATE'FILE'PAGE(F.M1'FILE'NO,J//SYSERR);
            ENDIF;
* FILE PAGE EXISTS.  CLEAR THE PMT BYTE USED FOR THE BUFFER
             CLRPMT(F.BUFFER'BYTE//SYSERR);
* AND PUT IN THE FILE PAGE
             PUT'PAGE'IN'PMT(F.M1'FILE'NO,J,F.BUFFER'BYTE//SYSERR);
            F.PAGE'IN'BUFFER←J;
        ENDIF;
GOT'PAGE:RETURN IF SPF=0;
        K←(F.BUFFER'PAGE)@PAGE'NUMBER-1;
        IF F.SEQ'PTR'CSIZE#CSIZE8 DO;
            F.SEQ'PTR←ZERO'24STR'IAW+K+I$WORD'ADDRESS;
            F.END'SEQ'PTR←ZERO'24STR'IAW+K+PAGE'SIZE;
        ELSE DO;
            F.SEQ'PTR←TWO'8STR'IAW+K+I$WORD'ADDRESS;
            F.END'SEQ'PTR←TWO'8STR'IAW+K+PAGE'SIZE;
        ENDIF;
        RETURN IF F.WRITE'OK OR F.FILE'LENGTH>=(J+1)@PAGE'NUMBER;
* INPUT FILE WITH LENGTH FALLING IN THIS BLOCK.
* SET EP TO FILE LENGTH
         F.END'SEQ'PTR←F.END'SEQ'PTR+(F.FILE'LENGTH$WORD'ADDRESS-PAGE'SIZE);
        RETURN;
        FUNCTION BLOCK'TRANSFER(F,FA,CA,CNT,WF);
* THIS FUNCTION DOES A BLOCK TRANSFER OF CNT WORDS STARTING AT FA IN
* FILE F AND AT CA IN CORE.  IF WF IS ON, DATA IS WRITTEN FROM CORE TO
* THE FILE, OTHERWISE IT IS READ FROM THE FILE TO CORE.  AN ATTEMPT
* TO ACCESS MISSING BLOCKS ON INPUT CAUSES A TRAP.  ON OUTPUT THE
* BLOCKS ARE CREATED.  THE SEQUENTIAL POINTER IS NOT SET.

* THE MAIN LOOP PROCEEDS AS FOLLOWS.  GET THE BLOCK ADDRESSED BY FA.
* MOVE WHATEVER PART OF THE DATA IS IN THIS BLOCK.  EXIT IF DONE,
* OTHERWISE UPDATE FA,CA,CNT AND LOOP
         CA←CA$ADDR14;
        TRAP IF CNT<0 OR CA+CNT>4B4;
        FOR CNT←CNT,CNT-I WHILE CNT>0 DO;
            GET'BLOCK(F,FA,0,WF);
            I←PAGE'SIZE-FA$WORD'ADDRESS;
            I←CNT IF I>CNT;
            J←FA;
            J$PAGE'NUMBER←F.BUFFER'PAGE;
            BCOPY(J IF WF ELSE CA, CA IF WF ELSE J,I);
            FA←FA+I; CA←CA+I;
        ENDFOR;
        RETURN;

         FUNCTION FIX'SEQ'PTR(F,I,CPF);
        IF I=0 OR I$WORD'ADDRESS#0 AND (CPF=1 OR I<F.FILE'LENGTH) DO;
            GET'BLOCK(F,I,1,CPF);
        ELSE DO;
            GET'BLOCK(F,I-1,1,CPF);
            F.SEQ'PTR←F.SEQ'PTR+1;
        ENDIF;
        RETURN;
        END;

        PROGRAM MEM'BRSS;
        INCLUDE EMDECS;
        DI I,J,K,L,M,F,STRING S1;
        DF RO'PAGE(0:3,3),SH'PAGE(0:1,1);

         FUNCTION BRS4();
* ARGUMENTS:  ADDRESS OF PAGE TO RELEASE IN A
         I←(RUNNING'FORK.FN'MAP)$(MAP'BYTE[SAVEDA$PAGEBITS]);
        RELEASE'BYTE(I);
FIX'MAP:PUT'IN'MAP(RUNNING'FORK);
        RETURN;


         FUNCTION BRS43();
* ARGUMENTS:  NONE
* RESULT:  MAP WORDS FOR CURRENT FORK RETURNED IN AB
         SAVEDAB←RUNNING'FORK.FN'MAP; RETURN;

         FUNCTION BRS44();
* ARGUMENTS:  NEW MAP WORDS IN AB
* RESULT:  MAP IS SET TO THESE WORDS AFTER THEY ARE CHECKED FOR VALIDITY
         CHECK'MAP(SAVEDAB);
        FIX'WORKING'SET(SAVEDAB,RUNNING'FORK.FN'MAP);
        RUNNING'FORK.FN'MAP←SAVEDAB;
        FORK'IN'MAP←0; GOTO FIX'MAP;

         FUNCTION BRS59();
        RETURN IF SAVEDA<0 OR SAVEDA>NPMTBYTES-1;
        IF PMT'940[SAVEDA]=0 DO;
            SAVEDA←0;
            RETURN;
        ENDIF;
        I←377700B;
        I$RO'PAGE←1 IF RPMTRO(PMT'940[SAVEDA]$PMT'M1)=1;
        I$SH'PAGE←1 IF PMT'940[SAVEDA]$IS'SUB'BYTE;
        SAVEDA←I;
        RETURN;

         FUNCTION BRS80();
* ARGUMENTS:  A(18,23) IS A BYTE NUMBER, A(0) IS SET TO MAKE THE BLOCK
* READ-ONLY, CLEAR TO MAKE IT READ-WRITE
* RESULT:  THE BYTE IS CHECKED TO MAKE SURE IT IS A 940 BYTE.  THEN
* THE PMTRO BIT IS SET OR CLEARED ACCORDING TO A0
         CHECK'BYTE(SAVEDA$BYTENO);
        I←PMT'940[SAVEDA$BYTENO];
        J←RPMTRO(I$PMT'M1);
        IF I$IS'SUB'BYTE# 0 AND SAVEDA$SIGN=0 DO;
            TRAP;
        ENDIF;
        SPMTRO(I$PMT'M1,SAVEDA$SIGN//BRS80E:ERRSPEC);
        SAVEDA$SIGN←J;
        RETURN;
* BRS80 ERROR. TRAP IF TRYING TO MAKE A RO PAGE RW, OTHERWISE SYSERR
BRS80E:  DSYSERR IF ERRCODE#'FPR' ELSE TRAP;

         FUNCTION BRS100();
*GETS A MAP AND A STARTING ADDRESS FOR A SUBSYSTEM
         TRAP IF SAVEDA#0 OR SAVEDX#-1;
        I←SAVEDB$ADDR14;
        S1←C940SP(I.W0,I.W1);
        GET'FILE(S1,SUBSYSTEM'FILE,0,'RO'// VALUE TRAP);
        READ'SUBSYSTEM(:SAVEDAB,SAVEDX,SUB'SYS'CWS,SUB'SYS'DWS);
        FOR I←0 TO 7 DO;
            J←SAVEDAB$(MAP'BYTE[I]);
            BYTE'OWNER[J]←RUNNING'FORK IF PMT'940[J]#0;
        ENDFOR;
        SKIP;
*REMOVE FILE BUFFER
         DELPMT(BUF'BYTE//SYSERR);
        CLOSE'FILE(BUF'FILE'NO//SYSERR);
        RETURN;

         FUNCTION PLACE'FILE'PAGES();
        F←FT'ADDR(SAVEDX);
        J←(SAVEDB-1 IF SAVEDB<=8 ELSE 7);
        K←(SAVEDA IF SAVEDA>=0 ELSE 0);
        SAVEDAB←LONGZERO;
        FOR I←0 TO J DO;
            IF NEXT'FILE'PAGE(F.M1'FILE'NO,K-1//SYSERR)=K DO;
                GET'MAP'BYTE(0:L,M);
                PUT'PAGE'IN'PMT(F.M1'FILE'NO,K,M//SYSERR);
                SAVEDAB$(MAP'BYTE[I])←L;
                BYTE'OWNER[L]←RUNNING'FORK;
            ENDIF;
            K←K+1;
        ENDFOR;
        SAVEDX←NEXT'FILE'PAGE(F.M1'FILE'NO,K-1//SYSERR);
        RETURN;

         FUNCTION BRS116();
* ARGUMENTS:  NONE
* RESULT:  THE USER'MAP IS RETURNED IN AB
         SAVEDAB←USER'MAP; RETURN;

         FUNCTION BRS117();
* ARGUMENTS:  NEW VALUE FOR USER MAP IN AB
* RESULT:  CHECK IT AND SET IT UP
         CHECK'MAP(SAVEDAB); USER'MAP←SAVEDAB; RETURN;

         FUNCTION BRS120();
        TRAP IF SAVEDA#0;
* ACQUIRES A BYTE
         I←ACQPMT(-1//SYSERR);
        NPPMT(I//SYSERR);
        FOR J←NCMEM+1 TO NPMTBYTES-1 DO;
            IF PMT'940[J]=0 DO;
                PMT'940[J]←I;
                BYTE'OWNER[J]←RUNNING'FORK;
                SAVEDA←J;
                SKIP;
                RETURN;
            ENDIF;
        ENDFOR;
        RETURN;

         FUNCTION BRS121();
* ARGUMENTS:  BYTE TO RELEASE IN A
* RESULT:  RELEASE IT
         RELEASE'BYTE(SAVEDA$BYTENO);   GOTO FIX'MAP;
        END;

        PROGRAM NRH'BRSS;
        INCLUDE EMDECS;

         DI I,J,WRITE'FLAG;
        DF NRH'PMT(0:5,12),BIT12(0:12,12);
        MONITOR READ'MAP'BYTE←101;
        FUNCTION OPEN'NRH'FILE(), FRETURN;
* SETS UP MIB'OBJECT'NAME FOR NRH FILE, AND OPENS IT IF NRH FILE#0.
* FRETURN IF ANY TROUBLE.
*           MIB'ADDRESS.MIB'UNDK←USER'UNDK;
         MIB'OBJECT'NAME[0]←-1;
        MIB'OBJECT'NAME[1]←0;
        MIB'OBJECT'NAME[2]←-1;
        MIB'ADDRESS.MIB'NAME←LONGLONGZERO;
*       SCOPY(MIB'NAME'STRING,PROCESS'NAME//FRETURN);
         SCOPY(MIB'NAME'STRING,NRH'NAME// FRETURN);
        MIB'ADDRESS.MIB'TYPE←6'NRH ';
        IF NRH'FILE=0 DO;
            OPEN'FILE'FCN(@NRH'FT'ENTRY[0],RW'ACCESS,0// FRETURN);
            NRH'FILE←@NRH'FT'ENTRY[0];
        ENDIF;
        RETURN;

         FUNCTION BRS7();
* RELEASE NRH,I.E., CLOSE NRH'FILE IF IT IS OPEN, AND DESTROY
* <PROCESS NAME>:NRH IF IT EXISTS.
         OPEN'NRH'FILE(//CLR'NRH);
        CLEAR'FILE(NRH'FILE);
        CLOSE'940'FILE(NRH'FILE);
CLR'NRH:NRH'FILE←0;
        RETURN;

         FUNCTION BRS124();
* ARGUMENTS:  A=CORE ADDRESS, B=DRUM ADDRESS, X=COUNT
* RESULT:  COPY THE SPECIFIED NUMBER OF WORDS FROM THE FILE ADDRESS
* IN NRH'FILE GIVEN BY B TO THE LOCATION GIVEN BY A.  THIS IS
* EXACTLY LIKE BI0 EXCEPT THAT THE BLOCK MUST EXIST AND THE FILE IS
* TAKEN FROM NRH'FILE.  SKIP RETURN
         WRITE'FLAG←0;
BRS1245:J←SAVEDB-NRH'BASE'ADDRESS;
        OPEN'NRH'FILE(// VALUE TRAP) IF NRH'FILE=0;
        IF SAVEDB>=2B7 DO;
            I←SAVEDB$NRH'PMT;
            J←SAVEDB$WORD'ADDRESS;
            SET'MAP'BYTE(-1,COPY'TO'PAGE,I//NRH'PMT'ERR:ERRSPEC);
            IF WRITE'FLAG DO;
***IS THIS RIGHT?
                 TRAP IF RPMTRO(I);
                BCOPY(COPY'TO'ADD+J,SAVEDA,SAVEDX);
            ELSE DO;
                BCOPY(SAVEDA,COPY'TO'ADD+J,SAVEDX);
            ENDIF;
            SET'MAP'BYTE(-1,COPY'TO'PAGE,0//NRH'PMT'ERR:ERRSPEC);
        ELSE DO;
            TRAP IF J A' 7B7 OR NEXT'FILE'PAGE(NRH'FILE.M1'FILE'NO,
             (I←J$PAGE'NUMBER)-1//SYSERR)#I OR I#(J+SAVEDX-1)$PAGE'NUMBER;
            BLOCK'TRANSFER(NRH'FILE,J,SAVEDA,
             SAVEDX,WRITE'FLAG);
        ENDIF;
        SKIP; RETURN;
NRH'PMT'ERR:SAVEDB←ERRNUMBER; RETURN;

         FUNCTION BRS125();
* LIKE BRS 124 BUT WRITES
         WRITE'FLAG←1; GOTO BRS1245;

         FUNCTION BRS126();
* ARGUMENTS:  NONE
* RESULT:  ASSIGNS A BLOCK IN NRH'FILE AND SKIP-RETURNS ITS (WORD)
* ADDRESS IN A.
         OPEN'NRH'FILE(// RETURN) IF NRH'FILE=0;
* FIND THE FIRST FREE PAGE, WHICH IS J+1 AFTER THIS LOOP
         I←J←-1;
        J←I FOR I←NEXT'FILE'PAGE(NRH'FILE.M1'FILE'NO,I//SYSERR) WHILE I=J+1;
* ASSIGN THE PAGE
         CREATE'FILE'PAGE(NRH'FILE.M1'FILE'NO,J+1//SYSERR);
        SAVEDA←(J+1)*PAGE'SIZE+NRH'BASE'ADDRESS;
        SKIP; RETURN;

         FUNCTION BRS127();
* RESULT: RELEASES A BLOCK IN NRH'FILE OF THE WHOSE WORD ADDRESS
* IS IN A
         OPEN'NRH'FILE(// VALUE TRAP) IF NRH'FILE=0;
        I←(SAVEDA-NRH'BASE'ADDRESS)$PAGE'NUMBER;
        TRAP IF NEXT'FILE'PAGE(NRH'FILE.M1'FILE'NO,I-1//SYSERR)#I;
        DELETE'FILE'PAGE(NRH'FILE.M1'FILE'NO,I//SYSERR);
        IF NRH'FILE.PAGE'IN'BUFFER=I DO;
            NRH'FILE.PAGE'IN'BUFFER←-1;
            NRH'PAGE'IN'BUF[NRH'FILE.BUFFER'PAGE-NRH'BUF'BASE]←-1;
        ENDIF;
        RETURN;

*READ DRUM ASSIGNMENT  JUST REPORT A CONSTANT 100B
         FUNCTION BRS130();
        SAVEDA←100B;
        RETURN;
        END;

        PROGRAM MAP'AUX'FCNS;
        INCLUDE EMDECS;
        DI I,J,FORK,MAP;

         FUNCTION CHECK'MAP (LONG MAP'WORDS);
* THIS FUNCTION TRAPS UNLESS ALL THE BYTES OF THE ARGUMENT HAVE OWNERS
* IN THE CURRENT JOB
         FOR I←0 TO 7 DO;
            J←MAP'WORDS$(MAP'BYTE[I]);
            CHECK'BYTE(J);
        ENDFOR;
        RETURN;

         FUNCTION CHECK'BYTE(BYTE);
* TRAP IF THE BYTE DOES NOT HAVE AN OWNER
         RETURN IF BYTE=0;
        TRAP IF BYTE'OWNER[BYTE]=0;
        RETURN;

         FUNCTION RELEASE'BYTE(BYTE);
* THIS FUNCTION SCANS THE MAPS FOR ALL FORK AND ZEROS ANY BYTE WHICH IS
* EQUAL TO THE ARGUMENT.  IT THEN DESTROYS THE PMT ENTRY ADDRESSED BY
* BYTE.
         RETURN IF BYTE=0;
        FOR I←0 TO NFORKS-1 DO;
            FORK←@(FORK'NODES[I]);
            MAP←@(FORK.FN'MAP);
            FOR J←0 TO 7 DO;
                IF MAP.(MAP'BYTE[J])=BYTE DO;
                    MAP.(MAP'BYTE[J])←0;
                    FORK'IN'MAP←0 IF FORK=RUNNING'FORK;
                ENDIF;
            ENDFOR;
        ENDFOR;
* CALL THE MONITOR TO FREE THE BYTE. IGNORE ANY FAILURE
* CONDITION
         DELPMT(PMT'940[BYTE]$PMT'M1// RETURN);
        PMT'940[BYTE]←0; BYTE'OWNER[BYTE]←0; RETURN;
        END;

        PROGRAM BRS1434;
        INCLUDE EMDECS; INCLUDE NEW'GLOBALS;
        DECLARE I,J,K,F;
        DECLARE EXTERNAL BRS144'WORD;

         DECLARE LABEL ARRAY BRS143'DISPATCH[8]←
         (READ'PTR,READ'LENGTH,READ'SEQIO'MODE,
         READ'CAPS,READ'BLOCK'SIZE,READ'USER'WORDS,READ'STRUCTURE,
         COUNT'DATA);
        DECLARE LABEL ARRAY BRS144'DISPATCH[8]←
         (SET'PTR,SET'LENGTH,SET'SEQIO'MODE,
         SET'CAPS,SET'BLOCK'SIZE,TRAP'BRS144,SET'STRUCTURE,TRAP'BRS144);

         FUNCTION BRS143();
* P9.2 ARGUMENTS:  A=TABLE ADDRESS IF B<0 ELSE DATA WORD
*                  B=(1,11) TYPE OF THINGY, MUST BE 1, (12,27)
*                   ATTRIBUTE INDEXES ABOVE DISPATCH TABLES
*                  X=FILE NUMBER
* RESULT:  THE SPECIFIED DATA IS READ
         F←CHECK'BRS1434();
        GOTO BRS143'DISPATCH[SAVEDB$ATTRIBUTE-1];
READ'PTR:I←GET'SEQ'PTR(F,1);
        BRS143'WORD(I); RETURN;

READ'LENGTH:BRS143'WORD(F.FILE'LENGTH); RETURN;

READ'SEQIO'MODE:BRS143'WORD(4B7 IF F.IS'OUTPUT'FILE ELSE 0);
        RETURN;

READ'CAPS:BRS143'WORD(F.FILE'CAPS); RETURN;

READ'BLOCK'SIZE:BRS143'WORD(PAGE'SIZE); RETURN;

READ'USER'WORDS:BRS143'WORD(0) FOR I←1 TO 5; RETURN;

READ'STRUCTURE:I←GET'SEQ'PTR(F,0);
        J←I$PAGE'NUMBER;
        K←NEXT'FILE'PAGE(F.M1'FILE'NO,J-1//SYSERR);
        IF K=-1 DO;
            BRS143'WORD(F.FILE'LENGTH-I+1@SIGN);
            GET'BLOCK(F,F.FILE'LENGTH,1,F.WRITE'OK);
        ELSEIF K#J DO;
            BRS143'WORD(K@PAGE'NUMBER-I+1@SIGN);
            GET'BLOCK(F,K@PAGE'NUMBER,1,F.WRITE'OK);
        ELSE DO;
            FOR K←K+1 WHILE NEXT'FILE'PAGE(F.M1'FILE'NO,K-1//SYSERR)=K DO;
            ENDFOR;
            BRS143'WORD(K@PAGE'NUMBER-I);
            FIX'SEQ'PTR(F,K@PAGE'NUMBER,F.WRITE'OK);
        ENDIF;
        RETURN;

COUNT'DATA:J←0; I←-1;
        J←J+PAGE'SIZE FOR I←NEXT'FILE'PAGE(F.M1'FILE'NO,I)
         WHILE I#-1;
        BRS143'WORD(J); RETURN;


         FUNCTION BRS144();
* P9.2 SEE BRS143
         F←CHECK'BRS1434();
        GOTO BRS144'DISPATCH[SAVEDB$ATTRIBUTE-1];
SET'PTR:TRAP IF F.POS'OK=0;
        I←BRS144'WORD();
        J←I$SEQ'PTR'CHAR'POS;
        I$SEQ'PTR'CHAR'POS←0;
        GET'BLOCK(F,I,1,F.WRITE'OK);
        IF J#0 DO;
            F.SEQ'PTR'CPOS←J-1;
            F.END'PTR'CPOS←2;
            F.SEQ'PTR'CSIZE←F.END'PTR'CSIZE←CSIZE8;
            F.SEQ'PTR'LWA←F.SEQ'PTR'LWA+1;
        ENDIF;
        RETURN;

SET'LENGTH:TRUNCATE'FILE(F,(F.FILE'LENGTH←BRS144'WORD())$PAGE'NUMBER);
        RETURN;

SET'SEQIO'MODE:I←BRS144'WORD()$SIGN;
        IF I=0 DO;
            TRAP IF F.READ'OK=0;
        ELSE DO;
            TRAP IF F.WRITE'OK=0;
        ENDIF;
        F.IS'INPUT'FILE←N' I;
        F.IS'OUTPUT'FILE←I; RETURN;

SET'CAPS:F.FILE'CAPS←F.FILE'CAPS A' BRS144'WORD();
        TRAP IF (I←F.FILE'RW'CAPS)=0;
* TEST FOR JUST ONE SET
         F.IS'SEQ'FILE←I IF I<3;
        RETURN;

SET'BLOCK'SIZE:RETURN;

SET'STRUCTURE:I←BRS144'WORD();
        J←GET'SEQ'PTR(F,0);
        DELETE'AREA(F,J,I);
        RETURN;

TRAP'BRS144:TRAP;

         FUNCTION DELETE'AREA(F,FA,CNT);
        TRAP IF F.WRITE'OK=0;
        FOR CNT←CNT,CNT-I WHILE CNT>0 DO;
            I←PAGE'SIZE-FA$WORD'ADDRESS;
            I←CNT IF I>CNT;
            J←FA;
            J$PAGE'NUMBER←F.BUFFER'PAGE;
            IF I=PAGE'SIZE DO;
                DELETE'FILE'PAGE(F.M1'FILE'NO,FA$PAGE'NUMBER//SYSERR);
            ELSE DO;
                BSET(J,0,I);
            ENDIF;
            FA←FA+I;
        ENDFOR;
        GET'BLOCK(F,FA,1,F.WRITE'OK);
        RETURN;
        END;
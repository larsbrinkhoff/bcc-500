        COMMON ASSM'VARIABLES;

         DECLARE STRING(4) ARRAYONE INSTR'OPCODES[86] ←
         ("ACI ", "ADC ", "ADD ", "ADI ", "ANA ");
        DECLARE STRING(4) ARRAYONE INSTR'OPCODES[ 6] ←
         ("ANI ", "CALL", "CC  ", "CM  ", "CMA ");
        DECLARE STRING(4) ARRAYONE INSTR'OPCODES[11] ←
         ("CMC ", "CMP ", "CNC ", "CNZ ", "CP  ");
        DECLARE STRING(4) ARRAYONE INSTR'OPCODES[16] ←
         ("CPE ", "CPI ", "CPO ", "CZ  ", "DAA ");
        DECLARE STRING(4) ARRAYONE INSTR'OPCODES[21] ←
         ("DAD ", "DB  ", "DCR ", "DCX ", "DI  ");
        DECLARE STRING(4) ARRAYONE INSTR'OPCODES[26] ←
         ("DS  ", "DW  ", "EI  ", "END ", "EQU ");
        DECLARE STRING(4) ARRAYONE INSTR'OPCODES[31] ←
         ("HLT ", "IN  ", "INR ", "INX ", "JC  ");
        DECLARE STRING(4) ARRAYONE INSTR'OPCODES[36] ←
         ("JM  ", "JMP ", "JNC ", "JNZ ", "JP  ");
        DECLARE STRING(4) ARRAYONE INSTR'OPCODES[41] ←
         ("JPE ", "JPO ", "JZ  ", "LDA ", "LDAX");
        DECLARE STRING(4) ARRAYONE INSTR'OPCODES[46] ←
         ("LHLD", "LXI ", "MOV ", "MVI ", "NOP ");
        DECLARE STRING(4) ARRAYONE INSTR'OPCODES[51] ←
         ("ORA ", "ORG ", "ORI ", "OUT ", "PCHL");
        DECLARE STRING(4) ARRAYONE INSTR'OPCODES[56] ←
         ("POP ", "PUSH", "RAL ", "RAR ", "RC  ");
        DECLARE STRING(4) ARRAYONE INSTR'OPCODES[61] ←
         ("RET ", "RIM ", "RLC ", "RM  ", "RNC ", "RNZ ");
        DECLARE STRING(4) ARRAYONE INSTR'OPCODES[67] ←
         ("RP  ", "RPE ", "RPO ", "RRC ", "RST ");
        DECLARE STRING(4) ARRAYONE INSTR'OPCODES[72] ←
         ("RZ  ", "SBB ", "SBI ", "SHLD", "SIM ", "SPHL");
        DECLARE STRING(4) ARRAYONE INSTR'OPCODES[78] ←
         ("STA ", "STAX", "STC ", "SUB ", "SUI ");
        DECLARE STRING(4) ARRAYONE INSTR'OPCODES[83] ←
         ("XCHG", "XRA ", "XRI ", "XTHL");



         DECLARE INTEGER ARRAYONE INSTR'CODES[86] ←
         (316B, 210B, 200B, 306B, 240B);
        DECLARE INTEGER ARRAYONE INSTR'CODES[ 6] ←
         (346B, 315B, 334B, 374B,  57B);
        DECLARE INTEGER ARRAYONE INSTR'CODES[11] ←
         ( 77B, 270B, 324B, 304B, 364B);
        DECLARE INTEGER ARRAYONE INSTR'CODES[16] ←
         (354B, 376B, 344B, 314B,  47B);
        DECLARE INTEGER ARRAYONE INSTR'CODES[21] ←
         ( 11B,   0B,   5B,  13B, 363B);
        DECLARE INTEGER ARRAYONE INSTR'CODES[26] ←
         (  0B,   0B, 373B,   0B,   0B);
        DECLARE INTEGER ARRAYONE INSTR'CODES[31] ←
         (166B, 333B,   4B,   3B, 332B);
        DECLARE INTEGER ARRAYONE INSTR'CODES[36] ←
         (372B, 303B, 322B, 302B, 362B);
        DECLARE INTEGER ARRAYONE INSTR'CODES[41] ←
         (352B, 342B, 312B,  72B,  12B);
        DECLARE INTEGER ARRAYONE INSTR'CODES[46] ←
         ( 52B,   1B, 100B,   6B,   0B);
        DECLARE INTEGER ARRAYONE INSTR'CODES[51] ←
         (260B,   0B, 366B, 323B, 351B);
        DECLARE INTEGER ARRAYONE INSTR'CODES[56] ←
         (301B, 305B,  27B,  37B, 330B);
        DECLARE INTEGER ARRAYONE INSTR'CODES[61] ←
         (311B, 40B,   7B, 370B, 320B, 300B);
        DECLARE INTEGER ARRAYONE INSTR'CODES[67] ←
         (360B, 350B, 340B,  17B, 307B);
        DECLARE INTEGER ARRAYONE INSTR'CODES[72] ←
         (310B, 230B, 336B,  42B, 60B, 371B);
        DECLARE INTEGER ARRAYONE INSTR'CODES[78] ←
         ( 62B,   2B,  67B, 220B, 326B);
        DECLARE INTEGER ARRAYONE INSTR'CODES[83] ←
         (353B, 250B, 356B, 343B);



         DECLARE INTEGER ARRAYONE INSTR'INCRE[86] ←
         (2B, 1B, 1B, 2B, 1B);
        DECLARE INTEGER ARRAYONE INSTR'INCRE[ 6] ←
         (2B, 3B, 3B, 3B, 1B);
        DECLARE INTEGER ARRAYONE INSTR'INCRE[11] ←
         (1B, 1B, 3B, 3B, 3B);
        DECLARE INTEGER ARRAYONE INSTR'INCRE[16] ←
         (3B, 2B, 3B, 3B, 1B);
        DECLARE INTEGER ARRAYONE INSTR'INCRE[21] ←
         (1B, 1B, 1B, 1B, 1B);
        DECLARE INTEGER ARRAYONE INSTR'INCRE[26] ←
         (0B, 2B, 1B, 0B, 0B);
        DECLARE INTEGER ARRAYONE INSTR'INCRE[31] ←
         (1B, 2B, 1B, 1B, 3B);
        DECLARE INTEGER ARRAYONE INSTR'INCRE[36] ←
         (3B, 3B, 3B, 3B, 3B);
        DECLARE INTEGER ARRAYONE INSTR'INCRE[41] ←
         (3B, 3B, 3B, 3B, 1B);
        DECLARE INTEGER ARRAYONE INSTR'INCRE[46] ←
         (3B, 3B, 1B, 2B, 1B);
        DECLARE INTEGER ARRAYONE INSTR'INCRE[51] ←
         (1B, 0B, 2B, 2B, 1B);
        DECLARE INTEGER ARRAYONE INSTR'INCRE[56] ←
         (1B, 1B, 1B, 1B, 1B);
        DECLARE INTEGER ARRAYONE INSTR'INCRE[61] ←
         (1B, 1B, 1B, 1B, 1B, 1B);
        DECLARE INTEGER ARRAYONE INSTR'INCRE[67] ←
         (1B, 1B, 1B, 1B, 1B);
        DECLARE INTEGER ARRAYONE INSTR'INCRE[72] ←
         (1B, 1B, 2B, 3B, 1B, 1B);
        DECLARE INTEGER ARRAYONE INSTR'INCRE[78] ←
         (3B, 1B, 1B, 1B, 2B);
        DECLARE INTEGER ARRAYONE INSTR'INCRE[83] ←
         (1B, 1B, 2B, 1B);

         DECLARE INTEGER
         L'COUNTER,              /*  LOCATION COUNTER.  */
         STMNT'NO,               /*  STATEMENT NUMBER.  */
         LAST'SYMBOL,            /*  LAST SYMBOL INDEX IN SYMBOL TABLE  */
         FILE'SOURCE'NO,         /*  INPUT FILE NUMBER.  */
         FILE'OBJECT'NO,         /*  OBJECT FILE NUMBER.  */
         FILE'TABLE'NO,          /*  TABLE FILE NUMBER.  */
         FILE'LIST'NO,           /*  LIST FILE NUMBER.  */
         ERROR'COUNT,            /*  NUMBER OF ERRORS ENCOUNTERED.  */
         PAGE'COUNT,             /*  THE PAGE COUNTER.  */
         LINE'COUNT,             /*  LINE NUMBER OF THE CURRENT PAGE.  */
         LIST'OPTION,            /*  CONTROLS LISTING OF PROGRAM.   */
*        THE FOLLOWING INTEGERS PERTAIN TO THE OBJECT CODE OUTPUT
*        ROUTINE;
         FIRST'TIME,             /*  TELL IF THIS IS THE FIRST TIME  */
*                                    THE OUTPUT ROUTINE HAS BEEN CALLED.
         SA,                     /*  STARTING ADDRESS OF CODE.  */
         EXPECTED,               /*  THE ADDRESS EXPECTED    */
*                                    FOR THE NEXT CALL.
         CHK'SUM,                /*  THE CHECK'SUM COUNTER.  */
         RECORD'NO,              /*  RECORD NUMBER FOR ALBERT RICH'S  */
*                                    LOADER.

*        THE FOLLOWING INTEGERS PERTAIN TO THE CROSS REF TABLE.
*
*
         NEXT'ONE,              /*  POINTS TO THE NEXT AVAILABLE ENTRY
*                                   IN THE CROSS REFERENCE TABLE.
         XREF'OPTION,           /*  DETERMINES IF CROSS REF  */
         FIRST'PAGE;            /*  TELLS NEW'PAGE'1 THAT THIS IS */
*        THE FIRST TIME IT IS BEING CALLED AND IT SHOULD NOT PUT A 
*        PAGE EJECT IN THE LIST FILE.
*
*                                       TABLE IS TO BE PRODUCED.
*

         DECLARE STRING
         TEXT(200),              /*  THE SOURCE TEXT   */
         L'FIELD(10),            /*  LABEL FIELD.  */
         I'FIELD(10),            /*  INSTRUCTION FIELD.  */
         O'FIELD(80),            /*  OPCODE FIELD.  */
         TITLE'PAGE(30),         /*  HEADING ON PAGE.  */
         DISPLAY,                /*  COPY OF STATEMENT BEING PROCESSED.  */
         BUFFR(100);             /*  OBJECT CODE BUFFR.  */

*        THE FOLLOWING ARE THE COMMANDS USED TO CONTROL THE
*        LISTING OF THE SOURCE PROGRAM.

         DECLARE STRING(7) ARRAY COMMANDS[4] ←
         ("TITLE", "NOPRINT", "PRINT", "PAGE");

/*  SYMBOL TABLE DECLARATION  */
         DECLARE STRING ARRAYONE
         SYMBOL[1000];

         DECLARE INTEGER ARRAYONE
         VALUES[1000],            /*  VALUE OF THE SYMBOLS.  */
         SYMBOL'SPACE[2005];     /*  SPACE FROM SYMBOL TABLE.  */

*        CROSS-REFERENCE TABLE DECLARATIONS.
         DECLARE INTEGER ARRAYONE
         XREF'TABLE[4000];
        END;  /*  END OF ASSM'VARIABLES.  */
*  THE FOLLOWING IS THE SUBSTRING FUNCTION.  IT TAKES 4 ARGUMENTS,
*  THE FIRST 3 BEING THE SAME AS IN PL/I.  THE 4TH ARGUMENT IS
*  THE STRING THAT YOU WANT THE SUBSTRING TO BE ASSIGNED TO.  EG:
*
*      TARGET ← SUBSTR(SOURCE, 1, 5, TARGET);
*
        PROGRAM SUBSTR;

         DECLARE STRING
         SOURCE,                 /*  SOURCE STRING  */
         TARGET,                 /*  TARGET STRING  */
         TMP1;                   /*  TEMPORARY DESCRIPTOR  */

         DECLARE INTEGER
         START,                  /*  START OF CHARACTER POSITION  */
         LENT,                   /*  LENGTH OF SUBSTRING REQUIRED  */
         I1;                     /*  INDEX VARIABLE  */

         STRING FUNCTION SUBSTR(SOURCE, START, LENT, TARGET);

         SETS(TARGET, 0, 0);
        IF LENT = 0
         DO;
            RETURN TARGET;
        ENDIF;
        TMP1 ← SOURCE;
        TMP1 ← CHOP(TMP1, START -1);
        FOR I1 ← 1 TO LENT
         DO;
            WCI(GCI(TMP1// GOTO STRINGRANGE), TARGET// GOTO STRINGSIZE);
        ENDFOR;
        RETURN (TARGET);

         STRINGRANGE:  /*  STRINGRANGE CONDITION RAISED  */
        PUTA("STRINGRANGE CONDITION RAISED.  PARAMETERS ARE:",1);
        PUTA(SOURCE,1);                                    PUTN(START,1);                                    PUTN(LENT, 1);
        EXIT();

         STRINGSIZE:  /*   STRINGSIZE CONDITION RAISED  */
        PUTA("STRINGSIZE CONDITION RAISED.  PARAMETERS ARE:", 1);
        PUTA(SOURCE,1);                                    PUTN(START,1);                                    PUTN(LENT, 1);
        EXIT();

         END;  /*  END OF 'SUBSTR'.  */

        PROGRAM PUT'SKIP;

         DECLARE INTEGER
         SKIPS;

         FUNCTION PUT'SKIP(SKIPS);

         PUTA("", SKIPS);
        RETURN;

         END;  /*  END OF PUT'SKIP.  */
        PROGRAM PUTN;

         DECLARE INTEGER
         LINE'FEEDS,
         NUMBER;

         FUNCTION PUTN(NUMBER, LINE'FEEDS);

         OUTPUT'NUMBER(NUMBER);
        IF LINE'FEEDS = 0
         DO;
            RETURN;
        ENDIF;

         PUT'SKIP(LINE'FEEDS);
        RETURN;

         END;  /*  END PUTN  */

        PROGRAM VERIFY;

         DECLARE STRING
         FIRST,
         SECOND,
         DUMMY(1);

         DECLARE INTEGER
         I1;

         INTEGER FUNCTION VERIFY(FIRST, SECOND);

         FOR I1 ← 1 TO LENGTH(FIRST)
         DO;
            IF INDEX(SECOND, SUBSTR(FIRST, I1, 1, DUMMY)) = 0
             DO;
                RETURN I1;
            ENDIF;
        ENDFOR;
        RETURN 0;

         END;  /*  END OF VERIFY.  */

        PROGRAM INDEX;

         DECLARE STRING
         S1, S2, S3, S4, SOURCE, TEST;

         DECLARE CHARACTER
         C1, C2, C3;

         DECLARE INTEGER
         I1;

         INTEGER FUNCTION INDEX(SOURCE, TEST);

         I1 ← 1;
        S1 ← SOURCE;
        S2 ← TEST;
        C1 ← C3 ← GCI(S2// RETURN 0);
        S4 ← S2;
        WHILE 1
         DO;
            C2 ← GCI(S1// RETURN 0);
            WHILE C1 # C2
             DO;
                C2 ← GCI(S1// RETURN 0);
                I1 ← I1 + 1;
            ENDFOR;
            S3 ← S1;
            WHILE C1 = C2
             DO;
                C1 ← GCI(S2// RETURN I1);
                C2 ← GCI(S1// RETURN 0);
            ENDFOR;
            S1 ← S3;
            S2 ← S4;
            C1 ← C3;
        ENDFOR;

         END;  /*  END OF INDEX.  */

        PROGRAM PARSE;

         DECLARE STRING
         LINE,
         LABEL'FIELD,
         OPCODE'FIELD,
         OPERAND'FIELD;

         DECLARE CHARACTER
         FIRST,
         C1;

         DECLARE INTEGER
         IN;

         FUNCTION PARSE(LINE, LABEL'FIELD, OPCODE'FIELD, OPERAND'FIELD);

         SETS(LABEL'FIELD, 0, 0);
        SETS(OPCODE'FIELD, 0, 0);
        SETS(OPERAND'FIELD, 0, 0);

         FIRST ← GC(LINE);

       WHILE FIRST > '←'
         DO;
           GCI(LINE);
           FIRST ← GC(LINE);
       ENDFOR;

         IF FIRST # ' '
         DO;
            C1 ← GCI(LINE);
            WHILE C1 # ' ' AND C1 # ':'
             DO;
                WCI(C1, LABEL'FIELD);
                C1 ← GCI(LINE//ERROR'MSG(8) & RETURN (LINE,LABEL'FIELD,OPCODE'FIELD,OPERAND'FIELD));
            ENDFOR;
        ENDIF;

         C1 ← GCI(LINE// RETURN (LINE,LABEL'FIELD,OPCODE'FIELD,OPERAND'FIELD));
        WHILE C1 = ' '
         DO;
            C1 ← GCI(LINE// RETURN (LINE,LABEL'FIELD,OPCODE'FIELD,OPERAND'FIELD));
        ENDFOR;
        WHILE C1 # ' '
         DO;
            WCI(C1, OPCODE'FIELD);
            C1 ← GCI(LINE// RETURN (LINE,LABEL'FIELD,OPCODE'FIELD,OPERAND'FIELD));
        ENDFOR;

         WHILE C1 = ' '
         DO;
            C1 ← GCI(LINE// RETURN (LINE,LABEL'FIELD,OPCODE'FIELD,OPERAND'FIELD));
        ENDFOR;
        IF C1 = ';'
         DO;
            RETURN (LINE,LABEL'FIELD,OPCODE'FIELD,OPERAND'FIELD);
        ENDIF;
        IN ← -1;
        WHILE C1 # ' ' OR IN = 1
         DO;
            IF C1 = 7B
             DO;
                IN ← -IN;
            ENDIF;
            WCI(C1,OPERAND'FIELD);
            C1 ← GCI(LINE// RETURN (LINE,LABEL'FIELD,OPCODE'FIELD,OPERAND'FIELD));
        ENDFOR;

         RETURN (LINE,LABEL'FIELD,OPCODE'FIELD,OPERAND'FIELD);

         END;  /*  END OF PARSE.  */

        PROGRAM CHOP;

         DECLARE STRING
         STR;                /* STRING TO BE CHOPPED.  */

         DECLARE INTEGER
         I1, I2;

         STRING FUNCTION CHOP(STR, I1);

         RETURN STR IF I1 = 0;
        FOR I2 ← 1 TO I1
         DO;
            GCI(STR// RETURN STR);
        ENDFOR;
        RETURN STR;

         END;  /*  END OF CHOP  */
        PROGRAM SEARCH'TABLE;

         DECLARE INTEGER
         I1, HIGH, LOW, HBOUND;

         DECLARE STRING
         STR1, TOKEN;

         DECLARE STRING ARRAYONE
         TABLE;

         FUNCTION SEARCH'TABLE(TABLE, TOKEN, HBOUND),                                FRETURN;

         HIGH ← HBOUND;
        LOW ← 1;
        WHILE HIGH >= LOW
         DO;
            I1 ← (HIGH + LOW)/2;
            STR1 ← TABLE[I1];
            IF LLT(TOKEN, STR1// FRETURN) = -1
             DO;
                HIGH ← I1 - 1;
            ELSEIF LGT(TOKEN, STR1// FRETURN) = -1
             DO;
                LOW ← I1 + 1;
            ELSE
             DO;
                RETURN I1;
            ENDIF;
        ENDFOR;
        FRETURN;

         END;  /*  END OF SEARCH'TABLE.  */

        PROGRAM NEAREST;

         DECLARE INTEGER
         I1, I2, LENT, IN;

         DECLARE CHARACTER
         C1;
        DECLARE STRING
         ARG1,
         EXP(80);

         INTEGER FUNCTION NEAREST(ARG1);

         SETS(EXP, 0, 0);
        IN ← -1;
        C1 ← GCI(ARG1);
        WHILE 1
         DO;
            IF C1 = 7B
             DO;
                IN ← - IN;
                WCI(C1, EXP);
                C1 ← GCI(ARG1// GOTO L1);
            ENDIF;
            IF IN = 1
             DO;
                WCI('!', EXP);
            ELSE
             DO;
                WCI(C1, EXP);
            ENDIF;
            C1 ← GCI(ARG1// GOTO L1);
        ENDFOR;
L1:
        I1 ← INDEX(EXP, "+");
        I2 ← INDEX(EXP, "-");
        LENT ← LENGTH(EXP) + 1;
        IF I1 <= 0
         DO;
            I1 ← LENT;
        ENDIF;
        IF I2 <= 0
         DO;
            I2 ← LENT;
        ENDIF;
        IF I1 < I2
         DO;
            RETURN I1;
        ELSE
         DO;
            RETURN I2;
        ENDIF;

         END;  /*  END OF NEAREST  */

        PROGRAM EVALUATE;

         DECLARE INTEGER
         RESULT, I1, I2;

         DECLARE CHARACTER
         C1;

         DECLARE STRING
         EXP,                    /*  THE EXPRESSION  */
         ARG1,                   /*  DUMMY ARGUMENT  */
         TMP(100),               /*  TEMPORARY VARIABLE  */
         DOPE(1);

         INTEGER FUNCTION EVALUATE(ARG1);

         RETURN 0 IF COMPARE'STRING(ARG1, ""//HELP()) = -1 OR
         COMPARE'STRING(ARG1, "     "//HELP()) = -1;
        EXP ← ARG1;
        C1 ← GCI(EXP);
        WCD(C1, EXP);
        IF C1 = '+' OR C1 = '-'
         DO;  /* NOTHING  */
        ELSE
         DO;
            SETS(TMP, 0, 0);
            WCI('+', TMP);
            APPEND(TMP, EXP//HELP());
            SCOPY(EXP, TMP//HELP());
        ENDIF;
        RESULT ← 0;
        WHILE 1
         DO;
            C1 ← GCI(EXP// RETURN RESULT);
            I1 ← NEAREST(EXP);
            I2 ← FIND(SUBSTR(EXP, 1, I1 - 1, TMP));
            IF C1 = '+'
             DO;
                RESULT ← RESULT + I2;
            ELSE
             DO;
                RESULT ← RESULT - I2;
            ENDIF;
            EXP ← CHOP(EXP, I1 - 1);
        ENDFOR;

         END;  /*  END OF EVALUATE.  */

        PROGRAM FIND;

         INCLUDE ASSM'VARIABLES;
        DECLARE INTEGER
         I1;

         DECLARE CHARACTER
         C1;

         DECLARE STRING
         FIRST(1),
         EXP;

         DECLARE INTEGER ARRAYONE REG'VALUE[13] ←
         (7, 0, 1, 2, 3, 4, 5, 6, 6, 6, 6, 6, 0);

         INTEGER FUNCTION FIND(EXP);

         IF COMPARE'STRING(EXP, "$"//HELP()) = -1
         DO;
            RETURN L'COUNTER;
        ENDIF;
        I1 ← INDEX("ABCDEHLMPSWSP", EXP);
        IF I1 # 0
         DO;
            I1 ← REG'VALUE[I1];
            RETURN I1;
        ENDIF;
        FIRST ← SUBSTR(EXP, 1, 1, FIRST);
        IF VERIFY(FIRST, "0123456789") = 0
         DO;  /*  WE HAVE A NUMBER */
        C1 ← GCD(EXP);
            IF C1 = 'H'
             DO;  /*  WE HAVE A HEX NUMBER.  */
            I1 ← CSN(EXP, 16//ERROR'MSG(2) & RETURN 0);
                RETURN I1;
            ELSEIF C1 = 'O' OR C1 = 'Q'
             DO;  /*  WE HAVE AN OCTAL NUMBER.  */
            I1 ← CSN(EXP, 8//ERROR'MSG(15) & RETURN 0);
                RETURN I1;
            ELSEIF C1 = 'D'
             DO;  /*  WE STILL HAVE A DECIMAL NUMBER.  */
            I1 ← CSN(EXP, 10//ERROR'MSG(3) & RETURN 0);
                RETURN I1;
            ELSEIF C1 = 'B'
             DO;  /*  WE HAVE A BINARY NUMBER.  */
            I1 ← CSN(EXP, 2//ERROR'MSG(16) & RETURN 0);
                RETURN I1;
            ELSE
             DO;  /*  WE MUST HAVE A DECIMAL NUMBER.  */
            WCI(C1, EXP);
                I1 ← CSN(EXP, 10//ERROR'MSG(3) & RETURN 0);
                RETURN I1;
            ENDIF;
        ENDIF;
        IF COMPARE'STRING(FIRST, "'"//HELP()) = -1
         DO;
            GCI(EXP);
            C1 ← GCI(EXP//ERROR'MSG(4) & RETURN 0);
            RETURN (C1 + 32);
        ENDIF;
        WHILE LENGTH(EXP) < 5
         DO;
            WCI(' ', EXP);
        ENDFOR;
        RETURN 0 IF COMPARE'STRING(EXP, "     "//HELP()) = -1;
        I1 ← SEARCH'TABLE(SYMBOL, EXP, LAST'SYMBOL//
         ERROR'MSG(1) & RETURN 0);
        ADD'TO'LIST(I1) IF XREF'OPTION = 0;
        I1 ← VALUES[I1];
        RETURN I1;

         END;  /*   END OF VALUE.  */

        PROGRAM HEXOUT;

         DECLARE STRING
         STR1,
         STR2(100);

         DECLARE INTEGER
         NUMBER,
         DONE,
         COUNT;

         DECLARE CHARACTER
         C1;
        STRING FUNCTION HEXOUT(NUMBER, STR1, COUNT);

         SETS(STR2, 0, 0);
        DONE ← 0;
        CNS(NUMBER, STR2, COUNT * 2, 16//HELP());
        C1 ← GCI(STR2//DONE ← 1);
        WHILE NOT DONE
         DO;
            C1 ← '0' IF C1 = ' ';
            WCI(C1, STR1);
            C1 ← GCI(STR2//DONE ← 1);
        ENDFOR;
        RETURN STR1;

         END;  /*  END OF HEXOUT.  */



        PROGRAM CHECK'LABEL;

         INCLUDE ASSM'VARIABLES;

         DECLARE STRING
         LABEL'FIELD,
         DUMMY(1);

         DECLARE INTEGER
         I1;

         FUNCTION CHECK'LABEL(LABEL'FIELD), FRETURN;

         RETURN IF COMPARE'STRING(LABEL'FIELD, "     "//HELP()) = -1;
        IF LENGTH(LABEL'FIELD) > 5
         DO;
            ERROR'MSG(5);
            FRETURN;
        ENDIF;
        IF VERIFY(SUBSTR(LABEL'FIELD, 1, 1, DUMMY),
         "0123456789") = 0
         DO;
            ERROR'MSG(6);
            FRETURN;
        ENDIF;
        SEARCH'TABLE(SYMBOL, LABEL'FIELD, LAST'SYMBOL// RETURN);
        ERROR'MSG(7);
        FRETURN;

         END;  /*  END OF CHECK'LABEL.  */

        PROGRAM INIT'ASSM;

         INCLUDE ASSM'VARIABLES;
        DECLARE STRING
         STR1;
        DECLARE INTEGER
         I1;
        DECLARE POINTER
         PTR1;

         FUNCTION INIT'ASSM();

         PTR1 ← @SYMBOL'SPACE[1];
        FOR I1 ← 1 TO 1000
         DO;
            STR1 ← SYMBOL[I1];
            SETUP(STR1, 5, PTR1, 8);
            SYMBOL[I1] ← STR1;
            PTR1 ← PTR1 + 2;
        ENDFOR;
        SETS(BUFFR, 0, 0);
        RECORD'NO ← ERROR'COUNT ← LAST'SYMBOL ← L'COUNTER ← 0;
        LIST'OPTION ← FIRST'PAGE ← PAGE'COUNT ← 1;
        XREF'OPTION ← FIRST'TIME ← LINE'COUNT ← STMNT'NO ← 1;
        SETS(TITLE'PAGE, 0, 0);
        APPEND(TITLE'PAGE, "8085 CROSS-ASSEMBLER LISTING"//HELP());
        NEW'PAGE'1();
        RETURN;

         END;  /*  END OF INIT'ASSM.  */

        PROGRAM ENTER'ENTRY;

         INCLUDE ASSM'VARIABLES;

         DECLARE FIELD
         XREF'AT (0:0, 11),
         NEXT'PTR (0: 12, 23);

         DECLARE STRING
         TOKEN,
         STR1,
         STR2;

         DECLARE INTEGER
         TOKEN'VALUE,
         I1,
         DONE;

         FUNCTION ENTER'ENTRY(TOKEN, TOKEN'VALUE);

         RETURN IF LENGTH(TOKEN) > 5;
        IF LAST'SYMBOL = 0
         DO;
            STR1 ← SYMBOL[1];
            SCOPY(STR1, TOKEN//HELP());
            SYMBOL[1] ← STR1;
            VALUES[1] ← TOKEN'VALUE;
            XREF'TABLE[1]$XREF'AT ← STMNT'NO;
            LAST'SYMBOL ← 1;
            RETURN;
        ENDIF;
        DONE ← 0;
        I1 ← LAST'SYMBOL;
        WHILE NOT DONE
         DO;
            IF I1 = 0
             DO;
                DONE ← 1;
            ELSE
             DO;
                STR1 ← SYMBOL[I1];
                IF LLT(TOKEN, STR1//HELP()) = -1
                 DO;
                    STR1 ← SYMBOL[I1];
                    STR2 ← SYMBOL[I1 + 1];
                    SCOPY(STR2, STR1//HELP());
                    SYMBOL[I1 + 1] ← STR2;
                    VALUES[I1 + 1] ← VALUES[I1];
                    XREF'TABLE[I1 + 1]$XREF'AT ← XREF'TABLE[I1]$XREF'AT;
                    I1 ← I1 - 1;
                ELSE
                 DO;
                    DONE ← 1;
                ENDIF;
            ENDIF;
        ENDFOR;
        STR1 ← SYMBOL[I1 + 1];
        SCOPY(STR1, TOKEN//HELP());
        SYMBOL[I1 + 1] ← STR1;
        VALUES[I1 + 1] ← TOKEN'VALUE;
        XREF'TABLE[I1 + 1]$XREF'AT ← STMNT'NO;
        LAST'SYMBOL ← LAST'SYMBOL + 1;
        RETURN;
        END;  /*  END OF ENTER'ENTRY.  */

        PROGRAM TEST;

         INCLUDE ASSM'VARIABLES, SEQ'FILE'DEFS;
        DECLARE STRING STR1(100), NAME(15);
        DECLARE INTEGER I1, I2, FNO;

         FUNCTION TEST();
        ASSEMBLE();
        EXIT();

         END;  /*  END OF TEST.  */
        PROGRAM OUTLINE;

         INCLUDE ASSM'VARIABLES;

         DECLARE FIELD
         BYTE'1 (0:0,7);

         DECLARE INTEGER
         I1,
         CODE,
         FNO,
         BYTE'COUNT;

         DECLARE STRING
         OUT'STR(200);

         FUNCTION OUTLINE(FNO, CODE, BYTE'COUNT);

         RETURN IF FNO < 0 OR LIST'OPTION = 0;
        LINE'COUNT ← LINE'COUNT + 1;
        NEW'PAGE'1() IF LINE'COUNT > 57;
        SETS(OUT'STR, 0, 0);
        CNS(STMNT'NO, OUT'STR, 4, 10//HELP());
        WCI(135B, OUT'STR);
        WCI(2, OUT'STR);
*      IF BYTE'COUNT = 0 THIS IS A COMMENT.  JUST PRINT OUT THE LINE.
         IF BYTE'COUNT = 0
         DO;
            WCI(135B, OUT'STR);
            WCI(14, OUT'STR);
            APPEND(OUT'STR, DISPLAY//HELP());
            OUTPUT'SEQ'FILE(FNO, OUT'STR//HELP());
            RETURN;
        ENDIF;
*      IF BYTE'COUNT = -1 THIS IS AND 'EQU' STATMENT.  PRINT OUT
*      SYMBOL VALUE.
         IF BYTE'COUNT = -1
         DO;
            I1 ← SEARCH'TABLE(SYMBOL, L'FIELD, LAST'SYMBOL//HELP());
            I1 ← VALUES[I1];
            OUT'STR ← HEXOUT(I1, OUT'STR, 2);
            WCI(135B, OUT'STR);
            WCI(10, OUT'STR);
            APPEND(OUT'STR, DISPLAY//HELP());
            OUTPUT'SEQ'FILE(FNO, OUT'STR//HELP());
            RETURN;
        ENDIF;
        OUT'STR ← HEXOUT(L'COUNTER, OUT'STR, 2);
        WCI(135B, OUT'STR);
        WCI(2, OUT'STR);
*      IF BYTE'COUNT = -2 THIS IS AN'ORG' INSTRUCTION.
         IF BYTE'COUNT = -2
         DO;
            WCI(135B, OUT'STR);
            WCI(8, OUT'STR);
            APPEND(OUT'STR, DISPLAY//HELP());
            OUTPUT'SEQ'FILE(FNO, OUT'STR//HELP());
            RETURN;
        ENDIF;
*      CONTROL COMES TO HERE WHEN WE HAVE A REGULAR INSTRUCTION.

         FOR I1 ← 1 TO BYTE'COUNT
         DO;
            OUT'STR ← HEXOUT(CODE$BYTE'1, OUT'STR, 1);
            CODE ← CODE LCY 8;
        ENDFOR;
        I1 ← BYTE'COUNT;
        WHILE I1 < 3
         DO;
            APPEND(OUT'STR, "  "//HELP());
            I1 ← I1 + 1;
        ENDFOR;
        APPEND(OUT'STR, "  "//HELP());
        APPEND(OUT'STR, DISPLAY//HELP());
        OUTPUT'SEQ'FILE(FNO, OUT'STR//HELP());
        RETURN;
        END;  /*  END OF OUTLINE  */
        PROGRAM ASSEMBLE;

         INCLUDE ASSM'VARIABLES, SEQ'FILE'DEFS, UTILITY'CALLS;

         DECLARE FIELD
         XREF'AT (0:0, 11),
         NEXT'PTR (0:12, 23);

         DECLARE INTEGER
         E1,  E2,  /*  ERROR CODES  */
         WORD,
         BYTE'COUNT,
         OPINDEX,
         L'INCRE,
         LABEL'VALUE,
         DONE, I1, I2, I3, I4;

         DECLARE CHARACTER
         C1;

         DECLARE STRING
         NAME(16),
         INNAME(16),
         STR1,
         DOPE(80);

         DECLARE LABEL ARRAYONE INSTR'BRANCH[86] ←

         (ACI , ADC , ADD , ADI , ANA ,
         ANI , CALL,  CC ,  CM , CMA ,
         CMC , CMP , CNC , CNZ ,  CP ,
         CPE , CPI , CPO ,  CZ , DAA ,
         DAD ,  DB , DCR , DCX ,  DI ,
         DS ,  DW ,  EI , ENDL , EQU ,
         HLT ,  IN , INR , INX ,  JC ,
         JM , JMP , JNC , JNZ ,  JP ,
         JPE , JPO ,  JZ , LDA , LDAX,
         LHLD, LXI , MOV , MVI , NOP ,
         ORA , ORGL , ORI , OUT , PCHL,
         POPL, PUSH, RAL , RAR ,  RC ,
         RET , RIM , RLC ,  RM , RNC , RNZ ,
         RP , RPE , RPO , RRC , RST ,
         RZ , SBB , SBI , SHLD, SIM, SPHL);
        DECLARE LABEL ARRAYONE INSTR'BRANCH[78] ←
         (STA, STAX, STC, SUB, SUI, XCHG, XRA, XRI, XTHL);



         DECLARE FIELD
         BYTE'1 (0:0,7),
         BYTE'2 (0:8,15),
         BYTE'3 (0:16,23),
         BITS'2'4 (0:2,4),
         BITS'21'23 (0:21,23),
         BITS'5'7 (0:5,7),
         BITS'3'3 (0:3,3),
         BITS'22'22 (0:22,22),
         BITS'21'22 (0:21,22),
         BITS'2'3 (0:2,3);


         FUNCTION ASSEMBLE();



         PUTA("8080/8085 CROSS-ASSEMBLER",2);
        L1:
        INNAME ← READ'LINE(-1,INNAME, "SOURCE:  ",0//
         SYSTEM'ERROR() & EXIT():INNAME, E1, E2);
        FILE'SOURCE'NO ← OPEN'SEQ'FILE(INNAME, READ'FILE, SYMBOLIC'FILE,
         8// GOTO L1);
L2:
        NAME ← READ'LINE(-1,NAME, "OBJECT:  ",0//
         SYSTEM'ERROR() & EXIT():NAME, E1, E2);
        FILE'OBJECT'NO ← OPEN'SEQ'FILE(NAME, WRITE'FILE, SYMBOLIC'FILE,
         8// GOTO L2);
L3:
        NAME ← READ'LINE(-1,NAME, "LIST:  ",0//
         SYSTEM'ERROR() & EXIT():NAME, E1, E2);
        IF LENGTH(NAME) # 0
         DO;
            FILE'LIST'NO ← OPEN'SEQ'FILE(NAME, WRITE'FILE, SYMBOLIC'FILE,
             8// GOTO L3);
        ELSE
         DO;
            FILE'LIST'NO ← -1;
        ENDIF;
L4:
        NAME ← READ'LINE(-1,NAME, "TABLE:  ",0//
         SYSTEM'ERROR() & EXIT():NAME, E1, E2);
        IF LENGTH(NAME) # 0
         DO;
            FILE'TABLE'NO ← OPEN'SEQ'FILE(NAME, WRITE'FILE, SYMBOLIC'FILE,
             8// GOTO L4);
        ELSE
         DO;
            FILE'TABLE'NO ← -1;
        ENDIF;
        INIT'ASSM();
/*  BEGIN PASS1  */

         FOR I1 ← 1 TO 1000
         DO;
            XREF'TABLE[I1]$NEXT'PTR ← 0;
        ENDFOR;
        DONE ← 0;
        WHILE NOT DONE
         DO;
            TEXT ← INPUT'SEQ'FILE(FILE'SOURCE'NO, TEXT//HELP());
            IF LENGTH(TEXT) = 0
             DO;
                PUTA("EOF ENCOUNTERED.", 1);
                CLOSE'SEQ'FILE(FILE'SOURCE'NO//HELP());
                CLOSE'SEQ'FILE(FILE'OBJECT'NO//HELP());
                CLOSE'SEQ'FILE(FILE'LIST'NO//HELP())
                 IF FILE'LIST'NO > 0;
                RETURN;
            ENDIF;
            DISPLAY ← TEXT;
*           IF WE ENCOUNTER A COMMENT IGNORE IT.
             C1 ← GCI(DISPLAY);
            DISPLAY ← TEXT;
            GOTO L6 IF C1 = '*' OR C1 = ';';
*  IF WE ENCOUNTER A NULL LINE IGNORE IT AND TREAT IT
*  AS A COMMENT.
           IF LENGTH(DISPLAY) = 1 DO;
               SETS(TEXT);
               SETS(DISPLAY);
               WCI(155B, TEXT);
               WCI(152B, TEXT);
               DISPLAY ← TEXT;
           ENDIF;
             GOTO L6 IF LENGTH(DISPLAY) = 2;
            GCD(TEXT);
            GCD(TEXT);
            PARSE(TEXT, L'FIELD, I'FIELD, O'FIELD:
             TEXT, L'FIELD, I'FIELD, O'FIELD);
            WHILE LENGTH(L'FIELD) < 5
             DO;
                WCI(' ', L'FIELD);
            ENDFOR;
            WHILE LENGTH(I'FIELD) < 4
             DO;
                WCI(' ', I'FIELD);
            ENDFOR;
            CHECK'LABEL(L'FIELD// GOTO L7);
L7:
            OPINDEX ← SEARCH'TABLE(INSTR'OPCODES, I'FIELD, 86//
             OPINDEX ← 0 & GOTO L5);
L5:
            IF OPINDEX = 0
             DO;
                ERROR'MSG(9);
            ELSE
             DO;
                L'INCRE ← INSTR'INCRE[OPINDEX];
                LABEL'VALUE ← L'COUNTER;
                IF OPINDEX =  22
                 DO;
                    L'INCRE ← 1;
                ELSEIF OPINDEX = 26
                 DO;
                    L'INCRE ← EVALUATE(O'FIELD);
                ELSEIF OPINDEX = 27
                 DO;
                    L'INCRE ← 2;
                ELSEIF OPINDEX = 29
                 DO;
                    DONE ← 1;
                ELSEIF OPINDEX = 52
                 DO;
                    L'COUNTER ← EVALUATE(O'FIELD);
                ELSEIF OPINDEX = 30
                 DO;
                    LABEL'VALUE ← EVALUATE(O'FIELD);
                ENDIF;
                IF COMPARE'STRING(L'FIELD, "     "//HELP()) = 0
                 DO;
                    ENTER'ENTRY(L'FIELD, LABEL'VALUE);
                ENDIF;
                L'COUNTER ← L'COUNTER + L'INCRE;
            ENDIF;
*      CONTROL SHOULD COME TO THIS LABEL FROM A GOTO ONLY IF WE ARE
*      PROCESSING A COMMENT.
L6:
            STMNT'NO ← STMNT'NO + 1;
        ENDFOR;

         CLOSE'SEQ'FILE(FILE'SOURCE'NO//HELP());
*      CHECK IF AN ERROR OCCURED IN PASS ONE.
         IF ERROR'COUNT > 0
         DO;
            PUTN(ERROR'COUNT, 0);
            PUTA(" ERRORS ENCOUNTERED IN PASS ONE.  ASSEMBLY TERMINATED.",
             1);
            CLOSE'SEQ'FILE(FILE'OBJECT'NO//HELP());
            CLOSE'SEQ'FILE(FILE'LIST'NO//HELP()) IF FILE'LIST'NO > 0;
            CLOSE'SEQ'FILE(FILE'TABLE'NO//HELP()) IF FILE'TABLE'NO > 0;
            RETURN;
        ENDIF;
PASS2:
        FILE'SOURCE'NO ← OPEN'SEQ'FILE(INNAME, READ'FILE, SYMBOLIC'FILE,
         8// HELP());

*      BEGIN PASS 2.

         STMNT'NO ← 1;
        NEXT'ONE ← LAST'SYMBOL + 1;
        XREF'OPTION ← XREF'OPTION - 1;
        DONE ← 0;
        WHILE NOT DONE
         DO;
            TEXT ← INPUT'SEQ'FILE(FILE'SOURCE'NO, TEXT//HELP());
            DISPLAY ← TEXT;
*          IF WE HAVE A NULL LINE OR A COMMENT IGNORE IT.
             I4 ← BYTE'COUNT ← 0;
            OPINDEX ← 52;
*          THIS IS TO INSURE THAT THE COMMENTS WILL BE PRINTED OUT
*          CORRECTLY.
           IF LENGTH(DISPLAY) = 1 DO;
               SETS(TEXT);
               SETS(DISPLAY);
               WCI(155B, TEXT);
               WCI(152B, TEXT);
               DISPLAY ← TEXT;
           ENDIF;
             GOTO NULL IF LENGTH(DISPLAY) = 2;
            C1 ← GCI(DISPLAY);
            DISPLAY ← TEXT;
            PSEUDO'COMMENT() & GOTO NULL IF C1 = '*' OR C1 = ';';
            GCD(TEXT);
            GCD(TEXT);
            PARSE(TEXT, L'FIELD, I'FIELD, O'FIELD:
             TEXT, L'FIELD, I'FIELD, O'FIELD);
            WHILE LENGTH(L'FIELD) < 5
             DO;
                WCI(' ', L'FIELD);
            ENDFOR;
            WHILE LENGTH(I'FIELD) < 4
             DO;
                WCI(' ', I'FIELD);
            ENDFOR;
            OPINDEX ← SEARCH'TABLE(INSTR'OPCODES, I'FIELD, 86//
             PUTA("SEARCH'TABLE FAILED.", 1) & EXIT());
            I4 ← BYTE'COUNT ← INSTR'INCRE[OPINDEX];
            I1 ← INSTR'CODES[OPINDEX];
            WORD$BYTE'1 ← I1$BYTE'3;
            I3 ← INDEX(O'FIELD, ",");
            IF (I3 # 0)  AND  (OPINDEX # 22)  /* OPINDEX=22 IS A  */
             DO;                     /* "DB" INSTRUCTION.  */
                I1 ← EVALUATE(SUBSTR(O'FIELD, 1, I3 - 1, DOPE));
                O'FIELD ← CHOP(O'FIELD, I3);
                I2 ← EVALUATE(O'FIELD);
            ELSE
             DO;
                I2 ← 70000;
                I1 ← EVALUATE(O'FIELD);
            ENDIF;

*      TRANSFER CONTROL

             GOTO INSTR'BRANCH[OPINDEX];

CMC:
STC:
            GOTO END1;

INR:
DCR:
            ERROR'MSG(11) IF I1 < 0 OR I1 > 7;
            WORD$BITS'2'4 ← I1 $BITS'21'23;
            GOTO END1;

CMA:
DAA:
NOP:
            GOTO END1;

MOV:
            ERROR'MSG(10) IF I2 = 70000;
            ERROR'MSG(11) IF I1 < 0 OR I1 > 7;
            ERROR'MSG(11) IF I2 < 0 OR I2 > 7;
            WORD$BITS'2'4 ← I1$BITS'21'23;
            WORD$BITS'5'7 ← I2$BITS'21'23;
            GOTO END1;

STAX:
LDAX:
            ERROR'MSG(11) IF I1 < 0 OR I1 > 7;
            WORD$BITS'3'3 ← I1$BITS'22'22;
            GOTO END1;

ADD:
ADC:
SUB:
SBB:
ANA:
XRA:
ORA:
CMP:
            ERROR'MSG(11) IF I1 < 0 OR I1 > 7;
            WORD$BITS'5'7 ← I1$BITS'21'23;
            GOTO END1;

RLC:
RRC:
RAL:
RAR:
            GOTO END1;

PUSH:
POPL:
DAD:
INX:
DCX:
            ERROR'MSG(11) IF I1 < 0 OR I1 > 7;
            WORD$BITS'2'3 ← I1$BITS'21'22;
            GOTO END1;

XCHG:
XTHL:
SPHL:
            GOTO END1;

ADI:
ACI:
SUI:
SBI:
ANI:
XRI:
ORI:
CPI:
            ERROR'MSG(12) IF I1 < -256 OR I1 > 255;
            WORD$BYTE'2 ← I1$BYTE'3;
            GOTO END1;

STA:
LDA:
SHLD:
LHLD:
            WORD$BYTE'2 ← I1$BYTE'3;
            WORD$BYTE'3 ← I1$BYTE'2;
            GOTO END1;

RIM:
SIM:
       GOTO END1;

PCHL:
            GOTO END1;

JMP:
JNZ:
JNC:
JC:
JPO:
JPE:
JZ:
JP:
JM:
            WORD$BYTE'2 ← I1$BYTE'3;
            WORD$BYTE'3 ← I1$BYTE'2;
            GOTO END1;

CALL:
CC:
CNC:
CZ:
CNZ:
CM:
CP:
CPE:
CPO:
            WORD$BYTE'2 ← I1$BYTE'3;
            WORD$BYTE'3 ← I1$BYTE'2;
            GOTO END1;

RET:
RC:
RNC:
RZ:
RNZ:
RM:
RP:
RPE:
RPO:
            GOTO END1;

RST:
            ERROR'MSG(11) IF I1 < 0 OR I1 > 7;
            WORD$BITS'2'4 ← I1$BITS'21'23;
            GOTO END1;

EI:
DI:
            GOTO END1;

IN:
OUT:
            ERROR'MSG(12) IF I1 < 0 OR I1 > 255;
            WORD$BYTE'2 ← I1$BYTE'3;
            GOTO END1;

HLT:
            GOTO END1;

ORGL:
            L'COUNTER ← I1;
            BYTE'COUNT ← -2;
            GOTO END1;

EQU:
            BYTE'COUNT ← -1;
            GOTO END1;

DB:
            WORD$BYTE'1 ← I1$BYTE'3;
            GOTO END1;

DW:
            WORD$BYTE'1 ← I1$BYTE'3;
            WORD$BYTE'2 ← I1$BYTE'2;
            GOTO END1;

DS:
            BYTE'COUNT ← -2;
            I4 ← I1;
            GOTO END1;

ENDL:

             DONE ← 1;
            BYTE'COUNT ← 0;
            GOTO END1;

MVI:
            ERROR'MSG(10) IF I2 = 70000;
            ERROR'MSG(11) IF I1 < 0 OR I1 > 7;
            ERROR'MSG(12) IF I2 > 255 AND I2 # 70000;
            WORD$BITS'2'4 ← I1$BITS'21'23;
            WORD$BYTE'2 ← I2$BYTE'3;
            GOTO END1;
LXI:
            ERROR'MSG(10) IF I2 = 70000;
            ERROR'MSG(11) IF I1 < 0 OR I1 > 6;
            WORD$BITS'2'3 ← I1$BITS'21'22;
            WORD$BYTE'2 ← I2$BYTE'3;
            WORD$BYTE'3 ← I2$BYTE'2;
            GOTO END1;
END1:
            OUT'CODE(WORD, BYTE'COUNT, L'COUNTER);
NULL:       /*  CONTROL COMES TO HERE WHEN WE A PROCESSING A COMMENT.  */
            OUTLINE(FILE'LIST'NO, WORD, BYTE'COUNT);
            STMNT'NO ← STMNT'NO + 1;
            L'COUNTER ← L'COUNTER + I4;
        ENDFOR;
        OUT'CODE(WORD, 1, 0);  /*  FLUSH OUT THE OBJECT CODE BUFFER.  */
        OUT'CODE(WORD, 4, 0);  /*  WRITE AN END-OF-RECORD MARK.  */
        PRINT'XREF() IF XREF'OPTION = 0 AND LAST'SYMBOL # 0;
        DUMP'SYMBOL(FILE'TABLE'NO) IF FILE'TABLE'NO > 0;
        CLOSE'SEQ'FILE(FILE'SOURCE'NO//HELP());
        CLOSE'SEQ'FILE(FILE'OBJECT'NO//HELP());
        CLOSE'SEQ'FILE(FILE'LIST'NO//HELP()) IF FILE'LIST'NO > 0;
FINISHED:
        RETURN;
        END;  /*  END OF ASSEMBLE.  */

        COMMON MESSAGE'BLOCK;

         DECLARE STRING(60) ARRAYONE MESSAGES[12];
        DECLARE STRING(60) ARRAYONE MESSAGES[1] ←

         ("SYMBOL WAS NOT FOUND.",
         "CONVERSION ERROR FOR HEX NUMBER.",
         "CONVERSION ERROR FOR DECIMAL NUMBER.",
         "LITERAL DID NOT FOLLOW AFTER QUOTE.",
         "LABEL IS GREATER THAN 5 CHARACTERS LONG.",
         "LABEL STARTS WITH A NUMBER.",
         "DUPLICATE LABEL FOUND.",
         "NO OPCODE FIELD FOUND.");

         DECLARE STRING(60) ARRAYONE MESSAGES[9] ←
         ("ILLEGAL OPCODE IN STATEMENT.",
         "2 OPERANDS REQUIRED.  ONLY ONE FOUND.",
         "REGISTER VALUE SPECIFIED OUT OF RANGE.",
         "OPERAND IS LARGER THAN 8 BITS.");
        END;  /*  END OF MESSAGE BLOCK  */
        PROGRAM ERROR'MSG;

         INCLUDE ASSM'VARIABLES, MESSAGE'BLOCK, SPECIAL'CHARS;

         DECLARE INTEGER
         ERROR'NO;

         DECLARE STRING
         STR1,
         OUT'STR(200);
        FUNCTION ERROR'MSG(ERROR'NO);

         SETS(OUT'STR, 0, 0);
        WCI(CR, OUT'STR);
        WCI(LF, OUT'STR);
        CNS(STMNT'NO, OUT'STR, 0, 10//HELP());
        WCI(CR, OUT'STR);
        WCI(LF, OUT'STR);
        IF ERROR'NO < 13
         DO;
            APPEND(OUT'STR, "          "//HELP());
            STR1 ← MESSAGES[ERROR'NO];
            APPEND(OUT'STR, STR1//HELP());
            WCI(CR, OUT'STR);
            WCI(LF, OUT'STR);
        ENDIF;
        PUTA(OUT'STR, 1);
        IF FILE'LIST'NO > 0
         DO;
            OUTPUT'SEQ'FILE(FILE'LIST'NO, OUT'STR//HELP());
        ENDIF;
        PUTA(DISPLAY, 0);
        ERROR'COUNT ← ERROR'COUNT + 1;
        RETURN;
        END;  /*  END OF ERROR'MSG.  */
        PROGRAM HELP;

       INCLUDE ASSM'VARIABLES, MESSAGE'BLOCK, SPECIAL'CHARS;

        FUNCTION HELP();
       PUTA(DISPLAY, 1);
        PUTA("HELP!!!!!!!", 1);
BREAK:  EXIT();
        END;  /*  END OF HELP  */
        PROGRAM UPDATE'BUFFR;

         DECLARE INTEGER
         BYTE'COUNT,
         CODE,
         CHK'SUM,
         I1;

         DECLARE STRING
         BUFFR;

         DECLARE FIELD
         BYTE'1 (0:0, 7),
         BYTE'2 (0:8,15),
         BYTE'3 (0:16, 23);


         FUNCTION UPDATE'BUFFR(BUFFR, BYTE'COUNT, CODE, CHK'SUM);

         FOR I1 ← 1 TO BYTE'COUNT
         DO;
            BUFFR ← HEXOUT(CODE$BYTE'1, BUFFR, 1);
            CHK'SUM$BYTE'3 ← CHK'SUM$BYTE'3 + CODE$BYTE'1;
            CODE ← CODE LCY 8;
        ENDFOR;
        RETURN (BUFFR, BYTE'COUNT, CODE, CHK'SUM);

         END;  /*  END OF UPDATE'BUFFR.  */

        PROGRAM OUTPUT'RECORD;

         INCLUDE SPECIAL'CHARS, ASSM'VARIABLES;

         DECLARE INTEGER
         FNO,
         SA,
         CHK'SUM,
         I1;

         DECLARE STRING
         BUFFR,
         STR1(100),
         STR2(2);

         DECLARE FIELD
         BYTE'1 (0:0,7),
         BYTE'2 (0:8,15),
         BYTE'3 (0:16,23),
         BITS'8'23 (0:8,23);

         FUNCTION OUTPUT'RECORD(FNO, BUFFR, SA, CHK'SUM);

         SCOPY(STR1, ":"//HELP());
        I1 ← LENGTH(BUFFR) / 2;
        STR1 ← HEXOUT(I1$BYTE'3, STR1, 1);
        CHK'SUM$BYTE'3 ← CHK'SUM$BYTE'3 + I1$BYTE'3;
        CHK'SUM$BYTE'3 ← CHK'SUM$BYTE'3 + SA$BYTE'2;
        CHK'SUM$BYTE'3 ← CHK'SUM$BYTE'3 + SA$BYTE'3;
        STR1 ← HEXOUT(SA$BITS'8'23, STR1, 2);
*       OUTPUT THE RECORD NUMBER FOR ALAN RICH'S LOADER.

         STR1 ← HEXOUT(RECORD'NO$BYTE'3, STR1, 1);
*        DON'T FORGET TO UPDATE THE CHECK SUM.
         CHK'SUM$BYTE'3 ← CHK'SUM$BYTE'3 + RECORD'NO$BYTE'3;
        RECORD'NO$BYTE'3 ← RECORD'NO$BYTE'3 + 1;

         APPEND(STR1, BUFFR//HELP());
        CHK'SUM$BYTE'3 ← -(CHK'SUM$BYTE'3);
        STR1 ← HEXOUT(CHK'SUM$BYTE'3, STR1, 1);
        WCI(CR, STR1);
        WCI(LF, STR1);
        OUTPUT'SEQ'FILE(FNO, STR1//HELP());
        RETURN;

         END;  /*  END OF OUTPUT'RECORD.  */

        PROGRAM OUT'CODE;

         INCLUDE ASSM'VARIABLES;

         DECLARE INTEGER
         CODE,
         BYTE'COUNT,
         ADDR1;

         FUNCTION OUT'CODE(CODE, BYTE'COUNT, ADDR1);

         RETURN IF BYTE'COUNT <= 0;
        IF BYTE'COUNT = 4
*       THIS MEANS WRITE OUT AND END OF FILE MARK ON TAPE.
         DO;
            SETS(BUFFR, 0, 0);
            CHK'SUM ← 0;
            OUTPUT'RECORD(FILE'OBJECT'NO, BUFFR, 0, CHK'SUM);
            RETURN;
        ENDIF;
        IF FIRST'TIME = 1
         DO;
            FIRST'TIME ← 0;
            SA ← ADDR1;
            EXPECTED ← ADDR1 + BYTE'COUNT;
            CHK'SUM ← 0;
            SETS(BUFFR, 0, 0);
            UPDATE'BUFFR(BUFFR, BYTE'COUNT, CODE, CHK'SUM:
             BUFFR, BYTE'COUNT, CODE, CHK'SUM);
            RETURN;
        ENDIF;
        IF ADDR1 # EXPECTED OR LENGTH(BUFFR) > 55
         DO;
            OUTPUT'RECORD(FILE'OBJECT'NO, BUFFR, SA, CHK'SUM);
            CHK'SUM ← 0;
            SA ← ADDR1;
            EXPECTED ← ADDR1 + BYTE'COUNT;
            SETS(BUFFR, 0, 0);
            UPDATE'BUFFR(BUFFR, BYTE'COUNT, CODE, CHK'SUM:
             BUFFR, BYTE'COUNT, CODE, CHK'SUM);
            RETURN;
        ENDIF;
        UPDATE'BUFFR(BUFFR, BYTE'COUNT, CODE, CHK'SUM:
         BUFFR, BYTE'COUNT, CODE, CHK'SUM);
        EXPECTED ← EXPECTED + BYTE'COUNT;
        RETURN;

         END;  /*  END OF OUT'CODE.  */

        PROGRAM NEW'PAGE'1;

         INCLUDE ASSM'VARIABLES, SPECIAL'CHARS;

         DECLARE STRING
         OUT'STR(200);

         FUNCTION NEW'PAGE'1();


         RETURN IF FILE'LIST'NO < 0;

         SETS(OUT'STR, 0, 0);
        IF FIRST'PAGE = 1
         DO;
            FIRST'PAGE ← 0;
            WCI(' ', OUT'STR);
        ELSE
         DO;
            WCI(154B, OUT'STR);
        ENDIF;
        WCI(LF, OUT'STR);
        WCI(LF, OUT'STR);
        WCI(LF, OUT'STR);
        WCI(LF, OUT'STR);
        WCI(135B, OUT'STR);
        WCI(24, OUT'STR);
        APPEND(OUT'STR, TITLE'PAGE//HELP());
        WCI(135B, OUT'STR);
        WCI(9, OUT'STR);
        APPEND(OUT'STR, "PAGE "//HELP());
        CNS(PAGE'COUNT, OUT'STR, 4, 10//HELP());
        OUTPUT'SEQ'FILE(FILE'LIST'NO, OUT'STR//HELP());
        SETS(OUT'STR, 0, 0);
        WCI(CR, OUT'STR);
        WCI(LF, OUT'STR);
        WCI(LF, OUT'STR);
        WCI(LF, OUT'STR);
        APPEND(OUT'STR, "STMNT  LC    CODE"//HELP());
        WCI(135B, OUT'STR);
        WCI(10, OUT'STR);
        APPEND(OUT'STR, "STATEMENT"//HELP());
        WCI(CR, OUT'STR);
        WCI(LF, OUT'STR);
        WCI(LF, OUT'STR);
        OUTPUT'SEQ'FILE(FILE'LIST'NO, OUT'STR//HELP());
        PAGE'COUNT ← PAGE'COUNT + 1;
        LINE'COUNT ← 5;
        RETURN;

         END;  /*  END OF NEW'PAGE'1.  */
        PROGRAM NEW'PAGE'2;

         INCLUDE ASSM'VARIABLES, SPECIAL'CHARS;

         DECLARE STRING
         OUT'STR(200);

         FUNCTION NEW'PAGE'2();


         SETS(OUT'STR, 0, 0);
        WCI(154B, OUT'STR);
        WCI(LF, OUT'STR);
        WCI(LF, OUT'STR);
        WCI(LF, OUT'STR);
        WCI(LF, OUT'STR);
        WCI(135B, OUT'STR);
        WCI(23, OUT'STR);
        APPEND(OUT'STR, "CROSS-REFERENCE LISTING"//HELP());
        WCI(135B, OUT'STR);
        WCI(15, OUT'STR);
        APPEND(OUT'STR, "PAGE "//HELP());
        CNS(PAGE'COUNT, OUT'STR, 4, 10//HELP());
        WCI(CR, OUT'STR);
        WCI(LF, OUT'STR);
        WCI(LF, OUT'STR);
        OUTPUT'SEQ'FILE(FILE'LIST'NO, OUT'STR//HELP());
        SCOPY(OUT'STR, "  DCL AT.  VALUE   SYMBOL       REFERENCED AT"//
         HELP());
        WCI(CR, OUT'STR);
        WCI(LF, OUT'STR);
        WCI(LF, OUT'STR);
        OUTPUT'SEQ'FILE(FILE'LIST'NO, OUT'STR//HELP());
        LINE'COUNT ← 5;
        PAGE'COUNT ← PAGE'COUNT + 1;
        RETURN;

         END;  /*  END OF NEW'PAGE'2.  */
        PROGRAM ADD'TO'LIST;

         INCLUDE ASSM'VARIABLES;

         DECLARE FIELD
         XREF'AT (0:0, 11),
         NEXT'PTR (0:12, 23);

         DECLARE INTEGER
         I1,
         INDEX'NO,
         PREVIOUS;

         FUNCTION ADD'TO'LIST(INDEX'NO);

         I1 ← INDEX'NO;
        WHILE I1 # 0
         DO;
            PREVIOUS ← I1;
            I1 ← XREF'TABLE[I1]$NEXT'PTR;
        ENDFOR;
        XREF'TABLE[PREVIOUS]$NEXT'PTR ← NEXT'ONE;
        XREF'TABLE[NEXT'ONE]$XREF'AT ← STMNT'NO;
        XREF'TABLE[NEXT'ONE]$NEXT'PTR ← 0;
        NEXT'ONE ← NEXT'ONE + 1;
        RETURN;

         END;  /*  END OF ADD'TO'LIST.  */
        PROGRAM PRINT'XREF;

         INCLUDE ASSM'VARIABLES, SPECIAL'CHARS;

         DECLARE FIELD
         XREF'AT (0:0, 11),
         NEXT'PTR (0:12, 23);

         DECLARE INTEGER
         I1, I2;

         DECLARE STRING
         STR1,
         OUT'STR(200);

         FUNCTION PRINT'XREF();

         RETURN IF FILE'LIST'NO < 0;
        NEW'PAGE'2();


         FOR I1 ← 1 TO LAST'SYMBOL
         DO;
            SETS(OUT'STR, 0, 0);
            CNS(XREF'TABLE[I1]$XREF'AT, OUT'STR, 5, 10//HELP());
            APPEND(OUT'STR, "      "//HELP());
            OUT'STR ← HEXOUT(VALUES[I1], OUT'STR, 2);
            APPEND(OUT'STR, "      "//HELP());
            STR1 ← SYMBOL[I1];
            APPEND(OUT'STR, STR1//HELP());
            APPEND(OUT'STR, "     "//HELP());
            I2 ← XREF'TABLE[I1]$NEXT'PTR;
            WHILE I2 # 0
             DO;
                IF LENGTH(OUT'STR) > 64
                 DO;
                    WCI(CR, OUT'STR);
                    WCI(LF, OUT'STR);
                    OUTPUT'SEQ'FILE(FILE'LIST'NO, OUT'STR//HELP());
                    SETS(OUT'STR, 0, 0);
                    APPEND(OUT'STR,
                     "                               "//HELP());
                    LINE'COUNT ← LINE'COUNT + 1;
                    NEW'PAGE'2() IF LINE'COUNT > 57;
                ENDIF;
                CNS(XREF'TABLE[I2]$XREF'AT, OUT'STR, 0, 10//HELP());
                WCI(',', OUT'STR);
                I2 ← XREF'TABLE[I2]$ NEXT'PTR;
            ENDFOR;
            GCD(OUT'STR);
            WCI(CR, OUT'STR);
            WCI(LF, OUT'STR);
            OUTPUT'SEQ'FILE(FILE'LIST'NO, OUT'STR//HELP());
            SETS(OUT'STR, 0, 0);
            LINE'COUNT ← LINE'COUNT + 1;
            NEW'PAGE'2() IF LINE'COUNT > 57;
        ENDFOR;
        RETURN;

         END;  /*  END OF PRINT'XREF.  */
        PROGRAM PSEUDO'COMMENT;


         INCLUDE ASSM'VARIABLES, SPECIAL'CHARS;

         DECLARE INTEGER
         I1, I2, C1, DONE;

         DECLARE STRING TMP1, STR1(10);

         DECLARE LABEL ARRAY CASE[5] ←
         (CASE0, CASE1, CASE2, CASE3, CASE4);

         FUNCTION PSEUDO'COMMENT();

         TMP1 ← DISPLAY;
        I2 ← INDEX(TMP1, "%");
        IF I2 # 0
         DO;
            TMP1 ← CHOP(TMP1, I2);
            C1 ← GCI(TMP1// RETURN);
            WHILE C1 = ' '
             DO;
                C1 ← GCI(TMP1// RETURN);
            ENDFOR;
            WCD(C1, TMP1);
            SETS(STR1, 0, 0);
            WHILE C1 # ' ' AND C1 # CR
             DO;
                WCI(C1, STR1// RETURN);
                C1 ← GCI(TMP1// RETURN);
            ENDFOR;
            GCI(STR1);
            DONE ← I1 ← 0;
            WHILE I1 < 4 AND NOT DONE
             DO;
                IF INDEX(STR1, COMMANDS[I1]) # 0
                 DO;
                    DONE ← 1;
                ELSE
                 DO;
                    I1 ← I1 + 1;
                ENDIF;
            ENDFOR;

             GOTO CASE[I1];

*  TITLE OPTION
CASE0:
            GCD(TMP1);
            GCD(TMP1);
            SETS(TITLE'PAGE, 0, 0);
            FOR I1 ← 1 TO 28
             DO;
                C1 ← GCI(TMP1//C1 ← ' ');
                WCI(C1, TITLE'PAGE);
            ENDFOR;
            GOTO COM;

*  NOPRINT OPTION
CASE1:
            LIST'OPTION ← 0;
            GOTO COM;

*  PRINT OPTION
CASE2:
            LIST'OPTION ← 1;
            GOTO COM;

*    PAGE OPTION.
CASE3:

             NEW'PAGE'1();
            GOTO COM;

*  ERROR.  UNRECOGNIZABLE COMMAND.
CASE4:
            ERROR'MSG(13);

COM:
        ENDIF;
        RETURN;

         END;  /*  END OF PSEUDO'COMMENT.  */
        PROGRAM DUMP'SYMBOL;

         INCLUDE SPECIAL'CHARS, ASSM'VARIABLES;

         DECLARE INTEGER
         I1, I2, I3,
         FILE'NO;

         DECLARE STRING
         STR1,
         BUFR(100);

         FUNCTION DUMP'SYMBOL(FILE'NO);

         FOR I1 ← 1 BY 5 TO LAST'SYMBOL
         DO;
            SETS(BUFR,0,0);
            I2 ← I1;
            I3 ← I1 + 5;
            WHILE I2 <= LAST'SYMBOL AND I2 < I3
             DO;
                STR1 ← SYMBOL[I2];
                APPEND(BUFR,STR1//HELP());
                WCI(',',BUFR);
                CNS(VALUES[I2],BUFR,0,16//HELP());
                WCI(',',BUFR);
                I2 ← I2+1;
            ENDFOR;
            GCD(BUFR);
            WCI(CR,BUFR);
            WCI(LF,BUFR);
            OUTPUT'SEQ'FILE(FILE'NO,BUFR//HELP());
        ENDFOR;
        CLOSE'SEQ'FILE(FILE'NO//HELP());
        RETURN;

         END;  /*  END OF DUMP'SYMBOL  */
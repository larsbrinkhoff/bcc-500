        COMMON SYSCALLS;

* MCALL DECLARATIONS

         MACRO ARBMC←UNKNOWN MONITOR;
        MACRO INTMC←INTEGER MONITOR;
        MACRO STMC←STRING MONITOR;
        MACRO LNMC←LONG MONITOR;
        MACRO LNLNMC←LONGLONG MONITOR;

* CALLS TO MANIPULATE MIBS AND SIBS
         INTMC CREATE'MIB←190;
        ARBMC READ'MIBOB'INDEX←0;
        ARBMC READ'MIBOB'NAME←1;
        ARBMC SET'MIBOB'NAME←2;
        ARBMC SET'MIBOB'ACCESS←3;
        ARBMC SET'LOCK'LIST←4;
        ARBMC DELETE'MIBOB←5;
        INTMC CREATE'MIBOB←6;
        ARBMC SET'MIB'ACCESS←10;
        INTMC READ'MIB'ACCESS←11;
        ARBMC SET'MIBOB'VALUE←12;
        INTMC COPY'MIBOB←14;* UNIMPLEMENTED
        ARBMC SET'NO'CHARGE←15;*** ???
        INTMC READ'MIB'SPACE←16;
        ARBMC SET'FILE'LOCK←18;*?* UNIMPLEMENTED
        ARBMC SET'DURABILITY←28;*** ???

* OFT CALLS
         INTMC MOPEN'FILE←19;
        ARBMC MREAD'OFT←20;
        ARBMC SET'OFT'AL←21;
        INTMC MSET'OFT'CL←22;
        ARBMC SET'FILE'LENGTH←23;* IMPROVE THIS FOR UTS
        INTMC CR'FILE'PAGE←24;
        INTMC DEL'FILE'PAGE←25;
        INTMC NEXT'FILE'PAGE←26;
        ARBMC MOVE'PAGE'PMT←27;

* PMT CALLS
         INTMC ACQUIRE'PMT←50;
        ARBMC NEW'PMT'PAGE←51;
        ARBMC CLEAR'PMT←53;
        ARBMC DELETE'PMT←54;
        ARBMC SET'PMT'AL←55;
        ARBMC SET'PMT'CL←56;
        ARBMC SET'PMT'RO←57;
        ARBMC READ'PMT←58;

* WORKING SET CALLS
         ARBMC PUT'PAGE'DWS←65;
        ARBMC PUT'PAGE'CWS←66;
        INTMC DEL'PAGE'DWS←67;
        INTMC DEL'PAGE'CWS←68;
        INTMC READ'LWS←70;
        ARBMC SET'LWS←71;

* SPT CALLS
         INTMC MCREATE'SP←90;
        ARBMC MDESTROY'SP←91;
        ARBMC MREAD'SPT←95;
        ARBMC READ'SPCS←96;
        INTMC MRD'SPT'FIELD←97;
        ARBMC MST'SPT'FIELD←98;
        ARBMC READ'MAP←99;
        ARBMC SET'MAP←100;
        INTMC READ'MAP'BYTE←101;
        ARBMC SET'MAP'BYTE←102;
        INTMC READ'SPS'PARAM←106;

* SPCS CALLS
         ARBMC SP'CALL←111;
        ARBMC SP'JUMP←112;
        ARBMC SP'TRAP←113;
        ARBMC TRAP'RETURN←114;
        ARBMC SP'BRANCH←115;
        ARBMC SP'RETURN←116;
        ARBMC JUMP'RETURN←117;
        ARBMC MARK'CALL←118;
        ARBMC DELETE'CALL←119;
        ARBMC MODIFY'CALL←120;

* PROCESS CALLS
        INTMC COPY'PMT'PROC←130;
        INTMC   ATTACH'PROC←131;
        INTMC ACTIVATE'PROC←132;
        ARBMC TRANSFER'TERM←133;
        ARBMC MAKE'DORMANT←134;
        ARBMC INIT'PROC'PAGE←135;
        ARBMC INIT'PROC'MAP←136;
        ARBMC INIT'SPT←137;
        INTMC READ'PROC'PARAM←211;
        INTMC SET'PROC'PARAM←212;

* IWS CALLS
         ARBMC SET'PROC'INT←163;
        ARBMC QUIT'BLOCK←164;
        INTMC GET'INT'NO←165;
        ARBMC READ'ICT←166;
        ARBMC ALLOW'INTS←168;
        ARBMC REFUSE'INTS←169;
        ARBMC BLOCK←170;
        ARBMC SET'ICT←172;
        ARBMC SET'ICT'CL←173;
        INTMC ACQUIRE'ICT←174;

* CHIO CALLS
         ARBMC SET'LINE'FIELD←180;
        ARBMC READ'LINE'TABLE←181;
        ARBMC READ'STRING'BRK←182;
        ARBMC WRITE'STRING←183;

* MISCELLANEOUS
         ARBMC MON'LOCK←29;*           LOCK SYSTEM OBJECT
         ARBMC MON'UNLOCK←30;*         UNLOCK SYSTEM OBJECT
         LNMC READ'CLOCK←210;
        ARBMC READ'WRITE'CM←255;    * ABSOLUTE MEMORY READ/WRITE

* UCALL DECLARATIONS

         MACRO ARBUC←UNKNOWN UTILITY;
        MACRO INTUC←INTEGER UTILITY;
        MACRO CHRUC←CHARACTER UTILITY;
        MACRO STUC←STRING UTILITY;
        MACRO LNUC←LONG UTILITY;

* MISCELLANEOUS UCALLS
         ARBUC BREAK'POINT←0;*             UCALL FOR DEBUGGING PROGRAMS
        STUC ERRORMSG←1;*                RETURN SYSTEM ERROR MESSAGE
        STUC GET'PARAM←2;*               STRIP PARAMETER FROM STRING
        STUC GET'COM'LINE←3;*            GET CURRENT COMMAND LINE FROM UTS
        INTUC ABRV'LKP←4;*                LOOK UP ABBREVIATED NAME IN STARY
        INTUC CON'ABRV'LKP←5;*            CONTINUE SAME IN NEW STARY
       ARBUC SET'COM'LINE ← 7;*           SET THE SAVED COMMAND LINE
       ARBUC SET'SAVED'USER ← 8;*         SET THE SAVED USER NO IN UTS
        STUC SYSTEM'VERSION ← 9;*      READ OUT THE CURRENT SYSTEM VERSION

* FILE SYSTEM CALLS
         ARBUC NAME'SEARCH←10;*            CONVERT FILE ST TO UTS NAME
        ARBUC SPECIAL'SEARCH←11;*         VARIATION OF ABOVE
        INTUC CONV'NAME←12;*              CONVERT FROM UTS TO MON FILE NAME
        ARBUC SPREAD'NAME←13;*            SPLIT FILE NAME STRING INTO COMP.
        ARBUC READ'MIBOB'VALUE←14;*       READ 'VALUE' OF MIB OBJECT
        ARBUC DELETE'FILE←15;*            DELETE FILE AND CONTENTS
        INTUC OPEN'FILE←16;*              OPEN FILE W/WO LOCKING
        ARBUC CLOSE'FILE←17;*             CLOSE AND UNLOCK FILE
        ARBUC READ'OFT←18;*               READ OFT
        INTUC READ'OFT'FIELD←19;*         READ OFT FIELD
        ARBUC SET'OFT'CL←20;*             SET OFT CONTROL LOCK
        ARBUC CONV'KEY←21;*               CONVERT DEFAULT ACCESS KEY

* EXTENDED SPS CALLS
         INTUC CREATE'SSP←30;*             CREATE SUBSIDIARY SUB-PROCESS
        INTUC CREATE'PSP←31;*             CREATE PARALLEL SUB-PROCESS
        ARBUC ATTACH←32;*                 ATTACH PI FILE TO SUB-PROCESS
        ARBUC DESTROY'SP←33;*             DESTROY SUB-PROCESSES
        ARBUC READ'SPT←34;*               READ SPT
        INTUC READ'SPT'FIELD←35;*         READ SPT FIELD
        ARBUC SET'SPT'FIELD←36;*          SET SPT FIELD
        STUC READ'SPNAME←37;*            READ SUB-PROC NAME
        ARBUC SET'SPNAME←38;*             SET SUB-PROC NAME
        INTUC SPNAME'SEARCH←39;*           LOOK UP SP NAME

* CIOS MANIPULATION
         INTUC CREATE'CIOS←40;*            CREATE CONTROL I/O STREAM
        INTUC READ'CIOS'FIELD←41;*        READ CIOS FIELD
        ARBUC SET'CIOS'FIELD←42;*         SET (SOME) CIOS FIELDS
        ARBUC SET'CIOS'INPUT←43;*         SET UP FOR INPUT
        ARBUC SET'CIOS'OUTPUT←44;*        SET UP FOR OUTPUT

* CIOS INPUT/OUTPUT
         ARBUC PRINT'STRING←45;*           WRITE STRING ON CIOS
        ARBUC PRINT'CHAR←46;*             WRITE (= BUFFER) CHAR ON CIOS
        ARBUC START'OUTPUT←47;*           DUMP OUTPUT BUFFER
        STUC READ'LINE←48;*              READ NEXT INPUT LINE
*STUC      EDIT'LINE ← 49;*              EDIT CURRENT LINE
         CHRUC READ'CHAR←50;*              READ NEXT CHARACTER
        ARBUC BLOCK'OB'EMPTY←51;*         WAIT UNTIL OUT BUFFER IS EMPTY

* USER, ACCOUNT, AND GROUP PROFILES
         STUC READ'UP'ITEM←60;*           READ ITEM FROM USER PROFILE
        STUC READ'UP'NAMES←61;*          READ NAMES OF UP ITEMS
        ARBUC SET'UP'ITEM←62;*            SET (CREATE) VALUE OF UP ITEM
        ARBUC SET'UP'ACCESS←63;*          SET ACCESS TO UP ITEM
        LNUC FIND'MIB←64;*               CONVERT USER NAME/NUMBER TO MIB ADDR
        ARBUC CREATE'UP'ENTRY←65;*        CREATE USER/UP ENTRY
        ARBUC DELETE'UP'ENTRY←66;*        DELETE USER/UP ENTRY

* PROCESSES, AND PROCESS PROFILE
        ARBUC CREATE'PROCESS←70;*        CREATE/INITIALIZE PROCESS
        STUC READ'PP'ITEM←71;*           READ ITEM FROM PROCESS PROFILE
        STUC READ'PP'NAMES←72;*          READ NAMES OF PP ITEMS
        ARBUC SET'PP'ITEM←73;*           SET (CREATE) VALUE OF PP ITEM
        ARBUC DESTRY'THIS'PROC←74;*      DESTROY PROCESS
       INTUC ANY'TIME'NUM←81;
       STUC DATE'TIME←82;
       END;

        COMMON DECDECS;
*
* SHORT DECLARATION MACROS FOR SPL
*

         MACRO INT←DECLARE INTEGER;
        MACRO OCT←DECLARE OCTAL;
        MACRO PTR←DECLARE POINTER;
        MACRO CHR←DECLARE CHARACTER;
        MACRO ST←DECLARE STRING;
        MACRO LN←DECLARE LONG;
        MACRO LNLN←DECLARE LONGLONG;
        MACRO LB←DECLARE LABEL;

         MACRO OCTFL←DECLARE OCTAL FIELD;
        MACRO INTFL←DECLARE INTEGER SIGNED FIELD;
        MACRO PTRFL←DECLARE POINTER FIELD;
        MACRO CHRFL←DECLARE CHARACTER FIELD;
        MACRO STFL←DECLARE STRING FIELD;
        MACRO LNFL←DECLARE LONG FIELD;
        MACRO ARYFL←DECLARE ARRAY FIELD;
        MACRO FNFL←DECLARE FUNCTION FIELD;

         MACRO INTARY←DECLARE INTEGER ARRAY;
        MACRO OCTARY←DECLARE OCTAL ARRAY;
        MACRO PTRARY←DECLARE POINTER ARRAY;
        MACRO CHRARY←DECLARE CHARACTER ARRAY;
        MACRO STARY←DECLARE STRING ARRAY;
        MACRO LNARY←DECLARE LONG ARRAY;
        MACRO LBARY←DECLARE LABEL ARRAY;
        MACRO FLARY←DECLARE FIELD ARRAY;
        MACRO FNARY←DECLARE FUNCTION ARRAY;

         MACRO INTARY1←DECLARE INTEGER ARRAYONE;
        MACRO PTRARY1←DECLARE POINTER ARRAYONE;

         MACRO INTFN←DECLARE INTEGER FUNCTION;

         MACRO ARBENT←UNKNOWN ENTRY;
        MACRO INTENT←INTEGER ENTRY;
        MACRO OCTENT←POINTER ENTRY;
        MACRO PTRENT←POINTER ENTRY;
        MACRO CHRENT←CHARACTER ENTRY;
        MACRO STENT←STRING ENTRY;
        MACRO LNENT←LONG ENTRY;
        MACRO LBENT←LABEL ENTRY;
        MACRO ARYENT←ARRAY ENTRY;

         MACRO ARBEXT←DECLARE UNKNOWN EXTERNAL;
        MACRO INTEXT←DECLARE INTEGER EXTERNAL;
        MACRO OCTEXT←DECLARE OCTAL EXTERNAL;
        MACRO PTREXT←DECLARE POINTER EXTERNAL;
        MACRO CHREXT←DECLARE CHARACTER EXTERNAL;
        MACRO STEXT←DECLARE STRING EXTERNAL;
        MACRO LNEXT←DECLARE LONG EXTERNAL;
        MACRO LBEXT←DECLARE LABEL EXTERNAL;
        MACRO ARYEXT←DECLARE ARRAY EXTERNAL;

         MACRO C'(X)←;* KLUDGE FOR INTERNAL COMMENTS

         MACRO LTABLE(F)←F$FLDWDSP+1;
        INTFL FLDWDSP(0:13,23);

* LENGTHS OF NAMES
         INT LMN←4,LTY←1,LFN←LMN+LTY;
        INT NBY←4,LNCH←24/NBY,NMNCH←LMN*NBY,
         NTYCH←LTY*NBY,NFNCH←LFN*NBY,NCMCH←90;
       END;

        COMMON SYS'COMMON; INCLUDE SYSCALLS;

*
* MCALLS, UCALLS, & GLOBAL CELLS
*

         DECLARE INTEGER TRAP'FLAG;
        DECLARE INTEGER QUIT'FLAG;* GLOBAL QUIT FLAG
        DECLARE INTEGER ERMSNO;* SYSTEM ERROR NUMBER
        DECLARE CHARACTER ERCODE;* SYSTEM ERROR CODE
       END;

        COMMON MACHINE'DECS; INCLUDE DECDECS;
*
* DECLARATIONS FOR MACHINE-DEPENDENT PROGRAMMING
*

* MAXIMUM NUMBER OF PERMISSABLE TERMINALS
         INT MAX'TERMS←200;
* PARAMETERS FOR BASING ITEMS IN ACTIVE-USER FILE

        DECLARE PARAMETER TIME'BASE←2043;  */ LAST TIME ACCT FILE BACKED UP /*
        DECLARE PARAMETER ACCT'LOCK←2045;
        DECLARE PARAMETER ENTER'LOCK←2047;
* LOW-G DEFINITIONS
         PTR STACK'PTR= G' [2],STACK'LIM= G' [3],
         RTRAP'PARAM= G' [5],RTRAP'LOC= G' [4];

* FIELDS IN BLL DESCRIPTOR
         PTRFL BRDPC(0:6,23),BRDLR(1:6,23);

* STATE DEFINTIONS
         INT PSTLOC←0,ASTLOC←1,BSTLOC←2,CSTLOC←3,DSTLOC←4,
         XSTLOC←6,LSTLOC←7,GSTLOC←8,ESTLOC←5,SSTLOC←9,
         LSTATE←10;

* FIELDS FOR TRAP DEFINITIONS
         PTRFL ADDR(0:6,23); OCTFL SP'TNO(-2),SP'TPAR(-1),
        BLL'CLASS(0:3,5),UTSE'CLASS(0:0,1),
         UTSE'SPTNO(0:1,5),UTSE'RTNO(0:2,5);
       END;

        COMMON COMDECS; INCLUDE DECDECS,SYS'COMMON;

*
* COMMON DECLARATIONS FOR CODING
*

* GENERALLY USEFUL MACROS

         MACRO NAMSET(S,L,A,B)←SETUP(S,L,A,B) & S$WP←S$EP;
        MACRO EMPTY(S)←LNGDES(S$RP,S$WP)<=0;*** WP=RP OR WP=BP?
        MACRO REPEAT← WHILE 1 DO;
        MACRO ENDRPT← ENDFOR;
        MACRO FDISP(F)←RUNTIME'FAILURE() IF F$FLDSTB#0 OR
         F$FLDSIZE#24 ELSE F$FLDWDSP;
        OCTFL FLDSTB(0:8,12),FLDSIZE(0:3,7);

* ERROR MACROS
         MACRO NC'PUNT←RUNTIME'FAILURE();* FOR NORMAL CALLS (EXPRESSIONS)
        MACRO LF'PUNT← VALUE NC'PUNT;* FOR LIBRARY FUNCTIONS
        MACRO SF'PUNT←LF'PUNT:ERCODE,ERMSNO;* FOR SYSTEM CALLS

* QUIT ACTION MACROS
         MACRO QUIT'PUNT(L)← VALUE GOTO L IF ERCODE='QIT' ELSE
         RUNTIME'FAILURE():ERCODE,ERMSNO;
        MACRO QUIT'PUNTX(L,X)← VALUE GOTO L IF ERCODE='QIT' ELSE
         RUNTIME'FAILURE():X,ERCODE,ERMSNO;

* PARAMETRIC CHARACTER DEFINITIONS
         CHR SCHERALD←'>' C'(/* SUB-COMMAND HERALD */),
         BELCH←303B C'(/* BELL */),NULCH←300B C'(/* NULL */),
         NLCH←307B C'(/* NEW LINE */),
         LFCH←310B C'(/* LINE FEED */),
         MBCH←200B C'(/* ZERO MULTIPLE BLANKS */),
         SQTCH←'&'' C'(/* SINGLE QUOTE */),
         DQTCH←'"' C'(/* DOUBLE QUOTE */),
         SEPCH←'-' C'(/* SEPARATOR */);

* STRING POINTER FIELDS
         OCTFL BP(0) C'(/* BEGINNING */),RP(1) C'(/* READER */),
         WP(2) C'(/* WRITER */),EP(3) C'(/* END */);
* CHARACTER FIELDS
         CHRFL CH0(0:0,7),CH1(0:8,15),CH2(0:16,23);
* BEAD LENGTH FIELD
         PTRFL LENGF(-1:6,23);

* FIELDS IN UTILITY FILE NAME
         LNFL UFNUN(0) C'(/* USER NUMBER/DISK ADDRESS */);
        OCTFL UFNEN(2) C'(/* OBJECT ENTRY-NUMBER */),
         UFNFN(3) C'(/* FILE NAME */),UFNMN(3) C'(/* MAIN NAME */),
         UFNTY(3+LMN) C'(/* TYPE WORD */);

* FIELDS FOR UNO/DKA
         OCTFL UNDKUN(0),
         UNDKDK(1);

         INT LUFN←LTABLE(UFNTY);* LENGTH OF UTILITY FILE:NAME

         INT CB'PMT←1;* PMT ADDRESS OF CONTEXT BLOCK

* DECLARATIONS OF COMMON FUNCTIONS

* SPL RUNTIME FUNCTIONS
*ARBEXT    SCOPY, APPEND, CNS, RUNTIME'FAILURE;
         PTREXT SBASE; INTEXT ARRAYUB,ARRAYLB;* STEXT ST'DESC;
        LNEXT LONG'ADD,LONG'SUB; INTEXT LONG'LE,LONG'LT;

* STORAGE ALLOCATOR
         PTREXT STKMAKE;*, MAKE, SETZONE;
*ARBEXT    STORINIT, SELZONE, EXTZONE, FREE, FREEZONE;
       END;

        COMMON UQNDECS; INCLUDE DECDECS;

* UNIQUE NAME FIELDS
         OCTFL UQNTY(0:0,1),UQNPMB(0:0,0),UQNLFB(0:1,1),
         UQNOWN(0:2,17),UQNHFN(0:18,23);
        OCTFL UQNLFN(1:0,12),UQNLPN(1:13,23),
         UQNSFN(1:0,15),UQNSPN(1:16,23);
       END;

        COMMON BFSDECS; INCLUDE UQNDECS;

* OBJECT TYPE-CODES
         INT SIBSFCD←0,SIBLFCD←1,SIBPRCD←2,SIBAKCD←3,
         SIBRSCD←4,SIBOWCD←5,SIBFRCD←6,
         SIBSCCD←14,SIBLKCD←15;

* ACCESS KEY FIELDS
         OCTFL ACK0(0),ACK1(1:0,7),ACKUN(1:8,23);
        INT NORM'FIL'AC←0357B;* P(NO) F(RW) O(OW) - NORMAL ACCESS
       END;

        COMMON SIBDECS; INCLUDE BFSDECS;
*
* DECLARATIONS FOR SIB
*

* FIELDS IN SIB NAME (SIBN)
         OCTFL SIBNOT(0:1,4),
         SIBNLN(0:10,23),
         SIBNAA(1:1,4),SIBNEN(1:10,23),
         SIBNMN(2),SIBNFN(2);
        OCTFL SIBNTY(SIBNMN$FLDWDSP+LMN),
         SIBNLL(SIBNTY$FLDWDSP+1:4,11),
         SIBNAC(SIBNLL$FLDWDSP:12,23);
        OCTFL SIBNPA(SIBNAC$FLDWDSP:12,15),
         SIBNFA(SIBNAC$FLDWDSP:16,19),
         SIBNOA(SIBNAC$FLDWDSP:20,23);

         INT LSIBN←LTABLE(SIBNOA);* LENGTH OF SIBN TABLE

* FIELDS IN SIB VALUE (SIBV)
         OCTFL SIBVOT(0:1,4),
         SIBVLN(0:10,23),
         SIBVAA(1:1,4),SIBVEN(1:10,23);
        LNFL SIBFLUN(2);
        OCTFL SIBFLLEN(4),
         SIBFLWD(5),
         SIBFLRD(6);

         LNFL SIBLKUN(2);
        OCTFL SIBLKEN(4),
         SIBLKMN(5),
         SIBLKTY(5+LMN);

         INT LSIBFL←LTABLE(SIBFLRD),LSIBLK←LTABLE(SIBLKTY),
         LSIBV←(LSIBFL IF LSIBFL>LSIBLK ELSE LSIBLK);
        INT MLSIB←(LSIBV IF LSIBV>LSIBN ELSE LSIBN);
       END;

        COMMON SPTDECS; INCLUDE DECDECS;

* FIELDS IN SPCS
         OCTFL SPCSNIS(0:0,0),SPCSNIC(0:1,1),
         SPCSCSP(0:2,5),SPCSPR(0:6,23),
         SPCS940M(1:0,0),SPCSR0SP(1:2,5),SPCSLR(1:6,23),
         SPCSR1SP(2:2,5),SPCSGR(2:6,23);
        LNFL SPCSIT(3);
        INT LSPCS←LTABLE(SPCSIT)+1;

         INT NSPT←8;
       END;

        COMMON ICTDECS; INCLUDE DECDECS;
        OCTFL ICTSRC(0:0,2),ICTACT(0:3,5),ICTSPEC(0:6,10),
         ICTBLK(0:11,11),ICTCL(0:15,23);
        LNFL ICTTM(1);
        INT NICT←24,LICT←LTABLE(ICTTM)+1;
        MACRO ICT'SAB(S,A,B)←S@ICTSRC V' A@ICTACT V' B@ICTBLK;
        INT ICTNULCD←ICT'SAB(0,0,0),
         ICTBLKCD←ICT'SAB(1,0,1),
         ICTTRPCD←ICT'SAB(1,2,1),
         ICTRTICD←ICT'SAB(2,1,1),
         ICTRTICD←ICT'SAB(2,1,1);
       END;

        PROGRAM LONG'COMPARE; INCLUDE DECDECS;
*
* COMPARE LONG VALUES
*
         PTR P,Q; INT N,M;

         INTENT LONG'COMPARE(INTEGER @P,INTEGER @Q,N);

         FOR N←N-1 TO 0 DO;
            M←P[N];
            RETURN 1 IF M#Q[N];
        ENDFOR;
        RETURN 0;
        END;

        PROGRAM SCOPY; INCLUDE COMDECS;
        PTR P; ST S,D; STFL A(0);

         ARBENT SCOPY(STRING @P,S), FRETURN;
        D←P.A; P.RP←D$WP←D$RP←D$BP; GOTO L;

         ARBENT APPEND(STRING @P,S), FRETURN;
        D←P.A;

****      CHECK STRING CHARACTER SIZES FOR COMPATABILITY
L:
        REPEAT; WCI(GCI(S// VALUE P.WP←D$WP & RETURN),D// FRETURN); ENDRPT;
        END;

        PROGRAM ST'DESC; INCLUDE COMDECS;
        INT N,S,O; PTR P; ST X;
        STENT ST'DESC(N,P,S,O);

         P←MAKE(S*(N+24/S-1)/24) IF P=0;

         IF S=8 DO;
            .LDA 44B6;
        ELSEIF S=6 DO;
            .LDA 40B6;
        ELSEIF S=12 DO;
            .LDA 50B6;
        ELSEIF S=24 DO;
            .LDA 54B6;
        ELSE DO;
            RUNTIME'FAILURE();
        ENDIF;

         .IOR P; .XMA O; .LSHA 18; .IOR O; .LDX-1; .ASP; .CXA;
        .STA X$BP; .STA X$RP; .STA X$WP; .LDX N; .ASP; .STX X$EP;
        RETURN X;
        END;

        PROGRAM CNS; INCLUDE COMDECS;
        INT N,F,R,T,I,D; PTR P; ST S,B(25); STFL A(0);

         ARBENT CNS(N,STRING @P,F,R), FRETURN;

         S←P.A;
        FRETURN IF R<2 OR R>36;
        T←(-N IF F>=0 AND N<0 ELSE N);
        B$RP←B$WP←B$EP; I←0;
LP:     .LDA T; .LSHD-23; .DIV R; .STA T; .STB D;
        WCD(D+('0' IF D<10 ELSE 'A'-10),B);
        I←I+1; GOTO LP IF T#0;
        WCD('-',B) & I←I+1 IF F>=0 AND N<0;
        F←F A' 77B;
        IF F=0 DO;
            F←I;
        ELSEIF F<=I DO;
            B$RP←INCDES(B$EP,-I);
        ELSE DO;
            WCI(' ',S// FRETURN) FOR I←I+1 TO F;
        ENDIF;
        WCI(D,S// FRETURN)
         FOR D←GCI(B// VALUE P.WP←S$WP & RETURN) WHILE 1;
        END;

        PROGRAM CSN; INCLUDE COMDECS;
        PTR P; INT R,F,D,N,FLB,FLP,PW; ST S; STFL A(0);

         INTENT CSN(STRING @P,R), FRETURN;

         FLB←FLP←0;

AGN:     S←P.A; FRETURN IF R<2 OR R>36;

         IF D←GCI(S// FRETURN)='-' OR D='+' DO;
            F←(1 IF D='-' ELSE 0); D←GCI(S// FRETURN);
        ELSE DO;
            F←0;
        ENDIF;

         D←D-'0' IF D>='0' AND D<='9' ELSE
         D←D-('A'-10) IF D>='A' AND D<='Z' ELSE FRETURN;
        FRETURN IF D>=R; N←D;

         FOR D←GCI(S//Y) REPEAT;
            D←D-'0' IF D>='0' AND D<='9' ELSE
             D←D-('A'-10) IF D>='A' AND D<='Z' ELSE GOTO X;
            GOTO X IF D>=R; N←N*R+D;
        ENDRPT;

X:       IF R<=10 AND (D←D+'A'-10='B' OR D='D') DO;
            IF FLB DO;
                S$RP←INCDES(S$RP,1) IF FLP;
            ELSE DO;
                FLB←-1;
                PW←GCI(S//Z); PW←PW-'0' & FLP←-1 IF PW>='0' AND PW<='9'
                ELSE S$RP←INCDES(S$RP,-1);
Z:              R←8 & GOTO AGN IF D='B' AND R#8;
                R←10 & GOTO AGN IF D='D' AND R#10;
            ENDIF;
        ELSE DO;
            S$RP←INCDES(S$RP,-1);
        ENDIF;
Y:      N←N*R FOR D←1 TO PW IF FLP;
        P.RP←S$RP; RETURN (-N IF F ELSE N);
        END;

        PROGRAM SBASE; INCLUDE COMDECS;
*
* FIND BASE ADDRESS OF WORD-ORIGINED STRING DESCRIPTOR
*
         ST S;

         PTRENT SBASE(S);
        .LDA S$BP; .LDX 1; .ASP; .CXA;
        .CMZ 3B6; .BNE L; .ETR 777777B; RETURN;
L:      RUNTIME'FAILURE();
        END;

        PROGRAM ALENGTH; INCLUDE COMDECS;
*
* COMPUTE ARRAY BOUNDS
*
         PTR A; OCTFL ABW(0);
        INTENT ARRAYUB(A);
        .LDA A.ABW; .CMZ 2B6; .BNE R' [2]; .ETR 17777B;
        .ETR 377777B; RETURN;

         INTENT ARRAYLB(A);
        .LDA A.ABW; .ETR 1B7; .ASHA-21; RETURN;
        END;

        PROGRAM LONG'ARITH; INCLUDE COMDECS;
*
* LONG ARITHMETIC/RELATIONALS
*
         LN X,Y; OCTFL W0(0),W1(1);

         LNENT LONG'ADD(X,Y);* ADD
        .LDA X$W1,ADD Y$W1,CAB;
        .LDA X$W0,ADC Y$W0; RETURN;

         LNENT LONG'SUB(X,Y);* SUBTRACT
        .LDA X$W1,SUB Y$W1,CAB;
        .LDA X$W0,SUC Y$W0; RETURN;

         INTENT LONG'LE(X,Y);* LESS THAN OR EQUALS
        RETURN (1 IF LONG'SUB(X,Y)$W0<=0 ELSE 0);

         INTENT LONG'LT(X,Y);* LESS THAN
        RETURN (1 IF LONG'SUB(X,Y)$W0<0 ELSE 0);

        INTENT LONG'EQ(X,Y);* EQUAL TO
        RETURN (1 IF (X$W0=Y$W0 AND X$W1=Y$W1) ELSE 0);

        END;

        COMMON ALLOC'DECS;

*
* SPL STORAGE ALLOCATOR
*

* THE BASIC STRUCTURE OF A STORAGE BLOCK IS AS IN THE OLD ALLOCATOR,
* I.E. THE WORD BEFORE THE 0'TH WORD OF A BLOCK CONTAINS THE LENGTH
* OF THE BLOCK (NUMBER OF INFORMATION WORDS +1), A FLAG IN BIT 0
* TO SAY THAT THE BLOCK IS FREE, AND A FLAG IN BIT 1 TO SAY THAT
* THE NEXT LOWER BLOCK IS FREE.
         DECLARE FIELD HIDDEN(-1),HSIZE(-1:6,23),HFREE(-1:0,0),
         HFTAG(-1:1,1),HZTAG(-1:2,2);
* FREE STORAGE COMES IN ZONES.  A ZONE CONSISTS OF A ZONE HEADER
* AND A CHAIN OF EXTENSIONS.  THE ZONE HEADER CONTAINS: THE BLOCK
* SIZE FOR THE ZONE (0 MEANS ALL SIZES ARE ALLOWABLE), THE OVERFLOW
* ROUTINE, THE EXTENSION LIST, AND THE FREE LIST ROVER.
         DECLARE FIELD FEXT(0),FLIST(2),FUEXT(3),FUNCTION FIELD FOVX(1);
        DECLARE PARAMETER FZHS←4;
* THE FEXT WORD IN EACH EXTENSION POINTS TO THE NEXT ONE.  THIS CHAIN,
* IS TERMINATED BY A -1.  THE FIRST TWO WORDS
* OF A FREE BLOCK ARE USED TO HOLD THE ADDRESS OF THE NEXT FREE
* BLOCK AND THE PREVIOUS FREE BLOCK.  THIS LIST IS CIRCULAR.
         DECLARE FIELD NBLK(0),PBLK(1);
* FOR FIXED-SIZE ZONES, THE ENTIRE FREE LIST AND THE HIDDEN WORDS
* ARE SET UP AT THE TIME AN EXTENSION IS CREATED.  FOR VARIABLE-SIZED
* ZONES, AN EXTENSION IS SET UP AS A SINGLE FREE BLOCK WHICH IS
* SUBDIVIDED AS THE NEED ARISES.  A FIRST-FIT STRATEGY WITH A "ROVER"
* IS USED FOR THE LATTER.  BLOCKS BELOW A MINIMUM SIZE WILL NOT BE CREATED.
         DECLARE PARAMETER MINSIZ←3;

         DECLARE INFINITY'ZONE,CURRENT'ZONE;* ZONE VARIABLES FOR ALLOCATOR
        END;

        PROGRAM STKMAKE; INCLUDE ALLOC'DECS;
        FIXED;
*
* ALLOCATE LOCAL (STACKED) STORAGE
*
         DECLARE SP= G' [2],SL= G' [3],BLK,SIZE;

         FUNCTION STKMAKE(SIZE);

         RUNTIME'FAILURE() IF SP+SIZE>=SL;
        SP←(BLK←SP+1)+SIZE;
        BLK.HIDDEN←SIZE+1;
        BSET(BLK,0,SIZE);
        RETURN BLK;
        END;

        PROGRAM MAKE; INCLUDE ALLOC'DECS;
*
* ASSIGN BLOCK OF SIZE (A) IN ZONE (B)
*
         DECLARE BLK,ROVER,RSIZE,EBLK,ROVEC;

         FUNCTION MAKE(SIZE,ZONE);

         ZONE←CURRENT'ZONE IF ZONE=0;
        SIZE←SIZE+1;
        GOTO MAKEOV IF ZONE.FLIST<0;
* VARIABLE-SIZED ZONE
         ROVEC←ROVER←ZONE.FLIST;
MAKE1:  RSIZE←ROVER.HSIZE;
        IF RSIZE<SIZE+MINSIZ AND RSIZE#SIZE DO;
            GOTO MAKE1 IF (ROVER←ROVER.NBLK)#ROVEC
             ELSE GOTO MAKEOV;
        ENDIF;
        EBLK←(BLK←ROVER)+ROVER.HSIZE;
        EBLK.HFTAG←0;
        IF ROVER.HSIZE=SIZE DO;
* EXACT FIT
             BLK.HFREE←0;
            ZONE.FLIST←RFB(ROVER,ZONE);
        ELSE DO;
* SPLIT THE BLOCK
             BLK←EBLK-SIZE;
            BLK.HIDDEN←1@HFTAG+SIZE;
            BLK[-2]←-(ROVER.HSIZE←ROVER.HSIZE-SIZE);
        ENDIF;
* COMMON EXIT
         BSET(BLK,0,SIZE-1);
        RETURN BLK;

* OVERFLOW
MAKEOV:  BLK←(ZONE.FOVX)(SIZE-1,ZONE); RETURN BLK;
        END;

        PROGRAM RFB; INCLUDE ALLOC'DECS;
        FUNCTION RFB(RBLK,ZONE);
        IF RBLK.NBLK=RBLK DO;
            RETURN ZONE.FLIST←-1;
        ELSE DO;
            RBLK.NBLK.PBLK←RBLK.PBLK;
            RETURN RBLK.PBLK.NBLK←RBLK.NBLK;
        ENDIF;
       END;

        COMMON USERDECS; INCLUDE COMDECS;
*
* DECLARATIONS FOR USER PROGRAMS
*
         ST OL(NCMCH);* OUTPUT BUFFER FOR USER CONSOLE OUTPUT
        LB TRAP'LABEL;* GO HERE AFTER TRAP
       DECLARE STACK'SIZE←3000;
       DECLARE ARRAY LARGE'STACK[STACK'SIZE];
       DECLARE INITIAL'SP←@LARGE'STACK[0],NORMAL'SL←@LARGE'STACK[STACK'SIZE-1];
       DECLARE INTEGER WAKEUP'TIMER,     /* ICT ENTRY NUMBER FOR BLOCKING */
                       THIS'SUB'PROCESS, /* CURRENT SUBPROCESS NUMBER */
                       PFS'SP'NUMBER,    /* SP NO FOR ACCT FILE BACKUP */
                       KEY,
                       LNO,
                       OFTI,
                       PMTI,
                       THIS'PRTI,
                       THAT'PRTI;
       DECLARE POINTER PTR2, PTR3;
       DECLARE PARAMETER
                       LINKING←0,        /*LOCK 0 RESERVED FOR LINKING*/
                       ACCTING←1,        /*LOCK 1 FOR ACCOUNT FILE*/
                       PRT'BASE←3300B,
                       MAX'PRT←32;
       DECLARE SIGNED FIELD LINE'FIELD(0:0,11);
       DECLARE FIELD
                       MIB'FIELD(0:12,23),
                       PRDET(9:3,3);

* OUTPUT MACROS
         MACRO IOUT()←SETS(OL,0,0);
        MACRO PTCH(C)←WCI(C,OL);
        MACRO PTST(S)←APPEND(OL,S//LF'PUNT);
        MACRO PTNO(N,F,R)←CNS(N,OL,F,R//LF'PUNT);
        MACRO PTDN(N)←PTNO(N,4B7,10);
        MACRO PTON(N)←PTNO(N,4B7,8);
        MACRO PTNL()←WCI(NLCH,OL);
        MACRO PTIS(S)←SCOPY(OL,S//LF'PUNT);
       END;

        COMMON TRAP'DECS; INCLUDE MACHINE'DECS;
        INCLUDE MACHINE'DECS;

* TRAP VARIABLES
         PTR INSTR'LOC;* PTR TO INSTR FOLLOWING ONE CAUSING ABE TRAP
        INT SAVEL;* SAVE L-REG WHILE DOING EAC IN ABE'TRAP
        INT GSAVER; INTARY GSTATE[LSTATE],SP'GSTATE[LSTATE];* GLOBAL TRAP STATES
        INT SP'LEV;* SUBPROCESS LEVEL ON ENTRY
        END;

        PROGRAM USER'ENTRIES; INCLUDE USERDECS,TRAP'DECS;
*
* ENTRY POINTS
*
         FIXED;

         MACRO SAVE'STATE(X)←.STX X[XSTLOC],EAX X[0],STORS,MIN TRAP'FLAG;

* COME HERE AFTER TRAP MESSAGE
T'L:     JUMP'RETURN(
        READ'SPS'PARAM('CSL'//SF'PUNT)-SP'LEV-1//T'R:ERCODE,ERMSNO);
T'R:    SP'RETURN(//SF'PUNT);

* INITIAL AND 'CONTINUE' SUBPROCESS ENTRIES
         ARBENT XXXXXX(), SP'ENTRY ←2;
        ARBENT XXXXXY(), SP'ENTRY ←3;

         .LDA INITIAL'SP,XLA;
        TRAP'LABEL←T'L; TRAP'FLAG←QUIT'FLAG←0;
        STACK'PTR←INITIAL'SP; STACK'LIM←NORMAL'SL;
        SET'SPT'FIELD(-1,'SB',READ'SPT'FIELD(-1,'SB'//SF'PUNT) V' 1B6
         //SF'PUNT);
        SP'LEV←READ'SPS'PARAM('CSL'//SF'PUNT);
        SET'SPT'FIELD(-1,'TM',READ'SPT'FIELD(-1,'TCM'//SF'PUNT)
         //SF'PUNT);
        RUN'USER(); RUNTIME'FAILURE();

* SP'TRAPS COME HERE
         ARBENT XXXSPT(), SP'ENTRY ←0; SAVE'STATE(SP'GSTATE); STRAP();


* RING TRAPS
         ARBENT XXXABE(), TRAP'ENTRY ←1; SAVE'STATE(GSTATE); ABE'TRAP();
        ARBENT XXXFLO(), TRAP'ENTRY ←2; SAVE'STATE(GSTATE); RTRAP(2);
        ARBENT XXXFLU(), TRAP'ENTRY ←3; SAVE'STATE(GSTATE); RTRAP(3);
        ARBENT XXXRO(), TRAP'ENTRY ←4; SAVE'STATE(GSTATE); RTRAP(4);
        ARBENT XXXIAT(), TRAP'ENTRY ←5; SAVE'STATE(GSTATE); RTRAP(5);
        ARBENT XXXUFN(), TRAP'ENTRY ←6; SAVE'STATE(GSTATE); RTRAP(6);
        ARBENT XXXFXO(), TRAP'ENTRY ←7; SAVE'STATE(GSTATE); RTRAP(7);
        ARBENT XXXDIZ(), TRAP'ENTRY ←8; SAVE'STATE(GSTATE); RTRAP(8);

* STACK OVERFLOW - WATCH OUT
         ARBENT XXXSOV(), TRAP'ENTRY ←9; STKTRAP();
        END;

        PROGRAM PUNT; INCLUDE USERDECS,TRAP'DECS;
        INCLUDE SPTDECS;
        INCLUDE ICTDECS;
*
* MAIN TRAP/PUNT PROCESSING ROUTINE
*
         INT N,P,Q,SR;
        INT LSPCS←5;
        INT I;
        LN NULL'UNDK←(0,0);
        LB R= L' [0];
        INTARY SPCA[LSPCS],STATE[LSTATE];
        PTR SA;* POINTER TO STATE[0]
        MACRO IS'TSB'INSTR(X)←((X) A' 07740000B=04600000B);
        OCTFL UTNO(0:0,5),SPCSLR(1:6,23);
        LB FIELD LBW0(0);

         MACRO SAVE'STATE(X)←BCOPY(SA←@STATE[0],@X[0],LSTATE) &
         (TRAP'PUNT() IF TRAP'FLAG#1);
        MACRO SPT'PUNT←SPTPUNT:ERCODE,ERMSNO;

*
* ENTRY FOR RING TRAPS
*
         ARBENT RTRAP(N);
        SAVE'STATE(GSTATE);
RTPUNT: RPUNTMSG(N,RTRAP'LOC); GOTO PUNTCOM;

*
* SPECIAL ENTRY FOR 'ABE' TRAP -
* CHECK IF REFERENCE IS FOLLOWED BY TSB OPCODE
*
         ARBENT ABE'TRAP();
        SAVE'STATE(GSTATE);
        INSTR'LOC←RTRAP'LOC+1;
        IF IS'TSB'INSTR($INSTR'LOC) DO;
            .LDX SA[XSTLOC],LDA SA[LSTLOC],XLA,STA SAVEL,EAC$INSTR'LOC;
            .LDA SAVEL,XLA,STX Q;
            R$BRDPC←Q;
            SA[PSTLOC]←@ABE'EXIT;
            R$BRDLR←SA[LSTLOC];
            SA[LSTLOC]←@R;
            TRAP'FLAG←0;
            .LDX SA,LOADS;
ABE'EXIT:   RETURN;
        ENDIF;
        N←1; GOTO RTPUNT;

*
* ENTRY FOR SP TRAPS
*
         ARBENT STRAP();
        SAVE'STATE(SP'GSTATE); N←@R.SP'TNO; Q←@R.SP'TPAR;
        READ'SPCS(0,SPCA//SPT'PUNT); R$BRDLR←SPCA[0]$SPCSLR;
        P←SPCA[0]$SPCSPR;
        GOTO SPTPUNT IF N#23;

* QUIT
QUIT:    QUIT'FLAG←1; REFUSE'INTS(2000,100//SF'PUNT);
        SA[LSTLOC]←@R;
        SA[PSTLOC]←@QUITX; .LDX SA,LOADS;
***       ARM TRAP
         I←ACQUIRE'ICT(GET'INT'NO('QT'//SF'PUNT)//SF'PUNT);
        SET'SPT'FIELD(-1,'TM',READ'SPT'FIELD(-1,'TM'//SF'PUNT) V' 1//SF'PUNT);
QUITX:  SP'RETURN(//SPT'PUNT);


* FREE STORAGE OVERFLOW
         ARBENT OFLOTRAP(ERCODE,ERMSNO);
        R←R$BRDLR.LBW0; N←24; GOTO RTF;

* UNEXPECTED RUNTIME FAILURE
         ARBENT RUNTIME'FAILURE(); N←25;
RTF:    P←R$BRDPC; Q←0;

SPTPUNT: ALLOW'INTS();
        SPUNTMSG(N,P,Q);
PUNTCOM:TRAP'FLAG←0;
        GOTO TRAP'LABEL;

* TRAP DURING STATE-SAVING
         ARBENT TRAP'PUNT();
        SPUNTMSG(26,R$BRDPC,0); GOTO PUNTCOM;
        END;

        PROGRAM STKOV'TRAP; INCLUDE USERDECS;
*
* STACK OVERFLOW TRAP PROCESSING
*
         FIXED;

         ARBENT STKTRAP();
STKWAIT:GOTO TRAP'LABEL;
        END;

        PROGRAM UTRAP'MSG; INCLUDE USERDECS,MACHINE'DECS;
*
* PRINT USER TRAP MESSAGE
*?*  THIS ROUTINE SHOULD FRETURN, RATHER THAN PUNTING (COULD CAUSE
*?*       PUNT LOOP AND STACK OVERFLOW)
*
         ST MSG(60),CM; INT N,P,Q,T;
        CHRARY RN[10]←(6'RT0?',6'ABE',6'FLO',6'FLU',6'ROIA',
         6'IAT',6'UFN',6'FXO',6'DIZ',6'SOV');
        CHRARY SN[27]←(6'MACC',6'PRO',6'PNIM',6'PNIC',6'PI',
         6'TI',6'BLL',6'ILIM',6'PNOD',6'DWSO',6'CWSO',
         6'NEP',6'DMRD',6'NILE',6'SPCO',6'PMTO',6'DKSE',
         6'?17?',6'?18?',6'?19?',6'?20?',6'?21?',6'UTSE',
         6'QUIT',6'FSOV',6'PUNT',6'TRAP');

         ARBENT RPUNTMSG(N,P); N←-(N+1);
        ARBENT SPUNTMSG(N,P,Q);


         SETS(MSG,0,0); WCI(NLCH,MSG);
        APPEND(MSG,"USER TRAP '"//LF'PUNT);

COM:
        IF N=22 DO;* 'UTSE' ERROR
        APPEND(MSG,"UTSE - "//LF'PUNT);
            N←(Q$UTSE'SPTNO IF T←Q$UTSE'CLASS>1 ELSE
             6 IF T=1 ELSE -(Q$UTSE'RTNO+1));
        ENDIF;

         IF N=6 DO;* BLL ERROR
        PUNT'WWD(MSG,6'BLL-'); WCI(Q$BLL'CLASS V' '0',MSG);
        ELSE DO;
            PUNT'WWD(MSG,SN[N] IF N>=0 ELSE RN[-(N+1)]);
        ENDIF;
        APPEND(MSG,"' AT P: "//LF'PUNT);
        CNS(P,MSG,4B7,8//LF'PUNT); WCI('B',MSG);

         WCI(NLCH,MSG);
QT'P:   PRINT'STRING(-1,MSG,0//QUIT'PUNTX(QT'P,MSG));
        RETURN;
        END;

        PROGRAM PUNT'WWD; INCLUDE COMDECS;
*
* APPEND 4 CHARACTER NAME TO STRING
*
         PTR P; CHR M,C; ST S; STFL A(0); CHRFL CH60(0:0,5);

         ARBENT PUNT'WWD(STRING @P,M); S←P.A;

         (WCI(C,S) IF C#' ') & M←M LSH 6
         FOR C←M$CH60 WHILE M#6'    ';
        P.WP←S$WP; RETURN;
        END;

        PROGRAM VARIOUS; INCLUDE USERDECS;

*
* CLEAR CIOS NPUT/OUTPUT &
* TYPE NEWLINE
*

         ARBENT CLEAR'CIOS();
LP:     QUIT'FLAG←0;
        SET'CIOS'FIELD(-1,'OCC',0//SF'PUNT);
        SET'CIOS'FIELD(-1,'ICC',0//SF'PUNT);
        IOUT();
        PRINT'CHAR(-1,NLCH,QUIT'FLAG//QUIT'PUNT(LP));
        RETURN;

*
* REMOVE QUIT CALL FROM SPCS AND UNWIND STACK
* BY NON-LOCAL GOTO
*

         ARBENT ZAP(LABEL ZLAB);
        DELETE'CALL(//SF'PUNT);
        GOTO ZLAB;
       END;

        COMMON ENTCOM;
        INCLUDE COMDECS, USERDECS;


        INT UK;
        DECLARE STRING ARRAY ENTRIES[3]←("ENTER","LOGOUT","TLOGOUT");
        DECLARE STRING NOTICE(480);
        DECLARE STRING HEADER(240);
        DECLARE STRING MAIL(480);
        END;

        PROGRAM MISSUBS; INCLUDE COMDECS;
        ST JST1,JST2,NAME'ST,WS;
        INT TEMP,UN,DK,TP,STRT←0,INDEX,NAMEL←5,ERMSNO,LAST←6;
        INTARY PN,SF[LUFN]; LN LUNDK; CHR ERCODE;
       OCTFL UNO(0);


         INTENT COMPARE(JST1,JST2);




         FOR TEMP←GCI(JST1//ENDST1) WHILE 1 DO;
            GOTO NOGD IF TEMP#GCI(JST2//NOGD);
        ENDFOR;
*               ERROR IF LOOP COMPLETES
         NC'PUNT;
ENDST1: GCI(JST2//GOOD);
NOGD:   RETURN 0;
GOOD:   RETURN 1;

         ENTRY CONV'FNAME(UN,NAME'ST,TP,PN);
        BSET(@PN[0],0,LUFN);
        WS←ST'DESC(16,@PN[3],6,0);
        SCOPY(WS,NAME'ST//LF'PUNT);
        PN[STRT]←UN;
        PN[STRT+7]←TP;
        RETURN;

         ENTRY DESTROY'PROC(LUNDK,TP);
        FOR INDEX←0,INDEX+1 REPEAT;
            BSET(@SF[0],0,LUFN);
            READ'MIBOB'INDEX(LUNDK,NAMEL,SF,INDEX,TP// VALUE
             (GOTO ENDMIB IF ERCODE='MOB' ELSE GOTO LOOP):
             ERCODE,ERMSNO);
            IF SF[LAST]=6'DEST' DO;
                BCOPY(@SF[3],@SF[2],5);
                SF[2]←SF[1];
                SF[1]←0;
                SF[0]←LUNDK$UNO;
                DELETE'MIBOB(SF,TP//LOOP:ERCODE,ERMSNO);
            ENDIF;
LOOP:   ENDFOR;
ENDMIB: RETURN;
        END;

        PROGRAM RUN'USER;

        INCLUDE ENTCOM;

        DECLARE LABEL ARRAY COM[3]←(IN,OUT,TOUT);
        DECLARE STRING S(72),CMND;
        DECLARE INTEGER K;

        ENTRY RUN'USER();

        WAKEUP'TIMER←ACQUIRE'ICT(-1//NC'PUNT);
        THIS'SUB'PROCESS←READ'SPS'PARAM('CSP'//SF'PUNT);
        GET'TABLE(//SF'PUNT);
        GET'COM'LINE(S:S//SF'PUNT);
        CMND←GET'PARAM(S);
        K←ABRV'LKP(CMND,ENTRIES//SF'PUNT);
        GOTO COM[K];
IN:     CHECK'TABLE(//BYE);
        SET'PROC'PARAM('EPR',1//SF'PUNT);
        ENTER'USER();
BYE:    DESTRY'THIS'PROC();
        SP'RETURN(//SF'PUNT);

OUT:    LOGOUT'USER(GET'PARAM(S));
        SP'RETURN(//SF'PUNT);

TOUT:   TLOGOUT'USER(GET'PARAM(S));
        SP'RETURN(//SF'PUNT);

        END;

        PROGRAM EPLNO;

        /* PROGRAM TO LOGIN THE USER INTO THE BCC 500 SYSTEM */

        INCLUDE ENTCOM, SIBDECS;

        ST      USRNAME(72),PASSWORD(72),ACCOUNT(72),MESSAGE,
                V,ST3(72),LINE,ST4(72),PRONAME,
                FILENAME,ST5(72),VERSION(72),MAINST(20:6);
        INT     CNT,ERMSNO,RE'ATTACHING,
                DET'PROC'COUNT,I,
                USNO,INDX,UK,FND,PRO,RES←0,PNO,TEMP;
        INTARY  FN[LUFN],SA[LUFN],FILE[LUFN];
        OCTFL   UNO(0);
        OCTFL   ENO(0:14,23);
        OCTFL   UPUN(0:0,15);
        CHR     ERCODE,NAME'CH;
        CHR     ESC←302B;
        LN      UNDK;
        PTR     PTR0,PTR1;


        ENTRY ENTER'USER();


        PRINT'CHAR(-1,NLCH,QUIT'FLAG//QUIT'PUNTX(EXIT2,NAME'CH));
        PRINT'STRING(-1,HEADER,QUIT'FLAG//QUIT'PUNTX(EXIT2,HEADER));
        UK←READ'SPT'FIELD(-1,'UAK'//SF'PUNT);
        UNDK$UNO←-1;
        CNT←0;
        ACCT'STR('K',"","","",0//EXIT2);  /* LOG TERMINAL GOING ACTIVE */
START:  SYSTEM'VERSION(VERSION:VERSION);
        PRINT'STRING(-1,"VERSION ",QUIT'FLAG//QUIT'PUNTX(EXIT2,VERSION));
        PRINT'STRING(-1,VERSION,QUIT'FLAG//QUIT'PUNTX(EXIT2,VERSION));
        PRINT'CHAR(-1,NLCH,QUIT'FLAG//QUIT'PUNTX(EXIT2,NAME'CH));
        PRINT'DATE'TIME();
RESTRT: SET'CIOS'FIELD(-1,'BWS','ALL'//SF'PUNT);
        MESSAGE←"";
RE'ENTER:PRINT'STRING(-1,"ENTER  ",QUIT'FLAG//QUIT'PUNTX(EXIT2,ST4));
GET'NAME:READ'WORD(USRNAME:USRNAME, NAME'CH//EXIT2:ERCODE, ERMSNO);
        CHECK(USRNAME,1);  /* SET PARAMETER TO 1 TO DELETE ANY BLANKS */
        IF NAME'CH = NLCH DO;
            GOTO PROMPT;
        ELSEIF NAME'CH = ' ' DO;
            GOTO PASS;
        ELSEIF NAME'CH=ESC OR NAME'CH='?' DO;
            PRINT'STRING(-1,"&/ENTER (YOUR USER NAME) ",QUIT'FLAG
                  //QUIT'PUNTX(EXIT2,ST4));
            GOTO GET'NAME;
        ELSE DO; * ACCOMMODATES '&Q'
            PRINT'CHAR(-1,NLCH,QUIT'FLAG//QUIT'PUNTX(EXIT2,NAME'CH));
            GOTO RE'ENTER;
        ENDIF;

*       PRINT PASSWORD MESSAGE
PROMPT: MESSAGE←"PASSWORD ";
PASS:   V←ST3;
        PRINT'STRING(-1,MESSAGE,QUIT'FLAG//QUIT'PUNTX(EXIT2,ST4));
        SET'CIOS'FIELD(-1,'EST',0//SF'PUNT);
        READ'WORD(PASSWORD:PASSWORD,NAME'CH//EXIT2:ERCODE,ERMSNO);
        CHECK(PASSWORD,1);  /* SET PARAMETER TO 1 TO DELETE ANY BLANKS */
        GOTO PASS1 IF NAME'CH = NLCH;
        IF NAME'CH = ' ' DO;
            PRINT'CHAR(-1,' ',QUIT'FLAG//QUIT'PUNTX(EXIT2,NAME'CH));
            GOTO PASS1;
        ELSEIF NAME'CH = ESC OR NAME'CH = '?' DO;
            PRINT'STRING(-1,"?&/(YOUR PASSWORD) ",QUIT'FLAG//
                  QUIT'PUNTX(EXIT2,ST4));
            GOTO PASS;
        ELSE DO; * ACCOMMODATES '&Q'
            PRINT'CHAR(-1,NLCH,QUIT'FLAG//QUIT'PUNTX(EXIT2,NAME'CH));
            GOTO PROMPT;
        ENDIF;

*       RESET ECHO
PASS1:  SET'CIOS'FIELD(-1,'EST',1//SF'PUNT);
        READ'UP'ITEM('UP',-1,0,USRNAME,"P",V,UK:V//NAME'ERR:ERCODE,ERMSNO);
        GOTO PASW'ERR IF COMPARE(V,PASSWORD)=0;
        V←ST3;
        SETS(ACCOUNT);
        READ'UP'ITEM('UP',-1,0,USRNAME,"ACCOUNT",V,UK:V//RUN:ERCODE,ERMSNO);
        IF NAME'CH = NLCH DO;
            MESSAGE ← "&MACCOUNT  ";
        ELSE DO;
            MESSAGE ← "";
        ENDIF;
ACCT:   READ'LINE(-1,ACCOUNT,MESSAGE,QUIT'FLAG:ACCOUNT//QUIT'PUNTX(EXIT2,ST4));
        CHECK(ACCOUNT,0);  /*SET PARAMETER TO 0 TO KEEP AS IS */
        IF LENGTH(ACCOUNT)=0 DO;
           PRINT'STRING(-1,"PLEASE TYPE YOUR NAME OR ACCOUNT&/",QUIT'FLAG
                 //QUIT'PUNTX(EXIT2,ST4));
           GOTO ACCT;
        ELSEIF LENGTH(ACCOUNT)>25 DO;
           PRINT'STRING(-1,"LINE TOO LONG, RETYPE&/",QUIT'FLAG
                 //QUIT'PUNTX(EXIT2,ST4));
           GOTO ACCT;
        ENDIF;

*       READ USER NUMBER
RUN:    V←ST3;
        READ'UP'ITEM('UP',-1,0,USRNAME,"#",V,UK:V//SF'PUNT);
        PRINT'CHAR(-1,NLCH,QUIT'FLAG//QUIT'PUNTX(EXIT2,NAME'CH));

LOGGED'IN: UNDK$UNO←USNO←SBASE(V).UPUN;
        DESTROY'PROC(UNDK,UK);
        DET'PROC'COUNT←0;
        FOR I←1 TO MAX'PRT-1 DO;
           PTR0←PTR3+12*I;
           PTR1←PTR2+4*I;
           IF PTR0.PRDET=1 AND PTR1.MIB'FIELD=USNO DO;
              DET'PROC'COUNT←DET'PROC'COUNT+1;
              THAT'PRTI←I;
           ENDIF;
        ENDFOR;
        GOTO ATT IF DET'PROC'COUNT>0;

LOOK:   RE'ATTACHING ← PNO ← 0;
        FOR INDX←0,INDX+1 REPEAT;
           READ'MIBOB'INDEX(UNDK,5,FN,INDX,UK//
                VALUE (GOTO GET'OUT IF ERCODE='MOB' ELSE GOTO
                NXENT):ERCODE,ERMSNO);
           IF FN[0]$SIBNOT=SIBPRCD AND FN[2]=6'PROC' DO;
                V←ST'DESC(4,@FN[3],6,0);
                V$WP←V$EP;
                TEMP←CSN(V//NXENT);
                PNO←TEMP IF TEMP>PNO;
           ENDIF;
NXENT:  ENDRPT;
        NC'PUNT;

GET'OUT:SCOPY(MAINST,6"PROC"//LF'PUNT);
        CNS(PNO+1,MAINST,0,10//LF'PUNT);
        CONV'FNAME(USNO,MAINST,6'PROC',FILE);

* CREATE, OPEN, INITIALIZE AND ACTIVATE THIS PROCESS AND COMMIT SUICIDE
CRPR:   CREATE'MIBOB(FILE,SIBPRCD,UK//EXIT2:ERCODE,ERMSNO);
        SET'MIBOB'ACCESS(FILE,357B,UK//SF'PUNT);
INIT:   CREATE'PROCESS(FILE,"",UK//EXIT2:ERCODE,ERMSNO);
        TABLE(USNO//EXIT2);

ACTV:   THAT'PRTI←ACTIVATE'PROC(FILE,-1,RES,UK//EXIT2:ERCODE,ERMSNO);
        ACCT'STR('E',USRNAME,"",ACCOUNT,0//EXIT2); * LOG SUCCESSFUL ENTRY

EXIT1:  PTR1←PTR2+THAT'PRTI*4;      /* ENTER USER IN ACTIVE-USERS */
        PTR1.LINE'FIELD←LNO RSH 1;
        IF NOT RE'ATTACHING DO;   /* IF RE-ATTACHING, SAVE ORIGINAL LOGIN TIME */
           PTR1.MIB'FIELD←USNO;
           PUT'TIME(PTR1+1);
        ENDIF;

EXIT:   DESTRY'THIS'PROC();
        SP'RETURN(//SF'PUNT);

WHICH:  PRINT'STRING(-1,"MORE THAN 1 DETACHED PROCESS. CARELESS!!",
                     QUIT'FLAG//QUIT'PUNTX(EXIT,ST4));
        PRINT'CHAR(-1,NLCH,QUIT'FLAG//QUIT'PUNTX(EXIT,NAME'CH));
        PRINT'STRING(-1,"NEXT TIME, DO NOT JUST FLICK YOUR TERMINAL TO 'LOCAL'",
                     QUIT'FLAG//QUIT'PUNTX(EXIT,ST4));
        PRINT'CHAR(-1,NLCH,QUIT'FLAG//QUIT'PUNTX(EXIT,NAME'CH));
        PRINT'STRING(-1,"AND WALK AWAY... YOU MUST EXPLICITLY LOGOUT!!!",
                     QUIT'FLAG//QUIT'PUNTX(EXIT,ST4));
EXIT2:  QUIT'FLAG←0;
        PRINT'CHAR(-1,NLCH,QUIT'FLAG//QUIT'PUNTX(EXIT,NAME'CH));
        PRINT'STRING(-1,"ENTER ABORTED",QUIT'FLAG//QUIT'PUNTX(EXIT,ST4));
        PRINT'CHAR(-1,NLCH,QUIT'FLAG//QUIT'PUNTX(EXIT,NAME'CH));
        GOTO EXIT;

ATT:    GOTO WHICH IF DET'PROC'COUNT>1;

NEW:    PRINT'CHAR(-1,NLCH,QUIT'FLAG//QUIT'PUNTX(EXIT2,NAME'CH));
        PRINT'STRING(-1,"DO YOU WISH TO RECONNECT TO DETACHED PROCESS?  ",
                         QUIT'FLAG//QUIT'PUNTX(EXIT2,ST4));
        SETS(ST4);
        READ'LINE(-1,ST4,"",QUIT'FLAG:ST4//QUIT'PUNTX(EXIT2,ST4));
        IF (NAME'CH←GCI(ST4//NEW))='Y' DO;
           ATTACH'PROC(THAT'PRTI,LNO RSH 1);
           RE'ATTACHING ← 1;
           GOTO EXIT1;
        ELSEIF NAME'CH='N' DO;
           GOTO LOOK;
        ELSE DO;
           GOTO NEW;
        ENDIF;

PASW'ERR:ACCT'STR('P',USRNAME,PASSWORD,"",0//EXIT2) IF LENGTH(PASSWORD)#0; * LOG BAD PASSWORD
        GOTO NAM'ERR1;

NAME'ERR:ACCT'STR('N',USRNAME,"","",0//EXIT2) IF LENGTH(USRNAME)#0; * LOG BAD USER NAME
NAM'ERR1:PRINT'STRING(-1,"&/INVALID",QUIT'FLAG//QUIT'PUNTX(EXIT2,ST4));
        PRINT'CHAR(-1,NLCH,QUIT'FLAG//QUIT'PUNTX(EXIT2,NAME'CH));
        CNT←CNT+1;
        GOTO RESTRT IF CNT<4;
        GOTO EXIT2;

ERROR:  PRINT'STRING(-1,"PROCESS ALREADY EXISTS.  RESTART IT?",
        QUIT'FLAG//QUIT'PUNTX(EXIT2,ST4));
        PRINT'CHAR(-1,NLCH,QUIT'FLAG//QUIT'PUNTX(EXIT2,NAME'CH));
        LINE←ST4;
        READ'LINE(-1,LINE,"",QUIT'FLAG:LINE//QUIT'PUNTX(EXIT2,ST4));
        V←GET'PARAM(LINE);
        GOTO WHICH IF EMPTY(V) OR COMPARE("YES",V)=0;
        GOTO ACTV;
        END;

       PROGRAM CHECK;

*     THIS PROGRAM BLOCK CHECKS A STRING PARM FOR CHARACTERS > 77B.
*     ALL CHARACTERS < 100B ARE PUT DIRECTLY INTO NEWPARM UNCHANGED.
*     CHARACTERS IN THE RANGE
*              100B - 177B ARE CONVERTED TO '$''CHR-100B'
*              200B - 277B ARE CONVERTED TO '%''CHR-200B'
*              300B - 377B ARE CONVERTED TO '&''CHR-300B'.
*     NEWPARM IS THEN COPIED BACK ONTO PARM.
*     ALSO, IF THE DELETE PARAMETER IS 1, THEN ANY BLANK CHARACTERS FOUND
*     WILL BE DELETED.  IF 0, THEN THE STRING IS LEFT AS IT IS.

       DECLARE INTEGER
          DEL'PARAM;

       DECLARE CHARACTER 
          CHAR;

       DECLARE STRING
          NEWPARM(144);


       STRING FUNCTION CHECK(STRING PARM, DEL'PARAM);

       WHILE 1 DO;
          IF (CHAR ← GCI (PARM//FAIL)) < 100B DO;
               WCI(CHAR,NEWPARM//FAIL) IF CHAR # ' ' OR NOT DEL'PARAM;
          ELSEIF CHAR < 200B DO;
               WCI ('$',NEWPARM//FAIL);
               WCI (CHAR-100B,NEWPARM//FAIL);
          ELSEIF CHAR < 300B DO;
               WCI ('%',NEWPARM//FAIL);
               WCI (CHAR-200B,NEWPARM//FAIL);
          ELSE DO;
               WCI (006B,NEWPARM//FAIL);   * 006B IS AN '&'
               WCI (CHAR-300B,NEWPARM//FAIL);
          ENDIF;
       ENDFOR;
FAIL:
       SCOPY (PARM,NEWPARM//RETURN);
       RETURN;
       END;

        PROGRAM READ'WORD;

        INCLUDE MACHINE'DECS, ENTCOM;

        DECLARE STRING WORD;
        DECLARE INTEGER FIRST;
        DECLARE CHARACTER IN'CHAR, ESC←302B;


        ENTRY READ'WORD(WORD), FRETURN;


        FIRST←1;
        SETS(WORD);
LOOP:   IN'CHAR←READ'CHAR(-1,QUIT'FLAG//FAIL1:ERCODE,ERMSNO);
        IF IN'CHAR=' ' DO;
            GOTO LOOP IF FIRST;
            RETURN (WORD,IN'CHAR);
        ELSEIF IN'CHAR=NLCH OR IN'CHAR='?' OR IN'CHAR=ESC DO;
            RETURN (WORD,IN'CHAR);
        ELSEIF IN'CHAR='&Q' DO;
            PRINT'CHAR(-1,'←',QUIT'FLAG//QUIT'PUNTX(FAIL1,IN'CHAR));
            SETS(WORD); RETURN (WORD,IN'CHAR);
        ELSEIF IN'CHAR='&A' DO;
            PRINT'CHAR(-1,'↑',QUIT'FLAG//QUIT'PUNTX(FAIL1,IN'CHAR));
            WORD$WP←INCDES(WORD$WP,-1) IF LENGTH(WORD)>0;
            GOTO LOOP;
        ENDIF;
        WCI(IN'CHAR,WORD//FAIL1);
        FIRST←0;
        GOTO LOOP;
FAIL1:  FRETURN (ERCODE,ERMSNO);
        END;

        PROGRAM GET'TABLE;

        INCLUDE USERDECS;

        DECLARE INTEGER I,PGNO;
        DECLARE INTEGER ARRAY FN[LUFN];
        DECLARE STRING NAME1←6"#1:X298-ACTUSR:BIN";
        DECLARE STRING NAME2←6"#1:REAL-CORE:BIN";
        DECLARE POINTER PTR4;


        ENTRY GET'TABLE(), FRETURN;


        KEY←READ'PROC'PARAM('IKY'//SF'PUNT);
        NAME'SEARCH(NAME1,FN,1,'',KEY//ERROR1:ERCODE,ERMSNO);
        MOPEN'FILE(-1,FN,0,KEY:OFTI//SF'PUNT);
BRING'IN:GET'FIRST'PAGE(OFTI:PMTI,PTR2);
        NAME'SEARCH(NAME2,FN,1,'',KEY//ERROR2:ERCODE,ERMSNO);
        MOPEN'FILE(-1,FN,0,KEY:OFTI//SF'PUNT);
        GET'FIRST'PAGE(OFTI:PMTI,PTR3);
        GET'SECOND'PAGE(OFTI,PTR3 RSH 11:PMTI,PTR4);
        PTR3←PTR3+PRT'BASE;
        LNO←READ'PROC'PARAM('TNO'//SF'PUNT);
        THIS'PRTI←READ'PROC'PARAM('PRT'//SF'PUNT);
        RETURN;

ERROR1: FRETURN (ERCODE,ERMSNO) IF ERCODE#'NNF';

*       INITIALIZATION
        CONV'FNAME(-1,6"X298-ACTUSR",6'BIN ',FN);
        CREATE'MIBOB(FN,0,KEY//SF'PUNT);
        MOPEN'FILE(-1,FN,0,KEY:OFTI//SF'PUNT);
        CR'FILE'PAGE(OFTI,0:PGNO//SF'PUNT);

*       CHANGE FILE LENGTH IF MAXIMUM LINES SUPORTED BY SYSTEM
*       EXCEEDS 500.
        SET'FILE'LENGTH(OFTI,2047//SF'PUNT);
        GOTO BRING'IN;

ERROR2: FRETURN;

        END;

        PROGRAM ON'TABLE;

        INCLUDE MACHINE'DECS, ENTCOM, USERDECS;

        DECLARE POINTER PTR1;
        DECLARE INTEGER UK,USNO,TERM'NO,J,BITS,LOCK'VALUE;
        DECLARE LONG UNDK,ON'TIME;
        DECLARE STRING USRNAME(20),S,CODE(10);
        DECLARE FIELD UNO(0);

        ENTRY TABLE(USNO), FRETURN;
        SETS(MAIL,0,0);
        READ'UP'ITEM('UP',-1,USNO,USRNAME,"LINKS",CODE,KEY:
             CODE//OK:ERCODE,ERMSNO);

*       ACQUIRE SYSTEM PRIVILEGES FOR SET'LINE'FIELD BELOW
OK:     BITS←READ'SPT'FIELD(-1,'SB'//SF'PUNT);
        SET'SPT'FIELD(-1,'SB',BITS V' 2B7//SF'PUNT);
        SET'LINE'FIELD(LNO,'LOK',COMPARE(CODE,"NO")//SF'PUNT);

*       GIVE UP SYSTEM PRIVILEGES
        SET'SPT'FIELD(-1,'SB',BITS//SF'PUNT);
        READ'UP'ITEM('UP',-1,USNO,USRNAME,"MAIL",MAIL,KEY:MAIL//NEXT:
             ERCODE,ERMSNO);
        SET'UP'ACCESS('UP',-1,USNO,USRNAME,"MAIL",0,-1,KEY//SF'PUNT);
        PRINT'STRING(-1,MAIL,QUIT'FLAG//QUIT'PUNTX(NEXT,MAIL));
        PRINT'STRING(-1,"",QUIT'FLAG//QUIT'PUNTX(NEXT,MAIL));

NEXT:   SETS(MAIL);
        READ'UP'ITEM('UP',-1,USNO,USRNAME,"NOTICE",MAIL,KEY:MAIL//BYE:
             ERCODE,ERMSNO);
        SET'UP'ACCESS('UP',-1,USNO,USRNAME,"NOTICE",0,-1,KEY//SF'PUNT);
        PRINT'STRING(-1,"&G&G&G&GNOTICE:",QUIT'FLAG//
             QUIT'PUNTX(BYE,MAIL));
        PRINT'CHAR(-1,NLCH,QUIT'FLAG//QUIT'PUNTX(BYE,MAIL));
        PRINT'STRING(-1,NOTICE,QUIT'FLAG//QUIT'PUNTX(BYE,NOTICE));

BYE:    RETURN;


        ENTRY CHECK'TABLE(), FRETURN;
        UK←READ'SPT'FIELD(-1,'UAK'//SF'PUNT);
        UNDK$UNO←-1;
        DESTROY'PROC(UNDK,UK);   /* DESTROY ANY PREVIOUS PROCESSES   */
        PTR1←PTR2+ENTER'LOCK; * LOOK AT ENTER'LOCK TO DECIDE ABOUT ENTRY
AGAIN:  IF (LOCK'VALUE←$PTR1)<0 DO; * ENTRY FORBIDDEN
           PRINT'STRING(-1,"&307SORRY, THE 500 IS NOT AVAILABLE&307",QUIT'FLAG
                //FRET:S,ERCODE,ERMSNO);
           FRETURN;
        ELSEIF LOCK'VALUE=0 DO; * SYSTEM NOW COMING UP: WAIT & TRY AGAIN
           PRINT'STRING(-1,"&307THE 500 IS BEING RESTARTED...TRY AGAIN SHORTLY.&307",
                 QUIT'FLAG//FRET:S,ERCODE,ERMSNO);
           FRETURN;
        ELSEIF LOCK'VALUE=1 DO; * MAYBE WE ARE THE FIRST CUSTOMER
           LOCK();
           IF $PTR1=1 DO; * CHECK TO MAKE SURE
              ACCT'STR('I',"","","",1//FRET); * LOG SYSTEM INITIALIZATION
              $PTR1←2;
              UNLOCK();
           ELSE DO; * NO, SOMEONE BEAT US TO THE PUNCH.  START OVER
              UNLOCK();
              GOTO AGAIN;
           ENDIF;
        ENDIF;
        TERM'NO←LNO RSH 1;
        RUNTIME'FAILURE() IF TERM'NO>MAX'TERMS;
        SETS(HEADER);
        READ'UP'ITEM('UP',-1,1,USRNAME,"HEADER",HEADER,KEY:HEADER//BELOW:
             ERCODE,ERMSNO);
BELOW:  SETS(NOTICE);
        READ'UP'ITEM('UP', -1, 1, USRNAME, "NOTICE", NOTICE, KEY: NOTICE//
             BELOW1: ERCODE, ERMSNO);
BELOW1: RETURN;

FRET:   FRETURN;

        END;

        PROGRAM GET'FIRST'PAGE;
        INCLUDE USERDECS;

         DECLARE INTEGER OFTI,PMTI,I;
        DECLARE POINTER P;
        DECLARE INTEGER FIELD PAG'FL(0:6,12);

         ENTRY GET'FIRST'PAGE(OFTI);
        ACQUIRE'PMT(-1:PMTI//SF'PUNT);
        FOR I←1,I+1 WHILE READ'MAP'BYTE(-1,I//SF'PUNT)#0 DO;
        ENDFOR;
        SET'MAP'BYTE(-1,I,PMTI//SF'PUNT);
        MOVE'PAGE'PMT(OFTI,0,PMTI//SF'PUNT);
        P←I@PAG'FL;
        RETURN (PMTI,P);

        ENTRY GET'SECOND'PAGE(OFTI,I);
        ACQUIRE'PMT(-1:PMTI//SF'PUNT);
        SET'MAP'BYTE(-1,I,PMTI//SF'PUNT);
        MOVE'PAGE'PMT(OFTI,0,PMTI//SF'PUNT);
        P←I@PAG'FL;
        RETURN (PMTI,P);

        END;

        PROGRAM LOGOUT;
        INCLUDE COMDECS, USERDECS, MACHINE'DECS;
        ST NAME'ST, USRNAME(30), NAME(30);
        INT ERMSNO, CUNO, LNO, UNO, COUNT, P;
        INT MIB'COUNT,I;
        CHR ERCODE, CH, TYPE;
        INTARY FN[7], FMTNAME[LUFN];
        LN UNDK, THEN, NOW;
        DECLARE LONG PARAMETER DELAY←(1,62341577B);  /* 5 MINUTES */
        DECLARE POINTER PTR1;
        OCTFL UN(0);

        ENTRY LOGOUT'USER (NAME'ST);
        SET'PROC'PARAM('LPR',1//SF'PUNT);
        CUNO←READ'PROC'PARAM('UNO'//SF'PUNT); * GET CURRENT USER NUMBER
        THAT'PRTI ← READ'PROC'PARAM('PRT'//SF'PUNT); *GET PROCESS NUMBER FOR ACCT'STR FUNCTION

* GET THE USER'S NAME;
        SETS(USRNAME);
        READ'UP'ITEM('UP',-1,CUNO,"","N",USRNAME,KEY:USRNAME//SF'PUNT);

* CHECK TO SEE IF LOGOUT PARAMETER SUPPLIED;
        CH←GCI(NAME'ST//DELET'FL); * TRY TO DELETE FILES IF NO PARAMETER;
        GOTO GET'OUT IF CH='T'; * SKIP DELETING AND JUST LOGOUT;

* ONLY 'T' IS LEGAL AT PRESENT...OTHER PARAMETERS MAY BE ADDED LATER
        PRINT'STRING (-1,"LOGOUT PARAMETER INCORRECT.  RETYPE.&307",
         QUIT'FLAG//QUIT'PUNTX(SPRTN,NAME'ST));
SPRTN:      SP'RETURN (//SF'PUNT);
DELET'FL:COUNT←0; * NO. OF TIMES THE USER IS LOGGED IN;

* FIGURE OUT HOW MANY TIMES THE USER IS ON;
        P ← PTR2; * P POINTS TO USER NO. IN ACTIVE USER FILE;
        FOR I←1 TO MAX'PRT-1 DO;
            SETS(NAME);
            IF $P#0 DO;
                READ'UP'ITEM('UP',-1,P.MIB'FIELD,"","N",NAME,KEY: NAME
                  //SF'PUNT);
                COUNT←COUNT + COMPARE(USRNAME, NAME);
            ENDIF;
            P ← P + 4;
        ENDFOR;
        IF COUNT=1 DO; * ONLY LOGGED ON ONCE--DELETE FILES;
            UNDK$UN←CUNO; * USER NUMBER DISK ADDRESS
            FOR MIB'COUNT←0 TO 127 DO; * DELETE MIB ENTRIES;
                READ'MIBOB'INDEX(UNDK,5,FN,MIB'COUNT,KEY
                  //GOTO GET'OUT IF ERCODE='MOB' ELSE GOTO NXENT:
                  ERCODE, ERMSNO);
* READ'MIBOB'INDEX RETURNS FILE NAME IN FN[2] - FN[5] AND FILE TYPE
* FN[6], BUT DELETION REQUIRES A MONITOR-FORMATTED NAME.  SO WE BCOPY
* THE NAME AND TYPE OF FN TO FMTNAME AND SET UNO, DISK ADDR AND INDEX
* WORDS OF FMTNAME.
                TYPE←FN[6];
                FMTNAME[0] ← CUNO;
                FMTNAME[1] ← 0;
* DON'T DELETE KEY'S, SPCL'S, OR PROC'S;
                IF TYPE # 6'KEY ' AND TYPE # 6'SPCL' AND TYPE # 6'PROC' DO;
                   FMTNAME[2] ← MIB'COUNT;
                    BCOPY(@FMTNAME[3], @FN[2], 5);
                    DELETE'FILE(FMTNAME, KEY//NXENT: ERCODE, ERMSNO);
               ENDIF;
NXENT:      ENDFOR;
        ENDIF;
        GOTO GET'OUT;


         ENTRY TLOGOUT'USER (NAME'ST);
        SET'PROC'PARAM('LPR',1//SF'PUNT);
        CUNO←READ'PROC'PARAM('UNO'//SF'PUNT);
        THAT'PRTI ← READ'PROC'PARAM('PRT'//SF'PUNT); *GET PROCESS NUMBER FOR ACCT'STR FUNCTION
        SETS(USRNAME);
        READ'UP'ITEM('UP',-1,CUNO,"","N",USRNAME,KEY:USRNAME//SF'PUNT);
GET'OUT:REFUSE'INTS(-1,100//SF'PUNT);
        REMOVE();
        ACCT'STR('O',USRNAME,"","",0//SF'PUNT); * LOG LOGOUT
        PTR1←PTR2+TIME'BASE;
        THEN←$PTR1;            /* GET TIME ACCOUNT FILE WAS LAST WRITTEN */
        NOW←READ'CLOCK('RTC'); /* GET PRESENT TIME */
        BACKUP'ACCT'FILE(PTR1,NOW) IF
             LONG'LT(LONG'ADD(THEN,DELAY),NOW);
        DESTRY'THIS'PROC();

         END;

        PROGRAM BACKUP'ACCT'FILE;
        INCLUDE USERDECS, COMDECS;

        DECLARE ARRAY FORMATTED'NAME[8];
        DECLARE LONG NOW;
        DECLARE POINTER PTR1;

        FUNCTION BACKUP'ACCT'FILE(PTR1,NOW);

* MAKE SUB-PROCESS TO RUN AUTO-PFS
       PFS'SP'NUMBER←CREATE'SSP(-1//SF'PUNT);
       SPECIAL'SEARCH("#2:EMULATOR:PIF",FORMATTED'NAME,'COM',-1//SF'PUNT);
       ATTACH(PFS'SP'NUMBER,FORMATTED'NAME,-1//SF'PUNT);

       SEND'TO'PFS(//QUIT'ANYWAY);
       $PTR1←NOW;
QUIT'ANYWAY: RETURN;


       END;

        PROGRAM OFF'TABLE; INCLUDE USERDECS,MACHINE'DECS;
        DECLARE LONG PARAMETER WAIT'TIME←(0,1*1000*100);
        DECLARE INTEGER I,BITS,RUMMY;
        DECLARE LONG DUMMY;
        DECLARE INTEGER FIELD LF(0:6,7),LQNK(2:11,23);
        DECLARE INTEGER ARRAY TABLE[7];
        DECLARE POINTER PTR1;
        DECLARE STRING S;

         ENTRY REMOVE();

        PTR1←PTR2+THIS'PRTI LSH 2;
        $PTR1←0;               /* REMOVE USER FROM ACTIVE-USERS */
        READ'LINE'TABLE(LNO,TABLE//EXIT1:ERCODE,ERMSNO);
        IF TABLE[0]$LF#0 DO;*   BREAK LINKS;
            BITS←READ'SPT'FIELD(-1,'SB'//EXIT1:ERCODE,ERMSNO);
            SET'SPT'FIELD(-1,'SB',BITS V' 2B7
              //EXIT1:ERCODE,ERMSNO);
GET1:       MON'LOCK(LINKING:RUMMY//GET3:DUMMY);
            SET'LINE'FIELD(TABLE[0]$LQNK-1,'LF',0
              //EXIT1:ERCODE,ERMSNO);
            SET'LINE'FIELD(LNO,'LF',0//EXIT1:ERCODE,ERMSNO);
            MON'UNLOCK(LINKING//GET2:DUMMY);
GET2:
            SET'SPT'FIELD(-1,'SB',BITS//EXIT1:ERCODE,ERMSNO);
            PRINT'STRING(-1,"LINK BROKEN",QUIT'FLAG//QUIT'PUNTX(EXIT1,S));
            PRINT'CHAR(-1,NLCH,QUIT'FLAG//QUIT'PUNTX(EXIT1,I));
        ENDIF;

         PRINT'STRING(-1,"LOGOUT ON  ",QUIT'FLAG//QUIT'PUNTX(EXIT,S));
        PRINT'DATE'TIME();
        PRINT'STRING(-1,"TOTAL CHARGES: ",QUIT'FLAG//QUIT'PUNTX(EXIT,S));
        PRINT'CHARGES(PTR1+1);
        PRINT'STRING(-1,"PAGE FAULTS:   ",QUIT'FLAG//QUIT'PUNTX(EXIT,S));
        PRINT'PG'FAULTS();
        PRINT'STRING(-1,"CPU TIME:      ",QUIT'FLAG//QUIT'PUNTX(EXIT,S));
        PRINT'CPU'TIME();
        PRINT'STRING(-1,"CONNECT TIME:  ",QUIT'FLAG//QUIT'PUNTX(EXIT,S));
        PRINT'DELTA'TIME(PTR1+1);
        START'OUTPUT(-1,QUIT'FLAG//EXIT:ERCODE,ERMSNO);
EXIT:
        RETURN;
EXIT1:  MON'UNLOCK(LINKING//EXIT:DUMMY);
        GOTO EXIT;

GET3:   SLEEP(WAIT'TIME) & GOTO GET1;

        END;

       PROGRAM SEND'TO'PFS;

*      THIS FUNCTION PUTS A COMMAND STRING FOR AUTO-PFS IN THE
* FILE APFS-CMNDS, SETS THE UTILITY'S COMMAND STRING TO "AUTO-PFS", AND
* INITIATES A SUB-PROCESS TO EXECUTE IT, THEREBY WRITING OUT THE ACCOUNT
* FILE ON THE DISK.

       INCLUDE USERDECS, COMDECS;

       DECLARE ARRAY
          PMT'ENTRY[5];      /* HOLDS ONE PMT ENTRY                   */

       DECLARE STRING
          PMT'FLAGS(128:6);  /* EACH CHARACTER INDICATES WHETHER THE  */
                             /*   CORRESPONDING PMT ENTRY IS IN USE   */

       DECLARE INTEGER
          IN'USE'BEFORE,     /* FLAGS WHETHER ENTRY WAS IN USE BEFORE */
          PMT'INDEX,
          PFS'CMD'FILE'NUM;

       MACRO PMT'IN'USE ← PMT'ENTRY[3];




       FUNCTION SEND'TO'PFS(), FRETURN;

       LOCK();

* OUTPUT THE COMMANDS TO PFS
       PFS'CMD'FILE'NUM ←
          OPEN'SEQ'FILE("#1:&"APFS-CMNDS&"",1,6'9SYM',8
             //BAD'NEWS);
       OUTPUT'SEQ'FILE(PFS'CMD'FILE'NUM,
         "@SYSTEM-01:&141&165&141)WX732-ACCFIL.#1:X732-ACCFIL.F."
         //BAD'NEWS);
       CLOSE'SEQ'FILE(PFS'CMD'FILE'NUM//BAD'NEWS);

* REMEMBER WHICH PMT ENTRIES ARE IN USE BEFORE PFS IS CALLED
       FOR PMT'INDEX ← 1 TO 200B DO;
          READ'PMT(PMT'INDEX, PMT'ENTRY//BAD'NEWS:ERCODE,ERMSNO);
          WCI(1 IF PMT'IN'USE ELSE 0, PMT'FLAGS//BAD'NEWS);
       ENDFOR;

* CALL PFS
       SET'SAVED'USER(1);
       SET'COM'LINE("AUTO-PFS");
       SP'CALL(PFS'SP'NUMBER, 2//GO'ON:ERCODE,ERMSNO);
GO'ON: UNLOCK();

* NOW FREE ALL THE ENTRIES WHICH THE EMULATOR HAS JUST TAKEN FOR PFS
       FOR PMT'INDEX ← 1 TO 200B DO;
          READ'PMT(PMT'INDEX, PMT'ENTRY//FRETURN:ERCODE,ERMSNO);
          IN'USE'BEFORE ← GCI(PMT'FLAGS//FRETURN);
          DELETE'PMT(PMT'INDEX//IGNORE'ERROR: ERCODE, ERMSNO)
             IF PMT'IN'USE AND NOT IN'USE'BEFORE;
IGNORE'ERROR:
       ENDFOR;
       RETURN;

BAD'NEWS: UNLOCK(); FRETURN;

       END;

       PROGRAM LOCK'UNLOCK;
       INCLUDE USERDECS, MACHINE'DECS;

*  PROGRAM TO LOCK AND UNLOCK THE ACCOUNT FILE.  THIS CODE FUNCTIONS
*      MORE OR LESS THE WAY THE MONITOR OBJECT LOCKS FUNCTION, EXCEPT
*      THAT THE LOCK IS STORED IN ACTIVE-USERS AND A 3-MINUTE TIMER
*      IS SET INSTEAD OF THE MONITOR'S 30-SECOND TIMER.

       DECLARE LONG PARAMETER WAIT'TIME←(1,1222784), /* 3 MINUTES */
                              LWAIT←(0,5*1000*100),  /* 5 SECONDS */
                              SWAIT←(0,1*1000*100),  /* 1 SECOND  */
                              LONG'ZERO←(0,0);
       DECLARE INTEGER LKEY, RUMMY;
       DECLARE LONG LOCK'TIME, NOW, THEN, DUMMY;
       DECLARE FIELD LWR'QUARTER(1:12,23);
       DECLARE POINTER PTR1;

       FUNCTION LOCK();
       PTR1←PTR2+ACCT'LOCK;
       WHILE 1 DO;
LOCK1:    MON'LOCK(ACCTING:LKEY//LOCK1X:DUMMY);
          THEN←LONG'ADD((NOW←READ'CLOCK('RTC')),WAIT'TIME);
          THEN$LWR'QUARTER←0;
          LOCK'TIME←$PTR1;
          LOCK'TIME$LWR'QUARTER←0;
          IF (LONG'EQ(LOCK'TIME,LONG'ZERO) OR
               LONG'LT(LOCK'TIME,NOW)) DO;
             THEN$LWR'QUARTER←LKEY;
             $PTR1←THEN;
             MON'UNLOCK(ACCTING//LOCK2:DUMMY);
LOCK2:
             RETURN;
          ELSE DO;
             MON'UNLOCK(ACCTING//LOCK3:DUMMY);
LOCK3:
             SLEEP(LWAIT);
          ENDIF;
       ENDFOR;

LOCK1X: SLEEP(SWAIT) & GOTO LOCK1;

       FUNCTION UNLOCK();
       PTR1←PTR2+ACCT'LOCK;
UNLOCK1: MON'LOCK(ACCTING:LKEY//UNLOCK1X:DUMMY);
       $PTR1←LONG'ZERO IF PTR1.LWR'QUARTER=LKEY;
       MON'UNLOCK(ACCTING//UNLOCK2:DUMMY);
UNLOCK2:
       RETURN;

UNLOCK1X: SLEEP(SWAIT) & GOTO UNLOCK1;

       END;

        PROGRAM SLEEP;

*   THIS FUNCTION WILL BLOCK FOR T CLOCK TIMES.

       INCLUDE USERDECS;


        DECLARE INTEGER
           STATUS'BITS,
           REAL'TIME'INT ← 2,
           JUST'WAKEUP ← 0;

        DECLARE LONG
           X,Y,
           TIME'TO'WAKEUP,
           DELAY'TIME,
           LZERO ← (0,0);

        DECLARE FIELD
           HIGH'WORD(0),
           LOW'WORD(1),
           SOURCE(0:0,2),
           ACTION(0:3,5),
           BLK(0:11,11);

        MACRO SETUP'SAB(S,A,B) ← S@SOURCE V' A@ACTION V' B@BLK;



        FUNCTION SLEEP(DELAY'TIME);

        TIME'TO'WAKEUP ← LONG'ADD(LONG(READ'CLOCK('RTC')),DELAY'TIME);
        SET'ICT(WAKEUP'TIMER,SETUP'SAB(REAL'TIME'INT,JUST'WAKEUP,1),
           THIS'SUB'PROCESS,TIME'TO'WAKEUP//NC'PUNT);
        BLOCK(4B7 RSH WAKEUP'TIMER//NC'PUNT);

        RETURN;



        END;

        PROGRAM PRINT'DATE'TIME; INCLUDE USERDECS;
        STRING UTILITY DATE'TIME←82;
        DECLARE LONG LOGON'TIME,ELAPSED'TIME,TIME;
        DECLARE POINTER P;
        DECLARE OCTAL FIELD W0(0),W1(1);
        DECLARE STRING S(72);
        DECLARE INTEGER I,PF;

         GOTO RET;

         ENTRY PRINT'DATE'TIME();
        SETS(S,0,0);
        PRINT'STRING(-1,DATE'TIME(READ'CLOCK('RTC'),S//SF'PUNT),
         QUIT'FLAG//QUIT'PUNTX(RET,S));
BYE:    PRINT'CHAR(-1,NLCH,QUIT'FLAG//QUIT'PUNTX(RET,I));
RET:    RETURN;

         ENTRY PRINT'DELTA'TIME(P);
        SETS(S,0,0);
        TIME←READ'CLOCK('RTC');
        LOGON'TIME$W0←$P; $P←0;
        P←P+1;
        LOGON'TIME$W1←$P; $P←0;
        LONG'SUB(TIME,LOGON'TIME:ELAPSED'TIME);
        S←DATE'TIME(ELAPSED'TIME,S//SF'PUNT);
        S$RP←INCDES(S$WP,-8);
        PRINT'STRING(-1,S,QUIT'FLAG//QUIT'PUNTX(BYE,S));
        GOTO BYE;

         ENTRY PRINT'PG'FAULTS();
        SETS(S,0,0);
        PF←READ'PROC'PARAM('PFC'//SF'PUNT);
        CNS(PF,S,0,10//BYE);
        PRINT'STRING(-1,S,QUIT'FLAG//QUIT'PUNTX(BYE,S));
        GOTO BYE;

         ENTRY PRINT'CPU'TIME();
        SETS(S,0,0);
        TIME←READ'CLOCK('CTC');
        S←DATE'TIME(TIME,S//SF'PUNT);
        S$RP←INCDES(S$WP,-8);
        PRINT'STRING(-1,S,QUIT'FLAG//QUIT'PUNTX(BYE,S));
        GOTO BYE;

         ENTRY PUT'TIME(P);
        LOGON'TIME←READ'CLOCK('RTC');
        $P←LOGON'TIME$W0;
        P←P+1;
        $P←LOGON'TIME$W1;
        RETURN;
       END;

       PROGRAM PRINT'CHARGES; INCLUDE USERDECS;

       DECLARE PARAMETER
               BASIC'CPU'RATE←1138,       /* $10.00/HR  (WAS 5689, $50) */
               ON'RATE←114;               /*  $1.00/HR  (WAS 569, $5)   */

       DECLARE INTEGER ON'TIME,CP'TIME,PF'RATE,
                       CPU'RATE,DOLLAR,CENTS,I,
                       DAY,HOUR,MIN,SEC;

       DECLARE LONG NOW,THEN,TIME,ON'CHARGE,
                    CPU'CHARGE,CHARGE;

       DECLARE STRING MONEY(15);

       DECLARE POINTER PTR1;

       ENTRY PRINT'CHARGES(PTR1);

       NOW←READ'CLOCK('RTC');
       THEN←$PTR1;
       ANY'TIME'NUM((TIME←LONG'SUB(NOW,THEN)):,,,DAY,HOUR,MIN,SEC);
       ON'TIME←(((DAY-1)*24+HOUR)*60+MIN)*60+SEC;
       TIME←READ'CLOCK('CTC');
       ANY'TIME'NUM(TIME:,,,DAY,HOUR,MIN,SEC);
       CP'TIME←(((DAY-1)*24+HOUR)*60+MIN)*60+SEC;
       PF'RATE←READ'PROC'PARAM('PFC'//SF'PUNT)/CP'TIME;
       IF PF'RATE <= 10 DO;
          CPU'RATE←BASIC'CPU'RATE;
       ELSEIF PF'RATE <= 40 DO;
          CPU'RATE←BASIC'CPU'RATE+((PF'RATE-10)*BASIC'CPU'RATE/30);
       ELSE DO;
          CPU'RATE←2*BASIC'CPU'RATE+((PF'RATE-40)*BASIC'CPU'RATE/20);
       ENDIF;
       .LDA ON'TIME, .MUL ON'RATE, .STD ON'CHARGE;
       .LDA CP'TIME, .MUL CPU'RATE, .STD CPU'CHARGE;
       CHARGE←LONG'ADD(ON'CHARGE,CPU'CHARGE);
       .ASHD -12, .DIV 100, .STA DOLLAR, .STB CENTS;
       WCI('$',MONEY//BYE);
       CNS(DOLLAR,MONEY,0,10//BYE);
       WCI('.',MONEY//BYE);
       WCI('0',MONEY//BYE) IF CENTS<10;
       CNS(CENTS,MONEY,0,10//BYE);
       PRINT'STRING(-1,MONEY,QUIT'FLAG//QUIT'PUNTX(BYE,MONEY));
BYE:   PRINT'CHAR(-1,NLCH,QUIT'FLAG//QUIT'PUNTX(RET,I));
RET:   RETURN;

       END;

       COMMON SEQ'FILE'DEFS;

*      THIS COMMON BLOCK CONTAINS THE DECLARATIONS OF IDENTIFIERS
* USED IN FILE HANDLING OPERATIONS.

       DECLARE FIELD
          PAGE'NUM'ADDR      /* THE PAGE NUMBER OF THE ADDRESS        */
             (0:6,12),
          PAGES'IN'FILE      /* NUMBER OF PAGES IN THE FILE           */
             (0:2,12),
          WORDS'IN'PAGE      /* WORD NUMBER IN THE LAST PAGE          */
             (0:13,23);

       DECLARE PARAMETER
          A'PAGE ← 2048;     /* WORDS TO A PAGE                       */

       DECLARE PARAMETER     /* FOR IOFLAG VALUES                     */
          READ'FILE ← 0,
          WRITE'FILE ← 1,
          APPEND'FILE ← 2;

       DECLARE PARAMETER     /* FOR OBJECT TYPES                      */
          SMALL'FILE ← 0,
          LARGE'FILE ← 1;

       DECLARE PARAMETER     /* FOR FILE TYPES                        */
          SUBCOMMAND'FILE ← 6'9SUB',
          SAVE'FILE ← 6'9SAV',
          BINARY'FILE ← 6'9BIN',
          SYMBOLIC'FILE ← 6'9SYM',
          DUMP'FILE ← 6'9DMP',
          UNKNOWN'FILE ← 6'    ';

       DECLARE PARAMETER     /* FOR THE MAXIMUM LENGTH OF FILENAMES   */
          LENGTH'PFS'NAMES ← 13,
          LENGTH'TSS'NAMES ← 16;

       DECLARE PARAMETER     /* FOR USE IN ALLOCATING FIXED AREAS OF  */
          FREE'STORAGE ← 1B5;/*   STORAGE                             */

       DECLARE PARAMETER       /* FOR USE WITH :9SYM FILES            */
           MB←135B,
           EOF←137B,
           BLANK←0B,
           CR←155B,
           LF←152B;

       DECLARE PARAMETER
          NUM'SEQ'FILES ← 3, /* CONTROLS THE NUMBER OF WINDOWS ALLO-  */
                             /*   CATED, WHICH CONTROLS THE NUMBER OF */
                             /*   FILES WHICH CAN BE OPEN AT ONE TIME */
          WINDOW'DESC'SIZE   /* THE NUMBER OF WORDS EACH ENTRY IN THE */
             ← 21;           /*   ARRAY OF WINDOW DESCRIPTORS IS      */

       DECLARE PARAMETER INDEX ← 0; * STRICTLY LOCAL

       MACRO SET'WINDOW ← DECLARE ARRAY SEQ'FILE'WINDOWS[INDEX] ←
          (FREE'STORAGE), INTEGER INDEX ← INDEX + 1,
          FREE'STORAGE ← FREE'STORAGE + A'PAGE;

       DECLARE ARRAY         /* FOR THE ADDRESS OF THE WINDOWS        */
          SEQ'FILE'WINDOWS[NUM'SEQ'FILES] ← (FREE'STORAGE);
       SET'WINDOW; SET'WINDOW;

       DECLARE ARRAY         /* OF WINDOW'DESCRIPTORS                 */
          SEQ'FILE'TABLE[NUM'SEQ'FILES:WINDOW'DESC'SIZE];

       DECLARE ARRAYONE
          OPEN'FILE'TABLE[16];
                             /* ARRAY DETERMINING WHICH FILES ARE OPEN*/
                             /* -1 MEANS THE ENTRY ISN'T USED, OTHER- OTHER-*/
                             /*   WISE, IT HOLDS THE INDEX OF THE     */
                             /*   WINDOW BEING USED                   */




       END;

       COMMON WINDOW'DEFS;
       
* THIS COMMON BLOCK DECLARES THE STRUCTURE OF A WINDOW DESCRIPTOR

       DECLARE SIGNED FIELD
          PAGE'IN'WINDOW (0:0,11); /* PAGE NUMBER OF THE FILE         */
       
       DECLARE FIELD
          PMT'INDEX (0:12,19),     /* PMT INDEX OF THE FILE           */
          WINDOW'IN'USE (0:20,20),
                                   /* BIT SIGNALING THE WINDOW IS IN  */
                                   /*   USE                           */
          LARGE'OR'SMALL (0:21,21),/* LARGE OR SMALL FILE             */
          OPERATION (0:22,23),     /* BITS REPRESENTING WHAT WILL BE  */
                                   /*   DONE TO THE FILE              */
          FILE'NUM (1:1,5),        /* NUMBER OF THE FILE              */
          WINDOW'ADDRESS (1:6,23), /* ADDRESS OF THE WINDOW IN USE    */
          CHARACTER'SIZE (2:0,5),  /* NUMBER OF BITS PER CHARACTER    */
          CHARS'PER'WORD (2:6,8),  /* NUMBER OF CHARACTERS PER WORD   */
          CHARS'PER'PAGE (2:9,23), /* NUMBER OF CHARACTERS PER PAGE   */
          NAME'STORAGE (3);        /* STORAGE FOR THE M1 FORMATTED    */
                                   /*   NAME                          */

       DECLARE STRING FIELD
          READ'DESC (11);          /* STRING DESCRIPTOR FOR A FILE    */
                                   /*   WHICH WILL BE READ            */

       DECLARE FIELD
          CHARS'LEFT (15);         /* NUMBER OF CHARACTERS YET TO BE  */
                                   /*   READ FROM THE FILE (AFTER THE */
                                   /*   CURRENT PAGE HAS BEEN READ)   */

       DECLARE STRING FIELD
          WRITE'DESC (16);         /* STRING DESCRIPTOR OF A FILE     */
                                   /*   WHICH WILL BE READ            */

       DECLARE FIELD
          LENGTH'IN'CHARS (20);    /* NUMBER OF CHARACTERS ALREADY    */
                                   /*   WRITTEN INTO THE FILE (AFTER  */
                                   /*   THE LAST PAGE HAD BEEN        */
                                   /*   WRITTEN)                      */
       

       END;

       COMMON IO'DEFS;

*      THIS COMMON BLOCK DECLARES THE FIELDS AND PARAMETERS NECESSARY
* TO PERFORM THE INPUT/OUTPUT FOR THIS PROGRAM

       DECLARE FIELD
          STATUS(0:0,1),     /* BITS SIGNIFYING WHY THE READ'STRING   */
                             /*   WAS TERMINATED                      */
          CHARS'FOUND        /* THE NUMBER OF CHARACTERS FOUND        */
            (0:2,23);

       DECLARE PARAMETER     /* FOR BREAK AND WAKEUP STRATEGIES       */
          NEVER'BREAK ← 0,
          BREAK'ON'CONTROL ← 1,
          BREAK'ON'PUN'CON ← 2,
          ALWAYS'BREAK ← 3;

       DECLARE PARAMETER     /* FOR DEVICE TYPES                      */
          NULL'DEVICE ← 0,
          TTY'37 ← 1,
          TTY'35 ← 2,
          IBM'2741 ← 3;

       DECLARE PARAMETER     /* FOR ECHO STRATEGIES                   */
          DO'NOT'ECHO ← 0,
          ECHO ← 1;

       DECLARE PARAMETER     /* FOR STATUS                            */
          NUMBER'DESIRED ← 0,
          BUFFER'EMPTIED ← 1,
          BREAK'CHAR'FOUND ← 2;

       DECLARE PARAMETER     /* FOR THE MODE OF READ'STRING           */
          DESTRUCTIVELY ← 0,
          NONDESTRUCTIVELY ← NOT DESTRUCTIVELY;

       DECLARE PARAMETER
          MOST'POSSIBLE ← -1;/* FOR READ'STRING AND WRITE'STRING      */

       DECLARE PARAMETER     /* FOR TTY INPUT/OUTPUT LINES            */
          LENGTH'TTY'LINES ← 80,
          MAX'LINE'LENGTH ← 130,
          USUAL'LINE'LIMIT ← 72;

       DECLARE PARAMETER     /* USE TTY 3 FOR THE FTP PSEUDO-TTY LINE */
          TTY'READ'LINE ← 6,
          TTY'WRITE'LINE ← 7;

       DECLARE PARAMETER     /* USE TTY 16D FOR THE FTP CONTROL LINE  */
          CNTRL'READ'LINE ← 32,
          CNTRL'WRITE'LINE← 33;


       END;


       COMMON GLOBAL'VARIABLES;

       INCLUDE
               COMDECS,
               USERDECS,
               SEQ'FILE'DEFS,
               WINDOW'DEFS,
               IO'DEFS;

       DECLARE PARAMETER

               TRUE←1,
               FALSE←0;

       END;

       PROGRAM ACCNT'FILE;

*THIS FUNCTION WRITES ACCOUNTING INFORMATION ONTO A FILE FROM
*ENTER-LOGOUT VALID CHARACTERS IN THE CALLING SEQUENCE ARE 
*I,K,N,P,E,O ALL OTHERS TAKE THE FUNCTIONS FAIL RETURN.

       INCLUDE COMDECS,SEQ'FILE'DEFS,MACHINE'DECS,USERDECS;

       DECLARE FIELD UPUN(0:0,15);

       DECLARE CHARACTER

               CH;

       DECLARE INTEGER
       
               ACCNT'FILE'NUM, /* FILE NUMBER                     */
               DAY,
               HOUR,
               MIN,
               SEC,
               I,
               LOCK'FLAG,      /* TO CONTROL WHETHER TO LOCK INSIDE*/
               NUM'LINES,      /*NUMBER OF CARRIAGE RETURNS RECORD */
               PAGE'FAULT,     /*NUMBER OF PAGE FAULTS AT LOGOUT   */
               TERM'NO,        /*LINE NUMBER OF TERMINAL           */
               UK,
               USNO;
       
       DECLARE LONG

               CPU'TIME;

       DECLARE PARAMETER

               NUM'VAL'CHAR ←     6,
               USUAL'LINE'LIMIT← 72,
               FOUR'LINE'RECORD←4*USUAL'LINE'LIMIT;

       DECLARE POINTER

               SAVE'WP;        /*WRITE POINTER FOR ASSEMBLY'LINE   */
       
       DECLARE STRING

               ACCOUNT'FILE ← "#1:X732-ACCFIL", /* SECURITY PURPOSES */
               CRLF ← "&155&152",
               ACCOUNT,
               ASSEMBLY'LINE(FOUR'LINE'RECORD),
               USRNAME,                
               USRNO(10),
               PASSWORD,
               TEMP'STRING(USUAL'LINE'LIMIT),
               V(10);

       DECLARE CHARACTER ARRAY VALID'CHAR[NUM'VAL'CHAR]←

               ('  I',
                '  K',
                '  N',
                '  P',
                '  E',
                '  O');

       FUNCTION ACCT'STR(CH,USRNAME,PASSWORD,ACCOUNT,LOCK'FLAG),FRETURN;
       
       FOR I←0 TO NUM'VAL'CHAR-1 DO;
               GOTO BEGIN IF CH = VALID'CHAR[I];
       ENDFOR;
       FRETURN;
BEGIN: 
       WCI(' ',ASSEMBLY'LINE//FAIL);
       NUM'LINES←0;

*WRITE TYPE OF ENTRY ONTO FILE STRING

       WCI(CH,ASSEMBLY'LINE//FAIL);

*WRITE USER NAME ON FILE STRING FOR 'N','P','E', OR 'O' CASES

       IF CH # 'I' AND CH # 'K' DO;
           APPEND(ASSEMBLY'LINE,"  "//FAIL);
           IF CH='P' OR CH='E' OR CH='O' DO;
               UK←READ'SPT'FIELD(-1,'UAK'//SF'PUNT);
               READ'UP'ITEM('UP',-1,0,USRNAME,"#",V,UK:V//SF'PUNT);
               USNO←SBASE(V).UPUN;
               CNS(USNO,USRNO,0,10//FAIL);
               WCI('U',ASSEMBLY'LINE//FAIL);
               APPEND(ASSEMBLY'LINE,USRNO//FAIL);
               APPEND(ASSEMBLY'LINE,"  "//FAIL);
           ENDIF;
           APPEND(ASSEMBLY'LINE,USRNAME//FAIL);
       ENDIF;

*IF PASSWORD IS INVALID WRITE ON STRING

       IF CH='P' DO;
           IF LENGTH(PASSWORD)+2+LENGTH(ASSEMBLY'LINE)
             > USUAL'LINE'LIMIT*(NUM'LINES+1) DO;
               APPEND(ASSEMBLY'LINE,CRLF//FAIL);
               NUM'LINES←NUM'LINES+1;
           ENDIF;
           APPEND(ASSEMBLY'LINE,"  "//FAIL);
           APPEND(ASSEMBLY'LINE,PASSWORD//FAIL);
       ENDIF;
       
*FOR VALID ENTER WRITE ACCOUNT ON STRING
       
       IF CH = 'E' AND LENGTH(ACCOUNT) # 0 DO;
           IF LENGTH(ACCOUNT)+1+LENGTH(ASSEMBLY'LINE)
             > USUAL'LINE'LIMIT*(NUM'LINES+1) DO;
               APPEND(ASSEMBLY'LINE,CRLF//FAIL);
               WCI(' ',ASSEMBLY'LINE//FAIL);
               NUM'LINES←NUM'LINES+1;
           ENDIF;
           WCI('[',ASSEMBLY'LINE//FAIL);
           APPEND(ASSEMBLY'LINE,ACCOUNT//FAIL);
           WCI(']',ASSEMBLY'LINE//FAIL);
       ENDIF;

*GET TERMINAL LINE NUMBER EXCEPT WHEN SYSTEM IS INITIATED

       IF CH # 'I' DO;
           TERM'NO ← LNO RSH 1;
           CNS(TERM'NO,TEMP'STRING,0,10//FAIL);
           WCI('-',TEMP'STRING//FAIL);
           CNS(THAT'PRTI,TEMP'STRING,0,10//FAIL);
           IF LENGTH(TEMP'STRING)+3+LENGTH(ASSEMBLY'LINE)
             > USUAL'LINE'LIMIT*(NUM'LINES+1) DO;
               APPEND(ASSEMBLY'LINE,CRLF//FAIL);
               NUM'LINES←NUM'LINES+1;
           ENDIF;
           APPEND(ASSEMBLY'LINE,"  "//FAIL);
           WCI('L',ASSEMBLY'LINE//FAIL);
           APPEND(ASSEMBLY'LINE,TEMP'STRING//FAIL);
       ENDIF;
       
*GET TIME AND PAGE FAULTS OR CURRENT TIME

       IF CH = 'O' DO;
           SETS(TEMP'STRING);
           PAGE'FAULT←READ'PROC'PARAM('PFC'//SF'PUNT);
           CNS(PAGE'FAULT,TEMP'STRING,0,10//FAIL);
           IF LENGTH(TEMP'STRING)+4+LENGTH(ASSEMBLY'LINE)
             > USUAL'LINE'LIMIT*(NUM'LINES+1) DO;
               APPEND(ASSEMBLY'LINE,CRLF//FAIL);
               NUM'LINES←NUM'LINES+1;
           ENDIF;
           APPEND(ASSEMBLY'LINE,"  "//FAIL);
           APPEND(ASSEMBLY'LINE,"PF"//FAIL);
           APPEND(ASSEMBLY'LINE,TEMP'STRING//FAIL);
           SETS(TEMP'STRING);
           CPU'TIME←READ'CLOCK('CTC');
           ANY'TIME'NUM(CPU'TIME:,,,DAY,HOUR,MIN,SEC);
           HOUR←HOUR+(DAY-1)*24;
           CNS(HOUR,TEMP'STRING,0,10//FAIL);
           WCI(':',TEMP'STRING//FAIL);
           CNS(MIN,TEMP'STRING,0,10//FAIL);
           WCI(':',TEMP'STRING//FAIL);
           CNS(SEC,TEMP'STRING,0,10//FAIL);
           IF LENGTH(TEMP'STRING)+3+LENGTH(ASSEMBLY'LINE)
             > USUAL'LINE'LIMIT*(NUM'LINES+1) DO;
               APPEND(ASSEMBLY'LINE,CRLF//FAIL);
               NUM'LINES←NUM'LINES+1;
           ENDIF;
           APPEND(ASSEMBLY'LINE,"  "//FAIL);
           WCI('T',ASSEMBLY'LINE//FAIL);
           APPEND(ASSEMBLY'LINE,TEMP'STRING//FAIL);
       ENDIF;
       SETS(TEMP'STRING);
       TEMP'STRING←DATE'TIME(READ'CLOCK('RTC'),TEMP'STRING//SF'PUNT);
       IF LENGTH(TEMP'STRING)+2+LENGTH(ASSEMBLY'LINE)
         > USUAL'LINE'LIMIT*(NUM'LINES+1) DO;
           APPEND(ASSEMBLY'LINE,CRLF//FAIL);
           NUM'LINES←NUM'LINES+1;
       ENDIF;
       APPEND(ASSEMBLY'LINE,"  "//FAIL);
       APPEND (ASSEMBLY'LINE,TEMP'STRING//FAIL);
       
*PUT NUMBER OF CARRIAGE RETURNS IN FIRST POSITION OF STRING IF >0
       
       IF NUM'LINES>0 DO;
           SAVE'WP←GETW(ASSEMBLY'LINE);
           SETS(ASSEMBLY'LINE);
           WCI('0'+NUM'LINES,ASSEMBLY'LINE//FAIL);
           SETW(ASSEMBLY'LINE,SAVE'WP);
       ENDIF;
       APPEND(ASSEMBLY'LINE,CRLF//FAIL);

*      LOCK ACCOUNT FILE

       LOCK() IF LOCK'FLAG=0;

* WRITE ON ACCOUNT'FILE

       ACCNT'FILE'NUM←OPEN'SEQ'FILE
                      (ACCOUNT'FILE,APPEND'FILE,SYMBOLIC'FILE,8//FAIL1);
       OUTPUT'SEQ'FILE(ACCNT'FILE'NUM,ASSEMBLY'LINE//FAIL1);
       CLOSE'SEQ'FILE(ACCNT'FILE'NUM//FAIL1);

* NOW UNLOCK THE ACCOUNT FILE SO OTHERS CAN USE IT

       UNLOCK() IF LOCK'FLAG=0;
       RETURN;

* IF THE WRITING OPERATIONS FAIL WE STILL MUST UNLOCK THINGS

FAIL1: UNLOCK();
FAIL:  FRETURN;

       END;

       PROGRAM SETUP'KLUDGE;

*      THIS FUNCTION DOES WHAT SETUP OUGHT TO DO -- TAKE A VARIABLE
* CHARACTER SIZE.  UNFORTUNATELY, THE ONLY WAY IT CAN DO IT IS BY DOING
* A SETUP FOR EACH POSSIBLE CHARACTER SIZE.

       DECLARE STRING FIELD
          STRING'DESC(0);

       DECLARE INTEGER
          BEGIN'ADDRESS,
          CHARACTER'SIZE,
          LENGTH;

       DECLARE STRING
*         KLUDGE,
          WORKING'NAME;



       UNKNOWN FUNCTION SETUP'KLUDGE(STRING @KLUDGE, LENGTH, BEGIN'ADDRESS,
          CHARACTER'SIZE), FRETURN;

       WORKING'NAME ← KLUDGE.STRING'DESC;
       IF CHARACTER'SIZE = 6 DO;
          SETUP(WORKING'NAME, LENGTH, BEGIN'ADDRESS, 6);
       ELSEIF CHARACTER'SIZE = 8 DO;
          SETUP(WORKING'NAME, LENGTH, BEGIN'ADDRESS, 8);
       ELSEIF CHARACTER'SIZE = 12 DO;
          SETUP(WORKING'NAME, LENGTH, BEGIN'ADDRESS, 12);
       ELSEIF CHARACTER'SIZE = 24 DO;
          SETUP(WORKING'NAME, LENGTH, BEGIN'ADDRESS, 24);
       ELSE DO;
          FRETURN;
       ENDIF;
       KLUDGE.STRING'DESC ← WORKING'NAME;

       RETURN;



       END;

       COMMON ARRAY'DEFS;

*      THIS COMMON BLOCK DEFINES ALL THE FIELDS USED TO MANIPULATE
* ARRAYS WITH.

       DECLARE FIELD         /* FOR THE ARRAY DESCRIPTOR ITSELF       */
          INDEXING'ORIGIN (0:2,2),
          ARRAY'TRAP'BIT (0:3,3),
          LEB (0:4,4),
          ITEM'SIZE'LEB0 (0:5,6),
          ITEM'SIZE'LEB1 (0:5,10),
          UPPER'BOUND'LEB0 (0:7,23),
          UPPER'BOUND'LEB1 (0:11,23),
          ARRAY'DESC'ADDR (1);

       DECLARE FIELD         /* FOR GENERAL INDIRECT ADDRESS WORDS    */
          IAW'TYPE (0:0,1),
          IAW'TAG (0:2,4),
          IAW'TRAP (0:5,5),
          IAW'ADDRESS (0:6,23);

       DECLARE PARAMETER     /* FOR IAW'TYPE                          */
          NORMAL'IAW ← 0,
          FIELD'IAW ← 1,
          STRING'IAW ← 2,
          ARRAY'IAW ← 3;

       DECLARE PARAMETER     /* FOR IAW'TAG                           */
          DIRECT ← 0,
          INDIRECT ← 1,
          INDEXED ← 2,
          BASE'INDEXED ← 3,
          POINTER'DISP ← 4,
          IND'PTR'DISP ← 5,
          BASE'INDEX'DISP ← 6,
          RELATIVE ← 7;


       END;

       PROGRAM CONS'ARRAY'DESC;

*      THIS FUNCTION CREATES AN ARRAY DESCRIPTOR GIVEN THE BASE ADDRESS,
* THE NUMBER OF ELEMENTS, ELEMENT SIZE, AND LOWER BOUND.  THIS FUNCTION
* FAILS IF ONE THE THE ARGUMENTS ARE INVALID.

       INCLUDE ARRAY'DEFS;

       DECLARE ARRAY
          ARRAY'DESC;

       DECLARE FIELD
          MULTIPLIER,        /* WHAT IT IS DEPENDS ON LEB             */
          UPPER'LIMIT;       /* WHAT IT IS DEPENDS ON LEB             */

       DECLARE INTEGER
          BASE'ADDRESS,      /* FIRST ADDRESS THAT STORAGE BEGINS IN  */
          ELEMENT'SIZE,      /* NUMBER OF WORDS PER ENTRY             */
          KLUDGE,
          LARGE'ELEMENT,
          LOWER'BOUND,       /* AN ARRAY OR AN ARRAYONE               */
          NO'OF'ELEMENTS,    /* NUMBER OF ELEMENTS                    */
          UPPER'BOUND;       /* HIGHEST VALID SUBSCRIPT               */



       ARRAY FUNCTION CONS'ARRAY'DESC(BASE'ADDRESS, NO'OF'ELEMENTS,
          ELEMENT'SIZE, LOWER'BOUND), FRETURN;

* CHECK THE PARAMETERS PASSED TO SEE IF THEY ARE VALID
       FRETURN IF (BASE'ADDRESS < 0 OR BASE'ADDRESS > (-1)$IAW'ADDRESS);
       FRETURN IF NO'OF'ELEMENTS < 0;
       FRETURN IF (ELEMENT'SIZE < 1 OR ELEMENT'SIZE >
          (-1)$ITEM'SIZE'LEB1 + 1);
       FRETURN IF (LOWER'BOUND # 0 AND LOWER'BOUND # 1);

* SET UP THE FIELDS FOR SMALL OR LARGE ELEMENT CASES
       IF ELEMENT'SIZE <= 4 DO;
          LARGE'ELEMENT ← 0;
          MULTIPLIER ← ITEM'SIZE'LEB0;
          UPPER'LIMIT ← UPPER'BOUND'LEB0;
       ELSE DO;
          LARGE'ELEMENT ← 1;
          MULTIPLIER ← ITEM'SIZE'LEB1;
          UPPER'LIMIT ← UPPER'BOUND'LEB1;
       ENDIF;

* COMPUTE AND CHECK UPPER'BOUND
       UPPER'BOUND ← LOWER'BOUND + NO'OF'ELEMENTS - 1;
*      A CONSTANT OR PARAMETER TAILED WITH A VARIABLE FIELD CAUSES SPL
* TO GENERATE INCORRECT CODE, SO HERE'S THE KLUDGE.
       KLUDGE ← -1;
       FRETURN IF UPPER'BOUND > KLUDGE$UPPER'LIMIT;

* CONSTRUCT AND RETURN THE DESCRIPTOR
       ARRAY'DESC$IAW'TYPE ← ARRAY'IAW;
       ARRAY'DESC$INDEXING'ORIGIN ← LOWER'BOUND;
       ARRAY'DESC$ARRAY'TRAP'BIT ← 0;
       ARRAY'DESC$LEB ← LARGE'ELEMENT;
       ARRAY'DESC$MULTIPLIER ← ELEMENT'SIZE - 1;
       ARRAY'DESC$UPPER'LIMIT ← UPPER'BOUND;
       ARRAY'DESC$ARRAY'DESC'ADDR ← NORMAL'IAW@IAW'TYPE V'
          INDEXED@IAW'TAG V' 0@IAW'TRAP V' BASE'ADDRESS@IAW'ADDRESS;

       RETURN ARRAY'DESC;


       END;

       PROGRAM OPEN'SEQ'FILE;

*      THIS FUNCTION OPENS A FILE SPECIFIED BY THE ARGUMENT FILE'NAME
* FOR INPUT OR OUTPUT DEPENDING ON THE SECOND ARGUMENT, IOFLAG.  THE
* THIRD ARGUMENT, CHAR'LENGTH DETERMINES WHAT THE SIZE OF THE CHAR-
* ACTERS READ FROM OR WRITTEN INTO THE FILE ARE.  THIS FUNCTION WILL
* FAIL FOR MANY REASONS, SUCH AS IF ANY OF THE SYSTEM CALLS IT USES
* FRETURNS.  HOWEVER, THE USER CAN CAUSE THE FUNCTION TO FAIL BY PAS-
* SING A BAD FILE NAME, OR BY SPECIFYING AN OBJECT WHICH REALLY ISN'T A
* FILE.  THIS FUNCTION ALSO FAILS IF THE USER TRIES TO OPEN A FILE WHEN
* HE ALREADY HAS THE MAXIMUM ALLOWABLE NUMBER OF FILES OPEN.

       INCLUDE GLOBAL'VARIABLES;

       DECLARE ARRAY
          FORMATTED'NAME,    /* M1 FORMATTED NAME                     */
          LENGTH'WORD[3];    /* VALUE OF THE M1 FORMATTED NAME        */


       DECLARE INTEGER
          ACCESS'SPEC,       /* ACCESS SPECIFICATION TO THE FILE      */
          CHAR'LENGTH,       /* LENGTH OF A CHARACTER IN BITS         */
          FILE'LENGTH,       /* LENGTH OF FILE IN CHARACTERS          */
          FILE'NUMBER,       /* TSS FILE NUMBER                       */
          FILE'TYPE,         /* TYPE OF FILE: SYMBOLIC, BINARY, ETC.  */
                             /*   (FILE TYPES DEFINED IN FILE'DEFS)   */
          IOFLAG,            /* OPERATION TO BE PERFORMED ON THE FILE */
                             /*   (0-RETRIEVE, 1-STORE, 2-APPEND)     */
          GARBAGE,           /* UNNECESSARY RETURNED VALUES           */
          LAST'PAGE,         /* LAST PAGE OF THE FILE                 */
          LAST'WORD,         /* LAST WORD OF THE LAST PAGE OF THE FILE*/
          OBJECT'TYPE,       /* TYPE OF FILE                          */
                             /*  (0 - SMALL FILE, 1 - LARGE FILE)     */
          PAGE'NUMBER,       /* PAGE NUMBER OF THE FILE               */
          SEQ'FILE'NUM;      /* NUMBER OF SEQUENTIAL FILES OPEN       */

       DECLARE POINTER
          FILE;              /* A POINTER TO THE FILE WINDOW          */

       DECLARE STRING
          NULL'STRING,       /* JUST A NULL STRING                    */
          FILE'NAME;         /* FILE THE USER WANTS TO OPEN           */
          



       FUNCTION OPEN'SEQ'FILE(FILE'NAME, IOFLAG, FILE'TYPE, CHAR'LENGTH),
          FRETURN;

* CAN THE USER OPEN A FILE?
       FOR SEQ'FILE'NUM ← 0 TO NUM'SEQ'FILES - 1 DO;
          GOTO SET IF NOT SEQ'FILE'TABLE[SEQ'FILE'NUM]$WINDOW'IN'USE;
       ENDFOR;
       RUNTIME'FAILURE();

* SET UP A POINTER TO THE FILE'S WINDOW DESCRIPTOR
SET:   FILE ← @SEQ'FILE'TABLE[SEQ'FILE'NUM];

* SET UP AN ARRAY DESCRIPTOR
       FORMATTED'NAME ← CONS'ARRAY'DESC(@(FILE.NAME'STORAGE), 8, 1, 0 //
          FRETURN);

* GET THE M1 FORMATTED NAME FROM THE FILE NAME TYPED IN BY THE USER
       NAME'SEARCH(FILE'NAME, FORMATTED'NAME, IOFLAG, FILE'TYPE, -1//
             FRETURN: ERCODE, ERMSNO);

* MAY HAVE TO BE CHANGED FOR THE APPEND
       ACCESS'SPEC ← ('WU' IF IOFLAG ELSE 'RU');

* IS THE FILE NEW (FORMATTED'NAME[2] = -1)?
       IF FORMATTED'NAME[2] = -1 DO;
          FILE'NUMBER ← OPEN'FILE(-1, FORMATTED'NAME, ACCESS'SPEC, -1//
             SF'PUNT);
          FILE'LENGTH ← 0;
          OBJECT'TYPE ← SMALL'FILE;

       ELSE DO;
*       THE FILE ALREADY EXISTS.  DO THIS TO BE SAFE, THE OLD NAME MAY
* NOT HAVE BEEN A MONITOR FORMATTED NAME.
          CONV'NAME(FORMATTED'NAME, FORMATTED'NAME, -1:
             GARBAGE, OBJECT'TYPE, GARBAGE//SF'PUNT);
          IF (OBJECT'TYPE = SMALL'FILE) OR (OBJECT'TYPE = LARGE'FILE) DO;
             READ'MIBOB'VALUE(FORMATTED'NAME, 1, LENGTH'WORD, 2, -1//
                SF'PUNT);
             FILE'NUMBER ← OPEN'FILE(-1, FORMATTED'NAME, ACCESS'SPEC, -1//
                SF'PUNT);
             LAST'PAGE ← LENGTH'WORD[2]$PAGES'IN'FILE - 1;
             LAST'WORD ← LENGTH'WORD[2]$WORDS'IN'PAGE + 1;
             FILE'LENGTH ← (0 IF NEXT'FILE'PAGE(FILE'NUMBER, -1//
                SF'PUNT) = -1
                ELSE (24/CHAR'LENGTH)*((2048*LAST'PAGE) + LAST'WORD));

             IF FILE'LENGTH AND IOFLAG = WRITE'FILE DO;
                DEL'SEQ'FILE(FILE'NUMBER//ABORT);
                FILE'LENGTH ← 0;
             ENDIF;
          ELSE DO;
             FRETURN;

          ENDIF;

       ENDIF;

* FILL UP THE WINDOW
       FILE.PAGE'IN'WINDOW ← -1;
       FILE.PMT'INDEX ← ACQUIRE'PMT(-1//SF'PUNT);
       FILE.WINDOW'IN'USE ← 1;
       FILE.LARGE'OR'SMALL ← (0 IF OBJECT'TYPE = SMALL'FILE ELSE 1);
       FILE.OPERATION ← IOFLAG;
       FILE.FILE'NUM ← FILE'NUMBER;
       FILE.WINDOW'ADDRESS ← SEQ'FILE'WINDOWS[SEQ'FILE'NUM];
       FILE.CHARACTER'SIZE ← CHAR'LENGTH;
       FILE.CHARS'PER'WORD ← 24/CHAR'LENGTH;
       FILE.CHARS'PER'PAGE ← 4000B*24/CHAR'LENGTH;
       FILE.CHARS'LEFT ← FILE'LENGTH;
       FILE.LENGTH'IN'CHARS ← FILE'LENGTH;

       SET'MAP'BYTE(THIS'SUB'PROCESS, FILE.WINDOW'ADDRESS$PAGE'NUM'ADDR,
          FILE.PMT'INDEX//SF'PUNT);

*      THIS IS RIDICULOUS.  THE STATEMENT SHOULD BE 
*         SETUP(NULL'STRING, 0, FILE.WINDOW'ADDRESS, CHAR'LENGTH);
* EXCEPT THAT SPL WON'T TAKE A VARIABLE CHARACTER LENGTH.
* (THERE ARE SIMILAR STATEMENTS IN MAP'IN'NEXT'PAGE AND CREATE'PAGE)
       SETUP'KLUDGE(NULL'STRING, 0, FILE.WINDOW'ADDRESS,
          FILE.CHARACTER'SIZE//ABORT);
       FILE.READ'DESC ← NULL'STRING;
       FILE.WRITE'DESC ← (PREPARE'APPEND(FILE, LAST'PAGE//ABORT) IF
          IOFLAG = APPEND'FILE ELSE NULL'STRING);
       OPEN'FILE'TABLE[FILE'NUMBER] ← SEQ'FILE'NUM;
       RETURN FILE'NUMBER;

* SOMETHING WENT WRONG, SO RESET THINGS
ABORT: FILE.WINDOW'IN'USE ← 0;
       CLOSE'SEQ'FILE(FILE'NUMBER//FRETURN);
       FRETURN;



       END;

       PROGRAM DEL'SEQ'FILE;

*      THIS FUNCTION DELETES ALL THE PAGES OF AN EXISTING FILE WHICH HAS
* BEEN OPENED FOR OUTPUT.  THE FUNCTION FAILS ONLY IF ONE OF THE MONITOR
* CALLS IT USES FAILS.  THE NAME OF THIS FUNCTION ISN'T EXACTLY AC-
* CURATE, BECAUSE IT ACTUALLY ONLY DELETES THE EXISTING PAGES OF THE
* FILE BUT DEL'FILE'PAGES IS EASILY CONFUSED WITH DEL'FILE'PAGE.

       INCLUDE GLOBAL'VARIABLES;

       DECLARE INTEGER
          FILE'NUMBER,       /* TSS FILE NUMBER                       */
          PAGE'NUMBER;       /* PAGE (MEMORY PAGE) NUMBER OF THE FILE */



       FUNCTION DEL'SEQ'FILE(FILE'NUMBER), FRETURN;

       PAGE'NUMBER ← 0;
       WHILE PAGE'NUMBER # -1 DO;
          DEL'FILE'PAGE(FILE'NUMBER, PAGE'NUMBER//
             SF'PUNT);
          PAGE'NUMBER ← NEXT'FILE'PAGE(FILE'NUMBER, PAGE'NUMBER//
             SF'PUNT);
       ENDFOR;
       SET'FILE'LENGTH(FILE'NUMBER, 0//SF'PUNT);

       RETURN;


       END;

       PROGRAM INPUT'SEQ'FILE;

*      THIS FUNCTION READS A LINE FROM A SPECIFIED FILE AND RETURNS IT
* TO THE CALLING FUNCTION.  A "LINE" IS A STRING OF CHARACTERS ENDING
* WITH A CARRIAGE RETURN LINEFEED, A CARRIAGE RETURN, OR A LINEFEED.
* THE LINE THE FUNCTION RETURNS HAS HAD ANY MULTIPLE BLANK CHARACTERS
* REMOVED AND THE APPROPRIATE NUMBER OF BLANKS INSERTED.
*      WHEN THIS FUNCTION IS CALLED THE FIRST TIME AFTER OPENING THE
* FILE, THE GCI AT READ FAILS BECAUSE FILE.READ'DESC WAS SET UP TO A
* LENGTH OF ZERO.  THE WAY END-OF-FILE IS SIGNALED IN THIS FUNCTION IS
* WHEN IT RETURNS A STRING OF LENGTH ZERO, SO THAT MUST CONSTANTLY BE
* TESTED FOR.

       INCLUDE GLOBAL'VARIABLES;

       DECLARE INTEGER
          CHAR,              /* A CHARACTER READ FROM THE FILE        */
          COUNT,             /* JUST A COUNTER FOR A FOR LOOP         */
          FINISHED,          /* A FLAG SIGNALING THAT THE FILE HAS    */
                             /*   BEEN COMPLETELY READ                */
          FILE'NUMBER;       /* THE NUMBER OF THE FILE                */

       DECLARE POINTER
          FILE;              /* A POINTER TO THE FILE WINDOW          */

       DECLARE STRING
          INPUT'DUMMY,       /* A STRING CONTAINING A PAGE OF THE FILE*/
                             /*   UNLESS IT IS THE LAST PAGE WHEN IT  */
                             /*   CONTAINS THE REMAINDER OF THE FILE  */
          OUTPUT'LINE;       /* THE STRING RETURNED WITH A LINE READ  */
                             /*   FROM THE FILE                       */



       STRING FUNCTION INPUT'SEQ'FILE(FILE'NUMBER, OUTPUT'LINE), FRETURN;

       SETS(OUTPUT'LINE);
* SET UP THE POINTER TO THE FILE
       FILE ← @SEQ'FILE'TABLE[OPEN'FILE'TABLE[FILE'NUMBER]];

* MAKE A DUMMY ASSIGNMENT OF THE STRING DESCRIPTOR TO KEEP SPL HAPPY
*   (REMEMBER TO REASSIGN FILE.READ'DESC BEFORE RETURNING)
       INPUT'DUMMY ← FILE.READ'DESC;

       FINISHED ← FALSE;
       WHILE 1 DO;
READ:     GOTO PAU IF FINISHED;
          CHAR ← GCI(INPUT'DUMMY//
             MAP'IN'NEXT'PAGE(FILE:INPUT'DUMMY, FINISHED//FRETURN) &
             GOTO READ) A' 177B;

* IS IT A MULTIPLE BLANK CHAR
          IF CHAR = MB DO;
BLANKS:      GOTO PAU IF FINISHED;
             CHAR ← GCI(INPUT'DUMMY//
                MAP'IN'NEXT'PAGE(FILE:INPUT'DUMMY, FINISHED//FRETURN) &
                GOTO BLANKS) A' 77B;
             WCI(BLANK, OUTPUT'LINE//RUNTIME'FAILURE()) FOR
                COUNT ← 1 TO CHAR - 1;
             CHAR ← BLANK;

* TEST FOR END OF LINE CHARACTER/CHARACTERS
          ELSEIF CHAR = CR DO;
C'RET:       GOTO PAU IF FINISHED;
             CHAR ← GCI(INPUT'DUMMY//
                MAP'IN'NEXT'PAGE(FILE: INPUT'DUMMY, FINISHED//FRETURN) &
                GOTO C'RET) A' 177B;

             IF CHAR = LF DO;
                WCI(CR, OUTPUT'LINE//RUNTIME'FAILURE());
             ELSE DO;
                CHAR ← CHAR V' 200B;
                INPUT'DUMMY$RP ← INCDES(INPUT'DUMMY$RP, -1);
                FILE.READ'DESC ← INPUT'DUMMY;
                RETURN OUTPUT'LINE;
             ENDIF;
          ENDIF;
          WCI(CHAR, OUTPUT'LINE//RUNTIME'FAILURE());
          IF CHAR = LF OR CHAR = CR DO;
PAU:         FILE.READ'DESC ← INPUT'DUMMY;
             RETURN OUTPUT'LINE;
          ENDIF;
       ENDFOR;

CARR:  WCI(CR, OUTPUT'LINE//FRETURN);
       FILE.READ'DESC ← INPUT'DUMMY;
       RETURN OUTPUT'LINE;




       END;

       PROGRAM INPUT'SEQ'FILE';

*      THIS FUNCTION RETURNS A SPECIFIED NUMBER OF CHARACTERS FROM THE
* FILE.  ASSUME THE FILE IS IN BINARY, SO DON'T INTERPRET ANYTHING.

       INCLUDE GLOBAL'VARIABLES;

       DECLARE INTEGER
          CHAR,              /* A CHARACTER READ FROM THE FILE        */
          COUNT,             /* JUST A COUNTER FOR A FOR LOOP         */
          FINISHED,          /* A FLAG SIGNALING THAT THE FILE HAS    */
                             /*   BEEN COMPLETELY READ                */
          FILE'NUMBER,       /* THE NUMBER OF THE FILE                */
          NUMBER'CHARS;      /* NUMBER OF CHARS TO RETURN             */

       DECLARE POINTER
          FILE;              /* A POINTER TO THE FILE WINDOW          */

       DECLARE STRING
          INPUT'DUMMY,       /* A STRING CONTAINING A PAGE OF THE FILE*/
                             /*   UNLESS IT IS THE LAST PAGE WHEN IT  */
                             /*   CONTAINS THE REMAINDER OF THE FILE  */
          OUTPUT'LINE;       /* THE STRING RETURNED WITH A LINE READ  */
                             /*   FROM THE FILE                       */



       STRING FUNCTION INPUT'SEQ'FILE'(FILE'NUMBER, OUTPUT'LINE,
          NUMBER'CHARS), FRETURN;

       SETS(OUTPUT'LINE);
* SET UP THE POINTER TO THE FILE
       FILE ← @SEQ'FILE'TABLE[OPEN'FILE'TABLE[FILE'NUMBER]];

* MAKE A DUMMY ASSIGNMENT OF THE STRING DESCRIPTOR TO KEEP SPL HAPPY
*   (REMEMBER TO REASSIGN FILE.READ'DESC BEFORE RETURNING)
       INPUT'DUMMY ← FILE.READ'DESC;

       FINISHED ← FALSE;
       FOR COUNT ← 1 TO NUMBER'CHARS DO;
READ:     GOTO PAU IF FINISHED;
          CHAR ← GCI(INPUT'DUMMY//
             MAP'IN'NEXT'PAGE(FILE:INPUT'DUMMY, FINISHED//FRETURN) &
             GOTO READ);
          WCI(CHAR, OUTPUT'LINE//FRETURN);
       ENDFOR;
PAU:   FILE.READ'DESC ← INPUT'DUMMY;
       RETURN OUTPUT'LINE;




       END;

       PROGRAM MAP'IN'NEXT'PAGE;

*      THIS FUNCTION SETS THINGS UP SO THAT ANOTHER PAGE MAY BE READ BY
* ACQUIRING A PMT INDEX FOR THE NEXT PAGE AND MAPPING IT IN.  IF IT IS
* SUCCESSFUL IN DOING THAT, THE FUNCTION RETURNS THE STRING DESCRIPTOR
* FOR THE STRING WHICH OVERLAYS THE PAGE OF THE FILE AND A FLAG SIGNAL-
* WHETHER THE FILE HAS BEEN FULLY READ.  THIS FUNCTION FAILS ONLY ON
* INTERNAL ERRORS.

       INCLUDE GLOBAL'VARIABLES;

       DECLARE INTEGER
          CHAR;              /* A CHARACTER READ FROM THE FILE        */

       DECLARE POINTER
          FILE;              /* POINTER TO THE FILE WINDOW            */

       DECLARE STRING
          INPUT'DUMMY;       /* STRING THAT CHARACTERS ARE READ FROM  */




       STRING FUNCTION MAP'IN'NEXT'PAGE(FILE), FRETURN;

* IS THE FILE WINDOW AVAILABLE?  IS THE FILE OPEN FOR INPUT?
       RUNTIME'FAILURE() IF NOT FILE.WINDOW'IN'USE OR FILE.OPERATION
          OR FILE.CHARS'LEFT < 0;

       IF FILE.CHARS'LEFT = 0 DO;
          SETUP'KLUDGE(INPUT'DUMMY, 0, FILE.WINDOW'ADDRESS,
             FILE.CHARACTER'SIZE//FRETURN);
          RETURN (INPUT'DUMMY, TRUE);
       ENDIF;
       FILE.PAGE'IN'WINDOW ← FILE.PAGE'IN'WINDOW + 1;
       CLEAR'PMT(FILE.PMT'INDEX//SF'PUNT);
       MOVE'PAGE'PMT(FILE.FILE'NUM, FILE.PAGE'IN'WINDOW, FILE.PMT'INDEX//
          SF'PUNT);

* IF THERE'S MORE THAN A PAGE LEFT
       IF FILE.CHARS'LEFT > FILE.CHARS'PER'PAGE DO;
          SETUP'KLUDGE(INPUT'DUMMY, FILE.CHARS'PER'PAGE,
             FILE.WINDOW'ADDRESS, FILE.CHARACTER'SIZE//FRETURN);
          INPUT'DUMMY$WP ← INPUT'DUMMY$EP;
          FILE.CHARS'LEFT ← FILE.CHARS'LEFT - FILE.CHARS'PER'PAGE;

* IF IT'S THE LAST PAGE
       ELSE DO;
          INPUT'DUMMY ← DET'END'OF'FILE(FILE//FRETURN);
       ENDIF;
       RETURN (INPUT'DUMMY, FALSE);


       END;

       PROGRAM DET'END'OF'FILE;

*      THIS FUNCTION DETERMINES WHERE THE LAST ACTUAL CHARACTER OF THE
* FILE IS.  THE MONITOR KNOWS THE LENGTH OF THE FILE IN WORDS.  THE
* REASON THINGS ARE SO INEXACT IS BECAUSE NO ONE KNEW HOW MANY EOF'S OLD
* SPL WROTE INTO FILES.  THIS FUNCTION WILL SET THE WRITE POINTER OF
* THE STRING TO THE RIGHT PLACE IF THE FIRST EOF IS ANYWHERE IN THE LAST
* WORD OR EVEN IF THERE IS NO EOF WRITTEN.  THE FUNCTION RETURNS A
* STRING DESCRIPTOR SETUP TO READ HOWEVER MANY CHARACTERS ARE LEFT IN
* THE FILE.

       INCLUDE GLOBAL'VARIABLES;

       DECLARE INTEGER
          CHAR,              /* A CHARACTER READ FROM THE STRING      */
          COUNT;             /* JUST A COUNTER FOR A FOR LOOP        */

       DECLARE PARAMETER
          CHARS'TO'CHECK ← 3;/* THE SPAN OF CHARACTERS CHECKED WHILE  */
                             /*   LOOKING FOR THE EOF CHARACTER       */

       DECLARE POINTER
          FILE;              /* A POINTER TO THE WINDOW IN USE        */

       DECLARE STRING
          LAST'FILE'PAGE;    /* THE STRING WHICH OVERLAYS THE WORDS   */
                             /*   OF THE FILE                         */



       STRING FUNCTION DET'END'OF'FILE(FILE), FRETURN;

       SETUP'KLUDGE(LAST'FILE'PAGE, FILE.CHARS'LEFT,
          FILE.WINDOW'ADDRESS, FILE.CHARACTER'SIZE//FRETURN);
       LAST'FILE'PAGE$WP ← LAST'FILE'PAGE$EP;
       LAST'FILE'PAGE$RP ← INCDES(LAST'FILE'PAGE$EP, -CHARS'TO'CHECK);

       FOR COUNT ← 1 TO CHARS'TO'CHECK DO;
          GOTO END'OF'FILE IF (CHAR ← GCI(LAST'FILE'PAGE) A' 177B = EOF);
       ENDFOR;
END'OF'FILE:
       LAST'FILE'PAGE$WP ← INCDES(LAST'FILE'PAGE$RP, -1) IF CHAR = EOF;
       SETR(LAST'FILE'PAGE, 0);
       FILE.CHARS'LEFT ← 0;

       RETURN LAST'FILE'PAGE;


       END;

       PROGRAM OUTPUT'SEQ'FILE;

*      THIS FUNCTION APPENDS THE STRING SPECIFIED BY ITS SECOND ARGUMENT
* TO THE FILE SPECIFIED BY THE SECOND ARGUMENT.  THE FIRST TIME THIS 
* FUNCTION IS CALLED AFTER OPENING THE FILE, ONE OF THE WCI'S WILL FAIL
* BECAUSE FILE.WRITE'DESC WAS SETUP WITH A LENGTH OF ZERO.  CREATE'NEW'-
* PAGE IS THEN CALLED TO CREATE ANOTHER FILE PAGE.  IT IS EXPECTED THAT
* INPUT'LINE WILL BE A STRING IN THE 940 CHARACTER SET, SO THAT THE
* STRING CAN SIMPLY BE WRITTEN INTO THE FILE.  THIS FUNCTION FAILS ONLY
* IF CREATE'NEW'PAGE FAILS.

       INCLUDE GLOBAL'VARIABLES;

       DECLARE INTEGER
          CHAR,              /* A CHARACTER TO BE WRITTEN INTO A FILE */
          FILE'NUMBER;       /* THE NUMBER OF THE FILE                */

       DECLARE POINTER
          FILE;              /* A POINTER TO THE FILE WINDOW          */

       DECLARE STRING
          INPUT'LINE,        /* THE STRING FROM WHICH CHARACTERS ARE  */
                             /*   WRITTEN INTO THE FILE               */
          OUTPUT'DUMMY;      /* A WORKING STRING                      */



       FUNCTION OUTPUT'SEQ'FILE(FILE'NUMBER, INPUT'LINE), FRETURN;

       FILE ← @SEQ'FILE'TABLE[OPEN'FILE'TABLE[FILE'NUMBER]];
       OUTPUT'DUMMY ← FILE.WRITE'DESC;
       WHILE 1 DO;
          CHAR ← GCI(INPUT'LINE//
             FILE.WRITE'DESC ← OUTPUT'DUMMY & RETURN);
WRITE'CHAR:
          WCI(CHAR, OUTPUT'DUMMY//OUTPUT'DUMMY ←
                CREATE'NEW'PAGE(FILE//FRETURN) & GOTO WRITE'CHAR);
       ENDFOR;



       END;

       PROGRAM CREATE'NEW'PAGE;

*      THIS FUNCTION CREATES A NEW FILE PAGE SO THAT MORE CHARACTERS CAN
* BE WRITTEN OUT TO THE FILE.  IT RESETS THE STRING OUTPUT'DUMMY SO MORE
* CHARACTERS CAN BE WRITTEN INTO IT AND OVERLAYS THE STRING ON THE PAGE
* IT HAS JUST CREATED.  THE LENGTH OF THE FILE KEPT IN THE WINDOW IS
* INCREMENTED BY A PAGE WORTH OF CHARACTERS.  IF THE PAGE ISN'T FILLED,
* CLOSE'SEQ'FILE SETS THE EXACT LENGTH WHEN IT TRIES TO CLOSE THE FILE.
* THIS FUNCTION FAILS IF ANY OF THE MONITOR CALLS IT USES FAILS.

       INCLUDE GLOBAL'VARIABLES;

       DECLARE POINTER
          FILE;              /* A POINTER TO THE FILE WINDOW          */

       DECLARE STRING
          OUTPUT'DUMMY;      /* THE STRING THAT THE CHARACTERS WILL   */
                             /*   BE WRITTEN INTO                     */



       STRING FUNCTION CREATE'NEW'PAGE(FILE), FRETURN;

* IS THE FILE REALLY OPEN?  IS IT OPEN FOR OUTPUT?
       RUNTIME'FAILURE() IF NOT FILE.WINDOW'IN'USE OR NOT FILE.OPERATION;

* DO THINGS TO MAP IN A NEW PAGE INTO THE WINDOW
       FILE.PAGE'IN'WINDOW ← FILE.PAGE'IN'WINDOW + 1;
       CR'FILE'PAGE(FILE.FILE'NUM, FILE.PAGE'IN'WINDOW//
          SF'PUNT);
       CLEAR'PMT(FILE.PMT'INDEX//SF'PUNT);
       MOVE'PAGE'PMT(FILE.FILE'NUM, FILE.PAGE'IN'WINDOW, FILE.PMT'INDEX//
          SF'PUNT);
       SETUP'KLUDGE(OUTPUT'DUMMY, FILE.CHARS'PER'PAGE,
          FILE.WINDOW'ADDRESS, FILE.CHARACTER'SIZE//FRETURN);

       FILE.LENGTH'IN'CHARS ← FILE.PAGE'IN'WINDOW*FILE.CHARS'PER'PAGE;
       RETURN OUTPUT'DUMMY;



       END;

       PROGRAM PREPARE'APPEND;

*      THIS FUNCTION IS A SPECIAL CASE OF MAP'IN'NEXT'PAGE WHERE THE
* PAGE WHICH WILL BE MAPPED INTO THE WINDOW IS THE LAST PAGE OF THE FILE.

       INCLUDE GLOBAL'VARIABLES;

       DECLARE INTEGER
          LAST'PAGE;         /* THE LAST PAGE OF THE FILE             */

       DECLARE POINTER
          FILE;              /* A POINTER TO THE FILE WINDOW          */

       DECLARE STRING
          APPEND'DESC;       /* THE STRING DESCRIPTOR SET UP SO THAT  */
                             /*   THE FILE CAN HAVE MORE CHARACTERS   */
                             /*   APPENDED TO IT                      */




       STRING FUNCTION PREPARE'APPEND(FILE, LAST'PAGE), FRETURN;

* IS THE FILE REALLY OPEN?  IS IT OPEN FOR OUTPUT?
       RUNTIME'FAILURE() IF NOT FILE.WINDOW'IN'USE OR
          FILE.OPERATION # APPEND'FILE;

* DO THINGS TO MAP IN A NEW PAGE INTO THE WINDOW
       FILE.PAGE'IN'WINDOW ← LAST'PAGE;
       CLEAR'PMT(FILE.PMT'INDEX//SF'PUNT);
       MOVE'PAGE'PMT(FILE.FILE'NUM, FILE.PAGE'IN'WINDOW, FILE.PMT'INDEX//
          SF'PUNT);
*      CHANGE THE CHARACTER COUNT SO DET'END'OF'FILE DOESN'T CREATE A
* STRING OVER A PAGE LONG.
       FILE.CHARS'LEFT ← FILE.CHARS'LEFT - FILE.CHARS'PER'PAGE*LAST'PAGE;
       APPEND'DESC ← DET'END'OF'FILE(FILE//FRETURN);
*      MOVE THE END POINTER OF THE STRING SO THAT THE STRING IS A WHOLE
* PAGE LONG.
       APPEND'DESC$EP ← INCDES(APPEND'DESC$BP, FILE.CHARS'PER'PAGE);
       FILE.LENGTH'IN'CHARS ← FILE.CHARS'PER'PAGE*(FILE.PAGE'IN'WINDOW);

       RETURN APPEND'DESC;



       END;

       PROGRAM CLOSE'SEQ'FILE;

*      THIS FUNCTION CLOSES THE FILE SPECIFIED BY ITS ONLY ARGUMENT.
* IT IS CALLED TO CLOSE BOTH FILES WHICH WERE OPENED FOR INPUT AND OUT-
* PUT.  HOWEVER, FOR FILES WHICH HAVE BEEN OPENED FOR OUTPUT, IT MUST
* DETERMINE THE EXACT LENGTH OF THE FILE AND LET THE MONITOR KNOW ABOUT
* IT.  THE FUNCTION FAILS ONLY FOR INTERNAL REASONS: THE FILE IS ALREADY
* CLOSED, OR ONE OF THE MONITOR CALLS IT USES FAILS.

       INCLUDE GLOBAL'VARIABLES;

       DECLARE INTEGER
          FILE'NUMBER,
          LENGTH'IN'WORDS;   /* LENGTH OF THE FILE IN WORDS           */

       DECLARE POINTER
          FILE;              /* A POINTER TO THE FILE WINDOW          */



       UNKNOWN FUNCTION CLOSE'SEQ'FILE(FILE'NUMBER), FRETURN;

       FILE ← @SEQ'FILE'TABLE[OPEN'FILE'TABLE[FILE'NUMBER]];
* CHECK TO SEE IF WHAT IT IS GOING TO BE CLOSED ALREADY IS
       RUNTIME'FAILURE() IF NOT FILE.WINDOW'IN'USE;
       IF FILE.OPERATION DO;
           OUTPUT'SEQ'FILE(FILE'NUMBER,"&137"// FRETURN);
          LENGTH'IN'WORDS ←
             (LENGTH(FILE.WRITE'DESC)*(FILE.CHARACTER'SIZE) + 23)/24;
          SET'FILE'LENGTH(FILE'NUMBER, LENGTH'IN'WORDS -1//
             SF'PUNT);
       ENDIF;

* FREE THE WINDOW
       CLOSE'FILE(FILE'NUMBER//SF'PUNT);
       FILE.WINDOW'IN'USE ← 0;
       OPEN'FILE'TABLE[FILE'NUMBER] ← -1;
       DELETE'PMT(FILE.PMT'INDEX//SF'PUNT);

       RETURN;



       END;
        COMMON SYSCALLS;

* MCALL DECLARATIONS

        MACRO ARBMC←UNKNOWN MONITOR;
        MACRO INTMC←INTEGER MONITOR;
        MACRO STMC←STRING MONITOR;
        MACRO LNMC←LONG MONITOR;
        MACRO LNLNMC←LONGLONG MONITOR;

* CALLS TO MANIPULATE MIBS AND SIBS
        INTMC CREATE'MIB←190;
        ARBMC READ'MIBOB'INDEX←0;
        ARBMC READ'MIBOB'NAME←1;
        ARBMC SET'MIBOB'NAME←2;
        ARBMC SET'MIBOB'ACCESS←3;
        ARBMC SET'LOCK'LIST←4;
        ARBMC DELETE'MIBOB←5;
        INTMC CREATE'MIBOB←6;
        ARBMC SET'MIB'ACCESS←10;
        INTMC READ'MIB'ACCESS←11;
        ARBMC SET'MIBOB'VALUE←12;
        INTMC COPY'MIBOB←14;* UNIMPLEMENTED
        ARBMC SET'NO'CHARGE←15;*** ???
        INTMC READ'MIB'SPACE←16;
        ARBMC SET'REF'DATE←18;*** ???
        ARBMC SET'DURABILITY←28;*** ???

* OFT CALLS
        ARBMC MREAD'OFT←20;
        ARBMC SET'OFT'AL←21;
        ARBMC SET'FILE'LENGTH←23;* IMPROVE THIS FOR UTS
        INTMC CR'FILE'PAGE←24;
        INTMC DEL'FILE'PAGE←25;
        INTMC NEXT'FILE'PAGE←26;
        ARBMC MOVE'PAGE'PMT←27;

* PMT CALLS
        INTMC ACQUIRE'PMT←50;
        ARBMC NEW'PMT'PAGE←51;
        ARBMC CLEAR'PMT←53;
        ARBMC DELETE'PMT←54;
        ARBMC SET'PMT'AL←55;
        ARBMC SET'PMT'CL←56;
        ARBMC SET'PMT'RO←57;
        ARBMC READ'PMT←58;

* WORKING SET CALLS
        ARBMC PUT'PAGE'DWS←65;
        ARBMC PUT'PAGE'CWS←66;
        INTMC DEL'PAGE'DWS←67;
        INTMC DEL'PAGE'CWS←68;
        INTMC READ'LWS←70;
        ARBMC SET'LWS←71;

* SPT CALLS
        INTMC MCREATE'SP←90;
        ARBMC MDESTROY'SP←91;
        ARBMC MREAD'SPT←95;
        ARBMC READ'SPCS←96;
        INTMC MRD'SPT'FIELD←97;
        ARBMC MST'SPT'FIELD←98;
        ARBMC READ'MAP←99;
        ARBMC SET'MAP←100;
        INTMC READ'MAP'BYTE←101;
        ARBMC SET'MAP'BYTE←102;
        INTMC READ'SPS'PARAM←106;

* SPCS CALLS
        ARBMC SP'CALL←111;
        ARBMC SP'JUMP←112;
        ARBMC SP'TRAP←113;
        ARBMC TRAP'RETURN←114;
        ARBMC SP'BRANCH←115;
        ARBMC SP'RETURN←116;
        ARBMC JUMP'RETURN←117;
        ARBMC MARK'CALL←118;
        ARBMC DELETE'CALL←119;
        ARBMC MODIFY'CALL←120;

* PROCESS CALLS
        INTMC COPY'PMT'PROC←130;
        INTMC ACTIVATE'PROC←132;
        ARBMC TRANSFER'TERM←133;
        ARBMC MAKE'DORMANT←134;
        ARBMC INIT'PROC'PAGE←135;
        ARBMC INIT'PROC'MAP←136;
        ARBMC INIT'SPT←137;
        INTMC READ'PROC'PARAM←211;

* IWS CALLS
        ARBMC SET'PROC'INT←163;
        ARBMC QUIT'BLOCK←164;
        INTMC GET'INT'NO←165;
        ARBMC READ'ICT←166;
        ARBMC ALLOW'INTS←168;
        ARBMC REFUSE'INTS←169;
        ARBMC BLOCK←170;
        ARBMC SET'ICT←172;
        ARBMC SET'ICT'CL←173;
        INTMC ACQUIRE'ICT←174;

* CHIO CALLS
        ARBMC SET'LINE'FIELD←180;
        ARBMC READ'LINE'TABLE←181;
        ARBMC READ'STRING'BRK←182;
        ARBMC WRITE'STRING←183;

* MISCELLANEOUS
        LNMC READ'CLOCK←210;
        INTMC READ'PR'PARAM←211;*** ???

* UCALL DECLARATIONS

        MACRO ARBUC←UNKNOWN UTILITY;
        MACRO INTUC←INTEGER UTILITY;
        MACRO CHRUC←CHARACTER UTILITY;
        MACRO STUC←STRING UTILITY;
        MACRO LNUC←LONG UTILITY;

* MISCELLANEOUS UCALLS
        ARBUC BREAK'POINT←0;*             UCALL FOR DEBUGGING PROGRAMS
        STUC ERRORMSG←1;*                RETURN SYSTEM ERROR MESSAGE
        STUC GET'PARAM←2;*               STRIP PARAMETER FROM STRING
        STUC GET'COM'LINE←3;*            GET CURRENT COMMAND LINE FROM UTS
        INTUC ABRV'LKP←4;*                LOOK UP ABBREVIATED NAME IN STARY
        INTUC CON'ABRV'LKP←5;*            CONTINUE SAME IN NEW STARY

* FILE SYSTEM CALLS
        ARBUC NAME'SEARCH←10;*            CONVERT FILE ST TO UTS NAME
        ARBUC SPECIAL'SEARCH←11;*         VARIATION OF ABOVE
        INTUC CONV'NAME←12;*              CONVERT FROM UTS TO MON FILE NAME
        ARBUC SPREAD'NAME←13;*            SPLIT FILE NAME STRING INTO COMP.
        ARBUC READ'MIBOB'VALUE←14;*       READ 'VALUE' OF MIB OBJECT
        ARBUC DELETE'FILE←15;*            DELETE FILE AND CONTENTS
        INTUC OPEN'FILE←16;*              OPEN FILE W/WO LOCKING
        ARBUC CLOSE'FILE←17;*             CLOSE AND UNLOCK FILE
        ARBUC READ'OFT←18;*               READ OFT
        INTUC READ'OFT'FIELD←19;*         READ OFT FIELD
        ARBUC SET'OFT'CL←20;*             SET OFT CONTROL LOCK
        ARBUC CONV'KEY←21;*               CONVERT DEFAULT ACCESS KEY

* EXTENDED SPS CALLS
        INTUC CREATE'SSP←30;*             CREATE SUBSIDIARY SUB-PROCESS
        INTUC CREATE'PSP←31;*             CREATE PARALLEL SUB-PROCESS
        ARBUC ATTACH←32;*                 ATTACH PI FILE TO SUB-PROCESS
        ARBUC DESTROY'SP←33;*             DESTROY SUB-PROCESSES
        ARBUC READ'SPT←34;*               READ SPT
        INTUC READ'SPT'FIELD←35;*         READ SPT FIELD
        ARBUC SET'SPT'FIELD←36;*          SET SPT FIELD
        STUC READ'SPNAME←37;*            READ SUB-PROC NAME
        ARBUC SET'SPNAME←38;*             SET SUB-PROC NAME
        INTUC SPNAME'SEARCH←39;*           LOOK UP SP NAME

* CIOS MANIPULATION
        INTUC CREATE'CIOS←40;*            CREATE CONTROL I/O STREAM
        INTUC READ'CIOS'FIELD←41;*        READ CIOS FIELD
        ARBUC SET'CIOS'FIELD←42;*         SET (SOME) CIOS FIELDS
        ARBUC SET'CIOS'INPUT←43;*         SET UP FOR INPUT
        ARBUC SET'CIOS'OUTPUT←44;*        SET UP FOR OUTPUT

* CIOS INPUT/OUTPUT
        ARBUC PRINT'STRING←45;*           WRITE STRING ON CIOS
        ARBUC PRINT'CHAR←46;*             WRITE (= BUFFER) CHAR ON CIOS
        ARBUC START'OUTPUT←47;*           DUMP OUTPUT BUFFER
        STUC READ'LINE←48;*              READ NEXT INPUT LINE
*STUC      EDIT'LINE ← 49;*              EDIT CURRENT LINE
        CHRUC READ'CHAR←50;*              READ NEXT CHARACTER
        ARBUC BLOCK'OB'EMPTY←51;*         WAIT UNTIL OUT BUFFER IS EMPTY

* USER PROFILE
        STUC READ'UP'ITEM←60;*           READ ITEM FROM USER PROFILE
        STUC READ'UP'NAMES←61;*          READ NAMES OF UP ITEMS
        ARBUC SET'UP'ITEM←62;*            SET (CREATE) VALUE OF UP ITEM
        ARBUC SET'UP'ACCESS←63;*          SET ACCESS TO UP ITEM
        LNUC FIND'MIB←64;*               CONVERT USER NAME/NUMBER TO MIB ADDR
        ARBUC CREATE'UP'ENTRY←65;*        CREATE USER/UP ENTRY
        ARBUC DELETE'UP'ENTRY←66;*        DELETE USER/UP ENTRY

       END;

        COMMON GLOBAL;
         INCLUDE SYSCALLS;
        DECLARE OA;            *OFT INDEX FOR ACCESS KEY
        DECLARE USER←-1;       *USER NUMBER
        DECLARE DKA'USER←0;    *USER'S MIB ADDRESS
        DECLARE SPTX←-1;       *SPT INDEX
        DECLARE C,D;           *ERROR CODES
        DECLARE FIELD W0(0),W1(1),W2(2),W3(3);
        DECLARE LONG LONG'ZERO←(0,0);

        END;

        COMMON PAGE'ALLOC;


         INCLUDE GLOBAL;
        DECLARE MAP0←32;        *START OF ALLOCATION SPACE
        DECLARE MAPN←39;        *END OF ALLOCATION SPACE
        DECLARE MAPLEN←MAPN-MAP0+1;

*ARRAY GIVING THE STATUS OF EACH PAGE OF THE ALLOCATION SPACE
*0=FREE,-1=OCCUPIED
         DECLARE ARRAY MAPA[MAPLEN];

*ARRAY GIVING THE PMT INDICES CORRESPONDING TO THE PAGES
*OF THE ALLOCATION SPACE
         DECLARE ARRAY PMT[MAPLEN];
        DECLARE MAPX;           *THE HIGHEST NUMBERED PAGE
*                              REFERENCED SO FAR


         END;

        COMMON DECDECS;
*
* SHORT DECLARATION MACROS FOR SPL
*

        MACRO INT←DECLARE INTEGER;
        MACRO OCT←DECLARE OCTAL;
        MACRO PTR←DECLARE POINTER;
        MACRO CHR←DECLARE CHARACTER;
        MACRO ST←DECLARE STRING;
        MACRO LN←DECLARE LONG;
        MACRO LNLN←DECLARE LONGLONG;
        MACRO LB←DECLARE LABEL;

        MACRO UINFL←DECLARE INTEGER FIELD;* /OCTFL/UINFL/
        MACRO SINFL←DECLARE INTEGER SIGNED FIELD;* /INTFL/SINFL/
        MACRO PTRFL←DECLARE POINTER FIELD;
        MACRO CHRFL←DECLARE CHARACTER FIELD;
        MACRO STFL←DECLARE STRING FIELD;
        MACRO LNFL←DECLARE LONG FIELD;
        MACRO FNFL←DECLARE FUNCTION FIELD;

        MACRO INTARY←DECLARE INTEGER ARRAY;
        MACRO PTRARY←DECLARE POINTER ARRAY;
        MACRO CHRARY←DECLARE CHARACTER ARRAY;
        MACRO STARY←DECLARE STRING ARRAY;
        MACRO LNARY←DECLARE LONG ARRAY;
        MACRO LBARY←DECLARE LABEL ARRAY;
        MACRO FLARY←DECLARE FIELD ARRAY;
        MACRO FNARY←DECLARE FUNCTION ARRAY;

        MACRO INTARY1←DECLARE INTEGER ARRAYONE;
        MACRO PTRARY1←DECLARE POINTER ARRAYONE;

        MACRO INTFN←DECLARE INTEGER FUNCTION;

        MACRO ARBENT←UNKNOWN ENTRY;
        MACRO INTENT←INTEGER ENTRY;
        MACRO PTRENT←POINTER ENTRY;
        MACRO CHRENT←CHARACTER ENTRY;
        MACRO STENT←STRING ENTRY;
        MACRO LNENT←LONG ENTRY;
        MACRO LBENT←LABEL ENTRY;
        MACRO ARYENT←ARRAY ENTRY;

        MACRO ARBEXT←DECLARE UNKNOWN EXTERNAL;
        MACRO INTEXT←DECLARE INTEGER EXTERNAL;
        MACRO PTREXT←DECLARE POINTER EXTERNAL;
        MACRO CHREXT←DECLARE CHARACTER EXTERNAL;
        MACRO STEXT←DECLARE STRING EXTERNAL;
        MACRO LNEXT←DECLARE LONG EXTERNAL;
        MACRO LBEXT←DECLARE LABEL EXTERNAL;
        MACRO ARYEXT←DECLARE ARRAY EXTERNAL;


        MACRO LTABLE(F)←F$FLDWDSP+1;
        SINFL FLDWDSP(0:13,23);

* LENGTHS OF NAMES
        INT LMN←4,LTY←1,LFN←LMN+LTY;
        INT NBY←4,LNCH←24/NBY,NMNCH←LMN*NBY,
        NTYCH←LTY*NBY,NFNCH←LFN*NBY,NCMCH←90;

       END;

        COMMON MACHINE'DECS; INCLUDE DECDECS;
*
* DECLARATIONS FOR MACHINE-DEPENDENT PROGRAMMING
*

* LOW-G DEFINITIONS
        PTR STACK'PTR= G' [2],STACK'LIM= G' [3],
        RTRAP'PARAM= G' [5],RTRAP'LOC= G' [4];

* FIELDS IN BLL DESCRIPTOR
        PTRFL BRDPC(0:6,23),BRDLR(1:6,23);

* STATE DEFINTIONS
        INT PSTLOC←0,ASTLOC←1,BSTLOC←2,CSTLOC←3,DSTLOC←4,
        XSTLOC←6,LSTLOC←7,GSTLOC←8,ESTLOC←5,SSTLOC←9,
        LSTATE←10;

* FIELDS FOR TRAP DEFINITIONS
        UINFL ADDR(0:6,23),SP'TNO(-2),SP'TPAR(-1),BLL'CLASS(0:3,5),
        UTSE'CLASS(0:0,1),UTSE'SPTNO(0:1,5),UTSE'RTNO(0:2,5);

       END;

        COMMON COMDECS; INCLUDE DECDECS,SYSCALLS;
*
* COMMON DECLARATIONS FOR CODING
*

* GENERALLY USEFUL MACROS

        MACRO NAMSET(S,L,A,B)←SETUP(S,L,A,B) & S$WP←S$EP;
        MACRO EMPTY(S)←LNGDES(S$RP,S$WP)<=0;*** WP=RP OR WP=BP?
        MACRO REPEAT← WHILE 1 DO;
        MACRO ENDRPT← ENDFOR;
        MACRO FDISP(F)←RUNTIME'FAILURE() IF F$FLDSTB#0 AND
        F$FLDSIZE#24 ELSE F$FLDWDSP;
        UINFL FLDSTB(0:8,12),FLDSIZE(0:3,7);

* ERROR MACROS
        MACRO NC'PUNT←RUNTIME'FAILURE();* FOR NORMAL CALLS (EXPRESSIONS)
        MACRO LF'PUNT← VALUE NC'PUNT;* FOR LIBRARY FUNCTIONS
        MACRO SF'PUNT←LF'PUNT:ERCODE,ERMSNO;* FOR SYSTEM CALLS

* QUIT ACTION MACROS
        MACRO QUIT'PUNT(L)← VALUE GOTO L IF ERCODE='QIT' ELSE
        RUNTIME'FAILURE():ERCODE,ERMSNO;
        MACRO QUIT'PUNTX(L,X)← VALUE GOTO L IF ERCODE='QIT' ELSE
        RUNTIME'FAILURE():X,ERCODE,ERMSNO;

* PARAMETRIC CHARACTER DEFINITIONS
        CHR SCHERALD←'>' /* SUB-COMMAND HERALD */,
        BELCH←303B /* BELL */,NULCH←300B /* NULL */,
        NLCH←307B /* NEW LINE */,
        LFCH←310B /* LINE FEED */,
        MBCH←200B /* ZERO MULTIPLE BLANKS */,
        SQTCH←'&'' /* SINGLE QUOTE */,
        DQTCH←'"' /* DOUBLE QUOTE */,
        SEPCH←'-' /* SEPARATOR */;

* STRING POINTER FIELDS
        UINFL BP(0) /* BEGINNING */,RP(1) /* READER */,
        WP(2) /* WRITER */,EP(3) /* END */;
* CHARACTER FIELDS
        UINFL CH0(0:0,7),CH1(0:8,15),CH2(0:16,23);
* BEAD LENGTH FIELD
        UINFL LENGF(-1:6,23);

* FIELDS IN UTILITY FILE NAME
        LNFL UFNUN(0) /* USER NUMBER/DISK ADDRESS */;
        UINFL UFNEN(2) /* OBJECT ENTRY-NUMBER */,
        UFNFN(3) /* FILE NAME */,UFNMN(3) /* MAIN NAME */,
        UFNTY(3+LMN) /* TYPE WORD */;

* FIELDS FOR UNO/DKA
        UINFL UNDKUN(0),
        UNDKDK(1);

        INT LUFN←LTABLE(UFNTY);* LENGTH OF UTILITY FILE:NAME

        INT CB'PMT←1;* PMT ADDRESS OF CONTEXT BLOCK

* DECLARATIONS OF COMMON FUNCTIONS

* SPL RUNTIME FUNCTIONS
*ARBEXT    SCOPY, APPEND, CNS, RUNTIME'FAILURE;
        ARYEXT LBARY'KLUDGE;*, AR'DESC;
        PTREXT SBASE; INTEXT ARRAYUB,ARRAYLB;* STEXT ST'DESC;
        LNEXT LONG'ADD,LONG'SUB; INTEXT LONG'LE,LONG'LT;

* STORAGE ALLOCATOR
        PTREXT STKMAKE;*, MAKE, SETZONE;
*ARBEXT    STORINIT, SELZONE, EXTZONE, FREE, FREEZONE;

       END;

        COMMON UQNDECS; INCLUDE DECDECS;

* UNIQUE NAME FIELDS
        UINFL UQNTY(0:0,1),UQNPMB(0:0,0),UQNLFB(0:1,1),
        UQNOWN(0:2,17),UQNHFN(0:18,23);
        UINFL UQNLFN(1:0,12),UQNLPN(1:13,23),
        UQNSFN(1:0,15),UQNSPN(1:16,23);

       END;

        COMMON BFSDECS; INCLUDE UQNDECS;

* OBJECT TYPE-CODES
        INT SIBSFCD←0,SIBLFCD←1,SIBPRCD←2,SIBAKCD←3,
        SIBRSCD←4,SIBOWCD←5,SIBFRCD←6,
        SIBSCCD←14,SIBLKCD←15;

* ACCESS KEY FIELDS
        UINFL ACK0(0),ACK1(1:0,7),ACKUN(1:8,23);
        INT NORM'FIL'AC←0357B;* P(NO) F(RW) O(OW) - NORMAL ACCESS

       END;

        COMMON OFTDECS; INCLUDE BFSDECS;

* FIELDS IN OFT
        UINFL OFTUB(0:0,0),OFTRB(0:1,1),OFTWB(0:2,2),OFTXB(0:3,3),
        OFTOB(0:4,4),OFTMIX(0:6,12),
        OFTAL(0:15,23);* BETTER CHECK THIS WITH REVISION

        UINFL OFTCL(1:15,23),
        OFTOT(2:0,3),OFTPIB(2:8,15),OFTPMIB(2:16,23);
        LNFL OFTUN(3);

        INT NOFT←16,LOFT←LTABLE(OFTUN)+1;


       END;

        COMMON SIBDECS; INCLUDE BFSDECS;
*
* DECLARATIONS FOR SIB
*

* FIELDS IN SIB NAME (SIBN)
        UINFL SIBNOT(0:1,4),
        SIBNLN(0:10,23),
        SIBNAA(1:1,4),SIBNEN(1:10,23),
        SIBNMN(2),SIBNFN(2);
        UINFL SIBNTY(SIBNMN$FLDWDSP+LMN),
        SIBNLL(SIBNTY$FLDWDSP+1:4,11),
        SIBNAC(SIBNLL$FLDWDSP:12,23);
        UINFL SIBNPA(SIBNAC$FLDWDSP:12,15),
        SIBNFA(SIBNAC$FLDWDSP:16,19),
        SIBNOA(SIBNAC$FLDWDSP:20,23);

        INT LSIBN←LTABLE(SIBNOA);* LENGTH OF SIBN TABLE

* FIELDS IN SIB VALUE (SIBV)
        UINFL SIBVOT(0:1,4),
        SIBVLN(0:10,23),
        SIBVAA(1:1,4),SIBVEN(1:10,23);
        LNFL SIBFLUN(2);
        UINFL SIBFLLEN(4),
        SIBFLWD(5),
        SIBFLRD(6);

        LNFL SIBLKUN(2);
        UINFL SIBLKEN(4),
        SIBLKMN(5),
        SIBLKTY(5+LMN);

        INT LSIBFL←LTABLE(SIBFLRD),LSIBLK←LTABLE(SIBLKTY),
        LSIBV←(LSIBFL IF LSIBFL>LSIBLK ELSE LSIBLK);
        INT MLSIB←(LSIBV IF LSIBV>LSIBN ELSE LSIBN);

       END;

        COMMON PMTDECS; INCLUDE UQNDECS;

* FIELDS FOR PMT ENTRY
        LNFL PMTUN(0);
        UINFL PMTFL(2:0,0),PMTDKA(2:2,23),
        PMTRO(3:0,0),PMTAL(3:3,11),PMTCL(3:15,23);

        INT NPMT←128;* NUMBER OF PMT ENTRIES
        INT LPMT←5;* SIZE OF PMT ENTRY


       END;

        COMMON SPTDECS; INCLUDE DECDECS;

* FIELDS IN SPCS
        UINFL SPCSNIS(0:0,0),SPCSNIC(0:1,1),
        SPCSCSP(0:2,5),SPCSPR(0:6,23),
        SPCS940M(1:0,0),SPCSR0SP(1:2,5),SPCSLR(1:6,23),
        SPCSR1SP(2:2,5),SPCSGR(2:6,23);
        LNFL SPCSIT(3);
        INT LSPCS←LTABLE(SPCSIT)+1;

        INT NSPT←8;

       END;

        COMMON ATTACHDECS; INCLUDE DECDECS;
*
* DEFINITION OF ATTACH (PI) FILE HEADER
*
        UINFL ATFMT(0),ATNP(1),ATMAP(3),ATMNM(38),
        ATCUF(43),ATEP(44),ATEG(45);
        UINFL BYTEC(0:12,13),BYTEP(0:16,23);

        INT FMTCODE←0;* VALUE OF CURRENT FORMAT

       END;

        COMMON ICTDECS; INCLUDE DECDECS;

* FIELDS IN ICT
        UINFL ICTSRC(0:0,2) /* SOURCE */,
        ICTACT(0:3,5) /* ACTION */,
        ICTSPEC(0:6,10) /* SUB-PROCESS/TRAP */,
        ICTBLK(0:11,11) /* BLOCKING */,
        ICTCL(0:15,23) /* CONTROL LOCK */;
        LNFL ICTTM(1);* REAL/COMPUTE TIME VALUE

        INT NICT←24,LICT←LTABLE(ICTTM)+1;

* VALUES FOR SOURCE-ACTION-BLOCK PARAMETER OF SET'ICT
        MACRO ICT'SAB(S,A,B)←S@ICTSRC V' A@ICTACT V' B@ICTBLK;
        INT ICTNULCD←ICT'SAB(0,0,0) /* NULL */,
        ICTBLKCD←ICT'SAB(1,0,1) /* BLOCKING */,
        ICTTRPCD←ICT'SAB(1,2,1) /* TRAP */,
        ICTRTICD←ICT'SAB(2,1,1) /* REAL-TIME INTERRUPR */;

       END;

        PROGRAM LABEL'KLUDGE; INCLUDE DECDECS;
*
* CONVERT SOURCE-RELATIVE LABEL ARRAY TO ABSOLUTE
*
        LB L; LBARY A;


        ARYENT LBARY'KLUDGE(A); RETURN A;

       END;

        PROGRAM LONG'COMPARE; INCLUDE DECDECS;
*
* COMPARE LONG VALUES
*
        PTR P,Q; INT N; UINFL W0(0);

        INTENT LONG'COMPARE(INTEGER @P,INTEGER @Q,N);

        RETURN 1 IF P[N]$W0#Q[N]$W0 FOR N←N-1 BY -1 TO 0;
        RETURN 0;

       END;

        PROGRAM SCOPY; INCLUDE COMDECS;
        PTR P; ST S,D; STFL A(0);

        ARBENT SCOPY(STRING @P,S), FRETURN;
        D←P.A; P.RP←D$WP←D$RP←D$BP; GOTO L;

        ARBENT APPEND(STRING @P,S), FRETURN;
        D←P.A;

****      CHECK STRING CHARACTER SIZES FOR COMPATABILITY
L:
        REPEAT; WCI(GCI(S// VALUE P.WP←D$WP & RETURN),D// FRETURN); ENDRPT;

       END;

PROGRAM COMPARE'STRING;

       /* THIS PROGRAM COMPARES TWO STRINGS, RETURNS 1 IF SAME, ELSE 0 */

       DECLARE INTEGER FIELD CHAR'SIZE(0:2,3);
       DECLARE INTEGER CHAR1, CHAR2, COUNT, LENGTH'SECOND;
       DECLARE STRING FIRST, SECOND;

FUNCTION COMPARE'STRING(FIRST, SECOND);

       RETURN 0 IF SECOND$CHAR'SIZE # FIRST$CHAR'SIZE;

       IF LENGTH(FIRST) # LENGTH(SECOND) DO;
           RETURN 0;
       ELSE DO;
           LENGTH'SECOND ← LENGTH(SECOND);
           FOR COUNT ← 1 TO LENGTH'SECOND DO;
               CHAR1 ← GCI(FIRST);
               CHAR2 ← GCI(SECOND);
               RETURN 0 IF CHAR1 # CHAR2;
           ENDFOR;
           RETURN 1;
       ENDIF;


END;

        PROGRAM ST'DESC; INCLUDE COMDECS;
        INT N,S,O; PTR P; ST X;
        STENT ST'DESC(N,P,S,O);

        P←MAKE(S*(N+24/S-1)/24) IF P=0;

        IF S=8 DO;
            .LDA 44B6;
        ELSEIF S=6 DO;
            .LDA 40B6;
        ELSEIF S=12 DO;
            .LDA 50B6;
        ELSEIF S=24 DO;
            .LDA 54B6;
        ELSE DO;
            RUNTIME'FAILURE();
        ENDIF;

        .IOR P; .XMA O; .LSHA 18; .IOR O; .LDX-1; .ASP; .CXA;
        .STA X$BP; .STA X$RP; .STA X$WP; .LDX N; .ASP; .STX X$EP;
        RETURN X;

       END;

        PROGRAM AR'DESC; INCLUDE COMDECS;
        INT N,S,O; PTR P;
        ARYENT AR'DESC(N,P,S,O);

        N←N-1 IF O=0;
        RUNTIME'FAILURE() IF S>63 OR S<1 OR S>3 AND N>17777B OR
        N>377777B OR N<O OR O#0 AND O#1;

        P←MAKE((N+1 IF O=0 ELSE N)*S) IF P=0;

        .LDA S; .SUB 1; .ICP 2; .BGT R' [3]; .IOR 100B; .LSHA 6; .LSHA 11;
        .IOR N; .CPZ O; .BEQ R' [2]; .IOR 1B7; .IOR 6B7; .CAB;
        .LDA P; .IOR 4B6; .XAB; RETURN;

       END;

        PROGRAM CNS; INCLUDE COMDECS;
        INT N,F,R,T,I,D; PTR P; ST S,B(25); STFL A(0);

        ARBENT CNS(N,STRING @P,F,R), FRETURN;

        S←P.A;
        FRETURN IF R<2 OR R>36;
        T←(-N IF F>=0 AND N<0 ELSE N);
        B$RP←B$WP←B$EP; I←0;
LP:     .LDA T; .LSHD-23; .DIV R; .STA T; .STB D;
        WCD(D+('0' IF D<10 ELSE 'A'-10),B);
        I←I+1; GOTO LP IF T#0;
        WCD('-',B) & I←I+1 IF F>=0 AND N<0;
        F←F A' 77B;
        IF F=0 DO;
            F←I;
        ELSEIF F<=I DO;
            B$RP←INCDES(B$EP,-I);
        ELSE DO;
            WCI(' ',S// FRETURN) FOR I←I+1 TO F;
        ENDIF;
        WCI(D,S// FRETURN)
        FOR D←GCI(B// VALUE P.WP←S$WP & RETURN) WHILE 1;

       END;

        PROGRAM CSN; INCLUDE COMDECS;
        PTR P; INT R,F,D,N; ST S; STFL A(0);

        INTENT CSN(STRING @P,R), FRETURN;

        S←P.A; FRETURN IF R<2 OR R>36;

        IF D←GCI(S// FRETURN)='-' OR D='+' DO;
            F←(1 IF D='-' ELSE 0); D←GCI(S// FRETURN);
        ELSE DO;
            F←0;
        ENDIF;

        D←D-'0' IF D>='0' AND D<='9' ELSE
        D←D-('A'-10) IF D>='A' AND D<='Z' ELSE FRETURN;
        FRETURN IF D>=R; N←D;

        FOR D←GCI(S//Y) REPEAT;
            D←D-'0' IF D>='0' AND D<='9' ELSE
            D←D-('A'-10) IF D>='A' AND D<='Z' ELSE GOTO X;
            GOTO X IF D>=R; N←N*R+D;
        ENDRPT;

X:      S$RP←INCDES(S$RP,-1);
Y:      P.RP←S$RP; RETURN (-N IF F ELSE N);

       END;

        PROGRAM SBASE; INCLUDE COMDECS;
*
* FIND BASE ADDRESS OF WORD-ORIGINED STRING DESCRIPTOR
*
        ST S;

        PTRENT SBASE(S);
        .LDA S$BP; .LDX 1; .ASP; .CXA;
        .CMZ 3B6; .BNE L; .ETR 777777B; RETURN;
L:      RUNTIME'FAILURE();

       END;

        PROGRAM ALENGTH; INCLUDE COMDECS;
*
* COMPUTE ARRAY BOUNDS
*
        PTR A; UINFL ABW(0);
        INTENT ARRAYUB(A);
        .LDA A.ABW; .CMZ 2B6; .BNE R' [2]; .ETR 17777B;
        .ETR 377777B; RETURN;

        INTENT ARRAYLB(A);
        .LDA A.ABW; .ETR 1B7; .ASHA-21; RETURN;

       END;

        PROGRAM LONG'ARITH; INCLUDE COMDECS;
*
* LONG ARITHMETIC/RELATIONALS
*
        LN X,Y; UINFL W0(0),W1(1);

        LNENT LONG'ADD(X,Y);* ADD
        .LDA X$W1,ADD Y$W1,CAB;
        .LDA X$W0,ADC Y$W0; RETURN;

        LNENT LONG'SUB(X,Y);* SUBTRACT
        .LDA X$W1,SUB Y$W1,CAB;
        .LDA X$W0,SUC Y$W0; RETURN;

        INTENT LONG'LE(X,Y);* LESS THAN OR EQUALS
        RETURN (1 IF LONG'SUB(X,Y)$W0<=0 ELSE 0);

        INTENT LONG'LT(X,Y);* LESS THAN
        RETURN (1 IF LONG'SUB(X,Y)$W0<0 ELSE 0);

       END;

        COMMON ALLOC'DECS;

*
* SPL STORAGE ALLOCATOR
*

* THE BASIC STRUCTURE OF A STORAGE BLOCK IS AS IN THE OLD ALLOCATOR,
* I.E. THE WORD BEFORE THE 0'TH WORD OF A BLOCK CONTAINS THE LENGTH
* OF THE BLOCK (NUMBER OF INFORMATION WORDS +1), A FLAG IN BIT 0
* TO SAY THAT THE BLOCK IS FREE, AND A FLAG IN BIT 1 TO SAY THAT
* THE NEXT LOWER BLOCK IS FREE.
        DECLARE FIELD HIDDEN(-1),HSIZE(-1:6,23),HFREE(-1:0,0),
        HFTAG(-1:1,1),HZTAG(-1:2,2);
* FREE STORAGE COMES IN ZONES.  A ZONE CONSISTS OF A ZONE HEADER
* AND A CHAIN OF EXTENSIONS.  THE ZONE HEADER CONTAINS: THE BLOCK
* SIZE FOR THE ZONE (0 MEANS ALL SIZES ARE ALLOWABLE), THE OVERFLOW
* ROUTINE, THE EXTENSION LIST, AND THE FREE LIST ROVER.
        DECLARE FIELD FEXT(0),FLIST(2),FUEXT(3),FUNCTION FIELD FOVX(1);
        DECLARE PARAMETER FZHS←4;
* THE FEXT WORD IN EACH EXTENSION POINTS TO THE NEXT ONE.  THIS CHAIN,
* IS TERMINATED BY A -1.  THE FIRST TWO WORDS
* OF A FREE BLOCK ARE USED TO HOLD THE ADDRESS OF THE NEXT FREE
* BLOCK AND THE PREVIOUS FREE BLOCK.  THIS LIST IS CIRCULAR.
        DECLARE FIELD NBLK(0),PBLK(1);
* FOR FIXED-SIZE ZONES, THE ENTIRE FREE LIST AND THE HIDDEN WORDS
* ARE SET UP AT THE TIME AN EXTENSION IS CREATED.  FOR VARIABLE-SIZED
* ZONES, AN EXTENSION IS SET UP AS A SINGLE FREE BLOCK WHICH IS
* SUBDIVIDED AS THE NEED ARISES.  A FIRST-FIT STRATEGY WITH A "ROVER"
* IS USED FOR THE LATTER.  BLOCKS BELOW A MINIMUM SIZE WILL NOT BE CREATED.
        DECLARE PARAMETER MINSIZ←3;

        DECLARE INFINITY'ZONE,CURRENT'ZONE;* ZONE VARIABLES FOR ALLOCATOR

       END;

        PROGRAM STKMAKE; INCLUDE ALLOC'DECS;
        FIXED;
*
* ALLOCATE LOCAL (STACKED) STORAGE
*
        DECLARE SP= G' [2],SL= G' [3],BLK,SIZE;

        FUNCTION STKMAKE(SIZE);

        RUNTIME'FAILURE() IF SP+SIZE>=SL;
        SP←(BLK←SP+1)+SIZE;
        BLK.HIDDEN←SIZE+1;
        BSET(BLK,0,SIZE);
        RETURN BLK;

       END;

        PROGRAM MAKE; INCLUDE ALLOC'DECS;
*
* ASSIGN BLOCK OF SIZE (A) IN ZONE (B)
*
        DECLARE BLK,ROVER,RSIZE,EBLK,ROVEC;

        FUNCTION MAKE(SIZE,ZONE);

        ZONE←CURRENT'ZONE IF ZONE=0;
        SIZE←SIZE+1;
        GOTO MAKEOV IF ZONE.FLIST<0;
* VARIABLE-SIZED ZONE
        ROVEC←ROVER←ZONE.FLIST;
MAKE1:  RSIZE←ROVER.HSIZE;
        IF RSIZE<SIZE+MINSIZ AND RSIZE#SIZE DO;
            GOTO MAKE1 IF (ROVER←ROVER.NBLK)#ROVEC
            ELSE GOTO MAKEOV;
        ENDIF;
        EBLK←(BLK←ROVER)+ROVER.HSIZE;
        EBLK.HFTAG←0;
        IF ROVER.HSIZE=SIZE DO;
* EXACT FIT
            BLK.HFREE←0;
            ZONE.FLIST←RFB(ROVER,ZONE);
        ELSE DO;
* SPLIT THE BLOCK
            BLK←EBLK-SIZE;
            BLK.HIDDEN←1@HFTAG+SIZE;
            BLK[-2]←-(ROVER.HSIZE←ROVER.HSIZE-SIZE);
        ENDIF;
* COMMON EXIT
        BSET(BLK,0,SIZE-1);
        RETURN BLK;

* OVERFLOW
MAKEOV: BLK←(ZONE.FOVX)(SIZE-1,ZONE); RETURN BLK;

       END;

        PROGRAM RFB; INCLUDE ALLOC'DECS;
        FUNCTION RFB(RBLK,ZONE);
* SUBROUTINE TO REMOVE A BLOCK FROM THE FREELIST
        IF RBLK.NBLK=RBLK DO;
            RETURN ZONE.FLIST←-1;
        ELSE DO;
            RBLK.NBLK.PBLK←RBLK.PBLK;
            RETURN RBLK.PBLK.NBLK←RBLK.NBLK;
        ENDIF;

       END;

        PROGRAM FREE; INCLUDE ALLOC'DECS;
*
* RELEASE BLOCK (A) TO ZONE (B)
*
        DECLARE EXPTR,EFB,PFB;

        FUNCTION FREE(BLK,ZONE);
        EFB←BLK+BLK.HSIZE;
        ZONE←CURRENT'ZONE IF ZONE=0;
        BLK.HFREE←1;
* VARIABLE-SIZED ZONE
* CHECK FOR MERGE WITH NEXT HIGHER BLOCK
        IF EFB.HFREE DO;
            BLK.HIDDEN←BLK.HIDDEN+EFB.HSIZE;
            RFB(EFB,ZONE);
            EFB←BLK+BLK.HSIZE;
        ENDIF;
* CHECK FOR MERGE WITH NEXT LOWER BLOCK
        IF BLK.HFTAG DO;
            PFB←BLK+(BLK[-2] IF BLK[-2]<0 ELSE -3);
            PFB.HIDDEN←PFB.HIDDEN+BLK.HSIZE;
            RFB(BLK←PFB,ZONE);
        ENDIF;
* CLEAN UP
        EFB.HFTAG←1;
        EFB[-2]←-BLK.HSIZE;
        FPB(BLK,ZONE);
        RETURN;

       END;

        PROGRAM FPB; INCLUDE ALLOC'DECS;
* SUBROUTINE TO PUT A BLOCK ON THE FREELIST
        DECLARE ZFP,ZNBP;

        FUNCTION FPB(BLK,ZONE);
        ZFP←ZONE.FLIST;
        IF ZFP<0 DO;
            ZONE.FLIST←BLK.NBLK←BLK.PBLK←BLK;
        ELSE DO;
            ZNBP←ZFP.NBLK;
            ZFP.NBLK←ZNBP.PBLK←BLK;
            BLK.NBLK←ZNBP;
            BLK.PBLK←ZFP;
        ENDIF;
        RETURN;

       END;

        PROGRAM SELZONE; INCLUDE ALLOC'DECS;

        FUNCTION SELZONE(ZONE);
        CURRENT'ZONE←ZONE; RETURN;

       END;

        PROGRAM STORINIT; INCLUDE ALLOC'DECS;
*
* SET UP ZONES
*

        FUNCTION STORINIT(ZONE,SIZE), FRETURN;
        (ZONE←ZONE+1).HIDDEN←SIZE;
        SETZONE(ZONE// FRETURN);
        CURRENT'ZONE←INFINITY'ZONE←ZONE; RETURN;

       END;

        PROGRAM SETZONE; INCLUDE ALLOC'DECS;
*
* INITIALIZE ZONE
*
        DECLARE FAREA,FUNCTION DUMBFUCN←OFLOTRAP;

        FUNCTION SETZONE(ZONE), FRETURN;
        FRETURN IF ZONE.HSIZE<FZHS+MINSIZ+4;
        ZONE.HZTAG←1;
        ZONE.FOVX←DUMBFUCN;
        ZONE.FLIST←-1;
        ZONE.FUEXT←0;
        FAREA←ZONE+(FZHS+1);
        FAREA.HIDDEN←ZONE.HSIZE-(FZHS+1);
        EXTZONE(FAREA,ZONE// VALUE RUNTIME'FAILURE());
        ZONE.FEXT←-1; RETURN ZONE;

       END;

        PROGRAM EXTZONE; INCLUDE ALLOC'DECS;
*
* ADD EXTENSION (B) TO ZONE (A)
*
        DECLARE EEXT,EXB;

        FUNCTION EXTZONE(EXT,ZONE), FRETURN;
        FRETURN IF EXT.HSIZE<MINSIZ+2;
        EEXT←EXT+EXT.HSIZE;
        EXT.FEXT←ZONE.FEXT;
        ZONE.FEXT←EXT;
        EXB←EXT+2;
        EXB.HIDDEN←(1@HFREE-3)+EXT.HSIZE;
        (EEXT-1).HIDDEN←1@HFTAG;
        FPB(EXB,ZONE);
        RETURN;

       END;

        PROGRAM FREEZONE; INCLUDE ALLOC'DECS;
*
* DELETE ZONE (A)
*
        DECLARE ZEPTR;

        FUNCTION FREEZONE(ZF,ZF1);
        SELZONE(INFINITY'ZONE) IF ZF=CURRENT'ZONE;
FZONE1: ZEPTR←ZF.FEXT; FREE(ZF,ZF1);
        GOTO FZONE1 IF (ZF←ZEPTR)>=0;
        RETURN;

        END;

        COMMON USERDECS; INCLUDE COMDECS;
*
* DECLARATIONS FOR USER PROGRAMS
*
        ST OL(NCMCH);* OUTPUT BUFFER FOR USER CONSOLE OUTPUT
        LB TRAP'LABEL;
        INT QUIT'FLAG;* GLOBAL QUIT FLAG
        PTR INITIAL'SP←3200B,NORMAL'SL←3777B,
        STORAGE'AREA←400B /* CHANGE FOR PARTICULAR CASES */;
        INT USER'NO; /*TSS USER NUMBER */
        INT PRIVILEGE; /* SET IF USER HAS ACCESS TO MIB #2 */

* OUTPUT MACROS
        MACRO IOUTS()←SETS(OL,0,0);
        MACRO PTCH(C)←WCI(C,OL);
        MACRO PTST(S)←APPEND(OL,S//LF'PUNT);
        MACRO PTNO(N,F,R)←CNS(N,OL,F,R//LF'PUNT);
        MACRO PTDN(N)←PTNO(N,4B7,10);
        MACRO PTON(N)←PTNO(N,4B7,8);
        MACRO PTNL()←WCI(NLCH,OL);
        MACRO PTIS(S)←SCOPY(OL,S//LF'PUNT);

       END;

        COMMON TRAP'DECS; INCLUDE MACHINE'DECS;
        INCLUDE MACHINE'DECS;

* TRAP VARIABLES
        INT TRAP'FLAG;* FLAG INDICATING WHETHER A TRAP IS BEING PROCESSED
        PTR INSTR'LOC;* PTR TO INSTR FOLLOWING ONE CAUSING ABE TRAP
        INT SAVEL;* SAVE L-REG WHILE DOING EAC IN ABE'TRAP
        INT GSAVER; INTARY GSTATE[LSTATE],SP'GSTATE[LSTATE];* GLOBAL TRAP STATES
        INT SP'LEV;* SUBPROCESS LEVEL ON ENTRY

       END;

        PROGRAM USER'ENTRIES; INCLUDE USERDECS,TRAP'DECS;
*
* ENTRY POINTS
*
        FIXED;
        INT ERMSNO; CHR ERCODE;

        MACRO SAVE'STATE(X)←.STX X[XSTLOC],EAX X[0],STORS,MIN TRAP'FLAG;

* COME HERE AFTER TRAP MESSAGE
T'L:    JUMP'RETURN(
        READ'SPS'PARAM('CSL'//SF'PUNT)-SP'LEV-1//T'R:ERCODE,ERMSNO);
T'R:    SP'RETURN(//SF'PUNT);

* INITIAL AND 'CONTINUE' SUBPROCESS ENTRIES
        ARBENT XXXXXX(), SP'ENTRY ←2;
        ARBENT XXXXXY(), SP'ENTRY ←3;

        .LDA INITIAL'SP,XLA;
        TRAP'LABEL←T'L; TRAP'FLAG←QUIT'FLAG←0;
        STACK'PTR←INITIAL'SP; STACK'LIM←NORMAL'SL;
        STORINIT(STORAGE'AREA,INITIAL'SP-STORAGE'AREA-1//LF'PUNT);
        SP'LEV←READ'SPS'PARAM('CSL'//SF'PUNT);
        SET'SPT'FIELD(-1,'TM',READ'SPT'FIELD(-1,'TCM'//SF'PUNT)
        //SF'PUNT);
        RUN'USER(); RUNTIME'FAILURE();

* SP'TRAPS COME HERE
        ARBENT XXXSPT(), SP'ENTRY ←0; SAVE'STATE(SP'GSTATE); STRAP();


* RING TRAPS
        ARBENT XXXABE(), TRAP'ENTRY ←1; SAVE'STATE(GSTATE); ABE'TRAP();
        ARBENT XXXFLO(), TRAP'ENTRY ←2; SAVE'STATE(GSTATE); RTRAP(2);
        ARBENT XXXFLU(), TRAP'ENTRY ←3; SAVE'STATE(GSTATE); RTRAP(3);
        ARBENT XXXRO(), TRAP'ENTRY ←4; SAVE'STATE(GSTATE); RTRAP(4);
        ARBENT XXXIAT(), TRAP'ENTRY ←5; SAVE'STATE(GSTATE); RTRAP(5);
        ARBENT XXXUFN(), TRAP'ENTRY ←6; SAVE'STATE(GSTATE); RTRAP(6);
        ARBENT XXXFXO(), TRAP'ENTRY ←7; SAVE'STATE(GSTATE); RTRAP(7);
        ARBENT XXXDIZ(), TRAP'ENTRY ←8; SAVE'STATE(GSTATE); RTRAP(8);

* STACK OVERFLOW - WATCH OUT
        ARBENT XXXSOV(), TRAP'ENTRY ←9; STKTRAP();

       END;

        PROGRAM PUNT; INCLUDE USERDECS,TRAP'DECS;
        INCLUDE SPTDECS;
*
* MAIN TRAP/PUNT PROCESSING ROUTINE
*
        DECLARE PUNT'LOC= L' [0];
        INT N,P,Q,SR;
        INT ERMSNO; CHR ERCODE;
        INT LSPCS←5;
        LB R= L' [0];
        INTARY SPCA[LSPCS],STATE[LSTATE];
        PTR SA;* POINTER TO STATE[0]
        MACRO IS'TSB'INSTR(X)←((X) A' 07740000B=04600000B);
        UINFL UTNO(0:0,5),SPCSLR(1:6,23);
        INTARY FN[10];
        LB FIELD LBW0(0);

        MACRO SAVE'STATE(X)←BCOPY(SA←@STATE[0],@X[0],LSTATE) &
        (TRAP'PUNT() IF TRAP'FLAG#1);
        MACRO SPT'PUNT←SPTPUNT:ERCODE,ERMSNO;

*
* ENTRY FOR RING TRAPS
*
        ARBENT RTRAP(N);
        SAVE'STATE(GSTATE);
RTPUNT: RPUNTMSG(N,RTRAP'LOC//HELP); GOTO PUNTCOM;

HELP:   SP'RETURN(//HELP1);
HELP1:  SP'RETURN(//HELP2);
HELP2:  FN[2]←0; MAKE'DORMANT(FN,-1//HELP3:ERCODE,ERMSNO);
HELP3:  GOTO HELP3;

*
* SPECIAL ENTRY FOR 'ABE' TRAP -
* CHECK IF REFERENCE IS FOLLOWED BY TSB OPCODE
*
        ARBENT ABE'TRAP();
        SAVE'STATE(GSTATE);
        INSTR'LOC←RTRAP'LOC+1;
        IF IS'TSB'INSTR($INSTR'LOC) DO;
            .LDX SA[XSTLOC],LDA SA[LSTLOC],XLA,STA SAVEL,EAC$INSTR'LOC;
            .LDA SAVEL,XLA,STX Q;
            R$BRDPC←Q;
            SA[PSTLOC]←@ABE'EXIT;
            R$BRDLR←SA[LSTLOC];
            SA[LSTLOC]←@R;
            TRAP'FLAG←0;
            .LDX SA,LOADS;
ABE'EXIT:   RETURN;
        ENDIF;
        N←1; GOTO RTPUNT;

*
* ENTRY FOR SP TRAPS
*
        ARBENT STRAP();
        SAVE'STATE(SP'GSTATE); ALLOW'INTS(); N←@R.SP'TNO; Q←@R.SP'TPAR;
        READ'SPCS(0,SPCA//SPT'PUNT); R$BRDLR←SPCA[0]$SPCSLR;
        P←SPCA[0]$SPCSPR;
        GOTO SPTPUNT IF N#23;

* QUIT
QUIT:   QUIT'FLAG←1;
        SA[LSTLOC]←@R;
        SA[PSTLOC]←@QUITX; .LDX SA,LOADS;
        SET'SPT'FIELD(-1,'TM',1//SF'PUNT);
QUITX:  SP'RETURN(//SPT'PUNT);


* FREE STORAGE OVERFLOW
        ARBENT OFLOTRAP(ERCODE,ERMSNO);
        R←R$BRDLR.LBW0; N←24; GOTO RTF;

* UNEXPECTED RUNTIME FAILURE
        ARBENT RUNTIME'FAILURE(); N←25;
RTF:    P←R$BRDPC; Q←0;

SPTPUNT:SPUNTMSG(N,P,Q//HELP);
PUNTCOM:TRAP'FLAG←0;
        GOTO TRAP'LABEL;

* TRAP DURING STATE-SAVING
        ARBENT TRAP'PUNT();
        SPUNTMSG(26,R$BRDPC,0); GOTO PUNTCOM;

* TO ACCOMMODATE CODE APPROPRIATED FROM KDF
       ARBENT PUNT();
       CRLF(1); SOUT("PUNT AT LOCATION "); IOUT(PUNT'LOC,8);
       TCO('B'); .HLT 0;

       FUNCTION P'(A);
       SOUT("PUNT "); SOUT("INFINITY") IF A=4B7-1 ELSE IOUT(A,10);
       CRLF(1); SOUT("LOCATION = "); IOUT(PUNT'LOC,8); TCO('B');
       .HLT 0;

       END;

        PROGRAM STKOV'TRAP; INCLUDE USERDECS;
*
* STACK OVERFLOW TRAP PROCESSING
*
        FIXED;

        ARBENT STKTRAP();
STKWAIT:GOTO TRAP'LABEL;


       END;

        PROGRAM UTRAP'MSG; INCLUDE USERDECS,MACHINE'DECS;
*
* PRINT USER TRAP MESSAGE
*?*  THIS ROUTINE SHOULD FRETURN, RATHER THAN PUNTING (COULD CAUSE
*?*       PUNT LOOP AND STACK OVERFLOW)
*
        INT ERMSNO; CHR ERCODE;
        ST MSG(60),CM; INT N,P,Q,T;
        CHRARY RN[10]←(6'RT0?',6'ABE',6'FLO',6'FLU',6'ROIA',
        6'IAT',6'UFN',6'FXO',6'DIZ',6'SOV');
        CHRARY SN[27]←(6'MACC',6'PRO',6'PNIM',6'PNIC',6'PI',
        6'TI',6'BLL',6'ILIM',6'PNOD',6'DWSO',6'CWSO',
        6'NEP',6'DMRD',6'NILE',6'SPCO',6'PMTO',6'DKSE',
        6'?17?',6'?18?',6'?19?',6'?20?',6'?21?',6'UTSE',
        6'QUIT',6'FSOV',6'PUNT',6'TRAP');

        ARBENT RPUNTMSG(N,P), FRETURN; N←-(N+1);
        ARBENT SPUNTMSG(N,P,Q), FRETURN;


        SETS(MSG,0,0); WCI(NLCH,MSG);
        APPEND(MSG,"USER TRAP '"// FRETURN);

COM:
        IF N=22 DO;* 'UTSE' ERROR
        APPEND(MSG,"UTSE - "// FRETURN);
            N←(Q$UTSE'SPTNO IF T←Q$UTSE'CLASS>1 ELSE
            6 IF T=1 ELSE -(Q$UTSE'RTNO+1));
        ENDIF;

        IF N=6 DO;* BLL ERROR
        PUNT'WWD(MSG,6'BLL-'); WCI(Q$BLL'CLASS V' '0',MSG);
        ELSE DO;
            PUNT'WWD(MSG,SN[N] IF N>=0 ELSE RN[-(N+1)]);
        ENDIF;
        APPEND(MSG,"' AT P: "// FRETURN);
        CNS(P,MSG,4B7,8// FRETURN); WCI('B',MSG);

        WCI(NLCH,MSG);
QT'P:   PRINT'STRING(-1,MSG,0// FRETURN);
        RETURN;

       END;

        PROGRAM PUNT'WWD; INCLUDE COMDECS;
*
* APPEND 4 CHARACTER NAME TO STRING
*
        INT ERMSNO; CHR ERCODE;
        PTR P; CHR M,C; ST S; STFL A(0); CHRFL CH60(0:0,5);

        ARBENT PUNT'WWD(STRING @P,M); S←P.A;

        (WCI(C,S) IF C#' ') & M←M LSH 6
        FOR C←M$CH60 WHILE M#6'    ';
        P.WP←S$WP; RETURN;

       END;

        PROGRAM VARIOUS; INCLUDE USERDECS;

*
* CLEAR CIOS NPUT/OUTPUT &
* TYPE NEWLINE
*

        INT ERMSNO; CHR ERCODE;
        ARBENT CLEAR'CIOS();
LP:     QUIT'FLAG←0;
        SET'CIOS'FIELD(-1,'OCC',0//SF'PUNT);
        SET'CIOS'FIELD(-1,'ICC',0//SF'PUNT);
        IOUTS();
        PRINT'CHAR(-1,NLCH,QUIT'FLAG//QUIT'PUNT(LP));
        RETURN;

*
* REMOVE QUIT CALL FROM SPCS AND UNWIND STACK
* BY NON-LOCAL GOTO
*

        ARBENT ZAP(LABEL ZLAB);
        DELETE'CALL(//SF'PUNT);
        GOTO ZLAB;

       END;

        COMMON ACCTAB; INCLUDE DECDECS;* ACCESS TABLE CODES

        INT LACVL←5;* ACCESS-CODE TABLES
        INTARY ACCWD[LACVL]←('NO','PX','RO','RW','OW');
        INTARY ACCVL[LACVL]←(0,2,12B,16B,17B);


       END;

        COMMON FCOMTAB; INCLUDE DECDECS;
*
* COMMAND TABLES
*
        INT LENTPT←7,LMAIN←31;

* ENTRY POINT TABLE
        STARY STBEP[LENTPT]←(6"EXAMINE-FILE",6"LIST-FILES",6"LIST-OBJECTS",
        6"DELETE-FILES",6"DELETE-OBJECTS",6"RENAME-FILES",6"FILE-MAINTENANCE");

* MAIN TABLE
        STARY STMAIN[LMAIN]←(6"USER",6"FINISHED",6"RENAME-FILES",
        6"COPY-KEY",6"CREATE-LINK",6"CREATE-FRIEND",
        6"CREATE-OWNER",6"CREATE-KEY",6"CREATE-SMALL-FILE",
        6"CREATE-LARGE-FILE",6"DELETE-FRIEND",6"DELETE-OWNER",
        6"DELETE-KEY",6"DELETE-OBJECT",6"DELETE-FILES",6"LIST-ALL",
        6"LIST-FRIENDS",6"LIST-OWNERS",6"LIST-LINKS",6"LIST-OBJECTS",
        6"LIST-PROCESSES",6"LIST-KEYS",6"LIST-FILES",
        6"EXAMINE-FILE",6"SET-TYPE",6"SET-PUBLIC-ACCESS",
        6"SET-FRIEND-ACCESS",6"SET-OWNER-ACCESS",
        6"SET-KEY-ACCESS",6"HELP",6"COMMANDS-FROM");

* 'LIST FILE' TABLE
        STARY LFOPN[5]←(6"ENTRY",6"BRIEF",6"ACCESS",6"LENGTH",
        6"TIME");
        STARY LFORD[3]←(6"ALPHABETIC",6"TIME",6"ENTRY");

       END;

        PROGRAM FMAIN; INCLUDE USERDECS,FCOMTAB,SIBDECS,ACCTAB;
        INCLUDE GLOBAL;
*
* COMMANDS FOR FILE MAINTENANCE
*

        MACRO SF'ERROR←ERXIT:ERCODE,ERMSNO;* UCALL/MCALL ERROR MACRO
        INT ENTNO,FILE'INPUT,IUNO;
        LBARY ENTTAB;
        STARY STRTAB;
        INT LIFCH,SETAC,SETCD,SETFN,COMFLG,FILE'PTR,PAGENO;
        INT VAL'PTR,ERCODE,ERMSNO,I,LIST'OBJ;
        INT RENTY,REN'PTR1,REN'PTR2,FILENO,OPTCD,KEY;
        INT FILE'NUMBER,FB,PAGE;
        INTARY FILE'ARY[LUFN],VAL'ARY[MLSIB],REN'ARY1[LUFN],
        REN'ARY2[LUFN],INDEX[2];
        ST NAME'ST1,COMLINE(NCMCH),NAME'ST2,RENMN,UNO(5),SAVE(50),
            INP'LINE(72),SF,ACCESS,CSLIST(10),TEMPS(5);
        LN UNDK,UNDK',UN'DK;
        UINFL SETFL,FRNDAC(0:1,4),FRNDUN(0:8,23),OBJ'TYPE(0:1,4);

        ARBUC SET'PP'ITEM←73;
        STUC READ'PP'ITEM←71;


* ENTRY POINTS
        LBARY ETBEP[LENTPT]←(EX'FILE,LI'FILE,LI'OBJ,DL'FILE,DL'OBJ,RENAME'C,COM'EP);

* MAIN TABLE
        LBARY LBMAIN[LMAIN]←(USER'C,FINISH'C,RENAME'C,NOT'IMP,
        CR'LINK,CR'FRND,CR'OWNR,NOT'IMP,CR'SFILE,CR'LFILE,
        DL'FRND,DL'OWNR,NOT'IMP,DL'OBJ,DL'FILE,LI'ALL,LI'FRND,
        LI'OWNR,NOT'IMP,LI'OBJ,NOT'IMP,NOT'IMP,LI'FILE,EX'FILE,
        SE'TYPE,SE'PUAC,SE'FRAC,SE'OWAC,NOT'IMP,HELP,COM'FROM'C);


        ENTRY RUN'USER();

        QUIT'FLAG←COMFLG←FILE'INPUT←0;
        KEY←READ'SPT'FIELD(-1,'UAK'//SF'PUNT);
        FILE'PTR←@FILE'ARY[0]; VAL'PTR←@VAL'ARY[0];
        REN'PTR1←@REN'ARY1[0]; REN'PTR2←@REN'ARY2[0];
        GET'COM'LINE(COMLINE:COMLINE//SF'PUNT);
        NAME'ST1←GET'PARAM(COMLINE);
        STRTAB←STBEP;

        /* DETERMINE IF USER HAS SYSTEM PRIVILEGES BY LOOKING AT COMMAND */
        /* SEARCH LIST MAKING SURE IT IS '2' AND NOT '3' OR '4'.          */
        USER'NO ← READ'PROC'PARAM('UNO'//SF'PUNT);
        READ'UP'ITEM('UP',-1,USER'NO,TEMPS,"CSL",CSLIST,0:CSLIST//DETRMIN
                     :ERCODE,ERMSNO);
        ACCESS ← GET'PARAM(CSLIST);
        ACCESS ← GET'PARAM(CSLIST);
DETRMIN:PRIVILEGE←1 IF (COMPARE'STRING(ACCESS,"2") OR USER'NO=1)
                     ELSE PRIVILEGE←0;

        GOTO ETBEP[ENTNO←ABRV'LKP(NAME'ST1,STBEP//COM'EP: ERCODE,ERMSNO)];

COM'EP: COMFLG←-1;

*
* COMMAND LOOP
*
        STRTAB←STMAIN;
COM'LP: READ'LINE(-1,COMLINE,">",QUIT'FLAG:COMLINE//
          QUIT'PUNTX(QT'XIT,COMLINE));
RUN'USER'1:GOTO COM'LP IF EMPTY(COMLINE);
        GOTO LBMAIN[ENTNO←ABRV'LKP(NAME'ST1←
            GET'PARAM(COMLINE),STMAIN//PARERR:ERCODE,ERMSNO)];

ERXIT2: SET'PP'ITEM("FSL",SAVE//SF'PUNT);
ERXIT:  IOUTS(); OL←ERRORMSG(ERMSNO,OL//SF'PUNT); GOTO LN'OUT;
PARERR: IOUTS(); PTCH(SQTCH); PTST(NAME'ST1); PTCH(SQTCH);
        PTST(" IS UNRECOGNIZABLE"); GOTO LN'OUT;

NOT'IMP:IOUTS(); PTCH(SQTCH); PTST(STRTAB[ENTNO]); PTCH(SQTCH);
        PTST(" NOT AVAILABLE YET");

LN'OUT: PTNL(); PRINT'STRING(-1,OL,0//QUIT'PUNTX(QT'XIT,OL));
EXIT:   QUIT'FLAG←0;
        GOTO COM'FROM'1 IF FILE'INPUT<0;
        GOTO COM'LP IF COMFLG<0;
FINISH'C:SP'RETURN(//SF'PUNT);* FINISHED

QT'XIT: CLEAR'CIOS();
        GOTO EXIT;

*
* CREATE FILE
*

CR'LFILE:SETCD←SIBLFCD; GOTO CR'FILE;
CR'SFILE:SETCD←SIBSFCD;

CR'FILE:NAME'ST1←GET'PARAM(COMLINE);
        NAME'SEARCH(NAME'ST1,FILE'ARY,1,6'    ',KEY//SF'ERROR);
        GOTO CREF3 IF FILE'PTR.UFNEN>=0;
        GOTO CREF4 IF FILE'PTR.UFNTY=0 OR FILE'PTR.UFNMN=0;
        CREATE'MIBOB(FILE'ARY,SETCD,KEY//SF'ERROR);
        SET'MIBOB'ACCESS(FILE'ARY,NORM'FIL'AC,KEY//
        SF'PUNT); GOTO EXIT;

CREF3:  PTIS("MUST HAVE NEW NAME"); GOTO LN'OUT;
CREF4:  PTIS("MUST SPECIFY NAME AND TYPE"); GOTO LN'OUT;

* DELETE OBJECTS
DL'OBJ: IF NOT PRIVILEGE DO;
            PTIS("SYSTEM PRIVILEGES REQUIRED!");
            GOTO LN'OUT;
        ENDIF;
        NAME'ST1←GET'PARAM(COMLINE);
        SCOPY(SAVE,NAME'ST1//LF'PUNT);
        REPEAT;
           IF GCD(SAVE//REGULAR) = ':' DO;
              /* TEST TO SEE IF NAME'ST1 IS A *:*:XXXX */
              GOTO REGULAR IF NOT COMPARE'STRING(SAVE,"*:*");
              GCI(NAME'ST1); GCI(NAME'ST1);
              SETS(SAVE);
              SAVE ← READ'PP'ITEM("FSL",SAVE//SF'PUNT);
              /* DELETE ALL FILES ON THE DRUM WITH FILE TYPE XXXX */
              FOR I ← 5 TO 128 DO;
                  SETS(UNO);
                  CNS(I,UNO,0,10//LF'PUNT);
                  SET'PP'ITEM("FSL",UNO//SF'PUNT);
                  SPECIAL'SEARCH(NAME'ST1,FILE'ARY,'PAR',KEY//CONTINUE:ERCODE,ERMSNO);
                  FILE'PTR.UFNEN←FILE'PTR.UFNEN-1;
                  REPEAT;
                     SPECIAL'SEARCH(NAME'ST1,FILE'ARY,'NXT',KEY//
                         (GOTO CONTINUE IF ERCODE='END' ELSE GOTO ERXIT):ERCODE,ERMSNO);
                     DELETE'FILE(FILE'ARY,KEY//SF'PUNT);
                  ENDRPT;
CONTINUE:     ENDFOR;
              SET'PP'ITEM("FSL",SAVE//SF'PUNT);
              GOTO EXIT;
           ENDIF;
        ENDRPT;


REGULAR:SPECIAL'SEARCH(NAME'ST1,FILE'ARY,'PAR',KEY//SF'ERROR);
        FILE'PTR.UFNEN←FILE'PTR.UFNEN-1;
        REPEAT;
            SPECIAL'SEARCH(NAME'ST1,FILE'ARY,'NXT',KEY//
              (GOTO EXIT IF ERCODE='END' ELSE GOTO ERXIT): ERCODE,ERMSNO);
            DELETE'FILE(FILE'ARY,KEY//SF'ERROR);
        ENDRPT;

DL'FILE:NAME'ST1←GET'PARAM(COMLINE);
        SETS(UNO,0,0); SETS(SAVE,0,0);
        IF LENGTH(NAME'ST1)=0 DO;
            NAME'ST1←READ'LINE(-1,INP'LINE,"FILE NAME: ",QUIT'FLAG//
                               QUIT'PUNTX(EXIT,NAME'ST1));
        ENDIF;
        SAVE←READ'PP'ITEM("FSL",SAVE//SF'PUNT);
        CNS(IUNO←READ'PROC'PARAM('UNO'//SF'PUNT),UNO,0,10//EXIT);
        SET'PP'ITEM("FSL",UNO//SF'PUNT) IF IUNO#1;
        IF NOT COMPARE'STRING(NAME'ST1,"*:*") DO;
            SPECIAL'SEARCH(NAME'ST1,FILE'ARY,'PAR',KEY//ERXIT2:ERCODE,ERMSNO);
        ENDIF;
        FILE'PTR.UFNEN←FILE'PTR.UFNEN-1;
        REPEAT;
            SPECIAL'SEARCH(NAME'ST1,FILE'ARY,'NXT',KEY//
              (GOTO RESET IF ERCODE='END' ELSE GOTO ERXIT2):ERCODE,ERMSNO);
            READ'MIBOB'NAME(FILE'ARY,0,INDEX,0,KEY//SF'PUNT);
            GOTO END'LOOP IF (I←INDEX[0]$OBJ'TYPE#SIBSFCD AND I#SIBLFCD AND I#SIBLKCD)
                             OR (FILE'ARY[0]#USER'NO AND NOT PRIVILEGE);
            DELETE'FILE(FILE'ARY,KEY//SF'PUNT);
END'LOOP:ENDRPT;

RESET:  SET'PP'ITEM("FSL",SAVE//SF'PUNT);
        GOTO EXIT;

*
* CREATE LINK
*
CR'LINK:IF NOT PRIVILEGE DO;
           PTIS("SYSTEM PRIVILEGES REQUIRED!");
           GOTO LN'OUT;
        ENDIF;
        NAME'ST1←GET'PARAM(COMLINE);
        NAME'SEARCH(NAME'ST1,FILE'ARY,1,6'    ',KEY//SF'ERROR);
        GOTO CREF3 IF FILE'PTR.UFNEN>=0;
        GOTO CREF4 IF FILE'PTR.UFNTY=0 OR FILE'PTR.UFNMN=0;
        NAME'ST2←GET'PARAM(COMLINE);
        SPREAD'NAME(NAME'ST2,6'    ',KEY:
        UNDK,NAME'ST2,RENTY,ERMSNO//SF'ERROR);
        GOTO CREF4 IF EMPTY(NAME'ST2) OR RENTY=6'    ';
        VAL'PTR.UFNUN←UNDK; VAL'PTR.UFNEN←0;
        SETUP(NAME'ST1,NMNCH,@(VAL'PTR.UFNMN),LNCH);
        SCOPY(NAME'ST1,NAME'ST2//LF'PUNT);
        REPEAT; WCI(' ',NAME'ST1//CREL1); ENDRPT;
CREL1:  VAL'PTR.UFNTY←RENTY;
        READ'MIBOB'NAME(VAL'ARY,0,REN'ARY1,0,KEY//CREL2:
        ERCODE,ERMSNO);
        VAL'PTR.UFNEN←REN'PTR1.UFNEN;
CREL2:  CREATE'MIBOB(FILE'ARY,SIBLKCD,KEY//SF'ERROR);
        SET'MIBOB'ACCESS(FILE'ARY,NORM'FIL'AC,KEY//SF'ERROR);
        SET'MIBOB'VALUE(FILE'ARY,LUFN,VAL'ARY,KEY//SF'PUNT);
        GOTO EXIT;

*
* RENAME AND SET TYPE
*

SE'TYPE:GOTO NOT'IMP;* SET TYPE


RENAME'C:NAME'ST1←GET'PARAM(COMLINE);
        IF LENGTH(NAME'ST1) = 0 DO;
               READ'LINE(-1,COMLINE,"PRESENT FILE NAME: ",QUIT'FLAG:COMLINE
                         //QUIT'PUNTX(QT'XIT,COMLINE));
               GOTO RENAME'C;
        ENDIF;
        SPECIAL'SEARCH(NAME'ST1,FILE'ARY,'PAR',KEY//SF'ERROR);
        IF (FILE'ARY[0]#USER'NO AND NOT PRIVILEGE) DO;
            PTIS("SYSTEM PRIVILEGES REQUIRED!");
            GOTO LN'OUT;
        ENDIF;
        FILE'PTR.UFNEN←FILE'PTR.UFNEN-1;
REN1:   NAME'ST2←GET'PARAM(COMLINE);
        IF LENGTH(NAME'ST2) = 0 DO;
               READ'LINE(-1,INP'LINE,"NEW FILE NAME: ",QUIT'FLAG:INP'LINE
                         //QUIT'PUNTX(QT'XIT,INP'LINE));
               SETUP(NAME'ST2,NMNCH,@(REN'PTR1.UFNFN),LNCH);
               SCOPY(NAME'ST2,INP'LINE//LF'PUNT);
        ENDIF;
        SPREAD'NAME(NAME'ST2,6'    ',KEY:
        UNDK,RENMN,RENTY,ERMSNO//SF'ERROR);
        SETUP(NAME'ST2,NMNCH,@(REN'PTR1.UFNFN),LNCH);
        SCOPY(NAME'ST2,RENMN//LF'PUNT);
        REPEAT; WCI(' ',NAME'ST2// GOTO REN2); ENDRPT;

REN2:   GOTO REN3 IF (FILE'PTR.UFNFN=0)#(REN'PTR1.UFNFN=0);
        GOTO REN3 IF (FILE'PTR.UFNTY=0)#(RENTY=0);

        REPEAT; SPECIAL'SEARCH(NAME'ST1,FILE'ARY,'NXT',KEY//
        VALUE (GOTO EXIT IF ERCODE='END' ELSE GOTO ERXIT):
        ERCODE,ERMSNO);
            READ'MIBOB'NAME(FILE'ARY,LSIBN-2,VAL'ARY,0,KEY//SF'PUNT);
            BCOPY(@(REN'PTR2.UFNFN),@(VAL'PTR.SIBNMN),LMN)
            IF REN'PTR1.UFNFN=0 ELSE
            BCOPY(@(REN'PTR2.UFNFN),@(REN'PTR1.UFNFN),LMN);
            REN'PTR2.UFNTY←
            (VAL'PTR.SIBNTY IF RENTY=0 ELSE RENTY);
            SET'MIBOB'NAME(FILE'ARY,REN'ARY2,KEY//SF'ERROR);
        ENDRPT;

REN3:   PTIS("STRUCTURE OF NAMES MUST AGREE"); GOTO LN'OUT;

*
* SET FILE SEARCH LIST
*
USER'C: IF PRIVILEGE DO;
           NAME'ST1←GET'PARAM(COMLINE);
           IF LIFCH←GCI(NAME'ST1//PARERR)='#' DO;
           ELSEIF LIFCH='@' DO;
               NAME'ST2←ST'DESC(2,@ENTNO,8,1);
               READ'UP'ITEM('UP',-1,0,NAME'ST1,"#",NAME'ST2,KEY:
               NAME'ST2//SF'ERROR);
               NAME'ST1$WP←NAME'ST1$RP;
               NAME'ST1$EP←COMLINE$EP;
               CNS(ENTNO,NAME'ST1,4B7,10//LF'PUNT);
           ELSE DO; NAME'ST1$RP←NAME'ST1$BP; GOTO PARERR;
           ENDIF;

           SET'PP'ITEM("FSL",NAME'ST1//SF'ERROR);
        ELSE DO;
           PTIS("SYSTEM PRIVILEGES REQUIRED!"); GOTO LN'OUT;
        ENDIF;
        GOTO EXIT;

*
* CREATE/DELETE FRIEND
*
CR'FRND:DL'FRND:CR'OWNR:DL'OWNR:
        GOTO NOT'IMP;* TEMPORARY

*
* LISTING
*
LI'ALL: LISTFILE("*",0,0,0,KEY//QT'XIT);
        LISTFRND(3//QT'XIT); GOTO EXIT;

LI'FRND:LISTFRND(2//QT'XIT); GOTO EXIT;
LI'OWNR:LISTFRND(1//QT'XIT); GOTO EXIT;

LI'OBJ: LIST'OBJ ← 1; GOTO LI'STRT; /* LISTS THE PROCS,KEYS,ETC. */
LI'FILE:LIST'OBJ ← 0;               /* LISTS ONLY THE FILES      */
LI'STRT:NAME'ST2←GET'PARAM(COMLINE);
        NAME'ST1←GET'PARAM(COMLINE);
        OPTCD←(1 IF EMPTY(NAME'ST1) ELSE
        ABRV'LKP(NAME'ST1,LFOPN//PARERR:ERCODE,ERMSNO));
        NAME'ST1←GET'PARAM(COMLINE);
        LISTFILE(NAME'ST2,OPTCD,0 IF EMPTY(NAME'ST1) ELSE
        ABRV'LKP(NAME'ST1,LFORD//PARERR:ERCODE,ERMSNO),LIST'OBJ,KEY//
        QT'XIT); GOTO EXIT;

EX'FILE:NAME'ST1←GET'PARAM(COMLINE);
        IF LENGTH(NAME'ST1)=0 DO;
            NAME'ST1 ← READ'LINE(-1,INP'LINE,"FILE NAME: ",QUIT'FLAG//
                                 QUIT'PUNTX(EXIT,NAME'ST1));
        ENDIF;
        NAME'SEARCH(NAME'ST1,FILE'ARY,0,6'    ',KEY//SF'ERROR);
        IF (FILE'ARY[0]#USER'NO AND NOT PRIVILEGE) DO;
            PTIS("SYSTEM  PRIVILEGES REQUIRED!");
            GOTO LN'OUT;
        ENDIF;
        NAME'ST1←GET'PARAM(COMLINE);
        OPTCD←(0 IF EMPTY(NAME'ST1) ELSE
        ABRV'LKP(NAME'ST1,LFOPN//PARERR:ERCODE,ERMSNO));
        EXFILE(FILE'ARY,OPTCD,0,KEY//QT'XIT); GOTO EXIT;

*
* ACCESS CODE SETTING
*
SE'PUAC:SETFL←SIBNPA; GOTO SET1;
SE'FRAC:SETFL←SIBNFA; GOTO SET1;
SE'OWAC:SETFL←SIBNOA;

* COMMON PROCESSING
SET1:   NAME'ST1←GET'PARAM(COMLINE);
        SPECIAL'SEARCH(NAME'ST1,FILE'ARY,'PAR',KEY//SF'ERROR);
        FILE'PTR.UFNEN←FILE'PTR.UFNEN-1;
        SETCD←GETACD(COMLINE//EXIT);

        REPEAT; SPECIAL'SEARCH(NAME'ST1,FILE'ARY,'NXT',KEY// VALUE
        (GOTO EXIT IF ERCODE='END' ELSE GOTO ERXIT):
        ERCODE,ERMSNO);
            READ'MIBOB'NAME(FILE'ARY,LSIBN-2,VAL'ARY,0,KEY//SF'ERROR);
            VAL'PTR.SETFL←SETCD;
            SET'MIBOB'ACCESS(FILE'ARY,VAL'PTR.SIBNAC,KEY//SF'ERROR);
        ENDRPT;

* HELP
HELP:   FOR I←0 TO LMAIN-1 DO;
            IOUTS(); PTST(STMAIN[I]); PTNL();
            PRINT'STRING(-1,OL,0//QUIT'PUNTX(EXIT,OL));
        ENDFOR;
        GOTO EXIT;

* COMMANDS-FROM FILE:
COM'FROM'C:NAME'ST1←GET'PARAM(COMLINE);
        IF LENGTH(NAME'ST1)=0 DO;
            READ'LINE(-1,COMLINE,"FILE NAME: ",QUIT'FLAG:COMLINE//
                      QUIT'PUNTX(EXIT,COMLINE));
            GOTO COM'FROM'C;
        ENDIF;
        NAME'SEARCH(NAME'ST1,FILE'ARY,0,6'9SYM',-1//SF'ERROR);
        OPEN'FILE(-1,FILE'ARY,'RO',-1:FILE'NUMBER//SF'ERROR);
        INIT'IN'FILE(SF,FILE'NUMBER:FB,PAGE);
        FILE'INPUT←-1;
COM'FROM'1:READ'LINE'FILE(FILE'NUMBER,FB,PAGE,COMLINE,SF:FB,PAGE//COM'FROM'2);
        GOTO RUN'USER'1;

COM'FROM'2:REL'PAGE(FB//COM'FROM'3);
COM'FROM'3:CLOSE'FILE(FILE'NUMBER//EXIT);
        FILE'INPUT←0;
        GOTO EXIT;

       END;


        PROGRAM FILE'INIT;
        INCLUDE GLOBAL;
        DECLARE PAGE,I;
        DECLARE STRING ST;
        DECLARE STRING FIELD STF(0);



         FUNCTION INIT'IN'FILE(STRING @S,INTEGER FILE);
        NEXT'FILE'PAGE(FILE,-1:PAGE//PUNT():C,D);
        I←GET'PAGE(FILE,PAGE//PUNT());
        SETUP(ST,2048*3,I); SETW(ST,2048*3);
        S.STF←ST; RETURN (I,PAGE);





         END;

        PROGRAM READ'LINE'FILE;
        INCLUDE GLOBAL;
        DECLARE STRING SF,SB, STRING FIELD STF(0);
        DECLARE CHR,SWITCH;



         FUNCTION READ'LINE'FILE(FILE,FB,PAGE,STRING @FS,@BS), FRETURN;
        SF←FS.STF; SB←BS.STF; SETS(SF,0,0);
CAL0:   CHR←GCI(SB//CAL10);
        IF CHR=155B DO;
CAL1:       CHR←GCI(SB//CAL11);
CALE:       BS.STF←SB; FS.STF←SF;
            RETURN (FB,PAGE);
        ELSEIF CHR=137B DO;
            SETS(SB);
            FRETURN IF LENGTH(SF)=0 ELSE GOTO CALE;
        ELSE DO; WCI(CHR,SF);
        ENDIF; GOTO CAL0;
CAL10:  SWITCH←0; GOTO CAL12;
CAL11:  SWITCH←1;
CAL12:  REL'PAGE(FB//PUNT());
        NEXT'FILE'PAGE(FILE,PAGE:PAGE//PUNT():C,D);
        FRETURN IF PAGE=-1;
        FB←GET'PAGE(FILE,PAGE//PUNT());
        SETUP(SB,2048*3,FB); SETW(SB,2048*3);
        GOTO CAL0 IF SWITCH=0 ELSE GOTO CAL1;


         END;

        PROGRAM REL'PAGE;
*REL'PAGE
*RELEASE PAGE FROM ALLOCATION SPACE
*A1:  STARTING ADDRESS OF PAGE
*RETURN
*FRETURN IF NO SUCH PAGE

         INCLUDE PAGE'ALLOC;
        DECLARE I;



         FUNCTION REL'PAGE(SPAGE), FRETURN;
        I←SPAGE/2048;
        FRETURN IF I<MAP0 OR I>MAPN OR MAPA[I-MAP0]=0;
        I←I-MAP0;
        CLEAR'PMT(PMT[I]//P'(9):C,D);
        MAPA[I]←0;
        RETURN;


         END;

        PROGRAM CIO;
        INCLUDE SYSCALLS;
        MONITOR BLOCK ← 170;
        DECLARE FIELD NCHF(0:0,1);
        DECLARE C,D;
        DECLARE STRING STR(2);
        DECLARE MEC, MEM, NCH;



         ENTRY TCO(CHAR);
        SETS(STR, 0, 0);
        IF CHAR<=77B DO; CHAR←CHAR+240B;
        ELSE DO; CHAR←CHAR-140B;
        ENDIF;
        WCI(37B,STR//CIO80) & WCI(CHAR+40B,STR//CIO80) IF
         CHAR<40B ELSE WCI(CHAR,STR//CIO80);
CIO10:  WRITE'STRING(-1,-1,STR:STR,NCH//CIO80:MEC,MEM);
        GOTO CIO10 IF NCH>0;
        RETURN;



         ENTRY TCI();
        SETS(STR, 0, 0);
CIO20:  READ'STRING'BRK(-2,1,0,STR:STR,NCH//CIO80:MEC,MEM);
        BLOCK(4B7 RSH 7//PUNT():C,D) IF NCH$NCHF=1;
        CHAR ← GCI(STR//CIO20);
        IF CHAR=37B DO;
            CHAR ← GCI(STR//CIO80) A' 37B;
        ELSEIF CHAR<40B DO;
            GOTO CIO80;
        ENDIF;
        CHAR←CHAR A' 177B;
        CHAR←(CHAR-40B IF CHAR>=40B ELSE CHAR+340B);
        RETURN CHAR;
CIO80:  PUNT();



         END;

        PROGRAM GET'PAGE;
*GET'PAGE
*PUT SPECIFIED PAGE OF A FILE INTO A FREE MAP BYTE
*AND RETURN THE ADDRESS OF THE ACQUIRED PAGE
*A1:  FILE NUMBER
*A2:  PAGE OF FILE
*RETURN R1
*R1:  STARTING ADDRESS OF ACQUIRED PAGE
*FRETURN IF NO AVAILABLE PAGE OR PAGE DID NOT EXIST IN FILE

         INCLUDE PAGE'ALLOC;
        DECLARE I;
        DECLARE NO'PAGE←5;



         FUNCTION GET'PAGE(FILE,PAGE), FRETURN;
        FOR I←0 TO MAPLEN-1 DO;
            GOTO CAL0 IF MAPA[I]=0;

         ENDFOR; FRETURN;
CAL0:    IF PMT[I]=0 DO;
            PMT[I]←ACQUIRE'PMT(-1//P'(7):C,D);
        ENDIF;
        MOVE'PAGE'PMT(FILE,PAGE,PMT[I]//CAL2:C,D);
        SET'MAP'BYTE(SPTX,MAP0+I,PMT[I]//CAL1:C,D);
        MAPA[I]←-1; MAPX←(I+MAP0 IF I+MAP0>MAPX ELSE MAPX);
        RETURN 2048*(MAP0+I);
CAL1:   CLEAR'PMT(PMT[I]//P'(9):C,D); P'(8);
CAL2:    FRETURN IF D=NO'PAGE ELSE P'(5);


         END;

        PROGRAM IOUT;
        DECLARE STRING ST(15);
        DECLARE A1,A2,I,FLAG;
        DECLARE STRING FIELD STFLD(0);
        DECLARE STRING ISTR;



         FUNCTION IOUT(A,RADIX); FLAG←0; GOTO XX;



         ENTRY IOUT'S(A,RADIX,STRING @STR); FLAG←-1;
        ISTR←STR.STFLD;
XX:     SETS(ST,0,0); I←0;
        IF A<0 AND RADIX=8 DO;
            IF FLAG DO;
                WCI(((A RSH ((8-I)*3)) A' 7)+20B,ISTR) FOR I←1 TO 8;
                GOTO X3;
            ELSE DO;
                TCO(((A RSH ((8-I)*3)) A' 7)+20B) FOR I←1 TO 8;
            ENDIF;
            RETURN;
        ELSEIF A<0 DO; A←-A; I←-1;
        ENDIF;
X0:     A1←A/RADIX; A2←A-RADIX*A1; A←A1;
        WCI(A2+20B,ST//X1A);
        IF A=0 DO; WCI('-',ST//X1A) IF I<0; GOTO X1A;
        ELSE DO; GOTO X0;
        ENDIF;
X1:     TCO(GCD(ST// RETURN)); GOTO X1;
X1A:    GOTO X1 IF FLAG=0;
X2:     WCI(GCD(ST//X3),ISTR); GOTO X2;
X3:     STR.STFLD←ISTR; RETURN;



         END;

        PROGRAM SOUT;
        DECLARE CHR;



         FUNCTION SOUT(STRING ST);
X1:     CHR←GCI(ST// RETURN);
        IF CHR>77B DO;
            TCO(CHR) IF CHR='&M' OR CHR='&J'; GOTO X1;
            TCO('&&');
        ENDIF; TCO(CHR A' 77B);
        GOTO X1;



         END;

        PROGRAM CRLF;
        DECLARE K;



         FUNCTION CRLF(I);
        (TCO('&M') & TCO('&J')) FOR K←1 TO I;
        RETURN;



         END;

        COMMON LIST'BEAD; INCLUDE USERDECS;
        UINFL NAMNX(0),NAMTM(0),
        NAMNM(1),
        NAMFN(4);
        INT LNAME←LUFN+1;
        PTR NAME'ZONE;

       END;

        PROGRAM LIST'ZONE; INCLUDE ALLOC'DECS,USERDECS,LIST'BEAD;
* STORAGE EXTENSION FUNCTIONS
        PTR S,Z,E; CHR ERCODE; INT ERMSNO; INTFN LE'KLUDGE;

        INTENT LIST'EXT(S,Z);
        EXTZONE(MAKE(5*LNAME,INFINITY'ZONE),NAME'ZONE//LF'PUNT);
        RETURN MAKE(S,Z);

        ENTRY LIST'INIT();
        NAME'ZONE←SETZONE(MAKE(30*LNAME,INFINITY'ZONE)//LF'PUNT);
        LE'KLUDGE←LIST'EXT; NAME'ZONE.FOVX←LE'KLUDGE; RETURN;

       END;

        PROGRAM LISTFILE; INCLUDE ALLOC'DECS,USERDECS,SIBDECS,LIST'BEAD;

        FNARY SORT'FCN[2]←(NAME'GRTR,TIME'GRTR);
        INT OPTION,ORDER,KEY,NAME'CNT,I,LIST'OBJ;
        INT NAME'PTR,LAST'NAME,ERCODE,ERMSNO;
        INTARY NAME'LIST,FILE'ARY[LUFN],VAL'ARY[MLSIB],INDEX[2];
        PTR FILE'PTR,VAL'PTR; ST FILE'NAME; UINFL OBJ'TYPE(0:1,4);

        ENTRY LISTFRND(OPTION), FRETURN; RETURN;
        ENTRY LISTFILE(FILE'NAME,OPTION,ORDER,LIST'OBJ,KEY), FRETURN;

        FILE'PTR←@FILE'ARY[0]; VAL'PTR←@VAL'ARY[0];
        FILE'PTR.UFNEN←-1; NAME'CNT←LAST'NAME←0;
        LIST'INIT();

        REPEAT;
START:      SPECIAL'SEARCH(FILE'NAME,FILE'ARY,'NXT',KEY
                           //END'RD: ERCODE,ERMSNO);
            IF OPTION # 0 DO; /* IT'S A BRIEF LIST: SKIP KEYS, PROCS, ETC. */
                READ'MIBOB'NAME(FILE'ARY,0,INDEX,0,KEY//SF'PUNT);
                GOTO START IF (I←INDEX[0]$OBJ'TYPE#SIBSFCD AND I#SIBLFCD
                              AND I#SIBLKCD AND NOT LIST'OBJ);
            ENDIF;
            GOTO START IF (FILE'ARY[0]#USER'NO AND NOT PRIVILEGE);
            NAME'PTR←MAKE(LNAME,NAME'ZONE);
            NAME'PTR.NAMNX←LAST'NAME; LAST'NAME←NAME'PTR;
            BCOPY(@(NAME'PTR.NAMNM),FILE'PTR,LUFN);
            NAME'CNT←NAME'CNT+1;
        ENDRPT;

END'RD: IF NAME'CNT=0 DO;
            PTIS("NO FILES FOUND"); PTNL();
            PRINT'STRING(-1,OL,0// VALUE (FRETURN IF ERCODE='QIT'
            ELSE NC'PUNT):ERCODE,ERMSNO); RETURN;
        ENDIF;
        NAME'LIST←AR'DESC(NAME'CNT,
        MAKE(NAME'CNT,INFINITY'ZONE),1,0);
TIME'LP:LAST'NAME←NAME'PTR.NAMNX;
        BCOPY(FILE'PTR,@(NAME'PTR.NAMNM),LUFN);
        READ'MIBOB'VALUE(FILE'ARY,LSIBV-2,VAL'ARY,0,KEY//SF'PUNT);
        NAME'PTR.NAMTM←VAL'PTR.SIBFLWD; NAME'CNT←NAME'CNT-1;
        NAME'LIST[NAME'CNT]←NAME'PTR;
        GOTO TIME'LP IF NAME'PTR←LAST'NAME#0;

        SORTFILE(NAME'LIST,SORT'FCN[ORDER]) IF ORDER<2;

        FOR NAME'CNT←0 TO ARRAYUB(@NAME'LIST) DO;
            BCOPY(FILE'PTR,@(NAME'LIST[NAME'CNT].NAMNM),LUFN);
            EXFILE(FILE'ARY,OPTION,LIST'OBJ,KEY// FRETURN);
        ENDFOR;

        FREE(@NAME'LIST[0],INFINITY'ZONE);
        FREEZONE(NAME'ZONE,INFINITY'ZONE);
        RETURN;

       END;

        COMMON EXFILEDECS; INCLUDE DECDECS;

        STARY TYPE[16]←(6" <SFL>",6" <LFL>",6" <PROC>",6" <KEY>",6" <RES>",
        6" <OWL>",6" <FRL>",6" <7?>",6" <8?>",6" <9?>",6" <10?>",
        6" <11?>",6" <12?>",6" <13?>",6" <BSCMD>",6" <LNK>");

       END;

        PROGRAM EXFILE; INCLUDE USERDECS,SIBDECS,EXFILEDECS;

        INT OPTION,KEY,ERCODE,ERMSNO,CHAR,ACWD,LIST'OBJ,LAST'PAGE,
            LAST'WORD,FILE'LENGTH;
        INTARY FILE'ARY,VAL'ARY[MLSIB],LENGTH'WORD[3]; PTR FILE'PTR,VAL'PTR;
        ST NAME'ST;
        UINFL PA(0:12,15),UA(0:16,19),OA(0:20,23),
              PAGES'IN'FILE(0:2,12),WORDS'IN'PAGE(0:13,23);

        ENTRY EXFILE(FILE'ARY,OPTION,LIST'OBJ,KEY), FRETURN;

        FILE'PTR←@FILE'ARY[0]; VAL'PTR←@VAL'ARY[0];
        READ'MIBOB'VALUE(FILE'ARY,LSIBV-2,VAL'ARY,0,KEY//SF'PUNT);

        IOUTS(); NAMSET(NAME'ST,NMNCH,@(FILE'PTR.UFNMN),LNCH);
        PTCH(CHAR) FOR CHAR←GCI(NAME'ST//LIFL1) WHILE CHAR#' ';
LIFL1:  PTCH(':');

        NAMSET(NAME'ST,NTYCH,@(FILE'PTR.UFNTY),LNCH);
        PTCH(CHAR) FOR CHAR←GCI(NAME'ST//LIFL2) WHILE CHAR#' ';

LIFL2:  IF ACWD←VAL'PTR.SIBVOT<=SIBLFCD DO;
            GOTO LIFL3 IF OPTION#0 AND OPTION#3;
            IF LIST'OBJ DO;
                PTST(" LEN= "); PTON(VAL'PTR.SIBFLLEN); PTCH('B');
            ELSE DO;
                READ'MIBOB'VALUE(FILE'ARY,1,LENGTH'WORD,2,-1//SF'PUNT);
                LAST'PAGE ← LENGTH'WORD[2]$PAGES'IN'FILE - 1;
                LAST'WORD ← LENGTH'WORD[2]$WORDS'IN'PAGE + 1;
                FILE'LENGTH ← ((2048*LAST'PAGE)+LAST'WORD);
                PTCH(' '); PTDN(FILE'LENGTH); PTST(" WORDS");
            ENDIF;
LIFL3:      GOTO LIFL4 IF OPTION#0 AND OPTION#4;
            /*PRINT TIMES*/
LIFL4:
        ELSEIF ACWD=SIBLKCD DO;
            IF OPTION=0 DO;
                PTST(" <LINKS TO> #"); PTDN(VAL'PTR.SIBLKUN$UNDKUN);
                PTCH(':'); NAMSET(NAME'ST,NMNCH,@(VAL'PTR.SIBLKMN),LNCH);
                PTCH(CHAR) FOR CHAR←GCI(NAME'ST//LILK1) WHILE CHAR#' ';
LILK1:          PTCH(':'); NAMSET(NAME'ST,NTYCH,@(VAL'PTR.SIBLKTY),LNCH);
                PTCH(CHAR) FOR CHAR←GCI(NAME'ST//LILK2) WHILE CHAR#' ';
LILK2:      ENDIF;
        ELSE DO;
            IF OPTION=0 DO;
                PTST(TYPE[ACWD]);
            ENDIF;
        ENDIF;
        GOTO LIFL5 IF OPTION#0 AND OPTION#2;
        READ'MIBOB'NAME(FILE'ARY,LSIBN-2,VAL'ARY,0,KEY//
        SF'PUNT); ACWD←VAL'PTR.SIBNAC;
        PRTAC(ACWD$PA,'NO','P');
        PRTAC(ACWD$UA,'RW','F');
        PRTAC(ACWD$OA,'OW','O');

* PRINT LOCK LIST
LIFL5:  PTNL();
        PRINT'STRING(-1,OL,0// VALUE FRETURN IF ERCODE='QIT'
        ELSE NC'PUNT:OL,ERCODE,ERMSNO); RETURN;


       END;

        PROGRAM PRTAC; INCLUDE USERDECS,ACCTAB;
        DECLARE ACVAL,NRMAC,CHAR,INDEX;

        ENTRY PRTAC(ACVAL,NRMAC,CHAR);
        (INDEX←ACCVL[INDEX] & GOTO PAC1) IF ACCWD[INDEX]=NRMAC
        FOR INDEX←LACVL-1 BY -1 TO 0;
        INDEX←-1;
PAC1:
        IF ACVAL#INDEX DO;
            PTCH(' '); PTCH(CHAR); PTCH('(');
            (CHAR←ACCWD[INDEX] & GOTO PAC2) IF ACCVL[INDEX]=ACVAL
            FOR INDEX←LACVL-1 BY -1 TO 0;
            PTON(ACVAL); PTCH(')'); RETURN;
PAC2:       PTCH(CHAR$CH1); PTCH(CHAR$CH2); PTCH(')');
        ENDIF; RETURN;

       END;

        PROGRAM GETACD; INCLUDE USERDECS,ACCTAB;
        INT AC,CD,ERMSNO; CHR ERCODE; ST L; STFL A(0); PTR P;

        INTENT GETACD(STRING @P), FRETURN;

        L←P.A; CD←CSN(L,10//GET1);
        GOTO GET2 IF CD<0 OR CD>17B ELSE GOTO GET3;

GET1:   AC←GCI(L//GET2);
        AC←(AC LSH 8) V' GCI(L//GET2);
        (CD←ACCVL[CD] & GOTO GET3) IF ACCWD[CD]=AC
        FOR CD←LACVL-1 BY -1 TO 0;

GET2:   PTIS("ILLEGAL ACCESS CODE VALUE"); PTNL();
        PRINT'STRING(-1,OL,0// VALUE (FRETURN IF ERCODE='QIT'
        ELSE NC'PUNT):OL,ERCODE,ERMSNO);
        FRETURN;

GET3:   P.RP←L$RP; RETURN CD;

       END;

        PROGRAM SORTFILE; INCLUDE USERDECS;
        INT NEXT,MAX,MXP,NXP;
        INTARY LIST; INTFN GRTRFCN;

        ENTRY SORTFILE(LIST,GRTRFCN);
        FOR MAX←ARRAYUB(@LIST) BY -1 TO 1 DO; MXP←LIST[MAX];
            FOR NEXT←MAX-1 BY -1 TO 0 DO; NXP←LIST[NEXT];
                IF NXP#0 AND (MXP=0 OR GRTRFCN(NXP,MXP)) DO;
                    LIST[NEXT]←MXP; MXP←LIST[MAX]←NXP;
                ENDIF;
            ENDFOR;
        ENDFOR;
        RETURN;

       END;

        PROGRAM SORT'FCNS; INCLUDE LIST'BEAD;
        DECLARE X,Y,A,B,STRING S,T;

        ENTRY NAME'GRTR(X,Y);
        NAMSET(S,NFNCH,@(X.NAMFN),LNCH);
        NAMSET(T,NFNCH,@(Y.NAMFN),LNCH);
LP:     A←GCI(S// RETURN 0); B←GCI(T);
        RETURN -1 IF A>B ELSE RETURN 0 IF A<B ELSE GOTO LP;

        ENTRY TIME'GRTR(X,Y);
        RETURN (-1 IF X.NAMTM>Y.NAMTM ELSE 0);

       END;

        COMMON REAL'NAMES; INCLUDE DECDECS;
*
* REAL NAME TABLE AND ATTACH HEADER FOR DEBUGGING
*
        MACRO RNTE(A,B)←(A,0,0,0,B);

        INTARY RNT[5:5]←
        (RNTE(6,23),RNTE(0,24),
        RNTE(1,25),RNTE(2,26),RNTE(-1,0));
        PTR RNTP= G' [7]←@RNT[0];

        INTARY ATFHDR[46:,30000B]←(0,7,0,60012002B,20032004B);
        INTARY ATFHDR[54B]←(12B,0);

        END;

        COMMON SYSCALLS;

* MCALL DECLARATIONS

        MACRO ARBMC←UNKNOWN MONITOR;
        MACRO INTMC←INTEGER MONITOR;
        MACRO STMC←STRING MONITOR;
        MACRO LNMC←LONG MONITOR;
        MACRO LNLNMC←LONGLONG MONITOR;

* CALLS TO MANIPULATE MIBS AND SIBS
        INTMC CREATE'MIB←190;
        ARBMC READ'MIBOB'INDEX←0;
        ARBMC READ'MIBOB'NAME←1;
        ARBMC SET'MIBOB'NAME←2;
        ARBMC SET'MIBOB'ACCESS←3;
        ARBMC SET'LOCK'LIST←4;
        ARBMC DELETE'MIBOB←5;
        INTMC CREATE'MIBOB←6;
        ARBMC SET'MIB'ACCESS←10;
        INTMC READ'MIB'ACCESS←11;
        ARBMC SET'MIBOB'VALUE←12;
        INTMC COPY'MIBOB←14;* UNIMPLEMENTED
        ARBMC SET'NO'CHARGE←15;*** ???
        INTMC READ'MIB'SPACE←16;
        ARBMC SET'FILE'LOCK←18;*?* UNIMPLEMENTED
        ARBMC SET'DURABILITY←28;*** ???

* OFT CALLS
        INTMC MOPEN'FILE←19;
        ARBMC MREAD'OFT←20;
        ARBMC SET'OFT'AL←21;
        INTMC MSET'OFT'CL←22;
        ARBMC SET'FILE'LENGTH←23;* IMPROVE THIS FOR UTS
        INTMC CR'FILE'PAGE←24;
        INTMC DEL'FILE'PAGE←25;
        INTMC NEXT'FILE'PAGE←26;
        ARBMC MOVE'PAGE'PMT←27;

* PMT CALLS
        INTMC ACQUIRE'PMT←50;
        ARBMC NEW'PMT'PAGE←51;
        ARBMC CLEAR'PMT←53;
        ARBMC DELETE'PMT←54;
        ARBMC SET'PMT'AL←55;
        ARBMC SET'PMT'CL←56;
        ARBMC SET'PMT'RO←57;
        ARBMC READ'PMT←58;

* WORKING SET CALLS
        ARBMC PUT'PAGE'DWS←65;
        ARBMC PUT'PAGE'CWS←66;
        INTMC DEL'PAGE'DWS←67;
        INTMC DEL'PAGE'CWS←68;
        INTMC READ'LWS←70;
        ARBMC SET'LWS←71;

* SPT CALLS
        INTMC MCREATE'SP←90;
        ARBMC MDESTROY'SP←91;
        ARBMC MREAD'SPT←95;
        ARBMC READ'SPCS←96;
        INTMC MRD'SPT'FIELD←97;
        ARBMC MST'SPT'FIELD←98;
        ARBMC READ'MAP←99;
        ARBMC SET'MAP←100;
        INTMC READ'MAP'BYTE←101;
        ARBMC SET'MAP'BYTE←102;
        INTMC READ'SPS'PARAM←106;

* SPCS CALLS
        ARBMC SP'CALL←111;
        ARBMC SP'JUMP←112;
        ARBMC SP'TRAP←113;
        ARBMC TRAP'RETURN←114;
        ARBMC SP'BRANCH←115;
        ARBMC SP'RETURN←116;
        ARBMC JUMP'RETURN←117;
        ARBMC MARK'CALL←118;
        ARBMC DELETE'CALL←119;
        ARBMC MODIFY'CALL←120;

* PROCESS CALLS
        INTMC COPY'PMT'PROC←130;
        INTMC ACTIVATE'PROC←132;
        ARBMC TRANSFER'TERM←133;
        ARBMC MAKE'DORMANT←134;
        ARBMC INIT'PROC'PAGE←135;
        ARBMC INIT'PROC'MAP←136;
        ARBMC INIT'SPT←137;
        INTMC READ'PROC'PARAM←211;

* IWS CALLS
        ARBMC SET'PROC'INT←163;
        ARBMC QUIT'BLOCK←164;
        INTMC GET''INT'NO←165;
        ARBMC READ'ICT←166;
        ARBMC ALLOW'INTS←168;
        ARBMC REFUSE'INTS←169;
        ARBMC BLOCK←170;
        ARBMC SET'ICT←172;
        ARBMC SET'ICT'CL←173;
        INTMC ACQUIRE'ICT←174;

* CHIO CALLS
        ARBMC SET'LINE'FIELD←180;
        ARBMC READ'LINE'TABLE←181;
        ARBMC READ'STRING'BRK←182;
        ARBMC WRITE'STRING←183;

* MISCELLANEOUS
        ARBMC MON'LOCK←29;
        ARBMC MON'UNLOCK←30;
        LNMC READ'CLOCK←210;

* UCALL DECLARATIONS

        MACRO ARBUC←UNKNOWN UTILITY;
        MACRO INTUC←INTEGER UTILITY;
        MACRO CHRUC←CHARACTER UTILITY;
        MACRO STUC←STRING UTILITY;
        MACRO LNUC←LONG UTILITY;

* MISCELLANEOUS UCALLS
        ARBUC BREAK'POINT←0;*             UCALL FOR DEBUGGING PROGRAMS
        STUC ERRORMSG←1;*                RETURN SYSTEM ERROR MESSAGE
        STUC GET'PARAM←2;*               STRIP PARAMETER FROM STRING
        STUC GET'COM'LINE←3;*            GET CURRENT COMMAND LINE FROM UTS
        INTUC ABRV'LKP←4;*                LOOK UP ABBREVIATED NAME IN STARY
        INTUC CON'ABRV'LKP←5;*            CONTINUE SAME IN NEW STARY

* FILE SYSTEM CALLS
        ARBUC NAME'SEARCH←10;*            CONVERT FILE ST TO UTS NAME
        ARBUC SPECIAL'SEARCH←11;*         VARIATION OF ABOVE
        INTUC CONV'NAME←12;*              CONVERT FROM UTS TO MON FILE NAME
        ARBUC SPREAD'NAME←13;*            SPLIT FILE NAME STRING INTO COMP.
        ARBUC READ'MIBOB'VALUE←14;*       READ 'VALUE' OF MIB OBJECT
        ARBUC DELETE'FILE←15;*            DELETE FILE AND CONTENTS
        INTUC OPEN'FILE←16;*              OPEN FILE W/WO LOCKING
        ARBUC CLOSE'FILE←17;*             CLOSE AND UNLOCK FILE
        ARBUC READ'OFT←18;*               READ OFT
        INTUC READ'OFT'FIELD←19;*         READ OFT FIELD
        ARBUC SET'OFT'CL←20;*             SET OFT CONTROL LOCK
        ARBUC CONV'KEY←21;*               CONVERT DEFAULT ACCESS KEY

* EXTENDED SPS CALLS
        INTUC CREATE'SSP←30;*             CREATE SUBSIDIARY SUB-PROCESS
        INTUC CREATE'PSP←31;*             CREATE PARALLEL SUB-PROCESS
        ARBUC ATTACH←32;*                 ATTACH PI FILE TO SUB-PROCESS
        ARBUC DESTROY'SP←33;*             DESTROY SUB-PROCESSES
        ARBUC READ'SPT←34;*               READ SPT
        INTUC READ'SPT'FIELD←35;*         READ SPT FIELD
        ARBUC SET'SPT'FIELD←36;*          SET SPT FIELD
        STUC READ'SPNAME←37;*            READ SUB-PROC NAME
        ARBUC SET'SPNAME←38;*             SET SUB-PROC NAME
        INTUC SPNAME'SEARCH←39;*           LOOK UP SP NAME

* CIOS MANIPULATION
        INTUC CREATE'CIOS←40;*            CREATE CONTROL I/O STREAM
        INTUC READ'CIOS'FIELD←41;*        READ CIOS FIELD
        ARBUC SET'CIOS'FIELD←42;*         SET (SOME) CIOS FIELDS
        ARBUC SET'CIOS'INPUT←43;*         SET UP FOR INPUT
        ARBUC SET'CIOS'OUTPUT←44;*        SET UP FOR OUTPUT

* CIOS INPUT/OUTPUT
        ARBUC PRINT'STRING←45;*           WRITE STRING ON CIOS
        ARBUC PRINT'CHAR←46;*             WRITE (= BUFFER) CHAR ON CIOS
        ARBUC START'OUTPUT←47;*           DUMP OUTPUT BUFFER
        STUC READ'LINE←48;*              READ NEXT INPUT LINE
*STUC      EDIT'LINE ← 49;*              EDIT CURRENT LINE
        CHRUC READ'CHAR←50;*              READ NEXT CHARACTER
        ARBUC BLOCK'OB'EMPTY←51;*         WAIT UNTIL OUT BUFFER IS EMPTY

* USER, ACCOUNT, AND GROUP PROFILES
        STUC READ'UP'ITEM←60;*           READ ITEM FROM USER PROFILE
        STUC READ'UP'NAMES←61;*          READ NAMES OF UP ITEMS
        ARBUC SET'UP'ITEM←62;*            SET (CREATE) VALUE OF UP ITEM
        ARBUC SET'UP'ACCESS←63;*          SET ACCESS TO UP ITEM
        LNUC FIND'MIB←64;*               CONVERT USER NAME/NUMBER TO MIB ADDR
        ARBUC CREATE'UP'ENTRY←65;*        CREATE USER/UP ENTRY
        ARBUC DELETE'UP'ENTRY←66;*        DELETE USER/UP ENTRY

* PROCESSES, AND PROCESS PROFILE
        ARBUC CREATE'PROCESS←70;*         CREATE/INITIALIZE PROCESS
        STUC READ'PP'ITEM←71;*           READ ITEM FROM PROCESS PROFILE
        STUC READ'PP'NAMES←72;*          READ NAMES OF PP ITEMS

        ARBUC SET'PP'ITEM←73;*            SET (CREATE) VALUE OF PP ITEM

        END;

        COMMON DECDECS;
*
* SHORT DECLARATION MACROS FOR SPL
*

        MACRO INT←DECLARE INTEGER;
        MACRO OCT←DECLARE OCTAL;
        MACRO PTR←DECLARE POINTER;
        MACRO CHR←DECLARE CHARACTER;
        MACRO ST←DECLARE STRING;
        MACRO LN←DECLARE LONG;
        MACRO LNLN←DECLARE LONGLONG;
        MACRO LB←DECLARE LABEL;

        MACRO OCTFL←DECLARE OCTAL FIELD;
        MACRO INTFL←DECLARE INTEGER SIGNED FIELD;
        MACRO PTRFL←DECLARE POINTER FIELD;
        MACRO CHRFL←DECLARE CHARACTER FIELD;
        MACRO STFL←DECLARE STRING FIELD;
        MACRO LNFL←DECLARE LONG FIELD;
        MACRO ARYFL←DECLARE ARRAY FIELD;
        MACRO FNFL←DECLARE FUNCTION FIELD;

        MACRO INTARY←DECLARE INTEGER ARRAY;
        MACRO OCTARY←DECLARE OCTAL ARRAY;
        MACRO PTRARY←DECLARE POINTER ARRAY;
        MACRO CHRARY←DECLARE CHARACTER ARRAY;
        MACRO STARY←DECLARE STRING ARRAY;
        MACRO LNARY←DECLARE LONG ARRAY;
        MACRO LBARY←DECLARE LABEL ARRAY;
        MACRO FLARY←DECLARE FIELD ARRAY;
        MACRO FNARY←DECLARE FUNCTION ARRAY;

        MACRO INTARY1←DECLARE INTEGER ARRAYONE;
        MACRO PTRARY1←DECLARE POINTER ARRAYONE;

        MACRO INTFN←DECLARE INTEGER FUNCTION;

        MACRO ARBENT←UNKNOWN ENTRY;
        MACRO INTENT←INTEGER ENTRY;
        MACRO OCTENT←POINTER ENTRY;
        MACRO PTRENT←POINTER ENTRY;
        MACRO CHRENT←CHARACTER ENTRY;
        MACRO STENT←STRING ENTRY;
        MACRO LNENT←LONG ENTRY;
        MACRO LBENT←LABEL ENTRY;
        MACRO ARYENT←ARRAY ENTRY;

        MACRO ARBEXT←DECLARE UNKNOWN EXTERNAL;
        MACRO INTEXT←DECLARE INTEGER EXTERNAL;
        MACRO OCTEXT←DECLARE OCTAL EXTERNAL;
        MACRO PTREXT←DECLARE POINTER EXTERNAL;
        MACRO CHREXT←DECLARE CHARACTER EXTERNAL;
        MACRO STEXT←DECLARE STRING EXTERNAL;
        MACRO LNEXT←DECLARE LONG EXTERNAL;
        MACRO LBEXT←DECLARE LABEL EXTERNAL;
        MACRO ARYEXT←DECLARE ARRAY EXTERNAL;

        MACRO C'(X)←;* KLUDGE FOR INTERNAL COMMENTS

        MACRO LTABLE(F)←F$FLDWDSP+1;
        INTFL FLDWDSP(0:13,23);

* LENGTHS OF NAMES
        INT LMN←4,LTY←1,LFN←LMN+LTY;
        INT NBY←4,LNCH←24/NBY,NMNCH←LMN*NBY,
        NTYCH←LTY*NBY,NFNCH←LFN*NBY,NCMCH←90;

        END;

        COMMON SYS'COMMON; INCLUDE SYSCALLS;

*
* MCALLS, UCALLS, & GLOBAL CELLS
*

        DECLARE INTEGER QUIT'FLAG;* GLOBAL QUIT FLAG
        DECLARE INTEGER QUIT'FCN'FLAG;* GLOBAL QUIT FUNCTION FLAG
        DECLARE INTEGER ERMSNO;* SYSTEM ERROR NUMBER
        DECLARE CHARACTER ERCODE;* SYSTEM ERROR CODE

        END;

        COMMON MACHINE'DECS; INCLUDE DECDECS;
*
* DECLARATIONS FOR MACHINE-DEPENDENT PROGRAMMING
*

* MAXIMUM NUMBER OF ACTIVE TERMINALS PERMITTED ON SYSTEM

       DECLARE PARAMETER MAX'PRT←32;
       DECLARE PARAMETER MAX'TERMS←40;

* SYSTEM OBJECT LOCK DECLARATIONS
       DECLARE PARAMETER LINKING←0;

* LOW-G DEFINITIONS
        PTR STACK'PTR= G' [2],STACK'LIM= G' [3],
        RTRAP'PARAM= G' [5],RTRAP'LOC= G' [4];

* FIELDS IN BLL DESCRIPTOR
        PTRFL BRDPC(0:6,23),BRDLR(1:6,23);

* STATE DEFINTIONS
        INT PSTLOC←0,ASTLOC←1,BSTLOC←2,CSTLOC←3,DSTLOC←4,
        ESTLOC←5,XSTLOC←6,LSTLOC←7,GSTLOC←8,SSTLOC←9,
        LSTATE←10;

* FIELDS FOR TRAP DEFINITIONS
        PTRFL ADDR(0:6,23); OCTFL SP'TNO(-2),SP'TPAR(-1),
        BLL'CLASS(0:3,5),UTSE'CLASS(0:0,1),
        UTSE'SPTNO(0:1,5),UTSE'RTNO(0:2,5);

        END;

        COMMON COMDECS; INCLUDE DECDECS,SYS'COMMON;
*
* COMMON DECLARATIONS FOR CODING
*

* GENERALLY USEFUL MACROS

        MACRO NAMSET(S,L,A,B)←SETUP(S,L,A,B) & S$WP←S$EP;
        MACRO EMPTY(S)←LNGDES(S$RP,S$WP)<=0;*** WP=RP OR WP=BP?
        MACRO REPEAT← WHILE 1 DO;
        MACRO ENDRPT← ENDFOR;
        MACRO FDISP(F)←RUNTIME'FAILURE() IF F$FLDSTB#0 OR
        F$FLDSIZE#24 ELSE F$FLDWDSP;
        OCTFL FLDSTB(0:8,12),FLDSIZE(0:3,7);

* ERROR MACROS
        MACRO NC'PUNT←RUNTIME'FAILURE();* FOR NORMAL CALLS (EXPRESSIONS)
        MACRO LF'PUNT← VALUE NC'PUNT;* FOR LIBRARY FUNCTIONS
        MACRO SF'PUNT←LF'PUNT:ERCODE,ERMSNO;* FOR SYSTEM CALLS

* QUIT ACTION MACROS
        MACRO QUIT'PUNT(L)← VALUE GOTO L IF ERCODE='QIT' ELSE
        RUNTIME'FAILURE():ERCODE,ERMSNO;
        MACRO QUIT'PUNTX(L,X)← VALUE GOTO L IF ERCODE='QIT' ELSE
        RUNTIME'FAILURE():X,ERCODE,ERMSNO;

* PARAMETRIC CHARACTER DEFINITIONS
        CHR SCHERALD←'>' C'(/* SUB-COMMAND HERALD */),
        BELCH←303B C'(/* BELL */),NULCH←300B C'(/* NULL */),
        NLCH←307B C'(/* NEW LINE */),
        LFCH←310B C'(/* LINE FEED */),
        MBCH←200B C'(/* ZERO MULTIPLE BLANKS */),
        SQTCH←'&'' C'(/* SINGLE QUOTE */),
        DQTCH←'"' C'(/* DOUBLE QUOTE */),
        SEPCH←'-' C'(/* SEPARATOR */);

* STRING POINTER FIELDS
        OCTFL BP(0) C'(/* BEGINNING */),RP(1) C'(/* READER */),
        WP(2) C'(/* WRITER */),EP(3) C'(/* END */);
* CHARACTER FIELDS
        CHRFL CH0(0:0,7),CH1(0:8,15),CH2(0:16,23);
* BEAD LENGTH FIELD
        PTRFL LENGF(-1:6,23);

* FIELDS IN UTILITY FILE NAME
        LNFL UFNUN(0) C'(/* USER NUMBER/DISK ADDRESS */);
        OCTFL UFNEN(2) C'(/* OBJECT ENTRY-NUMBER */),
        UFNFN(3) C'(/* FILE NAME */),UFNMN(3) C'(/* MAIN NAME */),
        UFNTY(3+LMN) C'(/* TYPE WORD */);

* FIELDS FOR UNO/DKA
        OCTFL UNDKUN(0),
        UNDKDK(1);

        INT LUFN←LTABLE(UFNTY);* LENGTH OF UTILITY FILE:NAME

        INT CB'PMT←1;* PMT ADDRESS OF CONTEXT BLOCK

* DECLARATIONS OF COMMON FUNCTIONS

* SPL RUNTIME FUNCTIONS
*ARBEXT    SCOPY, APPEND, CNS, RUNTIME'FAILURE;
        ARYEXT LBARY'KLUDGE;*, AR'DESC;
        PTREXT SBASE; INTEXT ARRAYUB,ARRAYLB;* STEXT ST'DESC;
        LNEXT LONG'ADD,LONG'SUB; INTEXT LONG'LE,LONG'LT;

* STORAGE ALLOCATOR
        PTREXT STKMAKE;*, MAKE, SETZONE;
*ARBEXT    STORINIT, SELZONE, EXTZONE, FREE, FREEZONE;

        END;

        COMMON UQNDECS; INCLUDE DECDECS;

* UNIQUE NAME FIELDS
        OCTFL UQNTY(0:0,1),UQNPMB(0:0,0),UQNLFB(0:1,1),
        UQNOWN(0:2,17),UQNHFN(0:18,23);
        OCTFL UQNLFN(1:0,12),UQNLPN(1:13,23),
        UQNSFN(1:0,15),UQNSPN(1:16,23);

        END;

        COMMON BFSDECS; INCLUDE UQNDECS;

* OBJECT TYPE-CODES
        INT SIBSFCD←0,SIBLFCD←1,SIBPRCD←2,SIBAKCD←3,
        SIBRSCD←4,SIBOWCD←5,SIBFRCD←6,
        SIBSCCD←14,SIBLKCD←15;

* ACCESS KEY FIELDS
        OCTFL ACK0(0),ACK1(1:0,7),ACKUN(1:8,23);
        INT NORM'FIL'AC←0357B;* P(NO) F(RW) O(OW) - NORMAL ACCESS

        END;

        COMMON SIBDECS; INCLUDE BFSDECS;
*
* DECLARATIONS FOR SIB
*

* FIELDS IN SIB NAME (SIBN)
        OCTFL SIBNOT(0:1,4),
        SIBNLN(0:10,23),
        SIBNAA(1:1,4),SIBNEN(1:10,23),
        SIBNMN(2),SIBNFN(2);
        OCTFL SIBNTY(SIBNMN$FLDWDSP+LMN),
        SIBNLL(SIBNTY$FLDWDSP+1:4,11),
        SIBNAC(SIBNLL$FLDWDSP:12,23);
        OCTFL SIBNPA(SIBNAC$FLDWDSP:12,15),
        SIBNFA(SIBNAC$FLDWDSP:16,19),
        SIBNOA(SIBNAC$FLDWDSP:20,23);

        INT LSIBN←LTABLE(SIBNOA);* LENGTH OF SIBN TABLE

* FIELDS IN SIB VALUE (SIBV)
        OCTFL SIBVOT(0:1,4),
        SIBVLN(0:10,23),
        SIBVAA(1:1,4),SIBVEN(1:10,23);
        LNFL SIBFLUN(2);
        OCTFL SIBFLLEN(4),
        SIBFLWD(5),
        SIBFLRD(6);

        LNFL SIBLKUN(2);
        OCTFL SIBLKEN(4),
        SIBLKMN(5),
        SIBLKTY(5+LMN);

        INT LSIBFL←LTABLE(SIBFLRD),LSIBLK←LTABLE(SIBLKTY),
        LSIBV←(LSIBFL IF LSIBFL>LSIBLK ELSE LSIBLK);
        INT MLSIB←(LSIBV IF LSIBV>LSIBN ELSE LSIBN);

        END;

        COMMON SPTDECS; INCLUDE DECDECS;

* FIELDS IN SPCS
        OCTFL SPCSNIS(0:0,0),SPCSNIC(0:1,1),
        SPCSCSP(0:2,5),SPCSPR(0:6,23),
        SPCS940M(1:0,0),SPCSR0SP(1:2,5),SPCSLR(1:6,23),
        SPCSR1SP(2:2,5),SPCSGR(2:6,23);
        LNFL SPCSIT(3);
        INT LSPCS←LTABLE(SPCSIT)+1;

        INT NSPT←8;

        END;

        PROGRAM LABEL'KLUDGE; INCLUDE DECDECS;
*
* CONVERT SOURCE RELATIVE LABEL TO ABSOLUTE
*
        LBARY A;

        ARYENT LBARY'KLUDGE(A); RETURN A;

        END;

        PROGRAM LONG'COMPARE; INCLUDE DECDECS;
*
* COMPARE LONG VALUES
*
        PTR P,Q; INT N;
        DECLARE INTEGER TEST;

        INTENT LONG'COMPARE(INTEGER @P,INTEGER @Q,N);

        FOR N←N-1 BY -1 TO 0 DO;
            TEST←P[N];
            RETURN 1 IF TEST#Q[N];
        ENDFOR;
        RETURN 0;

        END;

       PROGRAM COMPARE'STRING;

*      THIS FUNCTION COMPARES TWO STRING AND RETURNS -1 IF THEY ARE
* IDENTICAL AND 0 IF THEY AREN'T.  THIS FUNCTION FAILS IF THE TWO STRINGS
* DON'T HAVE THE SAME CHARACTER SIZES.


       DECLARE INTEGER
          CHAR1,            /* A CHARACTER READ FROM THE STRING FIRST */
          CHAR2,            /* A CHARACTER READ FROM THE STRING       */
                            /*   SECOND                               */
          COUNT,            /* JUST A COUNTER FOR A FOR LOOP          */
          LENGTH'FIRST;     /* THE LENGTH OF THE STRING FIRST         */

       DECLARE FIELD
          CHAR'SIZE (0:2,3); /* THE SIZE OF CHARACTERS IN THE STRING  */

       DECLARE STRING
          FIRST,
          SECOND;


       FUNCTION COMPARE'STRING(FIRST, SECOND), FRETURN;

       FRETURN IF FIRST$CHAR'SIZE # SECOND$CHAR'SIZE;
       LENGTH'FIRST ← LENGTH(FIRST);

       IF LENGTH'FIRST # LENGTH(SECOND) DO;
          RETURN 0;
       ELSE DO;
          FOR COUNT ← 1 TO LENGTH'FIRST DO;
             CHAR1 ← GCI(FIRST);
             CHAR2 ← GCI(SECOND);
             RETURN 0 IF CHAR1 # CHAR2;
          ENDFOR;
          RETURN -1;
       ENDIF;



       END;

        PROGRAM SCOPY; INCLUDE COMDECS;
        PTR P; ST S,D; STFL A(0);

        ARBENT SCOPY(STRING @P,S), FRETURN;
        D←P.A; P.RP←D$WP←D$RP←D$BP; GOTO L;

        ARBENT APPEND(STRING @P,S), FRETURN;
        D←P.A;

L:
        REPEAT; WCI(GCI(S// VALUE P.WP←D$WP & RETURN),D// FRETURN); ENDRPT;

        END;

        PROGRAM ST'DESC; INCLUDE COMDECS;
        INT N,S,O; PTR P; ST X;
        STENT ST'DESC(N,P,S,O);

        P←MAKE(S*(N+24/S-1)/24) IF P=0;

        IF S=8 DO;
            .LDA 44B6;
        ELSEIF S=6 DO;
            .LDA 40B6;
        ELSEIF S=12 DO;
            .LDA 50B6;
        ELSEIF S=24 DO;
            .LDA 54B6;
        ELSE DO;
            RUNTIME'FAILURE();
        ENDIF;

        .IOR P; .XMA O; .LSHA 18; .IOR O; .LDX-1; .ASP; .CXA;
        .STA X$BP; .STA X$RP; .STA X$WP; .LDX N; .ASP; .STX X$EP;
        RETURN X;

        END;

        PROGRAM CNS; INCLUDE COMDECS;
        INT N,F,R,T,I,D; PTR P; ST S,B(25); STFL A(0);

        ARBENT CNS(N,STRING @P,F,R), FRETURN;

        S←P.A;
        FRETURN IF R<2 OR R>36;
        T←(-N IF F>=0 AND N<0 ELSE N);
        B$RP←B$WP←B$EP; I←0;
LP:     .LDA T; .LSHD-23; .DIV R; .STA T; .STB D;
        WCD(D+('0' IF D<10 ELSE 'A'-10),B);
        I←I+1; GOTO LP IF T#0;
        WCD('-',B) & I←I+1 IF F>=0 AND N<0;
        F←F A' 77B;
        IF F=0 DO;
            F←I;
        ELSEIF F<=I DO;
            B$RP←INCDES(B$EP,-I);
        ELSE DO;
            WCI(' ',S// FRETURN) FOR I←I+1 TO F;
        ENDIF;
        WCI(D,S// FRETURN)
        FOR D←GCI(B// VALUE P.WP←S$WP & RETURN) WHILE 1;

        END;

        PROGRAM CSN; INCLUDE COMDECS;
        PTR P; INT R,F,D,N,FLB,FLP,PW; ST S; STFL A(0);

        INTENT CSN(STRING @P,R), FRETURN;

        FLB←FLP←0;

AGN:    S←P.A; FRETURN IF R<2 OR R>36;

        IF D←GCI(S// FRETURN)='-' OR D='+' DO;
            F←(1 IF D='-' ELSE 0); D←GCI(S// FRETURN);
        ELSE DO;
            F←0;
        ENDIF;

        D←D-'0' IF D>='0' AND D<='9' ELSE
        D←D-('A'-10) IF D>='A' AND D<='Z' ELSE FRETURN;
        FRETURN IF D>=R; N←D;

        FOR D←GCI(S//Y) REPEAT;
            D←D-'0' IF D>='0' AND D<='9' ELSE
            D←D-('A'-10) IF D>='A' AND D<='Z' ELSE GOTO X;
            GOTO X IF D>=R; N←N*R+D;
        ENDRPT;

X:      IF R<=10 AND (D←D+'A'-10='B' OR D='D') DO;
            IF FLB DO;
                S$RP←INCDES(S$RP,1) IF FLP;
            ELSE DO;
                FLB←-1;
                PW←GCI(S//Z); PW←PW-'0' & FLP←-1 IF PW>='0' AND PW<='9'
                ELSE S$RP←INCDES(S$RP,-1);
Z:              R←8 & GOTO AGN IF D='B' AND R#8;
                R←10 & GOTO AGN IF D='D' AND R#10;
            ENDIF;
        ELSE DO;
            S$RP←INCDES(S$RP,-1);
        ENDIF;
Y:      N←N*R FOR D←1 TO PW IF FLP;
        P.RP←S$RP; RETURN (-N IF F ELSE N);

        END;

        PROGRAM SBASE; INCLUDE COMDECS;
*
* FIND BASE ADDRESS OF WORD-ORIGINED STRING DESCRIPTOR
*
        ST S;

        PTRENT SBASE(S);
        .LDA S$BP; .LDX 1; .ASP; .CXA;
        .CMZ 3B6; .BNE L; .ETR 777777B; RETURN;
L:      RUNTIME'FAILURE();

        END;

        PROGRAM ALENGTH; INCLUDE COMDECS;
*
* COMPUTE ARRAY BOUNDS
*
        PTR A; OCTFL ABW(0);
        INTENT ARRAYUB(A);
        .LDA A.ABW; .CMZ 2B6; .BNE R' [2]; .ETR 17777B;
        .ETR 377777B; RETURN;

        INTENT ARRAYLB(A);
        .LDA A.ABW; .ETR 1B7; .ASHA-21; RETURN;

        END;

        PROGRAM LONG'ARITH; INCLUDE COMDECS;
*
* LONG ARITHMETIC/RELATIONALS
*
        LN X,Y; OCTFL W0(0),W1(1);

        LNENT LONG'ADD(X,Y);* ADD
        .LDA X$W1,ADD Y$W1,CAB;
        .LDA X$W0,ADC Y$W0; RETURN;

        LNENT LONG'SUB(X,Y);* SUBTRACT
        .LDA X$W1,SUB Y$W1,CAB;
        .LDA X$W0,SUC Y$W0; RETURN;

        INTENT LONG'LE(X,Y);* LESS THAN OR EQUALS
        RETURN (1 IF LONG'SUB(X,Y)$W0<=0 ELSE 0);

        INTENT LONG'LT(X,Y);* LESS THAN
        RETURN (1 IF LONG'SUB(X,Y)$W0<0 ELSE 0);

        END;

        COMMON ALLOC'DECS;

*
* SPL STORAGE ALLOCATOR
*

* THE BASIC STRUCTURE OF A STORAGE BLOCK IS AS IN THE OLD ALLOCATOR,
* I.E. THE WORD BEFORE THE 0'TH WORD OF A BLOCK CONTAINS THE LENGTH
* OF THE BLOCK (NUMBER OF INFORMATION WORDS +1), A FLAG IN BIT 0
* TO SAY THAT THE BLOCK IS FREE, AND A FLAG IN BIT 1 TO SAY THAT
* THE NEXT LOWER BLOCK IS FREE.
        DECLARE FIELD HIDDEN(-1),HSIZE(-1:6,23),HFREE(-1:0,0),
        HFTAG(-1:1,1),HZTAG(-1:2,2);
* FREE STORAGE COMES IN ZONES.  A ZONE CONSISTS OF A ZONE HEADER
* AND A CHAIN OF EXTENSIONS.  THE ZONE HEADER CONTAINS: THE BLOCK
* SIZE FOR THE ZONE (0 MEANS ALL SIZES ARE ALLOWABLE), THE OVERFLOW
* ROUTINE, THE EXTENSION LIST, AND THE FREE LIST ROVER.
        DECLARE FIELD FEXT(0),FLIST(2),FUNCTION FIELD FOVX(1);
        DECLARE PARAMETER FZHS←3;
* THE FEXT WORD IN EACH EXTENSION POINTS TO THE NEXT ONE.  THIS CHAIN,
* IS TERMINATED BY A -1.  THE FIRST TWO WORDS
* OF A FREE BLOCK ARE USED TO HOLD THE ADDRESS OF THE NEXT FREE
* BLOCK AND THE PREVIOUS FREE BLOCK.  THIS LIST IS CIRCULAR.
        DECLARE FIELD NBLK(0),PBLK(1);
* FOR FIXED-SIZE ZONES, THE ENTIRE FREE LIST AND THE HIDDEN WORDS
* ARE SET UP AT THE TIME AN EXTENSION IS CREATED.  FOR VARIABLE-SIZED
* ZONES, AN EXTENSION IS SET UP AS A SINGLE FREE BLOCK WHICH IS
* SUBDIVIDED AS THE NEED ARISES.  A FIRST-FIT STRATEGY WITH A "ROVER"
* IS USED FOR THE LATTER.  BLOCKS BELOW A MINIMUM SIZE WILL NOT BE CREATED.
        DECLARE PARAMETER MINSIZ←3;

        DECLARE INFINITY'ZONE,CURRENT'ZONE;* ZONE VARIABLES FOR ALLOCATOR

        END;

        PROGRAM STKMAKE; INCLUDE ALLOC'DECS;
        FIXED;
*
* ALLOCATE LOCAL (STACKED) STORAGE
*
        DECLARE SP= G' [2],SL= G' [3],BLK,SIZE;

        FUNCTION STKMAKE(SIZE);

        RUNTIME'FAILURE() IF SP+SIZE>=SL;
        SP←(BLK←SP+1)+SIZE;
        BLK.HIDDEN←SIZE+1;
        BSET(BLK,0,SIZE);
        RETURN BLK;

        END;

        PROGRAM MAKE; INCLUDE ALLOC'DECS;
*
* ASSIGN BLOCK OF SIZE (A) IN ZONE (B)
*
        DECLARE BLK,ROVER,RSIZE,EBLK,ROVEC;

        FUNCTION MAKE(SIZE,ZONE);

        ZONE←CURRENT'ZONE IF ZONE=0;
        SIZE←SIZE+1;
        SIZE←MINSIZ IF (SIZE<MINSIZ);
        GOTO MAKEOV IF ZONE.FLIST<0;
* VARIABLE-SIZED ZONE
        ROVEC←ROVER←ZONE.FLIST;
MAKE1:  RSIZE←ROVER.HSIZE;
        IF RSIZE<SIZE+MINSIZ AND RSIZE#SIZE DO;
            GOTO MAKE1 IF (ROVER←ROVER.NBLK)#ROVEC
            ELSE GOTO MAKEOV;
        ENDIF;
        EBLK←(BLK←ROVER)+ROVER.HSIZE;
        EBLK.HFTAG←0;
        IF ROVER.HSIZE=SIZE DO;
* EXACT FIT
            BLK.HFREE←0;
            ZONE.FLIST←RFB(ROVER,ZONE);
        ELSE DO;
* SPLIT THE BLOCK
            BLK←EBLK-SIZE;
            BLK.HIDDEN←1@HFTAG+SIZE;
            BLK[-2]←-RSIZE IF (RSIZE←ROVER.HSIZE←ROVER.HSIZE-SIZE)>MINSIZ;
        ENDIF;
* COMMON EXIT
        BSET(BLK,0,SIZE-1);
        RETURN BLK;

* OVERFLOW
MAKEOV: BLK←(ZONE.FOVX)(SIZE-1,ZONE); RETURN BLK;

        END;

        PROGRAM RFB; INCLUDE ALLOC'DECS;
        FUNCTION RFB(RBLK,ZONE);
* SUBROUTINE TO REMOVE A BLOCK FROM THE FREELIST
        IF RBLK.NBLK=RBLK DO;
            RETURN ZONE.FLIST←-1;
        ELSE DO;
            ZONE.FLIST←RBLK.NBLK IF ZONE.FLIST=RBLK;
            RBLK.NBLK.PBLK←RBLK.PBLK;
            RETURN RBLK.PBLK.NBLK←RBLK.NBLK;
        ENDIF;

        END;

        COMMON USERDECS; INCLUDE COMDECS;
*
* DECLARATIONS FOR USER PROGRAMS
*
        ST OL(NCMCH);* OUTPUT BUFFER FOR USER CONSOLE OUTPUT
        LB TRAP'LABEL;* GO HERE AFTER TRAP
        PTR INITIAL'SP←3000B, NORMAL'SL←3777B;

        INT WAKEUP'TIMER, THIS'SUB'PROCESS;
* OUTPUT MACROS
        MACRO IOUT()←SETS(OL,0,0);
        MACRO PTCH(C)←WCI(C,OL);
        MACRO PTST(S)←APPEND(OL,S//LF'PUNT);
        MACRO PTNO(N,F,R)←CNS(N,OL,F,R//LF'PUNT);
        MACRO PTDN(N)←PTNO(N,4B7,10);
        MACRO PTON(N)←PTNO(N,4B7,8);
        MACRO PTNL()←WCI(NLCH,OL);
        MACRO PTIS(S)←SCOPY(OL,S//LF'PUNT);

        END;

        COMMON TRAP'DECS; INCLUDE MACHINE'DECS;

* TRAP VARIABLES
        INT TRAP'FLAG;* FLAG INDICATING WHETHER A TRAP IS BEING PROCESSED
        PTR INSTR'LOC;* PTR TO INSTR FOLLOWING ONE CAUSING ABE TRAP
        INT SAVEL;* SAVE L-REG WHILE DOING EAC IN ABE'TRAP
        INT GSAVER; INTARY GSTATE[LSTATE],SP'GSTATE[LSTATE];* GLOBAL TRAP STATES
        INT SP'LEV;* SUBPROCESS LEVEL ON ENTRY

        END;

        PROGRAM USER'ENTRIES; INCLUDE USERDECS,TRAP'DECS;
*
* ENTRY POINTS
*
        FIXED;

        MACRO SAVE'STATE(X)←.STX X[XSTLOC],EAX X[0],STORS,MIN TRAP'FLAG;

* COME HERE AFTER TRAP MESSAGE
T'L:    JUMP'RETURN(
        READ'SPS'PARAM('CSL'//SF'PUNT)-SP'LEV-1//T'R:ERCODE,ERMSNO);
T'R:    SP'RETURN(//SF'PUNT);

* INITIAL AND 'CONTINUE' SUBPROCESS ENTRIES
        ARBENT XXXXXX(), SP'ENTRY ←2;
        ARBENT XXXXXY(), SP'ENTRY ←3;

        .LDA INITIAL'SP,XLA;
        TRAP'LABEL←T'L; TRAP'FLAG←QUIT'FCN'FLAG←QUIT'FLAG←0;
        STACK'PTR←INITIAL'SP; STACK'LIM←NORMAL'SL;
        SP'LEV←READ'SPS'PARAM('CSL'//SF'PUNT);
        SET'SPT'FIELD(-1,'TM',READ'SPT'FIELD(-1,'TCM'//SF'PUNT)
             //SF'PUNT);
        RUN'USER(); RUNTIME'FAILURE();

* SP'TRAPS COME HERE
        ARBENT XXXSPT(), SP'ENTRY ←0; SAVE'STATE(SP'GSTATE); STRAP();


* RING TRAPS
        ARBENT XXXABE(), TRAP'ENTRY ←1; SAVE'STATE(GSTATE); ABE'TRAP();
        ARBENT XXXFLO(), TRAP'ENTRY ←2; SAVE'STATE(GSTATE); RTRAP(2);
        ARBENT XXXFLU(), TRAP'ENTRY ←3; SAVE'STATE(GSTATE); RTRAP(3);
        ARBENT XXXRO(), TRAP'ENTRY ←4; SAVE'STATE(GSTATE); RTRAP(4);
        ARBENT XXXIAT(), TRAP'ENTRY ←5; SAVE'STATE(GSTATE); RTRAP(5);
        ARBENT XXXUFN(), TRAP'ENTRY ←6; SAVE'STATE(GSTATE); RTRAP(6);
        ARBENT XXXFXO(), TRAP'ENTRY ←7; SAVE'STATE(GSTATE); RTRAP(7);
        ARBENT XXXDIZ(), TRAP'ENTRY ←8; SAVE'STATE(GSTATE); RTRAP(8);

* STACK OVERFLOW - WATCH OUT
        ARBENT XXXSOV(), TRAP'ENTRY ←9; STKTRAP();

        END;

        PROGRAM PUNT; INCLUDE USERDECS,TRAP'DECS;
        INCLUDE SPTDECS;
*
* MAIN TRAP/PUNT PROCESSING ROUTINE
*
        INT N,P,Q,SR;
        INT LSPCS←5;
        LB R= L' [0];
        INTARY SPCA[LSPCS],STATE[LSTATE];
        PTR SA;* POINTER TO STATE[0]
        MACRO IS'TSB'INSTR(X)←((X) A' 07740000B=04600000B);
        OCTFL UTNO(0:0,5),SPCSLR(1:6,23);
        LB FIELD LBW0(0);

        MACRO SAVE'STATE(X)←BCOPY(SA←@STATE[0],@X[0],LSTATE) &
        (TRAP'PUNT() IF TRAP'FLAG#1);
        MACRO SPT'PUNT←SPTPUNT:ERCODE,ERMSNO;

*
* ENTRY FOR RING TRAPS
*
        ARBENT RTRAP(N);
        SAVE'STATE(GSTATE);
RTPUNT: RPUNTMSG(N,RTRAP'LOC); GOTO PUNTCOM;

*
* SPECIAL ENTRY FOR 'ABE' TRAP -
* CHECK IF REFERENCE IS FOLLOWED BY TSB OPCODE
*
        ARBENT ABE'TRAP();
        SAVE'STATE(GSTATE);
        INSTR'LOC←RTRAP'LOC+1;
        IF IS'TSB'INSTR($INSTR'LOC) DO;
            .LDX SA[XSTLOC],LDA SA[LSTLOC],XLA,STA SAVEL,EAC$INSTR'LOC;
            .LDA SAVEL,XLA,STX Q;
            R$BRDPC←Q;
            SA[PSTLOC]←@ABE'EXIT;
            R$BRDLR←SA[LSTLOC];
            SA[LSTLOC]←@R;
            TRAP'FLAG←0;
            .LDX SA,LOADS;
ABE'EXIT:   RETURN;
        ENDIF;
        N←1; GOTO RTPUNT;

*
* ENTRY FOR SP TRAPS
*
        ARBENT STRAP();
        SAVE'STATE(SP'GSTATE); ALLOW'INTS() IF (N←@R.SP'TNO)#23; Q←@R.SP'TPAR;
        READ'SPCS(0,SPCA//SPT'PUNT); R$BRDLR←SPCA[0]$SPCSLR;
        (@R)[-1]←P←(@R)[1];* SO UWSTK LABELS WILL WORK
        P←SPCA[0]$SPCSPR;
        GOTO SPTPUNT IF N#23;

* QUIT
QUIT:   QUIT'FLAG←1;
        TRAP'FLAG←0;
*!!!    QUIT'FCN() IF QUIT'FCN'FLAG;
        SA[LSTLOC]←@R-2;
        SET'SPT'FIELD(-1,'TM',READ'SPT'FIELD(-1,'TM'//SF'PUNT) V' 1
        //SF'PUNT);
        SA[PSTLOC]←@QUITX; .LDX SA,LOADS;
QUITX:  SP'RETURN(//SPT'PUNT);


* FREE STORAGE OVERFLOW
        ARBENT OFLOTRAP(ERCODE,ERMSNO);
        R←R$BRDLR.LBW0; N←24; GOTO RTF;

* UNEXPECTED RUNTIME FAILURE
        ARBENT RUNTIME'FAILURE(); N←25;
RTF:    P←R$BRDPC; Q←0;

SPTPUNT:SPUNTMSG(N,P,Q);
PUNTCOM:TRAP'FLAG←0;
        GOTO TRAP'LABEL;

* TRAP DURING STATE-SAVING
        ARBENT TRAP'PUNT();
        SPUNTMSG(26,R$BRDPC,0); GOTO PUNTCOM;

        END;

        PROGRAM STKOV'TRAP; INCLUDE USERDECS;
        INCLUDE TRAP'DECS;
*
* STACK OVERFLOW TRAP PROCESSING
*
        FIXED;
        INT R= L' [0];

        ARBENT STKTRAP();
        (@R).BRDLR←(@R).BRDLR.BRDLR WHILE STACK'LIM-(@R).BRDLR<100B;
        RPUNTMSG(9,RTRAP'LOC);
        TRAP'FLAG←0; GOTO TRAP'LABEL;

        END;

        PROGRAM UTRAP'MSG; INCLUDE USERDECS,MACHINE'DECS;
*
* PRINT USER TRAP MESSAGE
*?*  THIS ROUTINE SHOULD FRETURN, RATHER THAN PUNTING (COULD CAUSE
*?*       PUNT LOOP AND STACK OVERFLOW)
*
        ST MSG(60),CM; INT N,P,Q,T;
        CHRARY RN[10]←(6'RT0?',6'ABE',6'FLO',6'FLU',6'ROIA',
        6'IAT',6'UFN',6'FXO',6'DIZ',6'SOV');
        CHRARY SN[27]←(6'MACC',6'PRO',6'PNIM',6'PNIC',6'PI',
        6'TI',6'BLL',6'ILIM',6'PNOD',6'DWSO',6'CWSO',
        6'NEP',6'DMRD',6'NILE',6'SPCO',6'PMTO',6'DKSE',
        6'?17?',6'?18?',6'?19?',6'?20?',6'?21?',6'UTSE',
        6'QUIT',6'FSOV',6'PUNT',6'TRAP');

        ARBENT RPUNTMSG(N,P); N←-(N+1);
        ARBENT SPUNTMSG(N,P,Q);


        SETS(MSG,0,0); WCI(NLCH,MSG);
        APPEND(MSG,"USER TRAP '"//LF'PUNT);

COM:
        IF N=22 DO;* 'UTSE' ERROR
        APPEND(MSG,"UTSE - "//LF'PUNT);
            N←(Q$UTSE'SPTNO IF T←Q$UTSE'CLASS>1 ELSE
            6 IF T=1 ELSE -(Q$UTSE'RTNO+1));
        ENDIF;

        IF N=6 DO;* BLL ERROR
        PUNT'WWD(MSG,6'BLL-'); WCI(Q$BLL'CLASS V' '0',MSG);
        ELSE DO;
            PUNT'WWD(MSG,SN[N] IF N>=0 ELSE RN[-(N+1)]);
        ENDIF;
        APPEND(MSG,"' AT P: "//LF'PUNT);
        CNS(P,MSG,4B7,8//LF'PUNT); WCI('B',MSG);

        WCI(NLCH,MSG);
QT'P:   PRINT'STRING(-1,MSG,0//QUIT'PUNTX(QT'P,MSG));
        RETURN;

        END;

        PROGRAM PUNT'WWD; INCLUDE COMDECS;
*
* APPEND 4 CHARACTER NAME TO STRING
*
        PTR P; CHR M,C; ST S; STFL A(0); CHRFL CH60(0:0,5);

        ARBENT PUNT'WWD(STRING @P,M); S←P.A;

        (WCI(C,S) IF C#' ') & M←M LSH 6
        FOR C←M$CH60 WHILE M#6'    ';
        P.WP←S$WP; RETURN;

        END;

        PROGRAM VARIOUS; INCLUDE USERDECS;

*
* CLEAR CIOS NPUT/OUTPUT &
* TYPE NEWLINE
*

        ARBENT CLEAR'CIOS();
LP:     QUIT'FLAG←0;
        SET'CIOS'FIELD(-1,'OCC',0//SF'PUNT);
        SET'CIOS'FIELD(-1,'ICC',0//SF'PUNT);
        IOUT();
        PRINT'CHAR(-1,NLCH,QUIT'FLAG//QUIT'PUNT(LP));
        RETURN;

*
* REMOVE QUIT CALL FROM SPCS AND UNWIND STACK
* BY NON-LOCAL GOTO
*

        ARBENT ZAP(LABEL ZLAB);
        DELETE'CALL(//SF'PUNT);
        GOTO ZLAB;
        END;

        COMMON MYCALLS; INCLUDE USERDECS;
        DECLARE STRING ARRAY ENTRIES[8]←("LINK-TO","WHERE-IS","BROADCAST",
        "WHO-IS-ON","LINE","BREAK-LINKS","ALLOW-LINKS","REFUSE-LINKS");
        END;

        PROGRAM OUTPUT'FNS; INCLUDE MYCALLS;
        DECLARE CHARACTER C;
        DECLARE STRING S1,S2;
        DECLARE LABEL QL;

        ENTRY PRINT2(S1,S2,QL);
        PRINT'STRING(-1,S1,QUIT'FLAG//QUIT'PUNTX(QL,S1));
        PRINT'STRING(-1,S2,QUIT'FLAG//QUIT'PUNTX(QL,S2));
        RETURN;

        ENTRY END'LINE(S1,QL);
        PRINT'STRING(-1,S1,QUIT'FLAG//QUIT'PUNTX(QL,S1));
        PRINT'CHAR(-1,NLCH,QUIT'FLAG//QUIT'PUNTX(QL,C));
        RETURN;

        END;

        PROGRAM GET'TABLE; INCLUDE MYCALLS;
        DECLARE INTEGER I,PMTI,OFTI,LNO,KEY,USRR←0;
        DECLARE INTEGER ARRAY FN[LUFN];
        DECLARE POINTER PTR2;
        DECLARE STRING NAME←6"#1:X298-ACTUSR:BIN"; /* SECURITY PURPOSES */
        DECLARE INTEGER FIELD PAG'FL(0:6,12);

        ENTRY GET'TABLE(), FRETURN;
        KEY←READ'PROC'PARAM('IKY'//SF'PUNT);
        NAME'SEARCH(NAME,FN,1,'',KEY//ERROR:ERCODE,ERMSNO);
        MOPEN'FILE(-1,FN,0,KEY:OFTI//ERROR:ERCODE,ERMSNO);
        ACQUIRE'PMT(-1:PMTI//SF'PUNT);
        FOR I←1,I+1 WHILE READ'MAP'BYTE(-1,I//SF'PUNT)#0 DO;
        ENDFOR;
        SET'MAP'BYTE(-1,I,PMTI//SF'PUNT);
        MOVE'PAGE'PMT(OFTI,0,PMTI//SF'PUNT);
        LNO←READ'PROC'PARAM('TNO'//SF'PUNT);
        PTR2←I@PAG'FL+USRR;
        RETURN (OFTI,PMTI,PTR2,LNO,KEY);

ERROR:  FRETURN (ERCODE,ERMSNO);

        END;

        PROGRAM FIND; INCLUDE MYCALLS,MACHINE'DECS;
        DECLARE INTEGER FIELD UPUN(0:0,15);
        DECLARE FIELD LINE'FIELD(0:0,11),MIB'FIELD(0:12,23);
        DECLARE FIELD PROC(3:11,23);
        DECLARE STRING NAME,IN(72),OUT(72);
        DECLARE POINTER P,Q;
        DECLARE INTEGER I,J,K,KEY,TEST,UNO,LNO,USE'COUNT;
        DECLARE ARRAY TABLE[7];

        GOTO EXIT;                     /* HORRIBLE SPL KLUDGE */

        POINTER ENTRY FIND(NAME,Q,KEY,K), FRETURN;
        SETS(IN,0,0);
        IN←READ'UP'ITEM('UP',-1,0,NAME,"#",IN,KEY// VALUE
             (FRETURN (ERCODE,ERMSNO) IF ERCODE#'ENF' ELSE
             GOTO ILLEGAL):ERCODE,ERMSNO);
        UNO←SBASE(IN).UPUN;
        IF K=-1 DO;
           FOR I←0 TO MAX'PRT-1 DO;
              IF Q.MIB'FIELD=UNO DO;
                 READ'LINE'TABLE((LNO←Q.LINE'FIELD) LSH 1,TABLE//EXIT);
                 RETURN(LNO,UNO) IF TABLE[0]$PROC=I;
              ENDIF;
              Q←Q+4;
           ENDFOR;
ILLEGAL:   PRINT2(NAME," NOT ACTIVE.",EXIT);
EXIT:      END'LINE("",EXIT);
           RETURN (-1,UNO);
        ELSE DO;
           USE'COUNT←0;
           P←Q;
           FOR I←0 TO MAX'PRT-1 DO;
              USE'COUNT←USE'COUNT+1 IF P.MIB'FIELD=UNO;
              P←P+4;
           ENDFOR;
           IF USE'COUNT>0 DO;
              FOR LNO←0 TO MAX'TERMS-1 DO;
                 P←Q;
                 FOR I←0 TO MAX'PRT-1 DO;
                    IF P.MIB'FIELD=UNO AND P.LINE'FIELD=LNO DO;
                       READ'LINE'TABLE(LNO LSH 1,TABLE//EXIT);
                       IF TABLE[0]$PROC=I DO;
                          PRINT'LINE'NO(NAME,LNO,K:K);
                          GOTO EXIT IF (USE'COUNT←USE'COUNT-1)=0;
                       ENDIF;
                    ENDIF;
                    P←P+4;
                 ENDFOR;
              ENDFOR;
              P←Q;
              FOR I←0 TO MAX'PRT-1 DO;
                 IF P.MIB'FIELD=UNO DO;
                    READ'LINE'TABLE((LNO←P.LINE'FIELD) LSH 1,TABLE//EXIT);
                    IF TABLE[0]$PROC#I DO;
                       PRINT'DETACHED(NAME,I,K:K);
                       GOTO EXIT IF (USE'COUNT←USE'COUNT-1)=0;
                    ENDIF;
                 ENDIF;
                 P←P+4;
              ENDFOR;
              GOTO EXIT;
           ENDIF;
           GOTO ILLEGAL;
        ENDIF;



        END;

        PROGRAM AUX'PRNT'FCNS;
        INCLUDE MYCALLS,MACHINE'DECS;

        DECLARE STRING NAME,IN(72),OUT(72);
        DECLARE INTEGER LNO,PRNO,K;

        GOTO DONE;                     /* HORRIBLE SPL KLUDGE */

        FUNCTION PRINT'LINE'NO(NAME,LNO,K);
        IF K<1 DO;
           PRINT2(NAME," IS ON LINE",DONE);
           K←1;
        ENDIF;
        SETS(OUT,0,0);
        CNS(LNO,OUT,3,10//LF'PUNT);
        PRINT'STRING(-1,OUT,QUIT'FLAG//QUIT'PUNTX(DONE,OUT));
DONE:   RETURN K;

        FUNCTION PRINT'DETACHED(NAME,PRNO,K);
        K←1;
        SETS(OUT,0,0);
        SCOPY(OUT,"DETACHED, PROCESS #"//LF'PUNT);
        CNS(PRNO,OUT,0,10//LF'PUNT);
        PRINT'STRING(-1,OUT,QUIT'FLAG//QUIT'PUNTX(DONE,IN));
        GOTO DONE;


        END;

        PROGRAM SLEEP;

*   THIS FUNCTION WILL BLOCK FOR T CLOCK TIMES.

       INCLUDE USERDECS;


        DECLARE INTEGER
           STATUS'BITS,
           REAL'TIME'INT ← 2,
           JUST'WAKEUP ← 0;

        DECLARE LONG
           X,Y,
           TIME'TO'WAKEUP,
           DELAY'TIME,
           LZERO ← (0,0);

        DECLARE FIELD
           HIGH'WORD(0),
           LOW'WORD(1),
           SOURCE(0:0,2),
           ACTION(0:3,5),
           BLK(0:11,11);

        MACRO SETUP'SAB(S,A,B) ← S@SOURCE V' A@ACTION V' B@BLK;



        FUNCTION SLEEP(DELAY'TIME);

        TIME'TO'WAKEUP ← LONG'ADD(LONG(READ'CLOCK('RTC')),DELAY'TIME);
        SET'ICT(WAKEUP'TIMER,SETUP'SAB(REAL'TIME'INT,JUST'WAKEUP,1),
           THIS'SUB'PROCESS,TIME'TO'WAKEUP//NC'PUNT);
        BLOCK(4B7 RSH WAKEUP'TIMER//NC'PUNT);

        RETURN;



        END;

        PROGRAM LINK'UTILITIES; INCLUDE MYCALLS,MACHINE'DECS;

        DECLARE LONG PARAMETER WAIT'TIME←(0,1*1000*100); /* 1 SECOND */
        DECLARE INTEGER ARRAY TABLE[7];
        DECLARE LABEL ARRAY COM[8]←(LINK,WHER,BRCAST,WHO,MY'LINE,
        BREAK,ALLOW,REFUSE);
        DECLARE INTEGER FIELD LOK(3:8,8),LF(0:6,7),LQNK(2:11,23),
        UPUN(0:0,15);
        DECLARE FIELD PROC(3:11,23),LINE'FIELD(0:0,11),MIB'FIELD(0:12,23);
        DECLARE INTEGER RUMMY,I,J,K,UNO,LNO,CUNO,CLNO,KEY,PMTI,OFTI,BITS,
                        PRIVILEDGE;
        DECLARE LONG DUMMY;
        DECLARE STRING NAME,CMND,IN(72),LINE(80),CALLER(72),
                       SEND'PARAM(100),SEND'TO,MESSAGE(90),CSLIST(10),ACCESS;
        DECLARE POINTER P,PTR2;

        MACRO FR←ERROR:ERCODE,ERMSNO;
        MACRO ER←UNLOK:ERCODE,ERMSNO;

        UNKNOWN ENTRY MAIN();
        GET'COM'LINE(IN:IN//SF'PUNT);
        CUNO←READ'PROC'PARAM('UNO'//SF'PUNT);
        GOTO HOP;
        ENTRY TEST();
BACK:   SETS(IN,0,0);
        IN←READ'LINE(-1,IN,"IN?",QUIT'FLAG//QUIT'PUNTX(BACK,IN));
        CUNO←5;
HOP:    BITS←READ'SPT'FIELD(-1,'SB'//SF'PUNT);
        SET'SPT'FIELD(-1,'SB',BITS V' 2B7//SF'PUNT);
        SETS(LINE,0,0);
        SETS(CALLER,0,0);
        CMND←GET'PARAM(IN);
        NAME←GET'PARAM(IN);
        K←ABRV'LKP(CMND,ENTRIES//FR);
        GET'TABLE(:OFTI,PMTI,PTR2,CLNO,KEY//FR);
        GOTO COM[K];

RET:    RETURN;
UNLOK:  MON'UNLOCK(LINKING//EXIT:DUMMY);
EXIT:   DELETE'PMT(PMTI//SF'PUNT);
        MSET'OFT'CL(OFTI,0//EXIT1);
EXIT1:  END'LINE("",RET);
        SET'SPT'FIELD(-1,'SB',BITS//SF'PUNT);
        RETURN;

ERROR:  IN←ERRORMSG(ERMSNO,IN//ERROR2:ERCODE,ERMSNO);
        PRINT'STRING(-1,IN,QUIT'FLAG//QUIT'PUNTX(EXIT,IN));
        GOTO EXIT;
ERROR2: PRINT'STRING(-1,"ERROR2",QUIT'FLAG//QUIT'PUNTX(EXIT,IN));
        GOTO EXIT;

*  LINK-TO
*     TEST FOR PROMPT.

LINK:   IF LENGTH(NAME)=0 DO;
            NAME←READ'LINE(-1,IN,"LINE NUMBER OR USER NAME: ",
            QUIT'FLAG//QUIT'PUNTX(EXIT,IN));
            IF NAME="LINE NUMBER" OR NAME="USER NAME" DO;
                PRINT2("WHICH ",NAME,EXIT);
                NAME←READ'LINE(-1,IN,"? ",QUIT'FLAG//
                QUIT'PUNTX(EXIT,IN));
            ENDIF;
        ENDIF;
*   DETERMINE IF ARGUMENT IS LINE NUMBER OR NAME
        LNO←CSN(NAME,10//BY'NAME);
        NAME$RP←NAME$BP;
        READ'LINE'TABLE(2*LNO,TABLE//ER);
        IF (I←TABLE[0]$PROC)>1 DO; * LINE MUST NOT BELONG TO LISTENER */
           P←PTR2+4*I;
           GOTO CHECK IF P.LINE'FIELD=LNO;
        ENDIF;
        PRINT2("LINE ",NAME,UNLOK);
        END'LINE(" IS NOT ACTIVE.",UNLOK);
        GOTO EXIT;

BY'NAME:FIND(NAME,PTR2,KEY,-1:LNO,UNO//ER);
        GOTO EXIT IF LNO<0;

CHECK:  LNO ← LNO*2;   /* CONVERT TO LOGICAL TTY LINE NUMBER */
        GOTO SELF IF LNO=CLNO;
LINK1:  MON'LOCK(LINKING:RUMMY//LINK1X:DUMMY);
        READ'LINE'TABLE(LNO,TABLE//ER);
        GOTO REFUSED IF TABLE[0]$LOK#0;
        GOTO BUSY IF TABLE[0]$LF#0;
        READ'LINE'TABLE(CLNO,TABLE//ER);
        GOTO FUNNY IF TABLE[0]$LF#0;
        CALLER←READ'UP'ITEM('UP',-1,CUNO,IN,"N",CALLER,KEY//ER);
        SCOPY(LINE,"&G&G&G&G&G** LINK FROM "//LF'PUNT);
        APPEND(LINE,CALLER//LF'PUNT);
        APPEND(LINE,", LINE "//LF'PUNT);
        CNS(CLNO RSH 1,LINE,0,10//LF'PUNT);
        APPEND(LINE," **"//LF'PUNT);
        SET'LINE'FIELD(LNO,'LQN',CLNO+1//ER);
        SET'LINE'FIELD(CLNO,'LQN',LNO+1//ER);
        SET'LINE'FIELD(CLNO,'LF',1//ER);
        SET'LINE'FIELD(LNO,'LF',1//ER);
        WRITE'TTY(LNO,LINE//UNLOK);
        GOTO UNLOK;
LINK1X: SLEEP(WAIT'TIME) & GOTO LINK1;

REFUSED:PRINT2(NAME," REFUSING LINKS.",UNLOK);
        GOTO UNLOK;
BUSY:   PRINT2(NAME," IS LINKED WITH OTHER PARTY.",UNLOK);
        GOTO UNLOK;
FUNNY:  PRINT'STRING(-1,"SINGLE LINKS ONLY - DOUBLE LINK REQUEST REFUSED"
        ,QUIT'FLAG//QUIT'PUNTX(UNLOK,IN));
        GOTO UNLOK;
SELF:   PRINT'STRING(-1,"LINK TO SELF DISALLOWED",QUIT'FLAG//
        QUIT'PUNTX(UNLOK,IN));
        GOTO EXIT;

*  WHERE-IS

WHER:   IF LENGTH(NAME)=0 DO;
            NAME←READ'LINE(-1,IN,"USER NAME: ",QUIT'FLAG//
            QUIT'PUNTX(EXIT,IN));
        ENDIF;
        FIND(NAME,PTR2,KEY,0:I,J//FR);
        GOTO EXIT;

*  WHO-IS-ON

WHO:    END'LINE("LINE  NAME",EXIT);
        FOR LNO←0 TO MAX'TERMS-1 DO;
           READ'LINE'TABLE(LNO LSH 1,TABLE//ER);
           IF (I←TABLE[0]$PROC)>1 DO;
              P←PTR2+4*I;
              IF P.LINE'FIELD=LNO AND P.MIB'FIELD>1 DO;
                 SETS(LINE);
                 CNS(LNO,LINE,3,10//LF'PUNT);
                 APPEND(LINE,"*  "//LF'PUNT) IF CLNO RSH 1=LNO
                      ELSE APPEND(LINE,"   "//LF'PUNT);
                 LINE←READ'UP'ITEM('UP',-1,P.MIB'FIELD,NAME,"N",LINE,
                      KEY//FR);
                 END'LINE(LINE,EXIT);
              ENDIF;
           ENDIF;
        ENDFOR;
        FOR I ← 0 TO MAX'PRT-1 DO;
           IF PTR2.MIB'FIELD>1 DO;
              READ'LINE'TABLE((LNO←PTR2.LINE'FIELD) LSH 1,TABLE//EXIT);
              IF TABLE[0]$PROC # I DO;
                 SCOPY(LINE," DET  "//LF'PUNT);
                 LINE ← READ'UP'ITEM('UP',-1,PTR2.MIB'FIELD,NAME,"N",LINE,KEY//FR);
                 APPEND(LINE," (PROCESS #"//LF'PUNT);
                 CNS(I,LINE,0,10//LF'PUNT);
                 APPEND(LINE,")"//LF'PUNT);
                 END'LINE(LINE,EXIT);
              ENDIF;
           ENDIF;
           PTR2 ← PTR2+4;
        ENDFOR;
        GOTO EXIT;

*  LINE  (RETURN USER'S OWN LINE NUMBER)
MY'LINE:APPEND(LINE,"YOU ARE ON LINE"//LF'PUNT);
        CNS(CLNO RSH 1,LINE,3,10//LF'PUNT);
        PRINT'STRING(-1,LINE,QUIT'FLAG//QUIT'PUNTX(EXIT,LINE));
        GOTO EXIT;

*  BREAK-LINKS

BREAK:  READ'LINE'TABLE(CLNO,TABLE//FR);
        GOTO EXIT IF TABLE[0]$LF=0;
        LNO←TABLE[0]$LQNK;
        SET'LINE'FIELD(LNO,'LF',0//FR);
        SET'LINE'FIELD(CLNO,'LF',0//FR);
        GOTO EXIT;

*  ALLOW-LINKS

ALLOW:  SET'LINE'FIELD(CLNO,'LOK',0//FR);
        GOTO EXIT;

*  REFUSE LINKS

REFUSE: SET'LINE'FIELD(CLNO,'LOK',1//FR);
        GOTO EXIT;


*  BROADCAST

       /* THIS FUNCTION SENDS TO THE SPECIFIED ACTIVE USERS A ONE     */
       /* LINE MESSAGE, ONLY IF IT HAS SYSTEM PRIVILEDGES.            */

       /* DETERMINE IF THE USER HAS SYSTEM PRIVILIDGES BY LOOKING AT  */
       /* HIS COMMAND SEARCH LIST, MAKING SURE ITS A 2, NOT 3 OR 4.   */
BRCAST:READ'UP'ITEM('UP',-1,CUNO,CALLER,"CSL",CSLIST,0:CSLIST//DETRMIN
                    :ERCODE,ERMSNO);
       ACCESS ← GET'PARAM(CSLIST);
       ACCESS ← GET'PARAM(CSLIST);
DETRMIN:PRIVILEDGE←1 IF (CUNO=1 OR COMPARE'STRING(ACCESS,"2"//LF'PUNT))
                     ELSE PRIVILEDGE←0;

       IF NOT PRIVILEDGE DO;
           END'LINE("SORRY, YOU CAN'T DO THAT!",EXIT);
           GOTO EXIT;
       ENDIF;
       IF LENGTH(NAME)=0 DO;
           SCOPY(SEND'PARAM,"*"//LF'PUNT); /* EMPTY MEANS SEND TO ALL */
       ELSE DO;
           SETR(IN,LENGTH(CMND)+1);
           SCOPY(SEND'PARAM,IN//LF'PUNT);
       ENDIF;

PROMPT:LINE ← READ'LINE(-1,LINE,"MESSAGE: ",QUIT'FLAG//
           QUIT'PUNTX(EXIT,LINE));
       /* CHECK TO BE SURE IT'S A VALID LENGTH OF CHARACTERS          */
       IF LENGTH(LINE) > 65 DO;
           END'LINE("** LENGTH > 65 CHARACTERS. RETYPE. **", EXIT);
           GOTO PROMPT;
       ENDIF;
       RETURN IF LENGTH(LINE) = 0;

       /* CONSTRUCT MESSAGE */
       SCOPY(MESSAGE,"** SYSTEM: "//LF'PUNT);
       APPEND(MESSAGE,LINE//LF'PUNT);
       APPEND(MESSAGE," **"//LF'PUNT);

BEGIN'SEND:SEND'TO ← GET'PARAM(SEND'PARAM);

       IF COMPARE'STRING(SEND'TO,"*"//LF'PUNT) DO;
           SETS(SEND'PARAM);     /* REPLACE WITH ACTUAL LINE NUMBERS  */
           P←PTR2;
           FOR I←0 TO MAX'PRT-1 DO;
              IF P.MIB'FIELD>1 DO;
                 READ'LINE'TABLE((LNO←P.LINE'FIELD) LSH 1,TABLE//ER);
                 CNS(LNO,SEND'PARAM,3,10//LF'PUNT) IF TABLE[0]$PROC=I;
              ENDIF;
              P←P+4;
           ENDFOR;
           GOTO BEGIN'SEND;
       ENDIF;

       WHILE LENGTH(SEND'TO) DO;
           LNO ← CSN(SEND'TO,10//NAME'TRY);
           GOTO XXX;

NAME'TRY:  FIND(SEND'TO, PTR2, KEY, -1:LNO, UNO//ER);
XXX:       READ'LINE'TABLE(LNO LSH 1,TABLE//ER);
           GOTO MORE IF TABLE[0]$PROC<2;
           LNO ← LNO*2;      /* CONVERT TO LOGICAL TTY LINE NUMBER    */
           GOTO MORE IF LNO=CLNO; /* DON'T WANT TO SEND TO YOURSELF!  */

           /* RECEIVER VALIDITY ESTABLISHED. COMMENCE SENDING.        */
           WRITE'TTY(LNO, MESSAGE//LF'PUNT);

MORE:      SEND'TO ← GET'PARAM(SEND'PARAM);

       ENDFOR;
       GOTO EXIT;


       END;

PROGRAM WRITE'TTY;

       /* WRITES A STRING TO A PARTICULAR TERMINAL SPECIFIED BY       */
       /* LINE'NUMBER.                                                */

       INCLUDE SYS'COMMON;

       DECLARE INTEGER
           LINE'NUMBER,        /* TTY LNO STRING WILL BE WRITTEN ON   */
           CHAR,               /* TEMPORARY CHARACTER STORAGE         */
           I,                  /* COUNTER                             */
           NCHRS,              /* NO. OF CHARACTERS YET TO BE OUTPUT  */
           BELL ← 207B,        /* ASCII BELL CHARACTER                */
           CR ← 215B,          /* ASCII CARRIAGE RETURN               */
           LF ← 212B;          /* ASCII LINE FEED                     */

       DECLARE STRING
           ST,
           TEMP'ST(300);

FUNCTION WRITE'TTY(LINE'NUMBER, ST), FRETURN;

       LINE'NUMBER ← LINE'NUMBER+1;    /* SET IT TO OUTPUT BUFFER     */
       SETS(TEMP'ST);

       SCOPY(TEMP'ST,"&215&212&212"//FAILED);
       FOR I←1 TO 6 DO;
           WCI(BELL, TEMP'ST//FAILED);
       ENDFOR;

       WHILE LENGTH (ST) # 0 DO;
           CHAR ← GCI(ST)+40B;         /* ADD OFFSET TO CONVERT FROM  */
           WCI(CHAR, TEMP'ST//FAILED); /* 940 TO ASCII                */
       ENDFOR;

       WCI(CR, TEMP'ST//FAILED);
       WCI(LF, TEMP'ST//FAILED);
       WCI(LF, TEMP'ST//FAILED);

       WHILE LENGTH(TEMP'ST) DO;
           WRITE'STRING(LINE'NUMBER,-1,TEMP'ST:TEMP'ST,NCHRS//FAILED
               :ERCODE, ERMSNO);
       ENDFOR;

       RETURN;

FAILED:FRETURN;

END;

        PROGRAM RUN'USER; INCLUDE USERDECS, COMDECS;
        DECLARE INTEGER I;
        ENTRY RUN'USER();
BEGIN:
        WAKEUP'TIMER←ACQUIRE'ICT(-1//NC'PUNT);
        THIS'SUB'PROCESS←READ'SPS'PARAM('CSP'//SF'PUNT);
        MAIN();
        SP'RETURN(//SF'PUNT);
        END;
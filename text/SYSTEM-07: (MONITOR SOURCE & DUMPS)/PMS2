        PROGRAM ACQPMT;
          INCLUDE PROFILE, SPTD, PMTD, GLOBAL, PMS'MACROS;

*  ACQUIRE AND INITIALIZE A PMT ENTRY.  ENTER WITH PMTX = -1 OR 
*     SOME VALUE INDEXING PMT.  IF -1, GETS "NEXT" FREE ENTRY (ONE
*     WHOSE CL=0.  IF THERE IS NONE, IT "FREES" ONE.)  IF # -1,
*     IT STILL REQUIRES THAT THE ENTRY BE FREE.  THE ENTRY IS ZEROED
*     AND AL AND CL ARE SET TO THE NAME OF THE CALLING SUB-PROCESS,
*     PMTX IS RETURNED.

          DECLARE NAME, PMTE, MEC, MEM;

        ENTRY ACQPMT(PMTX), FRETURN, MONITOR ← 50;
          NAME ← SPNAME;

        ENTRY MACQPMT(PMTX, NAME), FRETURN;

          IF PMTX=-1 DO;
             FOR PMTX←PMT'PTR TO NPMTE DO;
FIND'FREE'PMT:  (PMT'PTR←PMTX+1 & GOTO SET'PMTE) IF PMT[PMTX]$PMTCL=0;
             ENDFOR;
             (PMTX←PMT'PTR←1 & GOTO FIND'FREE'PMT) IF PMT'PTR#1;
             PMTX←FREE'PMT(//FRETURN(MEC,MEM): MEC,MEM);
SET'PMTE:    PMTE←@PMT[PMTX];
          ELSE DO;
             GET'PMT'POINTER;
             FRETURN('PMA',119) IF PMTE.PMTCL#0;
          ENDIF;
*  INITIALIZE THE PMT ENTRY
          PMT[PMTX]←LONGLONG'ZERO;
          PMTE.PMTAL←PMTE.PMTCL←NAME;

          RETURN PMTX;

PMTX'ILLEGAL:
*  CONTROL COMES HERE IF CALLER PASSES OUT-OF-BOUNDS PMT INDEX
          FRETURN('PMI',110);

        END;

        PROGRAM NPPMT;
          INCLUDE PROFILE, PMTD, SPTD, SWPD, RESMON, GLOBAL, APTD;
          INCLUDE PMS'MACROS;

*  CREATE A PRIVATE MEMORY PAGE AND PUT ITS REAL NAME INTO PMT.
*     ENTER WITH PMTX.  A PRIVATE MEMORY PAGE IS CREATED AND ITS
*     UNIQUE NAME AND DISK ADDRESS ARE PUT INTO THE APPROPRIATE
*     FIELDS OF THE PMT ENTRY.  THE PAGE IS PUT INTO THE CORE AND DRUM
*     WORKING SETS OF THE PROCESS.  THE SF BIT AND PMTDWS BITS ARE SET
*     AND THE OTHER STATUS BITS OF THE ENTRY ARE CLEARED.

          DECLARE KEY, STATUS, MEC, MEM, PMTE, APTE, TEMP, APTX;

        FUNCTION NPPMT(PMTX), FRETURN, MONITOR ← 51;
          KEY ← SPKEY; STATUS ← SPSTATUS;

*  ENTRY POINT FOR MONITOR
        ENTRY MNPPMT(PMTX, KEY, STATUS), FRETURN;

*  CHECK FOR ERRORS
          GET'PMT'POINTER;
          FRETURN('PMC',121) IF (KEY A' PMTE.PMTCL)=0;* MUST HAVE CONTROL
          FRETURN('PMF',122) UNLESS PMTE.PMTDKA=0;* ENTRY MUST BE CLEAR
          FRETURN('DWF',123) IF (DWS'FULL AND STATUS$DDWSO=0);
          FRETURN('CWF',124) IF (CWS'FULL AND STATUS$DCWSO=0);
*!!       FRETURN('KSE',125) IF RSE[0]$DKSP=0;

*  SET-UP PMT[PMTX]
*  LEAVE OUT DKA FOR THE MOMENT SO THAT PUT'IN'CWS DOESN'T DO A KDT.
          TEMP←PMTE.WD3;               /* PRESERVE AL AND CL */
          PMT[PMTX] ← LONGLONG'ZERO;
          PMTE.PMTUN ← PMT[1]$PMTUN;* USE CB'S UNIQUE NAME
          PMTE.PMTINDEX ← PMTX;* WITH PMT INDEX OVERWRITTEN
          PMTE.WD3 ← TEMP A' (1@PMTDWS V' (-1)@PMTAL V' (-1)@PMTCL);

*  PUT PAGE IN APT WITH 'NEW-PAGE' BIT SET AND
*  SEND REQUEST FOR NEW PAGE TO AMC.  THIS CAN FAIL ONLY IF THE REAL
*  NAME WE JUST CREATED ALBEADY EXISTS.

          APTX ← PUT'IN'CWS(PMTX,0,0//FRETURN(MEC,MEM): MEC,MEM);
          APT[APTX]$APTNPG ← 1;
          PMTE.PMTDKA ← GET'DISK'ADDR(PMT[1]$PMTDKA//NP81);
          AMC'REQUEST(CRGFP,PMTX,PRTI,0//VALUE PUNT(MEC):MEC,MEM);

*  IF THE AMC WAS ABLE TO ASSIGN A FREE CORE PAGE FOR OUR NEW PAGE,
*  WE HAVE NOW TO ZERO THE PAGE, SET SF, AND RESET NPG.  IF THERE WAS NO
*  FREE CORE, AMC'REQUEST WILL HAVE BLOCKED AND THE AMC WILL HAVE ATTEMPTED
*  TO CREATE OUR PAGE AS IT SWAPPED OUR PROCESS BACK IN.  IF THIS 
*  SUCCEEDED, WE WILL HAVE SF SET, NPG RESET, AND THE PAGE WILL BE
*  ZEROED.  IF IT FAILED WE WILL HAVE SF RESET, NPG SET, AND SOME
*  ERROR INDICATION.
          RETURN IF PMTE.PMTSF;
          PUNT('NPG') IF (NOT PMTE.PMTDWS OR PMTE.PMTERR);
          PMTE.PMTSF ← 1;
          APT[APTX]$APTNPG ← 0;
          SETPRMB(NEW'PAGE'BYTE,PMTX);
          BSET(PAGESA(NEW'PAGE'BYTE), 0, 2048);
          RETURN;

*  ERROR RETURN FROM DISK ALLOCATOR
NP81:     PUNT('KAL');

PMTX'ILLEGAL:
*  CONTROL COMES HERE IF CALLER PASSES OUT-OF-BOUNDS PMT INDEX
          FRETURN('PMI',110);

        END;

        PROGRAM RNPMT;
          INCLUDE SPTD, GLOBAL, PMTD, PROFILE, PMS'MACROS;

*  PUT SPECIFIED REAL NAME INTO DESIGNATED PMT ENTRY.  THE UNIQUE NAME,
*     AND DISK ADDRESS SUPPLIED ARE SIMPLY COPIED INTO THE APPROPRIATE
*     FIELDS OF THE DESIGNATED PMT ENTRY.  THE FP BIT IS SET AND THE
*     OTHER STATUS BITS ARE CLEARED.

          DECLARE PMTE, TEMP;

        FUNCTION RNPMT(PMTX,LONG UNQN, INTEGER DKA), FRETURN,
                                                MONITOR ← 52;
*  CHECK FOR ERRORS
          FRETURN('STS',127) UNLESS SPSTATUS$SD;
          GET'PMT'POINTER;
          FRETURN('PMC',121) IF (SPKEY A' PMTE.PMTCL) = 0;
          FRETURN('PMF',122) IF PMTE.PMTDKA#0;
          FRETURN('ARG',999) IF DKA=0;

*  PUT REAL NAME INTO PMT[PMTX]
          TEMP ← PMTE.WD3;
          PMT[PMTX] ← LONGLONG'ZERO;
          PMTE.PMTUN←UNQN;
          PMTE.PMTDKA←DKA;
          PMTE.WD3 ← TEMP A' ((-1)@PMTAL V' (-1)@PMTCL);
          PMTE.PMTFP←1;*  TREAT LIKE FILE PAGE
*
          RETURN;

PMTX'ILLEGAL:
*  CONTROL COMES HERE IF CALLER PASSES OUT-OF-BOUNDS PMT INDEX
          FRETURN('PMI',110);

        END;

        PROGRAM CLRPMT;
          INCLUDE PROFILE,SPTD,PMTD,GLOBAL,PMS'MACROS,SWPD,RESMON;

*  CLEAR PMT ENTRY AND RELEASE ITS PAGE.  THE PAGE WHOSE REAL NAME
*     APPEARS IN THE DESIGNATED PMT ENTRY IS RELEASED FROM THE CORE
*     AND DRUM WORKING SETS OF THE PROCESS.  THE PAGE IS DESTROYED
*     IF IT IS PRIVATE MEMORY.  THE PMT ENTRY IS CLEARED.  AL AND CL
*     ARE PRESERVED.

          DECLARE KEY, MEC, MEM, PMTE, TEMP;

        FUNCTION CLRPMT(PMTX), FRETURN, MONITOR ← 53;
          KEY ← SPKEY;

*  ENTRY POINT FOR MONITOR
        ENTRY MCLRPMT(PMTX, KEY), FRETURN;

*  CHECK FOR ERRORS
          GET'PMT'POINTER;
          FRETURN('PMC',121) IF KEY A' PMTE.PMTCL=0;

*  RELEASE PAGE FROM DWS, AND DESTROY IT IF IT IS PRIVATE MEMORY.

*** NOTE: THERE IS REAL INEFFICIENCY HERE IF PAGE DOES GET DESTROYED

          RELEASE'THIS'DWS(PMTX//FRETURN(MEC,MEM): MEC,MEM);
          PMTE.PMTDWS ← 0;
          IF (PMTE.PMTDKA#0 AND PMTE.PMTFP=0) DO;
             AMC'REQ'WITH'RN(CRDEST,PMTE.PMTUN,PMTE.PMTDKA,@PRT[PRTI],1//
                  VALUE PUNT(MEC): MEC, MEM);
             REL'DISK'ADDR(PMTE.PMTDKA// VALUE PUNT('KBT'));
          ENDIF;

*  CLEAR PMT[PMTX] EXCEPT FOR CL AND AL AND
*  CLEAR PHYSICAL MAP IF REFERENCE FLAG IS SET.
          IF PMTE.PMTRF DO;
             CLEAR'MAP;
          ENDIF;
          TEMP ← PMTE.WD3;
          PMT[PMTX] ← LONGLONG'ZERO;
          PMTE.WD3 ← TEMP A' ((-1)@PMTAL V' (-1)@PMTCL);
          RETURN;

PMTX'ILLEGAL:
*  CONTROL COMES HERE IF CALLER PASSES OUT-OF-BOUNDS PMT INDEX
          FRETURN('PMI',110);

        END;

        PROGRAM DELPMT;
          INCLUDE PROFILE, SPTD, PMTD, GLOBAL, PMS'MACROS;

*  RELEASE PMT ENTRY.  DOES A CLRPMT BUT LEAVES AL AND CL CLEARED AS WELL.
*     ALL POINTERS TO THE DESIGNATED PMT ENTRY FROM VARIOUS MAPS ARE
*     DELETED AT THIS TIME.

          DECLARE KEY, I, LMAP, J;
          DECLARE MEC, MEM, LM, SPTE, PRME, PMTE;
          DECLARE FIXED FIELD B0'11(0:0,11), B12'23(0:12,23),
             BYTE0(0:4,11), BYTE1(0:16,23);

        FUNCTION DELPMT(PMTX), FRETURN, MONITOR ← 54;
          KEY ← SPKEY;

*  ENTRY POINT FOR MONITOR
        ENTRY MDELPMT(PMTX, KEY), FRETURN;

*  CHECK FOR ERRORS
          GET'PMT'POINTER;
          FRETURN('PMC',121) IF KEY A' PMTE.PMTCL=0;

*  FIRST CLEAR PMT[PMTX]
          MCLRPMT(PMTX, KEY//VALUE PUNT(MEC):MEC,MEM);

*  PMTX MUST NOW BE REMOVED FROM ALL MAPS, DAMMIT.
*  THE PROCESS MAP:
          FOR I ← 0 TO 63 DO;
             IF (PRME ← PRMAP[I]) # 0 DO;
                PRMAP[I]$B0'11 ← 0 IF PRME$BYTE0=PMTX;
                PRMAP[I]$B12'23 ← 0 IF PRME$BYTE1=PMTX;
             ENDIF;
          ENDFOR;
*  THE SUB-PROCESS MAPS:
          FOR I ← 1 TO NSPTE DO;
             IF SPT[I]$SPTOL#0 DO;
                SPTE ← @SPT[I];
                LMAP ← SPTE.SPTLM;
                LM ← 0;
                FOR J ← 0 TO LMAP DO;
                   IF SPTE.(PXFLDS[J])=PMTX DO;
                      SPTE.(PXFLDS[J]) ← 0;
                      SPTE.(ROFLDS[J]) ← 0;
                   ENDIF;
                   LM ← J IF SPTE.(PXFLDS[J])#0;
                ENDFOR;
                SPTE.SPTLM ← LM;
             ENDIF;
          ENDFOR;

*  FINALLY, FREE PMT[PMTX].
          PMTE.WD3 ← 0;
          RETURN;

PMTX'ILLEGAL:
*  CONTROL COMES HERE IF CALLER PASSES OUT-OF-BOUNDS PMT INDEX
          FRETURN('PMI',110);

        END;

        PROGRAM SET'PMT'FIELDS;
          INCLUDE PROFILE, SPTD, PMTD, GLOBAL, PMS'MACROS;

*  SET AL, CL, OR RO FIELDS OF A PMT ENTRY.  IF CL = 0, THE PMT ENTRY
*     IS RELEASED WITH DELPMT.

          DECLARE KEY, MEC, MEM, PMTE;

        ENTRY SPMTAL(PMTX,AL), FRETURN, MONITOR ← 55;
          KEY ← SPKEY;
*  ENTRY POINT FOR MONITOR
        ENTRY MSPMTAL(PMTX, AL, KEY), FRETURN;
*  CHECK FOR ERRORS
          GET'PMT'POINTER;
          FRETURN('PMC',121) UNLESS
             (KEY A' PMTE.PMTCL#0 OR
             (KEY A' PMTE.PMTAL#0 AND
                (PMTE.PMTAL A' N' AL) A' N' KEY=0));
          PMTE.PMTAL←AL;
          RETURN;

        ENTRY SPMTCL(PMTX, CL), FRETURN, MONITOR ← 56;
          KEY ← SPKEY;
*  ENTRY POINT FOR MONITOR
        ENTRY MSPMTCL(PMTX, CL, KEY), FRETURN;
*  CHECK FOR ERRORS
          GET'PMT'POINTER;
          FRETURN('PMC',121) IF KEY A' PMTE.PMTCL = 0;
*  RELEASE PMT[PMTX] IF CL GOES TO 0.
          MDELPMT(PMTX,KEY//VALUE PUNT(MEC):MEC,MEM) IF CL=0
               ELSE PMTE.PMTCL←CL;
          RETURN;

        ENTRY SPMTRO(PMTX,RO), FRETURN, MONITOR ← 57;
*  CHECK FOR ERRORS
          GET'PMT'POINTER;
          FRETURN('PMC',121) IF SPKEY A' PMTE.PMTCL = 0;
          RETURN IF PMTE.PMTRO=RO;
          FRETURN('FPR',135) IF (PMTE.PMTRO=1 AND PMTE.PMTFP=1);
*  SET/RESET THE BIT AND CLEAR THE PHYSICAL MAP IF NECESSARY
          PMTE.PMTRO←RO;
          IF PMTE.PMTRF DO;
             CLEAR'MAP;
          ENDIF;
          RETURN;

PMTX'ILLEGAL:
*  CONTROL COMES HERE IF CALLER PASSES OUT-OF-BOUNDS PMT INDEX
          FRETURN('PMI',110);

        END;

        PROGRAM READPMT;
          INCLUDE GLOBAL, PMTD, APTD, PROFILE, PMS'MACROS;

*  READ A DESIGNATED PMT ENTRY.  FIVE WORDS ARE COPIED INTO THE CALLER'S
*     ARRAY.  THE FIRST FOUR ARE THE FOUR WORDS OF THE PMT ENTRY.
*     THE FIFTH IS THE APT ENTRY WHICH POINTS THE PMT ENTRY OR ZERO IF
*     THERE IS NONE SUCH IN APT.

          DECLARE I, PMTE;

        FUNCTION READPMT(PMTX, ARRAY PMT'ARRAY), FRETURN, MONITOR ← 58;

*  CHECK FOR ERRORS
          GET'PMT'POINTER;
          PMT'ARRAY[I] ← PMTE[I] FOR I ← 0 TO LPMTE-1;
          PMT'ARRAY[LPMTE] ← GET'APT'ENTRY(PMTX:I);
          RETURN;

        FUNCTION READ'APT(APTX), FRETURN, MONITOR ← 72;
          FRETURN('API',164) UNLESS (1<=APTX AND APTX<=NAPTE);
          RETURN APT[NAPTE-APTX+1];

PMTX'ILLEGAL:
*  CONTROL COMES HERE IF CALLER PASSES OUT-OF-BOUNDS PMT INDEX
          FRETURN('PMI',110);

        END;

        PROGRAM AGE'APS;
*
*  MAINTAIN USE HISTORIES FOR ACTIVE PAGES
*
          INCLUDE APTD, PROFILE, PMTD, GLOBAL, PMS'MACROS;
          DECLARE I;

        ENTRY AGE'CWS();
          FOR I ← APTL-1 BY -1 TO LAST'CWS DO;
*
*  THE CODE HERE IS THE SAME AS:
*            APT[I]$APTUH←((PMT[APT[I]$APTPMT]$PMTRF LSH LAPTUH)
*              V' APT[I]$APTUH) RSH 1;
*            PMT[APT[I]$APTPMT]$PMTRF←0;
*  I.E., RIGHT SHIFT THE USE HISTORY FIELD BY 1, DRAGGING IN FROM
*     THE LEFT A 1 IF THE REFERENCED FLAG IS SET FOR THE GIVEN PAGE,
*     ELSE 0.  
             .EAX APT[I], LDX $G'[4103B], EAX $(PMT$WD0), LDA 0,
             .XMA $G'[4100B], LSHA LAPTUH, EAX APT[I],
             .IOR $G'[4101B], LSHA -1, STA $G'[4101B];
          ENDFOR;
          CLEAR'MAP;
          RETURN;

        ENTRY AGE'DWS();
          FOR I ← LAST'CWS-1 BY -1 TO LAST'DWS DO;
*  THE CODE HERE IS THE SAME AS:
*            APT[I]$APTUH←APT[I]$APTUH RSH 1;
*  I.E., RIGHT SHIFT THE USE HISTORY FIELD BY 1, DRAGGING IN A ZERO
*     FROM THE LEFT.
             .EAX APT[I], .LDA $G'[4101B], LSHA -1, STA $G'[4101B];
          ENDFOR;
          RETURN;

        END;

        PROGRAM FIND'APT'ENTRY;
          INCLUDE APTD, PROFILE, PMTD, GLOBAL, PMS'MACROS;
          DECLARE I, OLDEST, USE;

        ENTRY FIND'OLDEST'CWS(), FRETURN;
          FRETURN IF LCWS<=0;
LOOK'THROUGH'CWS:
          USE ← 4B7-1;* MAKES USE IMPOSSIBLY YOUNG
*  THE FOLLOWING LOOP COMPARES EACH CWS ENTRY WITH USE, LEAVING THE
*    "OLDEST" IN USE AND ITS INDEX IN I.  REMEMBER THAT THE 1'S
*    REPRESENT REFERENCED INDICATIONS.  HENCE, IT IS THE 0'S THAT
*    STAND FOR OLD AGE.  THE LOOP LOOKS FOR THE NUMERICALLY SMALLEST
*    VALUE OF PGL*2↑17+LOCK*2↑16+UH*2↑8+RF*2↑8+UH*2↑(-1).
          FOR I ← APTL-1 BY -1 TO LAST'CWS DO;
             .EAX APT[I], LDX $G'[4103B], EAX $(PMT$WD0),
             .LDA $G'[4100B], LSHA LAPTUH, EAX APT[I],
             .IOR $G'[4101B], LSHD -(LAPTUH+1), IOR $G'[4102B];
             .LSHD LAPTUH, ICP USE, BGE R'[4], STA USE, LDA I, STA OLDEST;
          ENDFOR;
          RETURN(OLDEST, APT[OLDEST]);

        ENTRY FIND'OLDEST'DWS(), FRETURN;
          FRETURN IF LDWS<=0;
          GOTO LOOK'THROUGH'CWS IF LDWS<=LCWS;
          USE ← 4B7-1;
*  THIS LOOP BEHAVES AS THE ONE ABOVE, EXCEPT THAT JUST THE USE
*    HISTORY FIELDS ARE COMPARED AS THEY CURRENTLY ARE.
          FOR I ← LAST'CWS-1 BY -1 TO LAST'DWS DO;
             .EAX APT[I], LDA $G'[4101B], ICP USE, BGE R'[4];
             .STA USE, LDA I, STA OLDEST;
          ENDFOR;
          RETURN(OLDEST, APT[OLDEST]);

        ENTRY GET'APT'ENTRY(PMTX);
          FOR I ← APTL-1 BY -1 TO LAST'DWS DO;
             (RETURN(APT[I], I)) IF APT[I]$APTPMT=PMTX;
          ENDFOR;
          RETURN(0,0);

        END;

        PROGRAM CHANGE'WS;
          INCLUDE PROFILE, GLOBAL, PMTD, APTD, SPTD, PMS'MACROS;

*  INSERT OR REMOVE DESIGNATED PMT ENTRY INTO/FROM WORKING SETS.
*     NO ACTION OCCURS IF ENTRY IS ALREADY IN WORKING SET.  IF WORKING
*     SET IS FULL, ANOTHER PAGE IS DELETED TO MAKE ROOM FOR IT.
*     AN ENTRY PLACED INTO CWS WILL NOT NECESSARILY CAUSE AN IMMEDIATE
*     XFER INTO CORE, I.E., A PAGE FAULT MAY OCCUR FIRST.
*     IT IS POSSIBLE TO SUPPLY -1 AS THE PMT ENTRY NUMBER, IN WHICH
*     CASE, A "CONVENIENT" ENTRY WILL BE DELETED FROM THE WORKING SET.

          DECLARE APTX, APTE, MEC, MEM, PMTE;

        ENTRY PPDWS(PMTX), FRETURN, MONITOR ← 65;
          GET'PMT'POINTER;
          GET'APT'ENTRY(PMTX: APTE,APTX);
          RETURN IF IN'DWS;
          FRETURN('DWF',133) IF (DWS'FULL AND SPSTATUS$DDWSO=0);
          PUT'IN'DWS(PMTX//FRETURN(MEC,MEM): MEC,MEM);
          RETURN;

        ENTRY PPCWS(PMTX), FRETURN, MONITOR ← 66;
          GET'PMT'POINTER;
          GET'APT'ENTRY(PMTX: APTE,APTX);
          RETURN IF IN'CWS;
          IF NOT IN'DWS DO;
             FRETURN('NOD', 208) IF SPSTATUS$DPNOD=0;
             FRETURN('DWF',133) IF (DWS'FULL AND SPSTATUS$DDWSO=0);
          ENDIF;
          FRETURN ('CWF',132) IF SPSTATUS$DCWSO=0;
          PUT'IN'CWS(PMTX,APTX,APTE//FRETURN(MEC,MEM): MEC,MEM);
          RETURN;

        ENTRY DPDWS(PMTX), FRETURN, MONITOR ← 67;
          IF PMTX # -1 DO;
             GET'PMT'POINTER;
             PMTX ← RELEASE'THIS'DWS(PMTX//FRETURN(MEC,MEM): MEC,MEM);
          ELSE DO;
             PMTX ← RELEASE'SOME'DWS(//FRETURN(MEC,MEM): MEC,MEM);
          ENDIF;
          RETURN PMTX;

        ENTRY DPCWS(PMTX), FRETURN, MONITOR ← 68;
          IF PMTX # -1 DO;
             GET'PMT'POINTER;
             PMTX ← RELEASE'THIS'CWS(PMTX//FRETURN(MEC,MEM): MEC,MEM);
          ELSE DO;
             PMTX ← RELEASE'SOME'CWS(//FRETURN(MEC,MEM): MEC,MEM);
          ENDIF;
          RETURN PMTX;

PMTX'ILLEGAL:
*  CONTROL COMES HERE IF CALLER PASSES OUT-OF-BOUNDS PMT INDEX
          FRETURN('PMI',110);

        END;

        PROGRAM READ'LWS;
          INCLUDE PROFILE, GLOBAL, APTD;

*  READ OR SET CURRENT VALUES OF WORKING SET SIZES, INCLUDING THEIR
*     OVERFLOW SIZES.  SEE BELOW FOR THE RULES FOR SETTING SIZES.

          DECLARE NCODES ← 6;
          DECLARE CHARACTER ARRAY CODES[NCODES] ←
             ('CWS', 'OCW', 'MCW', 'DWS', 'ODW', 'MDW');
          DECLARE POINTER ARRAY PTRS[NCODES] ←
             (@LCWS, @OLCWS, @MLCWS, @LDWS, @OLDWS, @MLDWS);
          DECLARE LABEL ARRAY ACTION[NCODES] ←
             (SET'LCWS,SET'OLCWS,SET'MLCWS,SET'LDWS,SET'OLDWS,SET'MLDWS);
          DECLARE I, LWS, MEC, MEM;
          DECLARE DAMMIT;

        ENTRY READ'LWS(CODE), FRETURN, MONITOR ← 70;
          GOTO RETURN'LENGTH IF (0<=CODE AND CODE<=NCODES-1);
          FOR I ← 0 TO NCODES-1 DO;
             (CODE←I & GOTO RETURN'LENGTH) IF CODES[I]=CODE;
          ENDFOR;
          FRETURN('ARG', 191);
RETURN'LENGTH:
          LWS ← $PTRS[CODE];
          RETURN LWS;

        ENTRY SET'LWS(CODE, LNGTH), FRETURN, MONITOR ← 71;
          GOTO ACTION[CODE] IF (0<=CODE AND CODE<=NCODES-1);
          FOR I ← 0 TO NCODES-1 DO;
             (CODE←I & GOTO ACTION[I]) IF CODES[I]=CODE;
          ENDFOR;
          FRETURN('ARG', 191);
SET'LCWS:
*  LCWS CANNOT BE MADE LESS THAN 0 OR GREATER THAN ITS CURRENT VALUE.
*  DECREASING IT IMPLIES RELEASING PAGES FROM CWS.
          FRETURN('WSL',192) UNLESS (0<=LNGTH AND LNGTH<=LCWS);

REDUCE'CWS:
          FOR I ← LCWS-1 BY -1 TO LNGTH DO;
             RELEASE'SOME'CWS(//RETURN'NEW'LNGTH: MEC,MEM);
          ENDFOR;
          GOTO RETURN'NEW'LNGTH;

SET'OLCWS:
*  OLCWS CANNOT BE MADE LESS THAN 0 OR GREATER THAN MLCWS.  MAKING IT
*  SMALLER THAN THE CURRENT VALUE OF LCWS IMPLIES RELEASING
*  PAGES FROM CWS.
          FRETURN('WSL',192) UNLESS (0<=LNGTH AND LNGTH<=MLCWS);
          OLCWS ← LNGTH;
          GOTO RETURN'NEW'LNGTH IF OLCWS>=LCWS;
          GOTO REDUCE'CWS;

SET'MLCWS:
SET'MLDWS:
*  THIS FUNCTION CANNOT BE USED TO MODIFY THESE PARAMETERS.
          FRETURN('ARG',191);

SET'LDWS:
*  LDWS CANNOT BE MADE LESS THAN 0 OR GREATER THAN ITS CURRENT VALUE.
*  DECREASING IT IMPLIES RELEASING PAGES FROM DWS.
          FRETURN('WSL',192) UNLESS (0<=LNGTH AND LNGTH<=LDWS);

REDUCE'DWS:
          FOR I ← LDWS-1 BY -1 TO LNGTH DO;
             RELEASE'SOME'DWS(//RETURN'NEW'LNGTH: MEC,MEM);
          ENDFOR;
          GOTO RETURN'NEW'LNGTH;

SET'OLDWS:
*  OLDWS CANNOT BE MADE LESS THAN 0 OR GREATER THAN MLDWS.  MAKING IT
*  SMALLER THAN THE CURRENT VALUE OF LDWS IMPLIES RELEASING PAGES FROM
*  DWS.
          FRETURN('WSL',192) UNLESS (0<=LNGTH AND LNGTH<=MLDWS);
          OLDWS ← LNGTH;
          GOTO REDUCE'DWS IF OLDWS<LDWS;

RETURN'NEW'LNGTH:
          OLCWS ← MAX(OLCWS,LCWS);
          OLDWS ← MAX(OLDWS,LDWS);
          RETURN DAMMIT ← $PTRS[CODE];

        END;

        PROGRAM AMC'REQUEST;
          INCLUDE RESMON, SWPD, GLOBAL, PROFILE, ICTD;
          DECLARE LONG UNIQUE'NAME;
          DECLARE DISK'ADDRESS, QUEUE, NO'FREE'NODE'CNT, FREE'NODE,
             ERROR'CODE, TRY'AGAIN'CNT, REQUEST'TIME,
             REQUEST, PRT'ADDRESS, I, BEGIN'PTR;
          DECLARE POINTER FREE'LIST ← SWFREL - RESM;
          DECLARE NO'FREE'NODE'LIM ← 100, TRY'AGAIN'LIM ← 5,
             AMC'WAIT'LIMIT ← 1000,
             LONG WAIT'TIME ← (0,30000),
             LONG NPG'WAIT'TIME ← (0,10000);
          DECLARE ARRAY INTERNAL'ARRAY[LSWQN];
          DECLARE LABEL ARRAY ERROR'ACTION[NSWRCDS-CRRSP+1] ←
             (CRRSP'ERROR, CWRPG'ERROR, CRDK'ERROR, CRWUN'ERROR,
              CRKD'ERROR, CRGFP'ERROR, CRDEST'ERROR);
          DECLARE ARRAY REAL'CORE[4*2048:,RESM];

*  ALL REQUESTS ON THE AMC ARE MADE THROUGH THIS FUNCTION.  IT HAS
*  3 ENTRY POINTS - THE FIRST TAKES A REQUEST CODE, A PMT INDEX,
*  A PRT INDEX, AND A 'WAIT FLAG' AS ARGUMENTS.  THE SECOND TAKES A
*  REQUEST CODE, A UNIQUE NAME, A DISK ADDRESS, A VIRTUAL PRT ADDRESS,
*  AND A 'WAIT FLAG'.  THE THIRD TAKES A FULLY FORMED REQUEST NODE.
*  THE 'WAIT FLAG' IS PASSED ON TO THE AMC IN THE WAKF FIELD OF THE
*  REQUEST.  IF IT IS 0, THE MONITOR WILL NOT BLOCK AND WAIT FOR THE
*  AMC TO RESPOND ON THOSE ACTIVATE REQUESTS WHICH CANNOT BE IMMEDIATELY
*  COMPLETED.

        ENTRY AMC'REQUEST(REQUEST'CODE, PMT'INDEX, PRT'INDEX,
                                         WAIT'FLAG), FRETURN;
          UNIQUE'NAME ← PMT[PMT'INDEX]$PMTUN;
          DISK'ADDRESS ← PMT[PMT'INDEX]$PMTDKA;
          PRT'ADDRESS ← @PRT[PRT'INDEX];

        ENTRY AMC'REQ'WITH'RN(REQUEST'CODE, LONG UNIQUE'NAME,
      INTEGER DISK'ADDRESS, PRT'ADDRESS, WAIT'FLAG), FRETURN;

FORM'REQUEST:
          REQUEST ← @INTERNAL'ARRAY[0];
          BSET(REQUEST, 0, LSWQN);
          REQUEST.SWUN ← UNIQUE'NAME;
          REQUEST.SWDKA ← DISK'ADDRESS;
          REQUEST.SWWAKF ← WAIT'FLAG;
          REQUEST.SWEPRT ← PRT'ADDRESS-RESM;
          REQUEST.SWRCD ← REQUEST'CODE;
          REQUEST.SWEQP ← SWEOQ;
          GOTO SEND'REQUEST;

        ENTRY DIRECT'AMC'REQ(ARRAY REQUEST'ARRAY), FRETURN;
          REQUEST ← @REQUEST'ARRAY[0];
          REQUEST'CODE ← REQUEST.SWRCD;
          WAIT'FLAG ← REQUEST.SWWAKF;

SEND'REQUEST:
          QUEUE ← AMC'QUEUES[REQUEST'CODE] - RESM;
          TRY'AGAIN'CNT ← NO'FREE'NODE'CNT ← 0;

GET'FREE'NODE:
*  REMOVE A NODE FROM THE SWAPPER'S FREE LIST.
          PROTECT(2);
             GOTO NO'FREE'NODES IF
                (FREE'NODE ← REAL'CORE[FREE'LIST]$MADF) = SWEOQ;
             BEGIN'PTR ← REAL'CORE[FREE'LIST]$MADF ←
                REAL'CORE[FREE'NODE]$SWFEQP;
             REAL'CORE[FREE'LIST]$MADF1 ←
                FREE'NODE - SWFEQP$FDDISP IF BEGIN'PTR = SWEOQ;
          UNPROTECT(2);
*  NOW COPY OUR READY-TO-GO NODE INTO IT.
          BCOPY(FREE'NODE+RESM, REQUEST, LSWQN);
*  AND PLACE NODE ON THE DESIGNATED SWAPPER QUEUE.
          PROTECT(2);
             IF REAL'CORE[QUEUE]$MADF = SWEOQ DO;
                REAL'CORE[QUEUE]$MADF ←
                   REAL'CORE[QUEUE]$MADF1 ← FREE'NODE;
             ELSE DO;
                REAL'CORE[QUEUE]$MADF1 ←
                   REAL'CORE[REAL'CORE[QUEUE]$MADF1]$SWEQP ← FREE'NODE;
             ENDIF;
             ACTL.WD0 ← 1 IF QUEUE = AMCQ-RESM;
          UNPROTECT(2);
*  START AMC
          ATTENTION(1);
*  NOW SEE WHAT TO DO NEXT.
          RETURN IF QUEUE # AMCQ-RESM;
          FOR I ← 1 TO AMC'WAIT'LIMIT DO;
             GOTO CHECK'RESPONSE IF ACTL.WD0 # 1;
          ENDFOR;
          PUNT('SNR');

CHECK'RESPONSE:
          RETURN IF ACTL.WD0=0;
          PUNT('AME') IF ACTL.WD0 # 4B7;
          ERROR'CODE ← ACTL.WD1;
          REQUEST'TIME ← 1;
          GOTO WAIT'FOR'WAKEUP IF ERROR'CODE=WAITWK;
          GOTO TRY'AGAIN'LATER IF ERROR'CODE=CPWAIT;

ANALYZE'ERROR:
          PUNT('AME') IF (ERROR'CODE=ARQOB OR ERROR'CODE=NOREQ);
          GOTO ERROR'ACTION[REQUEST'CODE-CRRSP];

WAIT'FOR'WAKEUP:
*  RETURN IF WAIT'FLAG ISN'T SET.  OTHERWISE
*  BLOCK UNTIL AMC COMPLETES THE REQUEST AND GENERATES A WAKEUP.
*  ERRORS ENCOUNTERED DURING THIS PART OF THE PROCESSING ARE
*  REPORTED IN A SPECIAL FIELD IN PRT, WHICH THE AMC CLEARS WHEN IT
*  RETURNS A WAITWK RESPONSE.
          RETURN IF WAIT'FLAG=0;
          MBLOCK(AMC);
          PROTECT(1);
             ERROR'CODE ← PRT[PRTI]$PRACTE;
             PRT[PRTI]$PRACTE ← 0;
          UNPROTECT(1);
          RETURN IF ERROR'CODE = 0;
          REQUEST'TIME ← 0;
          GOTO ANALYZE'ERROR;

TRY'AGAIN'LATER:
*  BLOCK FOR A LITTLE WHILE (300 MILLI-SECS) AND THEN MAKE THE REQUEST
*  AGAIN.  PUNT IF THIS HAPPENS MORE THAN TRY'AGAIN'LIM TIMES FOR
*  THE SAME REQUEST.
          GOTO SWAP'OUT IF REQUEST'CODE=CRGFP;
          PUNT('WTL') IF (TRY'AGAIN'CNT ← TRY'AGAIN'CNT+1) >
             TRY'AGAIN'LIM;
          SBLOCK(WAIT'TIME);
          GOTO GET'FREE'NODE;

CRRSP'ERROR:
          FRETURN('NCH',999) IF ERROR'CODE=NCHT;
          FRETURN('DAO',999) IF ERROR'CODE=DNCHT;
          PUNT('SCO') IF ERROR'CODE=SCHOVF;
          PUNT('AME');

CWRPG'ERROR:
          PUNT('AME');

CRDK'ERROR:
          RETURN IF (ERROR'CODE=UNER OR ERROR'CODE=NINDHT OR
                     ERROR'CODE=DNCHT OR ERROR'CODE=DKRAS OR
                     ERROR'CODE=HERDR OR ERROR'CODE=SERDR OR
                     ERROR'CODE=HERDK OR ERROR'CODE=SERDK);
          PUNT('DHT') IF ERROR'CODE=UNERK;
          PUNT('AME');

CRWUN'ERROR:
          IF ERROR'CODE=UNER DO;
             FRETURN('UNU',999) IF REQUEST'TIME;
             FRETURN('DAU',999);
          ENDIF;
          FRETURN('DAU',999) IF ERROR'CODE=DKINU;
          FRETURN('DKE',999) IF ERROR'CODE=HERDK;
          PUNT('AME');

CRKD'ERROR:
          FRETURN('DAO',999) IF (ERROR'CODE=UNER OR ERROR'CODE=DNCHT OR
                                 ERROR'CODE=DKRAS OR ERROR'CODE=UNERK);
          FRETURN('DME',999) IF ERROR'CODE=HERDR;
          FRETURN('DKE',999) IF (ERROR'CODE=HERDK OR ERROR'CODE=SERDK);
          PUNT('AME');

CRGFP'ERROR:
          FRETURN('UNU',999) IF ERROR'CODE=UNER;
          FRETURN('DAU',999) IF ERROR'CODE=DKINU;
          PUNT('AME');

CRDEST'ERROR:
          FRETURN('DAO',999) IF (ERROR'CODE=UNER OR ERROR'CODE=DNCHT OR
                                 ERROR'CODE=DKRAS);
          FRETURN('DKE',999) IF ERROR'CODE=HERDK;
          PUNT('DHT') IF ERROR'CODE=UNERK;
          PUNT('AME');

NO'FREE'NODES:
          UNPROTECT(2);
          GOTO GET'FREE'NODE IF (NO'FREE'NODE'CNT ← NO'FREE'NODE'CNT+1) <
             NO'FREE'NODE'LIM;
          PUNT('NFN');


** NOTE: SWAP'OUT IS SUPPOSED TO DO MORE THAN JUST RETURN!!

SWAP'OUT: SBLOCK(NPG'WAIT'TIME);
          GOTO GET'FREE'NODE;

        END;

        PROGRAM PNIC'TRAP;
          INCLUDE RESMON, PMTD, APTD, PARD, SPTD, PROFILE, SWPD;
          INCLUDE PMS'MACROS;
          DECLARE PMTX, SOURCE, APTE, MEC, MEM, APTX,
             TARGET, PMTE;
          MACRO SCHEDULED ← (PMTE.PMTSF);
          MACRO ON'DRUM ← (PMTE.PMTDWS);
          MACRO CLASS'CODE'ERROR ← (PMTE.PMTCCE);
          MACRO READ'ERROR ← (PMTE.PMTRDE);

        ENTRY PNIC'TRAP();

*  THE PNIC TRAP-HANDLING ROUTINE USES THE FOLLOWING INFORMATION
*  IN DECIDING WHAT TO DO TO CORRECT A PAGE-NOT-IN-CORE TRAP.
*     SOURCE - TRUE IF TRAP CAME OUT OF MONITOR RING
*     TARGET - TRUE IF REFERENCE WAS TO MONITOR RING
*     SCHEDULED - TRUE IF SF IS SET IN THE PAGE'S PMT ENTRY
*     CLASS'CODE'ERROR - TRUE IF CCE IS SET IN THE PAGE'S PMT ENTRY
*     IN'CWS - TRUE IF THE PAGE IS IN CWS
*     IN'DWS - TRUE IF THE PAGE APPEARS IN APT
*     ON'DRUM - TRUE IF DWS IS SET IN THE PAGE'S PMT ENTRY
*     IN'CHT - TRUE IF THE PAGE APPEARS IN CHT
*     READ'ERROR - TRUE IF RDE IS SET IN THE PAGE'S PMT ENTRY

          PMTX ← RDPRMB(PAGENO(TPAR))$PRMPMT;
          PMTE ← @PMT[PMTX];
*  CONVERT TO PNIM IF PMT ENTRY 'CLEAR'
          IF PMTE.PMTDKA=0 DO;
             PNIM'TRAP();
             RETURN;
          ENDIF;
          GET'APT'ENTRY(PMTX: APTE,APTX);
          SOURCE ← MRING(TRSTATE.STPC);
          TARGET ← MRING(TPAR);
*  ABORT IF LOOPING THROUGH CWS.
          IF TRSTATE.INSTD DO;
             PNIC'COUNT ← PNIC'COUNT+1;
             IF PNIC'COUNT > LCWS DO;
                TRSTATE.INSTD ← 0;
                TRAP(TNO(PNIC), TPAR, SOURCE);
             ENDIF;
          ELSE DO;
             TRSTATE.INSTD ← 1;
             PNIC'COUNT ← 0;
          ENDIF;


FIX'IT:   IF NOT SCHEDULED DO;
             IF NOT IN'CWS DO;
                TRAP(TNO(PNIC), TPAR, 0) IF (SPSTATUS$DPNIC=0 AND SOURCE=0);
                PUT'IN'CWS(PMTX,APTX,APTE//CANT'PUT'IN'CWS:MEC,MEM);
                GOTO SWAP'OUT;
             ELSE DO;* IN CWS BUT NOT SCHEDULED
                IF NOT ON'DRUM DO;
                   AMC'REQUEST(CRKD,PMTX,PRTI,1//TRANSFER'FAILURE: MEC,MEM);
                   PMTE.PMTDWS ← 1;
                   GOTO SWAP'OUT;
                ELSE DO;* IN CWS AND ON DRUM BUT NOT SCHEDULED
                   IF CLASS'CODE'ERROR DO;
                      (TRAP(TNO(NEP), TPAR, SOURCE) IF (SOURCE=0 OR
                       TARGET=0) ELSE PUNT('CCE'));
                   ELSEIF READ'ERROR DO;
                      (TRAP(TNO(DMRD), TPAR, SOURCE) IF (SOURCE=0 OR
                       TARGET=0) ELSE PUNT('DMR'));
                   ELSE DO;* EVERYTHING LOOKS OKAY
                      GOTO SWAP'OUT;
                   ENDIF;
                ENDIF;
             ENDIF;
          ELSE DO;* SCHEDULED, BUT UNAVAILABLE TO CPU
             GOTO SWAP'OUT;
          ENDIF;

CANT'PUT'IN'CWS:
          PUNT(MEC) IF (SOURCE=1 AND TARGET=1);
          IF ((SOURCE=1) AND (MEC='WSE' OR MEC='CWE' OR MEC='WSL')) DO;
             SET'LWS('OCW',OLCWS+1//CANT'INC'OCW);
             GOTO FIX'IT;
CANT'INC'OCW:SET'LWS('ODW',OLDWS+1//GIVE'UP);
             GOTO FIX'IT;
          ENDIF;
GIVE'UP:  TRAP(TNO(CWSO), TPAR, SOURCE) IF (MEC='CWE' OR MEC='WSL');

TRANSFER'FAILURE:
          PUNT(MEC) IF (SOURCE=1 AND TARGET=1);
          TRAP(TNO(NEP), TPAR, SOURCE) IF MEC='DAO';
          TRAP(TNO(DMRD), TPAR, SOURCE) IF (MEC='DME' OR MEC='DKE');
          PUNT(MEC);

SWAP'OUT:
*  AFTER DOING WHATEVER SHOULD BE DONE TO CORRECT THE PAGE FAULT, WE 
*  BLOCK.  THIS WILL HAVE THE EFFECT OF FORCING THE SWAPPER TO MAKE AN
*  ATTEMPT TO BRING IN THE MISSING PAGE, AND WILL ALSO GIVE TIME FOR ANY
*  TRANSIENT CONDITIONS (LIKE PAGE IN PROCESS OF BEING DESTROYED) TO
*  STABILIZE.
          PROTECT(1);
             PRT[PRTI]$PRPGF ← 1;
          UNPROTECT(1);
          SWBLOCK();
          RETURN;

        END;

        PROGRAM PNIM'TRAP;
          INCLUDE TRAPD, GLOBAL, RESMON, SPTD, SPCSD, PROFILE;
          DECLARE Q, PC, PMTX, TARGET'SP, MEC, MEM, SOURCE, BYTENO;
          DECLARE NAME, SPTE;

        ENTRY PNIM'TRAP();
          Q ← TPAR;
          PC ← TRSTATE.STPC;
          BYTENO ← PAGENO(Q);
          PMTX ← RDPRMB(BYTENO)$PRMPMT;
          TARGET'SP ← (SPCS[SPCSL]$CSR0SP IF URING(Q) ELSE
                       SPCS[SPCSL]$CSR1SP IF YRING(Q) ELSE
                       0);
          NAME ← 1 LSH TARGET'SP;
          SOURCE ← MRING(PC);

          PUNT('PNM') IF MRING(PC) AND MRING(Q);
          PUNT('MAC') IF MRING(Q) AND NOT MRING(PC);

          TRAP(TNO(PNIM), Q, SOURCE) IF TARGET'SP=0;
          TRAP(TNO(PNIM), Q, SOURCE) IF SPSTATUS$DPNIM=0 AND NOT MRING(PC);
          IF PMTX=0 DO;
             PMTX ← MACQPMT(-1, NAME//PMT'FULL:MEC, MEM);
          ENDIF;
          MNPPMT(PMTX, MKEY, MSTATUS//VALUE PUNT(MEC):MEC, MEM);

PUT'IN'MAP:
          SETPRMB(BYTENO, PMTX);
          BYTENO ← BYTENO-64 IF SPT[TARGET'SP]$SPTRING=1;
          SPTE ← @SPT[TARGET'SP];
          SPTE.(PXFLDS[BYTENO]) ← PMTX;
          SPTE.(ROFLDS[BYTENO]) ← 0;
          SPTE.SPTLM ← BYTENO IF BYTENO > SPTE.SPTLM;
          RETURN;

*  FAILURE RETURN FROM ACQPMT IS REASONABLE ONLY IF PMT IS FULL.
PMT'FULL: TRAP(TNO(PMTO), Q, SOURCE) IF MEC='PMO';
          PUNT(MEC);

        END;

        PROGRAM PUT'INTO'WS;
          INCLUDE GLOBAL, PROFILE, APTD, PMTD, SWPD, PMS'MACROS;
          DECLARE APTX', APTE', PMTX', PMTE', MEC, MEM,
             PUT'IN'DWS'ONLY, TEMP;
          MACRO ON'DRUM ← (PMT[PMTX]$PMTDWS);
          MACRO FIRST'NOT'CWS ← (NAPTE-LCWS);

        ENTRY PUT'IN'CWS(PMTX, APTX, APTE), FRETURN;

*  ENTER HERE TO PUT THE PAGE WITH REAL NAME IN PMT[PMTX] INTO CWS.
*  THIS FUNCTION MUST NOT BE CALLED IF THE PAGE IS ALREADY IN CWS.  IF 
*  THE PAGE HAS AN APT ENTRY, APTX MUST BE ITS INDEX AND APTE MUST
*  BE APT[APTX].   IF THE PAGE HAS NO APT ENTRY, APTX AND APTE MUST
*  BE 0.  IN THIS LATTER CASE WE MUST PUT THE PAGE INTO DWS BEFORE
*  PUTTING IT INTO CWS.

          GOTO ALREADY'IN'DWS IF IN'DWS;
          PUT'IN'DWS'ONLY ← 0;
          GOTO PUT'INTO'DWS;

        ENTRY PUT'IN'DWS(PMTX), FRETURN;

*  ENTER HERE TO PUT THE PAGE WITH REAL NAME IN PMT[PMTX] INTO DWS.
*  DO NOT CALL THIS FUNCTION FOR A PAGE WHICH ALREADY HAS AN ENTRY
*  IN APT.  THIS CODE IS ALSO USED IN PUTTING A PAGE INTO CWS IF
*  THE PAGE ISN'T ALREADY IN DWS.

          APTX ← APTE ← 0;
          PUT'IN'DWS'ONLY ← 1;

PUT'INTO'DWS:
*  FIRST WE READ THE PAGE FROM DISK TO DRUM.  IF THIS FAILS, WE HAVE
*  NOT DISTURBED THE WORKING SET IN ANY WAY.  IT IS POSSIBLE THAT
*  PMT[PMTX] IS "CLEAR", IN WHICH CASE WE DON'T ATTEMPT A TRANSFER.

          IF PMT[PMTX]$PMTDKA # 0 DO;
             AMC'REQUEST(CRKD,PMTX,PRTI,0//FRETURN(MEC,MEM): MEC,MEM);
             PMT[PMTX]$PMTDWS ← 1;
          ENDIF;

*  IF THE DRUM WORKING SET IS FULL, WE MUST RELEASE A PAGE FROM IT
*  BEFORE WE PUT IN THE NEW ONE.  THE FUNCTION TO DO THIS CAN FAIL ONLY
*  IF APT IS EMPTY OR ALL PAGES IN IT ARE LOCKED.  IF IT DOES FAIL, WE HAVE
*  TO RETURN THE PAGE WE JUST READ BACK TO THE DISK.

          IF DWS'FULL DO;
             RELEASE'SOME'DWS(//PUT'PAGE'BACK: MEC,MEM);
          ENDIF;

*  NOW WE ARE READY TO MAKE THE ENTRY IN APT.  WE PUT THE ENTRY
*  AT THE END OF THE CURRENT DRUM WORKING SET AND INCREMENT LDWS.  THE
*  ENTRY'S USE HISTORY IS SET TO THE MAXIMUM POSSIBLE VALUE.  THIS IS ALL
*  UNLESS THE CODE IS RUNNING AS PART OF PUT'IN'CWS.

          LDWS ← LDWS+1;
          APT[APTX←LAST'DWS] ← APTE ← (-1)@APTUH V' PMTX@APTPMT;
          RETURN APTX IF PUT'IN'DWS'ONLY;

ALREADY'IN'DWS:
*  THE PAGE IS NOW IN DWS AND ITS INDEX IS APTX.  IF CWS IS CURRENTLY FULL,
*  WE HAVE TO RELEASE A PAGE FROM IT BEFORE PUTTING THE NEW ONE IN.

          APTE' ← APT[APTX' ← FIRST'NOT'CWS];
          GOTO PUT'INTO'CWS IF NOT CWS'FULL;

*  WE MUST CHOOSE A PAGE TO REMOVE FROM CWS.  OLDEST'CWS WILL POINT
*  TO THE PAGE LEAST RECENTLY USED UNLESS WE HAVE ALREADY RELEASED
*  A PAGE SINCE THE LAST SWAP, IN WHICH CASE OLDEST'CWS WILL BE 0.
*  IN THIS CASE WE MUST FIND THE LEAST RECENTLY REFERENCED PAGE BY
*  COMPARING THE USE FIELDS OF ALL CWS PAGES.  THE FUNCTION TO DO
*  THIS WILL FAIL ONLY IF CWS IS EMPTY.  IT IS POSSIBLE THAT ALL OF
*  CWS IS LOCKED, IN WHICH CASE WE CANNOT MAKE ROOM.

          IF OLDEST'CWS # 0 DO;
             APTE' ← APT[APTX' ← APTL-OLDEST'CWS];
             OLDEST'CWS ← 0;
             GOTO FIND'OLDEST IF (PMT[APTE'$APTPMT]$PMTRF OR
                                  APTE'$APTLOCKS#0);
          ELSE DO;
FIND'OLDEST:
             APTX' ← FIND'OLDEST'CWS(:APTE'//FRETURN('CWE',158));
          ENDIF;
          FRETURN('WSL',205) IF APTE'$APTLOCKS#0;

PUT'INTO'CWS:
*  WE ARE NOW READY TO MOVE OUR APT ENTRY INTO THE CWS SECTION
*  OF THE TABLE.  APTX IS THE ENTRY'S CURRENT INDEX AND APTX' IS
*  THE INDEX OF THE ENTRY IT SHOULD REPLACE.  LCWS GETS
*  INCREMENTED IF THE ENTRY BEING REPLACED WASN'T IN CWS.  LTBW GETS
*  INCREMENTED IF THE ENTRY WE'RE PUTTING INTO CWS WASN'T ALREADY
*  IN TBW.  THEN WE SHUFFLE THE ENTRIES AROUND AND ARE DONE.

          LCWS ← LCWS+1 IF APTL-APTX'>LCWS;
          LTBW ← LTBW+1 IF APTL-APTX > LTBW;
          TEMP ← APT[APTX]; APT[APTX] ← APT[LAST'TBW];
          APT[LAST'TBW] ← APT[APTX']; APT[APTX'] ← TEMP;
          APT[APTX']$APTUH ← -1;
          RETURN APTX';

PUT'PAGE'BACK:
*  DWS IS FULL AND WE CAN'T MAKE ROOM FOR THE NEW ENTRY.  WE MUST
*  RELEASE THE NEW PAGE FROM THE DRUM.  DON'T WAIT FOR TRANSFER
*  TO COMPLETE.

          IF PMT[PMTX]$PMTDKA#0 DO;
             AMC'REQUEST(CRDK, PMTX, PRTI, 0//VALUE PUNT(MEC):MEC,MEM);
             PMT[PMTX]$PMTDWS ← 0;
          ENDIF;
          FRETURN(MEC,MEM);

        END;

        PROGRAM RELEASE'FROM'WS;
          INCLUDE PROFILE, APTD, PMTD, SWPD, GLOBAL, PMS'MACROS;
          DECLARE APTX, APTE, PMTX, TEMP, MEC, MEM;

        ENTRY RELEASE'SOME'CWS(), FRETURN;

*  ENTER HERE TO RELEASE THE LEAST RECENTLY REFERENCED PAGE FROM CWS.
*  OLDEST'CWS SHOULD POINT TO THE RIGHT PAGE TO RELEASE, BUT IT MAY
*  NOT, EITHER BECAUSE WE HAVE ALREADY USED OLDEST'CWS SINCE IT WAS
*  LAST UPDATED, OR BECAUSE THE PAGE IT POINTS TO HAS BEEN REFERENCED
*  SINCE APT WAS LAST AGED.
          IF OLDEST'CWS#0 DO;
             APTE ← APT[APTX ← APTL-OLDEST'CWS];
             OLDEST'CWS ← 0;
             GOTO FIND'OLDEST IF (PMT[APTE$APTPMT]$PMTRF OR
                                  APTE$APTLOCKS#0);
          ELSE DO;
FIND'OLDEST:
             APTX ← FIND'OLDEST'CWS(:APTE//FRETURN('CWE',999));
          ENDIF;
          FRETURN('WSL',205) IF APTE$APTLOCKS#0;
          PMTX ← APTE$APTPMT;
          GOTO MOVE'APT'ENTRY;

        ENTRY RELEASE'THIS'CWS(PMTX), FRETURN;

*  ENTER HERE TO RELEASE THE PAGE PMT[PMTX] FROM CWS.  FAILS ONLY
*  IF PAGE IS LOCKED.
          GET'APT'ENTRY(PMTX: APTE,APTX);
          FRETURN('PGL',999) IF APTE$APTLOCKS#0;

MOVE'APT'ENTRY:
*  THE APT ENTRY IS NOW MOVED OUT OF THE CWS SECTION OF APT.  IT IS
*  LEFT IN THE TBW SECTION.  THIS IS DONE BY EXCHANGING IT WITH THE
*  LAST ENTRY IN THE CWS SECTION AND DECREMENTING LCWS.
          TEMP ← APT[APTX];  APT[APTX] ← APT[LAST'CWS];
          APT[LAST'CWS] ← TEMP;
          LCWS ← LCWS-1;
          RETURN PMTX;

        ENTRY RELEASE'SOME'DWS(), FRETURN;

*  THIS FUNCTION CHOOSES THE BEST PAGE TO RELEASE FROM THE DRUM WORKING
*  SET AND CALLS ON THE AMC TO RETURN IT TO THE DISK.  IT FAILS ONLY
*  IN THE UNLIKELY CASE THAT THE ACTIVE PAGE TABLE IS EMPTY OR
*  ALL ENTRIES IN IT ARE LOCKED IN.  IT WILL RELEASE A PAGE FROM THE
*  CORE WORKING SET IF CWS=DWS.
          FRETURN('WSE',999) IF LDWS=0;
          APTX ← FIND'OLDEST'DWS(:APTE);
          FRETURN('WSL',999) IF APTE$APTLOCKS#0;
          PMTX ← APTE$APTPMT;
          GOTO CHECK'NEW'PAGE;

        ENTRY RELEASE'THIS'DWS(PMTX), FRETURN;

*  ENTER HERE TO RELEASE A SPECIFIC PAGE FROM THE DRUM WORKING SET.
          GET'APT'ENTRY(PMTX: APTE,APTX);
          RETURN -1 IF NOT IN'DWS;
          FRETURN('PGL',203) IF APTE$APTLOCKS#0;

CHECK'NEW'PAGE:
*  IF APTE HAS THE 'NEW PAGE' BIT SET, THE PAGE DOESN'T EXIST EXCEPT
*  FOR THE PMT AND APT ENTRIES.  WE JUST WRITE ITS UNIQUE NAME ON THE
*  DISK.  ANY ERROR WE GET IN DOING THIS CAUSES A PUNT FOR THE PRESENT.
          IF APTE$APTNPG DO;
             AMC'REQUEST(CRWUN,PMTX,PRTI,1//VALUE PUNT(MEC): MEC,MEM);
             GOTO DELETE'APT'ENTRY;
          ENDIF;

*  PAGE MUST BE SPECIFICALLY RELEASED FROM CORE IF SF IS SET.
          IF PMT[PMTX]$PMTSF DO;
             AMC'REQUEST(CWRPG,PMTX,PRTI,0//VALUE PUNT(MEC): MEC,MEM);
          ENDIF;

DELETE'APT'ENTRY:
*  WE HAVE TO FIX UP APT BEFORE WE MAKE THE REQUEST TO WRITE THE PAGE
*  ON THE DISK BECAUSE WE MAY GET SWAPPED OUT WHILE THE TRANSFER TAKES
*  PLACE.
          IF IN'CWS DO;
             APT[APTX] ← APT[LAST'CWS];  APT[LAST'CWS] ← APT[LAST'TBW];
             APT[LAST'TBW] ← APT[LAST'DWS];
             LCWS ← LCWS-1;  LTBW ← LTBW-1;
          ELSEIF IN'TBW DO;
             APT[APTX] ← APT[LAST'TBW];  APT[LAST'TBW] ← APT[LAST'DWS];
             LTBW ← LTBW-1;
          ELSE DO;
             APT[APTX] ← APT[LAST'DWS];
          ENDIF;
          APT[LAST'DWS] ← 0;
          LDWS ← LDWS-1;
          RETURN PMTX IF APTE$APTNPG;

*  FINALLY, WE RELEASE THE PAGE FROM THE DRUM, IF PMT[PMTX] HAS THE
*  DWS BIT SET AND IS NOT 'CLEAR'.
          IF PMT[PMTX]$PMTDKA#0 AND PMT[PMTX]$PMTDWS DO;
             AMC'REQUEST(CRDK,PMTX,PRTI,0//VALUE PUNT(MEC):MEC,MEM);
          ENDIF;
          PMT[PMTX]$PMTDWS ← 0;
          IF PMT[PMTX]$PMTRF DO;
             PMT[PMTX]$PMTRF ← 0;
             CLEAR'MAP;
          ENDIF;
          RETURN PMTX;

        END;

        PROGRAM SIMULATE'AMC'103;
*  THIS CODE DOES THE THINGS THAT WILL BE DONE BY THE AMC IN THE 1.03
*  VERSION.  CONVERTING THE MONITOR TO RUN WITH THE 1.03 AMC SHOULD
*  MAINLY BE A MATTER OF DELETING ALL CALLS ON THE FUNCTIONS IN THIS
*  PROGRAM.
          INCLUDE PROFILE, APTD, PMTD, SWPD, GLOBAL, PMS'MACROS;
          DECLARE APTX, APTE, PMTX, PMTE, MEC, MEM, TEMP;

        ENTRY FREE'TBW'PAGES();

*  THIS FUNCTION SHOULD BE CALLED JUST BEFORE EACH BLOCK.  IT RELEASES
*  FROM CORE ALL PAGES IN TBW BUT NOT IN CWS, THAT IS, ALL PAGES WHICH
*  HAVE BEEN REMOVED FROM CWS SINCE THE LAST SWAP-IN.
          FOR LTBW ← LTBW BY -1 TO LCWS+1 DO;
             APTE ← APT[APTX ← LAST'TBW];
             PMTE ← @PMT[PMTX ← APTE$APTPMT];
             IF PMTE.PMTSF DO;
                AMC'REQUEST(CWRPG,PMTX,PRTI,0//VALUE PUNT(MEC): MEC,MEM);
                PMTE.PMTSF ← 0;
             ENDIF;
          ENDFOR;
          LTBW ← LCWS;
          RETURN;

        ENTRY SHRINK'CWS();

*  THIS FUNCTION REMOVES FROM CWS ALL PAGES WHOSE APT ENTRIES HAVE
*  NO BITS IN COMMON WITH THE CONTROL WORD, MUMBLE.  IT SHOULD BE
*  CALLED BEFORE FREE'TBW'PAGES AND AFTER AGE'APS.  IF MUMBLE = -1,
*  IT WON'T DO ANYTHING.
          FOR APTX ← APTL-LCWS TO APTL-1 DO;
             IF APT[APTX] A' MUMBLE = 0 DO;
                TEMP ← APT[APTX];  APT[APTX] ← APT[LAST'CWS];
                APT[LAST'CWS] ← TEMP;
                LCWS ← LCWS-1;
             ENDIF;
          ENDFOR;
          RETURN;

        END;
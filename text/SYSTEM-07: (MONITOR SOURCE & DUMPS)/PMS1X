        PROGRAM ACQPMT;
          INCLUDE PROFILE, SPTD, PMTD, GLOBAL;
          DECLARE NAME, MEC, MEM;
*
        FUNCTION ACQPMT(PMTX), FRETURN, MONITOR ← 50;
          NAME ← SPNAME; GOTO ACQ05;
*  ENTRY POINT FOR MONITOR
        ENTRY MACQPMT(PMTX, NAME), FRETURN;
*  LOOK FOR A FREE PMT ENTRY IF PMTX = -1.
ACQ05:    IF PMTX=-1 DO;
             FOR PMTX←1 TO NPMTE DO;
                GOTO ACQ10 IF PMT[PMTX]$PMTCL=0;
             ENDFOR;
             PMTX ← FREE'PMT(//FRETURN(MEC, MEM):MEC, MEM);
          ENDIF;
*  INITIALIZE THE PMT ENTRY.
ACQ10:    FRETURN('PMI', 110) UNLESS (1<=PMTX AND PMTX<=NPMTE);
          FRETURN('PMA', 119) IF PMT[PMTX]$PMTCL#0;
          PMT[PMTX]← LONGLONG'ZERO;
          PMT[PMTX]$PMTAL←NAME;
          PMT[PMTX]$PMTCL←NAME;
*
          RETURN PMTX;

        END;

        PROGRAM NPPMT;
          INCLUDE PROFILE, PMTD, SPTD, SWPD, RESMON, GLOBAL, APTD;
          DECLARE ARRAY REQ[LSWQN];
          DECLARE KEY, STATUS, NODE, T, MEC, MEM, PMTE, APTE;
*
        FUNCTION NPPMT(PMTX), FRETURN, MONITOR ← 51;
          KEY ← SPKEY; STATUS ← SPSTATUS; GOTO NP10;
*  ENTRY POINT FOR MONITOR
        ENTRY MNPPMT(PMTX, KEY, STATUS), FRETURN;
*  CHECK FOR ERRORS
NP10:     FRETURN('PMI',110) UNLESS (1<=PMTX AND PMTX<=NPMTE);
          PMTE ← @PMT[PMTX];
          FRETURN('PMC',121) IF (KEY A' PMTE.PMTCL)=0;
          FRETURN('PMF',122) UNLESS PMTE.PMTDKA=0;
          FRETURN('DWF',123) IF (LDWS=OLDWS AND STATUS$DDWSO=0);
          FRETURN('CWF',124) IF (LCWS=OLCWS AND STATUS$DCWSO=0);
*!!       FRETURN('KSE',125) IF RSE[0]$DKSP=0;
*  MAKE ROOM IN CWS AND DWS IF NECESSARY
          DPCWS(-1//VALUE PUNT(MEC):MEC, MEM) IF LCWS=OLCWS;
          DPDWS(-1//VALUE PUNT(MEC):MEC, MEM) IF LDWS=OLDWS;
*  SET-UP PMT[PMTX]
          PMTE.PMTUN ← PMT[1]$PMTUN;* USE CB'S UNIQUE NAME
          PMTE.PMTINDEX ← PMTX;* WITH PMT INDEX OVERWRITTEN
          PMTE.PMTDKA ← GET'DISK'ADDR(PMT[1]$PMTDKA//NP81);
          PMTE.PMTRO ← 0;
          PMTE.PMTSF ← 0;
          PMTE.PMTRF ← 0;
          PMTE.PMTNC ← 0;
          PMTE.PMTCCE ← 0;
          PMTE.PMTFP←0;
          GOTO NP20;*  JUMP AROUND SPECIAL ENTRY POINT
*  SPECIAL ENTRY POINT FOR FILE SYSTEM
        ENTRY NFPPMT(PMTX), FRETURN;
          KEY ← MKEY; STATUS ← MSTATUS;
*  SEND REQUEST FOR NEW PAGE TO AMC
NP20:     NODE ← @REQ[0];
          BSET(NODE, 0, LSWQN);
          NODE.SWUN←PMTE.PMTUN;
          NODE.SWDKA←PMTE.PMTDKA;
          NODE.SWWAKF ← 1;* REQUEST A WAKEUP
          NODE.SWRCD ← CRGFP;
NP25:     SWPREQ(REQ, 0//NP82: MEC, MEM);
*  SET SF, PUT PAGE IN APT, CLEAR IT TO 0.
          PMTE.PMTSF←1;
          APTE ← (-1)@APTUH V' 1@APTDWS V' 1@APTCWS V' PMTX;
          MAKE'APT'ENTRY(APTE//VALUE PUNT('APT'));
          T←RDPRMB(MSC1);
          SETPRMB(MSC1,PMTX);
          BSET(PAGESA(MSC1), 0, 2048);
          SETPRMB(MSC1,T);
          RETURN;
*  ERROR RETURN FROM DISK ALLOCATOR
NP81:     PUNT('KAL');
*  AMC REJECTED THE REQUEST FOR A NEW PAGE FOR ONE OF THE FOLLOWING
*  REASONS.
*  (1) UNER - THERE IS ALREADY A CHT ENTRY WITH OUR 'NEW' UNIQUE
*      NAME IN IT.  PUNT.
*  (2) DKINU - THERE IS ALREADY A DHT ENTRY WITH OUR 'FREE' DISK ADDRESS
*      IN IT.  PUNT.
NP82:     PUNT('PAE') IF MEM=UNER;
          PUNT('KBT') IF MEM=DKINU;
          PUNT('AME');

        END;

        PROGRAM RNPMT;
          INCLUDE SPTD, GLOBAL, PMTD, PROFILE;
          DECLARE PMTE;
        FUNCTION RNPMT(PMTX,LONG UNQN, INTEGER DKA), FRETURN,
                                                MONITOR ← 52;
*  CHECK FOR ERRORS
          FRETURN('STS',127) UNLESS SPSTATUS$SD;
          FRETURN('PMI',110) UNLESS (1<=PMTX AND PMTX<=NPMTE);
          PMTE ← @PMT[PMTX];
          FRETURN('PMC',121) IF (SPKEY A' PMTE.PMTCL) = 0;
          FRETURN('PMF',122) IF PMTE.PMTDKA#0;
          FRETURN('ARG',999) IF DKA=0;
*  PUT REAL NAME INTO PMT[PMTX]
          PMTE.PMTUN←UNQN;
          PMTE.PMTDKA←DKA;
          PMTE.PMTRO←0;
          PMTE.PMTSF←0;
          PMTE.PMTRF←0;
          PMTE.PMTNC←0;
          PMTE.PMTCCE ← 0;
          PMTE.PMTFP←1;*  TREAT LIKE FILE PAGE
*
          RETURN;

        END;

        PROGRAM CLRPMT;
          INCLUDE PROFILE, SPTD, PMTD, GLOBAL;
          DECLARE KEY, MEC, MEM, PMTE, RF, AL, CL;
*
        FUNCTION CLRPMT(PMTX), FRETURN, MONITOR ← 53;
          KEY ← SPKEY; GOTO CLR10;
*  ENTRY POINT FOR MONITOR
        ENTRY MCLRPMT(PMTX, KEY), FRETURN;
*  CHECK FOR ERRORS
CLR10:    FRETURN('PMI',110) UNLESS (1<=PMTX AND PMTX<=NPMTE);
          PMTE ← @PMT[PMTX];
          FRETURN('PMC',121) IF KEY A' PMTE.PMTCL=0;
*  RELEASE PAGE FROM DWS, AND DESTROY IT IF IT IS PRIVATE MEMORY.
          MDPDWS(PMTX, KEY//VALUE PUNT(MEC):MEC,MEM);
          IF (PMTE.PMTDKA#0 AND PMTE.PMTFP=0) DO;
             DESTROY'PAGE(PMTE.PMTDKA, PMTE.PMTUN//
                VALUE PUNT(MEC): MEC, MEM);
          ENDIF;
*  CLEAR PMT[PMTX] EXCEPT FOR CL AND AL AND
*  CLEAR PHYSICAL MAP IF REFERENCE FLAG IS SET.
          RF ← PMTE.PMTRF;
          AL ← PMTE.PMTAL;
          CL ← PMTE.PMTCL;
          PMT[PMTX] ← LONGLONG'ZERO;
          PMTE.PMTAL ← AL;
          PMTE.PMTCL ← CL;
          IF RF DO;
             CLEAR'MAP;
          ENDIF;
          RETURN;
*

        END;

        PROGRAM DELPMT;
          INCLUDE PROFILE, SPTD, PMTD, GLOBAL;
          DECLARE KEY, I, LMAP, J;
          DECLARE MEC, MEM, LM, SPTE, PRME;
          DECLARE FIXED FIELD B0'11(0:0,11), B12'23(0:12,23),
             BYTE0(0:4,11), BYTE1(0:16,23);
*
        FUNCTION DELPMT(PMTX), FRETURN, MONITOR ← 54;
          KEY ← SPKEY; GOTO DEL10;
*  ENTRY POINT FOR MONITOR
        ENTRY MDELPMT(PMTX, KEY), FRETURN;
*  CHECK FOR ERRORS
DEL10:    FRETURN('PMI',110) UNLESS (1<=PMTX AND PMTX<=NPMTE);
          FRETURN('PMC',121) IF KEY A' PMT[PMTX]$PMTCL=0;
*  FIRST CLEAR PMT[PMTX]
          MCLRPMT(PMTX, KEY//VALUE PUNT(MEC):MEC,MEM);

*  PMTX MUST NOW BE REMOVED FROM ALL MAPS, DAMMIT.
*  THE PROCESS MAP:
          FOR I ← 0 TO 63 DO;
             IF (PRME ← PRMAP[I]) # 0 DO;
                PRMAP[I]$B0'11 ← 0 IF PRME$BYTE0=PMTX;
                PRMAP[I]$B12'23 ← 0 IF PRME$BYTE1=PMTX;
             ENDIF;
          ENDFOR;
*  THE SUB-PROCESS MAPS:
          FOR I ← 1 TO NSPTE DO;
             IF SPT[I]$SPTOL#0 DO;
                SPTE ← @SPT[I];
                LMAP ← SPTE.SPTLM;
                LM ← 0;
                FOR J ← 0 TO LMAP DO;
                   IF SPTE.(PXFLDS[J])=PMTX DO;
                      SPTE.(PXFLDS[J]) ← 0;
                      SPTE.(ROFLDS[J]) ← 0;
                   ENDIF;
                   LM ← J IF SPTE.(PXFLDS[J])#0;
                ENDFOR;
                SPTE.SPTLM ← LM;
             ENDIF;
          ENDFOR;

*  FINALLY, FREE PMT[PMTX].
          PMT[PMTX]$PMTAL ← 0;
          PMT[PMTX]$PMTCL ← 0;
          RETURN;
*

        END;

        PROGRAM SPMTAL;
          INCLUDE PROFILE, SPTD, PMTD, GLOBAL;
          DECLARE KEY;
*
        FUNCTION SPMTAL(PMTX,AL), FRETURN, MONITOR ← 55;
          KEY ← SPKEY; GOTO SAL10;
*  ENTRY POINT FOR MONITOR
        ENTRY MSPMTAL(PMTX, AL, KEY), FRETURN;
*  CHECK FOR ERRORS
SAL10:    FRETURN('PMI',110) UNLESS (1<=PMTX AND PMTX<=NPMTE);
          FRETURN('PMC',121) UNLESS
             (KEY A' PMT[PMTX]$PMTCL#0 OR
             (KEY A' PMT[PMTX]$PMTAL#0 AND
                (PMT[PMTX]$PMTAL A' N' AL) A' N' KEY=0));
*  DO IT.
          PMT[PMTX]$PMTAL←AL;
*
          RETURN;

        END;

        PROGRAM SPMTCL;
          INCLUDE PROFILE, SPTD, PMTD, GLOBAL;
          DECLARE KEY, MEC, MEM;
*
        FUNCTION SPMTCL(PMTX, CL), FRETURN, MONITOR ← 56;
          KEY ← SPKEY; GOTO SCL10;
*  ENTRY POINT FOR MONITOR
        ENTRY MSPMTCL(PMTX, CL, KEY), FRETURN;
*  CHECK FOR ERRORS
SCL10:    FRETURN('PMI',110) UNLESS (1<=PMTX AND PMTX <=NPMTE);
          FRETURN('PMC',121) IF KEY A' PMT[PMTX]$PMTCL = 0;
*  RELEASE PMT[PMTX] IF CL GOES TO 0.
          MDELPMT(PMTX,KEY//VALUE PUNT(MEC):MEC,MEM) IF CL=0;
          PMT[PMTX]$PMTCL←CL;
*
          RETURN;
*

        END;

        PROGRAM SPMTRO;
          INCLUDE GLOBAL, PMTD, PROFILE, SPTD;
*
        FUNCTION SPMTRO(PMTX,RO), FRETURN, MONITOR ← 57;
*  CHECK FOR ERRORS
          FRETURN('PMI',110) UNLESS (1<=PMTX AND PMTX<=NPMTE);
          FRETURN('PMC',121) IF SPKEY A' PMT[PMTX]$PMTCL = 0;
          FRETURN('FPR',135) IF (PMT[PMTX]$PMTRO=1
             AND PMT[PMTX]$PMTFP=1 AND
                RO@PMTRO=0);
*  SET/RESET THE BIT AND CLEAR THE PHYSICAL MAP IF NECESSARY
          PMT[PMTX]$PMTRO←RO;
          IF PMT[PMTX]$PMTRF DO;
             CLEAR'MAP;
          ENDIF;
          RETURN;

        END;

        PROGRAM READPMT;
          INCLUDE GLOBAL, PMTD, APTD, PROFILE;
          DECLARE I;
*
        FUNCTION READPMT(PMTX, ARRAY PMTE), FRETURN, MONITOR ← 58;
*  CHECK FOR ERRORS
          FRETURN('PMI',110) UNLESS (1<=PMTX AND PMTX<=NPMTE);
          PMTE[I] ← (@PMT[PMTX])[I] FOR I ← 0 TO LPMTE-1;
          PMTE[LPMTE] ← GET'APT'ENTRY(PMTX//VALUE 0);
          RETURN;

        FUNCTION READ'APT(APTX), FRETURN, MONITOR ← 72;
          FRETURN('API',164) UNLESS (1<=APTX AND APTX<=NAPTE);
          RETURN APT[NAPTE-APTX+1];

        END;

        PROGRAM AGE'APS;
*
*  MAINTAIN USE HISTORIES FOR ACTIVE PAGES
*
*  IF THIS ROUTINE NEEDS TO BE MORE EFFICIENT IT CAN BE CODED AS FOLLOWS.
*         FOR I ← NAPTE BY -1 TO NAPTE-LDWS+1 DO;
*            .EAX APT[I], LDX $APTPMT, EAX $PMT, LDA 0, XMA $PMTRF;
*            .LSHA LAPTUH, EAX APT[I], IOR $APTUH, LSHA -1, STA $APTUH;
*         ENDFOR;
          INCLUDE APTD, PROFILE, PMTD, GLOBAL;
          DECLARE I;
        FUNCTION AGE'APS();
*
          FOR I←NAPTE BY-1 TO NAPTE-LDWS+1 DO;
             APT[I]$APTUH ← ((PMT[APT[I]$APTPMT]$PMTRF LSH LAPTUH) V'
                             APT[I]$APTUH) RSH 1;
             PMT[APT[I]$APTPMT]$PMTRF←0;
          ENDFOR;
          CLEAR'MAP;
          RETURN;

        END;

        PROGRAM OLDEST'PAGE;
*    THIS PROGRAM FINDS THE 'OLDEST' ENTRY IN APT WHICH SATISFIES THE
*  CONDITION SPECIFIED BY THE TWO ARGUMENTS, MASKA AND MASKB.  MASKA
*  SELECTS BITS IN AN APT ENTRY, MASKB SPECIFIES THE VALUES THE
*  SELECTED BITS SHOULD HAVE.  THE ROUTINE FINDS THE 'OLDEST' ENTRY,
*  APTE, FOR WHICH (APTE AND MASKA)=MASKB.  IT RETURNS
*  THIS ENTRY.  IT FAILS IF THERE ARE NO SUCH ENTRIES.
*    THE PAGE LOCK FIELD IS GIVEN SPECIAL TREATMENT.
          INCLUDE APTD, GLOBAL, PROFILE, PMTD;
          DECLARE OLDEST, T, I, AGE, PGL, FLAG;
        ENTRY FIND'OLDEST'PAGE(MASKA, MASKB), FRETURN;
          FLAG ← 0; GOTO OLDST05;
*
        FUNCTION OLDEST'PAGE(MASKA, MASKB), FRETURN;
          FLAG ← 1;
OLDST05:  MASKB ← MASKB A' MASKA;
          PGL ← (-1)@APTPGL A' N' MASKA;
          MASKA ← MASKA V' PGL;
          OLDEST ← 0;
          T ← (1 LSH LAPTUH) V' (-1)$APTUH;
OLDST10:  FOR I ← NAPTE BY -1 TO NAPTE-LDWS+1 DO;
             IF APT[I] A' MASKA=MASKB DO;
                AGE ← (PMT[APT[I]$APTPMT]$PMTRF LSH LAPTUH) V'
                   APT[I]$APTUH;
                (T ← AGE & OLDEST ← I) IF AGE<=T;
             ENDIF;
          ENDFOR;
          IF OLDEST=0 DO;
             FRETURN IF PGL=0;
             MASKA ← MASKA A' N' PGL;
             PGL ← 0;
             GOTO OLDST10;
          ENDIF;
*
          RETURN (APT[OLDEST] IF FLAG ELSE OLDEST);
*

        END;

        PROGRAM GET'APT'ENTRY;
          INCLUDE PROFILE, APTD;
          DECLARE I, FLAG;
*
        ENTRY GET'APT'ENTRY(PMTX), FRETURN;
          FLAG ← 1; GOTO GAP10;
        ENTRY FIND'APT'ENTRY(PMTX), FRETURN;
          FLAG ← 0;
GAP10:    FOR I ← NAPTE BY -1 TO NAPTE-LDWS+1 DO;
             GOTO GAP20 IF APT[I]$APTPMT=PMTX;
          ENDFOR;
          FRETURN;
GAP20:    RETURN(APT[I] IF FLAG ELSE I);

        END;

        PROGRAM DELETE'APT'ENTRY;
          INCLUDE PROFILE, APTD;
          DECLARE APTX, LAST'CWS, LAST'DWS;
*
        ENTRY DELETE'APT'ENTRY(PMTX);
          APTX ← FIND'APT'ENTRY(PMTX//RETURN);
          LAST'CWS ← NAPTE-LCWS+1;
          LAST'DWS ← NAPTE-LDWS+1;
          IF APTX>=LAST'CWS DO;
             APT[APTX] ← APT[LAST'CWS];
             APT[LAST'CWS] ← APT[LAST'DWS];
             APT[LAST'DWS] ← 0;
             LCWS ← LCWS-1;
             LDWS ← LDWS-1;
          ELSEIF APTX>=LAST'DWS DO;
             APT[APTX] ← APT[LAST'DWS];
             APT[LAST'DWS] ← 0;
             LDWS ← LDWS-1;
          ELSE DO;
             PUNT('APT');
          ENDIF;
          RETURN;

        END;

        PROGRAM MAKE'APT'ENTRY;
          INCLUDE PROFILE, APTD;
          DECLARE FIRST'NOT'CWS, FIRST'FREE, APTX;
*
        ENTRY MAKE'APT'ENTRY(APTE), FRETURN;
          DELETE'APT'ENTRY(APTE$APTPMT);
          FRETURN IF LDWS>=NAPTE;
          FIRST'NOT'CWS ← NAPTE-LCWS;
          FIRST'FREE ← NAPTE-LDWS;
          IF APTE$APTCWS DO;
             APT[FIRST'FREE] ← APT[FIRST'NOT'CWS];
             APT[FIRST'NOT'CWS] ← APTE;
             APTX ← FIRST'NOT'CWS;
             LCWS ← LCWS+1;
             LDWS ← LDWS+1;
          ELSEIF APTE$APTDWS DO;
             APT[FIRST'FREE] ← APTE;
             APTX ← FIRST'FREE;
             LDWS ← LDWS+1;
          ELSE DO;
             APTX ← 0;
          ENDIF;
          RETURN APTX;

        END;

        PROGRAM PPDWS;
          INCLUDE PROFILE, SPTD, PMTD, GLOBAL, APTD;
          DECLARE MEC, MEM, IN'DWS, APTE, KEY, STATUS;
          MACRO DWS'FULL ← (LDWS>=OLDWS);
*
        FUNCTION PPDWS(PMTX), FRETURN, MONITOR ← 65;
          KEY ← SPKEY; STATUS ← SPSTATUS;
*  CHECK FOR ERRORS
          FRETURN ('PMI', 110) UNLESS (1<=PMTX AND PMTX<=NPMTE);
          FRETURN('PMC', 121) IF KEY A'
             (PMT[PMTX]$PMTCL V' PMT[PMTX]$PMTAL) = 0;
          GOTO PDWS10;
*  ENTRY POINT FOR MONITOR
        ENTRY MPPDWS(PMTX, KEY, STATUS), FRETURN;
*  MAKE ROOM IN DWS IF NECESSARY
PDWS10:   APTE ← 0;
          IN'DWS ← 1;
          APTE ← GET'APT'ENTRY(PMTX//VALUE IN'DWS ← 0);
          IF DWS'FULL DO;
             IF NOT IN'DWS DO;
                FRETURN('DWF', 133) IF STATUS$DDWSO=0;
                DPDWS(-1//PDWS80: MEC, MEM);
             ENDIF;
          ENDIF;
*  BRING IN THE PAGE AND MAKE APT ENTRY.
          IF (APTE$APTDWS=0 AND PMT[PMTX]$PMTDKA#0) DO;
             GETDP(PMTX//PDWS81:MEC, MEM);
          ENDIF;
          APTE ← APTE V' (-1)@APTUH V' 1@APTDWS V' PMTX@APTPMT;
          MAKE'APT'ENTRY(APTE//VALUE PUNT('APT'));
          RETURN;

*  ATTEMPT TO MAKE ROOM IN DWS FAILED
PDWS80:   FRETURN('RDW', 212) IF (MEC='WSL' OR MEC='PGL' OR
             MEC='DME' OR MEC='DKE' OR MEC='DWE');
          PUNT(MEC);

*  COULDN'T BRING THE PAGE IN
PDWS81:   FRETURN(MEC, MEM) IF (MEC='RNE' OR MEC='DME' OR MEC='DKE');
          PUNT(MEC);

        END;

        PROGRAM PPCWS;
          INCLUDE PROFILE, SPTD, APTD, GLOBAL;
          DECLARE MEC, MEM, APTE, KEY, STATUS, IN'DWS;
          MACRO CWS'FULL ← (LCWS>=OLCWS);
          MACRO IN'CWS ← (APTE$APTCWS);
*
        FUNCTION PPCWS(PMTX), FRETURN, MONITOR ← 66;
          KEY ← SPKEY; STATUS ← SPSTATUS;
          FRETURN('PMI', 110) UNLESS (1<=PMTX AND PMTX<=NPMTE);
          FRETURN('PMC', 121) IF KEY A'
             (PMT[PMTX]$PMTCL V' PMT[PMTX]$PMTAL)=0;
          GOTO PCWS10;
*  ENTRY POINT FOR MONITOR
        ENTRY MPPCWS(PMTX, KEY, STATUS), FRETURN;
PCWS10:   APTE ← 0;
          IN'DWS ← 1;
          APTE ← GET'APT'ENTRY(PMTX//VALUE IN'DWS ← 0);
          IF NOT IN'DWS DO;
             FRETURN('NOD', 208) IF STATUS$DPNOD=0;
             MPPDWS(PMTX,KEY, STATUS//PCWS80: MEC,MEM);
             APTE ← GET'APT'ENTRY(PMTX//VALUE PUNT('APT'));
             PUNT('APT') IF APTE$APTDWS=0;
          ENDIF;
*  MAKE ROOM IN CWS IF NECESSARY
          IF CWS'FULL DO;
             IF NOT IN'CWS DO;
                FRETURN('CWF', 132) IF STATUS$DCWSO=0;
                DPCWS(-1//PCWS81:MEC, MEM);
                APTE ← GET'APT'ENTRY(PMTX//VALUE PUNT('APT'));
             ENDIF;
          ENDIF;
*  UPDATE THE PAGE'S ENTRY IN APT.
          APTE ← APTE V' (-1)@APTUH V' 1@APTCWS;
          MAKE'APT'ENTRY(APTE//VALUE PUNT('APT'));
          RETURN;

*  COULDN'T PUT THE PAGE IN DWS
PCWS80:   FRETURN(MEC, MEM) IF (MEC='DWF' OR MEC='RDW' OR MEC='RNE' OR
             MEC='DME' OR MEC='DKE');
          PUNT(MEC);

*  COULDN'T MAKE ROOM IN CWS
PCWS81:   FRETURN(MEC, MEM) IF (MEC='CWE' OR MEC='WSL');
          PUNT(MEC);


        END;

        PROGRAM DPDWS;
          INCLUDE GLOBAL, PMTD, APTD, PROFILE, SPTD;
          DECLARE APTE, KEY, MEC, MEM;
*
        FUNCTION DPDWS(PMTX), FRETURN, MONITOR ← 67;
          KEY ← SPKEY; GOTO DDWS10;

*  ENTRY POINT FOR MONITOR
        ENTRY MDPDWS(PMTX, KEY), FRETURN;

DDWS10:   GOTO DDWS30 IF PMTX#-1;

*  CHOOSE DWS ENTRY FOR DELETION. TRY TO PICK ONE WHICH ISN'T IN CWS.
          APTE ← OLDEST'PAGE(1@APTCWS,0//DDWS20);
          PUNT('PGL') IF APTE$APTPGL#0;
          PMTX ← APTE$APTPMT;
          GOTO DDWS40;
*   THEY ARE ALL IN CWS.  PICK ANY ONE.
DDWS20:   APTE ← OLDEST'PAGE(0,0//FRETURN('DWE', 159));
          FRETURN('WSL', 130) IF APTE$APTPGL#0;
          PMTX ← APTE$APTPMT;
          GOTO DDWS40;

*  CALLER SPECIFIED ENTRY TO BE DELETED.  CHECK FOR ERRORS.
DDWS30:   FRETURN('PMI', 110) UNLESS (1<=PMTX AND PMTX<=NPMTE);
          FRETURN('PMC', 121) IF KEY A'
             (PMT[PMTX]$PMTCL V' PMT[PMTX]$PMTAL) = 0;
DDWS35:   APTE ← GET'APT'ENTRY(PMTX//RETURN -1);
          FRETURN('PGL', 203) IF APTE$APTPGL#0;

*  RELEASE PAGE FROM CORE AND DRUM.
DDWS40:   IF APTE$APTCWS DO;
             RELCP(PMTX//VALUE PUNT(MEC):MEC, MEM) IF PMT[PMTX]$PMTSF;
             MAKE'APT'ENTRY(APTE A' N' 1@APTCWS//VALUE PUNT('APT'));
          ENDIF;
          IF (APTE$APTDWS AND PMT[PMTX]$PMTDKA#0) DO;
             RELDP(PMTX//DDWS80: MEC, MEM);
          ENDIF;
*  REMOVE ENTRY FROM APT.
          DELETE'APT'ENTRY(PMTX);
          RETURN PMTX;

*  FAILURE RETURN FROM RELDP.  ONLY LEGITIMATE REASON IS A DRUM
*  OR DISK ERROR.
DDWS80:   FRETURN('DME', 213) IF MEC='DRE';
          FRETURN('DKE', 214) IF MEC='KRE';
          PUNT(MEC);

        END;

        PROGRAM DPCWS;
          INCLUDE APTD, PMTD, GLOBAL, PROFILE, SPTD;
          DECLARE APTE, MEC, MEM;
*
        FUNCTION DPCWS(PMTX), FRETURN, MONITOR ← 68;
          IF PMTX=-1 DO;
             APTE ← OLDEST'PAGE(1@APTCWS, 1@APTCWS//FRETURN('CWE',158));
             FRETURN('WSL', 205) IF APTE$APTPGL#0;
             PMTX ← APTE$APTPMT;
          ELSE DO;
             FRETURN('PMI', 110) UNLESS (1<=PMTX AND PMTX<=NPMTE);
             FRETURN('PMC', 121) IF SPKEY A'
                (PMT[PMTX]$PMTCL V' PMT[PMTX]$PMTAL) = 0;
             APTE ← GET'APT'ENTRY(PMTX//RETURN -1);
             RETURN -1 IF APTE$APTCWS=0;
             FRETURN('PGL', 204) IF APTE$APTPGL#0;
          ENDIF;
*  RELEASE PAGE FROM CORE AND UPDATE APT.
          RELCP(PMTX//VALUE PUNT(MEC):MEC, MEM) IF PMT[PMTX]$PMTSF;
          MAKE'APT'ENTRY(APTE A' N' 1@APTCWS//VALUE PUNT('APT'));
          IF PMT[PMTX]$PMTRF DO;
             CLEAR'MAP;
             PMT[PMTX]$PMTRF ← 0;
          ENDIF;
          RETURN PMTX;
*

        END;

        PROGRAM READ'LWS;
          INCLUDE PROFILE, GLOBAL, APTD;
          DECLARE NCODES ← 6;
          DECLARE CHARACTER ARRAY CODES[NCODES] ←
             ('CWS', 'OCW', 'MCW', 'DWS', 'ODW', 'MDW');
          DECLARE POINTER ARRAY PTRS[NCODES] ←
             (@LCWS, @OLCWS, @MLCWS, @LDWS, @OLDWS, @MLDWS);
          DECLARE I, LWS;
        ENTRY READ'LWS(CODE), FRETURN, MONITOR ← 70;
          GOTO RLWS20 IF (0<=CODE AND CODE<NCODES);
          FOR I ← 0 TO NCODES-1 DO;
             (CODE←I & GOTO RLWS20) IF CODES[I]=CODE;
          ENDFOR;
          FRETURN('ARG', 191);
*
RLWS20:   LWS ← $PTRS[CODE];
          RETURN LWS;
*
        ENTRY SET'LWS(CODE, LNGTH), FRETURN, MONITOR ← 71;
          GOTO SLWS20 IF (CODE=0 OR CODE=4);
          FOR I ← 1 BY 3 TO 4 DO;
             (CODE←I & GOTO SLWS20) IF CODES[I]=CODE;
          ENDFOR;
          FRETURN('ARG', 191);
*
SLWS20:   FRETURN('WSL', 192) UNLESS ($PTRS[CODE-1]<=LNGTH AND
                                  LNGTH<=$PTRS[CODE+1]);
          FRETURN('WSL', 192) IF
             (CODE=1 AND LNGTH>OLDWS) OR
             (CODE=4 AND LNGTH<OLCWS);
          $PTRS[CODE] ← LNGTH;
          RETURN;
*

        END;

        PROGRAM AMCREQ;
*  PUT A REQUEST ON AMC QUEUE
          INCLUDE RESMON, SWPD, GLOBAL, PROFILE, ICTD;
          DECLARE NFN, TR, TV, I, REQCODE, RESP, DATA, SWER, WAIT'COUNT;
          DECLARE WAIT'LIMIT ← 64, LONG WAIT'TIME ← (0,30000);
          DECLARE QNO;
*
        FUNCTION SWPREQ(OCTAL ARRAY NODE, SCALAR NFNA), FRETURN;
          REQCODE ← (@NODE[0]).SWRCD;
          QNO ← QNOS[REQCODE];
          WAIT'COUNT ← 0;

*  CHECK AVAILABILITY OF FREE REQUEST NODES
REQ10:    FOR I ← 1 TO SWWLIM DO;
             PROTECT(PRO2);
                GOTO REQ20;
REQ15:       UNPROTECT(PRO2);
*            FRETURN('NFN',NFN) IF NFNA;
          ENDFOR;
          PUNT('NFN');
*  GET AN EMPTY REQUEST NODE FROM THE FREE LIST AND COPY
*    THE REQUEST INTO IT.
REQ20:       TV ← RMQUEU(SWFREL, SWFEQP//REQ15);
             TV[I]←NODE[I] FOR I←0 TO LSWQN-1;
             TV.SWEPRT←@(PRT[PRTI])-RESM IF TV.SWEPRT = 0;
             TV.SWERRCNT ← 0;
             TV.SWEQP ← SWEOQ;
             NFNA ← TV.SWWAKF;
*  PUT REQUEST NODE ON END OF APPROPRIATE REQUEST QUEUE
             PUTQUEU(TV, SWQS[QNO], 1, SWEQP);
             AMCA[0] ← 1 IF QNO=ACTQ;
          UNPROTECT(PRO2);
*  CLEAR THE ERROR WORD IN PRT.
          PROTECT(PRO1);
             PRT[PRTI]$PRACTE ← 0;
          UNPROTECT(PRO1);
*  POKE THE AMC.
          ATTENTION(ATT1);
          RETURN IF QNO#ACTQ;
*  WAIT AND SEE WHAT HAPPENS IF REQUEST IS 'ACTIVATE' TYPE
          FOR I ← 1 TO SWWLIM DO;
             GOTO REQ40 IF AMCA[0]#1;
          ENDFOR;
          PUNT('SNR');* SWAPPER NOT RESPONDING
REQ40:    RESP ← AMCA[0];
          DATA ← AMCA[1];
          RETURN IF RESP=SWSUCCESS;
          AMCA[1] ← 0;
          AMCA[0] ← 0;* RELEASE ACTIVATE

*  REQUEST 'FAILED' - DATA CONTAINS ERROR CODE
          IF DATA=CPWAIT DO;
             PUNT('WTL') IF (WAIT'COUNT ← WAIT'COUNT+1) > WAIT'LIMIT;
             SBLOCK(WAIT'TIME);
             GOTO REQ10;
          ELSEIF DATA=WAITWK DO;
             RETURN IF NFNA=0;
             MBLOCK(AMC);
             PROTECT(PRO1);
                DATA ← PRT[PRTI]$PRACTE;
                PRT[PRTI]$PRACTE ← 0;
             UNPROTECT(PRO1);
             RETURN IF DATA=0;
          ENDIF;
          FRETURN('AME', DATA);
          RETURN;


        END;

        PROGRAM GETCP;
          INCLUDE PMTD, APTD, SWPD, GLOBAL, PROFILE;
          DECLARE ARRAY REQ[LSWQN];
          DECLARE NODE, MEC, MEM;
        ENTRY GETCP(PMTX), FRETURN;
          FRETURN('PMI', 110) UNLESS (1<=PMTX AND PMTX<=NPMTE);
          FRETURN('PME', 128) IF PMT[PMTX]$PMTDKA=0;
*  SEND 'RESERVE PAGE' REQUEST TO AMC.
          NODE ← @REQ[0];
          BSET(NODE, 0, LSWQN);
          NODE.SWUN ← PMT[PMTX]$PMTUN;
          NODE.SWDKA ← PMT[PMTX]$PMTDKA;
          NODE.SWWAKF ← 0;* NO WAKEUP REQUIRED
          NODE.SWRCD ← CRRSP;
          SWPREQ(REQ, 0//GCP80: MEC, MEM);
*  SET 'SCHEDULED FLAG' FOR PAGE
          PMT[PMTX]$PMTSF ← 1;
          RETURN;

*  REQUEST TO AMC FAILED.  POSSIBLE ERROR CODES AND THEIR SIGNIFICANCE
*  ARE:
*  (1) NCHT - NO ENTRY FOR PAGE IN CHT.  THIS MEANS OTHER STEPS MUST
*      BE TAKEN TO GET THE PAGE.  FAIL RETURN.
*  (2) DNCHT - THERE WAS AN ENTRY IN CHT FOR THE PAGE, BUT THE DISK
*      ADDRESS IN IT WAS DIFFERRENT FROM THE ONE WE GOT OUT OF PMT.
*      ANOTHER FAILURE RETURN.
*  (3) SCHOVF - THE PAGE WAS IN CHT WITH THE SAME DISK ADDRESS WE HAD,
*      BUT THE SCHEDULE COUNT FIELD IN THE CHT ENTRY WAS FULL.  PUNT.
GCP80:    FRETURN('NCH', 999) IF MEM=NCHT;
          FRETURN('DNC', 999) IF MEM=DNCHT;
          PUNT('SCO') IF MEM=SCHOVF;
          PUNT('AME');

        END;

        PROGRAM RELCP;
          INCLUDE PMTD, SWPD, GLOBAL;
          DECLARE ARRAY REQ[LSWQN];
          DECLARE MEC, MEM, NODE;
*
        FUNCTION RELCP(PMTX), FRETURN;
*  CHECK FOR ERRORS
          FRETURN('PMI', 110) UNLESS (1<=PMTX AND PMTX<=NPMTE);
RELCP05:  FRETURN('PNS', 112) UNLESS PMT[PMTX]$PMTSF;
*  SEND 'RELEASE PAGE TO DRUM' REQUEST TO AMC.  THIS REQUEST
*  CANNOT FAIL.
RELCP10:  NODE ← @REQ[0];
          BSET(NODE, 0, LSWQN);
          NODE.SWUN←PMT[PMTX]$PMTUN;
          NODE.SWDKA←PMT[PMTX]$PMTDKA;
          NODE.SWWAKF ← 0;* NO WAKEUP REQUIRED
          NODE.SWRCD ← CWRPG;
          SWPREQ(REQ, 0//VALUE PUNT(MEC):MEC, MEM);
*  RESET 'SCHEDULED FLAG' FOR PAGE
          PMT[PMTX]$PMTSF←0;
          RETURN;
*

        END;

        PROGRAM RELDP;
          INCLUDE SWPD, PMTD, GLOBAL, APTD, PROFILE;
          DECLARE ARRAY REQ[LSWQN];
          DECLARE NODE, MEC, MEM, APTE;
*
        FUNCTION RELDP(PMTX), FRETURN;
          FRETURN('PMI', 110) UNLESS (1<=PMTX AND PMTX<=NPMTE);
          FRETURN('PME', 128) IF PMT[PMTX]$PMTDKA=0;
          APTE ← GET'APT'ENTRY(PMTX//VALUE 0);
          FRETURN('PNA', 129) IF APTE$APTDWS=0;* THIS PROCESS ISN'T USING PAGE
          GOTO RDP10;
*  ENTRY POINT FOR PUT'IN'CWS
        ENTRY MRELDP(PMTX), FRETURN;
*  SEND 'DRUM TO DISK TRANSFER' REQUEST TO AMC
RDP10:    NODE ← @REQ[0];
          BSET(NODE, 0, LSWQN);
          NODE.SWUN←PMT[PMTX]$PMTUN;
          NODE.SWDKA←PMT[PMTX]$PMTDKA;
          NODE.SWWAKF ← 1;* REQUEST A WAKEUP
          NODE.SWRCD ← CRDK;
          SWPREQ(REQ, 0//RDP80: MEC, MEM);
          RETURN;

*    THE AMC FAILED TO DO THE TRANSFER FOR SOME REASON.  POSSIBLE VALUES
*  OF MEM AND THEIR SIGNIFICANCE ARE:
*  (1) NINDHT - PAGE NOT FOUND IN DHT.  THIS WE ASSUME TO MEAN THAT WE
*      DON'T HAVE TO RELEASE THE PAGE.
*  (2) DNCHT - PAGE IS IN CHT WITH A DISK ADDRESS DIFFERENT FROM THE ONE
*      WE SPECICIED.  WE ASSUME OUR DISK ADDRESS IS OLD AND WE DON'T
*      NEED TO RELEASE THE PAGE.
*  (3) DKRAS - CLASS CODE CHECK ON DRUM FAILED.  AGAIN WE ASSUME OUR
*      DISK ADDRESS IS OLD AND WE DON'T HAVE TO RELEASE THE PAGE.
*  (4) HERDR - 'HARD ERROR' IN READING FROM THE DRUM.  WE PUNT.
*  (5) SERDR - 'SOFT ERROR' IN READING FROM DRUM.  WE FAIL RETURN.
*  (6) HERDK - 'HARD ERROR' IN REFERENCING THE DISK.  WE PUNT.
*  (7) UNERK - CLASS CODE CHECK ON DISK FAILED AFTER DRUM CHECK
*      SUCCEEDED.  WE PUNT.
*  (8) SERDK - 'SOFT ERROR' IN READING FROM DISK.  WE FAIL RETURN.
RDP80:    PUNT('AMC') UNLESS MEC='AME';
          IF MEM=NINDHT DO;
             RETURN;
          ELSEIF MEM=DNCHT DO;
             RETURN;
          ELSEIF MEM=DKRAS DO;
             RETURN;
          ELSEIF MEM=HERDR DO;
             PUNT('HDE');
          ELSEIF MEM=SERDR DO;
             FRETURN('DRE', 206);
          ELSEIF MEM=UNERK DO;
             PUNT('DHT');
          ELSEIF MEM=SERDK DO;
             FRETURN('KRE', 207);
          ELSE DO;
             PUNT('AME');
          ENDIF;
*

        END;

        PROGRAM GETDP;
          INCLUDE PMTD, APTD, SWPD, GLOBAL, PROFILE;
          DECLARE ARRAY REQ[LSWQN];
          DECLARE MEC, MEM, APTE, NODE;
*
        FUNCTION GETDP(PMTX), FRETURN;
*  CHECK FOR ERRORS
          FRETURN('PMI', 110) UNLESS (1<=PMTX AND PMTX<=NPMTE);
          FRETURN('PME', 128) IF PMT[PMTX]$PMTDKA=0;
          APTE ← GET'APT'ENTRY(PMTX//GDP20);
          RETURN IF APTE$APTDWS;
          GOTO GDP20;
        ENTRY MGETDP(PMTX), FRETURN;
*  SEND 'DISK TO DRUM TRANSFER' REQUEST TO AMC
GDP20:    NODE ← @REQ[0];
          BSET(NODE, 0, LSWQN);
          NODE.SWUN←PMT[PMTX]$PMTUN;
          NODE.SWDKA←PMT[PMTX]$PMTDKA;
          NODE.SWWAKF ← 1;* REQUEST A WAKEUP
          NODE.SWRCD ← CRKD;
          SWPREQ(REQ, 0//GDP80: MEC, MEM);
*
          RETURN;

*  AMC FAILED FOR ONE OF THE FOLLOWING REASONS.
*  (1) UNER - CLASS CODE ERROR READING FROM DISK.  WE ASSUME OUR
*      DISK ADDRESS IS WRONG.
*  (2) DNCHT - DISK ADDRESS IN CHT DIFFERENT FROM THE ONE WE HAVE.
*  (3) DKRAS - UNIQUE NAME ON DRUM DIFFERENT FROM OURS.
*  (4) HERDR - HARD ERROR READING FROM DRUM.
*  (5) HERDK - HARD ERROR READING FROM DISK.
*  (6) SERDK - SOFT ERROR READING FROM DRUM.
GDP80:    FRETURN('RNE', 209) IF (MEM=UNER OR MEM=DNCHT
             OR MEM=DKRAS OR MEM=UNERK);
          FRETURN('DME', 210) IF MEM=HERDR;
          FRETURN('DKE', 211) IF (MEM=HERDK OR MEM=SERDK);
          PUNT('AME');
*

        END;

        PROGRAM CRDKPG;
          INCLUDE SWPD;
          DECLARE OCTAL ARRAY REQ[LSWQN];
          DECLARE MEC, MEM, NODE;
*
        ENTRY CRDKPG(DKA, LONG UNQN), FRETURN;
*  GET A DISK ADDRESS 'NEAR' DKA FROM THE DISK ALLOCATOR
          DKA ← GET'DISK'ADDR(DKA//VALUE PUNT('KBT'));
*  SEND A 'WRITE UNIQUE NAME' REQUEST TO THE AMC
          NODE ← @REQ[0];
          BSET(NODE, 0, LSWQN);
          NODE.SWUN ← UNQN;
          NODE.SWDKA ← DKA;
          NODE.SWWAKF ← 1;* REQUEST A WAKEUP
          NODE.SWRCD ← CRWUN;
          SWPREQ(REQ, 0//CDKP80: MEC, MEM);
          RETURN DKA;

*  AMC FAILED TO WRITE THE UNIQUE NAME FOR ONE OF THE FOLLOWING REASONS.
*  (1) UNER - THE 'NEW' NAME IS ALREADY IN CHT.  PUNT.
*  (2) DKINU - THE DISK PAGE IS NOT FREE (I.E., ITS CLASS CODE IS
*      NON-ZERO.  PUNT.
*  (3) HERDK - THERE WAS A 'HARD' ERROR IN REFERENCING THE DISK.  PUNT.
CDKP80:   PUNT('UNE') IF MEM=UNER;
          PUNT('KBT') IF MEM=DKINU;
          PUNT('DKE') IF MEM=HERDK;
          PUNT('AME');
*

        END;

        PROGRAM DESTROY'PAGE;
          INCLUDE SWPD, ICTD;
          DECLARE ARRAY REQ[LSWQN];
          DECLARE MEC, MEM, NODE;
*
        FUNCTION DESTROY'PAGE (DKA, LONG UNQN), FRETURN;
*  SEND 'DESTROY PAGE' REQUEST TO AMC
          NODE ← @REQ[0];
          BSET(NODE, 0, LSWQN);
          NODE.SWUN← UNQN;
          NODE.SWDKA← DKA;
          NODE.SWWAKF ← 1;* REQUEST A WAKEUP
          NODE.SWRCD ← CRDEST;
          SWPREQ(REQ, 0//DEST80:MEC, MEM);
*  RELEASE PAGE TO DISK ALLOCATOR
          REL'DISK'ADDR(DKA//VALUE PUNT('KBT'));
          RETURN;
*

*  AMC FAILED TO DESTROY THE PAGE FOR ONE OF THE FOLLOWING REASONS.
*  (1) UNER - UNIQUE NAME ON DRUM DIFFERENT FROM GIVEN ONE.  FAIL RETURN.
*  (2) DNCHT - UNIQUE NAME IS IN CHT WITH A DISK ADDRESS DIFFERENT
*      FROM THE GIVEN ONE.  FAIL RETURN.
*  (3) DKRAS - CLASS CODE AT GIVEN DISK ADDRESS DIFFERENT FROM GIVEN
*      UNIQUE NAME.  FAIL RETURN.
*  (4) HERDK - 'HARD' ERROR IN REFERENCING DISK.  FAIL RETURN.
*  (5) UNERK - CLASS CODE CHECK ON DISK FAILED AFTER DRUM CHECK
*      SUCCEEDED.  PUNT.
DEST80:   FRETURN('RNE', 999) IF (MEM=UNER OR MEM=DNCHT OR MEM=DKRAS);
          FRETURN('DKE', 999) IF MEM=HERDK;
          PUNT('DHT') IF MEM=UNERK;
          PUNT('AME');
*

        END;

        PROGRAM PNIC'TRAP;
          INCLUDE RESMON, PMTD, APTD, CHTD, PARD,SPTD,CHTD,PROFILE;
          DECLARE PMTX, SOURCE, SCHEDULED, CCE, IN'CWS, IN'DWS,
                  ON'DRUM, IN'CHT, READ'ERROR, APTE, Q, MEC,
          MEM, PC, APTX;
          DECLARE ARRAY CHTE[LCHTE];

        ENTRY PNIC'TRAP();
          AGE'APS();*  CALL THIS FCN FROM SOMEWHERE ELSE!!

WHY'PNIC:
*  THIS CODE FINDS OUT THE THINGS THAT THE PNIC TRAP-HANDLING
*  ROUTINE NEEDS TO KNOW ABOUT A PAGE THAT THE CPU HAS FOUND TO BE NOT-
*  IN-CORE.  IT SETS UP THE FOLLOWING FLAGS.
*     SOURCE - SET IF TRAP CAME OUT OF MONITOR RING
*     SCHEDULED - SET IF SF IS SET IN THE PAGE'S PMT ENTRY
*     CCE - SET IF CCE IS SET IN THE PAGE'S PMT ENTRY
*     IN'CWS - SET IF CWS IS SET IN THE PAGE'S APT ENTRY
*     IN'DWS - SET IF THE PAGE APPEARS IN APT
*     ON'DRUM - SET IF DWS IS SET IN THE PAGE'S APT ENTRY
*     IN'CHT - SET IF THE PAGE APPEARS IN CHT
*     READ'ERROR - SET IF THE STATUS FIELD IN THE PAGE'S CHT ENTRY
*               INDICATES A DRUM READ ERROR (AND NO OTHER FUNNY STATUS)

          Q ← TPAR;
          PC ← TRSTATE.STPC;
          PMTX ← RDPRMB(PAGENO(Q))$PRMPMT;
          PUNT('PMI') UNLESS (1<=PMTX AND PMTX<=NPMTE);
          SOURCE ← (1 IF MRING(PC) ELSE 0);
*  ABORT IF LOOPING THROUGH CWS.
          IF TRSTATE.INSTD DO;
             PNIC'COUNT ← PNIC'COUNT+1;
*            IF PNIC'COUNT > LWCS DO;
*               TRSTATE.INSTD ← 0;
*               TRAP(TNO(PNIC),Q,SOURCE);
*            ENDIF;
          ELSE DO;
             TRSTATE.INSTD ← 1;
             PNIC'COUNT ← 0;
          ENDIF;
          SCHEDULED ← PMT[PMTX]$PMTSF;
          CCE ← PMT[PMTX]$PMTCCE;
          APTX ← FIND'APT'ENTRY(PMTX//VALUE APTX ← 0);
          APTE ← (APT[APTX] IF APTX#0 ELSE 0);
          IN'CWS ← APTE$APTCWS;
          IN'DWS ← (APTE#0);
          ON'DRUM ← APTE$APTDWS;
          IN'CHT ← 0;
          IF SCHEDULED DO;
             READ'ERROR ← 0;
             RDCHT(PMT[PMTX]$PMTUN, CHTE//WHY30);
             IN'CHT ← 1;
             READ'ERROR ← ((@CHTE[0]).CSTA=RDER);
          ENDIF;
WHY30:    GOTO CASE1 IF NOT (MRING(PC) OR MRING(Q));
          GOTO CASE2 IF MRING(PC) AND NOT MRING(Q);
          GOTO CASE3 IF MRING(PC) AND MRING(Q);
          PUNT('MAC');*

*  CASE 1:  PC AND Q BOTH IN NON-MONITOR RING
CASE1:    IF NOT SCHEDULED DO;
             IF NOT IN'CWS DO;
                TRAP(TNO(PNIC), Q, 0) IF SPSTATUS$DPNIC=0;
                PUT'IN'CWS(PMTX,APTX,APTE//PNC80:MEC, MEM);
                GOTO SWAP'OUT;
             ELSE DO;* IN CWS BUT NOT SCHEDULED
                IF NOT ON'DRUM DO;
                   MPPDWS(PMTX,MKEY,MSTATUS//PNC81:MEC, MEM);
                   GOTO SWAP'OUT;
                ELSE DO;* IN CWS AND ON DRUM BUT NOT SCHEDULED
                   IF CCE DO;
                      TRAP(TNO(NEP), Q, 0);
                   ELSE DO;
                      GOTO SWAP'OUT;
                   ENDIF;
                ENDIF;
             ENDIF;
          ELSE DO;* SCHEDULED
             IF NOT IN'CHT DO;
                PMT[PMTX]$PMTSF ← 0;*RESET SCHEDULED FLAG
                GOTO SWAP'OUT;
             ELSE DO;* SCHEDULED AND IN CHT
                IF READ'ERROR DO;
                   TRAP(TNO(DMRD), Q, 0);
                ELSE DO;* SCHEDULED, IN CHT, NO READ ERROR
                   GOTO SWAP'OUT;
                ENDIF;
             ENDIF;
          ENDIF;

*  FAILURE RETURN FROM MPPCWS.  THIS TRANSLATES INTO SOME VARIETY OF TRAP.
PNC80:    TRAP(TNO(DWSO), Q, 0) IF MEC='RDW';
          TRAP(TNO(NEP), Q, 0) IF MEC='RNE';
          TRAP(TNO(DMRD), Q, 0) IF (MEC='DME' OR MEC='DKE');
          TRAP(TNO(CWSO), Q, 0) IF (MEC='CWE' OR MEC='WSL');
          PUNT(MEC);
*  FAILURE RETURN FROM MPPDWS.  THIS TRANSLATES INTO SOME KIND OF TRAP.
PNC81:    TRAP(TNO(DWSO), Q, 0) IF MEC='RDW';
          TRAP(TNO(NEP), Q, 0) IF MEC='RNE';
          TRAP(TNO(DMRD), Q, 0) IF (MEC='DME' OR MEC='DKE');
          PUNT(MEC);*

*  CASE 2: PC IN MONITOR RING, Q IN NON-MONITOR RING
CASE2:    IF NOT SCHEDULED DO;
             IF NOT IN'CWS DO;
                PUT'IN'CWS(PMTX, APTX, APTE//PNC82:MEC, MEM);
                GOTO SWAP'OUT;
             ELSE DO;* IN CWS BUT NOT SCHEDULED
                IF NOT ON'DRUM DO;
                   MPPDWS(PMTX, MKEY, MSTATUS//PNC83:MEC, MEM);
                   GOTO SWAP'OUT;
                ELSE DO;* IN CWS AND ON DRUM BUT NOT SCHEDULED
                   IF CCE DO;
                      TRAP(TNO(NEP), Q, 1);
                   ELSE DO;
                      GOTO SWAP'OUT;
                   ENDIF;
                ENDIF;
             ENDIF;
          ELSE DO;* SCHEDULED
             IF NOT IN'CHT DO;
                PMT[PMTX]$PMTSF ← 0;*RESET SCHEDULED FLAG
                GOTO SWAP'OUT;
             ELSE DO;* SCHEDULED AND IN CHT
                IF READ'ERROR DO;
                   TRAP(TNO(DMRD), Q, 1);
                ELSE DO;* SCHEDULED, IN CHT, NO READ ERROR
                   GOTO SWAP'OUT;
                ENDIF;
             ENDIF;
          ENDIF;

*  FAILURE RETURN FROM MPPCWS.  THIS TRANSLATES INTO SOME VARIETY OF TRAP.
PNC82:    TRAP(TNO(DWSO), Q, 1) IF MEC='RDW';
          TRAP(TNO(NEP), Q, 1) IF MEC='RNE';
          TRAP(TNO(DMRD), Q, 1) IF (MEC='DME' OR MEC='DKE');
          TRAP(TNO(CWSO), Q, 1) IF (MEC='CWE' OR MEC='WSL');
          PUNT(MEC);
*  FAILURE RETURN FROM MPPDWS.  THIS TRANSLATES INTO SOME KIND OF TRAP.
PNC83:    TRAP(TNO(DWSO), Q, 1) IF MEC='RDW';
          TRAP(TNO(NEP), Q, 1) IF MEC='RNE';
          TRAP(TNO(DMRD), Q, 1) IF (MEC='DME' OR MEC='DKE');
          PUNT(MEC);*

*  CASE 3: PC AND Q BOTH IN MONITOR RING
CASE3:    IF NOT SCHEDULED DO;
             IF NOT IN'CWS DO;
                PUT'IN'CWS(PMTX, APTX, APTE//VALUE PUNT(MEC):MEC, MEM);
                GOTO SWAP'OUT;
             ELSE DO;* IN CWS BUT NOT SCHEDULED
                IF NOT ON'DRUM DO;
                   MPPDWS(PMTX, MKEY, MSTATUS//VALUE PUNT(MEC):MEC, MEM);
                   GOTO SWAP'OUT;
                ELSE DO;* IN CWS AND ON DRUM BUT NOT SCHEDULED
                   IF CCE DO;
                      PUNT('CCE');
                   ELSE DO;
                      GOTO SWAP'OUT;
                   ENDIF;
                ENDIF;
             ENDIF;
          ELSE DO;* SCHEDULED
             IF NOT IN'CHT DO;
                PMT[PMTX]$PMTSF ← 0;*RESET SCHEDULED FLAG
                GOTO SWAP'OUT;
             ELSE DO;* SCHEDULED AND IN CHT
                IF READ'ERROR DO;
                   PUNT('DMR');
                ELSE DO;*SCHEDULED, IN CHT, NO READ ERROR
                   GOTO SWAP'OUT;
                ENDIF;
             ENDIF;
          ENDIF;

SWAP'OUT:
*  AFTER DOING WHATEVER SHOULD BE DONE TO CORRECT THE PAGE FAULT, WE
*  BLOCK.  THIS WILL HAVE THE EFFECT OF FORCING THE SWAPPER TO MAKE AN
*  ATTEMPT TO BRING IN THE MISSING PAGE, AND WILL ALSO GIVE TIME FOR ANY
*  TRANSIENT CONDITIONS (LIKE PAGE IN PROCESS OF BEING DESTROYED) TO
*  STABILIZE.
          SWBLOCK();
          RETURN;


        END;

        PROGRAM PNIM'TRAP;
          INCLUDE TRAPD, GLOBAL, RESMON, SPTD, SPCSD, PROFILE;
          DECLARE Q, PC, PMTX, TARGET'SP, MEC, MEM, SOURCE, BYTENO;
          DECLARE NAME, SPTE;

        ENTRY PNIM'TRAP();
          Q ← TPAR;
          PC ← TRSTATE.STPC;
          BYTENO ← PAGENO(Q);
          PMTX ← RDPRMB(BYTENO)$PRMPMT;
          TARGET'SP ← (SPCS[SPCSL]$CSR0SP IF URING(Q) ELSE
                       SPCS[SPCSL]$CSR1SP IF YRING(Q) ELSE
                       0);
          NAME ← 1 LSH TARGET'SP;
          SOURCE ← (1 IF MRING(PC) ELSE 0);

          GOTO CASE1 IF NOT (MRING(PC) OR MRING(Q));
          GOTO CASE2 IF MRING(PC) AND NOT MRING(Q);
          GOTO CASE3 IF MRING(PC) AND MRING(Q);
          PUNT('MAC');

*  CASE 1: PC AND Q BOTH IN NON-MONITOR RING
CASE1:    TRAP(TNO(MACC), Q, SOURCE) IF TARGET'SP=0;
          TRAP(TNO(PNIM), Q, SOURCE) IF SPSTATUS$DPNIM=0;
          IF PMTX=0 DO;
             PMTX ← MACQPMT(-1, NAME//PNM80:MEC, MEM);
          ENDIF;
          MNPPMT(PMTX, MKEY, MSTATUS//VALUE PUNT(MEC):MEC, MEM);
          GOTO PUT'IN'MAP;

*  CASE 2: PC IN MONITOR RING, Q IN NON-MONITOR RING
CASE2:    TRAP(TNO(MACC), Q, SOURCE) IF TARGET'SP=0;
          IF PMTX=0 DO;
             PMTX ← MACQPMT(-1, NAME//PNM80:MEC, MEM);
          ENDIF;
          MNPPMT(PMTX, MKEY, MSTATUS//VALUE PUNT(MEC):MEC, MEM);
          GOTO PUT'IN'MAP;

*  CASE 3: PC AND Q BOTH IN MONITOR RING
CASE3:    PUNT('PNM');

PUT'IN'MAP:
          SETPRMB(BYTENO, PMTX);
          BYTENO ← BYTENO-64 IF SPT[TARGET'SP]$SPTRING=1;
          SPTE ← @SPT[TARGET'SP];
          SPTE.(PXFLDS[BYTENO]) ← PMTX;
          SPTE.(ROFLDS[BYTENO]) ← 0;
          SPTE.SPTLM ← BYTENO IF BYTENO > SPTE.SPTLM;
          RETURN;

*  FAILURE RETURN FROM ACQPMT IS REASONABLE ONLY IF PMT IS FULL.
PNM80:    TRAP(TNO(PMTO), Q, SOURCE) IF MEC='PMO';
          PUNT(MEC);


        END;

        PROGRAM PUT'IN'CWS;
          INCLUDE GLOBAL, PROFILE, APTD, PMTD, SWPD;
          DECLARE APTX', APTE', PMTX', PMTE', MEC, MEM, DISK;
          MACRO IN'CWS ← (APTE$APTCWS);
          MACRO CWS'FULL ← (LCWS>=OLCWS);
          MACRO LAST'CWS ← (NAPTE+1-LCWS);
          MACRO FIRST'NOT'CWS ← (NAPTE-LCWS);
          MACRO IN'DWS ← (APTE$APTDWS);
          MACRO DWS'FULL ← (LDWS>=OLDWS);
          MACRO LAST'DWS ← (NAPTE+1-LDWS);
          MACRO FIRST'FREE ← (NAPTE-LDWS);

        ENTRY PUT'IN'CWS(PMTX, APTX, APTE), FRETURN;
          DISK ← (0 IF DRUM'SYSTEM ELSE 1);
*  TAKE CARE OF THE CASE WHERE THE DWS BIT HAS BEEN RESET BY AMC
          IF NOT IN'DWS AND APTE#0 DO;
             GETDP(PMTX//GETDP'FAILURE: MEC,MEM) IF DISK;
             APTE$APTDWS ← 1;
          ENDIF;

          GOTO NOT'IN'DWS IF NOT IN'DWS;

*  THE PAGE IS IN DWS BUT NOT IN CWS (OR ELSE WE SHOULDN'T BE CALLING
*  THIS FUNCTION).  THERE ARE TWO CASES, DISTINGUISHED BY WHETHER CWS
*  IS FULL.
          GOTO CWS'NOT'FULL IF NOT CWS'FULL;

*  THE PAGE IS ALREADY IN DWS, BUT CWS IS FULL AND WE HAVE TO MAKE ROOM
          APTX' ← FIND'OLDEST'PAGE(1@APTCWS, 1@APTCWS//FRETURN('CWE',158));
          APTE' ← APT[APTX'];
          FRETURN('WSL',205) IF APTE'$APTPGL#0;
          PMTX' ← APTE'$APTPMT;
          RELCP(PMTX'//VALUE PUNT(MEC): MEC,MEM) IF PMT[PMTX']$PMTSF;
          APT[APTX'] ← APTE V' (-1)@APTUH V' 1@APTCWS;
          APT[APTX] ← APTE' A' N' 1@APTCWS;
          RETURN;

CWS'NOT'FULL:
*  THE PAGE IS IN DWS AND THERE IS ROOM FOR IT IN CWS
          APT[APTX] ← APT[FIRST'NOT'CWS];
          APT[FIRST'NOT'CWS] ← APTE V' (-1)@APTUH V' 1@APTCWS;
          LCWS ← LCWS+1;
          RETURN;
*
NOT'IN'DWS:
*  THE PAGE ISN'T IN EITHER OF THE CORE AND DRUM WORKING SETS.  THERE
*  ARE 4 CASES TO CONSIDER.
          GOTO CASE1 IF CWS'FULL AND DWS'FULL;
          GOTO CASE2 IF CWS'FULL AND NOT DWS'FULL;
          GOTO CASE3 IF NOT CWS'FULL AND DWS'FULL;
          GOTO CASE4 IF NOT CWS'FULL AND NOT DWS'FULL;
          PUNT('EH?');

*  CASE 1: CWS AND DWS BOTH FULL
CASE1:    APTX' ← FIND'OLDEST'PAGE(1@APTCWS, 1@APTCWS//FRETURN('CWE',158));
          APTE' ← APT[APTX'];
          FRETURN('WSL',205) IF APTE'$APTPGL#0;
          PMTX' ← APTE'$APTPMT;
          PMTE' ← @PMT[PMTX'];
          RELCP(PMTX'//VALUE PUNT(MEC): MEC, MEM) IF PMTE'.PMTSF;
          APT[APTX'] ← APT[LAST'CWS];
          APTX' ← LAST'CWS;
          APT[LAST'CWS] ← APTE' A' N' 1@APTCWS;
          LCWS ← LCWS-1;
          IF APTE'$APTDWS AND PMTE'.PMTDKA#0 DO;
             MRELDP(PMTX'//CASE1'ERROR1: MEC,MEM) IF DISK;
          ENDIF;
          IF PMT[PMTX]$PMTDKA#0 DO;
             MGETDP(PMTX//CASE1'ERROR2: MEC,MEM) IF DISK;
          ENDIF;
          APT[APTX'] ← (-1)@APTUH V' 1@APTDWS V' 1@APTCWS V' PMTX@APTPMT;
          LCWS ← LCWS+1;
          RETURN;

CASE1'ERROR1:
          GOTO RELDP'FAILURE;

CASE1'ERROR2:
          APT[APTX'] ← APT[LAST'DWS];
          APT[LAST'DWS] ← 0;
          LDWS ← LDWS-1;
          GOTO GETDP'FAILURE;
*
*  CASE 2: CWS FULL, DWS NOT FULL
CASE2:    APTX' ← FIND'OLDEST'PAGE(1@APTCWS, 1@APTCWS//FRETURN('CWE',158));
          APTE' ← APT[APTX'];
          FRETURN('WSL',205) IF APTE'$APTPGL#0;
          PMTX' ← APTE'$APTPMT;
          RELCP(PMTX'//VALUE PUNT(MEC): MEC,MEM) IF PMT[PMTX']$PMTSF;
          APT[FIRST'FREE] ← APTE' A' N' 1@APTCWS;
          APT[APTX'] ← (-1)@APTUH V' 1@APTDWS V' 1@APTCWS V' PMTX@APTPMT;
          LDWS ← LDWS+1;
          IF PMT[PMTX]$PMTDKA#0 DO;
             MGETDP(PMTX//CASE2'ERROR1: MEC,MEM) IF DISK;
          ENDIF;
          APT[APTX']$APTDWS ← 1;
          RETURN;

CASE2'ERROR1:
          PUNT('SFS') IF PMT[PMTX]$PMTSF;
          APT[APTX'] ← APT[LAST'DWS] V' 1@APTCWS;
          APT[LAST'DWS] ← 0;
          LDWS ← LDWS-1;
          GOTO GETDP'FAILURE;
*

*  CASE 3: CWS NOT FULL, DWS FULL
CASE3:    APTX' ← FIND'OLDEST'PAGE(1@APTCWS, 0//VALUE PUNT('APT'));
          APTE' ← APT[APTX'];
          PMTX' ← APTE'$APTPMT;
          IF APTE'$APTDWS AND PMT[PMTX']$PMTDKA#0 DO;
             MRELDP(PMTX'//CASE3'ERROR1: MEC,MEM) IF DISK;
          ENDIF;
          IF PMT[PMTX]$PMTDKA#0 DO;
             MGETDP(PMTX//CASE3'ERROR2: MEC,MEM) IF DISK;
          ENDIF;
          APT[APTX'] ← APT[FIRST'NOT'CWS];
          APT[FIRST'NOT'CWS] ← (-1)@APTUH V' 1@APTDWS V' 1@APTCWS V'
                               PMTX@APTPMT;
          LCWS ← LCWS+1;
          RETURN;

CASE3'ERROR1:
          GOTO RELDP'FAILURE;
CASE3'ERROR2:
          APT[APTX'] ← APT[LAST'DWS];
          APT[LAST'DWS] ← 0;
          LDWS ← LDWS-1;
          GOTO GETDP'FAILURE;

*  CASE 4: NEITHER CWS NOR DWS FULL
CASE4:    IF PMT[PMTX]$PMTDKA#0 DO;
             MGETDP(PMTX//CASE4'ERROR1: MEC,MEM) IF DISK;
          ENDIF;
          APT[FIRST'FREE] ← APT[FIRST'NOT'CWS];
          APT[FIRST'NOT'CWS] ← (-1)@APTUH V' 1@APTDWS V' 1@APTCWS V'
                               PMTX@APTPMT;
          LCWS ← LCWS+1;
          LDWS ← LDWS+1;
          RETURN;

CASE4'ERROR1:
GETDP'FAILURE:
          FRETURN(MEC,MEM) IF (MEC='RNE' OR MEC='DME' OR MEC='DKE');
          PUNT(MEC);

RELDP'FAILURE:
          FRETURN('DME',213) IF MEC='DRE';
          FRETURN('DKE',214) IF MEC='KRE';
          PUNT(MEC);
        END;

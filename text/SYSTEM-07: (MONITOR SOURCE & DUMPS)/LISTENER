       COMMON    SYSCALLS;

* MCALL DECLARATIONS

        MACRO     ARBMC ← UNKNOWN MONITOR;
       MACRO     INTMC ← INTEGER MONITOR;
       MACRO     STMC ← STRING MONITOR;
       MACRO     LNMC ← LONG MONITOR;
       MACRO     LNLNMC ← LONGLONG MONITOR;

        INTMC     CREATE'MIB ← 190;
       ARBMC     READ'MIBOB'INDEX ← 0;
       ARBMC     READ'MIBOB'NAME ← 1;
       ARBMC     SET'MIBOB'NAME ← 2;
       ARBMC     SET'MIBOB'ACCESS ← 3;
       ARBMC     SET'LOCK'LIST ← 4;
       ARBMC     DELETE'MIBOB ← 5;
       INTMC     CREATE'MIBOB ← 6;
       ARBMC     SET'MIB'ACCESS ← 10;
       INTMC     READ'MIB'ACCESS ← 11;
       ARBMC     SET'MIBOB'VALUE ← 12;
       INTMC     COPY'MIBOB ← 14;* UNIMPLEMENTED
       ARBMC     SET'NO'CHARGE ← 15;*** ???
       INTMC     READ'MIB'SPACE ← 16;
       ARBMC     SET'REF'DATE ← 18;*** ???
       ARBMC     SET'DURABILITY ← 28;*** ???

        INTMC     MOPEN'FILE ← 19;
       ARBMC     MREAD'OFT ← 20;
       ARBMC     SET'OFT'AL ← 21;
       INTMC     MSET'OFT'CL ← 22;
       ARBMC     SET'FILE'LENGTH ← 23;* IMPROVE THIS FOR UTS
       INTMC     CR'FILE'PAGE ← 24;
       INTMC     DEL'FILE'PAGE ← 25;
       INTMC     NEXT'FILE'PAGE ← 26;
       ARBMC     MOVE'PAGE'PMT ← 27;

        INTMC     ACQUIRE'PMT ← 50;
       ARBMC     NEW'PMT'PAGE ← 51;
       ARBMC     CLEAR'PMT ← 53;
       ARBMC     DELETE'PMT ← 54;
       ARBMC     SET'PMT'AL ← 55;
       ARBMC     SET'PMT'CL ← 56;
       ARBMC     SET'PMT'RO ← 57;
       ARBMC     READ'PMT ← 58;
        ARBMC     PUT'PAGE'DWS ← 65;
       ARBMC     PUT'PAGE'CWS ← 66;
       INTMC     DEL'PAGE'DWS ← 67;
       INTMC     DEL'PAGE'CWS ← 68;
       INTMC     READ'LWS ← 70;
       ARBMC     SET'LWS ← 71;

        INTMC     MCREATE'SP ← 90;
       ARBMC     MDESTROY'SP ← 91;
       ARBMC     MREAD'SPT ← 95;
       ARBMC     READ'SPCS ← 96;
       INTMC     MRD'SPT'FIELD ← 97;
       ARBMC     MST'SPT'FIELD ← 98;
       ARBMC     READ'MAP ← 99;
       ARBMC     SET'MAP ← 100;
       INTMC     READ'MAP'BYTE ← 101;
       ARBMC     SET'MAP'BYTE ← 102;
       INTMC     READ'SPS'PARAM ← 106;

        ARBMC     SP'CALL ← 111;
       ARBMC     SP'JUMP ← 112;
       ARBMC     SP'TRAP ← 113;
       ARBMC     TRAP'RETURN ← 114;
       ARBMC     SP'BRANCH ← 115;
       ARBMC     SP'RETURN ← 116;
       ARBMC     JUMP'RETURN ← 117;
       ARBMC     MARK'CALL ← 118;
       ARBMC     DELETE'CALL ← 119;
       ARBMC     MODIFY'CALL ← 120;

        INTMC     COPY'PMT'PROC ← 130;
       INTMC     ACTIVATE'PROC ← 132;
       ARBMC     TRANSFER'TERM ← 133;
       ARBMC     MAKE'DORMANT ← 134;
       ARBMC     INIT'PROC'PAGE ← 135;
       ARBMC     INIT'PROC'MAP ← 136;
       ARBMC     INIT'SPT'MAP ← 137;
       INTMC     READ'PROC'PARAM ← 211;*** ???

        ARBMC     QUIT'BLOCK ← 164;
       INTMC     GET'INT'NO ← 165;
       ARBMC     READ'ICT ← 166;
       ARBMC     BLOCK ← 170;
       ARBMC     SET'ICT ← 172;
       ARBMC     SET'ICT'CL ← 173;
       INTMC     ACQUIRE'ICT ← 174;
        ARBMC     SET'LINE'FIELD ← 180;
       ARBMC     READ'LINE'TABLE ← 181;
       ARBMC     READ'STRING'BRK ← 182;
       ARBMC     WRITE'STRING ← 183;
       ARBMC     READ'WRITE'CM ← 255;

        LNMC      READ'CLOCK ← 210;
       INTMC     READ'PR'PARAM ← 211;
* UCALL DECLARATIONS

        MACRO     ARBUC ← UNKNOWN UTILITY;
       MACRO     INTUC ← INTEGER UTILITY;
       MACRO     CHRUC ← CHARACTER UTILITY;
       MACRO     STUC ← STRING UTILITY;
       MACRO     LNUC ← LONG UTILITY;

        ARBUC     BREAK'POINT ← 0;*             UCALL FOR DEBUGGING PROGRAMS
       STUC      ERRORMSG ← 1;*                RETURN SYSTEM ERROR MESSAGE
       STUC      GET'PARAM ← 2;*               STRIP PARAMETER FROM STRING
       STUC      GET'COM'LINE ← 3;*            GET CURRENT COMMAND LINE FROM UTS
       INTUC     ABRV'LKP ← 4;*                LOOK UP ABBREVIATED NAME IN STARY
       INTUC     CON'ABRV'LKP ← 5;*            CONTINUE SAME IN NEW STARY

        ARBUC     NAME'SEARCH ← 10;*            CONVERT FILE ST TO UTS NAME
       ARBUC     SPECIAL'SEARCH ← 11;*         VARIATION OF ABOVE
       INTUC     CONV'NAME ← 12;*              CONVERT FROM UTS TO MON FILE NAME
       ARBUC     SPREAD'NAME ← 13;*            SPLIT FILE NAME STRING INTO COMP.
       ARBUC     READ'MIBOB'VALUE ← 14;*       READ 'VALUE' OF MIB OBJECT
       ARBUC     DELETE'FILE ← 15;*            DELETE FILE AND CONTENTS
       INTUC     OPEN'FILE ← 16;*              OPEN FILE W/WO LOCKING
       ARBUC     CLOSE'FILE ← 17;*             CLOSE AND UNLOCK FILE
       ARBUC     READ'OFT ← 18;*               READ OFT
       INTUC     READ'OFT'FIELD ← 19;*         READ OFT FIELD
       ARBUC     SET'OFT'CL ← 20;*             SET OFT CONTROL LOCK

        INTUC     CREATE'SSP ← 30;*             CREATE SUBSIDIARY SUB-PROCESS
       INTUC     CREATE'PSP ← 31;*             CREATE PARALLEL SUB-PROCESS
       ARBUC     ATTACH ← 32;*                 ATTACH PI FILE TO SUB-PROCESS
       ARBUC     DESTROY'SP ← 33;*             DESTROY SUB-PROCESSES
       ARBUC     READ'SPT ← 34;*               READ SPT
       INTUC     READ'SPT'FIELD ← 35;*         READ SPT FIELD
       ARBUC     SET'SPT'FIELD ← 36;*          SET SPT FIELD
       STUC      READ'SPNAME ← 37;*            READ SUB-PROC NAME
       ARBUC     SET'SPNAME ← 38;*             SET SUB-PROC NAME
       INTUC     SPNAME'SEARCH ←39;*           LOOK UP SP NAME

        INTUC     CREATE'CIOS ← 40;*            CREATE CONTROL I/O STREAM
       INTUC     READ'CIOS'FIELD ← 41;*        READ CIOS FIELD
       ARBUC     SET'CIOS'FIELD ← 42;*         SET (SOME) CIOS FIELDS
       ARBUC     SET'CIOS'INPUT ← 43;*         SET UP FOR INPUT
       ARBUC     SET'CIOS'OUTPUT ← 44;*        SET UP FOR OUTPUT

        ARBUC     PRINT'STRING ← 45;*           WRITE STRING ON CIOS
       ARBUC     PRINT'CHAR ← 46;*             WRITE (= BUFFER) CHAR ON CIOS
       ARBUC     OUTPUT'CHAR ← 47;*            OUTPUT CHAR (& BUFFER)
       STUC      READ'LINE ← 48;*              READ NEXT INPUT LINE
       STUC      EDIT'LINE ← 49;*              EDIT CURRENT LINE
       CHRUC     READ'CHAR ← 50;*              READ NEXT CHARACTER
       ARBUC     BLOCK'OB'EMPTY ← 51;*         WAIT UNTIL OUT BUFFER IS EMPTY
        STUC      READ'UP'ITEM ← 60;*           READ ITEM FROM USER PROFILE
       STUC      READ'UP'NAMES ← 61;*          READ NAMES OF UP ITEMS
       ARBUC     SET'UP'ITEM ← 62;*            SET (CREATE) VALUE OF UP ITEM
       ARBUC     SET'UP'ACCESS ← 63;*          SET ACCESS TO UP ITEM
       LNUC      FIND'MIB ← 64;*               CONVERT USER NAME/NUMBER TO MIB ADDR
       ARBUC     CREATE'UP'ENTRY ← 65;*        CREATE USER/UP ENTRY
       ARBUC     DELETE'UP'ENTRY ← 66;*        DELETE USER/UP ENTRY

       END;

       COMMON    DECDECS;
*
* SHORT DECLARATION MACROS FOR SPL
*

        MACRO     INT ← DECLARE INTEGER;
       MACRO     PTR ← DECLARE POINTER;
       MACRO     CHR ← DECLARE CHARACTER;
       MACRO     ST  ← DECLARE STRING;
       MACRO     LN  ← DECLARE LONG;
       MACRO     LNLN ← DECLARE LONGLONG;
       MACRO     LB  ← DECLARE LABEL;

        MACRO     UINFL ← DECLARE INTEGER FIELD;
       MACRO     SINFL ← DECLARE INTEGER SIGNED FIELD;
       MACRO     PTRFL ← DECLARE POINTER FIELD;
       MACRO     CHRFL ← DECLARE CHARACTER FIELD;
       MACRO     STFL  ← DECLARE STRING FIELD;
       MACRO     LNFL  ← DECLARE LONG FIELD;
       MACRO     FNFL  ← DECLARE FUNCTION FIELD;

        MACRO     INTARY ← DECLARE INTEGER ARRAY;
       MACRO     PTRARY ← DECLARE POINTER ARRAY;
       MACRO     CHRARY ← DECLARE CHARACTER ARRAY;
       MACRO     STARY  ← DECLARE STRING ARRAY;
       MACRO     LNARY  ← DECLARE LONG ARRAY;
       MACRO     LBARY  ← DECLARE LABEL ARRAY;
       MACRO     FLARY ← DECLARE FIELD ARRAY;
       MACRO     FNARY ← DECLARE FUNCTION ARRAY;

        MACRO     INTARY1 ← DECLARE INTEGER ARRAYONE;
       MACRO     PTRARY1 ← DECLARE POINTER ARRAYONE;

        MACRO     INTFN ← DECLARE INTEGER FUNCTION;

        MACRO     ARBENT ← UNKNOWN ENTRY;
       MACRO     INTENT ← INTEGER ENTRY;
       MACRO     PTRENT ← POINTER ENTRY;
       MACRO     CHRENT ← CHARACTER ENTRY;
       MACRO     STENT ← STRING ENTRY;
       MACRO     LNENT ← LONG ENTRY;
       MACRO     ARYENT ← ARRAY ENTRY;
        MACRO     ARBEXT ← DECLARE UNKNOWN EXTERNAL;
       MACRO     INTEXT ← DECLARE INTEGER EXTERNAL;
       MACRO     PTREXT ← DECLARE POINTER EXTERNAL;
       MACRO     CHREXT ← DECLARE CHARACTER EXTERNAL;
       MACRO     STEXT ← DECLARE STRING EXTERNAL;
       MACRO     LNEXT ← DECLARE LONG EXTERNAL;
       MACRO     ARYEXT ← DECLARE ARRAY EXTERNAL;


        MACRO     LTABLE(F) ← F$FLDWDSP+1;
       SINFL     FLDWDSP(0: 13,23);

* LENGTHS OF NAMES
        INT       LMN ← 4, LTY ← 1, LFN ← LMN+LTY;
       INT       NBY ← 4, LNCH ← 24/NBY, NMNCH ← LMN*NBY,
        NTYCH ← LTY*NBY, NFNCH ← LFN*NBY, NCMCH ← 90;

       END;

       COMMON    MACHINE'DECS; INCLUDE DECDECS;
*
* DECLARATIONS FOR MACHINE-DEPENDENT PROGRAMMING
*

* LOW-G DEFINITIONS
        PTR       STACK'PTR = G'[2], STACK'LIM = G'[3],
        RTRAP'PARAM = G'[5], RTRAP'LOC = G'[4];

* FIELDS IN BLL DESCRIPTOR
        PTRFL     BRDPC(0: 6,23), BRDLR(1: 6,23);

* STATE DEFINTIONS
        INT       PSTLOC ← 0, ASTLOC ← 1, BSTLOC ← 2, CSTLOC ← 3, DSTLOC ← 4,
        XSTLOC ← 5, LSTLOC ← 6, GSTLOC ← 7, ESTLOC ← 8, SSTLOC ← 9,
        LSTATE ← 10;

* FIELDS FOR TRAP DEFINITIONS
        UINFL     ADDR(0: 6,23), SP'TNO(-2), SP'TPAR(-1), BLL'CLASS(0: 3,5),
        UTSE'CLASS(0: 0,1), UTSE'SPTNO(0: 1,5), UTSE'RTNO(0: 2,5);

       END;

       COMMON    COMDECS; INCLUDE DECDECS, SYSCALLS;
*
* COMMON DECLARATIONS FOR CODING
*

* GENERALLY USEFUL MACROS

        MACRO     PTDN(N) ← PTNO(N, 4B7, 10);
       MACRO     PTON(N) ← PTNO(N, 4B7, 8);
       MACRO     NAMSET(S,L,A,B) ← SETUP(S,L,A,B) & S$WP ← S$EP;
       MACRO     EMPTY(S) ← LNGDES(S$RP, S$WP) <= 0;*** WP=RP OR WP=BP?
       MACRO     REPEAT ← WHILE 1 DO;
       MACRO     ENDRPT ← ENDFOR;
       MACRO     FDISP(F) ← RUNTIME'FAILURE() IF F$FLDSTB # 0 AND
        F$FLDSIZE # 24 ELSE F$FLDWDSP;
       UINFL     FLDSTB(0: 8,12), FLDSIZE(0: 3,7);

* ERROR MACROS
        MACRO     NC'PUNT ← RUNTIME'FAILURE();* FOR NORMAL CALLS (EXPRESSIONS)
       MACRO     LF'PUNT ← VALUE NC'PUNT;* FOR LIBRARY FUNCTIONS
       MACRO     SF'PUNT ← LF'PUNT: ERCODE, ERMSNO;* FOR SYSTEM CALLS

* PARAMETRIC CHARACTER DEFINITIONS
        CHR       SCHERALD ← '>' /* SUB-COMMAND HERALD */,
        BELCH ← 303B /* BELL */, NULCH ← 300B /* NULL */,
        NLCH ← 307B /* NEW LINE */,
        SQTCH ← '&'' /* SINGLE QUOTE */,
        DQTCH ← '"' /* DOUBLE QUOTE */,
        SEPCH ← '-' /* SEPARATOR */;

* STRING POINTER FIELDS
        UINFL     BP(0) /* BEGINNING */, RP(1) /* READER */,
        WP(2) /* WRITER */, EP(3) /* END */;
* CHARACTER FIELDS
        UINFL CH0(0: 0,7), CH1(0: 8,15), CH2(0: 16,23);
* BEAD LENGTH FIELD
        UINFL     LENGF(-1: 6, 23);

* FIELDS IN UTILITY FILE NAME
        LNFL      UFNUN(0) /* USER NUMBER/DISK ADDRESS */;
       UINFL     UFNEN(2) /* OBJECT ENTRY-NUMBER */,
        UFNFN(3) /* FILE NAME */, UFNMN(3) /* MAIN NAME */,
        UFNTY(3+LMN) /* TYPE WORD */;

* FIELDS FOR UNO/DKA
        UINFL     UNDKUN(0),
        UNDKDK(1);

        INT       LUFN ← LTABLE(UFNTY);* LENGTH OF UTILITY FILE:NAME

        INT       CB'PMT ← 1;* PMT ADDRESS OF CONTEXT BLOCK
* DECLARATIONS OF COMMON FUNCTIONS

* SPL RUNTIME FUNCTIONS
*ARBEXT    SCOPY, APPEND, CNS, RUNTIME'FAILURE;
       PTREXT    SBASE; INTEXT ARRAYUB, ARRAYLB;* STEXT ST'DESC;
       LNEXT     LONG'ADD, LONG'SUB; INTEXT LONG'LE, LONG'LT;

* STORAGE ALLOCATOR
        PTREXT    STKMAKE;*, MAKE, SETZONE;
*ARBEXT    STORINIT, SELZONE, EXTZONE, FREE, FREEZONE;

       END;

       COMMON    UQNDECS; INCLUDE DECDECS;

* UNIQUE NAME FIELDS
        UINFL     UQNTY(0: 0,1), UQNPMB(0: 0,0), UQNLFB(0: 1,1),
        UQNOWN(0: 2,17), UQNHFN(0: 18,23);
       UINFL     UQNLFN(1: 0,12), UQNLPN(1: 13,23),
        UQNSFN(1: 0,15), UQNSPN(1: 16,23);

       END;

       COMMON    BFSDECS; INCLUDE UQNDECS;

* OBJECT TYPE-CODES
        INT       SIBSFCD ← 0, SIBLFCD ← 1, SIBPRCD ← 2, SIBAKCD ← 3,
        SIBRSCD ← 4, SIBOWCD ← 5, SIBFRCD ← 6,
        SIBSCCD ← 14, SIBLKCD ← 15;

* ACCESS KEY FIELDS
        UINFL     ACK0(0), ACK1(1:0,7), ACKUN(1:8,23);
       INT       NORM'FIL'AC ← 0357B;* P(NO) F(RW) O(OW) - NORMAL ACCESS

       END;

       COMMON    OFTDECS; INCLUDE BFSDECS;

* FIELDS IN OFT
        UINFL     OFTUB(0: 0,0), OFTRB(0: 1,1), OFTWB(0: 2,2), OFTXB(0: 3,3),
        OFTOB(0: 4,4), OFTMIX(0: 6,12),
        OFTAL(0: 15,23);* BETTER CHECK THIS WITH REVISION

        UINFL     OFTCL(1: 15,23),
        OFTOT(2: 0,3), OFTPIB(2: 8,15), OFTPMIB(2: 16,23);
       LNFL      OFTUN(3);

        INT       NOFT ← 16, LOFT ← LTABLE(OFTUN)+1;

       END;

       COMMON    SIBDECS; INCLUDE BFSDECS;
*
* DECLARATIONS FOR SIB
*

* FIELDS IN SIB NAME (SIBN)
        UINFL     SIBNOT(0: 1,4),
        SIBNLN(0: 10,23),
        SIBNAA(1: 1,4), SIBNEN(1: 10,23),
        SIBNMN(2), SIBNFN(2);
       UINFL     SIBNTY(SIBNMN$FLDWDSP+LMN),
        SIBNLL(SIBNTY$FLDWDSP+1: 4,11),
        SIBNAC(SIBNLL$FLDWDSP: 12,23);
       UINFL          SIBNPA(SIBNAC$FLDWDSP: 12,15),
        SIBNFA(SIBNAC$FLDWDSP: 16,19),
        SIBNOA(SIBNAC$FLDWDSP: 20,23);

        INT       LSIBN ← LTABLE(SIBNOA);* LENGTH OF SIBN TABLE

* FIELDS IN SIB VALUE (SIBV)
        UINFL     SIBVOT(0: 1,4),
        SIBVLN(0: 10,23),
        SIBVAA(1: 1,4), SIBVEN(1: 10,23);
       LNFL      SIBFLUN(2);
       UINFL     SIBFLLEN(4),
        SIBFLWD(5),
        SIBFLRD(6);

        LNFL      SIBLKUN(2);
       UINFL     SIBLKEN(4),
        SIBLKMN(5),
        SIBLKTY(5+LMN);

        INT       LSIBFL ← LTABLE(SIBFLRD), LSIBLK ← LTABLE(SIBLKTY),
        LSIBV ← (LSIBFL IF LSIBFL > LSIBLK ELSE LSIBLK);
       INT       MLSIB ← (LSIBV IF LSIBV > LSIBN ELSE LSIBN);

       END;

       COMMON    PMTDECS; INCLUDE UQNDECS;

* FIELDS FOR PMT ENTRY
        LNFL      PMTUN(0);
       UINFL     PMTFL(2: 0,0), PMTDKA(2: 2,23),
        PMTRO(3: 0,0), PMTAL(3: 3,11), PMTCL(3: 15,23);

        INT       NPMT ← 128;* NUMBER OF PMT ENTRIES
       INT       LPMT ← 5;* SIZE OF PMT ENTRY

       END;

       COMMON    SPTDECS; INCLUDE DECDECS;

* FIELDS IN SPCS
        UINFL     SPCSNIS(0: 0,0), SPCSNIC(0: 1,1),
        SPCSCSP(0: 2,5), SPCSPR(0: 6,23),
        SPCS940M(1: 0,0), SPCSR0SP(1: 2,5), SPCSLR(1: 6,23),
        SPCSR1SP(2: 2,5), SPCSGR(2: 6,23);
       LNFL      SPCSIT(3);
       INT       LSPCS ← LTABLE(SPCSIT) + 1;

        INT       NSPT ← 8;

       END;

       COMMON    ATTACHDECS; INCLUDE DECDECS;
*
* DEFINITION OF ATTACH (PI) FILE HEADER
*
        UINFL     ATFMT(0), ATNP(1), ATMAP(3), ATMNM(38),
        ATCUF(43), ATEP(44), ATEG(45);
       UINFL     BYTEC(0: 12,13), BYTEP(0: 16,23);

        INT       FMTCODE ← 0;* VALUE OF CURRENT FORMAT

       END;

       COMMON    ICTDECS; INCLUDE DECDECS;

* FIELDS IN ICT
        UINFL     ICTSRC(0: 0,2) /* SOURCE */,
        ICTACT(0: 3,5) /* ACTION */,
        ICTSPEC(0: 6,10) /* SUB-PROCESS/TRAP */,
        ICTBLK(0: 11,11) /* BLOCKING */,
        ICTCL(0: 15,23) /* CONTROL LOCK */;
       LNFL      ICTTM(1);* REAL/COMPUTE TIME VALUE

        INT       NICT ← 24, LICT ← LTABLE(ICTTM) + 1;

* VALUES FOR SOURCE-ACTION-BLOCK PARAMETER OF SET'ICT
        MACRO     ICT'SAB(S, A, B) ← S @ ICTSRC V' A @ ICTACT V' B @ ICTBLK;
       INT       ICTNULCD ← ICT'SAB(0, 0, 0) /* NULL */,
        ICTBLKCD ← ICT'SAB(1, 0, 1) /* BLOCKING */,
        ICTTRPCD ← ICT'SAB(1, 2, 1) /* TRAP */,
        ICTRTICD ← ICT'SAB(2, 1, 1) /* REAL-TIME INTERRUPR */;

       END;

       PROGRAM   SCOPY; INCLUDE COMDECS;
       PTR       P; ST S, D; STFL A(0);

        ARBENT    SCOPY(STRING @P, S), FRETURN;
       D ← P.A; SETS(D, 0,0); GOTO L;

        ARBENT    APPEND(STRING @P, S), FRETURN;
       D ← P.A;

****      CHECK STRING CHARACTER SIZES FOR COMPATABILITY
L:
        REPEAT;   WCI(GCI(S// VALUE P.WP ← D$WP & RETURN), D// FRETURN); ENDRPT;

       END;

       PROGRAM   CNS; INCLUDE COMDECS;
       INT       N, F, R, T, I, D; PTR P; ST S, B(25); STFL A(0);

        ARBENT    CNS(N, STRING @P, F, R), FRETURN;

        S ← P.A;
       FRETURN IF R < 2 OR R > 36;
       T ← (-N IF F >= 0 AND N < 0 ELSE N);
       B$RP ← B$WP ← B$EP; I ← 0;
LP:    .LDA T; .LSHD -23; .DIV R; .STA T; .STB D;
       WCD(D +('0' IF D < 10 ELSE 'A'-10), B);
       I ← I + 1; GOTO LP IF T # 0;
       WCD('-', B) & I ← I + 1 IF F >= 0 AND N < 0;
       F ← F A' 77B;
       IF F = 0 DO;
           F ← I;
       ELSEIF F <= I DO;
           B$RP ← INCDES(B$EP, -I);
       ELSE DO;
           WCI(' ', S// FRETURN) FOR I ← I + 1 TO F;
       ENDIF;
       WCI(D, S// FRETURN)
        FOR D ← GCI(B// VALUE P.WP ← S$WP & RETURN) WHILE 1;

       END;

       PROGRAM   CSN; INCLUDE COMDECS;
       PTR       P; INT R, F, D, N; ST S; STFL A(0);

        INTENT    CSN(STRING @P, R), FRETURN;

        S ← P.A; FRETURN IF R < 2 OR R > 36;

        IF D ← GCI(S// FRETURN) = '-' OR D = '+' DO;
           F ← (1 IF D = '-' ELSE 0); D ← GCI(S// FRETURN);
       ELSE DO;
           F ← 0;
       ENDIF;

        D ← D - '0' IF D >= '0' AND D <= '9' ELSE
        D ← D - 'A' IF D >= 'A' AND D <= 'Z' ELSE FRETURN;
       FRETURN IF D >= R; N ← D;

        FOR D ← GCI(S// Y) REPEAT;
           D ← D - '0' IF D >= '0' AND D <= '9' ELSE
            D ← D - 'A' IF D >= 'A' AND D <= 'Z' ELSE GOTO X;
           GOTO X IF D >= R; N ← N * R + D;
       ENDRPT;

X:      S$RP ← INCDES(S$RP, -1);
Y:     P.RP ← S$RP; RETURN (-N IF F ELSE N);

       END;

       PROGRAM   LONG'COMPARE; INCLUDE DECDECS;
*
* COMPARE LONG VALUES
*
        DECLARE INTEGER FIELD W0(0);
       PTR       P, Q; INT N;

        INTENT    LONG'COMPARE(INTEGER @P, INTEGER @Q, N);

        RETURN 1 IF P[N].W0 # Q[N].W0 FOR N ← N - 1 BY -1 TO 0;
       RETURN 0;

       END;

       PROGRAM   SBASE; INCLUDE COMDECS;
*
* FIND BASE ADDRESS OF WORD-ORIGINED STRING DESCRIPTOR
*
        ST        S;

        PTRENT    SBASE(S);
       .LDA S$BP; .LDX 1; .ASP; .CXA;
       .CMZ 3B6; .BNE L; .ETR 777777B; RETURN;
L:     RUNTIME'FAILURE();

       END;

       PROGRAM   ST'DESC; INCLUDE COMDECS;
       INT       N, S, O; PTR P; ST X;
       STENT     ST'DESC(N, P, S, O);

        P ← MAKE(S *(N + 24 / S - 1)/ 24) IF P = 0;

        IF S = 8 DO;
           .LDA 44B6;
       ELSEIF S = 6 DO;
           .LDA 40B6;
       ELSEIF S = 12 DO;
           .LDA 50B6;
       ELSEIF S = 24 DO;
           .LDA 54B6;
       ELSE DO;
           RUNTIME'FAILURE();
       ENDIF;

        .IOR P; .XMA O; .LSHA 18; .IOR O; .LDX -1; .ASP; .CXA;
       .STA X$BP; .STA X$RP; .STA X$WP; .LDX N; .ASP; .STX X$EP;
       RETURN X;

       END;

       PROGRAM   AR'DESC; INCLUDE COMDECS;
       INT       N, S, O; PTR P;
       ARYENT    AR'DESC(N, P, S, O);

        N ← N - 1 IF O = 0;
       RUNTIME'FAILURE() IF S > 63 OR S < 1 OR S > 3 AND N > 17777B OR
        N > 377777B OR N < O OR O # 0 AND O # 1;

        P ← MAKE((N + 1 IF O = 0 ELSE N)* S) IF P = 0;

        .LDA S; .SUB 1; .ICP 2; .BGT R'[3]; .IOR 100B; .LSHA 6; .LSHA 11;
       .IOR N; .CPZ O; .BEQ R'[2]; .IOR 1B7; .IOR 6B7; .CAB;
       .LDA P; .IOR 4B6; .XAB; RETURN;

       END;

       PROGRAM   ALENGTH; INCLUDE COMDECS;
*
* COMPUTE ARRAY BOUNDS
*
        PTR       A; UINFL ABW(0);
       INTENT    ARRAYUB(A);
       .LDA A.ABW; .CMZ 2B6; .BNE R'[2]; .ETR 17777B;
       .ETR 377777B; RETURN;

        INTENT    ARRAYLB(A);
       .LDA A.ABW; .ETR 1B7; .ASHA -21; RETURN;

       END;

       PROGRAM   LONG'ARITH; INCLUDE COMDECS;
*
* LONG ARITHMETIC/RELATIONALS
*
        LN        X, Y; UINFL W0(0), W1(1);

        LNENT     LONG'ADD(X, Y);* ADD
       .LDA X$W1, ADD Y$W1, CAB;
       .LDA X$W0, ADC Y$W0; RETURN;

        LNENT     LONG'SUB(X, Y);* SUBTRACT
       .LDA X$W1, SUB Y$W1, CAB;
       .LDA X$W0, SUC Y$W0; RETURN;

        INTENT    LONG'LE(X, Y);* LESS THAN OR EQUALS
       RETURN (1 IF LONG'SUB(X, Y)$W0 <= 0 ELSE 0);

        INTENT    LONG'LT(X, Y);* LESS THAN
       RETURN (1 IF LONG'SUB(X, Y)$W0 < 0 ELSE 0);

       END;

       COMMON ALLOC'DECS;

*
* SPL STORAGE ALLOCATOR
*

* THE BASIC STRUCTURE OF A STORAGE BLOCK IS AS IN THE OLD ALLOCATOR,
* I.E. THE WORD BEFORE THE 0'TH WORD OF A BLOCK CONTAINS THE LENGTH
* OF THE BLOCK (NUMBER OF INFORMATION WORDS +1), A FLAG IN BIT 0
* TO SAY THAT THE BLOCK IS FREE, AND A FLAG IN BIT 1 TO SAY THAT
* THE NEXT LOWER BLOCK IS FREE.
        DECLARE FIELD HIDDEN(-1), HSIZE(-1: 6,23), HFREE(-1: 0,0),
        HFTAG(-1: 1,1), HZTAG(-1: 2,2);
* FREE STORAGE COMES IN ZONES.  A ZONE CONSISTS OF A ZONE HEADER
* AND A CHAIN OF EXTENSIONS.  THE ZONE HEADER CONTAINS: THE BLOCK
* SIZE FOR THE ZONE (0 MEANS ALL SIZES ARE ALLOWABLE), THE OVERFLOW
* ROUTINE, THE EXTENSION LIST, AND THE FREE LIST ROVER.
        DECLARE FIELD FEXT(0), FLIST(2), FUEXT(3), FUNCTION FIELD FOVX(1);
       DECLARE PARAMETER FZHS←4;
* THE FEXT WORD IN EACH EXTENSION POINTS TO THE NEXT ONE.  THIS CHAIN,
* IS TERMINATED BY A -1.  THE FIRST TWO WORDS
* OF A FREE BLOCK ARE USED TO HOLD THE ADDRESS OF THE NEXT FREE
* BLOCK AND THE PREVIOUS FREE BLOCK.  THIS LIST IS CIRCULAR.
        DECLARE FIELD NBLK(0),PBLK(1);
* FOR FIXED-SIZE ZONES, THE ENTIRE FREE LIST AND THE HIDDEN WORDS
* ARE SET UP AT THE TIME AN EXTENSION IS CREATED.  FOR VARIABLE-SIZED
* ZONES, AN EXTENSION IS SET UP AS A SINGLE FREE BLOCK WHICH IS
* SUBDIVIDED AS THE NEED ARISES.  A FIRST-FIT STRATEGY WITH A "ROVER"
* IS USED FOR THE LATTER.  BLOCKS BELOW A MINIMUM SIZE WILL NOT BE CREATED.
        DECLARE PARAMETER MINSIZ←3;

        DECLARE INFINITY'ZONE, CURRENT'ZONE;* ZONE VARIABLES FOR ALLOCATOR

       END;

       PROGRAM   STKMAKE; INCLUDE ALLOC'DECS;
       FIXED;
*
* ALLOCATE LOCAL (STACKED) STORAGE
*
        DECLARE   SP=G'[2], SL=G'[3], BLK, SIZE;

        FUNCTION  STKMAKE(SIZE);

        RUNTIME'FAILURE() IF SP + SIZE >= SL;
       SP ← (BLK ← SP + 1) + SIZE;
       BLK.HIDDEN ← SIZE + 1;
       BSET(BLK, 0, SIZE);
       RETURN BLK;

       END;

       PROGRAM MAKE; INCLUDE ALLOC'DECS;
*
* ASSIGN BLOCK OF SIZE (A) IN ZONE (B)
*
        DECLARE BLK,ROVER,RSIZE,EBLK,ROVEC;

        FUNCTION MAKE(SIZE,ZONE);

        ZONE ← CURRENT'ZONE IF ZONE = 0;
       SIZE ← SIZE + 1;
       GOTO MAKEOV IF ZONE.FLIST<0;
* VARIABLE-SIZED ZONE
        ROVEC←ROVER←ZONE.FLIST;
MAKE1: RSIZE←ROVER.HSIZE;
       IF RSIZE<SIZE+MINSIZ AND RSIZE#SIZE DO;
           GOTO MAKE1 IF (ROVER←ROVER.NBLK)#ROVEC
            ELSE GOTO MAKEOV;
       ENDIF;
       EBLK←(BLK←ROVER)+ROVER.HSIZE;
       EBLK.HFTAG←0;
       IF ROVER.HSIZE=SIZE DO;
* EXACT FIT
            BLK.HFREE←0;
           ZONE.FLIST ← RFB(ROVER, ZONE);
       ELSE DO;
* SPLIT THE BLOCK
            BLK←EBLK-SIZE;
           BLK.HIDDEN ← 1 @ HFTAG + SIZE;
           BLK[-2]←-(ROVER.HSIZE←ROVER.HSIZE-SIZE);
       ENDIF;
* COMMON EXIT
        BSET(BLK, 0, SIZE - 1);
       RETURN BLK;

* OVERFLOW
MAKEOV: BLK ← (ZONE.FOVX)(SIZE-1,ZONE); RETURN BLK;

       END;

       PROGRAM RFB; INCLUDE ALLOC'DECS;
       FUNCTION RFB(RBLK, ZONE);
* SUBROUTINE TO REMOVE A BLOCK FROM THE FREELIST
        IF RBLK.NBLK=RBLK DO;
           RETURN ZONE.FLIST←-1;
       ELSE DO;
           RBLK.NBLK.PBLK←RBLK.PBLK;
           RETURN RBLK.PBLK.NBLK←RBLK.NBLK;
       ENDIF;

       END;

       PROGRAM STORINIT; INCLUDE ALLOC'DECS;
*
* SET UP ZONES
*

        FUNCTION STORINIT(ZONE, SIZE), FRETURN;
       (ZONE ← ZONE + 1).HIDDEN ← SIZE;
       SETZONE(ZONE// FRETURN);
       INFINITY'ZONE ← ZONE;

        FUNCTION SELZONE(ZONE);
       CURRENT'ZONE ← ZONE; RETURN;

       END;

       PROGRAM SETZONE; INCLUDE ALLOC'DECS;
*
* INITIALIZE ZONE
*
        DECLARE FAREA, FUNCTION DUMBFUCN ← OFLOTRAP;

        FUNCTION SETZONE(ZONE), FRETURN;
       FRETURN IF ZONE.HSIZE<FZHS+MINSIZ+4;
       ZONE.HZTAG ← 1;
       ZONE.FOVX ← DUMBFUCN;
       ZONE.FEXT←ZONE.FLIST←-1;
       ZONE.FUEXT ← 0;
       FAREA ← ZONE + (FZHS+1);
       FAREA.HIDDEN←ZONE.HSIZE-(FZHS+1);
       EXTZONE(FAREA, ZONE// VALUE RUNTIME'FAILURE());
       RETURN ZONE;

       END;

       PROGRAM EXTZONE; INCLUDE ALLOC'DECS;
*
* ADD EXTENSION (B) TO ZONE (A)
*
        DECLARE EEXT,EXB,FBLK;

        FUNCTION EXTZONE(EXT, ZONE), FRETURN;
       FRETURN IF EXT.HSIZE<MINSIZ+2;
       EEXT←EXT+EXT.HSIZE;
       EXT.FEXT←ZONE.FEXT;
       ZONE.FEXT←EXT;
       FBLK←EXB←EXT+2;
       EXB.HIDDEN ← (1@HFREE-3) + EXT.HSIZE;
       (EEXT - 1).HIDDEN ← 1 @ HFTAG;
       FPB(FBLK, ZONE);
       RETURN;

       END;

       PROGRAM FREE; INCLUDE ALLOC'DECS;
*
* RELEASE BLOCK (A) TO ZONE (B)
*
        DECLARE EXPTR,EFB,PFB;

        FUNCTION FREE(BLK,ZONE);
       EFB←BLK+BLK.HSIZE;
       ZONE ← CURRENT'ZONE IF ZONE = 0;
       BLK.HFREE←1;
* VARIABLE-SIZED ZONE
* CHECK FOR MERGE WITH NEXT HIGHER BLOCK
        IF EFB.HFREE DO;
           BLK.HIDDEN←BLK.HIDDEN+EFB.HSIZE;
           RFB(EFB, ZONE);
           EFB ← BLK + BLK.HSIZE;
       ENDIF;
* CHECK FOR MERGE WITH NEXT LOWER BLOCK
        IF BLK.HFTAG DO;
           PFB←BLK+(BLK[-2] IF BLK[-2]<0 ELSE -3);
           PFB.HIDDEN←PFB.HIDDEN+BLK.HSIZE;
           RFB(BLK ← PFB, ZONE);
       ENDIF;
* CLEAN UP
        EFB.HFTAG←1;
       EFB[-2]←-BLK.HSIZE;
       FPB(BLK, ZONE);
       RETURN;

       END;

       PROGRAM FPB; INCLUDE ALLOC'DECS;
* SUBROUTINE TO PUT A BLOCK ON THE FREELIST
        DECLARE ZFP,ZNBP;

        FUNCTION FPB(BLK, ZONE);
       ZFP←ZONE.FLIST;
       IF ZFP<0 DO;
           ZONE.FLIST←BLK.NBLK←BLK.PBLK←BLK;
       ELSE DO;
           ZNBP←ZFP.NBLK;
           ZFP.NBLK←ZNBP.PBLK←BLK;
           BLK.NBLK←ZNBP;
           BLK.PBLK←ZFP;
       ENDIF;
       RETURN;

       END;

       PROGRAM FREEZONE; INCLUDE ALLOC'DECS;
*
* DELETE ZONE (A)
*
        DECLARE ZEPTR;

        FUNCTION FREEZONE(ZF,ZF1);
       SELZONE(INFINITY'ZONE) IF ZF = CURRENT'ZONE;
FZONE1:ZEPTR←ZF.FEXT;
       FREE(ZF,ZF1);
       GOTO FZONE1 IF (ZF←ZEPTR)>=0;
       RETURN;

        END;

       COMMON LISTCOM; INCLUDE COMDECS,OFTDECS,ATTACHDECS;

        UINFL  PROCNO(3:11,23),CCNT(5:12,23),PAGE'FL(0:6,12);
       INT    ERMSNO,UTS'KEY ← 1,URING←400000B,MB,CD,FB;
       CHR    ERCODE;
       INTARY FN[LUFN],PN[LUFN];

        MACRO  TFR←FRETURN(ERCODE,ERMSNO): ERCODE,ERMSNO;

        INT    SB,RES;
       LN     LUNDK←(-1,-2);

       END;

       PROGRAM LISTNER; INCLUDE LISTCOM;

        INT    LSN,CHIOCEL,M,LNO,BEGLNO←0,INITLNO←31,ENDLNO←79,
               LSTNO←1,ADDRESS,DATA,ADD'MASK,LST,REMOVE'MASK,
               PLNO,NCHRS;
       LN     DA←(0,0);

        INTARY LINETAB[7],WA[5];
       CHR    CNTLK←13B,CHAR;
       DECLARE PARAMETER CTRL'K'SIG1←174B,  /* 1ST SIGNATURE, CTRL K */
                         CTRL'K'SIG2←003B,  /* 2ND SIGNATURE, CTRL K */
                        CTRL'K'SIG3←360B,   /* 3RD SIGNATURE, CTRL K */
                         MAIN'TABLE'BASE←5140B,  /* CHIO MAIN TABLE */
                         LOC'DEV'BASE←6250B,     /* CHIO LOC. DEVICE TBL */
                         REL'COMPENSATION←664B3, /* FOR THE MONITOR */
                         READ←0, WRITE←1,
                         NICP1←6376B+REL'COMPENSATION,
                         NICP2←6416B+REL'COMPENSATION;
       DECLARE FIELD DTYPE(0:18,23),CLINE(0:12,23),CBITS(0:0,17);
       ST      ST1(2),PRO'NAM'ST1(6:),CHST(22),ST2;
       ST   JUDY← 6"HP-COMM         ";


        INT   I,OFTX1,N,PMT1,PM;
       PTR   PTR1,PT;
       ST    FMS(64:12),WS,SMS(64:12);
       UINFL CCNTFL(0: 2,23);



        ENTRY LSTNR();

* ATTACH INITIALIZER

        M ← 4B7 RSH (CHIOCEL ← GET'INT'NO ('CHI'//SF'PUNT));
       I ← ACQUIRE'PMT(-1//SF'PUNT);
       NEW'PMT'PAGE(I//SF'PUNT);
       SET'MAP'BYTE(-1,1,I//SF'PUNT);


        ACQUIRE'ICT(CHIOCEL//SF'PUNT);*ACQUIRE CHIO INTERUPT CELL
       SET'ICT(CHIOCEL,1B4,0,DA//SF'PUNT);
       ACQUIRE'ICT(LNO ← GET'INT'NO ('QT'//SF'PUNT)//SF'PUNT);
       SET'ICT (LNO,1B4,0,DA//SF'PUNT);
       M ← M V' (4B7 RSH LNO);



        FOR LNO ← BEGLNO,LNO+2 WHILE LNO <= INITLNO DO;
           SET'LINE'FIELD (LNO,'BWS',10001B//SF'PUNT);
       ENDFOR;
       SET'LINE'FIELD(38,'BWS',2B4+2//SF'PUNT);
       INITL();* SHORTEN STACK UPON RETURNING FROM HENRY


* CREATE CONSOLE PROCESS

        CONV'FNAME(-1,-2,JUDY,6'PROC',PN);
       DESTROY'PROC(LUNDK,UTS'KEY);
       CREATE'MIBOB(PN,SIBPRCD,UTS'KEY//HR:ERCODE,ERMSNO);
       SET'MIBOB'ACCESS(PN,357B,UTS'KEY//SF'PUNT);
HR:    CR'PROC(PN,"",UTS'KEY//SF'PUNT);
       ACTIVATE'PROC(PN,0,RES,UTS'KEY//SF'PUNT);

*
* ACQUIRE SYSTEM PRIVILEGES
*
        MST'SPT'FIELD(-1,'SB',MRD'SPT'FIELD(-1,'SB'//ENDLOP:
                      ERCODE,ERMSNO) V' 2B7//ENDLOP:ERCODE,ERMSNO);
*
* GET OUR PRTI
*
        LST←READ'PR'PARAM('PRT'//SF'PUNT);
*
* FINALLY, START THE LISTENING LOOP.
*
RESTART:FOR LNO←BEGLNO,LNO+2 WHILE LNO<=ENDLNO DO;
           READ'LINE'TABLE(LNO,LINETAB//ENDLOP:ERCODE,ERMSNO);
           IF LINETAB[0]$PROCNO=LST DO;  /* HANDLE ONLY OUR LINES */
              READ'STRING'BRK(LNO,-1,1,CHST:ST2,NCHRS//ENDLOP:ERCODE,ERMSNO);
              IF NCHRS$CCNTFL # 0 DO;
RD'L1:           READ'FROM'LINE(LNO,CHST,1:ST2//ENDLOP);
                 GET'CHAR(ST2,LNO,CHST:CHAR,ST2//RD'L1);
RD'L3:           IF (CHAR A' 177B) = CNTLK DO;
                    SET'LINE'FIELD(LNO,'QIT',CHAR//ENDLOP:ERCODE,ERMSNO);
                    SCOPY(PRO'NAM'ST1,"EP"//ENDLOP);
                    CNS(LNO/2,PRO'NAM'ST1,0,10//ENDLOP);
   
* CREATE, OPEN, INITIALIZE AND ACTIVATE  PROCESS "PRO'NAM'ST"
*   SEND LINE NO. AND MESSAGE 'ENTER'
   
                    CONV'FNAME(-1,-2,PRO'NAM'ST1,6'PROC',PN);
HR3:                CREATE'MIBOB(PN,SIBPRCD,UTS'KEY//HR2:ERCODE,ERMSNO);
                    SET'MIBOB'ACCESS(PN,357B,UTS'KEY//HR2:ERCODE,ERMSNO);
                    CR'PROC(PN,"ENTER",UTS'KEY//HR2:ERCODE,ERMSNO);
                    ACTIVATE'PROC(PN,LNO RSH 1,RES,UTS'KEY
                                  //HR2:ERCODE,ERMSNO);
                 ELSE DO;
                    GOTO RD'L1 IF (CHAR A' 375B) # CTRL'K'SIG1;
                    GET'CHAR(ST2,LNO,CHST:CHAR,ST2//RD'L1);
                    GOTO RD'L1 IF (CHAR A' 373B) # CTRL'K'SIG2;
                    GET'CHAR(ST2,LNO,CHST:CHAR,ST2//RD'L1);
                    GOTO RD'L1 IF (CHAR A' 360B) # CTRL'K'SIG3;
                    ADDRESS←(LNO/2)*4+MAIN'TABLE'BASE+REL'COMPENSATION;
                    READ'WRITE'CM(ADDRESS,DATA,READ:DATA//ENDLOP);
                    DATA$DTYPE←2; /* SET DEVICE TYPE TO 2 (110 BPS) */
                    READ'WRITE'CM(ADDRESS,DATA,WRITE//ENDLOP);
                    FOR PLNO←0 TO 23 DO;
                       ADDRESS←(PLNO*2)+1+LOC'DEV'BASE+REL'COMPENSATION;
                       READ'WRITE'CM(ADDRESS,DATA,READ:DATA//ENDLOP);
                       GOTO RD'L2 IF DATA$CLINE = LNO;
                    ENDFOR;
                    GOTO ENDLOP;
RD'L2:              ADD'MASK←4B7 RSH PLNO;
                    REMOVE'MASK←N' ADD'MASK;
                    READ'WRITE'CM(NICP2,DATA,READ:DATA//ENDLOP);
                    READ'WRITE'CM(NICP2,DATA V' ADD'MASK,WRITE//ENDLOP);
                    READ'WRITE'CM(NICP1,DATA,READ:DATA//ENDLOP);
                    READ'WRITE'CM(NICP1,DATA A' REMOVE'MASK,WRITE//ENDLOP);
                    IF CHAR A' 4B = 4B DO;
                       CHAR←213B;
                    ELSE DO;
                       CHAR←13B;
                    ENDIF;
                    GOTO RD'L3;
                 ENDIF;
              ELSEIF LINETAB[0]$CBITS # 240401B DO;
                 ADDRESS←(LNO/2)*4+MAIN'TABLE'BASE+REL'COMPENSATION;
                 DATA←24040100B V' LINETAB[0]$DTYPE;
                 READ'WRITE'CM(ADDRESS,DATA,WRITE//ENDLOP);
                 READ'WRITE'CM(ADDRESS+1,213B,WRITE//ENDLOP);
              ENDIF;
           ENDIF;
ENDLOP: ENDFOR;

       BLOCK(M//RESTART:ERCODE,ERMSNO);
       GOTO RESTART;

HR2:   DELETE'MIBOB(PN,UTS'KEY//ENDLOP:ERCODE,ERMSNO);
       GOTO HR3;


        ENTRY     RUNTIME'FAILURE();

STOP:   GOTO STOP;

       END;

       PROGRAM AUX'LSTNR'1; INCLUDE LISTCOM;

       DECLARE INTEGER I,LNO,N,NCHRS;
       DECLARE STRING STR1,STR2;
       DECLARE FIELD CCNTFL(0:2,23);

       FUNCTION READ'FROM'LINE(LNO,STR1,N), FRETURN;
       FOR I←0 TO N DO;
          READ'STRING'BRK(LNO,-1,0,STR1:STR2,NCHRS//CAN'T:ERCODE,ERMSNO);
          (RETURN STR2) IF NCHRS$CCNTFL#0;
       ENDFOR;

CAN'T: FRETURN;

       END;

       PROGRAM AUX'LSTNR'2; INCLUDE LISTCOM;

       DECLARE INTEGER CHAR,LNO;
       DECLARE STRING STR1,STR2;

       FUNCTION GET'CHAR(STR2,LNO,STR1), FRETURN;
GET'1: IF CHAR←GCI(STR2//GET'10) =37B DO;
GET'2:    CHAR←GCI(STR2//GET'20)-40B;
       ENDIF;
       RETURN (CHAR,STR2);

GET'10: READ'FROM'LINE(LNO,STR1,20:STR2//FRETURN) & GOTO GET'1;
GET'20: READ'FROM'LINE(LNO,STR1,20:STR2//FRETURN) & GOTO GET'2;

       END;

       PROGRAM CREATE'PROCESS; INCLUDE LISTCOM;


        INT  ATF'PAGE,ATF'PMT,ATP'PAGE,ATP'PMT;
       INT       N;
       INT    LST;
       PTR  ATF'PTR,ATP'PTR;
       INT    UUNO←-1,UDKA←-2;
       ST   UST←6"UTILITY         ";
       INTARY UFN[LUFN],PN;
       INTARY PG;
       INTARY MESAGE[30];
       INT    POFT,I,RING←1,SB,UOFT,PMT',FB;
       INT    UN,DK;

        LBARY  ERROR[5]←(ER1,ER2,ER3,ER2,ER5);

        ST     FMS(32: 12),SMS(32: 12),WS,MESSTR;

        INT    UEP←403012B,UG←403000B;
       INT    E←0,UNO←-1,DKA←-2,STRT←0,K;
*  THIS MUST BE CHANGED IN THE NEAR FUTURE TO PICK UP THE
*    GROUP OWNER.

        ENTRY  CR'PROC(PN,MESSTR,K),FRETURN;



        ACQUIRE'PMT(-1:ATF'PMT//SF'PUNT);
       ATF'PAGE← GET'MAP'BYTE(//SF'PUNT);
       SET'MAP'BYTE(-1,ATF'PAGE,ATF'PMT//SF'PUNT);
       ATF'PTR←ATF'PAGE@PAGE'FL+URING;
*PN    =PROCESS NAME IN FILE NAME ARRAY FORMAT

*UFN   =UTILITY FILE NAME
*PNSTR =PROCESS NAME STRING
*MESSTR=MESSAGE STRING

*WORRY ABOUT CONVERTING KEY
*FILE MUST ALREADY BE CREATED
        I←0; ERCODE←'NUT';ERMSNO←32;
       MOPEN'FILE(-1,PN,1,K:POFT//ER: ERCODE,
        ERMSNO);
       I←I+1;*I=1
       CONV'FNAME(-1,-2,UST,6'PIF ',UFN);
       MOPEN'FILE(-1,UFN,1,K:UOFT//NC'PUNT:ERCODE,ERMSNO);
       I←I+1;*I=2

        MOVE'PAGE'PMT(UOFT,0,ATF'PMT//NC'PUNT:ERCODE,ERMSNO);

        I←I+1;*I=3

        NAMSET(WS,32,@(ATF'PTR.ATMAP),12);
       SCOPY(FMS,WS//LF'PUNT);
       CLEAR'PMT(ATF'PMT//SF'PUNT);
       I←I+1;*I=4
       INIT'SPT'MAP(POFT,RING,K//SF'PUNT);

        ACQUIRE'PMT(-1:SB//NC'PUNT:ERCODE,ERMSNO);
       I←1+1;
       ATP'PAGE←GET'MAP'BYTE(//SF'PUNT);
       SET'MAP'BYTE(-1,ATP'PAGE,SB//NC'PUNT:ERCODE,ERMSNO);
       ATP'PTR←ATP'PAGE@PAGE'FL+URING;

        FB←GCI(FMS//NC'PUNT);
       FB←FB$BYTEP;
       GOTO ER2 IF FB#1 ;*ADD 2ND CHECK LATER

        MOVE'PAGE'PMT(UOFT,FB,SB//NC'PUNT:ERCODE,ERMSNO);
       PG ← AR'DESC(1000B,ATP'PTR+3000B);

        INIT'PROC'PAGE(POFT,PMT'←CB'PMT,3000B,1000B,PG//NC'PUNT:ERCODE,ERMSNO);
       WS←ST'DESC(90,@MESAGE[0],8,0);
       WCI(LENGTH(MESSTR),WS//LF'PUNT);
       APPEND(WS,MESSTR//LF'PUNT);
       INIT'PROC'PAGE(POFT,PMT'←CB'PMT,2018,30,MESAGE//NC'PUNT:
        ERCODE,ERMSNO);
       WCI(PMT',SMS//LF'PUNT);
       CLEAR'PMT(SB//SF'PUNT);

        FOR FB←GCI(FMS//DONE)REPEAT;
           CD←FB$BYTEC;FB←FB$BYTEP;
           IF CD=0 DO;
               PMT'←0;
           ELSE DO;
               IF CD = 1 DO;
                   MOVE'PAGE'PMT(UOFT,FB,SB//NC'PUNT:ERCODE,ERMSNO);

                    COPY'PMT'PROC(POFT,SB:PMT'//NC'PUNT:ERCODE,ERMSNO);
               ELSE DO;
                   CR'FILE'PAGE(POFT,SB:PMT'//NC'PUNT:ERCODE,ERMSNO);
                   IF CD =3 DO;
                       MOVE'PAGE'PMT(UOFT,FB,ATF'PMT//NC'PUNT:ERCODE, ERMSNO);
                       CR'FILE'PAGE(POFT,SB:PMT'//ERROR2:ERCODE,ERMSNO);
                       BCOPY(ATP'PTR,ATF'PTR,4000B);
                       CLEAR'PMT(ATF'PMT//SF'PUNT);
                   ENDIF;
               ENDIF;
           ENDIF;
           WCI(PMT',SMS//LF'PUNT);
           CLEAR'PMT(SB//SF'PUNT) IF PMT' # 0;
       ENDRPT;
DONE:  DELETE'PMT(SB//SF'PUNT);
       DELETE'PMT(ATF'PMT//SF'PUNT);
       I←4;
       INIT'PROC'MAP(POFT,SMS//NC'PUNT:ERCODE,ERMSNO);
       MSET'OFT'CL(POFT,0//SF'PUNT);
       MSET'OFT'CL (UOFT,0//SF'PUNT);
       RETURN;*CALLING PROCESS MUST ACTIVATE NEW PROCESS

ERROR2: CLEAR'PMT(ATF'PMT//SF'PUNT);

ER5:    DELETE'PMT(SB//SF'PUNT);
       GOTO ER2;
ER3:   CLEAR'PMT(ATF'PMT//SF'PUNT);

ER2:    MSET'OFT'CL(POFT,0//SF'PUNT);
ER1:   MSET'OFT'CL(UOFT,0//SF'PUNT);
ER:    FRETURN (ERCODE,ERMSNO);

       END;

       PROGRAM MISC'LSTNR; INCLUDE COMDECS, OFTDECS;


        MACRO     TFR←FRETURN(ERCODE,ERMSNO):ERCODE,ERMSNO;

        INT    K,TP,ERMSNO;
       CHR  ERCODE;
       INTARY PN, SF[LUFN];

        ST     NAME'ST,WS;

        INT    STRT←0,UN,DK,LMIB←128,INDEX,NAMEL←5;
       LN     LUNDK;

        INT DUM1,DUM2,LAST←6;
       INT       PM,MB,PT,UTS'RING←0;
       UINFL     PAGE'FL (0:6,12);

        ENTRY  CONV'FNAME(UN,DK,NAME'ST,TP,PN);
       BSET(@PN[0],0,LUFN);
       WS←ST'DESC(16,@PN[3],6,0);
       SCOPY(WS,NAME'ST//LF'PUNT);
       PN[STRT]←UN;
       PN[STRT+1]←DK;
       PN[STRT+7]←TP;
       RETURN;

        ENTRY  DESTROY'PROC(LUNDK,K);
       FOR INDEX←0,INDEX+1 REPEAT;

            BSET(@SF[0],0,LUFN);

            READ'MIBOB'INDEX(LUNDK,NAMEL,SF,INDEX,K//VALUE
            (GOTO ENDMIB IF ERCODE = 'MOB' ELSE GOTO LOOP):
            ERCODE, ERMSNO);

            IF SF[LAST]=6'DEST' DO;
               BCOPY (@SF[3],@SF[2],5);
               SF[0]←-1;
               SF[2] ← SF[1];
               DELETE'MIBOB(SF,K//SF'PUNT);
           ENDIF;
LOOP:  ENDFOR;
ENDMIB:RETURN;

        ENTRY     GET'MAP'BYTE(),FRETURN;

        FOR MB ←0,MB+1 WHILE MB < 28 DO;
           RETURN(MB) IF READ'MAP'BYTE(-1,MB//TFR) = 0;
       ENDFOR;
       NC'PUNT;

       END;

       PROGRAM GT'PLACE; INCLUDE LISTCOM;
       INT    PM,UTS'RING←0;
       PTR    PT;

        ENTRY   GET'PLACE(),FRETURN;

        ACQUIRE'PMT(-1:PM//TFR);
       GET'MAP'BYTE(:MB//TFR);
       PT ← MB@PAGE'FL+UTS'RING;
       SET'MAP'BYTE(-1,MB,PM//TFR);
       RETURN(PM,PT);

       END;

       COMMON STACK'ASG; INCLUDE MACHINE'DECS;
       INT LSTACK ← 600;
       INTARY STK[LSTACK];
       PTR STKP ← @STK[0], STKL ← @STK[LSTACK-1];

        MACRO     RNTE(A,B) ← (A + 100B,0,0,0,B);

        INTARY    RNT[4:5] ← (RNTE(7,16),RNTE(8,17),RNTE(9,18),(-1,0,0,0,0));
       PTR       RNTP = G'[7] ← @RNT[0];

       END;

       PROGRAM MAINMAIN; INCLUDE LISTCOM, MACHINE'DECS, STACK'ASG;

        ENTRY MAIN(),SP'ENTRY←2;

        STACK'PTR ← STKP; STACK'LIM ←STKL;
       LSTNR();

       END;

       COMMON INTERCOM; DECLARE INTCEL;

       END;

       PROGRAM INITIALIZE; INCLUDE COMDECS; INCLUDE INTERCOM;


        INT    OFTX ,I,SPN,TAPE1,TAPE2,DLEN,PMT2,NNN,RSP;
       INTARY PMTX[2],INBUF,FN[LUFN],TA[LUFN];
       ST     STB(16: 12), WS;
       UINFL  PAG'FL(0:6,12), UE ( 0:18,18);
       PTRARY PTR'ARY[2];

        UINFL  FTYPE(1:0,3),FUSER(1:6,23),LHEADER(1:0,5),
        FEOF(0:1,1),FRECORDN(0:2,12),WORDN(0:13,23),
        FUSMIBAD(2),PG(0),LLK(8:9,11), HRCK(0:0,23);

        INT    SYSUSR←1,MIBAD,OFT1←1,ERMSNO,EOF,W2,MODE,WC,PGNO;

        CHR    ERCODE;

        INT    NOWDS,RNO,TU←0,USRR←400000B,HLEN;

        PTR    POINT,PTR1,PTR2;
       INT    FUSR,LHDR,DKA,PMT1,FL,PAGESIZE←2048,STFLG;
       INTARY INBUF2,DUMARY1,DUMARY2;

        ENTRY  INITL();
       INTCEL←ACQUIRE'ICT(-1//SF'PUNT);

        FOR I←0,I+1 WHILE I<=1 DO;
           ACQUIRE'PMT(-1:PMT1//SF'PUNT); PMTX[I]←PMT1;
       ENDFOR;

*GET MAP WORDS

        FOR I←0,I+1 WHILE I< 2 DO;
           FOR SPN← 0,SPN + 1 WHILE SPN <= 31 DO;
               IF (NNN ← READ'MAP'BYTE(-1,SPN//SF'PUNT))= 0 DO;
                   PTR'ARY [I]← SPN @ PAG'FL + USRR;
                   SET'MAP'BYTE (-1,SPN,PMTX[I]//SF'PUNT);
                   GOTO ENDLOOP;
               ENDIF;
           ENDFOR;
ENDLOOP:ENDFOR;


ENGH:   INBUF←AR'DESC(4000B,PTR'ARY[0]);
       INBUF2←AR'DESC(4000B,PTR'ARY[1]);
       PTR1←PTR'ARY[0];
       PTR2←PTR'ARY[1];
       PMT1←PMTX[0]; PMT2←PMTX[1];

        NEW'PMT'PAGE(PMT1//SF'PUNT);

* READ  TRAILER, TAPE MARK , HEADER, TAPEMARK
*        MORE CHECKING WILL BE DONE ON LABELS LATER.

* REWIND PATCH
        SEND'COM(3,0,1,0);
       GRSPO(:RSP,TAPE1,TAPE2,DLEN// SF'PUNT);

        MODE←15B;*556 BPI,SET DEN, EVEN, OFF OFF
       WC ←80;
       SEND'COM(4,TU,MODE,0);
BAK:   GRSPO(:RSP,TAPE1,TAPE2,DLEN//SF'PUNT);
*          SEND'COM(19,TU,0,0);
*          GRSPO(:RSP,TAPE1,TAPE2,DLEN//SF'PUNT);
        GOTO BAK IF RSP = 27;
       NC'PUNT IF RSP # 31;

*READ TAPE
        READ'TAPE(INBUF,WC:TAPE1,TAPE2,DLEN);

        NC'PUNT IF DLEN # 80 ;
       GOTO SHORT;
       NC'PUNT IF PTR1.HRCK # 61353306B;

        READ'TAPE (INBUF,WC:TAPE1,TAPE2,DLEN);
       NC'PUNT IF TAPE2$UE  # 1;
* THIS SHOULE  BE TAPE MARK BEFORE HEADER LABEL.

        READ'TAPE (INBUF,WC:TAPE1,TAPE2,DLEN);

*THIS SHOULD BE HEADER
        NC'PUNT IF PTR1.HRCK # 62142331B;

*READ TAPE MARK
SHORT:  READ'TAPE (INBUF,WC:TAPE1,TAPE2,DLEN);
       NC'PUNT IF TAPE2$UE # 1;





*IF WE GET HERE WE HAVE READ ALL LABELS

        WC←8192;* NO OF BYTES IN A PAGE
       MODE←12B;
* WILL EVENTUALLY BE 16B
        SEND'COM(4,TU,MODE,0);
       GRSPO(:RSP,TAPE1,TAPE2,DLEN//SF'PUNT);
* LATER DO A SEND COM 19 AND CHECK FOR 31
*SET MODE TO BINARY
NEWRD:  STFLG←0;W2←0;
NEWRDRD:READ'TAPE(INBUF,WC:TAPE1,TAPE2,DLEN);
       GOTO DONE IF TAPE2$UE=1;
NEWF:  RNO←PTR1.FRECORDN;
       NOWDS←PTR1.WORDN-1;
       FUSR←PTR1.FUSER;
       LHDR←PTR1.LHEADER+ W2;
       EOF ← PTR1.FEOF; GOTO HERE IF STFLG=1;
       I←0;STFLG←1;
       FOR POINT←PTR1+3,POINT+1 WHILE I< 5  DO;
           FN[I+3]←POINT.PG;
           I←I+1;
       ENDFOR;

*      GOTO OTHER IF FUSR#SYSUSR;
*          GO FIND OR CREATE NEW MIB
*          READ DKA
*          RIGHT NOW USE DEFAULT OPTION
        DKA←-2;
       NC'PUNT IF RNO#0;

        FN[0]←-1;
       FN[1]←DKA;

        READ'MIBOB'NAME(FN,5,TA,0,OFT1//CR'ITM:ERCODE,ERMSNO);
       GOTO OPEN;
       DELETE'MIBOB(FN,OFT1//SF'PUNT);
*GO CREATE ITEM AND RETURN PROPER FILE NAME
CR'ITM: CR'INITL'ITM(PTR1,FN,OFT1//SF'PUNT);

OPEN:  MOPEN'FILE(-1,FN,0,OFT1:OFTX//SF'PUNT);

HERE:   POINT←PTR1 + LHDR;
       PGNO←POINT.PG;


*PAGE IS NOT COMPLETE IF TRANSFER TAKES PLACE
*OTHERWISE WRITE OUT PAGE

        CR'FILE'PAGE(OFTX,PGNO:PGNO//VALUE( GOTO ERROR IF ERCODE # 'FPE'
           ELSE GOTO OK): ERCODE,ERMSNO);

OK:     MOVE'PAGE'PMT(OFTX,PGNO,PMT2//SF'PUNT);
       BCOPY(PTR2,PTR1+LHDR+1,NOWDS);
       FL←0;
       GOTO CLRPMT IF EOF=1 OR
        (NOWDS+LHDR+1)<PAGESIZE;
FILL:  W2 ← 2048 - NOWDS;
       READ'TAPE(INBUF,WC:TAPE1,TAPE2,DLEN);
       IF TAPE2$UE=1 DO; FL←2; GOTO CLRPMT; ENDIF;
       PTR1.WORDN ← PTR1.WORDN - W2;
       GOTO NOW IF ( EOF ← PTR1.FEOF) = 1;
       POINT← PTR1.LHEADER + PTR1 + W2;
       FL ← 1 IF POINT.PG # PGNO ;
*VALIDITY CHECK REST OF DATA?
NOW:    HLEN←PTR1.LHEADER ;

        DUMARY1←AR'DESC(W2,PTR2+NOWDS);
       DUMARY2←AR'DESC(W2,PTR1+HLEN);

        BCOPY(@DUMARY1[0],@DUMARY2[0],W2);
       NOWDS←NOWDS+W2;
CLRPMT:CLEAR'PMT(PMT2//SF'PUNT);
       GOTO DONE IF FL = 2;

        IF FL=0 AND EOF=1 DO;
           MSET'OFT'CL(OFTX,0//SF'PUNT);
           GOTO NEWRD;
       ENDIF;
       GOTO NEWRDRD  IF FL=0;

        IF FL=1 DO;

            FL←0;
           GOTO NEWF;

        ENDIF;

DONE:   DELETE'PMT(PMT1//SF'PUNT);
       DELETE'PMT(PMT2//SF'PUNT);
       SET'ICT'CL(INTCEL,0//SF'PUNT);
       RETURN;
*READ TRAILER AND CONVERT TO LISTENER

ERROR:  NC'PUNT;

       END;

       PROGRAM CREATE'ITEM; INCLUDE COMDECS,BFSDECS;

        MACRO     TFR ← FRETURN(ERCODE,ERMSNO):ERCODE,ERMSNO;

        PTR PTR1;
       INTARY FN;
       UINFL FTYPE(1:0,3),AC (8:12,23),DUR(8:1,2),LLK(8:8,11);
       INT FILETP,K,ENLLK,ERMSNO;
       UINFL  LOCK(0),LOCK2(1);
       CHR  ERCODE;
       LN LIST;


        ENTRY  CR'INITL'ITM (PTR1,FN,K),FRETURN;

        FILETP ← 0;
       CREATE'MIBOB(FN,FILETP,K//TFR);
       SET'MIBOB'ACCESS(FN,357B,K//SF'PUNT); *TEMP FIX UNTIL BO SETS ACCESS
       ENLLK←PTR1.LLK*2+PTR1;

        FOR PTR1←PTR1+1,PTR1+2 WHILE PTR1 <= ENLLK DO;
           LIST$LOCK←PTR1.LOCK;
           LIST$LOCK2←PTR1.LOCK2;
           SET'LOCK'LIST (FN,LIST,K//TFR);
       ENDFOR;
       RETURN;

       END;

       PROGRAM MISSUBS; INCLUDE COMDECS;
       ST JST1,JST2;
       INT  TEMP;


        INTENT COMPARE(JST1,JST2);




        FOR TEMP←GCI(JST1//ENDST1)WHILE 1 DO;
           GOTO NOGD IF TEMP#GCI(JST2//NOGD);
       ENDFOR;
*                         ERROR IF LOOP COMPLETES
        NC'PUNT;
ENDST1:GCI(JST2//GOOD);
NOGD:  RETURN 0;
GOOD:  RETURN 1;

       END;

       PROGRAM RD'TAPE; INCLUDE COMDECS;

        INT       ERMSNO; CHR ERCODE;

        INT    RSP,PAR1,PAR2,DLEN,TU←0,MODE,WC;
       INTARY INBUF;

        ENTRY  READ'TAPE(INBUF,WC);

        SEND'COM(0,TU,WC,0);
*      SEND'COM(19,TU,1,0);
*      GRSPO(:RSP,PAR1,PAR2,DLEN//SF'PUNT);
*      NC'PUNT IF RSP # 31;
        RDT(INBUF:RSP,PAR1,PAR2,DLEN//SF'PUNT);

        RETURN(PAR1,PAR2,DLEN) IF RSP=30;

        NC'PUNT;

       END;

       COMMON M30PAR; INCLUDE INTERCOM;

        DECLARE ARRAY COMTAB0[24]←(136,129,
        130,139,132,141,142,135,184,177,178,187,
        180,189,190,183,72,65,66,75,68,77,78,71);
       DECLARE ARRAY COMTAB1[8]←(120,113,114,
        123,116,125,126,119);

        DECLARE ARRAY R1LEN[8]←(1,2,2,2,0,0,3,0);
       DECLARE ARRAY R2LEN[8]←(0,0,0,0,0,0,1,0);
       DECLARE ARRAY P1LEN[20]←(1,1,1,1,1,3,3,3,3,3,
        0,0,0,0,0,0,0,0,1,1);
       DECLARE ARRAY P2LEN[20]←(3,3,3,1,1,0,0,0,0,0,
        0,0,0,0,0,0,0,0,3,1);
       DECLARE ARRAY P3LEN[20]←(0,0,0,1,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,1,0);

        DECLARE READ←0, READB←1, WRITE←2,
        CNTRL←3, SET'MODE←4, READ'BCARD←5,
        READ'ECARD←6, PRINTL←7, MOUNT'C←8,
        SENSE←9, RETRY←10, NO'RETRY←11, SKIP←12,
        REPEAT←13, RESTART←14, TAPE'RESTART←15,
        DATA'OK←16, DATA'BAD←17, HEADER'SEARCH←18,
        SET'SPEED←19,CHIO'NULL←23,PFIN←29;

        DECLARE CSL←300,DB←300B,M30R←38,M30W←39,FCPAR←10;

        DECLARE LONG MIN5←(1,62341600B),MIN3'5←(1,27571700B),
        MIN1←(0,26706600B),ALARM'CLOCK,
        SEC10←(0,3641100B),LZ,LNCON ← (1,0);
       DECLARE ARRAY FLGAR[1];

        DECLARE CHIOBIT, BBITS, FLAG,TIMER'NO,M30Q'FN,
        DPMTX,M30PMTX,Z,ERMSNO;
       DECLARE CHARACTER E,ERCODE;

        DECLARE FIELD BBT(0:0,0),ASLP(0:1,1),LTOP(0:2,2),PIP(0:3,3),
        PRQ(0:4,4),TRQ(0:6,6),
        CRQ(0:5,5),T7R(0:7,7),
        T9R(0:8,8),OIP(0:9,9),
        TBTS(0:7,8),DISP'FLD(0:3,6),IDLE'F(0:10,10);

        DECLARE FIELD BIT0(0:0,0),CIU(0:11,11),PIU(0:12,12),
        T7IU(0:13,13),T9IU(0:14,14),CRP(0:15,15),PRP(0:16,16),
        T7RP(0:17,17),T9RP(0:18,18);
       DECLARE FIELD ARRAY [4] REQB←(CRQ,PRQ,T7R,T9R),
        DEVF←(CIU,PIU,T7IU,T9IU),
        REQ'PEND←(CRP,PRP,T7RP,T9RP);




        DECLARE ARRAY M30Q'NAME[8]←(0,1,2,3,4,5,6,7);

        DECLARE ARRAY [4] ENN,TOPB;
       DECLARE ARRAY [10:8] DB1,DB2,DB3,DB4;
       DECLARE ARRAY ARRAY DBUF[4]←(DB1,DB2,DB3,DB4);

        DECLARE FIELD FII(0:0,0),FOP(0:1,5),FN(0:6,23),
        FER(1:0,0),FERC(1:1,5),FERDATA(1:6,23),
        FSA(2),FWC(3),FDT1(4),FDT2(5),FDT3(6),FDT4(7);

        MACRO EN←(DBUF[DEVNO])[ENO];
       MACRO II←EN$FII;
       MACRO OP←EN$FOP;
       MACRO N←EN$FN;
       MACRO ER←EN$FER;
       MACRO ERC←EN$FERC
        MACRO ERDATA←EN$FERDATA
        MACRO SA←EN$FSA;
       MACRO WC←EN$FWC;
       MACRO DT1←EN$FDT1;
       MACRO DT2←EN$FDT2;
       MACRO DT3←EN$FDT3;
       MACRO DT4←EN$FDT4;

        DECLARE FIELD BP(0),RP(1),WP(2),EP(3);
       MACRO     EMPTY(S) ← LNGDES(S$RP, S$WP) <=0;
       MACRO ERR(A,B)←FRETURN(A,B);
       MACRO LF'PUNT←RUNTIME'FAILURE();
       MACRO SF'PUNT←LF'PUNT:ERCODE,ERMSNO;
       MACRO SET(FLB)←FLAG$(FLB)←-1;
       MACRO CLEAR(FLB)←FLAG$(FLB)←0;
       MACRO IFF(FLB)← IF (FLAG$(FLB));

* MCALLS
        MACRO UMC←UNKNOWN MONITOR;
       MACRO IMC←INTEGER MONITOR;
       MACRO LMC←LONG MONITOR;

        UMC RSTB←182; UMC WST ← 183; *READ'STRING'BRK,WRITE'STRING
       LMC RRTC←210;
       IMC CVINT←165; IMC ACQICT←174; UMC RDICT←166; UMC SETICT←172;
       UMC BLOCK←170; UMC RESNI←168; UMC SETPIW←123;
       IMC READ'SPT'FIELD←97; UMC SET'SPT'FIELD←98; UMC SP'RETURN←116;
       UMC SET'MAP'BYTE←102;
       IMC ACQPMT←50; UMC CLRPMT←53;
       IMC OPEN←19; UMC GET'FILE'PAGE←27;

       END;

       PROGRAM LONG'ARIT;
*
* LONG ARITHMETIC PACKAGE
*
       DECLARE P,Q,I;
       DECLARE LONG X,Y;
       DECLARE FIELD W0(0),W1(1);


        LONG FUNCTION FAD(X,Y);
       .LDA X$W1; .ADD Y$W1; .CAB;
       .LDA X$W0; .ADC Y$W0; RETURN;

        LONG FUNCTION FSB(X,Y);
       .LDA X$W1; .SUB Y$W1; .CAB;
       .LDA X$W0; .SUC Y$W0; RETURN;

        FUNCTION FGT(X,Y);
       RETURN (1 IF FSB(Y,X)$W0<0 ELSE 0);

       END;

       PROGRAM MISCM30; INCLUDE M30PAR;

        DECLARE INTEGER C,P1,P2,P3;


        ENTRY SEND'COM(C,P1,P2,P3);
       S'C(COMTAB0[C],P1,4-P1LEN[C],P2,4-P2LEN[C],P3,4-P3LEN[C]:Z,Z
        //SF'PUNT);

        RETURN;

       END;

       PROGRAM M30BAS;
       INCLUDE M30PAR;INCLUDE INTERCOM;

        DECLARE FIELD HCBTS(0:18,19),LCBTS(0:21,23),BCHR(0:0,0),
        CHION(0:2,23);

        DECLARE CMD,RPR1,RPR2,RLEN,T,TT,I;
       DECLARE STRING PSTR(5),COMSTR(CSL+1),DATSTR,P1S,P2S,P3S,RP1S,RP2S;

        DECLARE P1,P2,P3,LEN,NCHRS,TCHR;
       DECLARE ARRAY BUF;

        FUNCTION S'C(CMD,P1,P1L,P2,P2L,P3,P3L),FRETURN;
       SETUP(P1S,4,@P1,6);
       SETUP(P2S,4,@P2,6);
       SETUP(P3S,4,@P3,6);
       SETS(P1S,P1L,4); SETS(P2S,P2L,4);
       SETS(P3S,P3L,4); SETS(COMSTR,0,0);
       WCI(CMD,COMSTR//LF'PUNT);
SC1:   WCI(GCI(P1S//SC2) V' DB,COMSTR//LF'PUNT) & GOTO SC1;
SC2:   WCI(GCI(P2S//SC3) V' DB,COMSTR//LF'PUNT) & GOTO SC2;
SC3:   WCI(GCI(P3S//SC4) V' DB,COMSTR//LF'PUNT) & GOTO SC3;
SC4:   WST(M30W,7,COMSTR:COMSTR,NCHRS//SC6:E,Z);
       GOTO SC4 IF NCHRS # 0;
       RETURN(0,0);
SC6:   ERR('SC0',1);



        FUNCTION RDT(BUF),FRETURN;
       SETUP(DATSTR,8192,@BUF[0],6);
       T←301B; CLEAR(BBT);
RDT1:  SETS(COMSTR,0,0);
       RSTB(M30R,CSL,0,COMSTR:COMSTR,NCHRS//RDT0:E,Z);
RDT4:  GOTO RDT7 IF NCHRS$CHION = CSL;
       (T←GCD(COMSTR) & GOTO RDT7) IF NCHRS$BCHR;
RDT3:  ALARM'CLOCK←FAD(RRTC('RTC'),LNCON);
       CHIOBIT←2B5 V' (4B7 RSH INTCEL);
       SETICT (INTCEL,2B7 V' 1B4,0,ALARM'CLOCK//SF'PUNT);
       SET(BBT);
RDT013:BLOCK(CHIOBIT//SF'PUNT);
       LZ←RRTC('RTC');
*         ERR('RD2',4) IF FGT(LZ,ALARM'CLOCK); TEMP FIX DURING DEBUG
        CLEAR(ASLP);
       TCHR ← NCHRS$CHION;
       RSTB(M30R,CSL-(NCHRS$CHION),0,COMSTR:COMSTR,NCHRS//RDT0:E,Z);
       GOTO RDT013 IF NCHRS$CHION = 0;
       NCHRS$CHION ← NCHRS$CHION + TCHR;
       GOTO RDT4;
RDT7:  WCI(GCI(COMSTR//RDT2),DATSTR//RDT6) & GOTO RDT7;
RDT6:  ERR('RD2',4);
RDT2:  GOTO RDT1 IF T>=300B;
       RLEN←(LENGTH(DATSTR)*3)/4;
RDT12: SETS(PSTR,0,0);
       CMD←((T $ HCBTS LSH 3) V' T $ LCBTS)-24;
       ERR('RD3',5) IF COMTAB1[CMD]#T;
       GOTO RDT8 IF (T←R1LEN[CMD]+R2LEN[CMD])=0;
       RPR1←RPR2←0;
RDT10: RSTB(M30R,T,0,PSTR:PSTR,NCHRS//RDT0:E,Z);
       GOTO RDT10 IF LENGTH(PSTR)#T;
       CLEAR(ASLP);
       SETUP(RP1S,4,@RPR1,6);
       SETUP(RP2S,4,@RPR2,6);
       SETS(RP1S,4,4);
       SETS(RP2S,4,4); SETS(PSTR,0,T);
       WCD(GCD(PSTR//RDT9),RP2S//LF'PUNT) FOR I←1 TO R2LEN[CMD];
       WCD(GCD(PSTR//RDT9),RP1S//LF'PUNT) FOR I←1 TO R1LEN[CMD];
RDT8:  CMD ← CMD + 24;
       (CLEAR(PIP) & GOTO RDT14) IF CMD=PFIN;
       RETURN (CMD, RPR1,RPR2,RLEN);


        ENTRY GRSPO(), FRETURN;
RDT14: CLEAR(BBT);
RDT13: SETS(COMSTR,0,0);
       RSTB(M30R,CSL,0,COMSTR:COMSTR,NCHRS//RDT0:E,Z);
       T←GCD(COMSTR//RDT11);
       GOTO RDT12 IF NCHRS$BCHR ELSE ERR('RD2',4);
RDT11: ALARM'CLOCK←FAD(RRTC('RTC'),LNCON);
       CHIOBIT←2B5 V' (4B7 RSH INTCEL);
       SETICT(INTCEL,2B7 V' 1B4,0,ALARM'CLOCK//SF'PUNT);
       BLOCK(CHIOBIT//SF'PUNT);
       LZ←RRTC('RTC');
*         ERR('RD1',3) IF FGT(LZ,ALARM'CLOCK); TEMP REMOVAL FOR DEBUG REASONS
        CLEAR(ASLP);
       GOTO RDT13;
RDT0:  ERR('RD1',3);
RDT9:  ERR('RD3',5);




        FUNCTION WDT(ARRAY BUF,LEN);
       SETUP(DATSTR,8192,@BUF[0],6);
       SETW(DATSTR,8192);
WDT1:  SETS(COMSTR,0,0);
WDT2:  WCI(GCI(DATSTR//WDT3),COMSTR//WDT4) & GOTO WDT2;
WDT4:  WST(M30W,CSL,COMSTR:COMSTR,NCHRS//WDT0:E,Z);
       GOTO WDT1;
WDT3:  WST(M30W,CSL,COMSTR:COMSTR,NCHRS//WDT0:E,Z);
       RETURN(0,0);
WDT0:  ERR('WD0',6);

        END;

       PROGRAM   OCTAL'PATCH;
       INCLUDE COMDECS;
*
* OCTAL PATCH COMMAND
*
        INT       OP'PAGE'ADDR ← 544000B;
       UINFL     A'PAGE(0:6,12), A'WORD(0:13,23);
       INTARY    FN[LUFN]; INT FILE, ADDR, OLDP, T, BYTE;
       CHR       CH; ST LINE(80), FS;
       CHR       ERCODE;
       INT       ERMSNO;

        ARBENT    OCTAL'PATCH();
       FILE ← -1; SETS(LINE,0,0);
       SET'LINE'FIELD('EST',-2,1//SF'PUNT);
       BYTE ← ACQUIRE'PMT(-1//SF'PUNT);
       SET'MAP'BYTE(-1, OP'PAGE'ADDR$A'PAGE, BYTE//SF'PUNT);
LP:    CH←GCI(LINE//READ);
       IF CH='@' DO;* FILE NAME FOLLOWS
       BSET(@FN[0],0,LFN);
           FN[0] ← -1;
           SETUP(FS, 16, @FN[3], 6);
WL1:       WCI(CH, FS//WL1) WHILE (CH ← GCI(LINE//OPEN))#':';
           SETUP(FS, 4, @FN[7], 6);
WL2:       WCI(CH, FS//WL2) WHILE (CH ← GCI(LINE//OPEN))#':';
OPEN:      T ← MOPEN'FILE(-1, FN, 0, 1//SF'PUNT);
           MSET'OFT'CL(FILE,0//SF'PUNT) IF FILE#-1;
           FILE ← T;
           OLDP ← -1;
       ENDIF;
       IF CH=':' DO;* ADDRESS FOLLOWS
       OCTAL'READ(LINE:ADDR,LINE//LF'PUNT);
       ELSEIF CH=' ' DO;
           OCTAL'READ(LINE:T,LINE//LF'PUNT);
           IF ADDR$A'PAGE#OLDP DO;
               CLEAR'PMT(BYTE//SF'PUNT);
               MOVE'PAGE'PMT(BYTE, FILE//SF'PUNT);
               OLDP ← ADDR$A'PAGE;
           ENDIF;
           OP'PAGE'ADDR[ADDR$A'WORD] ← T;
           ADDR ← ADDR+1;
       ELSEIF CH='*' DO;* ALL DONE
OUT:   DELETE'PMT(BYTE//SF'PUNT);
           MSET'OFT'CL(FILE,0//SF'PUNT) IF FILE#-1;
           SET'LINE'FIELD('EST',-2,0//SF'PUNT);
           RETURN;
       ENDIF;
       GOTO LP;
READ:  LINE ← ERD'LINE(-1,LINE//SF'PUNT);
       GOTO LP;

       END;

       PROGRAM   OCTAL'READ;
       INCLUDE COMDECS;
*
* READ OCTAL NUMBER FROM STRING
*

        CHR       CH; INT N, FLAG; ST S;

        INTENT    OCTAL'READ(S), FRETURN;
INIT:  FLAG ← N ← 0;
LP:    CH←GCI(S//EXIT1);
       IF CH >= '0' AND CH <= '7' DO;
           N ← N LSH 3 + CH - '0';
           FLAG ← 1;
           GOTO LP;
       ENDIF;
       GOTO LP IF FLAG = 0;
       WCD(CH, S);
EXIT:  RETURN (N,S);
EXIT1: RETURN (N,S) IF FLAG ELSE FRETURN;

       END;

       PROGRAM   M1'RD'LINE;
       INCLUDE COMDECS;
*
* M1-STYLE LINE COLLECTOR
*
        INT       N; CHR CH; ST NL;
       CHR       ERCODE;
       INT       ERMSNO;

*STENT    ERD'LINE(N, NL) UCF(48);
*STENT    EED'LINE(N, NL) UCF(49);
*         SEL'CIOS(N//TFR);
*         FR'CNINP IF CIOSP.CIOSIPT#1;
*         OUT'CH(NULCH);* FORCE OUTPUT
*         WS ← ST'DESC(CT ← LNGDES(NL$BP, NL$EP),
*            STKMAKE((CT+2)/3), 8, 0);
***** DO SOMETHING ABOUT HERALD
        STENT     ERD'LINE(N, NL), FRETURN;
LNKILL:SETS(NL,0,0);
GETCH: CH ← RD'CH();
       IF CH='%' DO;
           GCD(NL//GETCH);
       ELSEIF CH='!' DO;
           GOTO LNKILL;
       ELSEIF CH='&M' V' 200B DO;
*               OUT'CH('&J' V' 200B);
            GOTO EXIT;
       ELSEIF CH<300B DO;* NOT CTLP(CH)
       WCI(CH,NL//OVFLO);
       ENDIF;
       GOTO GETCH;

* LINE TERMINATION
EXIT:   WCI(NLCH, NL//OVFLO);
*         CIOSP.CIOSOB$RP ← CIOSP.CIOSOB$WP ← CIOSOL$BP;
*         CIOSP.CIOSIB$RP ← CIOSP.CIOSIB$WP ← CIOSIL$BP;
        RETURN NL;

* OVERFLOW (TEMPORARY)
OVFLO:  GCD(NL);
       GOTO EXIT;

       END;

       PROGRAM    KLUDGE'RD'CH;
       INCLUDE COMDECS;
*
*  SPECIAL CHARACTER INPUT ROUTINE FOR LISTENER
*
        ST        CHS(2);
       INT       NC, CH;
       INT       S1CH ← 37B;
       CHR       ERCODE;
       INT       ERMSNO;

        INTENT    RD'CH();
LP:    SETS(CHS, 0,0);
       READ'STRING'BRK(-1,1,0,CHS:CHS,NC//SF'PUNT);
       BLOCK(4B7 RSH GET'INT'NO('CHI'//SF'PUNT)//SF'PUNT) &
        GOTO LP IF EMPTY(CHS);
       CH ← GCI(CHS//LF'PUNT);
       IF CH=S1CH DO;
           CH ← 340B V' GCI(CHS//LF'PUNT);
       ELSEIF CH<40B WHERE CH ← CH A' 177B DO;
           CH ← 340B V' CH;
       ELSE DO;
           CH ← CH-40B;
       ENDIF;
       RETURN CH;
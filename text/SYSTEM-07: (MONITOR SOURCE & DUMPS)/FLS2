       PROGRAM  STLK;
*
*   SET LOCK AND ACCESS FOR LOCK ON ENTRY N;
*
       INCLUDE ERRD,FLS,PROFILE;
       DECLARE ACW,I,J,K;
       FUNCTION STLK(ARRAY N, LONG LK,I' OA) ,FRETURN,MONITOR←4;
       RDM'GETE'ACC(N,1,1:ACW,I//FRETURN);
       J←MIBA[I]$SIBA; GOTO CAL2 IF MIBA[J]$LKL=0;
       FOR K←J+FLK BY 2 TO J+FLK-2+MIBA[J]$LKL DO;
       IF MIBA[K]$LV1=LK$LV1 AND MIBA[K+1]=LK$LV2 DO;
       (MIBA[K]$RWXO←LK$RWXO & (RETURN)) IF LK$RWXO#0;
       DELWD(I,K,2); MIBA[J]$LKL←MIBA[J]$LKL-2;
       RETURN; ENDIF; ENDFOR;
CAL2:  RETURN IF LK$RWXO=0; MAKRM(I,2//FRETURN);
       FRETURN M17 IF MIBA[I]$SIBL>253 OR MIBA[J]$LKL>253;
       GOTO CAL3 IF MIBA[I]$SIBL=FLK;
       BLOCKM(@MIBA[J+FLK],@MIBA[J+FLK+2],MIBA[I]$SIBL-FLK);
CAL3:  MIBA[I]$SIBL←MIBA[I]$SIBL+2;
       MIBA[J+FLK]←LK$WD0; MIBA[J+FLK+1]←LK$WD1;
       MIBA[J]$LKL←MIBA[J]$LKL+2;
       RETURN;

       END;

       PROGRAM  DELWD;
*
*   DELETE WORDS IN SIBS;
*  I = OBT INDEX, K = STARTING WD ADDR, N = NO. OF WORDS
*
       INCLUDE FLS,PROFILE;
       FUNCTION DELWD(I,K,N);
       GOTO CAL1 IF MIBA[I]$SIBL+MIBA[I]$SIBA=K+N;
       BLOCKM(@MIBA[K+N],@MIBA[K],MIBA[I]$SIBL-(K-MIBA[I]$SIBA+N));
CAL1:  MIBA[I]$SIBL←MIBA[I]$SIBL-N;
       RETURN;

       END;

       PROGRAM  SETN;
*
*   SET NAME OF ENTRY N TO M;

       INCLUDE ERRD,FLS,PROFILE;
       DECLARE ACW,E,I,J,K;
       FUNCTION SETN(ARRAY N,ARRAY M,I' OA),FRETURN,MONITOR←2;
       RDM'GETE'ACC(N,0,1:ACW,I//FRETURN);
       GETE(M:E//CAL2:E,J);
       FRETURN M28;
CAL2:  J←MIBA[I]$SIBA;
       MIBA[J+K-3]←M[K] FOR K←3 TO 7;
       RETURN;

       END;

       PROGRAM  GETE;
*
*  SEARCH FOR ENTRY IN MIB
*;
       INCLUDE ERRD,FLS,PROFILE;
       DECLARE E,I,J,K,ARRAY MIBX;
       FUNCTION GETE(ARRAY N),FRETURN;
       MIBX←MIBA;
CAL1:  I←N[7];* DUMMY LOAD FOR PAGE FAULTS
       GOTO CAL3 IF N[2]<0 OR N[2]>=OBTL;
       E←N[2];
       IF MIBX[OBT+E]$U=1 AND E>-1 AND E<OBTL DO;
       J←MIBX[OBT+E]$SIBA;
       FOR I ← 3 TO 7 DO;
       GOTO CAL3 IF N[I]#MIBX[J]; J←J+1;
       ENDFOR; E←E+OBT;
       RETURN E ;*E THAT WAS PROVIDED WAS CORRECT;
       ENDIF;
CAL3:  FOR I←OBT TO OBTE DO;
       IF MIBX[I]$U=1 DO;
       J←MIBX[I]$SIBA;
       FOR K←3 TO 7 DO;
       GOTO CAL5 IF MIBX[J]#N[K];J←J+1;ENDFOR;
** REMOVE FOLLOWING STORE INTO POSSIBLY READONLY ARRAY
*      N[2] ← I-OBT;
       RETURN I;
CAL5:  ENDIF; ENDFOR;
       FRETURN M10;
       ENTRY GETEB(N),FRETURN;
       MIBX←MIBB; GOTO CAL1;

       END;

       PROGRAM  SETAC;
*
*   SET PUBLIC, FRIEND, OWNER ACCESS OF ENTRY N TO VALUE V;
*
       INCLUDE ERRD,FLS,PROFILE;
       DECLARE ACW,E,I,J;
       FUNCTION SETAC(ARRAY N,INTEGER V,I' OA) ,FRETURN,MONITOR←3;
       RDM'GETE'ACC(N,1,1:ACW,I//FRETURN);
CAL2:  J←MIBA[I]$SIBA;
       MIBA[J]$PFO←V;
       RETURN;

       END;

       PROGRAM  RDENN;
*
*   READ ENTRY N,E;
*
       INCLUDE ERRD,FLS,PROFILE;
       DECLARE FLAG,I,J,K,L,ACW,LONG UNDK;
       FUNCTION RDENN(ARRAY N,INTEGER NW,ARRAY WA,I' WI,I' OA),FRETURN,
       MONITOR←1;
       FLAG←1;
       UNDK$WD0←N[0];UNDK$WD1←N[1];
       GOTO CAL1;
       ENTRY RDENE(LONG UNDK,INTEGER NW,ARRAY WA,I' I,I' OA),FRETURN,MONITOR←0;
       FLAG←0; FRETURN M6 IF I<0 OR I>OBTL-1; WI←0; I←I+OBT;
CAL1:  RDMIB(UNDK,0//FRETURN);
       GETE(N:I//FRETURN) IF FLAG=1;
       FRETURN M10 IF MIBA[I]$U=0;
       SIBAC(I:ACW);*  * GET S1B ACCESS;
       NW←0 IF WI<0 OR WI>MIBA[I]$SIBL-1;
       FRETURN M8 IF ACW$RWXO=0; GOTO CAL6 IF NW<1;
       J←MIBA[I]$SIBA+WI;
       NW←MIBA[I]$SIBL-WI IF NW>MIBA[I]$SIBL-WI;
       L←2;
       FOR K←J TO J+NW-1 DO;
       WA[L]←MIBA[K]; L←L+1; ENDFOR;
CAL6:  WA[1]←I-OBT; WA[0]←MIBA[I]$SIBL;
       WA[1]$RWXO←ACW$RWXO;
       WA[0]$T←MIBA[I]$T; RETURN;

       END;

       PROGRAM  CRNE;
*
*
*   CREATE NEW ENTRY WITH NAME N AS TYPE T;
*
       INCLUDE SWPD,RESMON;
       INCLUDE ERRD,FLS,PROFILE,GLOBAL,PMTD,ICTD,APTD,SPCSD,SPTD;
       DECLARE ACW,E,I,J,DP,M,MEC,MEM;
       DECLARE LONG UN,LONG FIELD STDD(0),ARRAY FIELD STDD1(0);
       MACRO SETM'(A,B)←MIBB[MAPS+(A/2)]←(MIBB[MAPS+(A/2)] A' (7777B
          IF EVEN(A) ELSE 7777B4)) V' (PRMAP[A/2]
          A' (7777B4 IF EVEN(A) ELSE 7777B))
          V' ((B@PRMRO LSH 12) IF EVEN(A) ELSE B$PRMRO);
       FUNCTION CRNE(ARRAY N,I' TP,I' OA) ,FRETURN,MONITOR←6;
       GOTO CAL20 IF TP=SACKT;
       FRETURN M32 IF TP<0 OR TP>15 OR TP=7;
CAL20: RDMIB1(N,0//FRETURN);
       DP←0; M←MIBPMT;
       MIBAC(:ACW);
       FRETURN M23 IF ACW$O=0;
CAL1:  GETE(N:E//CAL2:E,I);
       DESTROY'PG(DP,UN) IF DP#0;
       FRETURN M28;
CAL2:  FOR I←OBT TO OBTE DO;
       GOTO CAL3 IF MIBA[I]$U=0;
       ENDFOR; DESTROY'PG(DP,UN) IF DP#0; FRETURN M21;
CAL3:  MAKRM(I,FLK+FDA+2//CAL12:E,I);*SETS TOP, BOT OF FREE AREA
       BSET(@MIBA[TOP],0,FLK+FDA+2);
       MIBA[I]$SIBA←TOP;
       MIBA[I]$T←TP;*SPECIAL ACCESS KEY TYPE IS ACKT+20B
       FOR J←3 TO 7 DO;
       MIBA[TOP]←N[J]; TOP←TOP+1; ENDFOR;
       N[2]←I-OBT;
       GOTO CAL4 IF TP<=LFILET;* CHECK FOR FILES;
       (MIBA[I]$SIBL←6 & GOTO CAL10) IF
          TP>=GARBT OR TP=FRIENDT OR TP=MIBACKT;
       GOTO CAL5 IF TP=ACKT OR TP=SACKT;
       GOTO CAL6 IF TP=PROCT;
       GOTO CAL7 IF TP=REST; PUNT'('000');
CAL4:  (MIBA[TOP+1+FDA]←DP V' 1@U & GOTO CAL8)
          IF TP=LFILET AND DP#0;
       FILEACC(1//FRETURN(E,I):E,I) IF TP=LFILET;
       UNIQUE(TP:UN);
       IF TP = LFILET DO;
          DP←GET'DISK'ADDR(CVDK(MIBA[MIBUN])// VALUE PUNT('KBT'));
          AMC'REQ'WITH'RN(CRWUN, UN, DP, @PRT[PRTI], 1//
               VALUE PUNT(MEC):MEC, MEM);
          GOTO CAL1;
       ENDIF;
CAL8:  MIBA[TOP+1]$STDD←UN;
       ACW←0 IF TP=SFILET ELSE ACW←1;
       MIBA[J]←0 FOR J←TOP+3 TO TOP+FDA;
       MIBA[I]$SIBL←FLK+FDA+ACW;
CAL10: MIBA[I]$U←1; RETURN;
CAL5:  IF TP=SACKT DO;
       MIBA[TOP+1]←0; MIBA[TOP+2]←MIBA[MIBUN];
       ELSE DO;
       MIBA[TOP+1]$STDD←UNIQUE(TP);**ACCESS KEY;
       ENDIF;
       MIBA[I]$SIBL←8; GOTO CAL10;
CAL6:  GOTO CAL11 IF DP#0;
       FILEACC(1//FRETURN(E,I):E,I);
       UNIQUE(TP:UN); UN$WD1←UN$WD1 V' 1;
       DP←GET'DISK'ADDR(CVDK(MIBA[MIBUN])// VALUE PUNT('KBT'));
       AMC'REQ'WITH'RN(CRWUN, UN, DP, @PRT[PRTI], 1//
            VALUE PUNT(MEC):MEC, MEM);
       RDIBCB(UN$WD0,UN$WD1,DP,1//CAL12:E,I);
       GOTO CAL1;
CAL11: MIBA[TOP+1]$STDD←UN;
       MIBA[TOP+1]$PROCDKA←DP;
       MIBA[I]$SIBL←FLK+PROCMOD$FDDISP+1;
*
*  INITIALIZE CB PMT
       ACW←@MIBB[PMTS];
       ACW.PMTFP←0;
       ACW.PMTAL←ACW.PMTCL←1;
       ACW.PMTUN←UN;
       ACW.PMTDKA←DP;
       BLOCKM(@PMT[2],@MIBB[PMTS+4],MPMTA*4-8);
       ACW←ACW+MPMTA*4-4;
       ACW.PMTUN←PMT[M]$PMTUN;
       ACW.PMTDKA←PMT[M]$PMTDKA;
       ACW.PMTFP←1;
       ACW.PMTAL←ACW.PMTCL←1;
       MIBB[@APT[NAPTE+1-1]-M'G]←CB0PMT@APTPMT
           V' 1@APTDWS V' 1@APTCWS V'(-1)@APTUH;
*
*  INITIALIZE VARIABLES
*
       BLOCKM(M'G,@MIBB[0],@CSP-M'G);
       MIBB[@PRUNO-M'G]←MIBA[MIBUN];
       MIBB[@MIBDKA-M'G]←PMT[M]$PMTDKA;
       MIBB[@PRANO-M'G]←MIBA[MIBAN];
       MIBB[@PRGRNO-M'G]←MIBA[MIBGR];
       MIBB[@ATTY-M'G]← -1;
       MIBB[@UTTY-M'G]← -1;
       MIBB[@LCWS-M'G]←MIBB[@LDWS-M'G]←1;
       MIBB[@OLCWS-M'G]←12; MIBB[@MLCWS-M'G]←40;
       MIBB[@MLDWS-M'G]←64; MIBB[@OLDWS-M'G]←32;
       MIBB[@CBVERS-M'G]←CBVERS;
       MIBB[@POP2-M'G]←SESS;
       MIBB[@SESP-M'G]←SESS;
       MIBB[@SESL-M'G]←SESE;
       MIBB[@INIT'PC-M'G]←@START'POP;
       MIBB[@INIT'GR-M'G]←M'G;
       MIBB[@PRCTT-M'G]←INITIAL'QUANTUM;
       MIBB[ITIMER-M'G]←INITIAL'QUANTUM;
       MIBB[@MIBARST-M'G+(MIB0PMT-1)/24]←4B7 RSH ((MIB0PMT-1) MOD 24);
*  INITIALIZE ICT
       MIBB[ICTS]←20010001B; MIBB[ICTS+6*3]←10001B;
*
*  INITIALIZE MAP
*
        SETM'(ACW,1) FOR ACW←MCP0MAP TO MCP8MAP;
       SETM'(CB0MAP,0);
       SETM'(ACW,0) FOR ACW←RT0MAP TO RT3MAP;
*
       GOTO CAL10;
CAL7:  FRETURN M32;* NO RESOURCES YET
CAL12: DESTROY'PG(DP,UN) IF DP#0;
       FRETURN (E,I);

       END;

       PROGRAM  SETVAL;
*
*   SET VALUE OF OBJECT N TO V;
*
       INCLUDE ERRD,FLS,PROFILE;
       DECLARE ACW,E,I,J,K,L;
       FUNCTION SETVAL( ARRAY N, INTEGER NW, ARRAY V,I' OA) ,FRETURN,MONITOR←12;
       FRETURN M32 IF NW<0;
       RDM'GETE'ACC(N,0,1:ACW,E//FRETURN);
       FRETURN M32 IF MIBA[E]$T<GARBT;
       I←MIBA[E]$SIBA;
       GOTO CAL2 IF (J←NW-MIBA[E]$SIBL+FLK+MIBA[I]$LKL)<1;
       FRETURN M17 IF MIBA[E]$SIBL+J>255;
       MAKRM(E,J//FRETURN);
CAL2:  MIBA[E]$SIBL←NW+FLK+MIBA[I]$LKL;
       RETURN IF NW=0;
       GET'PTR(E:J); L←0;
       FOR K←J TO J+NW-1 DO;
       MIBA[K]←V[L]; L←L+1;ENDFOR;
       RETURN;

       END;

       PROGRAM  RDAVSP;
*

*   READ AVAILABLE SPACE IN M1B;

       INCLUDE ERRD,FLS,PROFILE;
       DECLARE I,J,ACW,E;
       FUNCTION RDAVSP(LONG UNDK,I' OA) ,FRETURN,MONITOR←16;
       RDMIB(UNDK,0//FRETURN);
       MIBAC(:ACW);
       FRETURN M27 IF ACW$RWXO=0;
       J←SIBE-SIBS+1; E←OBTL;
       FOR I ← OBT TO OBTE DO;
       (J←J-MIBA[I]$SIBL & E←E-1) IF MIBA[I]$U=1;
       ENDFOR;
       RETURN (E,J);

       END;

       PROGRAM RDMIBACC;
         INCLUDE ERRD,FLS,PROFILE;
       DECLARE ACW;

ENTRY RDMIBA(LONG UNDK,INTEGER OA), FRETURN, MONITOR←11;

       RDMIB(UNDK,0 // FRETURN);
       ACW ← MIBAC();
       ACW ← ACW$RWXO;
       FRETURN M27 IF ACW=0;
       RETURN ACW;

       END;

       PROGRAM  DELEN;
       INCLUDE ERRD,FLS,PROFILE,PMTD,RESMON;
       DECLARE ACW,E,I,J,K,L,LONG UN;
       DECLARE FIXED FIELD LB(0:2,2),LEB(0:4,4),
          MULT0(0:5,6),MULT1(0:5,10),UB0(0:7,23),UB1(0:11,23);
       FUNCTION DELEN(ARRAY N,I' OA) ,FRETURN,MONITOR←5;
       RDM'GETE'ACC(N,0,1:ACW,E//FRETURN);
       J←MIBA[E]$T;
       GOTO CAL1 IF J = SFILET;
       GOTO CAL10  IF J=LFILET;* LARGE FILE;
       GOTO CAL20 IF J=PROCT;
       GOTO CAL30 IF J=REST;
       GOTO CAL2 IF J>=GARBT OR J=ACKT OR J=MIBACKT OR J=FRIENDT;
       FRETURN M32;
CAL1:  J←MIBA[E]$SIBA;
       FRETURN M31 IF MIBA[E]$SIBL#MIBA[J]$LKL+FLK+FDA;
CAL2:  MIBA[E]$U←0;
       RETURN;
CAL10: GET'PTR(E:J);
       RDIBCB(UN$WD0←MIBA[J],UN$WD1←MIBA[J+1],
          MIBA[J+FDA],1//FRETURN);
       FOR K←0 TO MAXLP DO;
       FRETURN M31 IF MIBB[K]$U#0;
       ENDFOR;
       MIBA[E]$U←0;
       DESTROY'PG(MIBA[J+FDA],UN);
       RETURN;
CAL30: FRETURN M32;* NO RESOURCES YET
CAL20: GET'PTR(E:J);
       FRETURN M48 IF PRT[MIBA[J]$PROCPRT]$PRUN1=MIBA[J]$PROCUN1
       AND PRT[MIBA[J]$PROCPRT]$PRUN2=MIBA[J]$PROCUN2;
       REALT(:K,L);
       FRETURN M48 IF MIBA[J]$PROCMOD>K;
       MIBA[J]$PROCMOD←K+PRMLK;
       RDIBCB(UN$WD0←MIBA[J],UN$WD1←MIBA[J+1],
          MIBA[J]$PROCDKA,1//FRETURN(E,I):E,I);
       FOR ACW←PMTS+4 BY 4 TO PMTS+4*NPMTE-4 DO;
       IF MIBB[ACW]$PMTDKA#0 AND MIBB[ACW]$PMTFP=0 DO;
       UN←MIBB[ACW]$PMTUN;
       DESTROY'PG(MIBB[ACW]$PMTDKA,UN);
       ENDIF;
       ENDFOR;
       UN←MIBA[J]$PROCUNL;
       DESTROY'PG(MIBA[J]$PROCDKA,UN);
       MIBA[E]$U←0;
       RETURN;

       END;

       PROGRAM  STNDR;
*
*    SET NO DRUM CHARGE FLAG FOR FILE;
*
       INCLUDE ERRD,FLS,PROFILE,SPTD;
       DECLARE ACW,E,I;
       FUNCTION STNDR(ARRAY N,I' V,I' OA) ,FRETURN,MONITOR←15;
       FRETURN M33 IF  SPSTATUS$SYS=0;
       RDM'GETE'ACC(N,1,1:ACW,E//FRETURN);
       FRETURN M32 IF MIBA[E]$T>LFILET;
       MIBA[MIBA[E]$SIBA]$S←V; RETURN;

       END;

       PROGRAM  STREFL;
*
*   SET WRITTEN, REFERENCED DATES ON FILE
*
       INCLUDE ERRD,FLS,PROFILE;
       DECLARE ACW,E,I,J;
       FUNCTION STREFL(ARRAY N,I' V,I' OA) ,FRETURN,MONITOR←18;
       RDM'GETE'ACC(N,0,1 IF V#0 ELSE 0:ACW,E//FRETURN);
       FRETURN M8 IF ACW = 0;
       FRETURN M32 IF MIBA[E]$T>LFILET;* WRONG TYPE;
       REALT(:ACW,I);
       GET'PTR(E:J);
       MIBA[J]$DFR←ACW;
       RETURN IF V = 0;
       MIBA[J]$DFW←ACW;
       RETURN;

       END;

       PROGRAM  SOFTAL;
*
*   SET ACCESS LOCK FOR OFT ENTRY L TO M;
*
       INCLUDE ERRD,FLS,PROFILE,SPTD;
       FUNCTION SOFTAL(F,M) ,FRETURN,MONITOR←21;
       CK'OFT(F//FRETURN);
       GOTO CAL1 IF OFT[F]$OFTCL A' SPT[CSP]$SPTKEY#0;
       FRETURN M13 IF OFT[F]$OFTAL A' SPT[CSP]$SPTKEY=0;
       OFT[F]$OFTAL←OFT[F]$OFTAL A' N' SPT[CSP]$SPTKEY V'
       M A' SPT[CSP]$SPTKEY;
       RETURN;
CAL1:  OFT[F]$OFTAL←M; RETURN;

       END;

       PROGRAM  RDOFT;
*
*   READ OFT ENTRY F;
*
       INCLUDE ERRD,FLS,PROFILE;
       FUNCTION RDOFT(F,ARRAY WA) ,FRETURN,MONITOR←20;
       CK'OFT(F//FRETURN);
       BLOCKM(@OFT[F],@WA[0],5); RETURN;

       END;

       PROGRAM  OPENF;
*
*   OPEN FILE F;
*
       INCLUDE ERRD,FLS,PROFILE,SPTD,RESMON;
       DECLARE ACW,E,J,K,L;
       FUNCTION OPENF(I' I,ARRAY N,I' RO,I' OA) ,FRETURN,MONITOR←19;
       FRETURN M36 IF I< -1 OR I>OFTL OR I=0;
       REALT(:K,L);
       IF OPPROC<K AND (OPPROC>0) DO;
       FOR I←1 TO OFTL DO;
       OFT[I]$U←0 IF OFT[I]$U#0 AND OFT[I]$TYPE=PROCT
           AND OFT[I]$OFTMOD=1;
       ENDFOR;
       OPPROC←0;
       ENDIF;
       GOTO CAL6 IF I=-1;
       FRETURN M11 IF OFT[I]$U#0 ELSE GOTO CAL2;
CAL6:  FOR I←1 TO OFTL DO;
       GOTO CAL2 IF OFT[I]$U=0;
       ENDFOR; FRETURN M11;
CAL2:  RDM'GETE'ACC(N,0,0:ACW,E//FRETURN);
       FRETURN M32 IF MIBA[E]$T>ACKT;
       BSET(@OFT[I],0,5);
       FRETURN M8 IF ACW$RWXO=0;
       FRETURN M35 IF ACW$X AND NOT ACW$R;
       J←MIBA[MIBA[E]$SIBA]$LKL+MIBA[E]$SIBA+FLK;
       OFT[I]$OFTUNL←MIBA[J]$LF0;
       OFT[I]$RWXO←ACW$RWXO;OFT[I]$U←0;
       OFT[I]$OTI←E-OBT;
       OFT[I]$TYPE←MIBA[E]$T;
       OFT[I]$OFTAL←OFT[I]$OFTCL←SPNAME;
       GOTO CAL11 IF MIBA[E]$T=ACKT;
       OFT[I]$OFTMIB←MIBPMT;
       GOTO CAL3 IF MIBA[E]$T=PROCT;
       OFT[I]$W←0 IF RO = 1 OR NOT SPSTATUS$WFI;
       GOTO CAL10 IF MIBA[E]$T=LFILET;
CAL11: OFT[I]$U←1;
       RETURN I;
*
CAL10: RDIBCB(MIBA[J],MIBA[J+1],MIBA[J+FDA],1//FRETURN);
       OFT[I]$OFTIB←MIBPMT; GOTO CAL11;
CAL3:  IF RO=1 DO;
*
       FRETURN M14 IF (NOT SPSTATUS$WFI
               OR NOT ACW$W);
       FRETURN M48 IF
          PRT[MIBA[J]$PROCPRT]$PRUN1=MIBA[J]$PROCUN1
          AND PRT[MIBA[J]$PROCPRT]$PRUN2=MIBA[J]$PROCUN2;
       FRETURN M47 IF (MIBA[J]$PROCI
           OR MIBA[J]$PROCMOD#0);
       FRETURN M49 IF OPPROC>0;
       MIBA[J]$PROCMOD←K+PRMLK; OPPROC←K+PROLK;
       ENDIF;
       RDIBCB(MIBA[J]$PROCUN1,MIBA[J]$PROCUN2,
             MIBA[J]$PROCDKA,1// FRETURN);
       OFT[I]$OFTIB←MIBPMT; OFT[I]$U←1;
       OFT[I]$OFTMOD←RO; RETURN I;

       END;

       PROGRAM  FPGPMT;
*
*   PUT RN OF PAGE M OF ILE F INTO PMT ENTRY K;
*
       INCLUDE ERRD,PMTD,SPTD,FLS,PROFILE;
       DECLARE E,I,J;
       FUNCTION FPGPMT(F,P,K) ,FRETURN,MONITOR←27;
       FRETURN M5 IF P<0;
       CKOFTAC(F,0,0//FRETURN);
       RDMIB2(F,0//FRETURN);
       CKOBTAC(F:E,I//FRETURN);
       FRETURN M32 IF MIBA[E]$T>LFILET;
       J←I+FDA;
       GOTO CAL1 IF OFT[F]$TYPE = SFILET;
       RDIBCB2(F,1//FRETURN);
       FRETURN M5 IF P>MAXLP OR MIBB[P]$U=0;
       GOTO CAL2;
CAL1:  FRETURN M5 IF J+P>MIBA[E]$SIBA+MIBA[E]$SIBL-1;
       FRETURN M5 IF MIBA[J+P]$U=0;
CAL2:  FRETURN M1 IF K<1 OR K >NPMTE;
       FRETURN M2 IF PMT[K]$PMTCL=0;
       FRETURN M4 IF SPT[CSP]$SPTKEY A' PMT[K]$PMTCL=0;
       FRETURN M3 IF PMT[K]$PMTDKA#0;
       PMT[K]$PMTDKA←(MIBA[J+P] IF
          OFT[F]$TYPE=SFILET ELSE MIBB[P]);
       PMT[K]$PMTFP←1;
       PMT[K]$PMTRO← N' OFT[F]$W;
       PMT[K]$PMTNC←MIBA[MIBA[E]$SIBA]$S;
       PMT[K]$PMTUN1←MIBA[I];
       PMT[K]$PMTUN2←MIBA[I+1]+P+1;
       RETURN;

       END;

       PROGRAM  CRPG;
*
*   CREATE NEW PAGE N OF FILE F;
*
       INCLUDE SWPD,RESMON;
       INCLUDE ERRD,FLS,PROFILE,SPTD,PMTD;
       DECLARE E,I,J,A1,A2,DP,MEC,MEM;
       DECLARE LONG UN, LONG FIELD STDD(0);
       FUNCTION CRPG(F,P) ,FRETURN,MONITOR←24;
       DP←0;
       CKOFTAC(F,1,0//FRETURN);
       RDMIB2(F,0//FRETURN);
CAL3:  CKOBTAC(F:E,I//CAL4:E,I);
       GOTO CAL7 IF OFT[F]$TYPE=SFILET;
       GOTO CAL10 IF OFT[F]$TYPE=LFILET;
       GOTO CAL20 IF OFT[F]$TYPE=PROCT;
       FRETURN M32;
CAL7:  J←I+FDA;
       FRETURN M17 IF P<0 OR P>MAXP;
       GOTO CAL2 IF J+P>(A1←MIBA[E]$SIBA+MIBA[E]$SIBL-1);
       GOTO CAL1 IF MIBA[J+P]$U=1;* PAGE ALREADY EXISTS;
       (MIBA[J+P]←DP V' 1@U & GOTO CAL6) IF DP#0;
       FILEACC(1//FRETURN(E,I):E,I);
       UN$WD0←MIBA[I];
       UN$WD1←MIBA[I+1] V' (P+1);
       DP←GET'DISK'ADDR(CVDK(MIBA[MIBUN])// VALUE PUNT('KBT'));
       AMC'REQ'WITH'RN(CRWUN, UN, DP, @PRT[PRTI], 1//
            VALUE PUNT(MEC):MEC, MEM);
       GOTO CAL3;
CAL6:  MIBA[I]$FLEN1←MIBA[E]$SIBL-J+MIBA[E]$SIBA;
       RETURN P;
CAL2:  A2←J+P-A1;
       GOTO CAL5 IF MIBA[E]$SIBL+A2 > 255;
       MAKRM(E,A2 //CAL4:E,I);
       A1←MIBA[E]$SIBA+MIBA[E]$SIBL;
       MIBA[I]←0 FOR I←A1 TO A1+A2-1;
       MIBA[E]$SIBL←MIBA[E]$SIBL+A2; GOTO CAL3;
CAL4:  DESTROY'PG(DP,UN) IF DP#0;
       FRETURN (E,I);
CAL1:  DESTROY'PG(DP,UN) IF DP#0;
       FRETURN M19;
CAL5:  DESTROY'PG(DP,UN) IF DP#0;
       FRETURN M17;
*
CAL10: FRETURN M17 IF P<0 OR P>MAXLP;
       RDIBCB2(F,1//FRETURN);
       GOTO CAL1 IF MIBB[P]$U#0;
       UN$WD0←OFT[F]$OFTUN1; UN$WD1←OFT[F]$OFTUN2 V' (P+1);
       (MIBB[P]←DP V' 1@U & GOTO CAL16) IF DP#0;
       FILEACC(1//FRETURN(E,I):E,I);
       DP←GET'DISK'ADDR(CVDK(MIBA[MIBUN])// VALUE PUNT('KBT'));
       AMC'REQ'WITH'RN(CRWUN, UN, DP, @PRT[PRTI], 1//
            VALUE PUNT(MEC):MEC, MEM);
       GOTO CAL3;
CAL16: MIBA[I]$FLEN1←P+1 IF P+1>MIBA[I]$FLEN1;
       RETURN P;
CAL20: RDIBCB2(F,1//FRETURN);
       FRETURN M1 IF P<1 OR P>NPMTE;
       FRETURN M4 IF SPT[CSP]$SPTKEY A' PMT[P]$PMTCL=0;
       FRETURN M3 IF PMT[P]$PMTDKA#0;
       FRETURN ('NSP',183) IF MIBB[@SPT[1]-M'G]$SPTOL=0;
       FOR A1←1 TO NPMTE DO;
       A2←@PMT[1]-M'G+A1*LPMTE-4;
       GOTO CAL21 IF MIBB[A2]$PMTCL=0 AND MIBB[A2]$PMTDKA=0;
       ENDFOR; FRETURN ('PMO',184);
CAL21: UN$WD0←OFT[F]$OFTUN1;
       UN$WD1←(OFT[F]$OFTUN2 A' N' 377B) V' A1;
       FILEACC(1//FRETURN(E,I):E,I);
       DP←GET'DISK'ADDR(CVDK(MIBA[MIBUN])// VALUE PUNT('KBT'));
       AMC'REQ'WITH'RN(CRWUN, UN, DP, @PRT[PRTI], 1//
            VALUE PUNT(MEC):MEC, MEM);
       (@MIBB[A2]).STDD←UN;
       MIBB[A2]$PMTDKA←DP;
       MIBB[A2]$PMTCL←2;
       PMT[P]$STDD←UN;
       PMT[P]$PMTDKA←DP;
       PMT[P]$PMTFP←1;
       PMT[P]$PMTRO←0;
       RETURN A1;

       END;

       PROGRAM  CKOFTAC;
       INCLUDE ERRD,FLS,PROFILE,SPTD;
       DECLARE I,J;
       FUNCTION CKOFTAC(F,RW,AOC),FRETURN;
       CK'OFT(F//FRETURN);
       FRETURN M13 IF NOT (OFT[F]$OFTCL A' SPKEY#0
          OR AOC=0 AND (OFT[F]$OFTAL A' SPKEY)#0);
CAL2:  FRETURN M14 IF OFT[F]$W=0 AND RW=1;
       REALT(:I,J);
       FRETURN M12 IF OFT[F]$TYPE = PROCT AND
          (OPPROC+PROLK)<I AND OFT[F]$OFTMOD#0;
       RETURN;

       END;

       PROGRAM  SOFTCL;
*
*   SET CONTROL LOCK FOR OFT ENTRY F TO M;
*
       INCLUDE ERRD,FLS,PROFILE,RESMON,SPTD;
       DECLARE E,I;
       FUNCTION SOFTCL(F,M) ,FRETURN,MONITOR←22;
       CKOFTAC(F,0,1//FRETURN);
       FRETURN M37 IF M A' N' (OFT[F]$OFTCL V' SPT[CSP]$SPTKEY) #0;
       OFT[F]$OFTCL←M; GOTO CAL4;
*
       ENTRY MSOFTCL(F);
CAL4:  GOTO CAL1 IF OFT[F]$TYPE =PROCT AND OFT[F]$OFTMOD=1
         AND OFT[F]$OFTCL=0;
CAL2:  OFT[F]$U←0 IF OFT[F]$OFTCL=0;
       RETURN;
CAL1:  REALT(:E,I);
       GOTO CAL3 IF (OPPROC+PROLK)<E;
       RDMIB2(F,0//CAL3:E,I);
       I←OFT[F]$OTI+OBT;
       GOTO CAL3 IF MIBA[I]$U=0 OR MIBA[I]$T#PROCT;
       GET'PTR(I:E);
       MIBA[E]$PROCMOD←0;
       MIBA[E]$PROCI←1;
CAL3:  OPPROC←0; GOTO CAL2;

       END;

       PROGRAM  DELOFT;
       INCLUDE ERRD,FLS,PROFILE;
       DECLARE I;
       FUNCTION DELOFT(IND);
*
*  DELETE NAME IN OFT ENTRY
       FOR I←1 TO OFTL DO;
       IF OFT[I]$U=1 DO;
       OFT[I]$OFTCL←OFT[I]$OFTCL A' N' (1 LSH IND);
       OFT[I]$OFTAL←OFT[I]$OFTAL A' N' (1 LSH IND);
       MSOFTCL(I);
       ENDIF;
       ENDFOR;
       RETURN;

       END;

       PROGRAM  CKOBTAC;
       INCLUDE ERRD,FLS,PROFILE;
       DECLARE ACW,E,I;
       FUNCTION CKOBTAC(F),FRETURN;
       E←OFT[F]$OTI;
       FRETURN M15 IF E<0 OR E>OBTL-1;
       E←E+OBT;
       GOTO CAL1 IF MIBA[E]$U=0 OR
       MIBA[E]$T#OFT[F]$TYPE;
       GET'PTR(E:I);
       GOTO CAL1 IF MIBA[I]#OFT[F]$OFTUN1;
       GOTO CAL1 IF MIBA[I+1]#OFT[F]$OFTUN2;
       RETURN (E,I);
CAL1:  FRETURN M10;

       END;

       PROGRAM  SETLEN;
*
*   SET WORD LENGTH FOR OFT ENTRY F TO M;
*
       INCLUDE ERRD,FLS,PROFILE;
       DECLARE ACW,E,I;
       FUNCTION SETLEN(F,M) ,FRETURN,MONITOR←23;
       CKOFTAC(F,1,0//FRETURN);
       RDMIB2(F,0//FRETURN);** READ M1B FOR FILE;
       CKOBTAC(F:E,I//FRETURN);
       FRETURN M32 IF MIBA[E]$T>LFILET;
       MIBA[I]$FLEN←M; RETURN;

       END;

       PROGRAM  DELPG;
*
*   DELETE PAGE N OF FILE F;
*
       INCLUDE ERRD,FLS,PROFILE;
       DECLARE ACW,I,E,J,K,L,A1,LONG UN;
       FUNCTION DELPG(F,P) ,FRETURN,MONITOR←25;
       CKOFTAC(F,1,0//FRETURN);
       FRETURN M32 IF OFT[F]$TYPE>LFILET;
       RETURN -1 IF (P<0 OR P>MAXLP) AND OFT[F]$TYPE=LFILET;
       RETURN -1  IF (P<0 OR P>MAXP) AND OFT[F]$TYPE=SFILET;
       RDMIB2(F,0//FRETURN);
       CKOBTAC(F:E,I//FRETURN);
       UN$WD0←MIBA[I]; UN$WD1←MIBA[I+1] V' (P+1);
       GOTO CAL10 IF OFT[F]$TYPE=LFILET;
       J ← I+FDA;
       RETURN -1 IF J+P>(A1←MIBA[E]$SIBA+MIBA[E]$SIBL-1);
       (A1←-1 & GOTO CAL2) IF MIBA[J+P]$U=0;
       MIBA[J+P]$U←A1←0;
       DESTROY'PG(MIBA[J+P],UN);
*         DELETE DISK PAGE. GIVE DISK ADDRESS AND UN;
CAL2:  L←0;
       FOR K←MIBA[E]$SIBA+MIBA[E]$SIBL-1 BY -1
       TO J DO;
       L←L-1 IF MIBA[K]$U=0 ELSE GOTO CAL3;
       ENDFOR;
CAL3:  MIBA[E]$SIBL←MIBA[E]$SIBL+L;
       MIBA[I]$FLEN1←MIBA[E]$SIBL-J+MIBA[E]$SIBA;
       RETURN A1;
CAL10: RDIBCB2(F,1//FRETURN);
       RETURN -1 IF MIBB[P]$U=0;
       MIBB[P]$U←0;
       GOTO CAL11 IF MIBA[E]$FLEN1>P+1;
       L←P+1;
       FOR K←P BY -1 TO 0 DO;
       L←L-1; GOTO CAL12 IF MIBB[K]$U#0;
       ENDFOR;
CAL12: MIBA[I]$FLEN1←L+1;
CAL11: DESTROY'PG(MIBB[P],UN);
       RETURN 0;

       END;

       PROGRAM  GNXTPG;
*
*   GIVE NEXT PAGE AFTER PAGE M OF FILE F;
*
       INCLUDE ERRD,FLS,PROFILE;
       DECLARE ACW,E,I,J,A1;
       FUNCTION GNXTPG(F,P) ,FRETURN,MONITOR←26;
       CKOFTAC(F,0,0//FRETURN);
       FRETURN M32 IF OFT[F]$TYPE>LFILET;
       GOTO CAL1 IF OFT[F]$TYPE=LFILET;
       FRETURN M17 IF P<-1 OR P>MAXP;
       RDMIB2 (F,0//FRETURN);
       CKOBTAC(F:E,I//FRETURN);
       J←I+FDA;
       RETURN -1 IF J+P+1>(A1←MIBA[E]$SIBA+MIBA[E]$SIBL-1);
       FOR I←J+P+1 TO A1 DO;
       RETURN (I-J) IF MIBA[I]$U=1;
       ENDFOR;
       RETURN -1;
CAL1:  FRETURN M17 IF P<-1 OR P>MAXLP;
       RDIBCB2(F,1//FRETURN);
       RETURN -1 IF P=MAXLP;
       FOR I←P+1 TO MAXLP DO;
       RETURN I IF MIBB[I]$U=1;
       ENDFOR; RETURN -1;

       END;

       PROGRAM FREE'PMT;
*
*  EITHER FREE A MONITOR PMT ENTRY OR FIND A SPECIFIC ENTRY
*
       INCLUDE FLS,PROFILE,ERRD;
       DECLARE F,I,J,K,FLAG,LONGLONG RN;
       FUNCTION FREE'PMT(),FRETURN;
       FLAG←0;
CAL3:  FOR I←0 TO (NPMTE-1)/24 DO;
       IF MIBAR[I]#0 DO;
         FOR J←0 TO 23 DO;
         K←I*24+J+1;
           IF (MIBAR[I] LSH J) < 0 DO;
           IF FLAG DO;
           (RETURN K) IF PMT[K]$PMTCL=MNAME AND
           PMT[K]$PMTUN2=RN$WD1 AND PMT[K]$PMTUN1=RN$WD0
           AND PMT[K]$PMTDKA=RN$WD2;
           ELSE DO;
             IF K#MPMTA AND K#MIBPMTA AND K#MIBPMTB DO;
               FOR F←1 TO OFTL DO;
               GOTO CAL1 IF OFT[F]$U=1 AND
               (K=OFT[F]$OFTMIB OR K=OFT[F]$OFTIB);
               ENDFOR;
             MDELPMT(K,MKEY//VALUE PUNT(J):J,I);
             MIBAR[I]←MIBAR[I] E' (4B7 RSH J);
             RETURN K;
             ENDIF;
CAL1:      ENDIF;
           ENDIF;
         ENDFOR;
       ENDIF;
       ENDFOR;
       FRETURN IF FLAG ELSE FRETURN ('PMO',118);
*
       ENTRY FIND'PMT(RN),FRETURN;
       FLAG←1; GOTO CAL3;

       END;

       PROGRAM  RDMIB1;
*
*   READ MIB AND RETURN CORE ADDRESS;
*
       INCLUDE ERRD,FLS,PROFILE,RESMON,SPTD,PMTD,GLOBAL;
       DECLARE I,E,J,K,L,F;
       DECLARE FIXED FIELD UNMSK(0:8,23), DKMSK(1:2,23),USM(0:2,17);
       DECLARE FIXED LONG FIELD LF0(0);
       DECLARE ARRAY MIBX;
       DECLARE LONG UNDK, LONGLONG RN;
       DECLARE RN0=RN$WD0,RN1=RN$WD1;
       FUNCTION RDMIB1(ARRAY N,INTEGER A1),FRETURN;
       UNDK$WD0←N[0]; UNDK$WD1←N[1];
       GOTO CAL1;
       ENTRY RDMIB(LONG UNDK,INTEGER A1),FRETURN;
CAL1:  (K←MIB0PMT & GOTO CAL3) IF UNDK$WD0=-1;
       FRETURN('UNO',200) UNLESS 
          (1<=UNDK$UNMSK AND UNDK$UNMSK<=NUMBER'MIBS);
       FRETURN('UNO',200) IF MIBDKA'ARRAY[UNDK$UNMSK]=0;
       RN←LONGLONG'ZERO;
       RN$USM←UNDK$UNMSK;
       RN$WD2←MIBDKA'ARRAY[UNDK$UNMSK];
CAL11: FIND'PMT(RN:K//CAL2);
       GOTO CAL3;
CAL2:  MACQPMT(-1,MNAME:K//FRETURN);
       MIBAR[(K-1)/24]←MIBAR[(K-1)/24] V' (4B7 RSH((K-1) MOD 24));
CAL5:  PMT[K]$PMTUN←RN$LF0;
       PMT[K]$PMTDKA←RN$WD2;
       PMT[K]$PMTFP←1;
CAL3:  MIBPMT←K; L←0; MIBPMTA←K IF A1=0 ELSE MIBPMTB←K;
       FOR I←MMAPA TO MMAPB DO;
       RDPRMB(I:E);
       (L←I & GOTO CAL10) IF (E A' 377B)=K;
       L←I IF E=0;
       ENDFOR;
       GOTO CAL8 IF L#0;
CAL12: L←MAPCYCLE IF MAPCYCLE <= MMAPB AND MAPCYCLE>MMAPA-1 ELSE
       (L←MAPCYCLE←MMAPA);
       (MAPCYCLE←MAPCYCLE+1 & GOTO CAL12)
       IF (A1=0 AND (@MIBB.MADF1)/2048=L)
       OR (A1=1 AND (@MIBA.MADF1)/2048=L);
CAL8:  SETPRMB(L,K);
CAL10: MIBX←ARRAY'D; (@MIBX).MADF1←L*2048;
       MAPCYCLE←L+1;
       L←MIBX[0];
       MIBA←MIBX IF A1=0 ELSE MIBB←MIBX;
       RETURN;
*
       ENTRY RDIBCB2(F,A1),FRETURN;
       K←OFT[F]$OFTIB;
       GOTO CAL9;
*
*
       ENTRY RDIBCB(RN0,RN1,K,A1),FRETURN;
       RN$WD2←K A' (2B7-1);
       GOTO CAL11;
*
       ENTRY RDMIB2(F,A1),FRETURN;
       K←OFT[F]$OFTMIB;
CAL9:  FRETURN M2 IF K=0 ELSE GOTO CAL3;

       END;

       PROGRAM  MAKRM;
*
*
*  MAKE ROOM FOR SIB ENTRY
*
       INCLUDE ERRD,FLS,PROFILE;
       DECLARE I,A1,A2,X2,NW, BOT;
       FUNCTION MAKRM(E,N),FRETURN;
CAL8:  TOP←SIBS; BOT←SIBE;
       GOTO CAL1 IF E = OBTE;
       FOR I←E+1 TO OBTE DO;
       (BOT←MIBA[I]$SIBA-1 & GOTO CAL1) IF MIBA[I]$U=1;
       ENDFOR;
CAL1:  GOTO CAL2 IF E=OBT;
       FOR I←E-1 BY -1 TO OBT DO;
       (TOP←MIBA[I]$SIBA+MIBA[I]$SIBL & GOTO CAL2)
       IF MIBA[I]$U=1;
       ENDFOR;
CAL2:  RETURN IF BOT-TOP+2>N AND MIBA[E]$U=0;
       GOTO CAL4 IF MIBA[E]$U=0;
       RETURN IF (A1←BOT-MIBA[E]$SIBL-MIBA[E]$SIBA+2)>N;
       A2←MIBA[E]$SIBA-TOP;
       GOTO CAL3 IF A2=0;
       BLOCKM(@MIBA[MIBA[E]$SIBA],@MIBA[TOP], MIBA[E]$SIBL);
       MIBA[E]$SIBA←TOP;
CAL3:  RETURN IF A2+A1>N; NW←N-A2-A1+1;
CAL4:  NW←N-BOT+TOP-1 IF MIBA[E]$U=0;
       GOTO CAL5 IF E=OBTE; X2←SIBE; A1←0;
       FOR I←OBTE BY -1 TO E+1 DO;
       IF MIBA[I]$U=1 DO;
       A1←X2-MIBA[I]$SIBA-MIBA[I]$SIBL+1;
       GOTO CAL6 IF A1=0; A1←NW IF A1>=NW;
       A2←MIBA[I]$SIBA;
       BLOCKM(@MIBA[A2],@MIBA[A2+A1], MIBA[I]$SIBL);
       MIBA[I]$SIBA←A2+A1;
CAL6:  X2←MIBA[I]$SIBA-1;
       ENDIF;
       ENDFOR; NW←NW-A1;
       GOTO CAL8 IF NW<1;
CAL5:  FRETURN M20 IF E=OBT; X2←SIBS; A1←0;
       FOR I← OBT TO E-1 DO;
       IF MIBA[I]$U=1 DO;
       A1←MIBA[I]$SIBA-X2; GOTO CAL7 IF A1=0;
       A1←NW IF A1>NW; A2←MIBA[I]$SIBA;
       BLOCKM(@MIBA[A2],@MIBA[A2-A1], MIBA[I]$SIBL);
       MIBA[I]$SIBA←X2←A2-A1;
CAL7:  X2←X2+MIBA[I]$SIBL;
       ENDIF; ENDFOR; NW←NW-A1;
       FRETURN M20 IF NW>0 ELSE GOTO CAL8;

       END;

       PROGRAM PATRON;
*
*  FIND PATRON OF MIB
*
       INCLUDE FLS,PROFILE,SPTD;
       DECLARE AT,OA';
       FUNCTION PATRON(ARRAY MIBX);
       FOR AT←OA,(AT RSH 6) WHILE AT#0 DO;
       IF (OA'←AT A' 77B)<=OFTL AND OA'>0 DO;
       IF OFT[OA']$U#0 AND OFT[OA']$TYPE=ACKT
          AND((OFT[OA']$OFTCL V' OFT[OA']$OFTAL) A' SPKEY)#0 DO;
       IF OFT[OA']$OFTUN1=0 AND (OFT[OA']$OFTUN2=MIBX[MIBUN]
          OR OFT[OA']$OFTUN2=MIBX[MIBAN]
          OR OFT[OA']$OFTUN2=MIBX[MIBGR]
          OR OFT[OA']$OFTUN2=MIBX[MIBSYS']) DO;
       RETURN ((1@O)$RWXO);
       ENDIF;
       ENDIF;
       ENDIF;
       ENDFOR;
       RETURN 0;

       END;

       PROGRAM FILE'ACCESS;
       INCLUDE FLS,PROFILE,SPTD;
*
*  FILE ACCESS FUNCTIONS;
*
       DECLARE ARRAY MIBX;
       DECLARE I,J,K,A1,E,AT,ACW,OA';
       ENTRY GET'ACC(AT,MIBX);
       (I←AT & GOTO CAL2) IF AT>15;
       FOR I←OBT TO OBTE DO;
         IF MIBX[I]$U=1 AND MIBX[I]$T=AT DO;
CAL2:      J←MIBX[I]$SIBA; K←MIBX[J]$LKL; J←J+FLK;
           ACW←0;
           FOR E←OA,(E RSH 6) WHILE E#0 DO;
           IF (OA'←E A' 77B)<=OFTL AND OA'>0 DO;
           IF OFT[OA']$U#0 AND OFT[OA']$TYPE=ACKT
              AND((OFT[OA']$OFTCL V' OFT[OA']$OFTAL) A' SPKEY)#0 DO;
           FOR A1←J BY 2 TO J+K-2 DO;
             IF OFT[OA']$OFTUN1=MIBX[A1]$LV1 AND
                OFT[OA']$OFTUN2=MIBX[A1]$LV2 DO;
                ACW←MIBX[A1]$RWXO V' ACW;
             ENDIF;
          ENDFOR;
          ENDIF;
          ENDIF;
          ENDFOR;
          RETURN ACW;
        ENDIF;
       ENDFOR;
       RETURN 0;
*
*
       FUNCTION SIBAC(E);
       MIBX←MIBA;
       GOTO CAL1;
       ENTRY MIBAC(); MIBX←MIBA;
CAL3:  E←0;
CAL1:
*** TEMPORARY REMOVAL OF ALL ACCESS CHECKING
       RETURN ((-1)@RWXO);
***
       A1←MIBX[E]$SIBA IF E;
       GET'ACC(MIBACKT,MIBX:ACW);
       IF ACW#0 DO;
       ACW ← ACW V' PATRON(MIBX);
       ELSE DO;
       ACW ← 17B IF PATRON(MIBX)#0;
       ENDIF;
       ACW←ACW A' MIBX[A1]$PFOO IF E;
       GOTO CAL4 IF E=0 OR ACW=17B;
       ACW←ACW V' (GET'ACC(FRIENDT,MIBX) A' MIBX[A1]$PFOF);
       GOTO CAL4 IF ACW=17B;
       ACW←ACW V' GET'ACC(E,MIBX);
       ACW←ACW V' MIBX[A1]$PFOP;
CAL4:  RETURN ACW@RWXO;
*
       ENTRY SIBACB(E);
       MIBX←MIBB; GOTO CAL1;
*
       ENTRY MIBACB();
       MIBX←MIBB; GOTO CAL3;

       END;

       PROGRAM  FILEACC;
*
*
*  DISK SPACE ACCOUNTING FOR FILES
*
       INCLUDE FLS,PROFILE,ERRD,SWPD,RESMON;
       DECLARE FIXED LONG FIELD LF(0);
       DECLARE LONG LW;
       DECLARE I,J,K=LW$WD0,L=LW$WD1,MEC,MEM;

       FUNCTION FILEACC(E),FRETURN;
       FRETURN M55 IF(MIBA[DISK'USED]+E)>MIBA[DISK'RESOURCES];
       REALT(:I,J);
       L←I-MIBA[DISK'CHARGE'TIME];
       K←MIBA[DISK'USED];
       .LDA K; .MUL L; .ASHD (-1); .STD K;
       FLTADDL(LW,MIBA[DISKAC1]$LF:LW);
       MIBA[DISKAC1]$LF←LW;
       MIBA[DISK'CHARGE'TIME]←I;
       MIBA[DISK'USED]←MIBA[DISK'USED]+E;
       RETURN;
*
*  DESTROY PAGE AND DECREMENT DISK CHARGES
*
       ENTRY DESTROY'PG(I,LW);
       FILEACC(-1//VALUE PUNT('DKE'));
       AMC'REQ'WITH'RN(CRDEST, LW, I, @PRT[PRTI], 1//
            VALUE PUNT(MEC):MEC, MEM);
       REL'DISK'ADDR(I// VALUE PUNT('KBT'));
       RETURN;

       END;

       PROGRAM RD'M'A;
       INCLUDE FLS,ERRD;
       DECLARE ACW,E,MA,OACC,ARRAY N;
*
*  READ MIB AND FIND OBJECT
*
       FUNCTION RDM'GETE'ACC(N,MA,OACC),FRETURN;
       RDMIB1(N,0//FRETURN);
       GETE(N:E//FRETURN);
       ACW←(MIBAC() IF MA ELSE 0);
       ACW←SIBAC(E) V' ACW;
       FRETURN M26 IF OACC=1 AND ACW$O=0;
       RETURN (ACW,E);

       END;

       PROGRAM GET'PTR;
       INCLUDE PROFILE,FLS;
       DECLARE E,ACW;
       ENTRY GET'PTR(E);
       ACW←MIBA[E]$SIBA;
       RETURN (MIBA[ACW]$LKL+ACW+FLK);

       END;

       PROGRAM CK'OFT;
       INCLUDE FLS,ERRD;
       ENTRY CK'OFT(F),FRETURN;
       FRETURN M36 IF F<1 OR F>OFTL;
       FRETURN M12 IF OFT[F]$U=0;
       RETURN;

       END;

       PROGRAM UNIQUE;

*GENERATE UNIQUE NAME OR ACCESS KEY
*RQ=0,1 FILE, RQ=2 PROCESS, RQ=3 ACCESS KEY

       INCLUDE RESMON,FLS,GLOBAL,ERRD;
       DECLARE LONG A1,A2;
       DECLARE FLAG,I=A1$WD0,J=A1$WD1;
       DECLARE FIXED FIELD F1(0:0,1);
       LONG FUNCTION UNIQUE(RQ);
       IF RQ=ACKT DO;
       .RUN; .ETR 77777B; .LSHD -1; .STD A1;
       FLTADD(I,J,0,2B5:I,J); RETURN A1;
       ELSE DO;
       I←(MIBA[MIBUN] LSH 6) V' RQ@F1;
CAL1:  FLAG←MIBA[UNIQUE'NAME]←MIBA[UNIQUE'NAME]+1;
       PUNT('UNE') IF FLAG>(2B7-1);
       GOTO CAL1 IF (FLAG A' 7)#0 AND RQ=LFILET;
       .ZOA; .LDB FLAG; .LSHD 8; .IOR I; .STD A2;
       RETURN A2;
       ENDIF;

       END;

       PROGRAM ACTPR;
       INCLUDE FLS,ERRD,RESMON,PROFILE,GLOBAL,CHIOD;
       DECLARE E,I,J,K,L,M,MX,FLAG,ACW;
*
*  ACTIVATE PROCESS
*
     FUNCTION ACTPR(ARRAY N,I' X1,RES,OA),FRETURN,MONITOR←132;
       FLAG←0;
CAL2:  RDM'GETE'ACC(N,0,1:ACW,E//FRETURN);
       M←MIBPMT;
       FRETURN M32 IF MIBA[E]$T#PROCT;
       GET'PTR(E:J);
       GOTO CAL3 IF FLAG#0; FRETURN M16 IF MIBA[J]$PROCMOD=0 AND
          MIBA[J]$PROCI=0;
       RDIBCB(MIBA[J]$PROCUN1,MIBA[J]$PROCUN2,MIBA[J]$PROCDKA,
          1//FRETURN); FLAG←1;
       MX←MIBPMT; GOTO CAL2;
CAL3:  REALT(:K,L);
       FRETURN M48 IF (MIBA[J]$PROCMOD>K)
          OR (MIBA[J]$PROCUN1=PRT[MIBA[J]$PROCPRT]$PRUN1
          AND MIBA[J]$PROCUN2=PRT[MIBA[J]$PROCPRT]$PRUN2);
       FOR I←2 TO PRTL DO;
       GOTO CAL1 IF PRT[I]$PRACT=0 AND PRT[I]$PRUN1=0
          AND PRT[I]$PRUN2=0;
       ENDFOR; FRETURN M7;
CAL1:  FRETURN M9 IF MIBB[@CBVERS-M'G]#CBVERS;
       GOTO CAL4 IF X1=-2;
       FRETURN M34 IF X1<-2 OR X1>NCLP;
       FRETURN M34 IF X1=-1 AND UTTY=-1;
       X1←(UTTY RSH 1) IF X1=-1;
       FRETURN M34 IF MTA[X1]$PROC#PRTI;
       MTA[X1]$PROC←I;
       (UTTY←-1 & GOTO CAL5) IF (MIBB[@UTTY-M'G]←(X1 LSH 1))=UTTY;
       GOTO CAL4;
CAL5:  GOTO CAL4 IF ATTY=-1;
       MTA[ATTY RSH 1]$LQNK←(X1 IF MTA[ATTY RSH 1]$LF#2 ELSE I);
       MIBB[@ATTY-M'G]←ATTY; ATTY←-1;
CAL4:  MIBA[J]$PROCPRT←MIBB[@PRTI-M'G]←I;
       PROTECT(PRO1);
          BSET(@PRT[I],0,12);
          PRT[I]$PRUNL←MIBA[J]$PROCUNL;
          PRT[I]$PRDK←MIBA[J]$PROCDKA;
          MIBB[@MIBDKA-M'G]←PMT[M]$PMTDKA;
          PRT[I]$PRACT←1;****** GO
       UNPROTECT(PRO1);
       MIS1CALL((@PRT[I]-RESM) V' WAKEUPC,0);
*  SEND 'DISK TO DRUM TRANSFER' REQUEST TO AMC
       AMC'REQUEST(CRKD, MX, I, 1// VALUE PUNT(MEC):MEC,MEM);
       RETURN I;

       END;

       PROGRAM GET'CB;
       INCLUDE ERRD,PROFILE,FLS;
       DECLARE E,I;
*
*  CHECK OFT ACCESS FOR PROCESS MANIPULATIONS
*
     FUNCTION GET'CB(F,RW,AOC),FRETURN;
       CKOFTAC(F,RW,AOC//FRETURN(E,I):E,I);
       FRETURN M32 IF OFT[F]$TYPE#PROCT;
       FRETURN M69 IF OFT[F]$OFTMOD#1;
       RDIBCB2(F,0//FRETURN(E,I):E,I);
       RETURN @MIBA[0];

       END;

       PROGRAM GO'DORM;
       INCLUDE ERRD,FLS,PROFILE,RESMON,PMTD,ICTD;
       DECLARE E,I,J,K,L,FLAG,ACW;
*
*  MAKE PROCESS DORMANT MONITOR CALL
*
     FUNCTION GO'DORM(ARRAY N,OA),FRETURN,MONITOR←134;
       GOTO CAL1 IF N[2]=0;
       RDM'GETE'ACC(N,0,1:ACW,E//FRETURN);
       FRETURN M32 IF MIBA[E]$T#PROCT;
       GET'PTR(E:J);
       K←MIBA[J]$PROCPRT;
       FRETURN M53 IF K>PRTL;
       FRETURN M53 IF PRT[K]$PRUN2#MIBA[J]$PROCUN2
          OR PRT[K]$PRUN1#MIBA[J]$PROCUN1
          OR PRT[K]$PRACT=0;
       PROTECT(PRO1);
          PRT[K]$PRDOR←1;
       UNPROTECT(PRO1);
       RETURN;
CAL1:  SLEEPY(0//FRETURN);
       RETURN;

       END;

       PROGRAM SLEEPY;
       INCLUDE CHIOD,FLS,ERRD,PROFILE;
       DECLARE E,I,J;
*
*  MAKE PROCESS DORMANT
*
     FUNCTION SLEEPY(I),FRETURN;
       GOTO CAL1 IF UTTY=-1;
       GOTO CAL2 IF ATTY=-1;
       MTA[ATTY RSH 1]$LQNK←MTA[ATTY RSH 1]$LF←0;
       ATTY←-1;
CAL2:  I ← @MTA[UTTY RSH 1];
       I.BWS ← -1;
       I.LF ← I.ES ← I.EBC ← 0;
       I.PROC ← 1;
       UTTY←-1;
*
*  RELEASE ALL TTY BUFFERS ***** DISCONNECT LINE
CAL1:  FOR I←MPMTA TO NPMTE DO;
       RELEASE'THIS'DWS(I//CAL3:E,J)
         IF PMT[I]$PMTCL#0 AND PMT[I]$PMTDKA#0;
CAL3:  ENDFOR;
       MIS1CALL(CHANGERTC+@PRT[PRTI]-RESM,-1);
       PRT[PRTI]$PRPRD←1;
CAL4:  MIS1CALL(2B6+1,0);
       XMBLOCK(UNLOADC);
       SCHED(0);
       GOTO CAL4 IF PRT[PRTI]$PRPRD;
       RETURN;

       END;

       PROGRAM COPYACK;
       INCLUDE ERRD,FLS,PROFILE;
       DECLARE I,J,K,E,ACW;
*
*  COPY ACCESS KEY FROM MIB TO MIB
*
       FUNCTION COPYACK(ARRAY N,L,I' FR,OA,K2),FRETURN,MONITOR←14;
       RDMIB1(N,1//FRETURN);
       RDMIB1(L,0//FRETURN);
       GETE(L:E//CAL1:E,I);
       FRETURN M28;
CAL1:  GETEB(N:E//FRETURN);
       FRETURN M32 IF MIBB[E]$T#ACKT;
       SIBACB(E:ACW);
       FRETURN M8 IF ACW$RWXO=0;
       FOR J←OBT TO OBTE DO;
       GOTO CAL2 IF MIBA[J]$U=0;
       ENDFOR; FRETURN M21;
CAL2:  OA←K2;
       MIBAC(:K);
       FRETURN M23 IF K$O=0;
       MAKRM(J,FLK+2//FRETURN);
       I←MIBB[E]$SIBA; I←I+MIBB[I]$LKL;
       FRETURN M54 IF MIBB[I]$ACKFR=1;
       MIBA[J]$SIBA←TOP; MIBA[J]$T←ACKT;
       FOR K←3 TO 7 DO;
       MIBA[TOP]←L[K]; TOP←TOP+1; ENDFOR;
       L[2]←J-OBT; MIBA[TOP]←0;
       MIBA[TOP+1]←MIBB[I]$LV1;
       MIBA[TOP+2]←MIBB[I]$LV2;
       MIBA[J]$SIBL←FLK+2;
       MIBA[TOP+1]$ACKFR←1 IF ACW$W=0 OR FR=1;
       MIBA[J]$U←1;
       RETURN;

       END;

        PROGRAM COPY'PMT;
*
*  COPY PMT FOR PROCESSES
*
          INCLUDE PROFILE, SPTD, PMTD, GLOBAL;
          DECLARE MEC, MEM, PMTX', FIXED FIELD WD1(1:0,23);
          DECLARE ARRAYONE SPT', LONGLONG ARRAYONE PMT';
          DECLARE CB;
        ENTRY COPY'PMT(OFTX, PMTX), FRETURN, MONITOR ← 130;
*  CHECK OFTX AND PMTX
          CB ← GET'CB(OFTX, 1, 0//FRETURN(MEC, MEM): MEC, MEM);
          FRETURN('PMI', 110) UNLESS (1<=PMTX AND PMTX<=NPMTE);
          FRETURN('PMC', 121) IF (SPKEY A' PMT[PMTX]$PMTCL)=0;
          FRETURN('PNF', 185) IF PMT[PMTX]$PMTFP=0;
*  MAKE DESCRIPTORS FOR PMT AND SPT IN THE OTHER CONTEXT BLOCK
          PMT' ← PMT;
          PMT'$WD1 ← CB+PMTS V' XTAG;
          SPT' ← SPT;
          SPT'$WD1 ← CB+SPTS V' XTAG;
*  CHECK THAT SPT'[1] HAS BEEN INITIALIZED
          FRETURN('NSP', 183) IF SPT'[1]$SPTOL=0;
*  FIND FREE ENTRY IN PMT'
          FOR PMTX' ← 1 TO NPMTE DO;
             GOTO CPMT20 IF PMT'[PMTX']$PMTCL=0;
          ENDFOR;
          FRETURN('PMO', 184);
*  ACQUIRE PMT'[PMTX'] FOR SPT'[1] AND COPY PMT[PMTX] INTO IT.
CPMT20:   PMT'[PMTX'] ← PMT[PMTX];
          PMT'[PMTX']$PMTRF ← 0;
          PMT'[PMTX']$PMTSF ← 0;
          PMT'[PMTX']$PMTCCE ← 0;
          PMT'[PMTX']$PMTAL ← 2;
          PMT'[PMTX']$PMTCL ← 2;
*
          RETURN PMTX';
*

        END;

        PROGRAM INITIALIZE'MAP;
          INCLUDE PROFILE, SPTD, PMTD, GLOBAL;
          DECLARE ARRAYONE SPT', LONGLONG ARRAYONE PMT';
          DECLARE CB, MEC, MEM, BSNM, LNM, LM, ML, BYTE, I,PMTX;
          DECLARE STRING SPMAP(64:8);
          DECLARE FIELD FLD, WD1(1:0,23);
        ENTRY INITIALIZE'MAP(OFTX, STRING NEWMAP), FRETURN,
                                             MONITOR ← 136;
*  GET BASE ADDRESS FOR CONTEXT BLOCK AND CHECK OFT ENTRY.
          CB ← GET'CB(OFTX, 1, 0//FRETURN(MEC, MEM): MEC, MEM);
*  MAKE DESCRIPTORS FOR SPT AND PMT IN THE OTHER CB.
          SPT' ← SPT;
          SPT'$WD1 ← CB+SPTS V' XTAG;
          PMT' ← PMT;
          PMT'$WD1 ← CB+PMTS V' XTAG;
*  CHECK THAT SPT'[1] HAS BEEN INITIALIZED.
          FRETURN('NSP', 183) IF SPT'[1]$SPTOL=0;
*  CHECK STRING DESCRIPTOR.
          BSNM ← BYTESIZE(NEWMAP);
          LNM ← LENGTH(NEWMAP);
          LM ← (32 IF SPT'[1]$SPTRING=1 ELSE 64);
          FRETURN('SPM', 100) UNLESS
             ((BSNM=12 OR BSNM=24) AND (0<=LNM AND LNM<=LM));
*  COPY NEWMAP INTO THE MAP OF SPT'[1], CHECKING EACH BYTE.
       BSET(@(SPT'[1]$SPTMAP),0,24);
          SETUP(SPMAP, LNM, @(SPT'[1]$SPTMAP), 8);
          FLD ← SPTROBITS;
          ML ← 0;
          FOR I ← 0 TO LNM-1 DO;
             BYTE ← GCI(NEWMAP//VALUE PUNT('GCI'));
       GOTO BYTE'OKAY IF (PMTX←BYTE$SPTPMT)=0;
       IF PMTX=1 DO;
       GOTO BYTE'OKAY IF (SPT'[1]$SPTRING=1 AND I=0);
       ENDIF;
       FRETURN ('SPM',101) UNLESS (1<=PMTX AND PMTX<=NPMTE);
       FRETURN ('SPM',101) IF PMT'[PMTX]$PMTCL=0 OR
          2 A' (PMT'[PMTX]$PMTCL V' PMT'[PMTX]$PMTAL)=0;
BYTE'OKAY:   WCI(BYTE$SPTPMT, SPMAP//VALUE PUNT('WCI'));
             SPT'[1]$FLD ← BYTE$SPTRO;
             FLD$FDFB ← FLD$FDFB+1;
             IF FLD$FDFB >= 24 DO;
                FLD$FDDISP ← FLD$FDDISP+1;
                FLD$FDFB ← 0;
             ENDIF;
              ML ← I IF BYTE$SPTPMT#0;
          ENDFOR;
          SPT'[1]$SPTLM ← ML;
*
          RETURN;
*

        END;

        PROGRAM INITIALIZE'SPT;
          INCLUDE PROFILE, SPTD, GLOBAL,FLS,ERRD;
          DECLARE CB,NAME,MEC,MEM;
          DECLARE ARRAYONE SPT';
          DECLARE FIELD WD1(1:0,23);
        ENTRY INITIALIZE'SPT(OFTX, RING, OFTN), FRETURN, MONITOR ← 137;
*  CHECK NEW OFT ACCESS
       CKOFTAC(OFTN,0,1//FRETURN);
       FRETURN M32 IF OFT[OFTN]$TYPE#ACKT;
*  GET BASE ADDRESS OF CONTEXT BLOCK AND CHECK OFT ENTRY
          CB ← GET'CB(OFTX, 1, 0//FRETURN(MEC, MEM): MEC, MEM);
*  CHECK REASONABLENESS OF RING.
          FRETURN('ARG', 193) UNLESS (RING=0 OR RING=1);
*  MAKE DESCRIPTOR FOR SPT IN THE OTHER CONTEXT BLOCK
          SPT' ← SPT;
          SPT'$WD1 ← CB+SPTS V' XTAG;
*  CLEAR SPT' AND INITIALIZE SPT'[1] AS A NORMAL SUB-PROCESS IN THE
*  SPECIFIED RING.
          BSET(@SPT'[1], 0, LSPTE*NSPTE);
          NAME ← 2;
          SPT'[1]$SPTOL ← NAME;
          SPT'[1]$SPTCL ← NAME;
          SPT'[1]$SPTKEY ← NAME;
          SPT'[1]$SPTCTRL←NAME;
          SPT'[1]$SPTFATHER ← 0;
          SPT'[1]$SPTUSP ← (0 IF RING=0 ELSE 1);
          SPT'[1]$SPTRING ← RING;
          SPT'[1]$SPTEP ← (USER'EP IF RING=0 ELSE UTILITY'EP);
          SPT'[1]$SPTEG ← (USER'EG IF RING=0 ELSE UTILITY'EG);
          SPT'[1]$SPTSB ← NORMAL'SB;
          SPT'[1]$SPTTM ← NORMAL'TM;
          SPT'[1]$SPTSCB ← NORMAL'SCB;
          SPT'[1]$SPTTCM ← NORMAL'TCM;
*  INITIALIZE ACSPT'
          $(CB+@ACSPT-M'G) ← NAME;
*
*  INITIALIZE OFT IN PROCESS
       MEC←CB+@OFT[OFTN]-M'G;
       BLOCKM(@OFT[OFTN],MEC,5);
       MEC.OFTCL←MEC.OFTAL←NAME;
          RETURN;

       END;

        PROGRAM INIT'PAGE;
          INCLUDE PROFILE, PMTD;
          DECLARE CB,I,PMTE,ARRAY PMT';
        ENTRY INIT'PAGE(OFTX,PMTX',ST,NW,
          ARRAY PG),FRETURN,MONITOR ← 135;
          CB ← GET'CB(OFTX,1,0//FRETURN);
          PMT' ← PMT;
          PMT'$WD1 ← CB+PMTS V' XTAG;
          FRETURN('PMI',110) UNLESS (1<=PMTX' AND PMTX'<=NPMTE);
          PMTE ← @PMT'[PMTX'];
          FRETURN('PMC',121) UNLESS
             (PMTX'=1 OR (PMTE.PMTCL A' 2)#0);
          FRETURN('PNP',999) IF (PMTE.PMTFP=1 OR PMTE.PMTDKA=0);
          FRETURN('EWC',50) IF (ST<0 OR (PMTX'=1 AND
             ST<3000B) OR ST+NW>4000B OR NW<1);
          IF PMTX'=1 DO;
             CB[ST+I] ← PG[I] FOR I ← 0 TO NW-1;
          ELSE DO;
             RDIBCB(PMTE.PMTUN1,PMTE.PMTUN2,PMTE.PMTDKA,1//FRETURN);
             MIBB[ST+I] ← PG[I] FOR I ← 0 TO NW-1;
          ENDIF;
          RETURN;

        END;


       PROGRAM INIT'MIB;
*
*  INITIALIZE MIB
*  MA[0]=USER#,MA[1]=ACCOUNT#,MA[2]=GROUP#,MA[3]=SYSTEM#
*
       INCLUDE FLS,ERRD,GLOBAL,PROFILE,SPTD,RESMON,SWPD;
       DECLARE LONG UN;
       DECLARE I=UN$WD0,J=UN$WD1,DK,K,L,MEC,MEM;
       FUNCTION INIT'MIB(ARRAY MA),FRETURN,MONITOR←190;
       FRETURN('UNO',200) UNLESS 
          (1<=MA[0] AND MA[0]<=NUMBER'MIBS);
       FRETURN('UNO',200) IF (MIBDKA'ARRAY[MA[0]])#0;
*      FRETURN M33 UNLESS SPSTATUS$SYS;
       I←(MA[0] A' 177777B) LSH 6; J←0;
       DK←GET'DISK'ADDR(CVDK(MA[0])// VALUE PUNT('KBT'));
       AMC'REQ'WITH'RN(CRWUN, UN, DK, @PRT[PRTI], 1//
            VALUE PUNT(MEC):MEC, MEM);
       RDIBCB(I,J,DK,0//CAL1:K,L);
       MIBA[MIBUN]←MA[0]; MIBA[MIBAN]←MA[1];
       MIBA[MIBGR]←MA[2]; MIBA[MIBSYS']←MA[3];
       RETURN (MIBDKA'ARRAY[MA[0]] ← DK);
CAL1:  DESTROY'PG(DK,UN);
       FRETURN (K,L);

       END;

       PROGRAM MOVE'DA;
*
*  MOVE DISK RESOURCES
*
       INCLUDE FLS,PROFILE,ERRD;
       FUNCTION MOVE'DA(LONG UNDK1,UNDK2,INTEGER N,OA),
            FRETURN, MONITOR←149;
       RDMIB(UNDK1,0//FRETURN);
       RDMIB(UNDK2,1//FRETURN);
       FRETURN M62 IF PATRON(MIBA)=0 OR PATRON(MIBB)=0;
       FRETURN M59 IF MIBA[DISK'RESOURCES]-MIBA[DISK'USED]-N<0;
       MIBB[DISK'RESOURCES]←MIBB[DISK'RESOURCES]+N;
*      MIBA[DISK'RESOURCES]←MIBA[DISK'RESOURCES]-N;
       RETURN;

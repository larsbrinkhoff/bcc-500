        PROGRAM WRITE'STRING;
          INCLUDE CHIOD, PROFILE, GLOBAL;
          DECLARE FIXED FIELD LC(RWEB$FDDISP:16,23);
          DECLARE I, LNGTH, RESP;
          DECLARE STRING CSTR;
*
        FUNCTION WRITE'STRING(LINE, NCHRS, STRING STR), FRETURN,
                                                MONITOR ← 183;
* CONVERT DEFAULT LINE NUMBERS AND CHECK FOR ERRORS
          LINE ← CHK'LINE'ACCESS(LINE//FRETURN);
          NCHRS ← LENGTH(STR) IF NCHRS=-1;
          NCHRS ← MIN'(NCHRS, LENGTH(STR));
          FRETURN('ARG',182) IF NCHRS<0;
* PUT REQUEST IN CPUIT
          GOTO WST20 IF CPUIT.RWCH=0;
          FOR I ← 1 TO CIOWLIM DO;
             GOTO WST20 IF CPUIT.RWCH=0;
          ENDFOR;
          PUNT('CNR');
WST20:    IF MTA[LINE RSH 1]$NOQ DO;
             MTA[LINE RSH 1]$WOC ← 1;
             GOTO WST40;
          ENDIF;
          CPUIT.CRT ← WST;
          CPUIT.LNO ← LINE;
          LNGTH ← MIN'(NCHRS, 21);
          SETUP(CSTR, LNGTH, CPUIT+RWSB$FDDISP);
          WCI(GCI(STR//WST80), CSTR//WST80) FOR I ← 1 TO LNGTH;
          IF (NCHRS>21 AND CPUIT.LC=SHIFT1) DO;
             LNGTH ← LNGTH-1;
             WCD(GCD(CSTR//WST80), STR//WST80);
          ENDIF;
          CPUIT.CARG1 ← LNGTH;
          CPUIT.RWCH ← 1;
* POKE CHIO
          ATTENTION(ATT3);
* WAIT AND SEE WHAT HAPPENS
          FOR I ← 1 TO CIOWLIM DO;
             GOTO WST30 IF CPUIT.RWCH=0;
          ENDFOR;
          PUNT('CNR');
WST30:    RESP ← CPUIT.NSR;
*  POSSIBLE VALUES OF RESP AND THEIR SIGNIFICANCE ARE:
*  0:  NO ABNORMAL CONDITIONS DETECTED
*  1:  LAST BUFFER FOR LINE USED
*  2:  ILLEGAL CHARACTER ENCOUNTERED (AND IGNORED)
*  3:  SOME FUNDAMENTAL ERROR
          PUNT('CIO') IF RESP=3;
          NCHRS ← NCHRS-LNGTH;
          GOTO WST40 IF NCHRS<=0;
          GOTO WST20 IF (RESP=0 OR RESP=2);
          GOTO WST20;
*
WST40:    RETURN(STR, NCHRS);
* GCI OR WCI FAILED UNEXPECTEDLY
WST80:    PUNT('GCI');
*

        END;

        PROGRAM READ'STRING;
          INCLUDE CHIOD, PROFILE, GLOBAL;
          DECLARE LNGTH, NCH, I, RESP, TNCH, FIXED FIELD RFLD(0:0,1);
          DECLARE STRING CSTR;
*
        STRING FUNCTION READ'STRING(LINE, NCHRS, MODE, STRING STR),
                                           FRETURN, MONITOR ← 182;
* CONVERT DEFAULT LINE NUMBERS AND CHECK FOR ERRORS
          LINE ← CHK'LINE'ACCESS(LINE//FRETURN);
          LNGTH ← LNGDES(STR$SWPTR, STR$SEPTR);
          FRETURN('ARG', 188) IF (LNGTH<2 OR NCHRS<-1);
          FRETURN('ARG', 189) UNLESS (MODE=0 OR MODE=1);
          NCHRS ← LNGTH-1 IF NCHRS=-1;
          FRETURN('ARG', 188) IF NCHRS>LNGTH-1;
          TNCH ← 0;
* PUT REQUEST IN CPUIT
          GOTO RST20 IF CPUIT.RWCH=0;
          FOR I ← 1 TO CIOWLIM DO;
             GOTO RST20 IF CPUIT.RWCH=0;
          ENDFOR;
          PUNT('CNR');
RST20:    CPUIT.CRT ← (RSTB IF MODE=0 ELSE RSND);
          CPUIT.LNO ← LINE;
          CPUIT.CARG1 ← MIN'(NCHRS, 20);
          CPUIT.RWCH ← 1;
* POKE CHIO
          ATTENTION(ATT3);
* WAIT AND SEE WHAT HAPPENS
          FOR I ← 1 TO CIOWLIM DO;
             GOTO RST30 IF CPUIT.RWCH=0;
          ENDFOR;
          PUNT('CNR');
RST30:    RESP ← CPUIT.NSR;
*  POSSIBLE VALUES OF RESP AND THEIR SIGNIFICANCE ARE:
*  0:  NO ERRORS DETECTED, REQUESTED NUMBER OF CHARACTERS RETURNED
*  1:  LAST CHARACTER IN LINE READ
*  2:  BREAK CHARACTER READ (FOR RSTB ONLY)
*  3:  SOME FUNDAMENTAL ERROR
          PUNT('CIO') IF RESP=3;
          NCH ← CPUIT.VALU;
          SETUP(CSTR, NCH, CPUIT+RWSB$FDDISP);
          SETW(CSTR, NCH);
          WCI(GCI(CSTR//RST80), STR//RST80) FOR I ← 1 TO NCH;
          NCHRS ← NCHRS - NCH;
          TNCH ← TNCH + NCH;
          GOTO RST40 IF (RESP=1 OR RESP=2);
          GOTO RST20 IF NCHRS>0;
          GOTO RST40 IF RESP=0;
          PUNT('NSR');
*
RST40:    I ← RESP@RFLD V' TNCH;
          RETURN(STR, I);
* GCI OR WCI FAILED UN-EXPECTEDLY
RST80:    PUNT('GCI');
*

        END;

        PROGRAM CHIOST;
          INCLUDE CHIOD, PROFILE, GLOBAL;
          DECLARE I, RESP;
*
        FUNCTION CHIOST(LINE,CODE,DATA), FRETURN, MONITOR ← 180;
* CONVERT DEFAULT LINE NUMBERS AND CHECK FOR ERRORS
          LINE ← CHK'LINE'ACCESS(LINE//FRETURN);
* DECODE CODE
          GOTO ST10 IF (0<=CODE AND CODE<NCIOCODES);
          FOR I ← 0 TO NCIOCODES-1 DO;
             (CODE ← I & GOTO ST10) IF CIOCODES[I]=CODE;
          ENDFOR;
          FRETURN('ARG',177);

ST10:     DATA ← CHK'CIO'FCNS(LINE,CODE,DATA//FRETURN);
* PUT REQUEST IN CPUIT
          GOTO ST20 IF CPUIT.RWCH=0;
          FOR I ← 1 TO CIOWLIM DO;
             GOTO ST20 IF CPUIT.RWCH=0;
          ENDFOR;
          PUNT('CNR');
ST20:     CPUIT.CRT ← PCF;
          CPUIT.LNO ← LINE;
          CPUIT.CARG1 ← (CIOFLDS[CODE])$WD0;
          CPUIT.CARG2 ← DATA;
          CPUIT.RWCH ← 1;
* POKE CHIO
          ATTENTION(ATT3);
* WAIT AND SEE WHAT HAPPENS
          FOR I ← 1 TO CIOWLIM DO;
             GOTO ST30 IF CPUIT.RWCH=0;
          ENDFOR;
          PUNT('CNR');
ST30:     RESP ← CPUIT.NSR;
          PUNT('CIO') IF RESP=3;
          PUNT('NSR') IF RESP#0;
*
          RETURN DATA;
*

        END;

        PROGRAM READ'LINE'TABLE;
          INCLUDE CHIOD, PROFILE, GLOBAL;
          DECLARE LB, UB, MTAE, MTCE, I;
*
        ENTRY READ'LINE'TABLE(LINE, ARRAY LTE), FRETURN, MONITOR ← 181;
* CONVERT DEFAULT LINE NUMBERS AND CHECK FOR ERRORS
          LINE ← CHK'LINE'ACCESS(LINE//FRETURN);
*
          LB ← LTE$ADLB;
          UB ← (LTE$ADLUB IF LTE$ADLE=0 ELSE LTE$ADUB);
          MTAE ← @MTA[LINE RSH 1];
          MTCE ← @MTC[LINE];
          LTE[I+LB] ← MTAE[I] FOR I ← 0 TO MIN'(LMTAE, UB-LB+1)-1;
          LTE[I+LB+LMTAE] ← MTCE[I] FOR I ← 0 TO
             MIN'(LMTCE, UB-(LB+LMTAE)+1)-1;
          RETURN;

        END;

        PROGRAM CHK'CIO'FCNS;
          INCLUDE CHIOD, PROFILE, GLOBAL, ICTD, SPTD, ERRD;
          DECLARE FIELD B0'11(0:0,11), B12'23(0:12,23);
          DECLARE BST, WST, PTR, OLD'VALUE, DEVICE'NUMBER;
          DECLARE LABEL ARRAY CHECKS[NCIOCODES] ←
             (CHK'BWS, CHK'DTYPE, CHK'EST, CHK'QUITC, CHK'WKCNT,
             CHK'NAB, CHK'LAB, CHK'LF, CHK'LQN, CHK'LOK);
*
        FUNCTION CHK'CIO'FCNS(LINE, CODE, NEW'VALUE), FRETURN;
          GOTO CHECKS[CODE];

CHK'BWS:  BST ← NEW'VALUE$B0'11;
          WST ← NEW'VALUE$B12'23;
          BST ← MTA[LINE RSH 1]$BS IF BST=7777B;
          WST ← MTA[LINE RSH 1]$WS IF WST=7777B;
          FRETURN('BWS',178) UNLESS (0<=BST AND BST<=3 AND
                                     0<=WST AND WST<=3);
          NEW'VALUE ← ((BST LSH 2) V' WST);
          RETURN NEW'VALUE;

CHK'DTYPE:
          FRETURN('DTN',179) UNLESS
             (0<=NEW'VALUE AND NEW'VALUE<=MAXDTYPE);
*  DAMMIT !!
          PTR ← @MTA[LINE RSH 1];
          PTR.LFK ← (1 IF NEW'VALUE=2 ELSE 0);
          OLD'VALUE ← PTR.DTYP;
          DEVICE'NUMBER ← PTR.LDVN;
          IF OLD'VALUE#0 DO;
             PTR ← @LBTB[OLD'VALUE-1];
             PTR.NCIP ← PTR.NCIP A' N' (4B7 RSH DEVICE'NUMBER);
          ENDIF;
          IF NEW'VALUE#0 DO;
             PTR ← @LBTB[NEW'VALUE-1];
             PTR.NCIP ← PTR.NCIP V' (4B7 RSH DEVICE'NUMBER);
          ENDIF;
          RETURN NEW'VALUE;

CHK'EST:  FRETURN('EST',179) UNLESS (0<=NEW'VALUE AND NEW'VALUE<=1);
          RETURN NEW'VALUE;

CHK'QUITC:
          FRETURN('QTC',180) UNLESS
             (0<=NEW'VALUE AND NEW'VALUE<=255);
*  CALLER MUST CONTROL THE QUIT INTERRUPT.
          FRETURN M42 IF SPKEY A' ICT[5]$CLICT=0;
          RETURN NEW'VALUE;

CHK'WKCNT:
          FRETURN('WKC', 999) UNLESS (0<=NEW'VALUE AND NEW'VALUE<=7777B);
          RETURN NEW'VALUE;

CHK'NAB:
CHK'LAB:
CHK'LF:
CHK'LQN:
CHK'LOK:
          RETURN NEW'VALUE;

        FUNCTION CHK'LINE'ACCESS(LINE), FRETURN;
          LINE ← UTTY IF LINE = -2;
          LINE ← UTTY+1 IF LINE = -1;
          FRETURN('LNO', 175) UNLESS (0<=LINE AND LINE<=MAXLNO);
          RETURN LINE IF (LINE=UTTY OR LINE=UTTY+1);
          RETURN LINE IF MTA[LINE RSH 1]$PROC=PRTI;
          RETURN LINE IF SPSTATUS$SYS;
          FRETURN('LAC', 176);
*
        END;

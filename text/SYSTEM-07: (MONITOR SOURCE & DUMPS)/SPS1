        PROGRAM MLOCK'UNLOCK;
        INCLUDE GLOBAL, PROFILE, RESMON, SPTD;

*  IMPLEMENTS SYSTEM OBJECT LOCKS.  THE LOCK FUNCTION SETS AN OBJECT
*     LOCK FOR A PERIOD OF TIME NO GREATER THAN 30 SECONDS.  IF THE
*     LOCK IS OWNED BY ANOTHER PROCESS OR SUBPROCESS, THE LOCK FUNCTION
*     FRETURNS THE AMOUNT OF REAL TIME WHICH MUST ELAPSE BEFORE
*     THE LOCK IS UP FOR GRABS AGAIN.  IF SUCCESSFUL, THE LOCK FUNCTION
*     RETURNS THE KEY IT USES INTERNALLY.  THIS IS FOR EXTENDED
*     LOCKING OPERATIONS.

        DECLARE LONG PARAMETER MAX'LOCK'TIME←(0,30*1000*100);  /* 30 SEC */
        DECLARE LONG NOW, THEN, LOCK'TIME, DIFF;
        DECLARE NOW0=NOW$WD0, NOW1=NOW$WD1,
                LOCK'TIME0=LOCK'TIME$WD0, LOCK'TIME1=LOCK'TIME$WD1;
        DECLARE FIELD UHALF(0:0,11),LHALF(1:12,23),
                      PROC'NO(1:12,19),SP'NO(1:20,23);

        FUNCTION LOCK(I), FRETURN, MONITOR ←29;

*  GET PRESENT TIME PLUS MAXIMUM HOLDING TIME.
        REALTL(:NOW); FLTADDL(NOW,MAX'LOCK'TIME:THEN);

* GET PRESENT CONTENTS OF LOCK
        LOCK'TIME←LOCK'ARRAY[I];

        IF (FLTEQL(LOCK'TIME,LONG'ZERO) OR
             FLTGE(NOW0,NOW1$UHALF@UHALF,
                   LOCK'TIME0,LOCK'TIME1$UHALF@UHALF)) DO;
           THEN$PROC'NO←PRTI;
           THEN$SP'NO←SPNAME;
           LOCK'ARRAY[I]←THEN;         /* ACTUALLY SETS LOCK */
           RETURN (THEN$LHALF);        /* RETURN KEY FOR HIGHER LOCKING */
        ELSE DO;
           FRETURN (DIFF←FLTSUBL(LOCK'TIME,NOW));
        ENDIF;

*  UNLOCK RELEASES THE SPECIFIED LOCK IF THE PROCESS NUMBER AND SUB-
*     PROCESS NUMBER MATCH.  IF THEY DO NOT, THEN SOME OTHER PROCESS
*     HAS PREEMPTED THE LOCK BECAUSE WE HAVE BEEN TOO TARDY.

        FUNCTION UNLOCK(I), FRETURN, MONITOR ←30;
        LOCK'TIME←LOCK'ARRAY[I];
        FRETURN LOCK'TIME UNLESS ((LOCK'TIME$PROC'NO=PRTI) AND
             (LOCK'TIME$SP'NO=SPNAME));
        LOCK'ARRAY[I]←LONG'ZERO;       /* RESETS THE LOCK */
        RETURN;

        END;

        PROGRAM CREATE'SP;
          INCLUDE SPTD,GLOBAL,PROFILE;
          DECLARE NAME;
*
        FUNCTION CREATE'SP(SPTX, RING), FRETURN, MONITOR ← 90;
* CHOOSE 1ST FREE SPT ENTRY IF NOT SPECIFIED (SPTX=-1)
          IF SPTX = -1 DO;
             FOR SPTX ← 1 TO NSPTE DO;
                GOTO CRSP20 IF SPT[SPTX]$SPTOL = 0;
             ENDFOR; FRETURN('SPF', 103);
          ENDIF;
* CHECK FOR ERRORS
CRSP10:   FRETURN('SPI', 138) UNLESS (1<=SPTX AND SPTX<=NSPTE);
          FRETURN('SPF', 103) IF SPT[SPTX]$SPTOL # 0;
          FRETURN('ARG', 193) UNLESS (RING=0 OR RING=1);
* INITIALIZE THE SPT ENTRY
CRSP20:   BSET(@SPT[SPTX], 0, LSPTE);
          NAME ← 1 LSH SPTX;
          SPT[SPTX]$SPTOL ← SPNAME;
          SPT[SPTX]$SPTCL ← NAME;
          SPT[SPTX]$SPTKEY ← NAME;
          SPT[SPTX]$SPTFATHER ← CSP;
          SPT[SPTX]$SPTUSP ← (SPT[CSP]$SPTUSP IF RING=0 ELSE SPTX);
          SPT[SPTX]$SPTRING ← RING;
          SPT[SPTX]$SPTEP ← (USER'EP IF RING=0 ELSE UTILITY'EP);
          SPT[SPTX]$SPTEG ← (USER'EG IF RING=0 ELSE UTILITY'EG);
          SPT[SPTX]$SPTSB ← NORMAL'SB A' (SPT[CSP]$SPTSCB A'
                                            SPT[CSP]$SPTSB);
          SPT[SPTX]$SPTTM ← NORMAL'TM A' (SPT[CSP]$SPTTCM A'
                                            SPT[CSP]$SPTTM);
          SPT[SPTX]$SPTSCB ← NORMAL'SCB A' SPT[CSP]$SPTSCB;
          SPT[SPTX]$SPTTCM ← NORMAL'TCM A' SPT[CSP]$SPTTCM;
* MERGE NEW SP'S NAME INTO GLOBAL BIT-WORD
          ACSPT ← ACSPT V' NAME;
*  UP-DATE ALL KEYS TO REFLECT THE CHANGES TO MASTER AND CONTROL LOCKS.
          COMPUTE'KEYS();
*
          RETURN SPTX;
*

        END;

        PROGRAM DESTROY'SP;
          INCLUDE SPTD, SPCSD, ICTD, PMTD,GLOBAL,PROFILE,RESMON, TRAPD;
          DECLARE I, NAME, CL, AL, SSP;
          DECLARE MEC, MEM;
*
        FUNCTION DESTROY'SP(SPTX), FRETURN, MONITOR ← 91;
          SAVE'STATE(SPSTATE);
          SPTX ← CHECK'SPNO(SPTX//FRETURN(MEC, MEM): MEC, MEM);
          FRETURN('CSE', 162) IF SPTX=CSP AND SPCSL=0;
          FRETURN('SPC', 196) IF SPKEY A' SPT[SPTX]$SPTOL=0;
          FOR I ← 0 TO SPCSL-1 DO;
             FRETURN('SPS', 161) IF
                (SPCS[I]$CSR0SP=SPTX OR SPCS[I]$CSR1SP=SPTX);
          ENDFOR;
          NAME ← 1 LSH SPTX;
          FOR I ← 1 TO NSPTE DO;
             FRETURN('SHD', 197) IF (I#SPTX AND SPT[I]$SPTOL=NAME);
          ENDFOR;
*  REMOVE NAME OF SUB-PROCESS FROM LOCKS IN OFT, PMT, AND ICT
          DELICT(SPTX);
          DELOFT(SPTX);
          FOR I ← 1 TO NPMTE DO;
             IF (CL ← PMT[I]$PMTCL)#0 DO;
                AL ← PMT[I]$PMTAL;
                IF AL A' NAME # 0 DO;
                   MSPMTAL(I, AL A' N' NAME, MKEY//DEST80:MEC, MEM);
                ENDIF;
                IF CL A' NAME # 0 DO;
                   MSPMTCL(I, CL A' N' NAME, MKEY//DEST81:MEC, MEM);
                ENDIF;
             ENDIF;
          ENDFOR;
*  CLEAR ENTRY'S OWNER AND CONTROL LOCKS
          SPT[SPTX]$SPTOL ← 0;
          SPT[SPTX]$SPTCL ← 0;
*   DELETE ALL REFERENCES TO SPT ENTRY FROM OTHER SPT ENTRIES
          FOR I ← 1 TO NSPTE DO;
             IF SPT[I]$SPTOL#0 DO;
                SPT[I]$SPTOL ← SPT[I]$SPTOL A' N' NAME;
                SPT[I]$SPTCL ← SPT[I]$SPTCL A' N' NAME;
                SPT[I]$SPTEL ← SPT[I]$SPTEL A' N' NAME;
                SPT[I]$SPTFATHER ← SPT[SPTX]$SPTFATHER IF
                   SPT[I]$SPTFATHER=SPTX;
                SPT[I]$SPTUSP ← 0 IF SPT[I]$SPTUSP=SPTX;
             ENDIF;
          ENDFOR;
* REMOVE SP'S NAME FROM GLOBAL BIT-WORD
          ACSPT ← ACSPT A' N' NAME;
*  UP-DATE KEYS
          COMPUTE'KEYS();
          RETURN IF SPTX#CSP;

*  EXIT FOR SUICIDES
          SUICIDE'RETURN();

*  FAILURE RETURN FROM SPMTAL
DEST80:   PUNT(MEC);
*  FAILURE RETURN FROM SPMTCL
DEST81:   PUNT(MEC);
*

        END;

        PROGRAM SET'MAP;
          INCLUDE SPTD,GLOBAL,PMTD, PROFILE, SPCSD;
          DECLARE BSNM, LNM, LM, BYTE, OLD'BYTE, RO, I;
          DECLARE SPTE, SPTE', MEC, MEM, R0SP, R1SP;
          DECLARE ARRAY SPT''[LSPTE];
*
        FUNCTION SET'MAP(SPTX, STRING MAP), FRETURN, MONITOR ← 100;
          SPTX ← CHECK'SPNO(SPTX//FRETURN(MEC, MEM): MEC, MEM);
          CHK'SP'CNTRL(SPTX//FRETURN('SPC', 137));
          BSNM ← BYTESIZE(MAP);
          LNM ← LENGTH(MAP);
          LM ← (32 IF SPT[SPTX]$SPTRING=1 ELSE 64);
          FRETURN('SPM', 100) UNLESS ((BSNM = 12 OR BSNM = 24) AND
                                           0 <= LNM AND LNM <= LM);
          SPTE ← @SPT[SPTX];
          SPTE' ← @SPT''[0];
          BSET(SPTE', 0, LSPTE);
          LM ← 0;
          FOR I ← 0 TO LNM-1 DO;
             RO ← (1@SPTRO IF SPTE.(ROFLDS[I])=1 ELSE 0);
             OLD'BYTE ← RO V' SPTE.(PXFLDS[I]);
             BYTE ← GCI(MAP//VALUE PUNT('GCI'));
             CHK'MAP'BYTE(BYTE, OLD'BYTE//FRETURN('SPM', 101));
             SPTE'.(ROFLDS[I]) ← BYTE$SPTRO;
             SPTE'.(PXFLDS[I]) ← BYTE$SPTPMT;
             LM ← I IF BYTE$SPTPMT#0;
          ENDFOR;
          BCOPY(SPTE+SPTMAP$FDDISP, SPTE'+SPTMAP$FDDISP, 24);
          SPTE.SPTLM ← LM;
          R0SP ← SPCS[SPCSL]$CSR0SP;
          R1SP ← SPCS[SPCSL]$CSR1SP;
          IF (SPTX=R0SP OR SPTX=R1SP) DO;
             LOAD'PROCESS'MAP(R0SP, R1SP);
          ENDIF;
          RETURN;

        STRING FUNCTION READ'MAP(SPTX,STRING MAP), FRETURN, MONITOR ← 99;
          SPTX ← CHECK'SPNO(SPTX//FRETURN(MEC, MEM): MEC, MEM);
          LM ← (32 IF SPT[SPTX]$SPTRING=1 ELSE 64);
          SPTE ← @SPT[SPTX];
          FOR I ← 0 TO MIN'(LM,LNGDES(MAP$SWPTR,MAP$SEPTR))-1 DO;
             RO ← (1@SPTRO IF SPTE.(ROFLDS[I])=1 ELSE 0);
             WCI(RO V' SPTE.(PXFLDS[I]), MAP//VALUE PUNT('WCI'));
          ENDFOR;
          RETURN MAP;

        END;

        PROGRAM MARK'CALL;
          INCLUDE SPTD,GLOBAL,SPCSD, PROFILE;
          DECLARE LONGLONG PLG, INTEGER PC=PLG$WD1;
          DECLARE CALLING'SP, SPTX, SPCSE, KEY;
*
        FUNCTION MARK'CALL(P, L, G), FRETURN, MONITOR ← 118;
          FRETURN('RNG', 155) IF MRING(P);
*  GET CALLER'S SPT INDEX
          GETPLG(:PLG//VALUE PUNT('PLG'));
          CALLING'SP ← (SPCS[SPCSL]$CSR0SP IF URING(PC) ELSE
                        SPCS[SPCSL]$CSR1SP IF YRING(PC) ELSE
                        0);
          PUNT('SPS') IF CALLING'SP=0;
*  CHECK FOR ROOM IN SPCS AND FOR SUB-PROCESS CONTROL
          FRETURN('RCS', 144) IF GENERATIONS(CALLING'SP)>NSPCSE-(SPCSL+1);
          SPTX ← (SPCS[SPCSL]$CSR0SP IF URING(P) ELSE
                  SPCS[SPCSL]$CSR1SP);
          FRETURN('SPC', 999) IF SPTX=0;
          KEY ← SPT[CALLING'SP]$SPTKEY;
          FRETURN('SPC',999) IF
             KEY A' (SPT[SPTX]$SPTOL V' SPT[SPTX]$SPTCL) = 0;
*  SAVE P, L, AND G IN SPCS
          SPCS[SPCSL]$CSPC ← P;
          SPCS[SPCSL]$CSLR ← L;
          SPCS[SPCSL]$CSGR ← G;
*  INITIALIZE NEW SPCS ENTRY
          SPCSE ← @SPCS[SPCSL+1];
          BSET(SPCSE, 0, LSPCSE);
          SPCSE.NIC ← (SPCS[SPCSL]$NISC#0);
          SPCSE.CSNIET ← SPCS[SPCSL]$CSNIET;
          SPCSE.CSCSP ← CALLING'SP;
          SPCSE.CSR0SP ← SPCS[SPCSL]$CSR0SP;
          SPCSE.CSR1SP ← SPCS[SPCSL]$CSR1SP;
*  PUSH DOWN SPCS AND SET CSP
          SPCSL ← SPCSL+1;
          CSP ← CALLING'SP;
*
          RETURN;

        END;

        PROGRAM MODIFY'CALL;
          INCLUDE PROFILE, GLOBAL, SPTD, SPCSD;
          DECLARE SPCSE, R0SP, R1SP, OLD'PC, SPTX;
*
        ENTRY MODIFY'CALL(CSL, PC, LR, GR, MODE), FRETURN, MONITOR ← 120;
          FRETURN('CSL', 153) UNLESS (-1<=CSL AND CSL<=SPCSL-1);
          FRETURN('RNG', 216) IF MRING(PC);
          FRETURN('ARG', 999) UNLESS (MODE=0 OR MODE=1);
          SPCSE ← @SPCS[SPCSL-1-CSL];
          R0SP ← SPCSE.CSR0SP;
          R1SP ← SPCSE.CSR1SP;
          OLD'PC ← SPCSE.CSPC;
          SPTX ← (R0SP IF URING(OLD'PC) ELSE R1SP);
          CHK'SP'CNTRL(SPTX//FRETURN('SPC', 215)) IF SPTX#0;
          SPTX ← (R0SP IF URING(PC) ELSE R1SP);
          FRETURN('SPC', 215) IF SPTX=0;
          CHK'SP'CNTRL(SPTX//FRETURN('SPC', 215));
          SPCSE.CSPC ← PC;
          SPCSE.CSLR ← LR;
          SPCSE.CSGR ← GR;
          SPCSE.CS940M ← MODE;
          RETURN;

        ENTRY DELETE'CALL(), FRETURN, MONITOR ← 119;
          FRETURN('CSL', 201) IF SPCSL<1;
          FRETURN('SNS', 202) UNLESS
             (SPCS[SPCSL]$CSR0SP=SPCS[SPCSL-1]$CSR0SP AND
              SPCS[SPCSL]$CSR1SP=SPCS[SPCSL-1]$CSR1SP);
          SPCSL ← SPCSL - 1;
          CSP ← SPCS[SPCSL]$CSCSP;
          RETURN;

        END;

        PROGRAM READ'SPCS;
          INCLUDE SPCSD, PROFILE, GLOBAL, SPTD;
          DECLARE I, LB, UB, MEC, MEM;
*
        FUNCTION READ'SPCS(CSL, ARRAY SPCSE), FRETURN, MONITOR ← 96;
          FRETURN('CSL',153) UNLESS (-1<=CSL AND CSL<=SPCSL-1);
          LB ← SPCSE$ADLB;
          UB ← (SPCSE$ADLUB IF SPCSE$ADLE=0 ELSE SPCSE$ADUB);
* THE FOLLOWING STATEMENT MAY CAUSE ANY OF A NUMBER OF TRAPS
          SPCSE[I+LB]←(@SPCS[SPCSL-1-CSL])[I] FOR I← 0 TO
             MIN'(LSPCSE, UB-LB+1)-1;
          RETURN;

        FUNCTION READ'SPT(SPTX, ARRAY SPTE, SCALAR NWORDS), FRETURN,
                                                       MONITOR ← 95;
          SPTX ← CHECK'SPNO(SPTX//FRETURN(MEC, MEM): MEC, MEM);
          LB ← SPTE$ADLB;
          UB ← (SPTE$ADLUB IF SPTE$ADLE=0 ELSE SPTE$ADUB);
          NWORDS ← MIN'(NWORDS, UB-LB+1);
          SPTE[I+LB] ← (@SPT[SPTX])[I] FOR I ← 0 TO MIN'(NWORDS,LSPTE)-1;
          RETURN;

        END;

        PROGRAM SET'SPT'FIELD;
          INCLUDE SPTD,PROFILE;
          DECLARE I,MEC,MEM, CLVL, OLD'VALUE, FLAG;
          DECLARE FIXED FIELD CODE(0:0,23), LVL(1:0,23);
*
        ENTRY SET'SPT'FIELD(SPTX,FLDNO,DATA), FRETURN, MONITOR ← 98;
          FLAG ← 0; GOTO SETFLD10;
        ENTRY READ'SPT'FIELD(SPTX, FLDNO), FRETURN, MONITOR ← 97;
          FLAG ← 1;
SETFLD10: SPTX ← CHECK'SPNO(SPTX//FRETURN(MEC, MEM): MEC, MEM);
          CLVL ← SP'CNTRL'LEVEL(SPTX);
*
          GOTO SETFLD20 IF (0<=FLDNO AND FLDNO<NSPTFLDS);
          FOR I ← 0 TO NSPTFLDS-1 DO;
             (FLDNO ← I & GOTO SETFLD20) IF SPTCODES[I]$CODE=FLDNO;
          ENDFOR;
          FRETURN('ARG',167);
SETFLD20: OLD'VALUE ← SPT[SPTX]$(SPTFLDS[FLDNO]);
          RETURN OLD'VALUE IF FLAG=1;

          FRETURN('SPC', 143) IF CLVL<SPTCODES[FLDNO]$LVL;
          CHECK'SPT'FIELDS(SPTX,FLDNO,DATA//FRETURN(MEC,MEM):MEC, MEM);
          SPT[SPTX]$(SPTFLDS[FLDNO]) ← DATA;
*  UPDATE KEYS IF OL OR CL WAS MODIFIED
          I ← SPTCODES[FLDNO]$CODE;
          COMPUTE'KEYS() IF (I='OL' OR I='CL');
          RETURN;
*

        END;

        PROGRAM CHECK'SPT'FIELDS;
          INCLUDE SPTD, GLOBAL, PROFILE, SPCSD;
          DECLARE LABEL ARRAY CHECKS[NSPTFLDS] ←
             (CHK'OL,CHK'CL,CHK'EL,CHK'KEY,CHK'PUNT,CHK'FATHER,
              CHK'PUNT,CHK'PUNT,CHK'EP,CHK'PUNT,CHK'EG,CHK'SB,CHK'TM,
              CHK'SCB,CHK'TCM);
          DECLARE T,I, G, MEC, MEM;

        ENTRY CHECK'SPT'FIELDS(SPTX, FLDNO, NEW'VALUE), FRETURN;
          GOTO CHECKS[FLDNO];

CHK'OL:   FRETURN('ILM', 999) IF NEW'VALUE=0;
          RETURN;

CHK'CL:   RETURN;

CHK'EL:   CHK'SP'CNTRL(SPTX//CEL20);
*  OK IF CSP CONTROLS SPTX
          RETURN;
*  OK TO SET ANY BITS AND TO RESET ANY IN CSP'S KEY
CEL20:    FRETURN('ILM', 200) IF
             (SPT[SPTX]$SPTEL A' N' NEW'VALUE) A' N' SPKEY # 0;
          RETURN;

CHK'KEY:  FRETURN('SPC', 148) IF NEW'VALUE A' N' SPT[SPTX]$SPTCTRL#0;
          RETURN;

CHK'FATHER:
          NEW'VALUE ← CHECK'SPNO(NEW'VALUE//FRETURN(MEC, MEM): MEC, MEM);
          CHK'SP'CNTRL(NEW'VALUE//FRETURN('SPC', 149));
* CHECK FOR FATHERHOOD LOOP
          T←NEW'VALUE;
          FOR I←1 TO NSPTE DO;
             FRETURN('FHL', 150) IF T = SPTX;
             GOTO SFTHR10 IF (T←SPT[T]$SPTFATHER) = 0;
          ENDFOR;
          PUNT('FHL');
* CHECK THAT SPCS ISN'T TOO FULL
SFTHR10:  G←GENERATIONS(NEW'VALUE) +1;
          GOTO SFTHR20 IF G <= GENERATIONS(SPTX);
          FOR I ← MAX(0,NSPCSE-G) TO SPCSL DO;
             FRETURN('RCS', 151) IF
                (SPTX=SPCS[I]$CSR0SP OR SPTX=SPCS[I]$CSR1SP);
          ENDFOR;
SFTHR20:  RETURN;

CHK'EP:
CHK'EG:   FRETURN('RNG',157) IF
             SPT[SPTX]$SPTRING=1 AND NOT YRING(NEW'VALUE) OR
             SPT[SPTX]$SPTRING=0 AND NOT URING(NEW'VALUE);
          RETURN;

CHK'SB:   FRETURN('MSB', 144) IF N' SPT[CSP]$SPTSCB A'
             (NEW'VALUE E' SPT[SPTX]$SPTSB)#0;
          RETURN;

CHK'TM:   FRETURN('MTM', 147) IF N' SPT[CSP]$SPTTCM A'
             (NEW'VALUE E' SPT[SPTX]$SPTTM)#0;
          RETURN;

CHK'SCB:  FRETURN('MSC', 145) IF N' SPT[CSP]$SPTSCB A'
             (NEW'VALUE E' SPT[SPTX]$SPTSCB)#0;
          RETURN;

CHK'TCM:  FRETURN('MTC', 146) IF N' SPT[CSP]$SPTTCM A'
             (NEW'VALUE E' SPT[SPTX]$SPTTCM)#0;
          RETURN;

CHK'PUNT: PUNT('SSP');
*

        END;

        PROGRAM LOAD'PROCESS'MAP;
          INCLUDE SPTD, GLOBAL, RESMON;
          DECLARE I, RO, SPTE, LM;
          DECLARE STRING MAP;
        FUNCTION LOAD'PROCESS'MAP(R0SP, R1SP);
* CLEAR USER AND UTILITY RINGS OF THE PROCESS MAP
          BSET(@PRMAP[0], 0, 48);
* SET UP USER RING IF R0SP # 0.
          IF R0SP#0 DO;
             SPTE ← @SPT[R0SP];
             LM ← SPTE.SPTLM;
             SETUP(MAP, LM+1, @PRMAP[0], 12);
             FOR I ← 0 TO LM DO;
                RO ← (1@PRMRO IF SPTE.(ROFLDS[I])=1 ELSE 0);
                WCI(RO V' SPTE.(PXFLDS[I]), MAP//VALUE PUNT('MAP'));
             ENDFOR;
          ENDIF;
* SET UP UTILITY RING IF R1SP # 0.
          IF R1SP#0 DO;
             SPTE ← @SPT[R1SP];
             LM ← SPTE.SPTLM;
             SETUP(MAP, LM+1, @PRMAP[32], 12);
             FOR I ← 0 TO LM DO;
                RO ← (1@PRMRO IF SPTE.(ROFLDS[I])=1 ELSE 0);
                WCI(RO V' SPTE.(PXFLDS[I]), MAP// VALUE PUNT('MAP'));
             ENDFOR;
          ENDIF;
*  THE CPU'S MAP MUST BE CLEARED.
          CLEAR'MAP;
          RETURN;

        END;

        PROGRAM CHK'SP'CNTRL;
          INCLUDE SPTD, PROFILE, GLOBAL, PMTD;
          DECLARE G, I, PMTX, PMTE;

        ENTRY CHK'SP'CNTRL(SPTX), FRETURN;
          FRETURN IF SPKEY A' (SPT[SPTX]$SPTOL V' SPT[SPTX]$SPTCL)=0;
          RETURN;

        ENTRY CHK'SP'ACCESS(SPTX), FRETURN;
          FRETURN IF SPKEY A'
             (SPT[SPTX]$SPTOL V' SPT[SPTX]$SPTCL V' SPT[SPTX]$SPTEL)=0;
          RETURN;

        ENTRY SP'CNTRL'LEVEL(SPTX);
          RETURN (3 IF SPKEY A' SPT[SPTX]$SPTOL # 0 ELSE
                  2 IF SPKEY A' SPT[SPTX]$SPTCL # 0 ELSE
                  1 IF SPKEY A' SPT[SPTX]$SPTEL # 0 ELSE
                  0);

        ENTRY CHECK'SPNO(SPTX), FRETURN;
          RETURN CSP IF SPTX=-1;
          FRETURN('SPI', 138) UNLESS (1<=SPTX AND SPTX<=NSPTE);
          RETURN SPTX;

        ENTRY GENERATIONS(SPTX);
          FOR G←1 TO NSPTE DO;
             RETURN G IF (SPTX←SPT[SPTX]$SPTFATHER)=0;
          ENDFOR;
* THERE IS A FATHERHOOD LOOP IN SPT
          PUNT('FHL');

        ENTRY ROOT(SPTX);
          FOR I←1 TO NSPTE DO;
             RETURN SPTX IF SPT[SPTX]$SPTFATHER=0;
             SPTX←SPT[SPTX]$SPTFATHER;
          ENDFOR;
          PUNT('FHL');

        ENTRY CHK'MAP'BYTE(BYTE, OLD'BYTE), FRETURN;
          RETURN IF BYTE=OLD'BYTE;
          RETURN IF (PMTX ← BYTE$SPTPMT)=0;
          FRETURN UNLESS (1<=PMTX AND PMTX<=NPMTE);
          PMTE ← @PMT[PMTX];
          FRETURN IF
             PMTE.PMTCL=0 OR
             SPKEY A' (PMTE.PMTCL V' PMTE.PMTAL) = 0;
          RETURN;

        END;

        PROGRAM TRAP'TARGET;
          INCLUDE SPTD,SPCSD,GLOBAL, PROFILE;
          DECLARE FREESLOTS,N,I,TM;
*
        FUNCTION TRAP'TARGET(SPTX,TRAPNO);
          TM ← 4B7 RSH TRAPNO;
          (SPTX←ROOT(SPTX) & GOTO DISARM'TRAP) IF
             (FREESLOTS←NSPCSE-1-SPCSL)<2;
          IF (N←GENERATIONS(SPTX) - FREESLOTS) > 0 DO;
             SPTX←SPT[SPTX]$SPTFATHER FOR I←1 TO N;
          ENDIF;
          FOR I←1 TO NSPTE DO;
             GOTO DISARM'TRAP IF ((TM A' SPT[SPTX]$SPTTM#0) OR
                SPT[SPTX]$SPTFATHER=0);
             SPTX←SPT[SPTX]$SPTFATHER;
          ENDFOR;
          PUNT('FHL');
DISARM'TRAP:
          SPT[SPTX]$SPTTM ← SPT[SPTX]$SPTTM A' N' TM;
          RETURN SPTX;

        END;

        PROGRAM COMPUTE'KEYS;
          INCLUDE SPTD;
          DECLARE I, J, CHANGE, CTRL;
          DECLARE OCTAL ARRAYONE LOCK[NSPTE];
        ENTRY COMPUTE'KEYS();
          FOR I ← 1 TO NSPTE DO;
             SPT[I]$SPTCTRL ← (1 LSH I IF SPT[I]$SPTOL#0 ELSE 0);
             LOCK[I] ← SPT[I]$SPTOL V' SPT[I]$SPTCL;
          ENDFOR;
          CHANGE ← 1;
          WHILE CHANGE DO;
             CHANGE ← 0;
             FOR I ← NSPTE BY -1 TO 1 DO;
                IF (CTRL ← SPT[I]$SPTCTRL)#0 DO;
                   FOR J ← NSPTE BY -1 TO 1 DO;
                      IF CTRL A' LOCK[J] # 0 DO;
                         CTRL ← CTRL V' SPT[J]$SPTCTRL;
                      ENDIF;
                   ENDFOR;
                   IF SPT[I]$SPTCTRL # CTRL DO;
                      SPT[I]$SPTCTRL ← CTRL;
                      CHANGE ← 1;
                   ENDIF;
                ENDIF;
             ENDFOR;
          ENDFOR;
          FOR I ← 1 TO NSPTE DO;
             SPT[I]$SPTKEY ← SPT[I]$SPTKEY A' SPT[I]$SPTCTRL;
          ENDFOR;
          RETURN;

        END;

        PROGRAM SET'MAP'BYTE;
          INCLUDE GLOBAL,PROFILE,SPTD,PMTD,SPCSD;
          DECLARE PNO, I, OLD'BYTE, SPTE, ML, RO, MEC, MEM;
*
        FUNCTION SET'MAP'BYTE(SPTX,BYTENO,BYTE), FRETURN, MONITOR ← 102;
****  TEMPORARY WHATNOT TO SPEED UP BRS 41
          IF SPTX=-1 AND BYTENO>=0 AND BYTENO<64 AND SPRING=0 DO;
             RETURN IF BYTE = $INCDES(50B6+@PRMAP[0],BYTENO);
          ENDIF;
****
          PNO ← 1 & GOTO SMB05;
        ENTRY READ'MAP'BYTE (SPTX,BYTENO), FRETURN, MONITOR ← 101;
          PNO ← 2 & GOTO SMB05;
*
SMB05:    SPTX ← CHECK'SPNO(SPTX//FRETURN(MEC, MEM): MEC, MEM);
          IF PNO=1 DO;
             CHK'SP'CNTRL(SPTX//FRETURN('SPC', 137));
          ENDIF;
          ML ← (32 IF SPT[SPTX]$SPTRING=1 ELSE 64);
          FRETURN('MBN',163) UNLESS (0<=BYTENO AND BYTENO<ML);
*
          SPTE ← @SPT[SPTX];
          RO ← (1@SPTRO IF SPTE.(ROFLDS[BYTENO])=1 ELSE 0);
          OLD'BYTE ← RO V' SPTE.(PXFLDS[BYTENO]);
          RETURN OLD'BYTE IF PNO=2;
*
          RETURN IF BYTE=OLD'BYTE;
          CHK'MAP'BYTE(BYTE, OLD'BYTE//FRETURN('SPM', 101));
          SPTE.(ROFLDS[BYTENO]) ← BYTE$SPTRO;
          SPTE.(PXFLDS[BYTENO]) ← BYTE$SPTPMT;
*  UPDATE THE STUPID MAP LENGTH
          GOTO SMB30 IF BYTENO<SPTE.SPTLM;
          FOR I ← BYTENO BY -1 TO 0 DO;
             (SPTE.SPTLM←I & GOTO SMB30) IF SPTE.(PXFLDS[I])#0;
          ENDFOR;
          SPTE.SPTLM ← 0;
SMB30:    IF (SPTX=SPCS[SPCSL]$CSR0SP OR SPTX=SPCS[SPCSL]$CSR1SP) DO;
             BYTENO ← BYTENO+64 IF SPT[SPTX]$SPTRING=1;
             SETPRMB(BYTENO, BYTE);
          ENDIF;
          RETURN;
*

        END;

        PROGRAM SPS'PARAMETERS;
          INCLUDE PROFILE;
          DECLARE PAR, I, NPARS ← 3;
          DECLARE CHARACTER ARRAY CODES[NPARS] ← ('CSP', 'CSL', 'ASP');
          DECLARE POINTER ARRAY PARS[NPARS] ← (@CSP, @SPCSL, @ACSPT);
        FUNCTION SPS'PARAMETERS(CODE), FRETURN, MONITOR ← 106;
          GOTO SPAR20 IF (0<=CODE AND CODE<NPARS);
          FOR I ← 0 TO NPARS-1 DO;
             (CODE←I & GOTO SPAR20) IF CODE=CODES[I];
          ENDFOR;
          FRETURN('ARG', 187);
*
SPAR20:   PAR ← $PARS[CODE];
          RETURN PAR;

        END;

        PROGRAM CALL'USER;
          INCLUDE SPTD, SPCSD, GLOBAL, TRAPD, ICTD;
          DECLARE ARRAY EPA;
          DECLARE LONG MAX'NI'TIME ← (0, 6B7);
          DECLARE NEW'SPCSL, SPCSE, RING, JUMP'FLAG, MEC, MEM,
             I, SSP, EPA'=EPA, SPTX, EPNO, NPARS, PC, SET'NIS'FLAG;

        ENTRY START'USER();
          SPCSL ← 0; SPTX ← 1; EPNO ← 2; SET'NIS'FLAG ← 0;
          GOTO DO'SPJUMP;

        FUNCTION TRAP(TRAPNO, PAR, FLAG);
          SAVE'ST'FOR'TRAP(FLAG);
          SET'NIS'FLAG ← (1 IF TRAPNO#TNO(NILE) ELSE 0);
          GOTO TRAP1;

        FUNCTION SP'TRAP(TRAPNO, PAR), FRETURN, MONITOR ← 113;
          SAVE'USER'STATE();
          SET'NIS'FLAG ← 0;
          FRETURN('TNO', 138) UNLESS (0<=TRAPNO AND TRAPNO<=NTRAPS);
*  THE TRAP FUNCTION COMES IN HERE
TRAP1:    IF SPCSL>=NSPCSE-1 DO;
             PAR ← TRAPNO;
             TRAPNO ← TNO(SPCSO);
          ENDIF;
          SPTX ← TRAP'TARGET(SPT[CSP]$SPTUSP IF YRING(SPSTATE.STPC) AND
             SPT[CSP]$SPTRING=0 ELSE CSP, TRAPNO);
          EPNO ← 0; GOTO DO'SPCALL;

        FUNCTION INTERRUPT(SPTX, INTNO, FLAG);
          SAVE'ST'FOR'TRAP(FLAG); EPNO ← 1; SET'NIS'FLAG ← 1;
          GOTO DO'SPCALL;

        FUNCTION SP'CALL(SPTX, EPNO), FRETURN, MONITOR ← 111;
          SAVE'USER'STATE(); JUMP'FLAG ← 0; SET'NIS'FLAG ← 0;
          GOTO CHECK'SPCALL;

        FUNCTION SP'JUMP(SPTX, EPNO), FRETURN, MONITOR ← 112;
          SAVE'USER'STATE(); JUMP'FLAG←1; SET'NIS'FLAG ← 0;

CHECK'SPCALL:
          SPTX ← CHECK'SPNO(SPTX//FRETURN(MEC, MEM):MEC, MEM);
          FRETURN('EPN', 173) UNLESS (2<=EPNO AND EPNO<=MAXEPNO);
          CHK'SP'ACCESS(SPTX//FRETURN('SPA', 140)); GOTO CHECK'STKOV;

        FUNCTION SP'BRANCH(SPTX, NP, NL, NG), FRETURN, MONITOR ← 115;
          SAVE'USER'STATE();
          SET'NIS'FLAG ← 0;
          SPTX ← CHECK'SPNO(SPTX//FRETURN(MEC,MEM):MEC, MEM);
          CHK'SP'CNTRL(SPTX//FRETURN('SPA', 140));
          FRETURN('RNG', 173) IF MRING(NP) OR SPT[SPTX]$SPTRING=0
             AND YRING(NP) OR SPT[SPTX]$SPTRING#0 AND URING(NP);
          EPNO ← -1; JUMP'FLAG←0;

CHECK'STKOV:
          FRETURN('RCS', 141) IF
             GENERATIONS(SPTX)+SPCSL>NSPCSE-1+JUMP'FLAG;
          GOTO DO'SPCALL IF JUMP'FLAG=0 ELSE GOTO DO'SPJUMP;

        FUNCTION TRAP'RETURN(TRAPNO, PAR), FRETURN, MONITOR ← 114;
          SAVE'STATE(SPSTATE);
          SET'NIS'FLAG ← 1; EPNO ← 0;
          FRETURN('TNO', 139) UNLESS (0<=TRAPNO AND TRAPNO<=NTRAPS);
          FRETURN('CSE', 152) IF SPCSL<1;
          SPTX ← TRAP'TARGET(SPCS[SPCSL-1]$CSCSP, TRAPNO);
          GOTO DO'SPJUMP;
DO'SPCALL:
          SPCS[SPCSL]$CSPC ← SPSTATE.STPC;
          SPCS[SPCSL]$CSLR ← SPSTATE.STLR;
          SPCS[SPCSL]$CSGR ← SPSTATE.STGR;
          SPCS[SPCSL]$CS940M ← SPSTATE.M940M;
          IF SPCSL<NSPCSE-1 DO;
             NEW'SPCSL ← SPCSL+1;
          ELSE DO;
DO'SPJUMP:
             NEW'SPCSL ← SPCSL;
          ENDIF;
          BSET(SPCSE←@SPCS[NEW'SPCSL], 0, LSPCSE);
          IF SPCSL>0 DO;
             SPCSE.NIC ← (SPCS[SPCSL]$NISC#0);
             SPCSE.CSNIET ← SPCS[SPCSL]$CSNIET;
          ENDIF;
          IF SET'NIS'FLAG DO;
             SPCSE.NIS ← 1;
             SPCSE.CSNIET ← FLTADDL(MAX'NI'TIME, REALTL());
          ENDIF;
          SPCSE.CSCSP ← SPTX;
          SPCSE.CSR0SP ← (SPTX IF SPT[SPTX]$SPTRING=0 ELSE
                          SPCS[SPCSL]$CSR0SP);
          SPCSE.CSR1SP ← SPT[SPTX]$SPTUSP;
*  IT IS OK TO LOAD THE PROCESS MAP HERE EVEN THOUGH CSP#SPTX BECAUSE
*  THE ONLY WAY THE MAP CAN CHANGE AGAIN BEFORE CSP=SPTX IS TO TRAP
*  AND COME THROUGH HERE AGAIN.
          LOAD'PROCESS'MAP(SPCSE.CSR0SP, SPCSE.CSR1SP);
*  NOW FINISH SETTING UP SPSTATE TO ENTER THE NEW SUB-PROCESS
          SPSTATE.INSTD ← 0;
          IF EPNO=-1 DO;
*  SP'BRANCH
             SPSTATE.STPC←NP; SPSTATE.STLR←NL; SPSTATE.STGR←NG;
          ELSE DO;
*  OBTAIN ENTRY POINT
             EPA' ← SPT[SPTX]$SPTEP V' ITAG;
             .EAX EPA[EPNO], STX $SPSTATE;
             SPSTATE.STLR ← 0;
             SPSTATE.STGR ← SPT[SPTX]$SPTEG;
*  PASS PARAMETERS IF NECESSARY (TRAP, SP'TRAP, OR INTERRUPT)
             NPARS ← (2 IF EPNO=0 ELSE 1 IF EPNO=1 ELSE 0);
             IF NPARS>0 DO;
                RING ← SPT[SPTX]$SPTRING;
                RING'CHECK(SPSTATE.STGR+2,RING//TRAP1:TRAPNO,PAR);
                SPSTATE.STLR ← SPSTATE.STGR.WD2;
                IF SPSTATE.STLR+NPARS > $(SPSTATE.STGR+3) DO;
                   TRAPNO ← TNO(BLLERR); PAR ← 7B7; GOTO TRAP1;
                ENDIF;
                RING'CHECK(SPSTATE.STLR+NPARS-1,RING//TRAP1:TRAPNO,PAR);
                SPSTATE.STLR.WD0 ← (TRAPNO IF EPNO=0 ELSE INTNO);
                SPSTATE.STLR.WD1 ← PAR IF EPNO=0;
                SPSTATE.STGR.WD2 ← SPSTATE.STLR+NPARS;
             ENDIF;
          ENDIF;
          SPSTATE.M940M ← 0;
          CSP ← SPTX;
          SPCSL ← NEW'SPCSL;
          SESP ← SESS;
          LOAD'STATE(SPSTATE);

*  SP'RETURN AND JUMP'RETURN DO NOT HAVE ANY CODE IN COMMON WITH THE REST
        FUNCTION JUMP'RETURN(STKL), FRETURN, MONITOR ← 117;
          SAVE'STATE(SPSTATE);
          FRETURN('CSL', 153) UNLESS (-1<=STKL AND STKL<=SPCSL-1);
*  CALLER MUST CONTROL SUB-PROCESSES WHICH GET JUMPED OVER.
          FOR I ← SPCSL-1 BY -1 TO SPCSL-STKL DO;
             PC ← SPCS[I]$CSPC;
             SSP ← (SPCS[I]$CSR0SP IF URING(PC) ELSE
                    SPCS[I]$CSR1SP IF YRING(PC) ELSE
                    0);
             CHK'SP'CNTRL(SSP//FRETURN('SPC', 154)) IF SSP#0;
          ENDFOR;
          RETURN IF STKL=-1;
*   POP UP SPCS STKL LEVELS
          SPCSL ← SPCSL-STKL;
          GOTO DO'SPRETURN;

        ENTRY SP'RETURN(), FRETURN, MONITOR ← 116;
          SAVE'STATE(SPSTATE);
          FRETURN('CSE', 152) IF SPCSL=0;
          GOTO DO'SPRETURN;
*  DESTROY'SP ENTERS HERE.
        ENTRY SUICIDE'RETURN();
DO'SPRETURN:
          SPCSL ← SPCSL-1;
          SPCSE ← @SPCS[SPCSL];
          SPSTATE.STPC ← SPCSE.CSPC;
          SPSTATE.STLR ← SPCSE.CSLR;
          SPSTATE.STGR ← SPCSE.CSGR;
          SPSTATE.M940M ← SPCSE.CS940M;
          LOAD'PROCESS'MAP(SPCSE.CSR0SP, SPCSE.CSR1SP);
          CSP ← SPCSE.CSCSP;
          SESP ← SESS;
          LOAD'STATE(SPSTATE);


        END;

        PROGRAM SAVE'SP'STATE;
          INCLUDE PROFILE, TRAPD, GLOBAL, SPTD;
          DECLARE LONGLONG PLG, INTEGER PC=PLG$WD1, LR=PLG$WD2,
             GR=PLG$WD3;
*
        FUNCTION SAVE'ST'FOR'TRAP(FLAG);
          IF FLAG=0 DO;
             BCOPY(SPSTATE, TRSTATE, 10);
             RETURN;
          ELSE DO;
             BSET(SPSTATE, 0, 10);
             GOTO SAVE'PLG;
          ENDIF;
*
        FUNCTION SAVE'USER'STATE();
          SAVE'STATE(SPSTATE);
SAVE'PLG: GETPLG(:PLG//VALUE PUNT('PLG'));
          SPSTATE.STPC ← PC; SPSTATE.STLR ← LR; SPSTATE.STGR ← GR;
          RETURN;
*
        FUNCTION RING'CHECK(ADDRESS, RING), FRETURN;
          FRETURN(TNO(MACC), ADDRESS) IF
             MRING(ADDRESS) OR RING=0 AND NOT URING(ADDRESS);
          RETURN;

        END;
       PROGRAM BO;
*
*      KLUDGE MONITOR CALL TO READ OR
*      WRITE ARBITRARY CELLS (ONLY FOR DEBUGGING)*****
       FUNCTION LEWENDAL(A1,A2,A3), FRETURN,MONITOR←255;
       FRETURN ('FIA',999) IF A1<0 OR A1>1B6-1;
       IF A3 DO;
       $A1←A2;
       ELSE DO;
       A2←$A1;
       ENDIF;
       RETURN A2;

       END;

       PROGRAM ATTACH'PROC;
       INCLUDE GLOBAL, RESMON, PROFILE;

*
*  MONITOR CALL TO ATTACH PREVIOUSLY DETACHED PROCESS
*

       FUNCTION ATTACH'PROC(I,J), MONITOR←131;
       PRT[I]$PRLNO←J;
       PRT[I]$PRATT←1;
       UTTY←ATTY←-1;
       MIS1CALL(IWAKEUPC+I,0);
       RETURN;

       END;

       PROGRAM BLOCK;
       INCLUDE ERRD, GLOBAL, ICTD, PROFILE, RESMON, CHIOD;

       DECLARE PARAMETER DEFAULT'QUANTUM←25000;    /* 0.25 SECOND */
       DECLARE PARAMETER MAX'QUANTA←31;   /* THIS OR MORE MEANS COMPUTE */

       DECLARE LONG IJ,KL;
       DECLARE INTEGER CH'LINE,CHIO'CONDITIONS;
       DECLARE INTEGER UCLL,I=IJ$WD0,J=IJ$WD1;
       DECLARE POINTER PTR;

*
*  BLOCK ON CONDITION ROUTINE
*

*
*  GENERAL ENTRY POINT FOR MONITOR
*

       ENTRY MBLOCK(WW);
       UCLL←0 & GOTO CAL1;

*
*  MONITOR ENTRY FOR DISMISSING FOR SPECIFIED TIME
*

       ENTRY SBLOCK(IJ);
       REALTL(:KL);
       FLTADDL(KL,IJ:IJ);
       ICT[0]$TDAT←IJ;
       MOTIM();
       WW←4B7+1;
       UCLL←0 & GOTO CAL2;

*
*  ENTRY POINTS FOR USER & UTILITY
*

       FUNCTION FBLOCK(WW,I), FRETURN, MONITOR←164;
       RETURN IF I#0;

       FUNCTION BLOCK(WW), FRETURN, MONITOR←170;
       UCLL←1;
CAL1:  FOR I←0 TO ICTE DO;
          FRETURN M38 IF (WW LSH I)<0 AND (ICT[I]$CLICT=0 OR ICT[I]$BLK=0);
       ENDFOR;
CAL2:  WHILE 1 DO;
          SCHED(UCLL);
          HANDLE'PIW(WW);
          IF PIWE#0 DO;
             IF UCLL=1 DO;
                CSTRAP(WW,1);
             ELSE DO;
                XMONTRAP;
             ENDIF;
          ENDIF;
          (PIWE←PIWE A' N' WW & RETURN) IF PIWE A' WW#0;
          XMBLOCK(BLOCKOUTC);    * THIS IS THE ACTUAL BLOCKING POINT
       ENDFOR;

*
*  MONITOR FUNCTION FOR PAGE FAULT BLOCKS
*

       FUNCTION SWBLOCK();  /* FN DOESN'T SEE OR HANDLE CO INTERRUPT */
       SCHED(0);
       PROTECT(PRO1);
          IF PRT[PRTI]$PRPIW A' (1@QUIT'CHR V' 1@IO V' 1@RT)#0 DO;
             PRT[PRTI]$PRPRI←PRT[PRTI]$PRPRI-1 IF (PRT[PRTI]$PRPRI>0);
          ENDIF;
          PIWE←PIWE V' PRT[PRTI]$PRPIW A' N' (1@RSI V' 1@CO);
          PRT[PRTI]$PRPIW←PRT[PRTI]$PRPIW A' 1@CO;
       UNPROTECT(PRO1);
       XMBLOCK(UNLOADC);      * THIS THE ACTUAL BLOCKING POINT
       SCHED(0);
       PROTECT(PRO1);
          IF PRT[PRTI]$PRPIW A' (1@QUIT'CHR V' 1@IO V' 1@RT)#0 DO;
             PRT[PRTI]$PRPRI←PRT[PRTI]$PRPRI-1 IF (PRT[PRTI]$PRPRI>0);
          ENDIF;
          PIWE←PIWE V' PRT[PRTI]$PRPIW A' N' (1@RSI V' 1@CO);
          PRT[PRTI]$PRPIW←PRT[PRTI]$PRPIW A' 1@CO;
       UNPROTECT(PRO1);
       IF PIWE#0 DO;
          XMONTRAP;
       ENDIF;
       RETURN;

*
*  MONITOR FUNCTION FOR TIMER OVERFLOW BLOCK
*

       FUNCTION TBLOCK();
       TIME'IT();
       PRCTT←I←-DEFAULT'QUANTUM A' (4B7-1);
       SIT(I);
       SCHED(0);
       HANDLE'PIW(0);
       XMBLOCK(UNLOADC);       * THIS IS THE ACTUAL BLOCKING POINT
       SCHED(0);
       HANDLE'PIW(0);
       IF PIWE#0 DO;
          XMONTRAP;
       ENDIF;
       RETURN;

*
*  FUNCTION TO MERGE PRPIW INTO PIWE AND PROVIDE SPECIAL HANDLING
*  FOR CO INTERRUPTS.  THIS HANDLING IS DEFERRED IF AMC BIT IS ON
*  IN WW.
*

       FUNCTION HANDLE'PIW(WW);
       PTR←@PRT[PRTI];
CAL3:  IF PTR.PRDET=0 DO;
          PROTECT(PRO1);
             IF PRT[PRTI]$PRPIW A' (1@QUIT'CHR V' 1@IO V' 1@RT)#0 DO;
                PRT[PRTI]$PRPRI←PRT[PRTI]$PRPRI-1 IF (PRT[PRTI]$PRPRI>0);
             ENDIF;
             IF PTR.PRCO=0 DO;
                PIWE←PIWE V' PTR.PRPIW A' N' 1@RSI;
                PTR.PRPIW←0;
             ELSE DO;
                IF WW A' AMC=1 DO;  /* DEFER CO INTERRUPT IN THIS CASE */
                   PIWE←PIWE V' PTR.PRPIW A' N' (1@RSI V' 1@CO);
                   PTR.PRPIW←PTR.PRPIW A' 1@CO;
                ELSE DO;   /* DETACH PROCESS HERE */
                   PIWE←PIWE V' PTR.PRPIW A' N' (1@RSI V' 1@CO);
                   PTR.PRPIW←0;
          UNPROTECT(PRO1);
                   SLEEPY(0//CAL4) IF PROC'NATURE$EPR=1;* COMMIT SUICIDE IF AN ENTER PROCESS
                   GOTO CAL3 IF PROC'NATURE$LPR=1;* DO NOT DETACH IF LOGGING OUT
                   PTR.PRDET←1;* OTHERWISE DETACH PROCESS
                   PTR.PRATT←0;
                   IF UTTY#-1 DO;
                      IF ATTY#-1 DO;
                         MTA[ATTY RSH 1]$LQNK←MTA[ATTY RSH 1]$LF←0;
                         ATTY←-1;
                      ENDIF;
                      CH'LINE←UTTY RSH 1;
                      CHIO'CONDITIONS←MTA[CH'LINE]$WD0;
                      CHIO'CONDITIONS$RCNO←CHIO'CONDITIONS$DTYP←0;
                      MTA[CH'LINE]$BWS←-1;
                      MTA[CH'LINE]$LF←MTA[CH'LINE]$ES
                                     ←MTA[CH'LINE]$EBC←0;
                      MTA[CH'LINE]$PROC←1;
                      UTTY←-1;
                   ENDIF;
                   MIS1CALL(CHANGERTC+@PRT[PRTI]-RESM,-1);
                   XMBLOCK(BLOCKOUTC);
                   GOTO CAL3;
                ENDIF;
             ENDIF;
          UNPROTECT(PRO1);
          RETURN;
       ELSE DO;
          IF PTR.PRCO=0 DO;
             IF PTR.PRATT=1 DO;  /* PROC IS TO BE ATTACHED.  CONTINUE */
                CH'LINE←PRT[PRTI]$PRLNO;
                MTA[CH'LINE]$WD0←MTA[CH'LINE]$RCNO V' MTA[CH'LINE]$DTYP
                                V' CHIO'CONDITIONS;
                MTA[CH'LINE]$PROC←PRTI;
                UTTY←CH'LINE LSH 1;
                PTR.PRDET←PTR.PRATT←0;
                PROTECT(PRO1);
                   PIWE←PIWE V' PTR.PRPIW A' N' (1@RSI V' 1@CO) V' WW;
                   PTR.PRPIW←0;
                UNPROTECT(PRO1);
             ELSE DO;   /* THIS CASE SHOULDN'T HAPPEN */
                PROTECT(PRO1);
                   PIWE←PIWE V' PTR.PRPIW A' N' 1@RSI;
                   PTR.PRPIW←0;
                UNPROTECT(PRO1);
                XMBLOCK(BLOCKOUTC);
                GOTO CAL3;
             ENDIF;
          ELSE DO;   /* THIS CASE CAN'T HAPPEN */
             PUNT('COD');
             RETURN;
          ENDIF;
          RETURN;
       ENDIF;

CAL4:   PUNT('DET');


       ENTRY TIME'IT();
       RDIT(J); I←0; J ← (J A' (4B7-1))-(PRCTT V' 4B7);
       FLTADDL(PRCT,IJ:PRCT);
       RETURN;

       END;

       PROGRAM TO'BLOCK;
       INCLUDE TRAPD,PROFILE,GLOBAL;
*
*  TIMER OVERFLOW TRAP
*
     FUNCTION TO'BLOCK();
       GOTO CAL10 IF TRSTATE.STPC<6B5;
       TIME'IT();
       PRCTT←-10000 A' (4B7-1); SIT(PRCTT); RETURN;
CAL10: TBLOCK(); RETURN;

       END;

       PROGRAM CSTRAP;
*
*
*  CAUSE INTERRUPTS
*
       INCLUDE ERRD,ICTD,SPCSD,PROFILE,GLOBAL,SPTD;
       DECLARE J,I;
       FUNCTION CSTRAP(WW,TR);
       MOTIM();
       RETURN IF (SPCS[SPCSL]$NIC V' SPCS[SPCSL]$NIS)#0
       AND NIT=0;
       J←PIWE A' N' WW;
       GOTO CAL3 IF NIT=1;
       J ← J A' -(4B7 RSH ICTE);
       WHILE J DO;
*          FIRST'BIT(J,I);
          .LDA  J, LSHD -1, LLT, ADX -1, STX I;
       GOTO CAL4 IF ICT[I]$CLICT=0;
       GOTO CAL1 IF ICT[I]$ACTION=0;
       PIWE←PIWE  A' N' WW A' N' (4B7 RSH I);
       INTERRUPT(ICT[I]$SPEC,I,TR) IF ICT[I]$ACTION=1;
       TRAP(ICT[I]$SPEC,I,TR) IF ICT[I]$ACTION=2;
       PUNT('PIS');
CAL1:     J ← J-4B7 RSH I;* CLEAR THE BIT IN J
       ENDFOR;
       RETURN;
CAL3:  PIWE←J; SPCS[SPCSL]$NIC←SPCS[SPCSL]$NIS←0;
       TRAP(TNO(NILE),0,TR);
CAL4:  PIWE←PIWE A' N' (1 LSH(23-I));
       GOTO CAL1;

       END;

       PROGRAM MOTIM;
*
*  SET UP REAL TIMERS AND SET PIW BITS
*
       INCLUDE ERRD,ICTD, RESMON,GLOBAL,SPCSD,PROFILE;
       DECLARE FIXED FIELD FLD1(0:15,23), FLD2(1:0,13),FLD3(0:1,9);
       DECLARE LONG NREAL,XREAL,MAX'TIME←(4B7-1,-1);
       DECLARE I, CCX, J, PREAL, RREAL;
       FUNCTION MOTIM();
       NIT←0;
       REALTL(:XREAL);
       PIWE$RT←0; NREAL←MAX'TIME;
       FOR I←0 TO ICTE DO; J←ICT[I]$SOURCE;
       GOTO CAL4 IF ICT[I]$CLICT=0;
       IF (J=2 OR J=3) AND (ICT[I]$DAT0#0 OR ICT[I]$DAT1#0) DO;
       FLTCPL(ICT[I]$TDAT,XREAL IF J=2 ELSE PRCT:CCX);
       GOTO CAL1 IF CCX<2; GOTO CAL2 IF J=3;
       FLTCPL(ICT[I]$TDAT,NREAL:CCX);
       NREAL←ICT[I]$TDAT IF CCX=0; GOTO CAL2;
CAL1:  ICT[I]$TDAT←LONG'ZERO;
       PIWE←PIWE V' (4B7 RSH I);
CAL2:  ENDIF;
CAL4:  ENDFOR;
       IF SPCS[SPCSL]$NIC#0 OR SPCS[SPCSL]$NIS#0 DO;
       FLTCPL(SPCS[SPCSL]$CSNIET,XREAL:CCX);
       GOTO CAL3 IF CCX<2;
       FLTCPL(SPCS[SPCSL]$CSNIET,NREAL:CCX);
       NREAL←SPCS[SPCSL]$CSNIET IF CCX=0;
CAL3:  ENDIF;
       IF NREAL$WD0#MAX'TIME$WD0 OR NREAL$WD1#MAX'TIME$WD1 DO;
       PREAL←(NREAL$FLD1)@FLD3 V' NREAL$FLD2;
       NREAL$WD0←(@PRT[PRTI]-RESM) V' CHANGERTC;
       NREAL$WD1←PREAL;
              IF NREAL$WD1#PRT[PRTI]$PRRT OR PRT[PRTI]$PRRTP=0 DO;
       MISCALL(NREAL);
       ENDIF;
       ENDIF;
       RETURN;

       END;

       PROGRAM MISCAL;
*
*  MICRO SCHEDULER CALL
*
       INCLUDE RESMON,GLOBAL,ERRD;
       DECLARE LONG NREAL;
       DECLARE I,J=NREAL$WD1,K=NREAL$WD0;
       FUNCTION MISCALL(LONG NREAL);
*
CAL4:  PROTECT(PRO4);
          GOTO CAL5 IF ($USITOP+2) A' 37B=0;
          $USITOP←$USITOP+2;
          I←$USITOP+RESM;
          $I←NREAL;
          ATTENTION(ATT2);
       UNPROTECT(PRO4); RETURN;
CAL5:  UNPROTECT(PRO4); GOTO CAL4;
       ENTRY MIS1CALL(K,J);
       GOTO CAL4;

       END;

       PROGRAM FLTCP;
*
*       48 BIT INTEGER COMPARE
*
       DECLARE FIXED FIELD WD0(0),WD1(1);
       DECLARE LONG LW1,LW2;
       DECLARE FLAG,N1=LW1$WD0,N2=LW1$WD1,M1=LW2$WD0,M2=LW2$WD1;
       FUNCTION FLTCP(N1,N2,M1,M2);
CAL1:  RETURN 0 IF N1<M1;
       RETURN 2 IF N1>M1;
       RETURN 1 IF N2=M2;
       RETURN 0 IF (N2-M2)<0;
       RETURN 2;
       ENTRY FLTCPL(LW1,LW2); GOTO CAL1;

       FUNCTION FLTEQ(N1,N2,M1,M2);
CAL2:  RETURN 1 IF ((N1=M1) AND (N2=M2)) ELSE RETURN 0;
       ENTRY FLTEQL(LW1,LW2); GOTO CAL2;

       FUNCTION FLTGE(N1,N2,M1,M2);
CAL3:  .LDA N2, SUB M2, STA N2, LDA N1, SUC M1, STA N1;
       RETURN 1 IF N1>=0 ELSE RETURN 0;
       ENTRY FLTGEL(LW1,LW2); GOTO CAL3;

       END;

       PROGRAM FLTADD;
       DECLARE FIXED FIELD WD0(0),WD1(1);
       DECLARE LONG LW1,LW2;
       DECLARE FLAG,N1=LW1$WD0,N2=LW1$WD1,M1=LW2$WD0,M2=LW2$WD1;
*
*      48 BIT INTEGER ADD
*
       FUNCTION FLTADD(N1,N2,M1,M2);
       .LDA  N2;
       .ADD  M2;
       .STA  N2;
       .LDA  M1;
       .ADC  N1;
       .STA  N1;
       RETURN (N1,N2);

       END;

       PROGRAM FLTADDL;
       DECLARE FIXED FIELD WD0(0),WD1(1);
       DECLARE LONG LW1,LW2;
       DECLARE FLAG,N1=LW1$WD0,N2=LW1$WD1,M1=LW2$WD0,M2=LW2$WD1;
       LONG ENTRY FLTADDL(LW1,LW2);
       .LDA  N2;
       .ADD  M2;
       .STA  N2;
       .LDA  M1;
       .ADC  N1;
       .STA  N1;
       RETURN LW1;

       END;

       PROGRAM FLTSUBL;
*
*   LONG SUBTRACTION
*
       DECLARE FIXED FIELD WD0(0), WD1(1);
       DECLARE LONG M, N;
       DECLARE M0=M$WD0, M1=M$WD1, N0=N$WD0, N1=N$WD1;

       LONG FUNCTION FLTSUBL(M, N);
       .LDA M1; .SUB N1; .STA M1;
       .LDA M0; .SUC N0; .STA M0;
       RETURN M;

       END;

       PROGRAM SETICT;
*
*  SET INTERRUPT CELL
*
       INCLUDE ERRD,ICTD,SPTD;
       DECLARE I;
       FUNCTION SETICT(N,SAB,SP,LONG DA),FRETURN, MONITOR←172;
       FRETURN M39 IF (SP<0 OR SP>23) AND SAB$ACTION=2;
       FRETURN M39 IF N<0 OR N>ICTE;
       FRETURN M42 IF ICT[N]$CLICT A' SPT[CSP]$SPTKEY=0;
       SAB←SAB V' SP@SPEC;
       FRETURN M44 IF
       SAB$SOURCE>3 OR SAB$ACTION>2
       OR (SAB$SOURCE=2 AND N<9);
       (CHECK'SPNO(SAB$SPEC:I//FRETURN) &
          CHK'SP'CNTRL(SAB$SPEC//FRETURN M45))
         IF SAB$ACTION=1;
       SP←ICT[N]$CLICT;
       ICT[N]$WD0←SAB; ICT[N]$CLICT←SP;
       ICT[N]$TDAT←DA;
       MOTIM();
       RETURN;

       END;

       PROGRAM CVINT;
*
*CONVERT INTERRUPT CHARACTER CONSTANT TO INTERRUPT NUMBER
*
       INCLUDE ERRD,ICTD;
       DECLARE I;
       FUNCTION CVINT(CH), FRETURN, MONITOR←165;
       FOR I←0 TO ICTE DO;
       RETURN I IF ICTC[I]=CH;
       ENDFOR;
       FRETURN M46;

       END;

       PROGRAM RDICT;
*
*  READ ICT ENTRY
*
       INCLUDE ERRD,ICTD;
       DECLARE FIXED LONG FIELD LF1(0);
       FUNCTION RDICT(N,ARRAY WA),FRETURN ,MONITOR←166;
       FRETURN M39 IF N<0 OR N>ICTE;
       WA[0]←ICT[N]$WD0;
       WA[1]$LF1←ICT[N]$TDAT;
       RETURN;

       END;

       PROGRAM RDPIW;
*
*  READ PIWE
*
       INCLUDE ERRD,ICTD,PROFILE,RESMON;
       DECLARE I;
       FUNCTION RDPIW() ,MONITOR←167;
       PROTECT(PRO1);
          I←PIWE←PRT[PRTI]$PRPIW V' PIWE;
          PRT[PRTI]$PRPIW←0;
       UNPROTECT(PRO1);
       RETURN I;

       END;

       PROGRAM RESNI;
*
*  MAKE PROCESS INTERRUPTIBLE
*
       INCLUDE ERRD,ICTD,SPCSD,PROFILE;
       FUNCTION RESNI() ,MONITOR←168;
       SPCS[SPCSL]$NIS←0;
       RETURN IF SPCS[SPCSL]$NIC=0;
       SPCS[SPCSL]$CSNIET←SPCS[SPCSL-1]$CSNIET;
       RETURN;

       END;

       PROGRAM MKNI;
*
*  MAKE PROCESS NON-INTERRUPTIBLE
*
*  THIS FUNCTION MAKES THE CALLING PROCESS NON-INTERRUPTIBLE FOR
*      THE LESSER OF THE SPECIFIED NUMBER OF CLOCK TICKS OR TWO MINUTES.
*
       INCLUDE ERRD,ICTD,RESMON,SPCSD,PROFILE;
       DECLARE LONG XREAL,I;
       DECLARE J=I$WD0,CT=I$WD1;

       FUNCTION MKNI(CT,DA), FRETURN, MONITOR←169;
       CT←(HALF'MAXTIM LSH 1) IF (CT RSH 1)>HALF'MAXTIM;
       FRETURN M43 IF (CT RSH 1)<(30/2);
       FRETURN M43 IF SPCS[SPCSL]$NIS=1;
       J←0;
       REALTL(:XREAL);
       FLTADDL(I,XREAL:XREAL);
       IF SPCS[SPCSL]$NIC=0 DO;
CAL2:  SPCS[SPCSL]$CSNIET←XREAL;
       SPCS[SPCSL]$NIS←1;
       MOTIM();*PUT PROCESS ON RTIME QUEU;
       RETURN;
       ENDIF;
       FLTCPL(XREAL,SPCS[SPCSL]$CSNIET:J);
       GOTO CAL2 IF J=2 ELSE RETURN;

       END;

       PROGRAM CLPIW;
*
*  CLEAR PIW BITS
*
       INCLUDE ERRD,ICTD,PROFILE,SPTD;
       DECLARE I;
       FUNCTION CLPIW(M),FRETURN ,MONITOR←171;
       FOR I←0 TO ICTE DO; GOTO CAL1 IF ICT[I]$CLICT=0;
       FRETURN M42 IF M LSH I<0 AND
       (SPT[CSP]$SPTKEY A' ICT[I]$CLICT)=0;
CAL1:  ENDFOR;
       PIWE←PIWE A' N' M;
       RETURN;

       END;

       PROGRAM SCLICT;
*
*  SET CONTROL LEVEL IN INTERRUPT CELL
*
       INCLUDE ERRD,ICTD,SPTD,PROFILE;
       FUNCTION SCLICT(N,I),FRETURN ,MONITOR←173;
       FRETURN M39 IF N<0 OR N>ICTE;
       FRETURN M42 IF ICT[N]$CLICT A' SPT[CSP]$SPTKEY=0;
       ICT[N]$CLICT←I A' ACSPT;
       RETURN;

       END;

       PROGRAM ACQICT;
*
*  ACQUIRE INTERRUPT CELL N
*
       INCLUDE ERRD,ICTD,SPTD,PROFILE;
       DECLARE I;
       FUNCTION ACQICT(N),FRETURN ,MONITOR←174;
       FRETURN M39 IF N<-1 OR N>ICTE;
       GOTO CAL1 IF N#-1;
       FOR I←9 TO ICTE DO;
       (N←I & GOTO CAL2) IF ICT[I]$CLICT=0;
       ENDFOR;
       FRETURN M41;
CAL1:  FRETURN M40 IF ICT[N]$CLICT#0;
** THE FOLLOWING STATEMENT DOES A FULL-WORD STORE TO CLEAR THE ACTION,
** SOURCE, AND SPEC FIELDS -- TEMP KLUDGE
CAL2:  ICT[N]← SPNAME;
       RETURN N;

       END;

       PROGRAM DELICT;
*
*
*  DELETE NAME IN ICT ENTRY
*
       INCLUDE ERRD,ICTD;
       DECLARE I,INA;
       FUNCTION DELICT(IND);
       INA← 1 LSH IND;
       FOR I←0 TO ICTE DO;
       IF ICT[I]$CLICT#0 DO;
       ICT[I]$CLICT←ICT[I]$CLICT A' N' INA;
       IF ICT[I]$CLICT#0 DO;
       ICT[I]$CLICT←0 IF ICT[I]$ACTION=1 AND ICT[I]$SPEC=IND;
       ENDIF;
       ENDIF;
       ENDFOR;
       RETURN;

       END;

       PROGRAM CK'DK'ADDR;
*
*  CHECK DISK ADDRESS FOR CORRECTNESS
*
       INCLUDE DKAL;
       DECLARE I,J;
       FUNCTION CK'DK'ADDR(DK),FRETURN;
       FRETURN  IF DK$TSU<2 OR DISKA[DK$DKNO]=-1
       OR DK$TRACK>TRACKA-1 OR DK$BAND>BANDA[DK$DKNO]-1
       OR DK$SECT>SECTA-1 OR DK$TSU>1+DKTSU;
       RETURN;
*  CONVERT DISK ADDRESS TO NUMBER
       ENTRY CV'DK'NO(DK),FRETURN;
       CK'DK'ADDR(DK//FRETURN );
       DK←DK$SECT+DK$BAND*SECTA+DK$TRACK*SECTA*BANDA[DK$DKNO]
        +DISKA[DK$DKNO];
       RETURN DK;
*  CONVERT NUMBER TO DISK ADDRESS
       ENTRY CV'NO'DK(DK),FRETURN;
       FRETURN IF DK<0 OR DK>MAXDK;
       FOR I←3 BY -1 TO 0 DO;
          IF DISKA[I]#-1 AND DK>=DISKA[I] DO;
             DK←DK-DISKA[I];
             J←0; J$TSU←2; J$DKNO←I;
             J$TRACK←DK/(SECTA*BANDA[I]); DK←DK MOD (SECTA*BANDA[I]);
             J$BAND←DK/SECTA; J$SECT←DK MOD SECTA;
             RETURN J;
          ENDIF;
       ENDFOR; PUNT('DKE');

       END;

       PROGRAM DKALL;
*
*
*  DISK ALLOCATOR ROUTINE
*
       INCLUDE ERRD,DKAL,RESMON;
       DECLARE I,REM,J,K,IS;
       FUNCTION REL'DISK'ADDR(DK),FRETURN;
       IS←0; GOTO CAL1;
*  REMOVE DISK PAGE FROM ALLOCATION TABLE
       ENTRY RDKALL(DK),FRETURN;
       IS←1;
CAL1:  CV'DK'NO(DK:J//FRETURN );
       REM←J MOD 24; I←J/24+DAST;
       FRETURN IF (I.WD0 LSH REM)<0 AND IS=0;
       J←4B7 RSH REM;
       I.WD0←I.WD0 V' J IF IS=0 ELSE
         I.WD0←I.WD0 A' N' J;
       RETURN;
*
*  GET DISK ADDRESS
*
       ENTRY GET'DISK'ADDR(DKO),FRETURN;
       CV'DK'NO(DKO:I//VALUE I←0);
       REM←I/24;
CAL13: J←I/24+DAST;
       IF J.WD0 # 0 DO;
          FOR K←(I MOD 24) TO 23 DO;
             IF (J.WD0 LSH K)<0 DO;
                J.WD0←J.WD0 E' (4B7 RSH K);
                CV'NO'DK((I/24)*24+K:J//VALUE PUNT('DKE'));
                RETURN J;
             ENDIF;
          ENDFOR;
       ENDIF;
       I←(I/24)*24+24; I←0 IF I>MAXDK;
       GOTO CAL13 IF REM#I/24;
       FRETURN;

*
*  CONVERT TO DISK ADDRESS FOR ALLOCATOR
*
       INTEGER FUNCTION CVDK(I);
       I←(I A' 1)@DKNO V' ((I RSH 1) A' 377B)@TRACK;
       RETURN I;

       END;

       PROGRAM SCHED;
*
*
*  SCHEDULER TEMPORARY FUNCTION
*
       INCLUDE RESMON,SWPD,GLOBAL,PAGE0;
       DECLARE PTR,E,I,PRIORITY,ARRAY AR[6];
       DECLARE POINTER SQUEUE;
       FUNCTION SCHED(UCLL);
*
*  REMOVE ENTRIES FROM WAKEUP QUEUE AND
*  PUT ON END OF SCHEDULER QUEUE
CAL1:  PROTECT(PRO1);
          RMQUEU(WAKEUPQ,PRPTR:PTR//CAL10);
          GOTO CAL2 IF PTR.PRPRD=1 AND PTR.PRACT=1;
          SQUEUE ← @SCHEDQS[PTR.PRPRI];
          PUTQUEU(PTR,SQUEUE,1,PRPTR);
          PTR.PRWAQ←0; PTR.PRSCQ←1;
       UNPROTECT(PRO1); GOTO CAL1;
CAL2:     (PUTQUEU(PTR,WAKEUPQ,1,PRPTR) & GOTO CAL10) IF UCLL=0;
          BSET(@AR[0],0,6);
          PTR.PRACT←0;
          AR[0]←PTR.PRUN1; AR[1]←PTR.PRUN2;
          AR[2]←PTR.PRDK; AR[4]←CRDK;
          BSET(PTR,0,12);
       UNPROTECT(PRO1);
       SWPREQ(AR,0//CAL1:E,I);
       GOTO CAL1;
*
*  PUT PROCESS ON SWAPPER QUEUE
*  CHECK WHETHER SWAPPER SHOULD CONSIDER MORE PROCESSES
CAL10: UNPROTECT(PRO1);
CAL11: FOR PRIORITY←0 TO 7 DO;
          RETURN IF (NCTX.WD0+NPR.WD0)>MAXPRO;
          SQUEUE ← @SCHEDQS[PRIORITY];
          PROTECT(PRO1);
             RMQUEU(SQUEUE,PRPTR:PTR//CAL12);
             PTR.PRSCQ←0; PTR.PRSWQ←1;
             BSET(@AR[0],0,6);
             AR[0]←PTR.PRUN1; AR[1]←PTR.PRUN2;
             AR[2]←PTR.PRDK; AR[3]←PTR-RESM;
          UNPROTECT(PRO1);
          AR[4]←CRRDP;
          SWPREQ(AR,0//CAL13:E,I);
          GOTO CAL11;
CAL12:    UNPROTECT(PRO1);
       ENDFOR;
       RETURN;
CAL13: PUNT('SWQ');

       END;

       PROGRAM RDTIME;
       INCLUDE PROFILE;
*
*  READ TIME CLOCKS
*
       DECLARE LONG LWT;
       FUNCTION RDTIME(P),MONITOR←210;
       RETURN PRCT IF P=1 OR P='CTC';
       REALTL(:LWT);
       RETURN LWT;

       END;

       PROGRAM SETPIW;
*
*  SET PIW BITS
*
          INCLUDE ICTD,FLS,PROFILE,RESMON,ERRD;
       DECLARE I,J,E,M,F;
       FUNCTION SETPIW(F,M),FRETURN,MONITOR←163;
       IF F=-1 DO;
          PIWE ← PIWE V' M A' N' RESPIW;
          RETURN;
       ENDIF;
       CKOFTAC(F,1,0//FRETURN);
       FRETURN M32 IF OFT[F]$TYPE#PROCT OR OFT[F]$OFTMOD=1;
       RDMIB2(F,0//FRETURN);
       CKOBTAC(F:E,I//FRETURN);
       J←MIBA[I]$PROCPRT;
       FRETURN M61 IF PRT[J]$PRUN1#MIBA[I]$PROCUN1 OR
         PRT[J]$PRUN2#MIBA[I]$PROCUN2;
       MIS1CALL(IWAKEUPC V' J,M A' N' RESPIW);
       RETURN;

          END;

        PROGRAM KLUDGE'DIO;
          INCLUDE SWPD, PROFILE;
          DECLARE ADDR, I, T, DAMMIT;
          DECLARE ARRAY NODE;
          DECLARE FIXED FIELD TSU'ST(17);

        ENTRY KDIO(NODE, ADDR), MONITOR ← 128;
          I ← @NODE[0];
*  MAKE DUMMY REFERENCE TO INSURE PAGE IS AVAILABLE AND READ-WRITE
          $ADDR ← DAMMIT ← $ADDR;
          .LDX ADDR, AAX, CXA, LSHA -11, STA T;
          I.SWCPA ← T; I.SWEPRT ← @PRT[PRTI]-RESM;
          TSUD.TSU'ST ← 0;
          SWPREQ(NODE,0//VALUE PUNT('DIO'));
          WHILE TSUD.TSU'ST = 0 DO;
          ENDFOR;
          BCOPY(I,TSUD,18);
          RETURN;

        END;

        PROGRAM DO'POT'PIN;
          INCLUDE CHIOD, PROFILE;
          DECLARE LONG ARGS, INTEGER A1=ARGS$WD0, A2=ARGS$WD1;
          DECLARE LONG FIXED FIELD CARGS(CARG1$FDDISP);
       DECLARE DAMMIT;

        ENTRY DO'POT'PIN(A1, A2, POTFLG), FRETURN, MONITOR ← 129;
          CPUIT.CARGS ← ARGS;
          CPUIT.WD0 ← 1@LNO V' 1@RWCH V' (DOAPOT IF POTFLG ELSE DOAPIN)@CRT;
          ATTENTION(ATT3);
          RETURN DAMMIT ← CPUIT.VALU IF CPUIT.RWCH=0 WHILE 1;
        END;
       PROGRAM BO;
*
*      KLUDGE MONITOR CALL TO READ OR
*      WRITE ARBITRARY CELLS (ONLY FOR DEBUGGING)*****
       FUNCTION LEWENDAL(A1,A2,A3), FRETURN,MONITOR←255;
       FRETURN ('FIA',999) IF A1<0 OR A1>1B6-1;
       IF A3 DO;
       $A1←A2;
       ELSE DO;
       A2←$A1;
       ENDIF;
       RETURN A2;

       END;

       PROGRAM BLOCK;
*
*  BLOCK ROUTINE
*
       INCLUDE ERRD,GLOBAL, ICTD,PROFILE,RESMON;
       DECLARE LONG IJ,TIBL;
       DECLARE UCLL,ECNT,I=IJ$WD0,J=IJ$WD1,TI=TIBL$WD0,BL=TIBL$WD1;
       FUNCTION FBLOCK(WW,I),FRETURN,MONITOR←164;
       RETURN IF I#0; UCLL←1; GOTO CAL1;
       FUNCTION BLOCK(WW),FRETURN ,MONITOR←170;
       UCLL←1;
CAL1:  FOR I←0 TO ICTE DO;
       IF(WW LSH I)<0 DO;
       FRETURN M38 IF ICT[I]$CLICT=0 OR ICT[I]$BLK=0;
       ENDIF;
       ENDFOR;
CAL4:  TI←0;
CAL5:  UNSCH(TI:BL); ECNT←0;
CAL2:  SCHED(UCLL);
CAL6:  PROTECT(PRO1);
          PRT[PRTI]$PRPRI←1;
          IF PRT[PRTI]$PRPIW A' (1@QUIT'CHR V' 1@IO V' 1@RT)#0 DO;
             PRT[PRTI]$PRNQTA←0;
          ENDIF;
          PIWE←PIWE V' PRT[PRTI]$PRPIW A' N' 1@RSI;
          PRT[PRTI]$PRPIW←0;
       UNPROTECT(PRO1);
       GOTO CAL3 IF TI#0 AND ECNT=0;
       IF PIWE#0 DO;
         IF UCLL#0 DO;
           CSTRAP(WW,1);
         ELSE DO;
           XMONTRAP;
         ENDIF;
       ENDIF;
       (PIWE←PIWE A' N' WW & RETURN) IF PIWE A' WW#0;

       RETURN IF TI#0 AND ECNT>0;
CAL3:  AGE'CWS();
       AGE'DWS();*  AGE WORKING SETS
       SHRINK'CWS();* SIMULATE 1.03 AMC
       FREE'TBW'PAGES();* SIMULATE 1.03 AMC
       XMBLOCK(BL);*   BLOCK PROCESS - DOES UNPROTECT BEFORE AND SLOK AFTER
       ECNT←ECNT+1;
       GOTO CAL6;
*
*  BLOCK OUT OF MONITOR FOR PAGEFAULT
*
       ENTRY SWBLOCK();
*
* SET VALUES TO THOSE SIMILAR TO TBLOCK BELOW EXCEPT SPECIFY BLOCKOUT
*   RATHER THAN UNLOAD AND BYPASS THE CALLING OF UNSCHED AND SCHED.
*
       UCLL←0; TI←2; BL←BLOCKOUTC; WW←0; ECNT←0;
       PROTECT(PRO1);
          PRT[PRTI]$PRPGF←1;           /*SET PAGE FAULT BIT FOR AMC*/
          PRT[PRTI]$PRPRI←0;           /*RUN W/ HIGHER PRIORITY*/
       UNPROTECT(PRO1);
       PAGE'FAULTS←PAGE'FAULTS + 1;    /*STEP COUNTER IN CB*/
       GOTO CAL3;
*
*  MONITOR ENTRY WITH BLOCK CONDITION
       ENTRY MBLOCK(WW);
       UCLL←0; GOTO CAL1;
*
*  TIMER OVERFLOW BLOCK
*
       ENTRY TBLOCK();
       PROTECT(PRO1);
          PRT[PRTI]$PRNQTA←PRT[PRTI]$PRNQTA+1 IF PRT[PRTI]$PRNQTA<32;
       UNPROTECT(PRO1);
       UCLL←0; TI←1;
       WW←0; GOTO CAL5;
*
*  MONITOR ENTRY FOR DISMISSING FOR TIME
*
       ENTRY SBLOCK(IJ);
       UCLL←0;
       REALTL(:TIBL); WW←4B7+1;
       FLTADDL(TIBL,IJ:IJ);
       ICT[0]$TDAT←IJ;
       MOTIM();
       GOTO CAL4;
*
*
       ENTRY TIME'IT();
       RDIT(J); I←0; J ← (J A' (4B7-1))-(PRCTT V' 4B7);
       FLTADDL(PRCT,IJ:PRCT);
       PRT[PRTI]$PRCIET←PRT[PRTI]$PRCIET+(J RSH 7);
       RETURN;

       END;

       PROGRAM TO'BLOCK;
       INCLUDE TRAPD,PROFILE,GLOBAL;
*
*  TIMER OVERFLOW TRAP
*
     FUNCTION TO'BLOCK();
       GOTO CAL10 IF TRSTATE.STPC<6B5;
       TIME'IT();
       PRCTT←-10000 A' (4B7-1); SIT(PRCTT); RETURN;
CAL10: TBLOCK(); RETURN;

       END;

       PROGRAM CSTRAP;
*
*
*  CAUSE INTERRUPTS
*
       INCLUDE ERRD,ICTD,SPCSD,PROFILE,GLOBAL,SPTD;
       DECLARE J,I;
       FUNCTION CSTRAP(WW,TR);
       MOTIM();
       RETURN IF (SPCS[SPCSL]$NIC V' SPCS[SPCSL]$NIS)#0
       AND NIT=0;
       J←PIWE A' N' WW;
       GOTO CAL3 IF NIT=1;
       J ← J A' -(4B7 RSH ICTE);
       WHILE J DO;
*          FIRST'BIT(J,I);
          .LDA  J, LSHD -1, LLT, ADX -1, STX I;
       GOTO CAL4 IF ICT[I]$CLICT=0;
       GOTO CAL1 IF ICT[I]$ACTION=0;
       PIWE←PIWE  A' N' WW A' N' (4B7 RSH I);
       INTERRUPT(ICT[I]$SPEC,I,TR) IF ICT[I]$ACTION=1;
       TRAP(ICT[I]$SPEC,I,TR) IF ICT[I]$ACTION=2;
       PUNT('PIS');
CAL1:     J ← J-4B7 RSH I;* CLEAR THE BIT IN J
       ENDFOR;
       RETURN;
CAL3:  PIWE←J; SPCS[SPCSL]$NIC←SPCS[SPCSL]$NIS←0;
       TRAP(TNO(NILE),0,TR);
CAL4:  PIWE←PIWE A' N' (1 LSH(23-I));
       GOTO CAL1;

       END;

       PROGRAM MOTIM;
*
*  SET UP REAL TIMERS AND SET PIW BITS
*
       INCLUDE ERRD,ICTD, RESMON,GLOBAL,SPCSD,PROFILE;
       DECLARE FIXED FIELD FLD1(0:15,23), FLD2(1:0,13),FLD3(0:1,9);
       DECLARE LONG NREAL,XREAL,MAX'TIME←(4B7-1,-1);
       DECLARE I, CCX, J, PREAL, RREAL;
       FUNCTION MOTIM();
       NIT←0;
       REALTL(:XREAL);
       PIWE$RT←0; NREAL←MAX'TIME;
       FOR I←0 TO ICTE DO; J←ICT[I]$SOURCE;
       GOTO CAL4 IF ICT[I]$CLICT=0;
       IF (J=2 OR J=3) AND (ICT[I]$DAT0#0 OR ICT[I]$DAT1#0) DO;
       FLTCPL(ICT[I]$TDAT,XREAL IF J=2 ELSE PRCT:CCX);
       GOTO CAL1 IF CCX<2; GOTO CAL2 IF J=3;
       FLTCPL(ICT[I]$TDAT,NREAL:CCX);
       NREAL←ICT[I]$TDAT IF CCX=0; GOTO CAL2;
CAL1:  ICT[I]$TDAT←LONG'ZERO;
       PIWE←PIWE V' (4B7 RSH I);
CAL2:  ENDIF;
CAL4:  ENDFOR;
       IF SPCS[SPCSL]$NIC#0 OR SPCS[SPCSL]$NIS#0 DO;
       FLTCPL(SPCS[SPCSL]$CSNIET,XREAL:CCX);
       GOTO CAL3 IF CCX<2;
       FLTCPL(SPCS[SPCSL]$CSNIET,NREAL:CCX);
       NREAL←SPCS[SPCSL]$CSNIET IF CCX=0;
CAL3:  ENDIF;
       IF NREAL$WD0#MAX'TIME$WD0 OR NREAL$WD1#MAX'TIME$WD1 DO;
       PREAL←(NREAL$FLD1)@FLD3 V' NREAL$FLD2;
       NREAL$WD0←(@PRT[PRTI]-RESM) V' CHANGERTC;
       NREAL$WD1←PREAL;
              IF NREAL$WD1#PRT[PRTI]$PRRT OR PRT[PRTI]$PRRTP=0 DO;
       MISCALL(NREAL);
       ENDIF;
       ENDIF;
       RETURN;

       END;

       PROGRAM MISCAL;
*
*  MICRO SCHEDULER CALL
*
       INCLUDE RESMON,GLOBAL,ERRD;
       DECLARE LONG NREAL;
       DECLARE I,J=NREAL$WD1,K=NREAL$WD0;
       DECLARE OLD'CPU'USIB'TOP,NEW'CPU'USIB'TOP;
       FUNCTION MISCALL(LONG NREAL);
*
CAL4:  PROTECT(PRO4);
          GOTO CAL5 IF ($USITOP+2) A' 37B=0;
          OLD'CPU'USIB'TOP←$USITOP←$USITOP+2;
          I←$USITOP+RESM;
          $I←NREAL;
          ATTENTION(ATT2);
          NEW'CPU'USIB'TOP←$USITOP;
       UNPROTECT(PRO4);
*
*  WE SUSPECT A PROTECT MALFUNCTION IN A CPU.  THIS IS A LITTLE CHECK
*  TO MAKE SURE THE USCHED HASN'T GONE ON ON ITS OWN.
*
       PUNT('USP') IF NEW'CPU'USIB'TOP#OLD'CPU'USIB'TOP;
       RETURN;
CAL5:  UNPROTECT(PRO4); GOTO CAL4;
       ENTRY MIS1CALL(K,J);
       GOTO CAL4;

       END;

       PROGRAM FLTCP;
*
*       48 BIT INTEGER COMPARE
*
       DECLARE FIXED FIELD WD0(0),WD1(1);
       DECLARE LONG LW1,LW2;
       DECLARE FLAG,N1=LW1$WD0,N2=LW1$WD1,M1=LW2$WD0,M2=LW2$WD1;
       FUNCTION FLTCP(N1,N2,M1,M2);
CAL1:  RETURN 0 IF N1<M1;
       RETURN 2 IF N1>M1;
       RETURN 1 IF N2=M2;
       RETURN 0 IF (N2-M2)<0;
       RETURN 2;
       ENTRY FLTCPL(LW1,LW2); GOTO CAL1;

       END;

       PROGRAM FLTADD;
       DECLARE FIXED FIELD WD0(0),WD1(1);
       DECLARE LONG LW1,LW2;
       DECLARE FLAG,N1=LW1$WD0,N2=LW1$WD1,M1=LW2$WD0,M2=LW2$WD1;
*
*      48 BIT INTEGER ADD
*
       FUNCTION FLTADD(N1,N2,M1,M2);
       .LDA  N2;
       .ADD  M2;
       .STA  N2;
       .LDA  M1;
       .ADC  N1;
       .STA  N1;
       RETURN (N1,N2);

       END;

       PROGRAM FLTADDL;
       DECLARE FIXED FIELD WD0(0),WD1(1);
       DECLARE LONG LW1,LW2;
       DECLARE FLAG,N1=LW1$WD0,N2=LW1$WD1,M1=LW2$WD0,M2=LW2$WD1;
       LONG ENTRY FLTADDL(LW1,LW2);
       .LDA  N2;
       .ADD  M2;
       .STA  N2;
       .LDA  M1;
       .ADC  N1;
       .STA  N1;
       RETURN LW1;

       END;

       PROGRAM FLTSUB;
*
*   48 BIT INTEGER SUBTRACT
*
       FUNCTION FLTSUB(N1,N2,M1,M2);
       .LDA N2; .SUB M2; .STA N2;
       .LDA N1; .SUC M1; .STA N1;
       RETURN (N1,N2);

       END;

       PROGRAM SETICT;
*
*  SET INTERRUPT CELL
*
       INCLUDE ERRD,ICTD,SPTD;
       DECLARE I;
       FUNCTION SETICT(N,SAB,SP,LONG DA),FRETURN, MONITOR←172;
       FRETURN M39 IF (SP<0 OR SP>23) AND SAB$ACTION=2;
       FRETURN M39 IF N<0 OR N>ICTE;
       FRETURN M42 IF ICT[N]$CLICT A' SPT[CSP]$SPTKEY=0;
       SAB←SAB V' SP@SPEC;
       FRETURN M44 IF
       SAB$SOURCE>3 OR SAB$ACTION>2
       OR (SAB$SOURCE=2 AND N<9);
       (CHECK'SPNO(SAB$SPEC:I//FRETURN) &
          CHK'SP'CNTRL(SAB$SPEC//FRETURN M45))
         IF SAB$ACTION=1;
       SP←ICT[N]$CLICT;
       ICT[N]$WD0←SAB; ICT[N]$CLICT←SP;
       ICT[N]$TDAT←DA;
       MOTIM();
       RETURN;

       END;

       PROGRAM CVINT;
*
*CONVERT INTERRUPT CHARACTER CONSTANT TO INTERRUPT NUMBER
*
       INCLUDE ERRD,ICTD;
       DECLARE I;
       FUNCTION CVINT(CH), FRETURN, MONITOR←165;
       FOR I←0 TO ICTE DO;
       RETURN I IF ICTC[I]=CH;
       ENDFOR;
       FRETURN M46;

       END;

       PROGRAM RDICT;
*
*  READ ICT ENTRY
*
       INCLUDE ERRD,ICTD;
       DECLARE FIXED LONG FIELD LF1(0);
       FUNCTION RDICT(N,ARRAY WA),FRETURN ,MONITOR←166;
       FRETURN M39 IF N<0 OR N>ICTE;
       WA[0]←ICT[N]$WD0;
       WA[1]$LF1←ICT[N]$TDAT;
       RETURN;

       END;

       PROGRAM RDPIW;
*
*  READ PIWE
*
       INCLUDE ERRD,ICTD,PROFILE,RESMON;
       DECLARE I;
       FUNCTION RDPIW() ,MONITOR←167;
       PROTECT(PRO1);
          I←PIWE←PRT[PRTI]$PRPIW V' PIWE;
          PRT[PRTI]$PRPIW←0;
       UNPROTECT(PRO1);
       RETURN I;

       END;

       PROGRAM RESNI;
*
*  MAKE PROCESS INTERRUPTIBLE
*
       INCLUDE ERRD,ICTD,SPCSD,PROFILE;
       FUNCTION RESNI() ,MONITOR←168;
       SPCS[SPCSL]$NIS←0;
       RETURN IF SPCS[SPCSL]$NIC=0;
       SPCS[SPCSL]$CSNIET←SPCS[SPCSL-1]$CSNIET;
       RETURN;

       END;

       PROGRAM MKNI;
*
*  MAKE PROCESS NON-INTERRUPTIBLE
*
       INCLUDE ERRD,ICTD,RESMON,SPCSD,PROFILE;
       DECLARE LONG XREAL,I;
       DECLARE J=I$WD0,CT=I$WD1;
       FUNCTION MKNI(CT,DA), FRETURN, MONITOR←169;
       FRETURN M43 IF CT>MAXTIM OR CT<30;
       FRETURN M43 IF SPCS[SPCSL]$NIS=1;
       J←0;
       REALTL(:XREAL);
       FLTADDL(I,XREAL:XREAL);
       IF SPCS[SPCSL]$NIC=0 DO;
CAL2:  SPCS[SPCSL]$CSNIET←XREAL;
       SPCS[SPCSL]$NIS←1;
       MOTIM();*PUT PROCESS ON RTIME QUEU;
       RETURN;
       ENDIF;
       FLTCPL(XREAL,SPCS[SPCSL]$CSNIET:J);
       GOTO CAL2 IF J=2 ELSE RETURN;

       END;

       PROGRAM CLPIW;
*
*  CLEAR PIW BITS
*
       INCLUDE ERRD,ICTD,PROFILE,SPTD;
       DECLARE I;
       FUNCTION CLPIW(M),FRETURN ,MONITOR←171;
       FOR I←0 TO ICTE DO; GOTO CAL1 IF ICT[I]$CLICT=0;
       FRETURN M42 IF M LSH I<0 AND
       (SPT[CSP]$SPTKEY A' ICT[I]$CLICT)=0;
CAL1:  ENDFOR;
       PIWE←PIWE A' N' M;
       RETURN;

       END;

       PROGRAM SCLICT;
*
*  SET CONTROL LEVEL IN INTERRUPT CELL
*
       INCLUDE ERRD,ICTD,SPTD,PROFILE;
       FUNCTION SCLICT(N,I),FRETURN ,MONITOR←173;
       FRETURN M39 IF N<0 OR N>ICTE;
       FRETURN M42 IF ICT[N]$CLICT A' SPT[CSP]$SPTKEY=0;
       ICT[N]$CLICT←I A' ACSPT;
       RETURN;

       END;

       PROGRAM ACQICT;
*
*  ACQUIRE INTERRUPT CELL N
*
       INCLUDE ERRD,ICTD,SPTD,PROFILE;
       DECLARE I;
       FUNCTION ACQICT(N),FRETURN ,MONITOR←174;
       FRETURN M39 IF N<-1 OR N>ICTE;
       GOTO CAL1 IF N#-1;
       FOR I←9 TO ICTE DO;
       (N←I & GOTO CAL2) IF ICT[I]$CLICT=0;
       ENDFOR;
       FRETURN M41;
CAL1:  FRETURN M40 IF ICT[N]$CLICT#0;
** THE FOLLOWING STATEMENT DOES A FULL-WORD STORE TO CLEAR THE ACTION,
** SOURCE, AND SPEC FIELDS -- TEMP KLUDGE
CAL2:  ICT[N]← SPNAME;
       RETURN N;

       END;

       PROGRAM DELICT;
*
*
*  DELETE NAME IN ICT ENTRY
*
       INCLUDE ERRD,ICTD;
       DECLARE I,INA;
       FUNCTION DELICT(IND);
       INA← 1 LSH IND;
       FOR I←0 TO ICTE DO;
       IF ICT[I]$CLICT#0 DO;
       ICT[I]$CLICT←ICT[I]$CLICT A' N' INA;
       IF ICT[I]$CLICT#0 DO;
       ICT[I]$CLICT←0 IF ICT[I]$ACTION=1 AND ICT[I]$SPEC=IND;
       ENDIF;
       ENDIF;
       ENDFOR;
       RETURN;

       END;

       PROGRAM CK'DK'ADDR;
*
*  CHECK DISK ADDRESS FOR CORRECTNESS
*
       INCLUDE DKAL;
       DECLARE I,J;
       FUNCTION CK'DK'ADDR(DK),FRETURN;
       FRETURN  IF DK$TSU<2 OR DISKA[DK$DKNO]=-1
       OR DK$TRACK>TRACKA-1 OR DK$BAND>BANDA[DK$DKNO]-1
       OR DK$SECT>SECTA-1 OR DK$TSU>1+DKTSU;
       RETURN;
*  CONVERT DISK ADDRESS TO NUMBER
       ENTRY CV'DK'NO(DK),FRETURN;
       CK'DK'ADDR(DK//FRETURN );
       DK←DK$SECT+DK$BAND*SECTA+DK$TRACK*SECTA*BANDA[DK$DKNO]
        +DISKA[DK$DKNO];
       RETURN DK;
*  CONVERT NUMBER TO DISK ADDRESS
       ENTRY CV'NO'DK(DK),FRETURN;
       FRETURN IF DK<0 OR DK>MAXDK;
       FOR I←3 BY -1 TO 0 DO;
          IF DISKA[I]#-1 AND DK>=DISKA[I] DO;
             DK←DK-DISKA[I];
             J←0; J$TSU←2; J$DKNO←I;
             J$TRACK←DK/(SECTA*BANDA[I]); DK←DK MOD (SECTA*BANDA[I]);
             J$BAND←DK/SECTA; J$SECT←DK MOD SECTA;
             RETURN J;
          ENDIF;
       ENDFOR; PUNT('DKE');

       END;

       PROGRAM DKALL;
*
*
*  DISK ALLOCATOR ROUTINE
*
       INCLUDE ERRD,DKAL,RESMON;
       DECLARE I,REM,J,K,IS;
       FUNCTION REL'DISK'ADDR(DK),FRETURN;
       IS←0; GOTO CAL1;
*  REMOVE DISK PAGE FROM ALLOCATION TABLE
       ENTRY RDKALL(DK),FRETURN;
       IS←1;
CAL1:  CV'DK'NO(DK:J//FRETURN );
       REM←J MOD 24; I←J/24+DAST;
       FRETURN IF (I.WD0 LSH REM)<0 AND IS=0;
       J←4B7 RSH REM;
       I.WD0←I.WD0 V' J IF IS=0 ELSE
         I.WD0←I.WD0 A' N' J;
       RETURN;
*
*  GET DISK ADDRESS
*
       ENTRY GET'DISK'ADDR(DKO),FRETURN;
       CV'DK'NO(DKO:I//VALUE I←0);
       REM←I/24;
CAL13: J←I/24+DAST;
       IF J.WD0 # 0 DO;
          FOR K←(I MOD 24) TO 23 DO;
             IF (J.WD0 LSH K)<0 DO;
                J.WD0←J.WD0 E' (4B7 RSH K);
                CV'NO'DK((I/24)*24+K:J//VALUE PUNT('DKE'));
                RETURN J;
             ENDIF;
          ENDFOR;
       ENDIF;
       I←(I/24)*24+24; I←0 IF I>MAXDK;
       GOTO CAL13 IF REM#I/24;
       FRETURN;

*
*  CONVERT TO DISK ADDRESS FOR ALLOCATOR
*
       INTEGER FUNCTION CVDK(I);
       I←(I A' 1)@DKNO V' ((I RSH 1) A' 377B)@TRACK;
       RETURN I;

       END;

       PROGRAM UNSCH;
*
*
*
*  UNSCHEDULE PROCESS
*
       INCLUDE ERRD,RESMON,GLOBAL,PROFILE;
       DECLARE PARAMETER DEFAULT'QUANTUM←10000;   /* 0.1 SECOND */
       DECLARE I;
       FUNCTION UNSCH(TI);
       RETURN BLOCKOUTC IF TI=0;
       TIME'IT();
       PRCTT←I←-DEFAULT'QUANTUM A' (4B7-1); SIT(I);
       RETURN UNLOADC;
       RETURN;

       END;

       PROGRAM SCHED;
*
*
*  SCHEDULER TEMPORARY FUNCTION
*
       INCLUDE RESMON,SWPD,GLOBAL,PAGE0;
       DECLARE PTR,QNO,E,I,PRIORITY,ARRAY AR[6];
       DECLARE POINTER SQUEUE;
       DECLARE FIG'MERIT,CURR'PTR,PREV'PTR;
       FUNCTION SCHED(UCLL);
*
*  REMOVE ENTRIES FROM WAKEUP QUEUE AND
*  PUT IN PROPER PLACE IN SCHEDULER QUEUE
*
CAL1:  PROTECT(PRO1);
          RMQUEU(WAKEUPQ,PRPTR:PTR//CAL10);
          GOTO CAL2 IF PTR.PRPRD=1 AND PTR.PRACT=1;
          IF QNO←(PTR.PRSPRI← (0 IF PTR.PRNQTA<4 ELSE 1))=0 DO;
             PUTQUEU(PTR,@SCHEDQS[0],1,PRPTR);
          ELSE DO;
             FIG'MERIT←((PTR.PRPIET LSH 4)+PTR.PRCIET)*PTR.PRWGHT;
             PREV'PTR←1B6-1+RESM;
             CURR'PTR←SCHEDQS[1]$MADF+RESM;
             WHILE CURR'PTR#1B6-1+RESM AND
                  ((CURR'PTR.PRPIET LSH 4)+CURR'PTR.PRCIET)*CURR'PTR.PRWGHT
                  <=FIG'MERIT DO;
                PREV'PTR←CURR'PTR;
                CURR'PTR←CURR'PTR.PRPTR+RESM;
             ENDFOR;
             SCHEDQS[1]$MADF←PTR-RESM IF PREV'PTR=1B6-1+RESM ELSE
                  PREV'PTR.PRPTR←PTR-RESM;
             SCHEDQS[1]$MADF1←PTR-RESM IF CURR'PTR=1B6-1+RESM;
             PTR.PRPTR←CURR'PTR-RESM;
          ENDIF;
          PTR.PRWAQ←0; PTR.PRSCQ←1;
       UNPROTECT(PRO1); GOTO CAL1;
CAL2:     (PUTQUEU(PTR,WAKEUPQ,1,PRPTR) & GOTO CAL10) IF UCLL=0;
*
*  ASK SWAPPER TO DESTROY THE PROCESS
*
          BSET(@AR[0],0,6);
          PTR.PRACT←0;
          AR[0]←PTR.PRUN1; AR[1]←PTR.PRUN2;
          AR[2]←PTR.PRDK; AR[4]←CRDK;
          BSET(PTR,0,12);
       UNPROTECT(PRO1);
       DIRECT'AMC'REQ(AR//CAL1:E,I);
       GOTO CAL1;
CAL10: UNPROTECT(PRO1);
*
*  CHECK FOR NEW SCHEDULING INTERVAL.
*
       IF $RTC#$ORTC0+0 DO;    /* I CAN'T BELIEVE I HAVE TO DO THIS...*/
*
*  MOVE CURRENT INTERVAL ELAPSED TIME TO PREVIOUS INTERVAL ELAPSED TIME
*  AND START NEW INTERVAL
*  NOTE NO USE OF A PROTECT FOR THIS OPERATION.
*
          $ORTC0←$RTC+0;       /* ... TO GET IT TO COMPILE.  UGH!   */
          FOR I←0 TO PRTL-1 DO;
             PRT[I]$PRPIET←PRT[I]$PRCIET RSH 4;
             PRT[I]$PRCIET←0;
          ENDFOR;
       ENDIF;
*
*  PUT PROCESS ON SWAPPER QUEUE
*  CHECK WHETHER SWAPPER SHOULD CONSIDER MORE PROCESSES
*
CAL11: FOR PRIORITY←0 TO 1 DO;
          RETURN IF (NCTX.WD0+NPR.WD0)>MAXPRO;
          SQUEUE ← @SCHEDQS[PRIORITY];
          PROTECT(PRO1);
             RMQUEU(SQUEUE,PRPTR:PTR//CAL12);
             PTR.PRSCQ←0; PTR.PRSWQ←1;
             BSET(@AR[0],0,6);
             AR[0]←PTR.PRUN1; AR[1]←PTR.PRUN2;
             AR[2]←PTR.PRDK; AR[3]←PTR-RESM;
          UNPROTECT(PRO1);
          AR[4]←CRRDP;
          DIRECT'AMC'REQ(AR//CAL13:E,I);
          GOTO CAL11;
CAL12:    UNPROTECT(PRO1);
       ENDFOR;
       RETURN;
CAL13: PUNT('SWQ');

       END;

       PROGRAM RDTIME;
       INCLUDE PROFILE;
*
*  READ TIME CLOCKS
*
       DECLARE LONG LWT;
       FUNCTION RDTIME(P),MONITOR←210;
       RETURN PRCT IF P=1 OR P='CTC';
       REALTL(:LWT);
       RETURN LWT;

       END;

       PROGRAM SETPIW;
*
*  SET PIW BITS
*
          INCLUDE ICTD,FLS,PROFILE,RESMON,ERRD;
       DECLARE I,J,E,M,F;
       FUNCTION SETPIW(F,M),FRETURN,MONITOR←163;
       IF F=-1 DO;
          PIWE ← PIWE V' M A' N' RESPIW;
          RETURN;
       ENDIF;
       CKOFTAC(F,1,0//FRETURN);
       FRETURN M32 IF OFT[F]$TYPE#PROCT OR OFT[F]$OFTMOD=1;
       RDMIB2(F,0//FRETURN);
       CKOBTAC(F:E,I//FRETURN);
       J←MIBA[I]$PROCPRT;
       FRETURN M61 IF PRT[J]$PRUN1#MIBA[I]$PROCUN1 OR
         PRT[J]$PRUN2#MIBA[I]$PROCUN2;
       MIS1CALL(IWAKEUPC V' J,M A' N' RESPIW);
       RETURN;

          END;

        PROGRAM KLUDGE'DIO;
          INCLUDE SWPD, PROFILE;
          DECLARE ADDR, I, T, DAMMIT;
          DECLARE ARRAY NODE;
          DECLARE FIXED FIELD TSU'ST(17);

        ENTRY KDIO(NODE, ADDR), MONITOR ← 128;
          I ← @NODE[0];
*  MAKE DUMMY REFERENCE TO INSURE PAGE IS AVAILABLE AND READ-WRITE
          $ADDR ← DAMMIT ← $ADDR;
          .LDX ADDR, AAX, CXA, LSHA -11, STA T;
          I.SWCPA ← T; I.SWEPRT ← @PRT[PRTI]-RESM;
          TSUD.TSU'ST ← 0;
          DIRECT'AMC'REQ(NODE//VALUE PUNT('DIO'));
          WHILE TSUD.TSU'ST = 0 DO;
          ENDFOR;
          BCOPY(I,TSUD,18);
          RETURN;

        END;

        PROGRAM DO'POT'PIN;
          INCLUDE CHIOD, PROFILE;
          DECLARE LONG ARGS, INTEGER A1=ARGS$WD0, A2=ARGS$WD1;
          DECLARE LONG FIXED FIELD CARGS(CARG1$FDDISP);
       DECLARE DAMMIT;

        ENTRY DO'POT'PIN(A1, A2, POTFLG), FRETURN, MONITOR ← 129;
          CPUIT.CARGS ← ARGS;
          CPUIT.WD0 ← 1@LNO V' 1@RWCH V' (DOAPOT IF POTFLG ELSE DOAPIN)@CRT;
          ATTENTION(ATT3);
          RETURN DAMMIT ← CPUIT.VALU IF CPUIT.RWCH=0 WHILE 1;
        END;
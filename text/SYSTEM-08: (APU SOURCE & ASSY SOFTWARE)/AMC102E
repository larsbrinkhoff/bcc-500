AMCCD  IDENT;
       REM DEFNS, XFER VECTORS, AND DECLARATIONS COMPILING

*  TRANSFER VECTOR CODES FOR SWAPPER

*                         REQUEST   STARTUP   CLEANUP
*READ PROCESS                1;
*      CONTEXT BLOCK                   1         1
*      PAGE READ                       2         2

*WRITE PROCESS               3,1;
*      PAGE DIRTY                                7
*      PAGE CLEAN                                6

*DIRECT DRUM                 4         4         4;

*DIRECT DISK                 5         5         5;

*RESERVE PAGE                9;

*NEW PAGE                                        9;

*WRITE PAGE, PAGE DIRTY     10                   7;
*WRITE PAGE, PAGE CLEAN     10                   6;

*DRUM TO DISK TSFR          11;
*      DRUM READ                       3         3
*      CHECK UN ON DISK               11        11
*      WRITE ON DISK                  10        10

*WRITE UNIQUE NAME          12;
*      CHECK UN                       12        12
*      WRITE                          14        14

*DISK TO DRUM TSFR          13;
*      READ DISK                      13        13
*      READ DRUM                      17        17

*GET FREE PAGE              14;

*DESTROY PAGE               15;
*      CHECK UN ON DISK               15        15
*      DESTROY ON DISK                16        16
*      CHECK ON DRUM                   8         8

*      READ PAGE KLUDGE     18        18        18

*SEEK REQUEST               19        19        19

*CWRPR   EQU 3 WRITE PROCESS ONTO DRUM REQUEST;
*CWRPG   EQU 10 WRITE PAGE ONTO DRUM REQUEST;
*CRDK    EQU 11 REQUEST DRUM TO DISK TRANSFER;
$CDSDK   EQU 3;* DRUM START FOR DRUM TO DISK TRANSFER &
*               DRUM CLEANUP FOR DRUM TO DISK TRANSFER
CKSDKU   EQU 11;* DISK STARTUP FOR UN=0 CHECK ON DRUM-DISK TRANSFER &
*               DISK CLEANUP FOR UN=0 CHECK ON DRUM-DISK TRANSFER
$CKSDK   EQU 10;* DISK STARTUP FOR DRUM-DISK TRANSFER (WRITE)
*               DISK CLEANUP FOR DRUM-DISK TRANSFER (WRITE)
*CRWUN   EQU 12 REQUEST TO WRITE UNIQUE NAME;
*CKSWU   EQU 12 DISK START FOR WRITE UNIQUE NAME (UN = 0);
*               DISK CLEANUP FOR WRITE UNIQUE NAME (UN = 0)
$CKSWU0  EQU 14;* DISK START FOR WRITE UNIQUE NAME
*               DISK CLEANUP FOR WRITE UNIQUE NAME
*CRKD    EQU 13 REQUEST FOR DISK-DRUM TRANSFER;
CDSKD    EQU 17;* DRUM START FOR DISK-DRUM TRANSFER
*               DRUM CLEANUP FOR DISK-DRUM TRANSFER
$CKSKD   EQU 13;* DISK START FOR DISK-DRUM TRANSFER
*               DISK CLEANUP FOR DISK-DRUM TRANSFER
CRDDT    EQU 4;* REQUEST FOR DIRECT DRUM TRANSFER
*CDSDDT  EQU 4 DRUM START FOR DIRECT DRUM TRANSFER;
*               DRUM CLEANUP FOR DIRECT DRUM TRANSFER
*CRDKI   EQU 5 REQUEST FOR DIRECT DISK TRANSFER;
*CKSDKI  EQU 5  DISK START FOR DIRECT DISK TRANSFER;
*               DISK CLEANUP FOR DIRECT DISK TRANSFER
CRRDP    EQU 1;* REQUEST TO READ PROCESS
*CDSRCB  EQU 1 DRUM STARTUP FOR READ CB;
*               DRUM CLEANUP FOR READ CB
CDSRPR   EQU 2;* DRUM START FOR READ PROCESS PAGE
*               DRUM CLEANUP FOR READ PROCESS PAGE
*CRGFP   EQU 14 GET FREE PAGE REQUEST;
CDNPG  EQU 9;*  CLEANUP CODE FOR NEW PAGE REQUEST
*CRDEST  EQU 15 REQUEST TO DESTROY PAGE;
CDSDET   EQU 8;* DRUM START FOR DESTROY PAGE
CDCDET   EQU 8;* DRUM CLEANUP FOR DESTROY PAGE
$CKSDET  EQU 15;* DISK START FOR DESTROY PAGE (UN CHECK)
*               DISK CLEANUP FOR DESTROY PAGE (UN CHECK)
$CKSDE0  EQU 16;* DISK START FOR DESTROY PAGE (UN = 0)
*               DISK CLEANUP FOR DESTROY PAGE (UN=0)
CDSEEK EQU 19;*  SEEK REQUEST
$LREQ  EQU 21;* LAST REQUEST

*  AMC FIELD DEFINITIONS
*  CHT FIELDS
UN0    FLDPK 0,0,23;*       UNIQUE NAME
UN1    FLDPK 1,0,23;*       UNIQUE NAME
DKA    FLDPK 2,2,23;*       DISK ADDRESS
DB     FLDPK 3,0,0;*         DIRTY BIT
DKWR   FLDPK 3,1,1;*       DISK WRITE IN PROGRESS
RDIP   FLDPK 3,3,3;*       READ IN PROGRESS
RDER   FLDPK 3,4,4;*       READ ERROR FIELD
WRIP   FLDPK 3,5,5;*       WRITE IN PROGRESS
INCORM EQU RDIPM+DKWRM;*      INCORE MASK
CPA    FLDPK 3,6,12;*       CORE PAGE ADDRESS
LOCK   FLDPK 3,13,15;*     PAGE LOCK
SCH    FLDPK 3,16,23;*      SCHEDULED COUNT
FCLP   DF 4,6,23;*      FREE CORE LIST POINTER
CLP    DF 5,6,23;*       COLLISION POINTER


*  DHT FIELDS
DMA    FLDPK 0,2,23;*      DRUM OR DISK ADDRESS IN DHT
ONDK   FLDPK 1,0,0;*       CLEAN ON DISK
ONDR   FLDPK 1,1,1;*       PAGE HAS BEEN WRITTEN ON DRUM
WUN    FLDPK 1,2,2;*       WRITE UNIQUE NAME WHEN TRANSFERRIN TO DISK
DKD    FLDPK 1,3,7;*       DEST,KDT,KDT FIELD
DEST   FLDPK 1,3,3;*       PAGE BEING DESTROYED
KDT    FLDPK 1,4,4;*       DISK TO DRUM TRANSFER IN PROGRESS
DKT    FLDPK 1,5,5;*        DRUM TO DISK TRANSFER IN PROGRESS
UNDCK  FLDPK 1,6,6;*     CHECK UNIQUE NAME ONLY ON DISK
HDRER  FLDPK 1,7,7;*      HARD DRUM ERROR ON READ FOR DESTROY
*                             PAGE
UCNT   FLDPK 1,14,23;*    USE COUNT FIELD
UCOVF  FLDPK 1,13,13;*         USE COUNT OVERFLOW


*  REQUEST NODE FIELDS
*  UNIQUE NAME AND DISK ADDRESS DEFINED BY CHT
WAKF   FLDPK 3,0,1;*        WAKEUP FIELD
ERRCNT DF 3,2,5;*     ERROR COUNT
EPRT   FLDPK 3,6,23;*      PRT POINTER TO PROCESS
ECWS   FLDPK 4,0,5;*       CWS INDEX
WDCNT  DF 4,0,5;*      WORD COUNT FOR DIRECT I/O
*PGAD  DF 4,6,12;*      PAGE ADDRESS FOR DIRECT I/O
LNODE  FLDPK 4,13,13;*    LEAVE NODE ON QUEU FOR DIRECT I/O
TIM    DF 4,14,15;*      TIMING FOR DIRECT I/O
DUMP   FLDPK 4,16,16;*     DUMP INFORMATION FOR DIRECT I/O
RCVR  FLDPK 4,17,17;*     RECOVER INFORMATION FOR DIRECT I/O
RCD    FLDPK 4,18,23;*      REQUEST CODE FOR DISPATCHERS
IDCODE FLDPK 5,0,3;*     ID CODE FOR TSU INSTRUCTION
INSTN  FLDPK 5,0,5;*      TSU INSTRUCTION FOR DIRECT I/O
EQP    FLDPK 5,6,23;*       QUEUE POINTS

*  DISK AND DRUM ADDRESS FIELDS
KTSUN  DF 2,2,3;*      DISK TSU IN NODE
DTSU   FLDPK 0,3,4;*       DRUM TSU
TRACK  DF 2,4,11;*    DISK TRACK IN NODE
KBAND  DF 2,12,17;*   DISK BAND IN NODE
DBAND  FLDPK 0,10,16;*    DRUM BAND
KSECT  FLDPK 2,18,21;*    DISK SECTOR IN NODE
DSECT  FLDPK 0,17,21;*    DRUM SECTOR
DSECTN DF 2,17,21;*   DRUM SECTOR IN NODE
DDEV   FLDPK 0,10,21;*     DRUM DEVICE NO.
KUNIT  DF 2,22,23;*   DISK UNIT IN NODE
DUNIT  FLDPK 0,22,23;*    DRUM UNIT


*  PRT DEFINITIONS
PRSW   EQU 5;
PRST   EQU 8;
$AMCW  EQU 4B5;*  WAKUP WORD FOR AMC

ACT    FLDPK 2,0,0;
CBE    DF 2,1,1;
SWERW  FLDPK 4,0,23;*          AMC ERROR WORD IN PRT
ERRCD  FLDPK PRSW,0,5;*        ERROR CODE SLOT IN PRT
DTC    FLDPK PRSW,16,23;
PRSTW  FLDPK PRST,0,23;
PGF    FLDPK PRST,11,11;
WAQ    FLDPK PRST,13,13;
CBC    FLDPK PRST,14,14;
PDW    FLDPK PRST,15,15;
PQ     FLDPK PRST,16,16;
SWQ    FLDPK PRST,17,17;
LDD    FLDPK PRST,20,20;
DTC0   EQU 200B;


*  CWS,PMT FIELDS
APTDWS DF 0,12,12;
CWS    FLDPK 0,13,13;
NPG    FLDPK 0,14,14;
PMTI   FLDPK 0,16,23;
SF     FLDPK 3,12,12;
CCE    DF 3,13,13;
HERR   DF 3,14,14;

*  AMC FAIL RETURNS TO CPU

CPWAIT EQU 1;* TELL CPU TO WAIT, COME BACK LATER
$UNER  EQU 2;* UNIQUE NAME ALREADY EXISTS
DKINU  EQU 3;* DISK ADDRESS IN USE
NINDHT EQU 4;* NOT IN DHT
DNCHT  EQU 5;* DISK ADDRESS DID NOT COMPARE IN CHT
WAITWK EQU 6;* WAIT FOR WAKE-UP
DKRAS  EQU 7;* DISK ADDRESS REASSIGNED
HERDR  EQU 8;* HARD ERROR ON DRUM READ
SERDR  EQU 9;* SOFT ERROR FROM DRUM
$HERDK EQU 10;* HARD ERROR ON DISK
$UNERK EQU 11;* UNIQUE NAME ERROR ON DISK AFTER DRUM COMPARED
$SERDK EQU 12;* SOFT ERROR ON DISK READ
$ARQOB EQU 13;* ACTIVATE REQUEST OUT OF BOUNDS
NOREQ  EQU 14;* NO REQUEST NODE
NCHT   EQU 15;* NO CHT ENTRY
SCHOVF EQU 16;* SCHEDULED COUNT OVERFLOW
PRTRBL EQU 17;* PROCESS IN TROUBLE
$LPRERR EQU PRTRBL;*                   NO OF PROC ERR RETURNS IN COUNTER
LAMCER EQU 11B;*                       NO OF AMC ERRORS IN COUNTER

*  RESIDENT CORE LOCATIONS

ACTL   EQU 100B;*   ACTIVATE LOCATION
ACTQ   EQU 102B;*   ACTIVATE QUEUE
SWAPRQ EQU 104B;*   GENERAL REQUEST QUEUE
SWAPIN EQU 106B;*   REQUEST QUEUE FOR SWAPPING PROCESSES
$RIPQ  EQU 114B;*   READ IN PROGRESS QUEUE
CTXQ   EQU 116B;*   CONTEXT BLOCK QUEUE
WRTQ   EQU 120B;*   WRITE QUEUE
NFREL  EQU 123B;*   NUMBER ON FREE REQUEST ENTRY LIST
$DKCLQ EQU 126B+4;* DISK CLEANUP QUEUE
DRCLQ  EQU 126B;*   DRUM CLEANUP QUEUE
$DKSLB EQU 136B;*   DISK SECTOR LIST BASE
$NKTER EQU 152B;*   LOC. FOR COUNTING NKT ERRORS
NCTX   EQU 153B;*   LOC. FOR COUNTING NO. OF CB'S CONSIDERED
$NPR   EQU 154B;*   LOC. FOR COUNTING NO. OF PROC. SWAPPING
DSRLB  EQU 155B;*   DRUM SECTOR READ LIST BASE
$DFBTB EQU 156B;*   DRUM FREE BIT TABLE BASE
KCQB   EQU 160B;*   DISK CYLINDER QUEUE BASE
LKCQ   EQU 161B;*     LAST DISK CYLINDER QUEUE
DIOQ   EQU 162B;*   DIRECT I/O RETURN QUEUE
*STAPUFLAG EQU 164B;*  FAST STARTUP: 0, OTHERWISE -1
NSWPG  EQU 165B;*   NUMBER OF SWAP PAGES IN CORE
NPGQ   EQU 166B;*              NEW PAGE QUEUE
NDMPG  EQU 170B;*    NUMBER OF FREE DRUM PAGES 
DIOLK  EQU 171B;*    DIRECT I/O DUMP LOCK
LOCKCTR EQU 172B;*  USED BY MONITOR TO COUNT LOCKED PAGES
$CNTA  EQU 177B;*   ARRAY TO COUNT STARTUPS AND ACTIVATE ERRORS
$PRERRA EQU CNTA+LREQ+LPRERR+LAMCER;*  ARRAY OF COUNTS OF ERRORS REPORTED
*                                TO PROCESS
*  TSUD FORMERLY WAS AT 3100B--MOVED TO ACCOMMODATE CHIO SCRATCHPADS
TSUD   EQU 3200B;*   SYSTEM TSU DUMP LOCATIONS
$PRTB  EQU 302B;*    LOC. FOR BASE ADDRESS OF PRT
REL    EQU 64000B;*           BASE ADDRESS OF AMCCD

*  COUNTERS
*  CNTA IS ONE INDEXED AND BEGINS AT 200B
*  THE FIRST BLOCK IS STARTUP COUNTS
* 200:  1 - CONTEXT BLOCK
* 201:  2 - PAGE READ (BOTH CONTEXT AND PROCESS PAGE)
* 202:  3 - DRUM READ FOR DRUM TO DISK TRANSFER
* 203:  4 - DIRECT DRUM TRANSFER
* 204:  5 - DIRECT DISK TRANSFER
* 205:  6 - WRITE FOR PAGE NOT ON DRUM
* 206:  7 - WRITE FOR DIRTY PAGE
* 207: 10 - CHECK ON DRUM FOR DESTROY PAGE
* 210: 11 - NOTHING
* 211: 12 - WRITE ON DISK FOR DRUM TO DISK TRANSFER
* 212: 13 - CHECK UN ON DISK FOR DRUM TO DISK TRANSFER
* 213: 14 - CHECK UN FOR WRITE UNIQUE NAME ON DISK
* 214: 15 - READ DISK FOR DISK TO DRUM TRANSFER
* 215: 16 - WRITE FOR WRITE UNIQUE NAME
* 216: 17 - CHECK UN ON DISK FOR DESTROY PAGE
* 217: 20 - DESTROY ON DISK
* 220: 21 - READ DRUM FOR DISK TO DRUM TRANSFER
* 221: 22 - READ PAGE KLUDGE
* 222: 23 - PAGE FAULT READ
* 223: 24 - PAGE FAULT WRITE
* 224: 25 - PAGE FAULT WAKEUP


*  THE NEXT BLOCK OF COUNTERS ARE FOR COUNTING ACTIVATE ERROR RETURNS
*  IT BEGINS AT 225B
* 225:  1 - WAIT CPU
* 226:  2 - UNIQUE NAME ALREADY EXISTS
* 227:  3 - DISK ADDRESS IN USE
* 230:  4 - NOT IN DHT
* 231:  5 - DISK ADDRESS DID NOT COMPARE IN CHT
* 232:  6 - WAIT FOR WAKE-UP
* 233:  7 - DISK ADDRESS REASSIGNED
* 241: 13 - ACTIVATE REQUEST OUT OF BOUNDS
* 242: 14 - NO REQUEST NODE
* 243: 15 - NO CHT ENTRY
* 244: 16 - SCHEDULED COUNT OVERFLOW
* 245: 17 - PROCESS IN TROUBLE


*  THE NEXT BLOCK OF COUNTERS ARE FOR COUNTING 'AMC' ERRORS
*  IT BEGINS AT 246B
* 246:  1 - REGISTER LOADING VIOLATIONS
* 247:  2 - TAG FIELD ERROR
* 250:  3 - DATA TRANSFER LATE ERRORS (RATE ERRORS)
* 251:  4 - DRUM POLICY VIOLATIONS
* 252:  5 - DRUM READ ERRORS - CHECK CODE NOT ZERO
* 253:  6 - TOTAL DEVICE ERRORS - READ & WRITE
* 254:  7 - TOTAL HARD ERRORS
* 255: 10 - REDO WRITE FOR ANY REASON
* 256: 11 - RESTART CLEANUP DUE TO AMC & TSU OUT OF SYNC


*  THE NEXT BLOCK OF COUNTERS ARE FOR COUNTING THE NUMBER OF ERRORS
*  SENT TO A PROCESS.  IT BEGINS AT 257B.
*  SEE LIST OF ERRORS FOR INDICES


*  TSU DUMP DEFINITIONS FOR CLEANUP

TSUDMP EQU 100B-18D;* TSU REG. DUMP ON CLEANUP
$CLNQC EQU TSUDMP;* TSU CLEANUP QUEUE
TSUNC  EQU TSUDMP+1;*  TSU NO. IN SELECT POS.
$INSTC EQU TSUDMP+2;*  INSTRUCTION REG.
DEVADR EQU TSUDMP+4;*    DEVICE ADDRESS
$UN1C  EQU TSUDMP+7;*  CLASS CODE 1 REG.
$UN0C  EQU TSUDMP+8;*  CLASS CODE 0 REG.
HUNIT  EQU TSUDMP+9;*    HOLDING UNIT 
$STATC EQU TSUDMP+17;* STATUS REG.


*  VARIOUS SWAPPER PARAMETERS

$PAGESZ EQU 4000B;*  PAGE SIZE
$NKSECT EQU 5;*      NUMBER OF DISK SECTOR QUEUES
$MCTX   EQU 1;*     MAX. NO. OF CB'S TO BE CONSIDERED
$MNPR   EQU 1;*   MAX. NO. OF PROCESSES TO BE CONSIDERED
$CWSDSP EQU 2751B;* CWS BASE
$PMTDSP EQU 300B-4;*  PMT BASE
$SZPRTE EQU 12;* SIZE OF PRT ENTRY
NDUNIT EQU 2;* NUMBER OF DRUM UNITS
ACTDU  EQU 1;*    LAST ACTIVE DRUM UNIT
ZRBAND EQU 5000B;*;*                     ZERO BAND FOR NEW PAGE REQUEST
LBUF   EQU 7770B;*                     END OF ERROR BUFFER
$HERST EQU 2216B;* 13,16,20,21,22 HEADER NOT EQUAL
*                              EXCESSIVE TIME CONSUMED
*                              DRUM PLICY VIOLATION
*                              DRUM PLICY VIOLATION
*                              DEVICE NOT AVAILABLE
*                              REGISTER LOADING VIOLATION
COPYFG EQU 4B7;
STKCQ  EQU 2B7;


*  TSU PARAMETERS
$TSPC0 EQU 1B4;*   POSITION COUNTER 0 OF TSU
$PCHCL EQU 1B7;*   HOLDING REGISTER WAITING FOR CLEANUP
$TSRLV EQU 2;*;*  REGISTER LOADING VIOLATION
$TSDTL EQU 20B;*   DATA TRANSFER LATE
$TSCNE EQU 400B;*  CLASS CODE NOT EQUAL
$TSCN0 EQU 100B;*  CHECK CODE NOT ZERO
$TSDPE EQU 1000B;* DEVICE PARITY ERROR
$TSDPV EQU 10B;* DRUM POLICY VIOLATION
KTSU   EQU 4B6;*   DISK TSU NUMBER FOR TSU SELECT REGISTER
TSCVF  EQU 4B6;*               TSU CYLINDER VERIFIED BIT 

       FREEZE;

*  AMC TRANSFER VECTOR

START  PUNT; BRU GENRQ; BRU ACTRQ;
       BRU RDDRUM; BRU STNPG; BRU TSUCL;
       BRU RQRD; BRU RQCB; BRU CPDKCL;
       BRU DKSTART; BRU WRPGS;


       VARD QKRDT;*            TEMPS FOR QUEUE ROUTINES
$SECTP  ZRO 0;*                   SECTOR POSITION FOR UNIT
$CUNIT  ZRO 0;*                   CURRENT UNIT
$KIDSEQ ZRO;* ID CODE SEQUENCE NUMBER
       VARD $TEMP,$TEMPA,I;
       VARD $PMTBAS,$FRENODE,$NRDQUE;* READ,WRITE PROCESS
$DKCQPT ZRO;*  DISK CYLINDER QUEUE ROTATION POINTER
$CBADD ZRO;* CONTEXT BLOCK ADDRESS
$CHTCB  ZRO;* CONTEXT BLOCK CHT ADDRESS
$SFCNT  ZRO;* SCHEDULED FLAG COUNT
$NDRTRY ZRO;*   NUMBER OF DRUM TRYS
$WRPGT ZRO;* SAVE DRUM ADDRESS
$TRY3TM BSS 1;
$WRTCNT BSS 1;
$DSRLHD ZRO;*  DSRL HEADER SET BY QDRD
$SEEKST BSS 4;*                 SEEK STARTED, ONE FLAG FOR EACH UNIT
$SEEKPT BSS 4;*                 LAST SEEK POSITION


       IF *-START>=100B-18; REM ***  STACK ERROR;
       ENDF;
       BSS 100B+START-*;*  STORAGE FOR TSU REGISTERS FOR THE CLEANUP


*STACK AREA;
       ZRO 6000B; BSS 8;


$CLRSTR DATA -1;*                       BIT TABLE FOR CLEAR SECTORS
$BFPT  ZRO 7676B;*                     BEGINNING OF ERROR BUFFER

*  GENERAL REQUEST AND ACTIVATE TRANSFER VECTORS

*  VECTOR INITIALIZED FOR NORMAL AMC,  HOWEVER BY 
*  CHANGING FOUR CELLS, ONE CAN CONVERT TO DRUM AMC.
*  CHANGE THE FOLLOWING TRANSFER VECTOR CELLS FOR ACTIVATE REQUESTS:
*      ZRO RDKT,4              TO      ZRO DMRDKT,4
*      ZRO RWUN,4              TO      ZRO DMRWUN,4
*      ZRO RKDT,4              TO      ZRO DMRKDT,4
*      ZRO RQDEST,4            TO      ZRO DMRDST,4
*  THIS MAY BE DONE BY MEANS OF THE FLAG DRMAMC=1.

DRMAMC EQU     1               SET FOR DRUM AMC AT PRESENT

$GRQTV EQU *;
$ARQTV ZRO GENRQ1,4; ZRO WRPROC,4; ZRO GENRQ1,4;
       ZRO WRPROC,4; ZRO RDDIO,4; ZRO RDKIO,4;
$MAGRQ EQU *-ARQTV-1;*         MAX GENERAL REQ
       ZRO PNT,4; ZRO PNT,4; ZRO PNT,4;
*  ACTIVATE REQUESTS
$MIARQ EQU *-ARQTV-1           MIN ACTIVATE REQ -1;
       ZRO RQRSP,4; ZRO RQRP,4;

       IF DRMAMC=1

       ZRO DMRDKT,4; ZRO DMRWUN,4
       ZRO DMRKDT,4; ZRO GETFP,4; ZRO DMRDST,4;

       ELSE

       ZRO RDKT,4; ZRO RWUN,4;
       ZRO RKDT,4; ZRO GETFP,4; ZRO RQDEST,4;

       ENDF

       ZRO PNT,4; ZRO PNT,4; ZRO RDPG,4;
$MAARQ EQU *-ARQTV-1;*           MAX ACTIVATE REQ


*  TSU STARTUP TRANSFER VECTOR

$TVECDS ZRO PNT,4; ZRO GCCB,4; ZRO GCPG,4; ZRO GCDK,4;
       ZRO DSDDT,4; ZRO KSDKI,4; ZRO PNT,4;
       ZRO PNT,4; ZRO GCDS,4; ZRO PNT,4;
*  DISK START
       ZRO KSDK,4; ZRO KSCHUN,4; ZRO KSCHUN,4; ZRO KSKD,4;
       ZRO KSWU0,4; ZRO KSCHUN,4; ZRO KSDE0,4; ZRO GCKD,4;
       ZRO SRDPG,4;
$MAKSRQ EQU *-TVECDS-1;*          MAX DISK START REQ


*  TSU CLEANUP TRANSFER VECTOR

$CLTV  ZRO PNT,4; ZRO DCCB,4; ZRO DCPRD,4; ZRO DCDK,4;
       ZRO DCDDT,4; ZRO KCDKI,4; ZRO DCWR,4;
       ZRO DCWR,4; ZRO DCDES,4; ZRO CLNPG,4;
*  DISK CLEANUP
       ZRO KCDK,4; ZRO KCDKU,4; ZRO KCWU,4; ZRO KCKD,4;
       ZRO KCWW,4; ZRO KCDS,4; ZRO KCDSW,4; ZRO DCKD,4;
       ZRO CRDPG,4; ZRO CSEEK,4;
$MACLRQ EQU *-CLTV-1;*            MAX CLEANUP REQ


*  PUNT INSTRUCTION FROM THE TRANSFER VECTOR
PNT    PUNT;

*  TELL CPU TO WAIT, COME BACK LATER
$CPWTE  ECNT CPWAIT; LDI CPWAIT; BRU FRACT;
*  UNIQUE NAME ALREADY EXISTS
$UNERE  ECNT UNER; LDI UNER; BRU FRACT;
*  DISK ADDRESS IN USE
$DKINE  ECNT DKINU; LDI DKINU; BRU FRACT;
*  NOT IN DHT
$NIDHE ECNT NINDHT; LDI NINDHT; BRU FRACT;
*  DISK ADDRESS DID NOT COMPARE IN CHT
$DNCHE ECNT DNCHT; LDI DNCHT; BRU FRACT;
*  WAIT FOR WAKEUP
$WAITE ECNT WAITWK; LDI WAITWK; BRU FRACT;
*  ACTIVATE REQUEST OUT OF BOUNDS
$ARQBE ECNT ARQOB; LDI ARQOB; BRU FRACT;
*  DISK ADDRESS REASSIGNED
$DKRAE  ECNT DKRAS; LDI DKRAS; BRU FRACT;
*  NO REQUEST NODE
NORQE  ECNT NOREQ; LDI NOREQ; BRU FRACT;
*  NO CHT ENTRY
$NCHTE  ECNT NCHT; LDI NCHT; BRU FRACT;
*  SCHEDULED COUNT OVERFLOW
SCHOVE ECNT SCHOVF; LDI SCHOVF; BRU FRACT;


*  FAILURE AND SUCCESS RETURN ACTIVATES

$FRACT LDB =4B7; BRU CACT;
$SRACT CLAB;
CACT   UPR 17B; STA ACTL+1,4; STB ACTL,4;
*  CHECK WHETHER NODE HAS TO BE RELEASED
       CSB EPTR; SKB =-1; CALL SETFL; RET;


$REACT LDB =ACTQ; CALL RTEQP,Z; BRU NORQE; CBX; MDC NFREL,4; BVR 1;


       NOLIST EXT,GO;

       END;

BMCCD  IDENT;
       REM 1ST THIRD OF CODE COMPILING;

*  RELEASE CHT, DHT ENTRIES

$RLDCHT CSX EPTR; BSL DCHTE; NOP;
$RLDHT CSX EPTR; LDA DKAD,6; CALL DHTSCH,Z; BVR 1;
       LDA ONDRD,6; SKNA =ONDRM; BRU RLDHT0;
       LDA DMAD,6; LSR3 =-1; SCALL CSFDPT; MIN NDMPG,4;
RLDHT0 CSX EPTR; LDA DKAD,6; CALL DDHT,Z; PUNT; BVR 1;

*  ENTER ENTRY INTO CHT
*  B - POINTER TO CHT ENTRY
*  X - POINTER TO NODE CONTAINING UN AND DISK ADDRESS
*  SRETURN IF UN NOT 0
*  B - PTR TO CHT ENTRY
*  SKUN0 - UN0
*  SKUN1 - UN1

$ECHTE LDI 1; STF RDIP; STF SCH;
$ECHTE1 CBS SR0; LDA 0,6; LDB 1,6; LEW2 2,6;
*  TEST UN0 FOR 0
       SKNA =-1; BRU ECHTE3;
ECHTE2 CSX SR0; CALL ECHT; CSB SR1; BVR 2;
*  UN0 IS 0, TEST UN1
ECHTE3 SKB =-1; BRU ECHTE2; BVR 1;


*  DELETE CHT ENTRY AND PUT ON FREE LIST
*  X = POINTER TO UNIQUE NAME AND DISK ADDRESS
*  SKIP RETURN IF IN CHT

$DCHTE SCALL INCOR,FA0; BVR 1;
*  DISK ADDRESSES COMPARE, DELETE CHT ENTRY, ETC
$DCHT1 SKA =SCHM; CLRMAP;
DCHT2  LDB =77B6; SCALL DCHT+2; CALL CCHTE; CALL PPFCL; BVR 2;


*  DESTROY PAGE DELETE CHT ENTRY
*  CHTPT - PTR TO CHT ENTRY
$DESCHT CSX CHTPT; SCALL INCOR,FA0; BVR 1; BRU DCHT2;


*  TEST PAGE DIRTY OR NOT ON DRUM
*  SKIP IF NOT DIRTY AND ON DRUM (COMPLETELY CLEAN)
*  DHTPT HAS TO POINT TO DHT ENTRY, CHTPT TO CHT ENTRY
$PGDOND CSX CHTPT; LDA DBD,6; SKA =DBM; BVR 1;
       CSX DHTPT; LDA ONDRD,6; SKA =ONDRM; BVR 2; BVR 1;


*  RETURN FROM APU CODE

$RETURN UPR 17B; CSB EPTR; SKB =-1; CALL SETFL; RET;
$RET1  UPR 17B; RET;


*  REMOVE GENERAL REQUEST
$REGRQ LDB =SWAPRQ; CALL RTEQP,Z; BRU RET1; UPR 17B; CBX; 
       MDC NFREL,4; BVR 1;


*  REMOVE REQUEST FROM CLEANUP QUEUE
$RECLQ LDB CLNQC; CALL RTEQP,Z; PUNT; CBX; BVR 1;

*  CLEANUP READ ROUTINE, REMOVES ENTRY FROM QUEUE, CHECKS FOR IN CORE,
*  RETURNS:
*  CHTPT - PTR TO CHT ENTRY
*  CLEARS RIDP BIT IN CHT STATUS
*  A - CONTAINS STATUS WORD OF CHT
$CLQICR LDB CLNQC; CALL RTEQP,Z; PUNT; CBX; SCALL INCOR,FA0; PUNT;
       CXS CHTPT; ETR =@INCORM; STA SCHD,6; BVR 1;


*  QUEUE READ REQUEST ON DSRL
*  NO SKIP-NOT IN DHT, ONE SKIP-NOT ON DRUM, TWO SKIPS-READ QUEUED
*  A=REQUEST CODE, B=POINTER TO UNIQUE NAME AND DISK ADDRESS (NODE)
$QDRD  STF RCD;
$QDRD1 LDF DKA; STB FRENODE; CALL DHTSCH,Z; BVR 1;

*  ALTERNATE ENTRY POINT
*  X - POINTER TO DHT2
*  FRENODE - PTR TO NODE
$QDRD2 CXB; LDA ONDRD,6;
*  STATE WHEN SKIP RETURN OCCURS
*  X,B - CONTAIN PTR TO DHT2
*  FRENODE - CONTAIN POINTER TO NODE
       SKNA =ONDRM; BVR 2;
       LDF DSECT; SKL =24; LDI 23; LCY 1; ADD DSRLB,4; STA DSRLHD;
       LDB FRENODE; CALL AELEQP; BVR 3;


*  QUEUE DISK READ
*  A=REQUEST CODE, B=POINTER TO NODE

$QKRD  STF RCD;
$QKRD1 LDF TRACK; 
$QKRD2 SKL =256; LDI 255; ADD KCQB,4; CAX; LDA 0,6;
       STF EQP; STB 0,6; CSA FLAGRG; ETR =@STKCQ; CAS FLAGRG; 
       LKCQCNT =-256; BVR 1;

*  PUT ENTRY ON DISK SECTOR LIST

$QKSL  ISK NKT;
$QKSLNI LDF KSECT;
QKSL0  SKL =NKSECT; LDI NKSECT-1; LCY 1; ADD =DKSLB; CALL AELEQP; BVR 1;

*  REMOVE ENTRIES FROM DISK CYLINDER QUEUE

$CPDKCL SKEL* DKCQPT; BRU CPD1;
CPD0   MIN DKCQPT; LDA LKCQ,4; SKL DKCQPT; RET;
CPD5   LDA KCQB,4; STA DKCQPT; RET;
*  FOUND A CYLINDER, COPY ALL REQUESTS OVER TO SECTOR QUEUES
CPD1   LDA DKCQPT; SKG LKCQ,4; SKGE KCQB,4; BRU CPD5; CAX;
*  NOP IN NEXT LINE PATCHES OUT SEEK LOGIC (REPLACES BRU CPD7)
       LDB 0,6; LDF KUNIT; XXA; SKP SEEKST,2; NOP; XXA
       LDF EQP; STA 0,6; LDF RCD; SKNE =CDSDK; BRU CPD4;
CPD6   BSL QKSLNI;
CPD2   ISK NKT; CSA FLAGRG; SNEL* DKCQPT; BRU CPD3;
       MRG =COPYFG; CAS FLAGRGF; RET;
*  FINISHED CYLINDER QUEUE, RESET FLAG
CPD3   ETR =@COPYFG; CAS FLAGRG; LDI -1; STA SEEKST; STA SEEKST+1; 
       BRU CPD0;

*QUEUE DRUM READ FOR DRUM-DISK TRANSFER;
CPD4   BSL QDRD1; PUNT; BRU *+2; BRU CPD2;
*  NOP IN NEXT LINE PATCHES OUT CHECKING (REPLACES LDI CKSDKU)
       LDB WUND,6; LDI CKSDK; SKB =WUNM; NOP; LDB FRENODE;
       STF RCD;
       LDX FRENODE; SCALL INCOR,FA0; PUNT; ADD =1; STA SCHD,6; 
       LDB FRENODE; BRU CPD6;


*  SEND SEEK INSTRUCTION
CPD7   STX TEMPA; LDA DKCQPT; SKNE SEEKPT,2; BRU CPD8;
       CBS EPTR; LDA =KTSU; CALL FSTR,Q; RET; CALL REFFL,Q; RET; 
       CSX EPTR; LDA DKAD,6; ETR =KSECTM; SUB =2*KSECT1; SKG =-1;
       ADD =NKSECT*KSECT1; STA TEMP; LDA DKAD,6; XXB; ETR =@KSECTM; 
       MRG TEMP; STA DKAD,6; LDI CDSEEK; STA RCDD,6; CXS EPTR; 
       BSL KSCHUN; PUNT; LDA DKCQPT; LDX TEMPA; 
CPD8   STA SEEKPT,2; STA SEEKST,2; BRU RET1;


*  RESERVE PAGE REQUEST

$RQRSP  BSL REACT; SCALL INCOR,FA0; BRU NCHTE; SKA =INCORM; BRU CPWTE;
       ADD =1; STA SCHD,6; BRU SRACT;



*  GET FREE PAGE REQUEST
*  EPTR=POINTER TO NODE

$GETFP  BSL REACT; SCALL INCOR,FA0; BRU GETFP1; SKA =RDIPM; BRU CPWTE;
       BRU UNERE;
GETFP1 CSA DKACMP; SKNA =4B7; BRU UNERE;
       CALL GFC,Q; BRU CPWTE; CBS CHTPT; CSB EPTR; LDF DKA; CAS DHT0;
       CLS DHT1; LDHT2 =WUN1+UCNT1; CALL EDHT,Z; BRU GETFP2;
       CSB CHTPT; LDI 1; STF SCH; CSX EPTR; BSL ECHTE1; PUNT; BRU SRACT;
GETFP2 LDI DKINU; LDB DKDD,6; SKB =DKDM; LDI CPWAIT; STA ACTL+1,4;
       SKB =DKDM; ECNT CPWAIT; SKNB =DKDM; ECNT DKINU;
       CSB CHTPT; CALL PPFCL; LDA ACTL+1,4; BRU FRACT;

*  REQUEST TO RELEASE PAGE TO DRUM
$RQRP   BSL REACT; SCALL INCOR,FA0; BRU SRACT; CXS CHTPT;
       SKA =SCHM; SUB =1; STA SCHD,6; SKA =SCHM+LOCKM; BRU SRACT;
       SKA =DBM; BRU RQRP1; LDA DKAD,6; CALL DHTSCH,Z; PUNT;
       LDA ONDRD,6; SKNA =ONDRM; BRU RQRP1;
       CSB CHTPT; CALL PPFCL; BRU SRACT;
*  PUT ON WRITE LIST
RQRP1  CSB EPTR; LDI WRTQ; CALL SELEQP; LDI 0; CAS EPTR; BRU SRACT;


*  REQUEST TO READ A PROCESS-CB READ

$RQCB   SNEL SWAPIN,4; RET; LDI MCTX; SKG NCTX,4; RET;
       LDB =SWAPIN; PRO 3; CALL RTEQP,Z; BRU RET1; CBS EPTR; MDC NFREL,4;
       LDF EPRT; CAX; LDA ACTD,6; SKNA =ACTM; BRU RETURN;
       LDA PRST,6; SKA =CBCM+PQM; BRU RETURN; CXS PRTPT;
       EOR =SWQM+CBCM; STA PRST,6; CXS SR0; CSB EPTR; LDX =3; CALL BCOPY;
       CSX EPTR; SCALL INCOR,FA0; BRU RQCB1; SKA =INCORM; BRU RQCB1;
       SKA =RDERM; BRU RQCB2; ADD =1; STA SCHD,6;
       CSB EPTR; LDI CTXQ; CALL AELEQP; MIN NCTX,4; BRU RET1;
RQCB1  CSB EPTR; BSL QDRD1; BRU RQCB2; BRU RQCB2; MIN NCTX,4; BRU RET1;
*  REPORT ERROR TO PROCESS NO. 1
RQCB2  BSL PRCER1; BRU RET1;

*  REQUEST TO READ A PROCESS (PAGE READ)

$RQRD   LDA NPR,4; SKL =MNPR; RET;
       LDB =CTXQ; CALL RTEQP,Z; RET; CBS EPTR;
       PRO 3; LDF EPRT; CAS PRTPT; CBX; CAB; LDI -1; STF PQ;
       SCALL INCOR,FA0; BRU RQRD10; SKA =INCORM; BRU RQRD11;
       STX CHTCB; ETR =CPAM; STA CBADD;
       ADD =CWSDSP+1; CAS CWSPT; ADD =PMTDSP-CWSDSP-1; STA PMTBAS;
       CSX PRTPT; LDA PRSTWD,6; SKA =LDDM; BRU RQRD9;
PFRD   CLA; STA NRDQUE; STA SFCNT;
*  AT THIS POINT BEGIN LOOP
*  CWSPT - CWS ADDRESS
*  PMTBAS - PMT BASE ADDRESS
*  PRTPT - PRT POINTER
*  PMTPT - PMT ADDRESS
*  FRENODE - ENTRY USED FOR READ QUEUEING
*  NRDQUE - NO. OF READS QUEUED = 0
*  CHTCB - POINTER TO CONTEXT BLOCK CHT ENTRY
*  CBADD - ABSOLUTE CORE ADDRESS OF CWS
*  SFCNT - SCHEDULED FLAG COUNT MUST BE LESS THAN NO. OF SWAP PAGES
RQRD0  MIN SFCNT; LDA NSWPG,4; SKG SFCNT; BRU RQRD7;
RQRD1  UPR 17B; DSK CWSPT; CSX CWSPT;
       LDA 0,6; SKNA =CWSM; BRU RQRD7; CAB;
       ETR =PMTIM; LCY 2; ADD PMTBAS; CAS PMTPT; CAX;
       LDA SFD,6; SKA =SFM; BRU RQRD0; SKB =NPGM; BRU NPAGE;
       SCALL INCOR,FA0; BRU RQRD2; SKA =INCORM; BRU RQRD12;
       ADD =1; STA SCHD,6; LDI 1; CSB PMTPT; STF SF; BRU RQRD0;
*  DISK ADDRESS COMPARE?
RQRD2  CSA DKACMP; SKNA =4B7; BRU RQRD4;
*  IN DHT
RQRD12 CSX PMTPT; LDA DKAD,6; CALL DHTSCH,Z; BRU RQRD3; CXS DHTPT;
       LDA DESTD,6; SKA =DESTM; BRU RQRD1;
*  FREE NODE
       CALL REFFL,Z; BRU RQRD5; STB FRENODE;
*  NOW COPY UN AND DISK ADDRESS FROM PMT
       CSS PMTPT,SR0; LDX =3; CALL BCOPY;
       CSX SR1; CSA PRTPT; STA EPRTD,6;
       CSA CWSPT; CNA; ADD CBADD; ADD =CWSDSP; LCY 18; MRG =CDSRPR;
       STA RCDD,6; CSX DHTPT; BSL QDRD2; PUNT; BRU RQRD6;
NPAG0  MIN NRDQUE; LDI 1; CSB PMTPT; STF SF; BRU RQRD0;
*  NOT IN DHT
RQRD3  CSB CWSPT; CLA; STF APTDWS; BRU RQRD1;
*  DISK ADDRESSES DO NOT COMPARE, SET CLASS CODE ERROR IN PMT
RQRD4 CSB PMTPT; LDI 1; STF CCE; BRU RQRD1;
*  NO FREE NODE
RQRD5  CSB EPTR; LDI CTXQ; CALL SELEQP; PRO 3;
       CSB PRTPT; LDF DTC; ADD NRDQUE;
       MRG =DTC0; STF DTC; BRU RET1;
*  COULD NOT QUEUE READ BECAUSE IT WAS NOT ON THE DRUM, FORGET THE READ
RQRD6  LDB FRENODE; CALL SETFL; BRU RQRD1;
*  ALL THROUGH, DIDDLE SOME BITS AND COUNTS AND PUT REQUEST ON 
*  READ IN PROGRESS QUEUE
RQRD7  LDB CHTCB; LDI -1; PRO 3; ADF SCH; STF DB;
       CSB PRTPT; LDF DTC; ETR =@DTC0;
       ADD NRDQUE; STF DTC; SKG =0; BRU RQRD8;
       MIN NPR,4; LDI 1; ZRF CBC;
       CSB EPTR; LDI RIPQ; CALL AELEQP; SKR NCTX,4; BRU RET1;
       LDI 0; STA NCTX,4; BRU RET1;
*  NO READS NECESSARY, SEND WAKEUP AND RELEASE NODE
RQRD8  LDI SWQM+CBCM+PQM; ZRF PRSTW; LDI 1; STF LDD; CLX; 
       PRO 13B; CALL WAKEUP;
       CLA; SNEL RIPQ,4; STA NPR,4; SKR NCTX,4; BRU RETURN;
       LDI 0; STA NCTX,4; BRU RETURN;
*  PROCESS ALREADY LOADED, FORGET READING THE PROCESS
RQRD9 LDB CHTCB; LDI -1; ADF SCH; BRU RQRD11;
*  CONTEXT BLOCK PAGE NOT IN CORE OR DISK ADDR DOES NOT COMPARE, LET
*  PROCESS 1 HANDLE IT, FORGET THE READ
$RQRD10 BSL PRCERR; BRU RET1;
*  DIDDLE BITS AND FORGET PROCESS READ
RQRD11  CSB PRTPT; PRO 3; BSL ZPRTS;
       SKR NCTX,4; BRU RETURN; LDI 0; STA NCTX,4; BRU RETURN;

*  NEW PAGE REQUEST
NPAGE  SCALL INCOR,FA0; BRU *+2; BRU RQRD4;
       CSA DKACMP; SKNA =4B7; BRU RQRD4; CALL REFFL,Z; BRU RQRD5;
       STB FRENODE; CSB PMTPT; LDF DKA; CAS DHT0; CLS DHT1;
       LDHT2 =WUN1+UCNT1; CALL EDHT,Z; BRU NPAG1;
       LDB FRENODE; CSS PMTPT,SR0; LDX =3; CALL BCOPY;
       LDX FRENODE; CSA PRTPT; STA EPRTD,6;
       CSA CWSPT; CNA; ADD CBADD; ADD =CWSDSP; LCY 18;
       MRG =CDNPG; STA ECWSD,6;
       LDI NPGQ; CXB; CALL AELEQP; BRU NPAG0;
*  PAGE ALREADY IN DHT, FREE NODE AND SET CCE ERROR
NPAG1  LDB FRENODE; CALL SETFL; BRU RQRD4;


*  WRITE PROCESS ONTO DRUM REQUEST

$WRPROC BSL REGRQ; SCALL INCOR,FA0; BRU RETURN; SKA =INCORM; BRU WRPRC5;
       STB CHTCB; ETR =CPAM; STA CBADD;
       ADD =CWSDSP+1; CAS CWSPT; ADD =PMTDSP-CWSDSP-1; STA PMTBAS;
       CSB EPTR; LDF EPRT; CAS PRTPT; CAX; PRO 3; CAB;
       LDA PRST,6; SKA =PQM+LDDM; BRU WRPRC6;
       SKA =PDWM; BRU WRPRC1; SKA =PGFM; BRU PGFLT;
WRPRC0 LDI 1; STF PDW; ZRF PGF; LDB CHTCB; ADF SCH;
*  CHTCB - CHT CONTEXT BLOCK PTR
*  CBADD - CONTEXT BLOCK ADDRESS
*  CWSPT - ABSOLUTE CWS ADDRESS
*  PMTBAS - ABSOLUTE PMT BASE
*  PMTPT - ABSOLUTE PMT ADDRESS
*  PRTPT - PRT POINTER FOR PROCESS
WRPRC1 UPR 17B; DSK CWSPT; CSX CWSPT;
       LDA 0,6; SKNA =CWSM; BRU WRPRC3;
       SKA =NPGM; BRU WRPRC1;
       ETR =PMTIM; LCY 2; ADD PMTBAS; CAS PMTPT; CAX;
       LDA SFD,6; SKNA =SFM; BRU WRPRC1; EOR =SFM; STA SFD,6;
       SCALL INCOR,FA0; BRU WRPRC1; SKA =SCHM; SUB =1; STA SCHD,6;
       SKA =LOCKM+SCHM; BRU WRPRC1; CBS CHTPT; SKA =DBM; BRU WRPRC2;
       LDA DKAD,6; CALL DHTSCH,Z; PUNT; LDA ONDRD,6; SKNA =ONDRM;
       BRU WRPRC2; CSB CHTPT; CALL PPFCL; BRU WRPRC1;
*  PAGE DIRTY OR NOT ON DRUM, CHECK IF ON WRITE LIST
WRPRC2 CSX PMTPT; LDI WRTQ-5; BSL SCHLST; BRU WRPRC1;
       CALL REFFL,Z; BRU WRPRC4; CSS CHTPT,SR0; LDX =3; CALL BCOPY;
       CSB SR1; LDI WRTQ; CALL SELEQP; BRU WRPRC1;
*  ALL THROUGH, DIDDLE SOME BITS AND QUEUE THE CONTEXT BLOCK
WRPRC3 LDB CHTCB; LDI -1; PRO 3; ADF SCH; CSB PRTPT; ZRF PDW; CSB EPTR;
       LDI WRTQ; CALL SELEQP; RET;
*  NO FREE NODE, RETURN CURRENT PAGE TO ITS INITIAL STATE(?)
WRPRC4 CSB CHTPT; LDI 1; ADF SCH; CSB PMTPT; STF SF;
*  STACK REQUEST ON INPUT QUEUE
WRPRC5 RQS 1; CSB EPTR; LDI SWAPRQ; PRO 2; CALL SELEQP; BRU RET1;
*  PAGE COMING INTO CORE, TERMINATE WRITE
WRPRC6 SKNA =PDWM; BRU RETURN; CLA; STF PDW;
       LDB CHTCB; LDI -1; ADF SCH; BRU RETURN;

*  PAGE FAULT LOGIC
*  THE MONITOR WILL SET BIT 11 (PGF) IN THE PROCESS STATE WORD
*  AND BLOCK FOR A PAGE FAULT.  THE AMC WILL THE LOOK AT
*  ITS INTERNAL STATE AND DECIDE IF IT WILL READ IN THE PROCESS OR
*  WRITE IT OUT.  CURRENTLY THIS IS DECIDED BY DETERMINING IF A PROCESS
*  IS CURRENTLY COMING IN TO CORE.
PGFLT  SKA =WAQM; BRU WRPRC0; LDA NPR,4; SKL =MNPR; BRU PGFL0;
       LDI 1; STF CBC; ZRF PGF; LDB CHTCB; ADF SCH; CNT 23B; MIN NCTX,4;
       BRU PFRD;
*  STACK REQUEST ON SWAPIN QUEUE AND WRITE OUT
PGFL0  CALL REFFL,Z; BRU PGFL1; CSS EPTR,SR0; LDX =4; CALL BCOPY;
       CSX SR1; LDI 1; STA RCDD,6; CSB PRTPT; STF SWQ; CXB;
       LDI SWAPIN; PRO 2;
       CALL SELEQP; RQS 1; CSB PRTPT; CNT 24B; BRU WRPRC0;
*  NO FREE NODE, SEND WAKEUP AND WRITE PROCESS OUT
PGFL1  CSB PRTPT; CLX; PRO 13B; CALL WAKEUP;
       CSB PRTPT; CNT 25B; BRU WRPRC0;


*  REQUEST FOR DRUM TO DISK TRANSFER

RDKT   BSL REACT; LDA DKAD,6; CALL DHTSCH,Z; BRU NIDHE; CXS DHTPT;
       LDA DKDD,6; SKA =DKDM; BRU CPWTE; SKNA =ONDKM; BRU RDKT1;
       CSX EPTR; SCALL INCOR,FA0; BRU RDKT0; SKA =INCORM+DBM; BRU RDKT1;
*  DO NOT TRANSFER, DECREMENT USE COUNT
       CXS CHTPT; CSX DHTPT; LDA UCNTD,6; SKA =UCNTM; SUB =1; STA UCNTD,6;
       SKA =UCNTM; BRU SRACT;
*  USE COUNT IS ZERO, DELETE?
       CSX CHTPT; LDA SCHD,6; SKNA =SCHM+LOCKM; BSL RLDCHT; BRU SRACT; 

*  NOT IN CHT OR DISK ADDRESS DOES NOT COMPARE
RDKT0  CSA DKACMP; SKNA =4B7; BRU DNCHE; 
RDKT1  LDI CDSDK; CSB EPTR; BSL QKRD; LDA =DKTM;
SDHSTS CSX DHTPT; ADM DKTD,6; LDI 0; CAS EPTR; BRU WAITE;


*  (DRUM) REQUEST FOR DRUM TO DISK TRANSFER
$DMRDKT BSL REACT; LDA DKAD,6; CALL DHTSCH,Z; BRU NIDHE; CXS DHTPT;
       BRU SRACT;



*  REQUEST FOR DISK TO DRUM TRANSFER

RKDT   BSL REACT; LDA DKAD,6; 
       CAS DHT0; CLS DHT1; LDHT2 =ONDK1+KDT1+UCNT1;
       CALL EDHT,Z; BRU RKDT1; CSB EPTR; CSS DHT1,EPTR; BSL QKRD1;
       BRU WAITE;
RKDT1  CXS DHTPT; LDA DKDD,6; SKA =DKDM; BRU CPWTE;
       CSX EPTR; SCALL INCOR,FA0; BRU RKDT2; SKA =INCORM; BRU RKDT3;
       LDI 1; CSB DHTPT; ADF UCNT; BRU SRACT;

*  DISK ADDRESS COMPARE?
RKDT2  CSA DKACMP; SKNA =4B7; BRU DNCHE;
RKDT3  CSB EPTR; LDI CDSKD; STF RCD; STB FRENODE; CSX DHTPT; 
       BSL QDRD2; PUNT; BRU DKRAE; LDA =KDTM; BRU SDHSTS;


*  (DRUM) REQUEST FOR DISK TO DRUM TRANSFER
$DMRKDT BSL REACT; LDA DKAD,6; CALL DHTSCH,Z; BRU DKRAE; BRU SRACT;


*  REQUEST TO DESTROY PAGE

RQDEST BSL REACT; SCALL INCOR,FA0; BRU RQDE1; SKA =INCORM; BRU RQDE2;
       SKA =WRIPM+LOCKM; BRU CPWTE; 
       LDA DKAD,6; CALL DHTSCH,Z; BRU RQDE2; LDA DKDD,6; 
       SKA =DKDM; BRU CPWTE; MRG =DESTM; STA DKDD,6; CSX EPTR; 
       BSL DCHTE; PUNT;
RQDE0  CSA EPTR; CLS EPTR; CAB; BSL QKRD1; BRU WAITE;
RQDE1  CSA DKACMP; SKNA =4B7; BRU DNCHE;
RQDE2  CSB EPTR; LDF DKA; CAS DHT0; CLS DHT1; LDHT2 =DEST1+UNDCK1;
       CALL EDHT,Z; BRU *+2; BRU RQDE0; CXS DHTPT; LDA  DKDD,6;
       SKA =DKDM; BRU CPWTE; SKNA =ONDRM; BRU CPWTE; 
       CSB EPTR; STB FRENODE; LDI CDSDET; STF RCD;
       BSL QDRD2; PUNT; PUNT; LDA =DESTM; BRU SDHSTS;


*  (DRUM) REQUEST TO DESTROY PAGE
$DMRDST BSL REACT; BSL RLDCHT; BRU SRACT;


TIMS DATA 0,6,12,18;

*  REQUEST FOR DIRECT DRUM I/O

$RDDIO  BSL REGRQ; LDF TIM; CAX;
$RWUN5  LDF DSECTN; ADD TIMS,2;
       SKL =24; SUB =24;
       SKL =24; LDI 23; LCY 1;
       ADD DSRLB,4;
       CALL AELEQP; BRU RET1


TIMSK DATA 0,64,128,192;

*  REQUEST FOR DIRECT DISK I/O

$RDKIO  BSL REGRQ;
       LDF TIM; CAX;
*  PATCH IN NEXT LINE SUBSTITUES QKSL FOR QKRD2--HAS TO DO W/ DIO
       LDF TRACK; ADD TIMSK,2; SKL =256; SUB =256; BSL QKSL; BRU RET1;


       NOLIST EXT,GO;

       END;

CMCCD  IDENT;
       REM 2ND THIRD OF CODE COMPILING;

*  REQUEST TO WRITE UNIQUE NAME

RWUN   BSL REACT; SCALL INCOR,FA0; BRU *+2; BRU UNERE; CSA DKACMP;
       SKNA =4B7; BRU UNERE; CLS DHT1;
       CSB EPTR; LDF DKA; CAS DHT0;
       LDHT2 =DKTM; CALL EDHT,Z; BRU RWUN0;
*  THINK THE NEXT LINE HAS A BUG FIXED--QKRD REPLACING QKRD1
       CSB EPTR; CSS DHT1,EPTR; LDI 14; BSL QKRD; BRU WAITE;
RWUN0  LDA DKDD,6; SKA =DKDM; BRU CPWTE; BRU DKINE;


*  (DRUM) REQUEST TO WRITE UNIQUE NAME

$DMRWUN BSL REACT; SCALL INCOR,FA0; BRU *+2; BRU UNERE; CSA DKACMP;
       SKNA =4B7; BRU UNERE; LDI ACTDU; STA CUNIT; LDI 23; STA SECTP;
RWUN3  LSR1 SECTP; LSR2 CUNIT; SCALL FBFDPT,FA0; BRU RWUN4; CAS DHT1;
       CSB EPTR; LDF DKA; CAS DHT0; LDHT2 =ONDRM; CALL EDHT,Z; BRU RWUN2;
       CSA DHT1; CLS SR3; SCALL CSFDPT; MDC NDMPG,4;
       ECNT WAITWK; LDI WAITWK; STA ACTL+1,4; LDB =4B7; STB ACTL,4;
       CSX EPTR; CSA DHT1; STA DKAD,6; LDI CRDDT+RCVRM; STA RCDD,6;
       LDA =10B*INSTN1; STA EQPD,6; CXB; CLX; BRU RWUN5;
RWUN2  LDA DKDD,6; SKA =DKDM; BRU CPWTE; BRU DKINE;
RWUN4  SKR SECTP; BRU RWUN3; LDI 23; STA SECTP; SKR CUNIT; BRU RWUN3; PUNT;


*  GET COMMAND OFF DSRL (GENERAL)

MRDRM  CSX SELUNIT; LDS SR5,=GTDV0; CALL FRET,Q;
$RDDRUM CXA; CBS EPTR; SKLE =MAKSRQ; PUNT;
RDDRM0 BSL* TVECDS,2; BRU RDDRM1; LDI 1; STA NDRTRY; BRU RETURN;
$RETSR1 EQU *-RDDRM0; LDI 1; STA NDRTRY; BRU RET1;
RDDRM1 LDS SR5,=STDRUM; SKR NDRTRY; CALL FRET; BRU RETSR1+RDDRM0;
$TRNPWT EQU *-RDDRM0; LDS SR5,=NOREAD; CALL FRET;

*  WRITE PAGE ONTO DRUM

$WRPGS  CSX SELUNIT; CLA; CALL FSTR,Q; BRU WRPG6; 
       CAS SR1; CSS SELUNIT,SR2;
       SCALL FBFDPT,FA0; BRU WRPG6; SKNE WRPGT; BRU RET1; STA WRPGT;
       LDB =WRTQ; CALL RTEQP,Z; RET; CBS EPTR;
       CBX; SCALL INCOR,FA0; BRU RETURN; SKA =WRIPM+SCHM+LOCKM; BRU RETURN;
       CXS CHTPT; STA TEMP;
       LDA DKAD,6; CALL DHTSCH,Z; BRU RETURN; CXS DHTPT; LDA DESTD,6;
       SKA =DESTM; BRU RETURN; ETR =@ONDKM; CAB; SKN TEMP; BRU WRPG7;
WRPG1  CSX CHTPT; LDA TEMP; MRG =WRIPM; ETR =@DBM; STA DBD,6;
       SKN TEMP; BRU WRPG3; CSX DHTPT; STB ONDKD,6; CNT 7;
WRPG3  CLRMAP; UPR 2; SKN TEMP; CNT 6;
       CSX EPTR; SIDSEQ IDCODD,6; LDI 6; SKP TEMP; LDI 7; STA RCDD,6;
       LDA WRPGT; CSB CHTPT; LDX =40B; SCALL EXEC;
       LDI DRCLQ; CSB EPTR; CALL AELEQP; BRU RET1;

*  INCREMENT WRITE UNIT AND TRY AGAIN
WRPG6  ISK SELUNIT; 
       CSA SELUNIT; SKL =3; SKR WRTCNT; SKL =NDUNIT; CLS SELUNIT; 
       SKI WRTCNT; BRU WRPGS; LDI -NDUNIT; STA WRTCNT; BRU RET1;
WRPG7  SKA =ONDRM; BRU RETURN; BRU WRPG1;


*  STARTUP FOR NEW PAGE
$STNPG  CSX SELUNIT; CLA; CALL FSTR,Q; BRU STNP1; STA SECTP;
       CAX; LDA CLRSTR; LCY 0,2; SKNA =4B7; BRU STNP1;
       LDB =NPGQ; CALL RTEQP,Z; PUNT; CBX; CBS EPTR;
       SCALL INCOR,FA0; BRU STNP2;
*  ERROR, SET CCE, RESET SF, WAKE PROCESS, FREE NODE
STNP0  BSL SFOFF; BRU *+2; STF CCE; BSL WKLD;
STNP1  UPR 17B; LDB =-1; RET;
*  CHECK DISK ADDRESS NOT COMPARE FLAG
STNP2  CSA DKACMP; SKNA =4B7; BRU STNP0;
       CSX EPTR; LDA DKAD,6; CALL DHTSCH,Z; BRU STNP0;
       LDA DESTD,6; SKA =DESTM; BRU STNP0;
       CALL GFC,Q; BRU STNP3; CSX EPTR; BSL ECHTE; PUNT;
       LDA SECTP; LCY 2; MRG =ZRBAND; SSELUNIT TEMP; MRG TEMP; 
       CSX EPTR; SIDSEQ IDCODD,6; CLX; SCALL EXEC; 
       LDI DRCLQ; CSB EPTR; CALL AELEQP; CLB; UPR 17B; RET;
*  PUT NODE BACK ON NPGQ, AND RETURN
STNP3  LDI NPGQ; CSB EPTR; CALL SELEQP; BRU STNP1;




*  GET COMMAND OFF DSRL (DRUM-DISK TRANSFER)
*  B - NODE POINTER

$GCDK  LDF DKA; CALL DHTSCH,Z; PUNT; 
       CXS DHTPT; CSX EPTR; SCALL INCOR,FA0; BRU GCDK2; CXS CHTPT;
       SKA =INCORM; BRU RQREAD; SKA =DBM; BRU GCDK1; 
       CSX DHTPT; LDA ONDKD,6; SKNA =ONDKM; BRU GCDK1;
       SKNA =UCNTM-1; BRU GCDK0;
*  ENTRY FOR CLEANUP ROUTINE
$DCDK0 SUB =1; 
*  ENTRY FOR DISK-DRUM ROUTNINE
GCKD0  ETR =@DKDM; STA ONDKD,6; BRU KWAKP;

*  ON DISK AND USE COUNT <=1, FORGET WRITE
GCDK0  CSX CHTPT; LDA SCHD,6; SKA =SCHM+LOCKM; BRU RSDKD;

*  RELEASE CHT,DHT, DO DISK WAKEUP BELOW
$KRLWK BSL RLDCHT; BRU KWAKP;

*  DISK ADDRESS COMPARE ERROR, REPORT  ERROR AND WAKE PROCESS, FORGET
*  READ
KCERR LDI DNCHT;
$RDERR BSL RPERP;

*  RESET DKD FIELD, WAKE PROCESS, FORGET READ
$RSDKD  LDI 0; CSB DHTPT; STF DKD;

*** DECREMENT NKT ***, WAKE PROCESS, FORGET READ
$KWAKP DSK NKT; BSL WAKEPR; CSB EPTR; CALL SETFL; BVR 1;

*  REQUEUE NODE AND DO ANOTHER STARTUP IF ANOTHER NODE ON QUEUE
RQREAD CSB EPTR; STB FRENODE; CSX DHTPT; BSL QDRD2; PUNT; PUNT;
DAREAD CSA EPTR; SKE* DSRLHD; BRU *+2; BVR TRNPWT; LDA* DSRLHD; BVR 1;

*  PAGE NOT ON DISK OR DIRTY, WRITE ON DISK
GCDK1  CSB CHTPT; LDI 1; ADF SCH; CSX DHTPT; LDB WUND,6; 
*  ENTER TO QUEUE DK TRANSFER
*  PATCH TO NEXT LINE REPLACES NOP FOR SKNB =WUNM
$KQDKQ LDI CKSDKU; NOP =WUNM;
*  ENTER TO QUEUE DK TRANSFER
$KQDKT LDI CKSDK;
*  ENTER TO QUEUE DISK TRANSFER
$KQDKT0 CSB EPTR; STF RCD; BSL QKSLNI; BVR 1;

*  DISK ADDRESS COMPARE?
GCDK2  CSX DHTPT; LDA ONDRD,6; SKNA =ONDRM; PUNT;
       CSA DKACMP; SKNA =4B7; BRU KCERR; CNT CDSDK;
*  FALL THROUGH TO DO READ

*  COMMON LOGIC TO DO READS FROM DRUM
*  ENTER FREE CORE ENTRY FOR DRUM READ

$NDRRD CALL GFC,Q; BRU NDRD0; CSX EPTR; BSL ECHTE; PUNT; UPR 2;
       CSX EPTR; SIDSEQ IDCODD,6; CSX DHTPT; LDA DMAD,6; CLX;
       SCALL EXEC; LDI DRCLQ; CSB EPTR; CALL AELEQP; BVR RETSR1;
$NDRD0 RQS 1; CSB EPTR; BSL QDRD1; PUNT; PUNT;
       BRU DAREAD;


*  DRUM START FOR DIRECT DRUM TRANSFER

*  B - PTR TO NODE
$DSDDT LDF WDCNT; CAX; LDI 1; LCY 0,2; STA TEMP;
       CBX; LDA 2,6; CAS SR2; ETR =DUNITM; STA TEMPA;
       CSA SR2; ETR =DTSUM; CAS SR0;
       LDF INSTN; LCY 2; MRG TEMPA; MRG =77B6; CAS SR1;
       LDA 4,6; ETR =CPAM; CAS SR3;
       LDA UN0D,6; LDB UN1D,6; LDX TEMP; SCALL STSUI; CNT CRDDT;
       CSB EPTR; LDI DRCLQ; CALL AELEQP; BVR RETSR1;


*  DISK START FOR DIRECT I/O

$KSDKI LDF WDCNT; CAX; LDI 1; LCY 0,2; STA TEMPA;
       CBX; LDF KUNIT; STA TEMP;
       LDF INSTN; LCY 2; MRG TEMP; MRG =77B6; CAS SR1;
       LDA 4,6; ETR =CPAM; CAS SR3;
       LDF KTSUN; LCY 19; MRG =2*DTSU1; CAS SR0;
       LDF TRACK; LCY 14; STA TEMP; LDF KBAND;
       LCY 7; ADM TEMP; LDF KSECT; LCY 2; MRG TEMP; CAS SR2;
       LDA UN0D,6; LDB UN1D,6; LDX TEMPA; SCALL STSUI; CNT 5;
       CSB EPTR; LDI DKCLQ; CALL AELEQP; BVR RETKS1;


*  GET COMMAND OFF DSRL (READ FOR DESTROY PAGE)

$GCDS LDF DKA; CALL DHTSCH,Z; PUNT; LDA ONDRD,6; CXS DHTPT;
       SKNA =ONDRM; PUNT; CSX EPTR; SCALL INCOR,FA0; BRU GCDS0;
       SKA =INCORM; BRU RQREAD; BSL DCHT1; PUNT; CSB EPTR; LDI CKSDET; 
       BSL QKRD; BVR 1;
*  DISK ADDRESS COMPARE?
GCDS0  CSA DKACMP; SKNA =4B7; BRU *+3; CNT CDSDET; BRU NDRRD;

*  DISK ADDRESS BAD
       CSX EPTR; LDA UN0D,6; LDB UN1D,6; CALL CHTSCH,Z; PUNT;
       CXS CHTPT;
       BSL PGDOND; BRU GCDS1; CSB CHTPT; CALL PPFCL;
GCKD1  ISK NKT; BRU KCERR;
*  PAGE NEEDS WRITING (DISK ADDRESS IN NODE NOT USED)
GCDS1  LDI WRTQ; CSB EPTR; CALL SELEQP; LDI DNCHT; BSL RPERP;
*  RESET MAGIC DHT BITS, WAKE PROCESS, RETURN
$RSDKWK CSB DHTPT; LDI 0; STF DKD; BSL WAKEPR; BVR 1;

*  GET COMMAND OFF DSRL (DISK-DRUM TRANSFER)

$GCKD  LDF DKA; CALL DHTSCH,Z; PUNT; LDA ONDRD,6; SKNA =ONDRM; PUNT;
       CXS DHTPT; CSX EPTR; SCALL INCOR,FA0; BRU GCKD2; 
       SKA =INCORM; BRU RQREAD;
*  PAGE ALREADY IN CORE, INCREMENT USE COUNT
$DCKD0 CSX DHTPT; LDA UCNTD,6; ADD =1; SKA =UCOVFM; PUNT; ISK NKT;
       BRU GCKD0;
*  DISK ADDRESS COMPARE?
GCKD2  CSA DKACMP; SKNA =4B7; BRU GCKD1; CNT CDSKD; BRU NDRRD;



*  GET COMMAND, PAGE READ
$GCPG  CBX; SCALL INCOR,FA0; BRU GCPG3; SKA =INCORM; BRU GCPG1;

       ADD =1; STA SCHD,6;
GCPG0  BSL WKLD; BVR 1;

*  NOT IN CORE YET - REQUEUE
GCPG1  CSB EPTR; BSL QDRD1; BRU GCPG2; BRU GCPG2; BRU DAREAD;
GCPG2  BSL SFOFF; BRU GCPG0; STF CCE; BRU GCPG0;

*  NOT IN COR OR NOT IN CHT
GCPG3  CSA DKACMP; SKNA =4B7; BRU GCPG2;
*  NOT IN CORE, FIND DHT ENTRY
       CSX EPTR; LDA DKAD,6; CALL DHTSCH,Z; BRU GCPG4; CXS DHTPT;
       LDA DESTD,6; SKNA =ONDRM; BRU GCPG2; SKA =DESTM; BRU GCPG1;
       CNT CDSRPR; BRU NDRRD;
GCPG4  BSL SFOFF; BRU GCPG0; BRU GCPG0;


*  GET COMMAND, CONTEXT BLOCK READ

$GCCB  SKEL CTXQ,4; BRU GCCB0; 
       CBX; SCALL INCOR,FA0; BRU GCCB1; SKA =INCORM; BRU GCCB0;
       SKA =RDERM; BRU GCCB2; ADD =1; STA SCHD,6;
       LDI CTXQ; CSB EPTR; CALL AELEQP; CNT CRRDP; BVR RETSR1;

*  NOT IN CORE YET, REQUEUE
GCCB0  CSB EPTR; BSL QDRD1; BRU GCCB2; BRU GCCB2; BRU DAREAD;

*  NOT IN CORE OR NOT IN CHT
GCCB1  CSA DKACMP; SKNA =4B7; BRU GCCB2;
*  NOT IN CHT
       CSX EPTR; LDA DKAD,6; CALL DHTSCH,Z; BRU GCCB2; CXS DHTPT;
       LDA DESTD,6; SKNA =ONDRM; BRU GCCB2; SKA =DESTM; BRU GCCB0;
       CNT CRRDP; BRU NDRRD;

*  CONTEXT BLOCK IN A BAD WAY, REPORT TO PROCESS 1
GCCB2  BSL PRCERR; BVR 1;

*  DRUM WRITE CLEANUP

$DCWR  BSL RECLQ; SCALL INCOR,FA0; BRU DCWR7; CBS CHTPT;
       ETR =@WRIPM; STA WRIPD,6; SKA =DBM; BRU DCWR2;
       BSL ERRCK; BRU DCWR0; PUNT; BRU DCWR1; BRU DCWR1;
       LDA DEVADR; CLS SR3; SCALL CSFDPT; MDC NDMPG,4; CSX CHTPT; 
       LDA DKAD,6; CALL DHTSCH,Z; PUNT; LDA DEVADR; XMA DMAD,6; LDB ONDRD,6;
       SKNB =ONDRM; BRU DCWR4; LSR3 =-1; SCALL CSFDPT; MIN NDMPG,4;
DCWR3  CSB CHTPT; CALL PPFCL; BRU RETURN;
DCWR4  CBA; MRG =ONDRM; STA ONDRD,6; BRU DCWR3;
*  TRY THREE TIMES
DCWR0  BSL DCWR5; BRU RSCLUP;
*  SOFT OR HARD ERROR
DCWR1  BSL DCWR5; BRU RET1;
*  DIRTY AGAIN
DCWR2  BSL DCWR6; BRU RET1;
*  SET DIRTY BIT TO PREVIOUS VALUE
DCWR5  CSX EPTR; LDA RCDD,6; CSB CHTPT; STF DB; ERCNT 10B;
*  REQUEUE WRITE
DCWR6  LDI WRTQ; CSB EPTR; CALL SELEQP; LDI -1; STA WRPGT; BVR 1;
DCWR7  LDI -1; STA WRPGT; BRU RETURN;


*  CLEANUP FOR NEW PAGE

$CLNPG BSL CLQICR; LDA DKAD,6; CALL DHTSCH,Z; BRU CNPG2;
       LDA DESTD,6; SKA =DESTM; BRU CNPG2;
       CSX EPTR; LDA 0,6; STA UN0C; LDA 1,6; STA UN1C;
       BSL ERRCK; BRU CNPG0; PUNT; BRU CNPG1; BRU CNPG1;
       CSB EPTR; BSL GPMT; BRU *+4; LDI 1; CXB; ZRF NPG;
       BSL WKLD; BRU RET1;
*  TRY THREE TIMES
CNPG0  LDI NPGQ; CSB EPTR; CALL SELEQP; BRU RSCLUP;
*  SOFT ERROR, HARD ERROR
CNPG1  CSB CHTPT; LDI 1; STF RDER; BSL WKLD; BRU RET1;
*  NOT IN DHT OR BEING DESTROYED
CNPG2  BSL DESCHT; BSL SFOFF; BSL WKLD; BRU RET1;

*  DRUM CLEANUP FOR DRUM-DISK TRANSFER

$DCDK  BSL CLQICR; LDA DKAD,6; CALL DHTSCH,Z; PUNT; CXS DHTPT;
       BSL ERRCK; BRU DRSCL; BRU DCDK4; BRU DCDK5; BRU DCDK6;
       CSX DHTPT; LDA ONDKD,6; SKA =ONDKM; BRU DCDK2; CAB;
       BSL KQDKQ; BRU RET1;

*  ON DISK, DECREMENT USE COUNT, ETC.
DCDK2  SKNA =UCNTM; BRU DCDK3; BSL DCDK0;
       CSX CHTPT; LDA SCHD,6; SKA =SCHM; SUB =1; STA SCHD,6;
       CXB; CALL PPFCL; BRU RET1;
*  PAGE NOT IN USE, DELETE ON DRUM
DCDK3  BSL KRLWK; BRU RET1;
*  UNIQUE NAME ERROR
DCDK4  LDI DKRAS; BRU DCDK7;
*  SOFT ERROR
DCDK5  LDI SERDR; BRU DCDK7;
*  HARD ERROR
DCDK6  LDI HERDR;
DCDK7  BSL RDERR; CSX CHTPT; BSL DCHTE; PUNT; BRU RET1;


*  DRUM CLEANUP FOR CB READ

$DCCB  BSL CLQICR; LDA DKAD,6; CALL DHTSCH,Z; BRU DCCB2;
       LDA DESTD,6; SKA =DESTM; BRU DCCB1;
       BSL ERRCK; BRU DCCB0; BRU DCCB2; BRU DCCB2; BRU DCCB2;
       LDI CTXQ; CSB EPTR; CALL AELEQP; BRU RET1;
*  TRY THREE TIMES
DCCB0  CSX EPTR; BSL DCHTE; PUNT;
       CSB EPTR; BSL QDRD1; BRU DCCB2; BRU DCCB2; BRU RSCLUP;
*  BEING DESTROYED
DCCB1  BSL DESCHT; CSB EPTR; BSL QDRD1; BRU DCCB2; BRU DCCB2; BRU RET1;
*  REPORT ERROR TO PROCESS 1
DCCB2  CSB EPTR; LDF EPRT; CAS PRTPT; BRU RQRD10;

*  DRUM CLEANUP FOR PROCESS READ

$DCPRD BSL CLQICR; LDA DKAD,6; CALL DHTSCH,Z; BRU DCPR2;
       LDA DESTD,6; SKA =DESTM; BRU DCPR1;
       BSL ERRCK; BRU DRSCL; BRU DCPR2; BRU DCPR2; BRU DCPR5;
DCPR0  BSL WKLD; BRU RET1;
*  PAGE BEING DESTROYED
DCPR1  BSL DESCHT; BRU DCPR3;
*  NOT IN DHT OR UNIQUE NAME ERROR
DCPR2  CSX EPTR; BSL DCHTE; PUNT;
*  RESET SF, SET CCE
DCPR3  BSL SFOFF; BRU DCPR0; STF CCE; BRU DCPR0;
*  SOFT ERROR, SET READ ERROR STATUS IN CHT ENTRY
DCPR4  CSB CHTPT; LDI 1; STF RDER; BRU DCPR0;
*  HARD ERROR, DELETE CHT ENTRY
DCPR5  CSX EPTR; BSL DCHTE; PUNT; BSL SFOFF; BRU DCPR0; STF HERR; 
       BRU DCPR0;


*  DRUM CLEANUP FOR DISK-DRUM TRANSFER

$DCKD  BSL CLQICR; SKA =SCHM; SUB =1; STA SCHD,6; CALL PPFCL;
       CSX CHTPT; LDA DKAD,6; CALL DHTSCH,Z; PUNT; CXS DHTPT;
       BSL ERRCK; BRU DRSCL; BRU DCKD3; BRU DCKD5; BRU DCKD4;
DCKD2  BSL DCKD0; BRU RET1;
*  UN ERROR
DCKD3  LDI DKRAS; BRU *+2;
*  HARD ERROR
DCKD4  LDI HERDR; ISK NKT; BSL RDERR; CSX CHTPT; BSL DCHTE; PUNT;
       BRU RET1;
*  SOFT ERROR, UN OK, ACCEPT PAGE ON DRUM
DCKD5  CSX EPTR; BSL DCHTE; PUNT; BRU DCKD2;


*  DRUM CLEANUP FOR DESTROY PAGE

$DCDES BSL CLQICR; LDA DKAD,6; CALL DHTSCH,Z; PUNT; CXS DHTPT;
       CSX EPTR; BSL DCHTE; PUNT; 
       BSL ERRCK; BRU DRSCL0; BRU DCDS1; BRU DCDS0; BRU DCDS2;
*  PUT DESTROY COMMAND ON DISK CYLINDER QUE (SOFT ERROR OK)
DCDS0  CSB EPTR; LDI CKSDET; BSL QKRD; BRU RET1;
*  UN ERROR
DCDS1  ISK NKT; LDI DKRAS; BSL RDERR; BRU RET1;
*  HARD ERROR, SET BIT IN DHT, AND READ DISK
DCDS2  CSB DHTPT; LDI 1; STF HDRER; BRU DCDS0;

*  DISK CLEANUP FOR DIRECT I/O

$KCDKI BSL RECLQ; LDA RCVRD,6; SKNA =RCVRM; BRU KCKI0;
       BSL DIERR; BRU KRSCL; BRU KCKI2; PUNT; BRU KCKI1;
KCKI0  DSK NKT; BRU DCDD0;
*  HARD ERROR
KCKI1  LDI HERDK; BSL RPERP; BRU KCKI0;
*  UN ERROR
KCKI2  LDI UNERK; BSL RPERP; BRU KCKI0;


*  DRUM CLEANUP FOR DIRECT I/O

$DCDDT BSL RECLQ; LDA RCVRD,6; SKNA =RCVRM; BRU DCDD0;
       BSL DIERR; BRU DCDD4; BRU DCDD5; PUNT; BRU DCDD3;
DCDD0  CSX EPTR; LDA DUMPD,6; SKNA =DUMPM; BRU DCDDT1;
       LSR0 =REL+TSUDMP; LDB =TSUD; LDX =18; CALL BCOPY; CSX EPTR;
DCDDT1 LDA LNODED,6; SKNA =LNODEM; BRU DCDDT2; CXB;
       LDA STATC; STF INSTN; RCY 6; STF WDCNT;
       MIN NFREL,4; LDI DIOQ; PRO 2; CALL AELEQP; BSL WAKEPR; BRU RET1;
DCDDT2 BSL WAKEPR; BRU RETURN;
*  HARD ERROR
DCDD3  LDI HERDR; BSL RPERP; BRU DCDD0;
*  RETRY
DCDD4  CSB EPTR; LDF DSECTN; SKL =24; LDI 23; LCY 1; ADD DSRLB,4;
       CALL AELEQP; BRU RSCLUP;
DCDD5  LDI UNER; BSL RPERP; BRU DCDD0;


*  DISK START-UP FOR UNIQUE NAME CHECK FOR THE FOLOWING:
*  DRUM - DISK TRANSFER
*  WRITE UNIQUE NAME
*  DESTROY PAGE

$KSCHUN BSL KCOM; CLEAR; BRU STDISK;


       NOLIST EXT,GO;

       END;

DMCCD  IDENT;
       REM LAST THIRD OF CODE COMPILING;

*  DISK START-UP FOR DRUM-DISK TRANSFER (WRITE PAGE)

$KSDK  CBX; SCALL INCOR,FA0; BRU KSDK0; SKA =WRIPM; BRU RQKT;
       SKA =INCORM; BRU KSDK1; SKNA =LOCKM+SCHM-27B; MRG =DKWRM; 
       STA SCHD,6; SKA =SCHM-1; CLRMAP; CBS CHTPT;
       CSX EPTR; LDA DKAD,6; CALL DHTSCH,Z; PUNT; CXS DHTPT; 
       BSL KCOM; CSX CHTPT; LDA CPAD,6; ETR =CPAM; CAS SR3;
*  PATCH TO NEXT LINE DISABLES DISK SYSTEM WXO CHECK
*      (REPLACES MRG =100B BY NOP)
       CSX DHTPT; LDB WUND,6; CSA SR1; MRG =40B; SKNB =WUNM; NOP
       CAS SR1; CSA SKUN0; CSB SKUN1; LDX =PAGESZ; CNT CKSDK; BRU STDISK;
*  DISK ADDRESS COMPARE?
KSDK0  CSA DKACMP; SKNA =4B7; PUNT;
*  REQUEUE DRUM READ
KSDK1  LDI CDSDK; CSB EPTR; BSL QDRD; PUNT; BRU *+2; BVR RETKS1;
*  NOT ON DRUM, MUST BE IN CORE!
       LDI CKSDK; CSB EPTR; STF RCD;
*  FALL THROUGH TO QUEUE ON DISK
*  REQUEUE DISK TRANSFER
RQKT   CSB EPTR; BSL QKSLNI; BVR RETKS1;


*  DISK STARTUP FOR WRITE UNIQUE NAME 

$KSWU0 BSL KCOM; CSA SR1; MRG =40B; CAS SR1;
       CSX EPTR; LDA 0,6; LDB 1,6; LDX =1; CNT CKSWU0; BRU STDISK;


*  DISK STARTUP FOR DESTROY PAGE (WRITE UN = 0)

$KSDE0 BSL KCOM; CSA SR1; MRG =40B; CAS SR1;
       CLAB; LDX =1; CNT CKSDE0; BRU STDISK;


*  DISK STARTUP FOR DISK-DRUM TRANSFER

$KSKD  CBX; SCALL INCOR,FA0; BRU KSKD0;
       LDA DKAD,6; CALL DHTSCH,Z; PUNT; CXS DHTPT; DCSTK; BRU QWRT;
KSKD0  CSA DKACMP; SKNA =4B7; BRU KSKD1; CALL GFC,Q; BRU RQKT;
       CSX EPTR; BSL ECHTE1; PUNT; LDI 1; STF RDIP;
       LDF CPA; LCY 11; CAS SR4; BSL KCOM; CSS SR4,SR3;
       CSA SKUN0; CSB SKUN1; LDX =PAGESZ; CNT CKSKD; BRU STDISK;
*  DISK ADDRESS FOULED UP, DELETE CHT,DHT
KSKD1  LDI UNER; BSL RPERP; BSL KRLWK; BVR RETKS1;

*  DISK CLEANUP FOR DESTROY PAGE (UN MATCH)

$KCDS BSL RECLQ; CNT CKSDET; LDA DKAD,6; CALL DHTSCH,Z; PUNT; CXS DHTPT;
       BSL ERRCK; BRU KRSCL; BRU KCDS1; BRU KCDS0; BRU KCDS4;
*  UN OK, DELETE CHT ENTRY, QUEUE DELETE WRITE
KCDS0  CSX EPTR; LDI CKSDE0; STA RCDD,6; BSL DCHTE; NOP; 
       CSB EPTR; BSL QKSLNI; BRU RET1;
*  UNIQUE NAME ERROR, CHECK FOR UN = 0
KCDS1  CSX DHTPT; LDB WUND,6; SKNB =WUNM; BRU KCDS2;
       LDA UN0C; MRG UN1C; SKE =0; BRU KCDS2;
*  WE BELIEVE EVERYTHING OK, DELETE PAGE NOW!
DELPAG BSL KRLWK; BRU RET1;

*  WE HAVE EITHER A BAD UN OR A RESET WUN
KCDS2  SKB =HDRERM; BRU KCDS3; LDI UNERK; SKNB =UNDCKM;

*  DISK UN ERROR, RETURN
KUNER  LDI UNERK;
*  SEND ERROR, RELEASE PAGE, WAKEUP PROCESS
KERLWK BSL RPERP; BSL KRLWK; BRU RET1;
*  DISK SOFT ERROR, RETURN
KSFER  LDI SERDK; BRU KERLWK;
*  DISK HARD ERROR
KHDER  LDI HERDK; BRU KERLWK;

*  COULD NOT READ OFF THE DRUM EITHER, REPORT UNER, LEAVE DHT,CHT ALONE
KCDS3  LDI UNER; BSL RDERR; BRU RET1;
*  HARD ERROR, IF CHECK ON DISK ONLY - DELETE PAGE, OTHERWISE
*  LEAVE CHT,DHT ALONE
KCDS4  CSX DHTPT; LDB UNDCKD,6; SKA =UNDCKM; BRU DELPAG;
       BSL KWAKP; BRU RET1;
       BSL RLDCHT; BSL WAKEPR; BRU RETURN;
KCDS7 CSB DHTPT; CLA; STF DEST; STF HDRER;
       BSL WAKEPR; BRU RETURN;


*  DISK CLEANUP FOR DESTROY PAGE (WRITE UN =0)

$KCDSW BSL RECLQ; BSL ERRCK; BRU KRSCL; BRU KCDW0; BRU KCDW0; BRU KCDW1;
*  EVERTHING OK, NO USEFUL DATA ON DISK
KCDW0  BSL KRLWK; BRU RET1;
*  HARD ERROR
KCDW1  CSX EPTR; LDA DKAD,6; CALL DHTSCH,Z; PUNT; CXS DHTPT; LDB UNDCKD,6;
*  IF CECKED ON DISK ONLY - SEND ERROR AND DELTE PAGE
*  OTHERWISE - SEND ERROR ONLY, ALWAYS SEND WAKEUP ETC...
       LDI HERDK; SKB -UNDCKM; BRU KERLWK;
*  SEND ERROR ONLY
       BSL RDERR; BRU RET1;

*  DISK CLEANUP FOR DISK-DRUM TRANSFER

$KCKD  BSL CLQICR; LDA DKAD,6; CALL DHTSCH,Z; PUNT; CXS DHTPT;
       BSL ERRCK; BRU KCKD0; BRU KUNER; BRU KSFER; BRU KHDER;
QWRT   LDI WRTQ; CSB EPTR; CALL SELEQP; DSK NKT; BSL RSDKWK; BRU RET1;
*  DELETE CHT ENTRY, TRY AGAIN
KCKD0  CSX EPTR; BSL DCHTE; PUNT; BRU KRSCL;


*  DISK CLEANUP FOR DRUM-DISK TRANSFER (UN=0 CHECK)

$KCDKU BSL CLQICR; CNT CKSDKU; LDA DKAD,6; CALL DHTSCH,Z; PUNT; CXS DHTPT;
       BSL ERRCK; BRU KRSCL; BRU KCDKU1; BRU KCDKU0; BRU KCDKU3;
*  UN NAME CORRECT, QUEUE WRITE
KCDKU0 BSL KQDKT; BRU RET1;
*  CHECK UN FOR 0
KCDKU1 LDA UN0C; MRG UN1C; SKNE =0; BRU KCDKU0;
*  UN ERROR, FREE PAGE AND SEND ERROR
       LDI UNERK;
KCDKU2 BSL RPERP;
DSCHWK CSX CHTPT; LDA SCHD,6; SKA =SCHM; SUB =1; STA SCHD,6;
KFCWT  BSL PGDOND; BRU QWRT; CSB CHTPT; CALL PPFCL; BSL RSDKD; BRU RET1;
*  HARD ERROR
KCDKU3 LDI HERDK; BRU KCDKU2;


*  DISK CLEANUP FOR DRUM-DISK TRANSFER (WRITE PAGE)

$KCDK  BSL CLQICR; LDA DKAD,6; CALL DHTSCH,Z; PUNT; CXS DHTPT;
       BSL ERRCK; BRU KRSCL; BRU KCDK1; BRU KCDK2; BRU KCDK3;
       CSX DHTPT; LDA UCNTD,6; ETR =@WUNM;
KCDK0  SKA =UCNTM; SUB =1; STA UCNTD,6; SKA =UCNTM; BRU DSCHWK;
*  PAGE ALMOST FREE TO DELETE
       CSX CHTPT; LDA SCHD,6; SKA =SCHM; SUB =1; STA SCHD,6;
       SKA =SCHM+LOCKM; BRU KFCWT; 
       BSL KRLWK; BRU RET1;

*  UN ERROR
KCDK1  LDI UNERK; BRU KCDK4;
*  SOFT ERROR ON DISK
KCDK2  LDI SERDK; BRU *+2;
*  HARD ERROR ON DISK
KCDK3  LDI HERDK;
KCDK4  BSL RPERP; CSX DHTPT; LDA UCNTD,6; BRU KCDK0;

*  DISK CLEANUP FOR WRITE UNIQUE NAME (UN CHECK FOR 0)

$KCWU  BSL RECLQ; CNT 12; LDA DKAD,6; CALL DHTSCH,Z; PUNT; CXS DHTPT;
       BSL ERRCK; BRU KRSCL; BRU KCWU1; BRU KCWU0; BRU KCWU2;
KCWU0  LDI CKSWU0; BSL KQDKT0; BRU RET1;
*  UN ERROR, CHECK FOR ZERO
KCWU1  LDA UN0C; MRG UN1C; SKNE =0; BRU KCWU0;
*  UN ERROR
       LDI UNERK; BSL RDERR; BRU RET1;
*  HARD ERROR
KCWU2  LDI HERDK; BSL RDERR; BRU RET1;


*  DISK CLEANUP FOR WRITE UNIQUE NAME

$KCWW  BSL RECLQ; BSL ERRCK; BRU KRSCL; BRU KUNER; BRU KSFER; BRU KHDER;
       BSL KRLWK; BRU RET1;


*  CLEANUP FOR SEEK ROUTINE

$CSEEK BSL RECLQ; SNEL EQPD,6; BRU CSEK1;
CSEK0  LDX DKAD,6; LSR4 =KTSU; CALL GETPOS;
       SKNA =TSCVF; BSL KSCHUN; BRU RETURN; BRU RET1;
*  ANOTHER NODE ON CLEANUP QUEUE, IS IT A SEEK COMMAND?
CSEK1  LDB EQPD,6; LDF RCD; SKE =19; BRU CSEK0; CXB; CALL SETFL; 
       LDB* CLNQC; CBS EPTR; BRU CSEEK;


*  READ PAGE KLUDGE, PUT IN SPECIFICALLY FOR SYSDDT

$RDPG  BSL REACT; SCALL INCOR,FA0; BRU RDPG0; SKA =INCORM; BRU RDPG1;
       ADD =1; STA SCHD,6; BRU SRACT;
RDPG0  CSA DKACMP; SKNA =4B7; BRU DNCHE;
RDPG1  CSB EPTR; BSL QDRD1; BRU NIDHE; BRU WAITE;
       LDI 0; CAS EPTR; BRU SRACT;


*  START READ PAGE REQUEST

$SRDPG CBX; SCALL INCOR,FA0; BRU SRDP0; SKA =INCORM; BRU NDRD0;
       ADD =1; STA SCHD,6; CSB EPTR; CALL SETFL; BVR 1;
SRDP0  CSA DKACMP; SKNA =4B7; BRU RETURN; CSX EPTR; LDA DKAD,6; 
       CALL DHTSCH,Z; PUNT; CXS DHTPT; CNT 18; BRU NDRRD;


*  CLEANUP FOR READ PAGE KLUDGE

$CRDPG BSL CLQICR;
       BSL ERRCK; BRU DRSCL; BRU CRDPG0; BRU CRDPG0; BRU CRDPG0;
       BRU RETURN;
CRDPG0 CSX EPTR; BSL DCHTE; PUNT; BRU RETURN;

*  GENERAL REQUEST DISPATCHER

$GENRQ CBS EPTR; SKG =MAGRQ; BRU* GRQTV,2;
$GENRQ1 BSL REGRQ; BRU RETURN;


*  ACTIVATE REQUEST DISPATCHER

$ACTRQ CBS EPTR; SKG =MAARQ; SKG =MIARQ; BRU *+2; BRU* ARQTV,2;
       BSL REACT; BRU ARQBE;
       LDI ARQOB; BRU FRACT;


*  RESTART CLEANUP BECAUSE TSU AND AMC OUT OF SYNC
$KRSCL CSB EPTR; BSL QKSLNI; BRU RSCLUP;
$KRSCL0 CSB EPTR; BSL QKSL; BRU RSCLUP;
$DRSCL CSX EPTR; BSL DCHTE; PUNT;
$DRSCL0 CSB EPTR; BSL QDRD1; PUNT; PUNT;
$RSCLUP SNEL* CLNQC; BRU RET1; SKN TRY3TM; BRU RET1; ERCNT 11B;
       LDB* CLNQC; LDF RCD; CAX;


*  CLEANUP FOR TSU'S
*  A,X HAS REQUEST CODE
*  B HAS POINTER TO NODE

$TSUCL CBS EPTR; SKG =MACLRQ; BRU* CLTV,2;
       BSL RECLQ; CALL SETFL; UPR 17B; RET;


*  DISK START DISPATCHER
$DKSTART CXA; CBS EPTR; SKG =MAKSRQ;
DKST0  BSL* TVECDS,2; BRU RETURN;
$RETKS1 EQU *-DKST0; BRU RET1;


*  START DISK, ALL REGISTER SET UP
$STDISK SCALL STSUI; CSB EPTR; LDI DKCLQ; CALL AELEQP; BVR RETKS1;

*  ERROR CHECK
*  EPTR = POINTER TO NODE
*  RETURNS:
*  1 - TRY 3 TIMES OR ERROR IN ID CODE,
*  2 - UN ERROR
*  4 - HARD ERROR
*  5 - NO ERROR

*  B - CONTAINS STATC THROUGHOUT ROUTINE
*  X CONTAINS EPTR THROUGHOUT ROUTINE

*  THE FOLLOWING ENTRY POINT IS USED BY DIRECT I/O CLEANUPS
$DIERR LDB STATC; CSX EPTR; SKB =TSRLV; BRU ERRCK0; 
       STB TRY3TM; LDA INSTC; ETR =77B6; SKE =77B6; BVR 1; BRU DIER0;

*  THIS IS THE NORMAL ENTRY POINT
$ERRCK LDB STATC; CSX EPTR; SKB =TSRLV; BRU ERCK14;
       STB TRY3TM; LDA IDCODD,6; EOR INSTC; SKA =IDCODM; BRU ERCK13;
DIER0  SKB =3776B; BRU ERRCK6
       LDA 0,6; SKE UN0C; BRU ERRCK0;
       LDA 1,6; SKE UN1C; BRU ERRCK0;
       BVR 5;
ERRCK0 XXB; LDF ERRCNT; ADD =1; SKL =3; BRU ERRCK2;
ERRCK1 STF ERRCNT; STA TRY3TM; BVR 1;
ERRCK2 ERCNT 7; XXB; SKB =HERST; BRU ERRCK3;
       SKB =TSCNE; BRU ERRCK5;
       LDA 0,6; SKE UN0C; BRU ERRCK4;
       LDA 1,6; SKE UN1C; BRU ERRCK4;
ERRCK3 BSL ERRBUF; CSX EPTR; BVR 4;
ERRCK4 SKB =TSCN0+TSDPE; BRU ERRCK3; BVR 2;
ERRCK5 SKB =TSDPE; BRU ERRCK3; BVR 2;
ERRCK6 SKB =TSDTL+TSDPV; BRU ERCK10;
       LDA TSUNC; ETR =6B6; SKE =0; BRU ERRCK9;
       SKB =TSCNE+TSDPE; BRU ERRCK8;
       SKB =TSCN0; ERCNT 5;
ERRCK7 XXB; LDF ERRCNT; ADD =1; SKL =10; BRU ERRCK2; BRU ERRCK1;
ERRCK8 STX ERRBFX; BSL ERRBUF; LDX ERRBFX; BRU ERRCK7;
ERRCK9 SKB =TSCN0+TSDPE; ERCNT 6; BRU ERRCK7;
ERCK10 SKB =TSDTL; BRU ERCK12; ERCNT 4;
ERCK11 LDI 0; STA TRY3TM; BVR 1;
ERCK12 ERCNT 3; BRU ERCK11;
ERCK13 ERCNT 2; BVR 1;
ERCK14 ERCNT 1; BRU ERCK11;

ERRBUF STA ERRBFA; LDA BFPT; ADD =2; SKL =LBUF; LDI 7700B; STA BFPT;
       CAX; LDA DEVADR; STA 0,2; LDA STATC; STA 1,2; LDA ERRBFA; BVR 1;

ERRBFA BSS 1
ERRBFX BSS 1



*  PROCESS WAKEUP IN NODES
*  EPTR EXPECTED TO POINT TO NODE

$WAKEPR CSX EPTR; LDA WAKFD,6; SKNA =WAKFM; BVR 1; LDB EPRTD,6;
*  ENTRY POINT
*  B - PTR TO PRT ENTRY
$WAKPR0 LDX =AMCW; PRO 13B; CALL WAKEUP; BVR 1;


*  WAKEUP PROCESS IF LOADED
*  EPTR = POINTER TO NODE

$WKLD  CSB EPTR; LDF EPRT; CAS PRTPT; CAX; PRO 3; LDA DTCD,6;
       SKA =DTCM; SUB =1; STA DTCD,6;
       SKNA =DTCM; BSL WKPRC; CSB EPTR; CALL SETFL; BVR 1;

*  WAKEUP PROCESS WHICH HAS NOW BEEN READ INTO CORE
*  X - PRTPT
*  PROTECT 1 MUST BE SET

$WKPRC LDA PRST,6; ETR =@[CBCM+PQM+SWQM]; MRG =LDDM; STA PRST,6;
       CXB; CLX; PRO 13B; CALL WAKEUP; 
       SKR NPR,4; BRU *+3; LDI 0; STA NPR,4;
       LDB =RIPQ; CALL RTEQP,Z; BVR 1; CALL SETFL; BVR 1;


*  REPORT ERROR TO PROCESS
*  A - ERROR CODE

$RPERP CAS SR1; CAX; SKG =LPRERR; MIN PRERRA,6;
       CSB EPTR; CBX; LDF EPRT; CAB; CSA SR1; PRO 3; STF ERRCD;
       LDA DKAD,6; STF SWERW; BVR 1;


*  REPORT ERROR TO PROCESS #1
*  EPTR - POINTER TO NODE
*  GIVE PROCESS #1 THE PRT POINTER AND A PROCESS IN TROUBLE ERRCD
*  SEND PROCESS #1 AN AMC WAKEUP
*  FREE NODE

$PRCERR SKR NCTX,4; BRU *+3; LDI 0; STA NCTX,4;
$PRCER1 CSB EPTR; LDF EPRT; CAS PRTPT; CALL SETFL;
       LDX PRTB,4; EAX SZPRTE,2; CSA PRTPT; STA SWERWD,6; LDI PRTRBL;
       CXB; STF ERRCD; BSL WAKPR0; CSB PRTPT; LDI 1; STF CBE; 
$ZPRTS LDI CBCM+PQM+PGFM; ZRF PRSTW; BVR 1;


*  SET UP DISK COMMAND DEVICE ADDRESS
*  THE IDEA HERE IS TO SET UP MOST REGISTERS FOR THE TYPICAL COMMAND.
*  REG AFFECTED ARE:
*  SR1 - ID CODE AND UNIT NUMBER
*  SR2 - DEVICE ADDRESS (TSU FORMAT)
*  SR3 - 0
*  ABSOLUTE 0 - 0 (IN ORDER THAT FIRST CELL OF A ZERO COMMAND BE ZERO)

$KCOM  CSB EPTR; LDF KUNIT; MRG KIDSEQ; CAS SR1;
       LCY 4; STF IDCODE; LDA =4B6; ADM KIDSEQ;
       LDF KTSUN; LCY 19; CAS SR0; CLS SR3; SSR3 0,4;
       LDF TRACK; LCY 14; STA TEMP;
       LDF KBAND; LCY 7; ADM TEMP; LDF KSECT;
       LCY 2; MRG TEMP; CAS SR2; BVR 1;


*  TURN SF OFF
$SFOFF CSB EPTR; BSL GPMT; BVR 1; LDI 1; ZRF SF; BVR 2;

*  FIND PMT ENTRY
*  B - PTR TO ENTRY
*  SUCCESS RETURN B - PTR TO PMT ENTRY
*  FAIL RETURNS IF CONTEXT BLOCK NOT IN CORE, OR
*  IF CWS INDEX DOES NOT PRODUCE A CWS ENTRY.
$GPMT  LDF EPRT; CAX; LDF ECWS; CNA; ADD =CWSDSP; STA CBADD;
       SCALL INCOR,FA0; BVR 1; SKA =INCORM; BVR 1;
*  CONTEXT BLOCK IN CORE, COMPUTE ABSOLUTE ADDRESS OF PAGE
       ETR =CPAM; XMA CBADD; ADD CBADD; CAX; CAS CWSPT;
*  NOW CHECK CWS ENTRY
       LDA CWSD,6; SKNA =CWSM; BVR 1; ETR =PMTIM; LCY 2;
       ADD =PMTDSP; ADD CBADD; CAB; BVR 2;


*  SEARCH LIST ON UNIQUE NAME AND DISK ADDRESS WITH DISP OF 5
*  A - PTR TO PSEUDO-NODE OF HEADER
*  X - PTR TO NODE CONTAINING DISK ADDRESS
*  SUCCESS RETURN - NO SKIP
*      X - PTR TO NODE
*  SKUN0,SKUN1 CONTAIN THE UNIQUE NAME
*      SR4 - PTR TO PREVIOUS NODE
*      SR0 - PTR TO UN1 WORD IN NODE

$SCHLST LSR1 2,6;
       LDB =77B6; SCALL CHTS0-1,T; BVR 2;
SCHL1  CSA SR1; EOR 2,6; SKNA =@6B7; BVR 1;
       SCALL CHTS0,T; BVR 2; BRU SCHL1;



       NOLIST EXT,GO;

       END;

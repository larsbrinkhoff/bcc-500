       COMMON UNPP';
       INCLUDE COMM,STDEC,STST,UPST,PRST;


* THIS FILE CONTAINS THE SPL UNPREPROCESSOR.

       PROGRAM EDSA;
       INCLUDE UNPP';

* THIS FUNCTION FINDS A SYMBOLIC ADDRESS FOR SOME LINE STARTING
* WITH EDSASI AND WORKING BACK. IF NO LABELED LINE IS FOUND THEN
* AN RETN OCCURS WITH 0,N (N=NO. OF LINES FROM IB BEGIN),
* OTHERWISE AN RETN OCCURS WITH T,N (N=ABSOLUTE DISPLACEMENT FROM EDSASI,
* T=TOKEN NUMBER OF LABEL). FRETN OCCURS IF NO CURRENT IB SELECTED.
       DI EDSAX1,EDSAX2,EDSAX3;
       DP EDSAPV;

FUNCTION ZEDSA(EDSASI), FRETURN;
       FRETN IF ICGTN=0;
       EDSAX1←-1; EDSAX2←EDSASI;
EDSAL1:EDSAX1←EDSAX1+1;
       EDSAPV←STPTR(EDSAX2);
       RETN (EDSAX3←GHW(EDSAPV,PTTO),EDSAX1) IF LASTHW(EDSAPV)>PTTO
        AND GHW(EDSAPV,PTTO+1) A' OPTMSK=TNRMIN+':';
       GOTO EDSAL1 IF(EDSAX2←SPREV(EDSAX2))#0;
       RETN (0,EDSAX1+1);



       PROGRAM UNPP;
       INCLUDE UNPP';

* THIS FUNCTION UNPREPROCESS THE SI INDICATED BY UPSI IN THE BLOCK
* INDICATED BY THE TOKEN UNBTN AND RETNS WITH STRING UPS CONTAINING
* THE TEXT. SPACING MODE SELECTED BY UNMOD( SEE UNSMOD DECLARATION).
       DI UNPPX1,UNPPX2,UNTOKN;
       DECLARE FUNCTION ARRAY UNPPFA[20B]←(
        UNSC,UNSC,UNSC,UNSC,UNSC,UNSC,UNSC,UNSC,
        UNSM,UNSM,UNSM,UNSM,UNOP,UNKW,UNCON,UNFE);

FUNCTION ZUNPP (UPSI,UNBTN,UNMOD);
       UNSMOD←UNMOD;
       UNTOKN←-1;
UNPPL4:CERR(127) IF UNBTN=0;* NO CURRENT BLOCK
       SSELECT(UNBTN);
       UPV←STPTR(UPSI);
       BCOPY(PPTA,UPV,UPV.PTSIZE);
       GOTO UNPPL1;
* SAME AS UNPP EXCEPT CHARACTER NUMBER WILL BE RETNED FOR TOKEN NUMBER UNTOKN
ENTRY ZUNPSI(UPSI,UNBTN,UNTOKN);
       UNSMOD←2;GOTO UNPPL4;
* THIS IS THE SAME AS UNPP EXCEPT SI IS ALLREADY IN PPTB
ENTRY ZUNPK(UNBTN);
       UNSMOD←2;UPSI←0;
       UNTOKN←-1;
       CERR(127) IF UNBTN=0;* NO CURRENT BLOCK
       SSELECT(UNBTN);
UNPPL1:SETS(UPS);
       UPPSI←UPSI;
       UNCHN←UNCHNE←-1;
       PLBM←0;
       UPI2←LASTHW(PPTA);
       RETN IF UPI2<PTTO;
       UNSPCT←UNERR←0;
       UTKIND←(37777777B IF UNSMOD<=2
        ELSE 0 IF ICBA.IBFTYPE#IBFTSPL OR UPI2<PTTO+1
        OR GHW(PPTA,PTTO+1) A' OPTMSK#TNRMIN+':'
        ELSE PTTO+2);
       UNCSTR←0;*INITIALIZE FLAG
       FOR UPI1←PTTO TO UPI2 DO;
          UNTK←GHW(PPTB,UPI1);
*****
* 5/5/73  JACK FREEMAN
* KLUDGE (?) TO KEEP FROM PASSING MULTIPLE-BLANK TOKENS TO UNSP
* (AND THROUGH IT TO PBLANK, WHICH CAN'T HANDLE THEM).  THIS MAY
* EVEN BE THE RIGHT THING TO DO.  THE FOLLOWING STATEMENT REPLACES
* A LINE WHICH READ:
*         UNSP();
          UNSP() IF UNTK<TNBMIN OR UNTK>TNBMAX;
*****
          UNCHN←LENGTH(UPS) IF (UPI1-PTTO)=UNTOKN;
          (UNPPFA[UNTK RSH 8])();
          UNCHNE←LENGTH(UPS) IF (UPI1-PTTO)=UNTOKN;
          IF UNERR#0 DO;
             CERR(UNERR);
          ENDIF;
       ENDFOR;
       UNCHNE←LENGTH(UPS) IF UNCHNE<0;
       RETN UNCHN;



       PROGRAM UNSP;
       INCLUDE UNPP';

* THIS FUNCTION INSERTS BLANKS IN UPS ACCORDING TO BLANK MODE (UNSMOD)
* AND SURROUNDING TOKENS.
       DI UNSPX1,UNSPX2;

FUNCTION UNSP();
       IF (TNRMIN<=UNTK AND UNTK<TNKMIN)DO;
          UNSPCT←UNSPCT+UNTK$OPTLB;
       ENDIF;
       UNSPCT←UNSPCT+(UNSPX1←PBLANK(UNTK));
       IF UPI1>=UTKIND DO;
          UTKIND←37777777B; *SHUT THE DOOR
          IF (UNTK=TKN50 OR UNTK=TKN55) AND LENGTH(UPS)=0 DO;
             UNSPX2←0;
          ELSEIF PPTA.PTIND=0 AND UNSMOD>2 DO;
             GOTO UNSPL3;
          ELSE DO;
             UNSPX2←EMARGIN-LENGTH(UPS);
             UNSPX2←UNSPX2+EINDENT*(PPTA.PTIND-1)IF UNSMOD>2;
             IF (UPV←SPREV(UPPSI))#0 DO;
                   UPV←STPTR(UPV);
                UNSPX2←UNSPX2+ECONTSP IF UPV.PTEOS=0; *CONTINUATION ADJUSTMEN 
             ENDIF;
             UNSPX2←0 IF UNSPX2<0;
          ENDIF;
       ELSEIF (UNSMOD=2 OR UNSMOD=4) DO; *DUPLICATE ORIGINAL TEXT
UNSPL3:   UNSPX2←(UNSPCT IF UNSPCT>=0 ELSE UNSPX1);
       ELSEIF (UNSMOD=1 OR UNSMOD=3) DO; *STANDARD SPACING
          UNSPX2←UNSPX1;
       ENDIF;
UNSPL1: UBLANK(UNSPX2);
*****
* 5/6/73  JACK FREEMAN
* I HAVE CHANGED THE FOLLOWING STATEMENT TO SET UNSPCT TO 0 INSTEAD
* OF -1.  I'M NOT SURE THIS IS THE RIGHT THING TO DO, BUT IT'S A
* BETTER THING.
*****
       UNSPCT←0; RETURN;
UNSPL145:UNERR←145; RETURN;



       PROGRAM UBLANK;
       INCLUDE UNPP';

* THIS FUNCTION DOES THE ACTUAL BLANK ENCODING

FUNCTION UBLANK(UBLNUM);
       RETURN IF UBLNUM<1;
       IF UBLNUM = 1 DO;
           WCI(' ', UPS//UBL1);
       ELSE DO;
           UBLNUM←CHMB1+UBLNUM;
           WHILE UBLNUM>CHMB2 DO;
               WCI(CHMB2,UPS//UBL1);
               UBLNUM←UBLNUM-CHMB2+CHMB1;
           ENDFOR;
           WCI(UBLNUM,UPS//UBL1);
       ENDIF;
       RETURN;
UBL1:  UNERR←145;
       RETURN;



       PROGRAM KWST;
       INCLUDE UNPP';

* THIS FUNCTION WILL SRETURN WITH THE KEYWORD STRING CORRESPONDING
* TO THE TOKEN NUMBER KWTN IN KWDS. KEYWORD TABLE KWTBL IS USED.
* FRETURN IF NO SUCH TOKEN, OR IF KWDS OVERFLOWS
       DECLARE INTEGER KWTX6,KWTX7,KWTX8,KWTX9,KWTX10;
       DS KWTS1;

STRING FUNCTION KWST(KWTN,STRING KWDS), FRETURN;
       IF (KWTX6 ← KWTN - KWTBLX[1]$KWF6) < 0 DO;
           CERR(126);* ILLEGAL KEYWORD TOKEN
       ENDIF;
       KWTX6←KWTBLX[KWTX6+2]$KWF8;
       KWTX7←@KWTBL[KWTX6];
       KWTX8←KWTX7.KWF9;
       WCI(KWTBL[KWTX6+((KWTX8+1)RSH 2)]AA 77B,KWDS//FRETN);
       SETUP(KWTS1,KWTX8+1,KWTX7,6);
       KWTS1$WP←KWTS1$EP;
       GCI(KWTS1);
       WCI(GCI(KWTS1//RETN KWDS),KWDS//FRETN) WHILE 1;



       PROGRAM UNFE;
       INCLUDE UNPP';

* TOKEN IS A SPACE COUNT, FORMAT EFFECTOR, OR COMMENT
       DECLARE SWITCH UNFEA[4]←(UFCL,UFCM,UFCM1,UFCS);

FUNCTION UNFE();
       IF UNTK<=TNBMAX DO;
           UNSPCT←0 IF UNSPCT<0;
           UNSPCT←UNSPCT+UNTK-TNBMIN;
           RETURN;
       ELSE DO;
           GOTO LABEL'FIXER(UNFEA[UNTK A' 177B]);
       ENDIF;
* PAGE EJECT
UFCL:  IF UMCONT DO;
           WCI(CHFF,UPS//RETURN);
       ELSE DO;
           APPND(UPS,UNFFS//RETURN);
       ENDIF;
       RETURN;
* ERROR
UFCM1: UPI1←UPI1+1;
* COMMENT
UFCM:  UNCM();
       RETURN;
* CONTINUE STRING
UFCS:  UNCSTR←1;
       RETURN;



       PROGRAM UNXY;
       INCLUDE UNPP';

* TOKEN IS A SINGLE OPERATOR.

FUNCTION UNOP();
       WCI((UNTK A' OPTMSK)-TNRMIN,UPS//UNXYL1);
       UNSPCT←1 IF UNTK$OPTRB;
       RETURN;
UNXYL1:UNERR←145; RETURN;

* TOKEN IS A KEYWORD.

FUNCTION UNKW();
       KWTBL←SPLKW; KWTBLX←SPLKWX;
       UPS←KWST(UNTK,UPS//UNKWL1); RETURN;
UNKWL1:UNERR←145; RETURN;

* TOKEN IS A SMALL INTEGER

FUNCTION UNSM();
       FCNS(UNTK-TNCZRO,UPS,0,10//UNXYL1);
       RETURN;

* TOKEN IS A SYMBOL

FUNCTION UNSC();
       UPS←SWSYM(UNTK,UPS//UNXYL1);
       RETURN;



       PROGRAM UNCM;
       INCLUDE UNPP';

* THIS FUNCTION PUTS A COMMENT INTO UPS
       DI UNCMX1,UNCMX2;
       DS UNCMS(0);

FUNCTION UNCM();
       UNCMX1←@PPTB[(UPI1+1) RSH 1]+1;
       UNCMX2←GHW(PPTB,UPI1+1); *GET NUMBER OF BYTES
       UPI1←UPI1+(UPI1 AA 1)+(UNCMX2+1)*2/3+1;
       SETUP(UNCMS,UNCMX2,UNCMX1);
       SETW(UNCMS,UNCMX2);
       GOTO UNCML4 IF UMCONT=0;
       APPND(UPS,UNCMS//UNCML2);
       RETURN;
UNCML2:UNERR←145; RETURN;
UNCML4:UNCMX1←GCI(UNCMS//RETURN);
       IF UNCMX1=CHFF DO;
           APPND(UPS,UNFFS//UNCML2);
       ELSEIF UNCMX1=' ' DO;
           UNCMX1←1;
           UNCMX1←UNCMX1+1 WHILE(UNCMX2←GCI(UNCMS//VALUE
           UBLANK(UNCMX1) & RETURN))=' ';
           UBLANK(UNCMX1);
           UNCMS$SR ← INCDES(UNCMS$SR,-1);
       ELSE DO;
           WCI(UNCMX1,UPS//UNCML2);
       ENDIF;
       GOTO UNCML4;

       PROGRAM UNCON;
       INCLUDE UNPP',KTDEC;

* TOKEN INTRODUCES A PACKED CONSTANT.
       DI UCNTY,UCSIZE,UCNCS,UCNQC,UCCC,UCCH,UCBB;
       DI UCCHM←4B7 RSH KTSTR+4B7 RSH KTCHAR;
       DM GETHW()←(GHW(PPTB,UPI1) WHERE UPI1←UPI1+1);
       DM UWCI(X)←WCI(X,UPS//UCERR);
       DECLARE ARRAY UCET[20B]←('0','1','2','3','4','5','6','7',
         '8','9','.','+','-','D','E','B');
       DECLARE SWITCH UCNSW[4]←(UC60,UC80,UC81,UC68E);
       DECLARE ARRAY UCSD[2]←('6','8');
       DECLARE ARRAY UCSM[2]←(77B,377B);

FUNCTION UNCON();
       UCNTY←UNTK$KTTYPE;
       IF (UCSIZE←UNTK$KTSIZE)=0 DO;
           UCSIZE←GETHW();
       ENDIF;
       UCNCS←UNTK$KTCSIZE;
       UPI1←UPI1+1 IF (UPI1 AA 1)=0 AND (UCNTY=KTSTR OR UCNTY=KTCHAR);
       IF UCCHM LSH UCNTY<0 DO;
* CHARACTER OR STRING CONSTANT
           UWCI(UCSD[UCNCS]) IF UNTK$KT6V8;
           UWCI(UCNQC←('"' IF UCNTY=KTSTR ELSE '&''));
           UCCC←UCNCS;
           FOR UCSIZE←UCSIZE-1 BY -1 TO 0 DO;
               GOTO LABEL'FIXER(UCNSW[UCCC]);
UC60:          UCCH←(UCBB←GETHW()) RSH 6;
               GOTO UCON1;
UC68E:         UCCC←UCNCS;
               UCCH←UCBB AA UCSM[UCNCS];
               GOTO UCON3;
UC80:          UCCH←(UCBB←GETHW()) RSH 4;
               UCCC←UCCC+1;
               GOTO UCON2;
UC81:          UCCH←(UCBB AA 17B) LSH 4;
               UCCH←UCCH+(UCBB←GETHW()) RSH 8;
UCON1:         UCCC←3;
UCON2:         
UCON3:         IF UCCH>=100B DO;
* CONVERT TO PSEUDO-CHARACTER
                   UWCI('&&');
                   IF UCCH>='&A' AND UCCH<='&Z' DO;
                       UCCH←UCCH+('A'-'&A');
                   ELSE DO;
                       UWCI('0'+UCCH RSH 6);
                       UWCI('0'+((UCCH RSH 3) AA 7));
                       UCCH←'0'+(UCCH AA 7);
                   ENDIF;
               ELSEIF UCCH='&&' OR UCCH=UCNQC DO;
                   UWCI('&&');
               ENDIF;
               UWCI(UCCH);
           ENDFOR;
           UWCI(UCNQC) IF UNCSTR=0 ELSE UNCSTR←0;
       ELSE DO;
* NUMERIC CONSTANT
           UCCC←0;
           FOR UCSIZE←UCSIZE-1 BY -1 TO 0 DO;
               IF (UCCC←UCCC-1)<0 DO;
                   UCCC←2;
                   UCBB←GETHW() LSH 8;
               ENDIF;
               UWCI(UCET[(UCBB←UCBB LSH 4) RSH 20]);
           ENDFOR;
           UWCI('I') IF UCNTY=KTIMAG;
       ENDIF;
       RETURN;
* UPS FULL
UCERR: UNERR←145; RETURN;


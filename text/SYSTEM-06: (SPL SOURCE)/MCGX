       COMMON SXFN';
       INCLUDE COMM,STST,SCDEC,SCOPS,SGST;

**************
*  SPL CODE  *
* GENERATORS *
**************



       COMMON TX'PARAM;
       INCLUDE SCOPS,SGDEC,SGTAB;
***
*** PARAMETER TABLE FOR CODE GENERATORS
***
       DFF NCF(0:0,0);* NOT COMMUTATIVE FLAG
       DFF INF(0:17,23);* INSTRUCTION (ASSUMED RIGHT-JUSTIFIED)

       DECLARE ARRAY TOPPAT[OPQCOUNT+1]←(
        0,0,0,0,0,  0,0,0,0,0,
        1,4,7,10,1@NCF+ZIMOD,  0,0,0,0,0,
        0,0,0,ZAND,ZIOR,  ZEOR,0,1@NCF+ZLSHA,0,1@NCF+ZCYA,
        0,0,0,0,RTXFER,  RFXFER,0,0,0,0);

* TABLE OF INSTRUCTIONS FOR ARITHMETIC OPERATORS
       DECLARE ARRAYONE TAOTAB[12]←(
        ZADD,ZFAD,ZCFAD,ZSUB,ZFSB,ZCFSB,
        ZIMUL,ZFMP,ZCFMP,ZIDIV,ZFDV,ZCFDV);

       PROGRAM TXX;
       INCLUDE SXFN';

***
*** TXXERR(A)
***
* ROUTINE FOR ILLEGAL AND UNIMPLEMENTED OPERATORS

FUNCTION TXXERR(POINTER XX00);
ENTRY TXSC(XX00);
ENTRY TXPOW(XX00);
* ILLEGAL OPERATOR
       CERR(87);


***
*** TXLIST(A)
***
* SPECIAL ERROR FOR UNEXPECTED EXPRESSION LIST

FUNCTION TXLIST(XX00);
* EXPRESSION LIST IN ILLEGAL CONTEXT
       CERR(97);


***
*** TXNIL(A)
***
* CODE GENERATOR FOR EMPTY SUBTREE

FUNCTION TXNIL(XX00);
       RETURN RNOVAL;


       PROGRAM TXBO;
       INCLUDE SXFN',TX'PARAM;
***
*** TXBO(A)
***
* CODE GENERATOR FOR SIMPLE BINARY OPERATORS

       DI W01;
       DP P01;

FUNCTION TXBO(POINTER A01);
       W01←TOPPAT[A01.TOPR];
       P01←TSWOP(P01) IF TSPP(A01.TO1,A01.TO2:,P01) AND W01$NCF;
       TSI(W01$INF,P01);
       RETURN RVALA;

       PROGRAM TXARITH;
       INCLUDE SXFN',TX'PARAM,SGEN';
***
*** TXPLUS(A)
***  CODE GENERATOR FOR +
*** TXMINUS(A)
***  CODE GENERATOR FOR -
*** TXTIMES(A)
***  CODE GENERATOR FOR *
*** TXQUOT(A)
***  CODE GENERATOR FOR /
***

       DP R30;

FUNCTION TXPLUS(POINTER A30);
TXCAE: TSPP(A30.TO1,A30.TO2:,R30);
TXAE:  TSI(TAOTAB[TOPPAT[A30.TOPR]+TTDTAB[A30.TTYPE]],R30);
       RETURN RVALA;

FUNCTION TXMINUS(A30);
       GOTO TXAE IF TSPP(A30.TO1,A30.TO2:,R30)=0;
       TFNEG(R30);
       TFAO(R30,TADOTB);
       RETURN RVALA;

FUNCTION TXTIMES(A30);
       GOTO TXCAE;

FUNCTION TXQUOT(A30);
       R30←TSWOP(R30) IF TSPP(A30.TO1,A30.TO2:,R30);
       GOTO TXAE;

       PROGRAM TXUNARY;
       INCLUDE SXFN';

***
*** TXNEG(A)
***
* CODE GENERATOR FOR NEGATION

FUNCTION TXNEG(POINTER AU);
       IF AU.TTYPE=TTINT AND TNCA(AU.TO1)#0 DO;
            TSCAN(AU.TO1,RADDR);
            TSI(ZLNX,RESULT);
            RETURN RVALX;
       ELSE DO;
            TSCAN(AU.TO1,RVALA);
            TFNEG(AU);
            RETURN RVALA;
       ENDIF;

***
*** TXLOGNOT(A)
***
* CODE GENERATOR FOR LOGICAL NOT

FUNCTION TXLOGNOT(POINTER AU);
       TSCAN(AU.TO1,RVALA);
       TSW(ZEOR@INSOP+IQ(-1));
       RETURN RVALA;

***
*** TXNOT(A)
***
* CODE GENERATOR FOR PREDICATE NOT

FUNCTION TXNOT(POINTER AU);
       TSCAN(AU.TO1,RFXFER IF RMODE=RTXFER ELSE RTXFER);
       RETURN RTXFER+RFXFER-RMODE;

***
*** TXPRED(A)
***
* CODE GENERATOR FOR PREDICATE 'AND' AND 'OR'


       PROGRAM TXPRED;
       INCLUDE SXFN',TX'PARAM;
* RECURSIVE LOCAL VARIABLES
       DECLARE POINTER B54,L54,INTEGER M54;

       DM NM54←RTXFER+RFXFER-M54;

FUNCTION TXPRED(POINTER A54);
       M54←TOPPAT[A54.TOPR];* RTXFER FOR 'OR', RFXFER FOR 'AND'
       B54←RESULT;
       IF RMODE#NM54 DO;
               IF RMODE#M54 DO;
                       B54←RESULT←TSBRA();
               ENDIF;
               TSCAN(A54.TO1,M54);
               RESULT←B54;
               TSCAN(A54.TO2,M54);
       ELSE DO;
               RESULT←L54←TSBRA();
               TSCAN(A54.TO1,M54);
               RESULT←B54;
               TSCAN(A54.TO2,M54←NM54);
               TSBDEF(L54);
       ENDIF;
       RESULT←B54;
       RETURN M54;

***
*** TXREL(A)
*** TXLREL(A)
***
* CODE GENERATOR FOR RELATIONS
* COMPARISONS AGAINST 0 ARE SUPPRESSED, BUT
* NO OTHER OPTIMIZATION IS DONE



       PROGRAM TXREL;
       INCLUDE SXFN',SGTAB;
* RECURSIVE LOCAL VARIABLES
       DECLARE POINTER B58,INTEGER C58,M58;

       DP R58,P58,Q58;
       DI T58;
       DECLARE ARRAY TRITAB[7]←(0,4,2,6,1,5,3);

FUNCTION TXLREL(POINTER A58);
FUNCTION TXREL(POINTER A58);
       C58←R58.TOIV WHERE R58←A58.TO3;
       C58←7-C58 IF RMODE=RFXFER;
       P58←A58.TO1;
       Q58←A58.TO2;
       IF RMODE#RTXFER AND RMODE#RFXFER DO;
               RMODE←RTXFER;
               B58←TSBRA();
       ELSE DO;
               B58←RESULT;
       ENDIF;
       M58←RMODE;
       IF P58.TOPR=OPCON DO;
               P58←Q58;
               Q58←A58.TO1;
               C58←TRITAB[C58];
       ENDIF;
       IF A58.TOPR=OPREL DO;
               C58←TRITAB[C58] IF TSPP(P58,Q58:,R58);
               TFCP(R58);
       ELSE DO;
               P58←TSCAN(P58,RVALS);
               TSCAN(Q58,RADDR);
               TSA(ZBLL,LCPFD);
               TSW(U(APMCON,APMODE)+U(APINT,APTYPE)+P58.TADDR);
               TSW(U(APMCON,APMODE)+U(APINT,APTYPE)+RESULT.TADDR);
               TSW(U(APMCON,APMODE)+U(APINT,APTYPE)+
          U(1,APLAST)+IQ(TTLTAB[RESULT.TTYPE]));
       ENDIF;
       TSBI(TRCTAB[C58],B58);
       RESULT←B58;
       RETURN M58;

***
*** TXSET(A) ###
***
* CODE GENERATOR FOR ASSIGNMENT
* OPTIMIZES A←A+X, A←A-C



       PROGRAM TXSET;
       INCLUDE SXFN';
* RECURSIVE LOCAL VARIABLES
       DECLARE POINTER P63,Q63, INTEGER V63;


FUNCTION TXSET(POINTER A63);
       P63←A63.TO2;
       IF P63.TOPR=OPPLUS AND P63.TTYPE=TTINT AND P63.TO1=A63.TO1 DO;
            Q63←TSCAN(P63.TO2,RVALS);
            TSCAN(A63.TO1,RADDR);
            TFINC(RESULT.TADDR,Q63.TADDR);
            RETURN RMODE VV RVALA;
       ENDIF;
       IF V63←TSMA(A63.TO1) DO;
            TSCAN(P63,RVALA+RVALX);
            IF (RMODE AA RVALX)=0 DO;
                 RESULT←A63.TO1;
            ELSE DO;
                 TSI(ZSTX,RESULT←A63.TO1);
                 RETURN V63+RVALX;
            ENDIF;
       ELSEIF TNCA(A63.TO1) DO;
            TSCAN(P63,RVALA);
            TSCAN(A63.TO1,RADDR);
       ELSEIF TSMA(P63) DO;
               P63←TSCAN(A63.TO1,RADDR);
               TSCAN(A63.TO2,RVALA);
               RESULT←P63;
       ELSE DO;
               P63←TSCAN(P63,RVALS);
               TSCAN(A63.TO1,RADDR);
               TSLCR(P63);
               V63←RADDR;
       ENDIF;
       TSSCR(RESULT);
       RETURN RVALA+V63;

       PROGRAM TXREF;
       INCLUDE SXFN';
***
*** TXREF(A) ###
***
* CODE GENERATOR FOR REFERENCE


       DP P64;

FUNCTION TXREF(POINTER A64);
       IF P64.TTYPE=TTLAB AND P64.TOPR=OPVAR AND
   P64.TDEF#0 WHERE P64←A64.TO1 DO;
            TSBI(ZEAX,P64);
       ELSE DO;
            TSCAN(P64,RADDRX);
       ENDIF;
       RETURN RVALX;


***
*** TXINDIR(A) ###
***
* CODE GENERATOR FOR INDIRECTION

FUNCTION TXINDIR(POINTER A64);
       TSCAN(A64.TO1,RVALS);
       A64.TADDR←RESULT.TADDR;
       RESULT←A64;
       RETURN RADDRS;

***
*** TXUNTAIL(A)
***
* CODE GENERATOR FOR UNTAILING



       PROGRAM TXUNTAIL;
       INCLUDE SXFN';

       DI W67,LS67,RS67;
       DP P67;

FUNCTION TXUNTAIL(POINTER A67);
       TSCAN(A67.TO2,RVALS);
       TSCAN(A67.TO1,RVALA);
       P67←A67.TO2;
       IF P67.TOPR=OPCON DO;
            W67←P67.TO1;
            LS67←24-W67$FIWBL;
            RS67←W67$FIWBA;
            IF LS67=RS67 AND (W67←(-1) RSH RS67)<=FRMASK(INSIMV)/2 DO;
                 TSW(U(ZAND,INSOP)+IQ(W67)) IF W67#-1;
            ELSE DO;
                 TSW(U(ZLSHA,INSOP)+IQ(LS67)) IF LS67;
                 TSW(U(ZLSHA,INSOP)+IQ(-RS67)) IF RS67;
            ENDIF;
            RETURN RVALA;
       ELSE DO;
            TSIND(P67,A67//TXUTE);
            TSW(U(ZLDB,INSOP)+U(ATREL,INSTAG)+U(ASTIM,INSST));
            TSI(ZSTB,RESULT←TSTEMP(TTINT));
            TSI(ZEAX,RESULT);
            TSI(ZSTA,A67);
            RETURN RVALS;
       ENDIF;
* INDIRECTION FAILED
TXUTE: CERR(59);

***
*** TXBX(A)
***
* CODE GENERATOR FOR ARRAY SUBSCRIPTING AND PART-WORD TAILING



       PROGRAM TXBX;
       INCLUDE SXFN';
* RECURSIVE LOCAL VARIABLES
       DECLARE POINTER P75;

       DI V75;

FUNCTION TXBX(POINTER A75);
       IF V75←TSMA(A75) DO;
            RESULT←A75;
            RETURN V75;
       ENDIF;
       P75←TSCAN(A75.TO1,RVALS);
       TSCAN(A75.TO2,RVALX);
       TSIND(P75,A75//TSUE);
       RESULT←A75;
       RETURN RADDR;
* INDIRECTION FAILED
TSUE:  CERR(59);


***
*** TXPD(A)
***
* CODE GENERATOR FOR NON-ARRAY SUBSCRIPTING AND FULL-WORD TAILING

FUNCTION TXPD(POINTER A75);
       IF V75←TSMA(A75) DO;
            RESULT←A75;
            RETURN V75;
       ENDIF;
       TSPPZ(A75.TO1,A75.TO2,RVALX:,A75);
       TSI(ZADX,A75);
       RETURN RADDRX;

***
*** TXIF(A)
***
* CODE GENERATOR FOR IF



       PROGRAM TXIF;
       INCLUDE SXFN';
* RECURSIVE LOCAL VARIABLES
       DECLARE POINTER TX81,FX81,R81,INTEGER M81;


FUNCTION TXIF(POINTER A81);
       M81←RMODE;
       IF R81.TOPR=OPBLOCK WHERE R81←A81.TO2 DO;
               RESULT←FX81←TSBRA();
               IF R81.TOPR=OPCON WHERE R81←A81.TO1 DO;
                       TFIF(FX81,R81.TOIV#0);
               ELSE DO;
                       TSCAN(R81,RFXFER);
                       TFIF(FX81,-1);
               ENDIF;
       ELSEIF TFGOTO(A81.TO2:,TX81) DO;
               RESULT←TX81;
               TSCAN(A81.TO1,RTXFER);
               TSCAN(A81.TO3,M81);
       ELSEIF TFGOTO(A81.TO3:,TX81) DO;
               RESULT←TX81;
               TSCAN(A81.TO1,RFXFER);
               TSCAN(A81.TO2,M81);
       ELSE DO;
               M81←(M81 VV RVALA) AA NN (RVALS+RADDR)
          IF M81 AA (RVALS+RADDR);
               M81←(M81 VV RADDRA) AA NN RADDRS
          IF M81 AA RADDRS;
               R81←RESULT;
               TX81←0;
               FX81←RESULT←TSBRA();
               TSCAN(A81.TO1,RFXFER);
               RESULT←R81;
               TSCAN(A81.TO2,M81);
               RESULT←R81;
               M81←M81 A' N' (RVALA+RVALX) V' RMODE A' (RVALA+RVALX);
               R81←A81.TO3;
               TSBI(ZBRU,TX81←TSBRA()) IF FLOWTHRU#0
          AND (R81.TOPR#OPNIL OR M81#RNOVAL);
               TSBDEF(FX81);
               IF R81.TOPR#OPNIL DO;
                       TSCAN(R81,M81);
                       RMODE←M81;
               ELSEIF M81 AA (RVALA+RVALX) DO;
                       TSA(ZLDA IF M81 AA RVALA ELSE ZLDX,IQ(0));
                       RMODE←(RVALA IF M81 A' RVALA ELSE RVALX);
               ELSEIF M81#RNOVAL DO;
                       TSA(ZBLLN,RTEFD);
               ENDIF;
               TSBDEF(TX81) IF TX81;
       ENDIF;
       RETURN RMODE;

***
*** TXGOTO(A)
***
* CODE GENERATOR FOR GOTO



       PROGRAM TXGOTO;
       INCLUDE SXFN';

       DP P83;

FUNCTION TXGOTO(POINTER A83);
       P83←A83.TO1;
       IF P83.TDEF DO;
               TSBI(ZBRU,P83);
       ELSE DO;
               TSCAN(P83,RADDR);
               TSI(ZBLLN,RESULT);
       ENDIF;
       FLOWTHRU←0;
       DBFLAG←1;
       RETURN RNOVAL;

***
*** TXSEQ(A)
***
* CODE GENERATOR FOR &


       PROGRAM TXSEQ;
       INCLUDE SXFN';
* RECURSIVE LOCAL VARIABLES
       DECLARE INTEGER M86,POINTER R86;

 FUNCTION TXSEQ(POINTER A86);
       M86←RMODE;
       R86←RESULT;
       TSCAN(A86.TO1,RNOVAL);
       RESULT←R86;
       RESULT←TSCAN(A86.TO2,M86);
       RETURN RMODE;

***
*** TXLABEL(A)
***
* PROCESSOR FOR LABELS



       PROGRAM TXLABEL;
       INCLUDE SXFN';

       DP TP92,SP92,L92;

FUNCTION TXLABEL(POINTER A92);
       SSPTR(A92.TO1:TP92,SP92);
* LABEL IS ALREADY DECLARED ?
       CERR(92) IF TP92.TKTYPE#TTUND AND (TP92.TKTYPE#TTLAB
   OR TP92.TKIMPL=0);
       TSBDW(SP92.SYVAL) IF TP92.TKIMPL;
       SP92.SYVAL←RQ(RELLOC);
       TP92.TKTYPE←TTLAB;
       TP92.TKIMPL←0;
       TP92.TKPARAM←1;
       RETURN RNOVAL;

***
*** TFFOR(V,LL,ELL,B)
***
* GENERATE NEW ENTRY ON FOR STACK
* VARIABLE IS V, LABELS ARE LL AND ELL, BASLR IS B
* GIVE AN ERROR IF THE TREE AREA IS FULL



       PROGRAM TFFOR;
       INCLUDE SXFN';


FUNCTION TFFOR(V04,POINTER LL04,ELL04,INTEGER B04);
* BLOCK STACK FULL ?
       CERR(84) IF FORSTK-FORLE<TREETOP;
       FORSTK←FORSTK-FORLE;
       FORSTK.BSTKOP←OPENDFOR;
       FORSTK.BSTKID←SSID;
       FORSTK.FORVAR←V04;
       FORSTK.FORLL←LL04.BADWORD;
       FORSTK.FORELL←ELL04.BADWORD;
       FORSTK.FORBASE←BASLR;
       BASLR←B04;
       ILEV←ILEV+1;
       RETURN;

***
*** TFCLF(V,L)*
***
* COMPUTE RELATION REQUIRED TO CLOSE LOOP
* WITH INCREMENT V, '-1' FLAG L.
* RELATION TRUE = GO THROUGH LOOP AGAIN



       PROGRAM TFCLF;
       INCLUDE SXFN';


FUNCTION TFCLF(INC04,LF04);
       RETURN ((ORLE IF INC04>=0 ELSE ORGE)-
   (OREQ IF LF04 ELSE 0));

***
*** TEMACH(A)
***
* CODE GENERATOR FOR MACHINE LANGUAGE



       PROGRAM TEMACH;
       INCLUDE SXFN';

       DI OP69,AD69,TN69,FTN69;
       DP TP69,SP69,P69;

FUNCTION TEMACH(POINTER A69);
       FTN69←ICGTN;
       P69←A69.TO1;
       IF P69.TOPR=OPCON DO;
* ILLEGAL MACHINE OPCODE ?
            CERR(94) IF P69.TTYPE#TTINT;
            OP69←P69.TOIV;
            AD69←-1;
       ELSEIF P69.TOPR#OPVAR OR (TN69←SSFGS(P69.TVTOKEN,
   MOBTN,0))=0 DO;
* ILLEGAL MACHINE OPCODE
            CERR(94);
       ELSE DO;
            SSPTR(TN69:TP69,SP69);
            OP69←SP69.SYVAL;
            AD69←SP69.SYDIM;
            SSELECT(FTN69);
       ENDIF;
       A69←A69.TO2;
       IF A69.TOPR=OPNIL DO;
* REQUIRES ADDRESS ?
            CERR(100) IF AD69=1;
            TSW(OP69);
       ELSEIF AD69=0 DO;
* MUST NOT HAVE ADDRESS
            CERR(102);
       ELSEIF OP69 A' N' 177B DO;
* ILLEGAL MACHINE OPCODE
            CERR(94);
       ELSEIF TFLAB(A69) WHERE OP69←OP69+(OP69 A' 100B) DO;
            TSBI(OP69,A69);
       ELSEIF TSMA(A69)=0 AND A69.TOPR#OPVAR DO;
* ADDRESS IS NOT SIMPLE
            CERR(101);
       ELSEIF A69.TOPR#OPCON DO;
            TSW(OP69@INSOP V' (1@INSPOP IF OP69>=200B ELSE 0)
          V' A69.TADDR);
       ELSE DO;
            TSI(OP69,A69);
       ENDIF;
       RETURN RNOVAL;

***
*** TEWHILE(A)
***
* CODE GENERATOR FOR WHILE



       PROGRAM TEWHILE;
       INCLUDE SXFN';
* RECURSIVE LOCAL VARIABLES
       DECLARE POINTER LL77,ELL77;

       DP P77;

FUNCTION TEWHILE(POINTER A77);
       P77←A77.TO1;
       LL77←TSBRA();
       ELL77←TSBRA();
       IF P77.TOPR=OPBLOCK DO;
               TSBDEF(LL77);
               RESULT←ELL77;
               TSCAN(A77.TO2,RFXFER);
               TFFOR(0,LL77,ELL77,BASLR);
       ELSE DO;
               TSBI(ZBRU,ELL77);
               TSBDEF(LL77);
               TSCAN(P77,RNOVAL);
               TSBDEF(ELL77);
               RESULT←LL77;
               TSCAN(A77.TO2,RTXFER);
       ENDIF;
       RETURN RNOVAL;

***
*** TEFOR(A)
***
* CODE GENERATOR FOR FOR-TO AND FOR-WHILE



       PROGRAM TEFOR;
       INCLUDE SXFN',SGTAB;
* RECURSIVE LOCAL VARIABLES
       DECLARE POINTER X78,INC78,LIM78,LL78,ELL78, INTEGER LF78;

       DP P78,Q78;
       DI V78;

FUNCTION TEFOR(POINTER A78);
       P78←A78.TO2;
       X78←P78.TO1;
* FOR VARIABLE IS NOT SIMPLE ?
       CERR(85) IF X78.TOPR#OPVAR OR X78.TVTOKEN=0;
       LL78←TSBRA();
       ELL78←TSBRA();
       IF A78.TOPR=OPFORW DO;
* FOR X←I[,TO3] WHILE TO4 DO TO1
            IF Q78.TOPR=OPNIL WHERE Q78←A78.TO3 DO;
                 TSBDEF(LL78);
                 TSCAN(P78,RNOVAL);
            ELSE DO;
                 TSCAN(P78.TO2,RVALA);
                 TSBI(ZBRU,ELL78);
                 TSBDEF(LL78);
                 TSCAN(A78.TO3,RVALA);
                 TSBDEF(ELL78);
                 TSSCR(X78);
            ENDIF;
            RESULT←ELL78←TSBRA();
            TSCAN(A78.TO4,RFXFER);
            P78←A78.TO1;
            GOTO TFORI;
       ELSE DO;
* FOR X←I [BY TO3] TO TO4 DO TO1
            INC78←TSCAN(A78.TO3,RVALS);
            P78←A78.TO4;
            IF P78.TOPR=OPPLUS  AND P78.TTYPE=TTINT AND INC78.TOPR=
          OPCON AND (Q78.TOPR=OPCON AND Q78.TOIV=(-1 IF INC78.TOIV>=0
          ELSE 1) WHERE Q78←P78.TO2) DO;
                 LIM78←TSCAN(P78.TO1,RVALS);
                 LF78←1;
            ELSE DO;
                 LIM78←TSCAN(P78,RVALS);
                 LF78←0;
            ENDIF;
            P78←A78.TO2;
            TSCAN(P78.TO2,RVALA);
            TSSCR(X78);
            P78←A78.TO1;
            IF X78.TTYPE=TTINT AND INC78.TOPR=OPCON DO;
* INTEGERS, CONSTANT INCREMENT
                 V78←INC78.TOIV;
                 TSBI(ZBRU,ELL78);
                 TSBDEF(LL78);
                 TFFOR(X78.TADDR,LL78,ELL78,CURLR);
                 FORSTK.FORINC←INC78.TADDR;
                 FORSTK.FORLIM←LIM78.TADDR;
                 FORSTK.FORLF←LF78;
                 FORSTK.FORSIGN←(V78<0);
            ELSE DO;
* NOT THE ABOVE
                 TSBI(ZBRU,ELL78);
                 TSBDEF(LL78);
                 IF X78.TTYPE=TTINT DO;
                      TFINC(X78.TADDR,INC78.TADDR);
                 ELSE DO;
                      TSLCR(X78);
                      TFAO(INC78,TADOTB);
                      TSSCR(X78);
                 ENDIF;
                 TSBDEF(ELL78);
                 RESULT←ELL78←TSBRA();
                 IF LIM78.TOPR=OPNIL DO;
                 ELSEIF INC78.TOPR=OPCON DO;
* SIGN OF INCREMENT KNOWN
                      TFCP(LIM78);
                      TSBI(TRCTAB[7-TFCLF(INC78.TO1,LF78)],ELL78);
                 ELSE DO;
* SIGN NOT KNOWN
                      X78←TSBRA();
                      TFAO(LIM78,TSBOTB);
                      TSBI(ZBEQ,X78);
                      TSI(ZEOR,INC78);
                      TSBI(ZBGE,ELL78);
                      TSBDEF(X78);
                 ENDIF;
TFORI:           TFFOR(0,LL78,ELL78,BASLR);
            ENDIF;
       ENDIF;
       IF P78.TOPR#OPBLOCK DO;
          TSCAN(P78,RNOVAL);
          TEEFOR(A78);
       ENDIF;
       RETURN RNOVAL;

***
*** TEEFOR(A)
***
* CODE GENERATOR FOR ENDFOR



       PROGRAM TEEFOR;
       INCLUDE SXFN',SGTAB;

       DP P80,S80;

FUNCTION TEEFOR(POINTER A80);
* ENDFOR WITHOUT FOR OR WHILE ?
       CERR(82) IF (S80←FORSTK)=TREELIM;
* MISNESTING OF IF AND FOR ?
       CERR(83) IF S80.BSTKOP#OPENDFOR;
       P80←TSBRA();
       P80.BADWORD←S80.FORLL;
       IF S80.FORVAR=0 DO;
            TSBI(ZBRU,P80);
            TSBDW(S80.FORELL);
       ELSE DO;
            TFINC(S80.FORVAR,S80.FORINC);
            TSBDW(S80.FORELL);
            TSA(ZICP,S80.FORLIM) IF S80.FORLIM#IQ(0);
            TSBI(TRCTAB[TFCLF(-S80.FORSIGN,S80.FORLF)],P80);
       ENDIF;
       BASLR←S80.FORBASE;
       FORSTK←FORSTK+FORLE;
       SILEV←ILEV←ILEV-1;
       RETURN RNOVAL;

***
*** TEELSEIF(A)
***
* CODE GENERATOR FOR ELSEIF (AND ELSE)



       PROGRAM TEELSEIF;
       INCLUDE SXFN';

       DP P89,Q89;
       DI V89;

FUNCTION TEELSEIF(POINTER A89);
* ELSE OR ELSEIF WITHOUT IF ?
       CERR(81) IF IFSTK=TREELIM;
       SILEV←ILEV-1;
* MISNESTING OF IF AND FOR ?
       CERR(83) IF IFSTK.BSTKOP#OPENDIF;
       IFSTK.BSTKID←SSID;
       GOTO TEIP IF IFSTK.IFCONST>=0;
       Q89←A89.TO1;
       IF Q89.TOPR=OPCON DO;
            IFSTK.IFCONST←V89←(Q89.TOIV#0);
            GOTO TEIP IF V89=0;
       ELSE DO;
            IFSTK.IFCONST←V89←-1;
       ENDIF;
       POISON←0;
       IF IFSTK.IFNEXT#U(1,BACHN) AND FLOWTHRU#0 DO;
            P89←TSBRA();
            P89.BADWORD←IFSTK.IFCLS;
            TSBI(ZBRU,P89);
            IFSTK.IFCLS←P89.BADWORD;
       ENDIF;
       TSBDW(IFSTK.IFNEXT);
       IF V89#1 DO;
            RESULT←P89←TSBRA();
            TSCAN(Q89,RFXFER);
            IFSTK.IFNEXT←P89.BADWORD;
       ELSE DO;
            IFSTK.IFNEXT←U(1,BACHN);
       ENDIF;
       RETURN RNOVAL;
TEIP:  TSBDW(IFSTK.IFNEXT);
       IFSTK.IFNEXT←U(1,BACHN);
       POISON←1;
       RETURN RNOVAL;

***
*** TEEIF(A)
***
* CODE GENERATOR FOR ENDIF



       PROGRAM TEEIF;
       INCLUDE SXFN';

       DP P90,Q90;

FUNCTION TEEIF(POINTER A90);
* ENDIF WITHOUT IF ?
       CERR(80) IF IFSTK=TREELIM;
* MISNESTING OF IF AND FOR ?
       CERR(83) IF IFSTK.BSTKOP#OPENDIF;
       TSBDW(IFSTK.IFNEXT);
       TSBDW(IFSTK.IFCLS);
       IFSTK←IFSTK+IFLE;
       SILEV←ILEV←ILEV-1;
       RETURN RNOVAL;

       COMMON SGFN';
       INCLUDE COMM,STDEC,STST,SCDEC,SCOPS,SGST,SGTAB;

***********************
* SPL CODE GENERATORS *
* FOR FUNCTION CALLS  *
***********************



* FIELD DECLARATIONS FOR TABLES ASSOCIATED WITH SPECIAL FUNCTIONS

* FIELDS FOR ARGUMENT DESCRIPTION POINTER TABLE
       DF AWPTR(0:12,23);* INDEX OF FIRST ARG DESC BYTE
       DF AWCNT(0:9,11);* ARG COUNT
       DF AWSTC(0:6,8);* MAXIMUM NUMBER OF STORES
       DF AWFSTC(0:3,5);* MAXIMUM NUMBER OF FAILURE STORES
       DF AWFRET(0:2,2);* 1 IF FAILURE RETURN
       DF AWBLL(0:1,1);* 1 IF CALLED WITH BLL, 0 IF OPEN CODE

* FIELDS FOR ARGUMENT DESCRIPTION TABLE
       DF AVLOC(0:21,23);* ARGUMENT LOCATION
       DF AVTYPE(0:15,20);* ARGUMENT TYPE
       DF AVDI(0:9,14);* INDEX TO DEFAULT VALUE

* SPECIAL FUNCTION DEFAULT VALUE TABLE
       DECLARE ARRAY ADTAB[7]←(
   0,IQ(10),IQ(-1),IQ(0),IQ(8),IQ(23),IQ(1));

* SPECIAL FUNCTION ARGUMENT DESCRIPTION TABLE
* RELEVANT FIELDS: AVLOC, AVTYPE, AVDI
       DECLARE ARRAY AVTAB[58]←(
   31B,21B,50B,60B,60B,1020B,20B,60B,
   3020B,1020B,30B,60B,3020B,40B,60B,3020B,
   21B,60B,60B,20B,20B,4020B,60B,3020B,
   3020B,60B,3020B,20B,20B,20B,3020B,20B,
   120B,60B,60B,20B,20B,2020B,21B,20B,
   20B,3020B,4020B,3020B,20B,3020B,5020B,3020B,
   20B,3020B,6020B,3020B,20B,20B,3020B,20B,
   20B,20B);

* SPECIAL FUNCTION DESCRIPTION TABLE
* RELEVANT FIELDS: AWPTR, AWCNT, AWSTC, AWFSTC, AWFRET, AWBLL
       DECLARE ARRAY AWTAB[46]←(
   00010000B,00010000B,00010001B,00010001B,
   00010002B,00010002B,30020004B,30010003B,
   30010003B,30040006B,30030012B,30030015B,
   10010003B,10020020B,10010003B,10020020B,
   10040022B,00030026B,00020031B,00020031B,
   00010003B,00010003B,30020033B,20020035B,
   30020037B,20020035B,30020035B,20020035B,
   30020041B,00030043B,30020041B,00020046B,
   00020046B,00030043B,30010006B,20040050B,
   20040054B,20040060B,20030064B,20000000B,
   20030067B,20020035B,20020035B,20010006B,
   00010003B,00010003B);


* PARAMETERS AND STORES FOR INTRINSIC FUNCTIONS
       DECLARE ARRAY APA74[FRMASK(AWCNT)],APP74[FRMASK(AWCNT)],
   SA74[FRMASK(AWSTC)],FSA74[FRMASK(AWFSTC)];

***
*** TFCARG(A,I)*
***
* COMPILE ACTUAL PARAMETERS ON CHAIN A, PUTTING AP WORDS INTO TADDR
* IF I=1, ALLOW 1 ARGUMENT TO GO IN THE CENTRAL REGISTERS
* IF I=0, FORCE ALL ARGUMENTS TO BE IN STORAGE
* IF I=-1, SAME AS I=0 AND NO SPECIAL HANDLING FOR ARRAY ELEMENTS
* OTHERWISE, I POINTS TO AVTAB



       PROGRAM TFCARG;
       INCLUDE SGFN';
* RECURSIVE LOCAL VARIABLES
       DECLARE POINTER P01,X01,R01;

       DECLARE SWITCH ACTAB[2]←(TACS,TACA);
       DI M01,T01;
       DP Q01;

FUNCTION TFCARG(POINTER A01,INTEGER I01);
       P01←A01;
       A01←R01←0;
       WHILE P01.TOPR#OPNIL DO;
               X01←P01.TO1;
               IF R01#0 AND TSMA(X01)#RVALS DO;
                       A01←R01.TO1;
                       TSSCR(A01←TSTEMP(A01.TTYPE));
                       R01.TADDR←R01.TADDR-APREGS+A01.TADDR;
                       R01←0;
               ENDIF;
               IF X01.TTYPE=TTUND DO;
* UNKNOWN ARGUMENT FOR FUNCTION OR RETURN
                       NODE←X01;
                       CERR(45);
               ENDIF;
               IF I01>1 DO;
                       I01←I01+1;
                       GOTO LABEL'FIXER(ACTAB[I01[-1]$AVLOC]);
               ENDIF;
               IF X01.TOPR=OPBX AND (Q01.TTYPE=TTARRAY WHERE Q01←
          X01.TO1) AND I01>=0 DO;
                       TSCAN(X01,RADDRS);
                       TSIND(RESULT,RESULT//TFCAE);
                       M01←U(APMELT,APMODE)+RESULT.TADDR;
               ELSE DO;
                       T01←X01.TTYPE;
                       IF I01=1 AND TSMA(X01)#RVALS AND TSPTAB[T01]=0 DO;
TACA:                          TSCAN(X01,RVALA);
                               M01←APREGS;
                               R01←P01;
                       ELSE DO;
TACS:                          TSCAN(X01,RVALS);
                               M01←RESULT.TADDR;
                       ENDIF;
                       M01←(U(APMARR,APMODE) IF X01.TTYPE=TTARRAY
                  ELSE U(APMVAR,APMODE) IF X01.TOPR=OPVAR
                  ELSE U(APMCON,APMODE))+M01;
               ENDIF;
               P01.TADDR←M01;
               P01←P01.TO2;
       ENDFOR;
       TSLCR(A01) IF I01>1 AND A01#0;
       RETURN;
* INDIRECTION FAILED
TFCAE: CERR(59);

***
*** TFARGS(B,A,F,R,N)*
***
* GENERATE BLL OR BLLN INSTRUCTION AND ACTUAL PARAMETER WORDS
* BLL IS TO B.TADDR: A IS ARGUMENT CHAIN WITH AP WORDS IN TADDR
* F=0 MEANS THERE IS ACTUALLY ANOTHER ARGUMENT (FAILURE GOTO)
* B=0 MEANS BLL HAS ALREADY BEEN GENERATED
* WHEN PARAMETERS ARE EXHAUSTED, CONTINUE UNTIL
* N WORDS HAVE BEEN STORED, USING VALUES FROM
* AVTAB STARTING WITH THE ENTRY POINTED TO BY R



       PROGRAM TFARGS;
       INCLUDE SGFN';

       DP TP02,SP02,X02;
       DI M02,W02;

FUNCTION TFARGS(POINTER B02,A02,INTEGER F02,REFERENCE R02,INTEGER N02);
       F02←U(F02,APLAST);
       IF B02 DO;
            W02←B02.TADDR;
            M02←((W02$INSTAG=ATREL) A' (W02$INSST=ASTIM));
            IF A02.TOPR#OPNIL OR F02=0 DO;
                    IF M02 DO;
                            TSA(ZOPR,W02);
                    ELSE DO;
                            TSI(ZBLL,B02);
                    ENDIF;
            ELSE DO;
                    IF M02 DO;
                            TSA(ZOPR,W02-400B IF (W02+2000B)$INSIMV
                       ELSE W02+1400B);
                    ELSE DO;
                            TSI(ZBLLN,B02);
                    ENDIF;
            ENDIF;
       ENDIF;
       WHILE A02.TOPR#OPNIL DO;
               N02←N02-1;
               R02←R02+1;
               X02←A02.TO1;
               IF (M02←X02.TTYPE)=TTARRAY AND X02.TOPR=OPVAR DO;
                       SSPTR(X02.TVTOKEN:TP02,SP02);
                       M02←TP02.TKTYPE IF SP02.SYMODE=SMARRAY;
               ENDIF;
               W02←A02.TADDR+(M02←U(TAPTAB[M02],APTYPE));
               A02←A02.TO2;
               TSA(0,W02+(F02 IF A02.TOPR=OPNIL AND N02<=0 ELSE 0));
               IF W02$APMODE=APMELT DO;
                       X02←X02.TO1;* X01.TOPR=OPSUB
                       TSA(0,X02.TADDR+U(APMARR,APMODE));
               ENDIF;
       ENDFOR;
       FOR N02←N02-1 BY -1 TO 0 DO;
               TSW(ADTAB[R02.AVDI]+U(TAPTAB[R02.AVTYPE],APTYPE)+
          U(APMCON,APMODE)+(F02 IF N02=0 ELSE 0));
               R02←R02+1;
       ENDFOR;
       RETURN;

***
*** TFFCN(A,B)*
***
* PREPARE THE NODE A FOR BEING USED AS A FUNCTION
* (DIRECT ADDRESSING IF DEFINED FUNCTION, INDIRECT OTHERWISE)
* FRETURN IF INTRINSIC FUNCTION, RETURN OTHERWISE
* PUTTING THE FUNCTION ADDRESS INTO NODE B
* RETURN 1 IF MCALL OR UCALL, 0 IF NOT



       PROGRAM TFFCN;
       INCLUDE SGFN';

       DI W03;

FUNCTION TFFCN(POINTER A03,B03), FRETURN;
       IF A03.TDEF DO;
               B03.TADDR←W03←A03.TADDR;
               IF W03$INSTAG=ATREL AND W03$INSST=ASTIM DO;
                       RETN 1 IF W03$INSIMV<0 ELSE FRETN;
               ENDIF;
               RETN 0;
       ENDIF;
       TSCAN(A03,RVALS);
       TSIND(RESULT,B03//TFFCE);
       RETN 0;
* INDIRECTION FAILED
TFFCE: CERR(59);

***
*** TFAPT(A,I,N)*
***
* CHECK THE TYPES OF THE ACTUAL PARAMETERS ON THE CHAIN A
* AGAINST THOSE GIVEN IN THE ARGUMENT DESCRIPTION STRING
* STARTING AT ARG. DESC. TABLE ENTRY I
* RETURN 0 IF ALL OK, 1 IF TYPE MISMATCH, 2 IF REQUIRED
* ARGUMENT MISSING, 3 IF TOO MANY ARGUMENTS



       PROGRAM TFAPT;
       INCLUDE SGFN';

       DI D11,V11;
       DP P11;

FUNCTION TFAPT(POINTER A11,INTEGER I11,N11);
TFAP0: RETURN (0 IF A11=0 OR A11.TOPR=OPNIL ELSE 3)
   IF (N11←N11-1)<0;
       D11←AVTAB[I11];
       I11←I11+1;
       IF A11=0 OR A11.TOPR=OPNIL DO;
            RETURN 2 IF D11$AVDI=0 ELSE GOTO TFAP0;
       ELSEIF P11.TTYPE#(V11←D11$AVTYPE) WHERE P11←A11.TO1 DO;
            RETURN 1 IF P11.TTYPE#TTUND ELSE P11.TTYPE←V11;
       ENDIF;
       A11←A11.TO2;
       GOTO TFAP0;


***
*** TFCHZ(A)*
***
* RETURN 0 IF A IS AN EMPTY CHAIN, A OTHERWISE



       PROGRAM TFCHZ;
       INCLUDE SGFN';


FUNCTION TFCHZ(POINTER A12);
       RETURN (0 IF A12.TOPR=OPNIL ELSE A12);

***
*** TFCST(A,F)*
***
* COMPILE THE STORES ON CHAIN A
* STORE THE F.P. WORDS IF F=0
* PUT THE ADDRESSES INTO THE ARRAY AT F IF F#0
* RETURN THE FINAL VALUE OF F



       PROGRAM TFCST;
       INCLUDE SGFN';

       DI W13,T13;
       DP X13,P13;

FUNCTION TFCST(POINTER A13,REFERENCE F13);
       RETURN F13 IF A13=0;
       T13←0;
       WHILE A13.TOPR#OPNIL DO;
            P13←A13.TO1;
            W13←(TFFP(P13) IF P13.TOPR#OPNIL ELSE T13 IF F13 OR T13
          ELSE (T13←P13.TADDR+(U(FPMVAL,FPMODE)+U(FPCONT,FPADRF)+
          U(TFPTAB[TTINT],FPTYPE)) WHERE P13←TSTEMP(TTINT)));
            X13←A13.TO2;
            IF F13 DO;
                 $F13←W13 AA (FMASK(INSTAG)+FMASK(INSGD));
                 F13←F13+1;
            ELSE DO;
                 W13←W13+U(1,APLAST) IF X13.TOPR=OPNIL;
                 TSW(W13);
            ENDIF;
            A13←X13;
       ENDFOR;
       RETURN F13;

***
*** TXCALL(A) ###
*** TXNCALL(A) ###
***
* CODE GENERATOR FOR FUNCTION CALLS



       PROGRAM TXCALL;
       INCLUDE SGFN',SDOPS;
* RECURSIVE LOCAL VARIABLES
       DECLARE POINTER B74,L74, INTEGER SC74, GARBAGE;

       DP P74;

FUNCTION TXCALL(POINTER A74);
       B74←TFCHZ(A74.TO4);
       SC74←L74←0;
       IF B74 DO;
* DEAL WITH FAILURE ACTION
               IF TFGOTO(B74:,GARBAGE)#0 AND TFCHZ(A74.TO5)=0 DO;
                       B74←B74.TO1;
                       DBFLAG←1;
               ELSE DO;
                       L74←B74←TSBRA();
               ENDIF;
       ENDIF;
       SC74←TFFCN(A74.TO1,A74//TIFC);
* GENERATE THE ACTUAL PARAMETER LIST
       TFCARG(A74.TO2,1);
       TFARGS(A74,A74.TO2,B74=0,0,0);
TIFF:  IF B74 DO;
* STORE APW FOR FAILURE ACTION
               P74←A74.TO4;
               IF P74.TOPR=OPFRET AND P74.TO1=A74.TO5 AND
          FRETLR>=0 AND RETOK LSH CFLOC<0
          AND SC74=0 DO;
                       VINSA←LQ(FRETLR);
                       L74←0;
               ELSE DO;
                       TSBU(B74,TSGL(2));
                       PUT(VAA+FNEWL,1@FWCPA) IF TFCHZ(A74.TO5);
               ENDIF;
               TSA(0,U(TAPTAB[TTLAB],APTYPE)+U(APMCON,APMODE)+
          U(1,APLAST)+VINSA);
       ENDIF;
* GENERATE SUCCESS STORES
       IF P74←TFCHZ(A74.TO3) DO;
               TFCST(P74.TO2,0);
               (TFFP(P74) & TSSCR(P74)) IF P74←TFCHZ(P74.TO1);
       ENDIF;
* NOW FAILURE STORES, IF ANY, AND FAILURE COMPUTATION
TIFR:  IF L74 DO;
               TSBI(ZBRU,B74←TSBRA());
               TSBDEF(L74);
               TFCST(A74.TO5,0);
               TSCAN(A74.TO4,RVALA+RNOVAL);
               TSBDEF(B74);
       ENDIF;
       RETURN RVALA;
TIFC:  TXSF(A74,B74,TFCHZ(A74.TO3),TFCHZ(A74.TO5)//TIFF);
       GOTO TIFR;

ENTRY TXNCALL(POINTER A74);
       B74←0;
       TFFCN(A74.TO1,A74//TIFNC);
       TFCARG(A74.TO2,1);
       TFARGS(A74,A74.TO2,1,0,0);
TIFNF: RETURN RVALA;
TIFNC: TXSF(A74,B74,0,0//TIFNF);
       RETURN RVALA;

***
*** TXSF(ST,FST)
***
* PSEUDO CODE GENERATOR FOR SPECIAL FUNCTIONS



       PROGRAM TXSF;
       INCLUDE SGFN';
* RECURSIVE LOCAL VARIABLES
       DECLARE INTEGER AW74,SFI74,ABI74;

       DI I74,N74,W74, REFERENCE PT74;
       DP FN74,Y74;
       DI AA1=APA74[0],AA2=APA74[1],AA3=APA74[2],AA4=APA74[3];
       DP AP1=APP74[0],AP2=APP74[1],AP3=APP74[2],AP4=APP74[3];
       DECLARE SWITCH AS74[4]←(SFA0,SFA1,SFX,SFX);
       DECLARE SWITCH SS74[4]←(SFS0,SFS1,SFX,SFX);
       DECLARE SWITCH FS74[4]←(SFF0,SFS1,SFX,SFX);
* SPECIAL FUNCTION DISPATCHER:
* ADDRESS OF CODE GENERATOR IF AWBLL=0
       DECLARE SWITCH AXTAB[46]←(
   EFIX,EENTIER,EFLOAT,EDFLOAT,ERE,EIM,EBLL,EBLL,
   EBLL,EBLL,EBLL,EBLL,EGCI,EWCI,EGCD,EWCD,
   ESETUP,ESETS,ESETR,ESETW,ELENGTH,EGC,EBLL,EBLL,
   EBLL,EBLL,EBLL,EBLL,EBLL,EBCOPY,EBLL,EINCDES,
   ELNGDES,EBSET,EBLL,EBLL,EBLL,EBLL,EBLL,EBLL,
   EBLL,EBLL,EBLL,EBLL,EGETR,EGETW);

FUNCTION TXSF(POINTER Z74,FRET74,ST74,FST74), FRETURN;
       FN74←Z74.TO1;
       N74←FN74.TADDR$INSIMV;
       I74←ICGTN;
       SSELECT(1);
       SSPTR(N74:,Y74);
       W74←Z74.TADDR←Y74.SYVAL;
       SFI74←Y74.FSIFN-1;
       AW74←AWTAB[SFI74];
       Z74.TADDR←YCFD(N74) IF W74=0 AND AW74$AWBLL#0;
       SSELECT(I74);
* FAILURE RETURN NOT ALLOWED
       CERR(109) IF AW74$AWFRET=0 AND FRET74#0;
       ABI74←AW74$AWPTR;
       GOTO LABEL'FIXER(AS74[TFAPT(Z74.TO2,ABI74,AW74$AWCNT)]);
* WRONG SYNTAX FOR SPECIAL FUNCTION
SFX:   CERR(110);
* ARGUMENT OF WRONG TYPE
SFA1:  CERR(111);
SFA0:  GOTO LABEL'FIXER(SS74[TFAPT(ST74,I74←ABI74+AW74$AWCNT,AW74$AWSTC)]);
* STORE INTO VARIABLE OF WRONG TYPE
SFS1:  CERR(112);
SFS0:  GOTO LABEL'FIXER(FS74[TFAPT(FST74,I74+AW74$AWSTC,AW74$AWFSTC)]);
SFF0:  TFCARG(Z74.TO2,@AVTAB[ABI74]);
       N74←TFCST(ST74,@SA74[0]);
       SA74[I74] ← 0 FOR I74 ← N74-@SA74[0] TO AW74$AWSTC-1;
       N74←TFCST(FST74,@FSA74[0]);
       FSA74[I74] ← 0 FOR I74 ← N74-@FSA74[0] TO AW74$AWFSTC-1;
       N74←AW74$AWCNT;
       Y74←Z74.TO2;
       GOTO EBLL IF AW74$AWBLL;
       FOR I74←0 TO N74-1 DO;
            IF Y74.TOPR=OPNIL DO;
                 APP74[I74]←0;
                 APA74[I74]←ADTAB[AVTAB[ABI74+I74]$AVDI];
            ELSE DO;
                 APP74[I74]←Y74.TO1 ;
                 APA74[I74]←Y74.TADDR←Y74.TADDR AA
               (FMASK(INSTAG)+FMASK(INSGD));
                 Y74←Y74.TO2;
            ENDIF;
       ENDFOR;
       GOTO LABEL'FIXER(AXTAB[SFI74]);


* INDIVIDUAL CODE GENERATORS

* NOT IMPLEMENTED

EENTIER:
ERE:
EIM:
        CERR(113);
* INDIRECTION FAILED
EI:    CERR(59);

* BLL-TYPE
EBLL:  TFARGS(Z74,Y74,FRET74=0,@AVTAB[ABI74],N74);
       FRETN;

* FIX, FLOAT, DFLOAT
EFIX:  TSW(ZZFIX);
       RETN;
EFLOAT: TSDP(TTREAL);
EFLT:  TSW(ZZFLOAT);
       RETN;
EDFLOAT: TSDP(TTDBL);
       GOTO EFLT;

* GCI, WCI
EGCI:  TSA(ZISD,AA1+FDISP(SR));
       SFFRET(ZBEQ,ZBNE,FRET74);
       TSA(ZLDA,TSIIA(AA1+FDISP(SR)//EI));
       RETN;
EWCI:  TSA(ZISD,AA2+FDISP(SW));
       SFFRET(ZBEQ,ZBNE,FRET74);
       TSA(ZSTA,TSIIA(AA2+FDISP(SW)//EI));
       RETN;

* BCOPY, BSET
EBCOPY: W74←ZZMVB;
       GOTO EBO;
EBSET: W74←ZZMVC;
EBO:   TSA(ZLDX,AA2);
       TSA(ZLDB,AA1);
       IF AP3 DO;
            TSA(ZLDA,AA3);
       ELSE DO;
            TSGL(1);
            PUT(VAA,U(IWTFLD,IWTYPE)+U(6,FIWBA)+
          U(18,FIWBL)+U(-1,FIWDISP));
            TSA(ZLDA,TSIIA(VINSA//EI));
       ENDIF;
       TSW(W74);
       RETN;

* GCD, WCD
EGCD:  TSA(ZDSD,AA1+FDISP(SR));
       SFFRET(ZBEQ,ZBNE,FRET74);
       TSA(ZISD,AA1+FDISP(SW));
       TSA(ZLDA,TSIIA(AA1+FDISP(SW)//EI));
       TSA(ZDSD,AA1+FDISP(SR));
       RETN;
EWCD:  TSA(ZDSD,AA2+FDISP(SL));
       SFFRET(ZBEQ,ZBNE,FRET74);
       TSA(ZISD,AA2+FDISP(SR));
       TSA(ZSTA,TSIIA(AA2+FDISP(SR)//EI));
       TSA(ZDSD,AA2+FDISP(SL));
       RETN;

* LENGTH, LNGDES
ELENGTH: TSA(ZLDD,AA1+FDISP(SR));
ELEN:  TSW(ZZCLS);
       RETN;
ELNGDES: TSA(ZLDB,AA2);
       GOTO ELEN;

* GC
EGC:   Y74←TSTEMP(TTINT);
       W74←Y74.TADDR;
       TSA(ZLDA,AA1+FDISP(SR));
       TSA(ZLDX,IQ(1));
       TSW(ZZASP);
       TSA(ZSTX,W74);
       TSA(ZLDA,TSIIA(W74//EI));
       RETN;

* INCDES
EINCDES: TSA(ZLDX,AA2);
       TSW(ZZASP);
       TSW(ZZCXA);
       RETN;

* SETUP
ESETUP: GOTO ESU1 IF AA4$INSTAG#ATREL OR AA4$INSST#ASTIM
   ELSE GOTO ESU2 IF (AA4←AA4$INSIMV)#6 AND AA4#8
   AND AA4#12 AND AA4#24;
       TSGL(2);
       W74←U(IWTSTR,IWTYPE)+U(2 IF AA4=12 ELSE AA4/8,SIWCS);
       PUT(VAA,W74+U(3-W74$SIWCS,SIWCA)-1);
       PUT(VAA+1,U(-1,SIWWA));
       TSA(ZLDA,AA3);
       TSA(ZAND,VINSA+1);
       TSA(ZADD,VINSA);
       TSA(ZSTA,AA1+FDISP(SL));
       TSA(ZSTA,AA1+FDISP(SR));
       TSA(ZSTA,AA1+FDISP(SW));
       IF AP2.TOPR#OPCON DO;
            TSA(ZCPZ,AA2);
            SFFRET(ZBLT, ZBGE, FRET74);
       ENDIF;
       TSA(ZLDX,AA2);
       TSW(ZZASP);
       TSA(ZSTX,AA1+FDISP(SU));
       RETN;
* CHARACTER SIZE MUST BE CONSTANT
ESU1:  CERR(167);
* BAD CHARACTER SIZE
ESU2:  CERR(56);

* SETR, SETW, SETS
ESETW: TSA(ZLDA,AA1+FDISP(SL));
       ESSP(AA2,AA1+FDISP(SW),AA1+FDISP(SU));
       RETN;
ESETS: TSA(ZLDA,AA1+FDISP(SL));
       ESSP(AA3,AA1+FDISP(SW),AA1+FDISP(SU));
ESETR: TSA(ZLDA,AA1+FDISP(SL));
       ESSP(AA2,AA1+FDISP(SR),AA1+FDISP(SW));
       RETN;

* GETR, GETW
EGETR: TSA(ZLDD,AA1+FDISP(SL));
       GOTO ELEN;
EGETW: TSA(ZLDA,AA1+FDISP(SL));
       TSA(ZLDB,AA1+FDISP(SW));
       GOTO ELEN;

* ESSP(I,A,B)*
* INTERNAL FUNCTION FOR SETR, SETW, SETS
* SETS THE CHARACTER POINTER AT ADDRESS A TO THE I'TH BYTE
* BEYOND (A), FORCING I>=0 AND CLS(ASP(A,I),B)<=0
* I,A,B ARE ALL MACHINE ADDRESSES



       PROGRAM ESSP;
       INCLUDE SGFN';


FUNCTION ESSP(SSI74,SSA74,SSB74);
       IF SSI74$INSTAG=ATREL AND SSI74$INSST=ASTIM AND
   SSI74$INSIMV<=0 DO;
            TSA(ZSTA,SSA74);
       ELSE DO;
            TSA(ZLDX,SSI74);
            TSA(ZCPZ,U(ATREL,INSTAG)+U(ASTIMX,INSST));
            TSW(U(ZBGE,INSOP)+RQ(2));
            TSA(ZLDX,IQ(0));
            TSW(ZZASP);
            TSW(ZZCXB);
            TSA(ZLDA,SSB74);
            TSW(ZZCLS);
            TSW(U(ZBLE,INSOP)+RQ(2));
            TSA(ZLDB,SSB74);
            TSA(ZSTB,SSA74);
       ENDIF;
       RETURN;

* SFFRET(OP1,OP2,F)*
* INTERNAL FUNCTION FOR FAILURE RETURNS
* GENERATES .OP1 F IF F#0,
* OTHERWISE .OP2 R'[2], BLLN RUNTIME'FAILURE



       PROGRAM SFFRET;
       INCLUDE SGFN';


FUNCTION SFFRET(OP174,OP274,FR74);
       IF FR74 DO;
            TSBI(OP174,FR74);
       ELSE DO;
            TSW(U(OP274,INSOP)+RQ(2));
            TSA(ZBLLN,RTEFD);
       ENDIF;
       RETURN;

***
*** TXRET(A)
*** TXFRET(A)
***
* CODE GENERATOR FOR RETURN AND FRETURN



       PROGRAM TXRET;
       INCLUDE SGFN',SDOPS;
* RECURSIVE LOCAL VARIABLES
       DECLARE POINTER P84;

       DP Q84;
       DI W84;

FUNCTION TXRET(POINTER A84);
       P84←A84.TO1;
       W84←(0 IF P84.TOPR=OPNIL OR (Q84.TOPR=OPNIL WHERE
        Q84←P84.TO2) ELSE 1);
* WRONG NUMBER OF VALUES FOR RETURN ?
       NRETVAL←W84 IF NRETVAL<0 ELSE CERR(169) IF NRETVAL#W84;
       IF P84.TOPR=OPNIL DO;
            TSW(ZZRETN);
       ELSE DO;
            TFCARG(Q84,-1);
* UNKNOWN ARGUMENT FOR FUNCTION OR RETURN ?
            CERR(45) IF A84.TTYPE=TTUND WHERE A84←P84.TO1;
            TSCAN(P84.TO1,RVALA);
            IF P84.TOPR#OPNIL WHERE P84←P84.TO2 DO;
                 ICGSP.GSNEWL←ICNEWL←ICNEWL VV U(1,FDCPR);
                 TSW(ZZRET);
                 TFARGS(0,P84,1,0,0);
            ELSE DO;
                 TSW(ZZRETN);
            ENDIF;
       ENDIF;
* RETURN, FRETURN NOT ALLOWED ?
TRET1: CERR(57) IF RETOK LSH CFLOC>=0;* CONTINUES
       FLOWTHRU←0;*IT'S NOT SAFE TO RESET FLOWTHRU HERE? JF 9/14/74
       DBFLAG←1;
       RETURN RNOVAL;


ENTRY TXFRET(POINTER A84);
* FRETURN NOT ALLOWED ?
       CERR(107) IF FRETLR<0;
       P84←A84.TO1;
       TFCARG(P84,-1);
       W84←(ZZRETN IF P84.TOPR=OPNIL ELSE ZZRET);
       W84$INSLRD←FRETLR;
       TSW(W84);
       TFARGS(0,P84,1,0,0);
       GOTO TRET1;
       COMMON SGEN';
       INCLUDE COMM,STST,SCDEC,SCOPS,SGDEC,SGST;

* CONVERT TYPE TO SEMANTIC INDEX
       DECLARE ARRAY TTDTAB[TTNTT]←(
        -1,-1,0,1,1,2,3,3,3,3,3,4,4,-1);


*************
* SPL CODE  *
* GENERATOR *
*************




***
*** TSEX(A,F)
***
* SCAN THE TREE AT A AS A STATEMENT
* RESET OPTIMIZATION IF F=0



       PROGRAM TSEX;
       INCLUDE SGEN';


FUNCTION TSEX(POINTER A00,INTEGER F00);
       CURLR←BASLR;
       IF F00=0 DO;
            CFLAGS←U(1,CNDPF)+U(1,CFTF);
            LASTB←RELLOC;
       ENDIF;
       TSCAN(A00,RNOVAL);
       RETURN;

***
*** TSCAN(A,M) ###
***
* GENERATE CODE FOR THE NODE AT ADDRESS A
* FORCING IT TO DELIVER A RESULT OF MODE M
* RETURN THE VALUE OF RESULT, ASSUMED SET UP BY THE TX ROUTINE



       PROGRAM TSCAN;
       INCLUDE SGEN';
* RECURSIVE LOCAL VARIABLES
       DECLARE POINTER R01,S01;
       DI T01,I01;

***
*** CODE GENERATION DISPATCHER
***
       DECLARE FUNCTION ARRAY TOPXFT[OPQCOUNT+1]←(
        TXXERR,TXVAR,TXCON,TXSC,TXNIL,
        TXXERR,TXXERR,TXXERR,TXXERR,TXXERR,
        TXPLUS,TXMINUS,TXTIMES,TXQUOT,TXBO/*MOD*/,
        TXPOW,TXNEG,TXXERR,TXXERR,TXXERR,
        TXXERR,TXXERR,TXXERR,TXBO/*A'*/,TXBO/*V'*/,
        TXBO/*E'*/,TXLOGNOT,TXBO/*LSH*/,TXXERR,TXBO/*LCY*/,
        TXXERR,TXXERR,TXXERR,TXXERR,TXPRED/*OR*/,
        TXPRED/*AND*/,TXXERR,TXNOT,TXREL,TXLREL);
       DECLARE FUNCTION ARRAY TOPXFT[40]←(
        TXXERR,TXXERR,TXXERR,TXSET,TXREF,
        TXINDIR,TXXERR,TXUNTAIL,TXXERR,TEMACH,
        TXXERR,TXLIST,TXNCALL,TXXERR,TXCALL,
        TXBX,TXPD,TEWHILE,TEFOR,TEFOR,
        TEEFOR,TXIF,TXXERR,TXGOTO,TXRET,
        TXFRET,TXSEQ,TXXERR,TXXERR,TEELSEIF,
        TEEIF,TXXERR,TXLABEL,TEVDEC,TXXERR,
        TEFDEC,TXXERR,TXXERR,TXXERR,TEINCLUDE,
        TEEND);

***
*** RESULT TRANSFORMATION SWITCH
***
       DECLARE SWITCH TSRCTB[NRMODE*NRMODE]←(
    SNNB,SXERR,SBXVA,SBXVX,SBXVS,SBXAD,SBXAD,SBXAD,SBXVS, SNN ,
  SXERR, SNNB,SBXVA,SBXVX,SBXVS,SBXAD,SBXAD,SBXAD,SBXVS, SNN );
       DECLARE SWITCH TSRCTB[20]←(
   SVABX,SVABX, SNN ,SZCAX,SZSTR,SVAAD,SVAAD,SVAAD,SZSTR, SNN );
       DECLARE SWITCH TSRCTB[30]←(
   SVXBX,SVXBX,SZCXA, SNN ,SZSTX,SVXAD,SVXAD,SVXAD,SVXIX, SNN );
       DECLARE SWITCH TSRCTB[40]←(
   SVSBX,SVSBX,SZLDR,SZLDX, SNN ,SVSAD,SVSAD,SVSAD, SNN , SNN,
   SAABB,SAABB,SAABB,SAABB,SAABB, SNN ,SZCAX,SZSTR,SAABB, SNN );
       DECLARE SWITCH TSRCTB[60]←(
   SAXVB,SAXVB,SAXVB,SAXVB,SAXVB,SZCXA, SNN ,SZSTX,SAXVB, SNN ,
   SASVB,SASVB,SASVB,SASVB,SASVB,SZLDR,SZLDX, SNN ,SASVB, SNN );
       DECLARE SWITCH TSRCTB[80]←(
   SVSBX,SVSBX,SZLDR,SZLDX,SVSSA,SVSAD,SVSAD,SVSAD, SNN , SNN ,
   SVERR,SVERR,SVERR,SVERR,SVERR,SVERR,SVERR,SVERR,SVERR, SNN );

FUNCTION TSCAN(POINTER A01,INTEGER M01);
       R01←RESULT;
       RMODE←M01;
       S01←NODE;
       RMODE←(TOPXFT[A01.TOPR])(NODE←A01);
       NODE←S01;
SGO:   RETURN RESULT IF RMODE AA M01;
       T01←FLLO(M01);
       I01←NRMODE*FLLO(RMODE)+T01-(NRMODE+1);
       RMODE←4B7 RSH T01;
       GOTO LABEL'FIXER(TSRCTB[I01]);
SZCAX: TSW(ZZCAX);
SNN:   RETURN RESULT;
SZCXA: TSW(ZZCXA);
       RETURN RESULT;
SZLDR: RETURN TSLCR(RESULT);
SVSSA: TSLCR(RESULT);
SZSTR: RETURN TSSCR(RESULT←TSTEMP(A01.TTYPE));
SZLDX: TSI(ZLDX,RESULT);
       RETURN RESULT;
SBXVA: TSFVAL(ZLDA,M01);
       RETURN 0;
SBXVX: TSFVAL(ZLDX,M01);
       RETURN 0;
SBXVS: TSFVAL(ZLDA,M01);
       RETURN TSSCR(RESULT←TSTEMP(TTINT));
SBXAD: TSFVAL(ZLDA,M01);
       RMODE←RVALA;
       GOTO SGO;
SVSBX: TSI(ZCPZ,RESULT);
       GOTO SVB;
SVXBX: TSA(ZCPZ,U(ATREL,INSTAG)+U(ASTIMX,INSST));
       GOTO SVB;
SVABX: TSA(ZICP,IQ(0)) IF CCOK=0;
SVB:   TSBI(ZBNE IF (RMODE←M01)=RTXFER ELSE ZBEQ,R01);
SNNB:  RETURN RESULT←R01;
SVXAD: TSI(ZSTX,RESULT←TSTEMP(TTINT));
       GOTO SVSAD;
SVAAD: TSSCR(RESULT←TSTEMP(A01.TTYPE));
SVSAD: TSI(ZEAX,RESULT);
       IF M01=RADDRA DO;
               TSW(ZZCXA);
       ELSEIF M01=RADDRS DO;
SZSTX:         TSI(ZSTX,RESULT←TSTEMP(TTINT));
       ENDIF;
       RETURN RESULT;
SVXIX: A01.TADDR←U(ATREL,INSTAG)+U(ASTIMX,INSST);
       RESULT←A01;
       RMODE←RADDR;
       RETURN RESULT;
SAABB: TSW(ZZCAX);
       RMODE←RADDRX;
       GOTO SGO;
SAXVB: A01.TADDR←U(ATPD,INSTAG)+U(PDPXR,PDPTR);
       RESULT←A01;
       RMODE←RADDR;
       GOTO SGO;
SASVB: RMODE←RADDR;
SAS2:  TSIND(RESULT,RESULT//SAS1);
       GOTO SGO;
SAS1:  TSSCR(RESULT←TSTEMP(TTINT));
       GOTO SAS2;
* OPERAND VALUE ERROR
SXERR: CERR(50);
* NO VALUE GENERATED
SVERR: CERR(104);

***
*** TSMA(A)
***
* TEST WHETHER THE TREE AT A IS A SIMPLE MACHINE ADDRESS
* RETURN RVALS, RADDR, OR 0 AS APPROPRIATE



       PROGRAM TSMA;
       INCLUDE SGEN';
* RECURSIVE LOCAL VARIABLES
       DECLARE POINTER P02,Q02;

       DI OP02,R02,S02;

FUNCTION TSMA(POINTER A02);
       OP02←A02.TOPR;
       IF OP02=OPVAR DO;
               RETURN (0 IF A02.TDEF#0 AND (A02.TTYPE=TTLAB OR
                A02.TTYPE=TTFUNC) ELSE RVALS);
       ELSEIF OP02=OPCON DO;
               RETURN (RVALS IF A02.TADDR#0 AND A02.TADDR$INSTAG=ATD
                ELSE 0) IF A02.TTYPE=TTSTR;
               TSCAN(A02,RVALS) IF A02.TADDR=0;
               RETURN RVALS;
       ELSEIF OP02=OPINDIR DO;
               RETURN 0 IF TSMA(P02←F(A02,TO1))=0;
               TSIND(P02,A02//TSMA0);
               RETURN RADDR;
       ELSEIF OP02=OPBX DO;
               RETURN 0 IF (TSMA(P02←A02.TO1)
          A' TSMA(Q02←A02.TO2))=0;* MUST BOTH BE RVALS
               R02←U(ATBX,INSTAG)+
          U(TSMFIT(P02.TADDR,FRMASK(BXBASE)//TSMA0),BXBASE)+
          U(TSMFIT(Q02.TADDR,FRMASK(BXINDEX)//TSMA0),BXINDEX);
       ELSEIF OP02=OPPD DO;
               RETURN 0 IF (TSMA(Q02←A02.TO1)
          A' TSMA(P02←A02.TO2))=0;* MUST BOTH BE RVALS
               R02←F(P02,TADDR);
               RETURN 0 IF R02$INSTAG#ATREL OR R02$INSST#ASTIM;
               R02←SE(R02$INSIMV,INSIMV);
               RETURN 0 IF R02<-FRMASK(PDDISP)/2-1 OR R02>FRMASK(PDDISP)/2;
               R02←U(ATPD,INSTAG)+
               U(TSMFIT(Q02.TADDR,FRMASK(PDPTR)//TSMA0),PDPTR)
               +U(R02,PDDISP);
       ELSE DO;
TSMA0:         RETURN 0;
       ENDIF;
       E(A02,TADDR,R02);
       RETURN RADDR;

***
*** TSIND(A,B)
***
* PUT INTO B.TADDR THE INDIRECT EQUIVALENT OF A.TADDR
* FRETURN IF A.TADDR=0 OR THE RESULT IS NOT A SIMPLE ADDRESS
* RETURN NO VALUE OTHERWISE



       PROGRAM TSIND;
       INCLUDE SGEN';


FUNCTION TSIND(POINTER A05,B05), FRETURN;
       B05.TADDR←TSIIA(A05.TADDR//FRETN);
       RETN;


***
*** TSIIA(W)
***
* RETURN THE INDIRECT EQUIVALENT OF THE
* INSTRUCTION ADDRESS W, FRETURN IF NOT POSSIBLE



       PROGRAM TSIIA;
       INCLUDE SGEN';

       DI T05;
       DQ Z05←37777776B;
       DA QT05[7]←(ATI@INSTAG-ATD@INSTAG,Z05,Z05,Z05,
        ATIPD@INSTAG-ATPD@INSTAG,Z05,Z05);
       DA QS05[8]←(ASTILR@INSST-ASTLR@INSST,Z05,
        ARTISR@INSRT-ARTSR@INSRT,ARTISR@INSRT-ARTSR@INSRT,
        Z05,Z05,Z05,Z05+1);

FUNCTION TSIIA(R05), FRETURN;
TSIN1: IF R05=0 DO;
           FRETN;
       ELSEIF (T05←(QT05[T05] IF (T05←R05$INSTAG)#ATREL ELSE
        QS05[R05$INSST]))<Z05 DO;
           RETN R05+T05;
       ELSEIF T05#Z05 DO;
           TSGL(1);
           PUT(VAA,R05$INSIMV);
           R05←VINSA;
           GOTO TSIN1;
       ELSE DO;
           FRETN;
       ENDIF;

***
*** TSW(X)
***
* STORE THE WORD X IN THE OUTPUT CODE



       PROGRAM TSW;
       INCLUDE SGEN';


FUNCTION TSW(X07);
       IF CODEFLAG DO;
               TSIH();
               FIOUT(X07,-1,4B7,8);
               COUT('&/', -1);
       ENDIF;
       PUT(CODETOP+RELLOC-RELORG,X07);
       RELLOC←RELLOC+1;
       CFLAGS←U(1,CFTF);
       RETURN;


***
*** TSIH()*
***
* PRINT INSTRUCTION HEADER


FUNCTION TSIH();
       IF (RELLOC AA 3)=0 DO;
               FIOUT(RELLOC,-1,0,8);
               COUT(')', -1);
       ENDIF;
       COUT(' ', -1);
       RETURN;

       PROGRAM TSTDX;
       INCLUDE SGEN';
***
*** TSLCR(A)
***  LOAD REGISTERS FROM A.TADDR
*** TSSCR(A)
***  STORE REGISTERS IN A.TADDR
*** TFAO(A,C)
***  ARITHMETIC OPERATION WITH A.TADDR:
***   USE C[0] FOR INTEGER, C[1] FOR REAL, C[2] FOR COMPLEX
*** TFCP(A)
***  COMPARE AGAINST A.TADDR
*** TFNEG(A)
***  COMPILE A NEGATE OF THE TYPE OF A
***

       DECLARE ARRAY TSLCA[5]←(ZLDA,ZFLD,ZLDD,ZLDD,ZLDA),
        TSSCA[5]←(ZSTA,ZSTF,ZSTD,ZSTD,ZSTA),
        TFCPA[2]←(ZICP,ZFCP),
        TFNEGA[3]←(ZZCNA,ZZFNEG,ZZCFNEG);
       DECLARE ARRAY C09;
       DI T09;

FUNCTION TSLCR(POINTER A09);
       C09←ARRAY'FIXER(TSLCA);
TSTD1: TSDP(T09←A09.TTYPE);
       TSI(C09[TTDTAB[T09]],A09);
       RETURN A09;

FUNCTION TSSCR(A09);
       C09←ARRAY'FIXER(TSSCA);
       GOTO TSTD1;

FUNCTION TFAO(A09,C09);
       GOTO TSTD1;

FUNCTION TFCP(A09);
       RETURN IF A09.TOPR=OPCON AND A09.TO1=0 AND CCOK;
       C09←ARRAY'FIXER(TFCPA);
       GOTO TSTD1;

FUNCTION TFNEG(A09);
       TSDP(T09←A09.TTYPE);
       TSW(TFNEGA[TTDTAB[T09]]);
       RETURN;

***
*** TSMFIT(A,K)*
***
* ATTEMPT TO FIT THE MACHINE ADDRESS A INTO THE FIELD WITH FRMASK K
* RETURN THE RESULT IF IT FITS
* OTHERWISE FRETURN



       PROGRAM TSMFIT;
       INCLUDE SGEN';

       DI D10;

FUNCTION TSMFIT(A10,K10), FRETURN;
       K10←K10 RSH 1;
       IF A10$INSTAG=ATD DO;
               FRETN IF (D10←A10$INSGD)=0 OR D10>K10
          ELSE RETN D10;
       ELSEIF A10$INSTAG=ATREL AND A10$INSST=ASTLR DO;
               FRETN IF (D10←A10$INSLRD)>K10 ELSE RETN K10+1+D10;
       ELSE DO;
               FRETN;
       ENDIF;

***
*** TSI(P,A) ###
***
* OUTPUT AN INSTRUCTION FORMED FROM OPCODE P AND ADDRESS A.TADDR
* RETURN NO VALUE
***
*** TSA(C,A)
***
* STORE AN INSTRUCTION WITH OPCODE C AND ADDRESS A



       PROGRAM TSI;
       INCLUDE SGEN';

       DS H13←"# #:#/";
* FIELDS FOR TIOPT
       DF IPRF(0:6,14);* FLAGS TO RESET
       DF IPSF(0:15,23);* FLAGS TO SET
       DF IPSWI(0:0,5);* OPTIMIZATION ROUTINE (TISW INDEX)
* OPTIMIZATION CODE TABLE
* (REFER TO SGDEC FOR FLAGS)
       DECLARE OCTAL ARRAY TIOPT[NOPS]←(
        00000040B,01000045B,00005040B,02000042B,
        03000045B,02000042B,02000042B,04000045B,
        00001044B,00001044B,00001044B,05020051B,
        05020051B,04000041B,00000040B,06000042B,
        00001044B,00001044B,00001044B,00001044B,
        07001045B,00002040B,07001045B,07001045B,
        00005040B,00001044B,00004040B,00004040B,
        00004040B,00004040B,00004040B,00037040B);
       DECLARE OCTAL ARRAY TIOPT[40B]←(
        00001044B,00001044B,00001044B,00001044B,
00001044B,00001044B,00004040B,00002040B,
        00040000B,00000040B,00000040B,00000040B,
        00000040B,00000040B,00000040B,00033044B,
        00033044B,00002040B,00037040B,00034040B,
        00007040B,00000040B,00000040B,00000040B,
        02000042B,03000045B,00024050B,00001044B,
        00001044B,00001044B,00001044B,00007040B);
       DECLARE OCTAL ARRAY TIOPT[100B]←(
        10B6,11B6,12B6,17B6,17B6,17B6,17B6,17B6,
        13B6,14B6,15B6,16B6,17B6,17B6,17B6,17B6);
* OPTIMIZATION ROUTINE SWITCH
       DECLARE SWITCH TISW[16]←(
        TIRET,TILDA,TILDX,TILDD,TISTA,TISTD,TISTX,TIAM,
        TIIMUL,TIIDIV,TIIMOD,TICFAD,TICFSB,TICFMP,TICFDV,TIERR);
       DI W13,V13,R13,C13;

FUNCTION TSI(P13,POINTER A13);
TSI0:  R13←W13←U(P13,INSOP) VV F(A13,TADDR);
       IF P13>=200B DO;
            C13←TIOPT[ZBLL];
            W13$INSPOP←1;
       ELSE DO;
            C13←TIOPT[P13];
       ENDIF;
       GOTO LABEL'FIXER(TISW[C13$IPSWI]);
TIRET: CFLAGS←CFLAGS AA NN C13$IPRF VV C13$IPSF;
TIENT: V13←W13 AA (FMASK(INSTAG)+FMASK(INSRT));
       IF V13=U(ATREL,INSTAG)+U(ARTSR,INSRT)
   OR V13=U(ATREL,INSTAG)+U(ARTISR,INSRT) DO;
               W13$INSSRD←W13$INSSRD-RELLOC;
       ENDIF;
       PUT(CODETOP+RELLOC-RELORG,W13);
       IF CODEFLAG DO;
               TSIH();
               FMTO(H13);
               OUT(P13);
               OUT(W13$INSTAG);
               OUT(W13$INSGD);
       ENDIF;
       RELLOC←RELLOC+1;
       RETURN;
* INDIVIDUAL OPTIMIZATION ROUTINES
TIAM:
TISTA: R13$INSOP←ZLDA;
TILDA: /*RETURN IF CONTA=R13;*/
       CONTA←R13;
       GOTO TIRET;
TISTX: R13$INSOP←ZLDX;
TILDX: /*RETURN IF CONTX=R13;*/
       CONTX←R13;
* KLUDGE TO MAKE SURE WE DON'T GENERATE EAX OR EAC WITH IMMEDIATE OPERAND
       IF (P13 = ZEAX OR P13 = ZEAC) DO;
           IF (CONTX$INSTAG = ATREL AND CONTX$INSST = ASTIM) DO;
               PUT(TSGL(1), CONTX$INSIMV);
               R13 ← W13 ← P13@INSOP V' VINSA;
           ENDIF;
       ENDIF;
       AOK←CONTA←0 IF CONTA$INSTAG#ATD AND (CONTA$INSTAG#ATREL
   OR CONTA$INSST#ASTLR AND CONTA$INSRT#ARTSR);
       GOTO TIRET;
TISTD: R13$INSOP←(ZFLD IF P13=ZSTF ELSE ZLDD);
TILDD: AOK←CONTA←0 IF CFLAGS$CNDPF=0 /*ELSE RETURN IF CONTA=W13*/
        ELSE CONTA←W13;
       GOTO TIRET;
* PSEUDO OPCODES
TIIMUL:TSI(ZMUL,A13);
       TSW(U(ZASHD,INSOP)+IQ(23));
       RETURN;
TIIDIV:TSW(U(ZASHD,INSOP)+IQ(-23));
       P13←ZDIV;
       GOTO TSI0;
TIIMOD:TSI(ZIDIV,A13);
       TSW(ZZCBA);
       RETURN;
* UNIMPLEMENTED PSEUDO INSTRUCTIONS
TICFAD:TSW(U(ZHLT,INSOP)+IQ(110B));
       RETURN;
TICFSB:TSW(U(ZHLT,INSOP)+IQ(111B));
       RETURN;
TICFMP:TSW(U(ZHLT,INSOP)+IQ(112B));
       RETURN;
TICFDV:TSW(U(ZHLT,INSOP)+IQ(113B));
       RETURN;
* ERROR IN INDEX TO TIOPT
TIERR: CERR(94);

ENTRY TSA(P13,V13);
       W13←U(P13,INSOP) VV V13;
       C13←TIOPT[ZEXU];
       GOTO TIRET;

***
*** TSBI(P,A)
***
* OUTPUT AN INSTRUCTION FORMED FROM OPCODE P AND THE
* BRANCH ADDRESS (LABEL OR GENERATED) IN NODE A



       PROGRAM TSBI;
       INCLUDE SGEN';

       DI W14,V14;

FUNCTION TSBI(P14,POINTER A14);
       P14←U(P14,INSOP);
TSBI1: W14←U(ATREL,INSTAG)+U(ARTSR,INSRT)+P14;
       V14←TSUL(A14,RELLOC);
       IF A14.BACHN=0 DO;
               TSW(W14+U(V14 IF A14.BAABS ELSE V14-RELLOC,INSSRD));
       ELSE DO;
               TSW(W14+U(V14,INSSRD));
               CONTA←0 IF AOK=0;
               CONTX←0 IF XOK=0;
               IF F(A14,BAREF) DO;
                       E(A14,BACA,0) IF F(A14,BACA)#CONTA;
                       E(A14,BACX,0) IF F(A14,BACX)#CONTX;
               ELSEIF A14.TOPR#OPVAR DO;
                       E(A14,BAREF,1);
                       E(A14,BACA,CONTA);
                       E(A14,BACX,CONTX);
               ENDIF;
       ENDIF;
       RETURN;


***
*** TSBA(W,A)
***
* OUTPUT A BRANCH INSTRUCTION FORMED FROM THE WORD W
* AND THE BRANCH ADDRESS IN NODE A

ENTRY TSBA(P14,POINTER A14);
       GOTO TSBI1;

***
*** TSUL(A,L)*
***
* PREPARE TO USE BRANCH NODE A AT REL. LOC. L
* RETURN THE INSSRD FIELD OF THE WORD TO STORE



       PROGRAM TSUL;
       INCLUDE SGEN';

       DI C14;
       DP TP14,SP14;

FUNCTION TSUL(POINTER Z14,INTEGER L14);
       C14←Z14.BALOC;
       IF Z14.BACHN DO;
               Z14.BALOC←L14+(FRMASK(INSSRD)/2+1);
               IF Z14.TOPR=OPVAR DO;
                       SSPTR(Z14.TVTOKEN:TP14,SP14);
                       SP14.SYVAL←Z14.BADWORD;
               ENDIF;
       ELSEIF L14<0 DO;
               C14←C14-L14;
       ENDIF;
       RETURN C14;


***
*** TSBU(A,P)
***
* GENERATE A REFERENCE TO THE BRANCH NODE A
* PUT THE DESCRIPTOR AT P (IN LITBUF)



       PROGRAM TSBU;
       INCLUDE SGEN';


FUNCTION TSBU(POINTER X14,B14);
       PUT(B14+FNEWP,U(ATREL,IWTAG)+U(ARTSR,IWRT)+
   TSUL(X14,B14-ELITBUF));
       PUT(B14+FNEWL,0);
       RETURN;

***
*** TSBRA()
***
* GENERATE A BRANCH LOCATION NODE
* RETURN THE ABSOLUTE ADDRESS



       PROGRAM TSBRA;
       INCLUDE SGEN';

       DP A16;
       DECLARE ARRAY IA16[BANLE]←(
        0, U(1,BWCHN), U(OPBRANCH,TOPR), 0,
        0, 0, 0);

FUNCTION TSBRA();
       A16←TSGT(BANLE);
       CPCOPY(A16,@IA16[0],BANLE);
       RETURN A16;

***
*** TSBDEF(A)
***
* DEFINE THE BRANCH LOCATION NODE AT ADDRESS A



       PROGRAM TSBDEF;
       INCLUDE SGEN';

       DS H17←" (#)#/";
       DI L17,R17,T17,W17;
       DP P17;

FUNCTION TSBDEF(POINTER A17);
       T17←A17.BADWORD;
* ATTEMPT TO REDEFINE BRANCH POINT ?
       CERR(51) IF T17$BWCHN=0;
       A17.BADWORD←U(ATREL,INSTAG)+U(ARTSR,INSRT)+U(RELLOC,INSSRD);
       IF T17$BWREF DO;
               IF FLOWTHRU=0 DO;
                       CFLAGS←A17.BACF;
                       CONTA←F(A17,BACA);
                       CONTX←F(A17,BACX);
               ELSE DO;
                       CFLAGS←CFLAGS AA A17.BACF VV U(1,CFTF);
                       AOK←0 IF F(A17,BACA)#CONTA;
                       XOK←0 IF F(A17,BACX)#CONTX;
               ENDIF;
       ELSE DO;
               A17.BAREF←1;
TSBD1:         CFLAGS←U(1,CFTF);
       ENDIF;
       WHILE L17←SE(T17$INSSRD,INSSRD) DO;
               IF (R17←L17←L17 XOR NN (FRMASK(INSSRD)/2))<0 DO;
                       P17←ELITBUF+L17;
               ELSE DO;
                       P17←(A(CODETOP,L17-RELORG) IF L17>=RELORG
                   ELSE A(ICCODE,L17));
               ENDIF;
               W17←T17←GET(P17);
               W17$INSSRD←RELLOC-R17;
               PUT(P17,W17);
               IF CODEFLAG DO;
                       FMTO(H17);
                       OUT(L17);
                       OUT(W17);
               ENDIF;
       ENDFOR;
       LASTB←RELLOC;
       RETURN;


***
*** TSBDW(X)
***
* DEFINE THE BRANCH LOCATION WITH DATA WORD X

ENTRY TSBDW(T17);
* ATTEMPT TO REDEFINE BRANCH POINT ?
       CERR(51) IF T17$BWCHN=0;
       GOTO TSBD1;

***
*** TSFVAL(C,M)*
***
* FORCE THE CODE TO GENERATE A 0 OR 1 VALUE
* C IS ZLDA OR ZLDX TO INDICATE THE REGISTER
* M IS RTXFER OR RFXFER TO SHOW THE CONDITION UNDER WHICH
* THE EXISTING CODE BRANCHES TO RESULT



       PROGRAM TSFVAL;
       INCLUDE SGEN';

       DI V18;

FUNCTION TSFVAL(C18,M18);
       TSA(C18,V18←IQ(M18=RFXFER));
       TSW(U(ZBRU,INSOP)+RQ(2));
       TSBDEF(RESULT);
       TSA(C18,V18 XOR U(1,INSIMV));
       RETURN;

***
*** TSGT(N)
***
* GET N WORDS OF TREE SPACE, RETURNING THE ABSOLUTE ADDRESS
* ERROR IF SPACE EXHAUSTED



       PROGRAM TSGT;
       INCLUDE SGEN';

       DP P22;

FUNCTION TSGT(N22);
* TREE AREA FULL ?
       CERR(86) IF (P22←TREETOP)+N22>TREEMEM;
       TREETOP←TREETOP+N22;
       RETURN P22;

***
*** TSDP(T)
***
* SET THE TEMPORARY DP FLAG AS APPROPRIATE FOR TYPE T:
* OFF FOR REAL, LONG, LABEL, ARRAY;
* ON FOR DOUBLE, COMPLEX, STRING, LONGLONG;
* DON'T CARE FOR OTHER TYPES



       PROGRAM TSDP;
       INCLUDE SGEN';

       DECLARE ARRAY DPFTAB[5]←(0,0,1@CNDPF,0,1@CDPF);
       DI N24;

FUNCTION TSDP(T24);
       N24←DPFTAB[TTLTAB[T24]];
       RETURN IF N24=0 OR CFLAGS A' N24#0;
       TSW(ZZDP IF N24=U(1,CDPF) ELSE ZZNDP);
       CFLAGS←(CFLAGS A' N' (U(1,CNDPF)+U(1,CDPF))) V' N24;
       RETURN;

***
*** TFLAB(A)
***
* MAKE THE VARIABLE IN NODE A INTO A LABEL IF UNDEFINED
* RETURN 1 IF RESULT IS A LABEL, 0 IF NOT



       PROGRAM TFLAB;
       INCLUDE SGEN';

       DP TP06,SP06;

FUNCTION TFLAB(POINTER A06);
       RETURN 0 IF A06.TOPR#OPVAR OR A06.TVTOKEN=0;
       RETURN 1 IF A06.TTYPE=TTLAB AND A06.TDEF#0;
       RETURN 0 IF A06.TTYPE#TTUND;
       SSPTR(A06.TVTOKEN:TP06,SP06);
       RETURN 0 IF SP06.SYVAL;
       TP06.TKTYPE←TTLAB;
       TP06.TKIMPL←1;
       TP06.TKPARAM←1;
       A06.TADDR←SP06.SYVAL←U(1,BACHN);
       A06.TDEF←1;
       A06.TTYPE←TTLAB;
       RETURN 1;

***
*** TFIV(A,T,L)
***
* CHECK TO MAKE SURE THAT A IS A CONSTANT OF TYPE T
* (IF T<0, AN INTEGER LIST OF LENGTH -T)
* THEN STORE ITS VALUE INTO THE LITERAL AREA
* EXCEPT IF IT IS AN INTEGER EXPRESSIBLE AS AN IMMEDIATE ADDRESS
* (THIS ROUTINE IS FOR INITIALIZED VARIABLES)
* RETURN THE ADDRESS
* IF L#0, STORE THE VALUE AT L IN ANY CASE
* (THIS IS FOR INITIALIZED ARRAYS)
* RETURN NOTHING IN PARTICULAR



       PROGRAM TFIV;
       INCLUDE SGEN';
* RECURSIVE LOCAL VARIABLES
       DECLARE POINTER P53;

       DI I53,K53,V53,N53,W53,S53;
       DECLARE INTEGER GARBAGE;
       DP Q53,TP53,SP53,MS53;
       DM VCERR(X)←(CERR(X) & GOTO TFVE);

FUNCTION TFIV(POINTER A53,INTEGER T53,POINTER L53);
       N53←(TTLTAB[T53] IF T53>=0 ELSE -T53);
       P53←(L53 IF L53#0 OR T53=TTINT OR T53=TTSTR AND
   ICTYPE=IBTFN ELSE TSGL(N53));
       V53←VINSA;
       IF T53=TTLONG OR T53=TTLLONG OR T53<0 DO;
               IF A53.TOPR=OPCON AND A53.TTYPE=TTSTR DO;
* INITIALIZATION OF WRONG SIZE ?
                       VCERR(95) IF A53.TO3#N53*(4-A53.TO2);* CONTINUES
                       MS53←STPTR(A53.TO1);
               ELSE DO;
* INITIALIZATION OF WRONG SIZE ?
                       VCERR(95) IF TFCIL(A53,TTINT,P53,N53)#0;* CONTINUES
                       RETURN VINSA;
               ENDIF;
       ELSEIF T53=TTFUNC DO;
*** WHAT ABOUT SYSCALLS?
               IF A53.TOPR#OPVAR DO;
* INITIALIZATION VALUE IS NOT A CONSTANT
                       VCERR(53);* CONTINUES
               ELSEIF A53.TTYPE=TTUND DO;
                       W53←YGFD(A53.TVTOKEN:,GARBAGE,GARBAGE)+GBASE;
               ELSEIF A53.TTYPE=TTFUNC AND A53.TDEF#0 DO;
                       W53←A53.TADDR$INSGD+GBASE;
               ELSE DO;
* INITIALIZATION VALUE OF WRONG TYPE
                       VCERR(55);* CONTINUES
               ENDIF;
               PUT(P53,W53);
               RETURN VINSA;
       ELSEIF T53=TTLAB DO;
* INITIALIZATION CONSTANT OF WRONG TYPE ?
               VCERR(55) IF TFLAB(A53)=0;* CONTINUES
               TSBU(A53,P53);
               RETURN VINSA;
       ELSEIF A53.TTYPE#T53 DO;
* INITIALIZATION CONSTANT OF WRONG TYPE
               VCERR(55);* CONTINUES
       ELSEIF T53=TTARRAY DO;
* INITIALIZATION VALUE IS NOT A CONSTANT ?
               VCERR(53) IF A53.TOPR#OPVAR OR A53.TDEF=0;* CONTINUES
               W53←A53.TADDR;
               IF W53$INSTAG=ATD DO;
                       P53←GBASE+W53$INSGD;
               ELSE DO;* MUST BE SOURCE-RELATIVE, NEGATIVE
                       P53←ELITBUF+W53$INSSRD-(FRMASK(INSSRD)+1);
               ENDIF;
               UMOVE(L53,P53,N53);
               RETURN VINSA;
       ELSEIF A53.TOPR#OPCON AND A53.TOPR#OPSC DO;
* INITIALIZATION VALUE IS NOT A CONSTANT
               VCERR(53);* CONTINUES
       ELSEIF T53=TTSTR DO;
               TLSC(A53:N53,S53);
               K53←(P53>=LITBUF AND P53<ELITBUF OR P53=0);
               Q53←TSGL((N53+S53-1)/S53+K53);
               W53←I53←U(4-S53,SIWCS)+U(IWTSTR,IWTYPE);
               I53$SIWCA←3-I53$SIWCS;
               W53←(W53+U((N53-1) MOD S53,SIWCA)+U((N53+S53-1)/S53,
          SIWWA) IF N53 ELSE I53);
               IF K53 DO;
                       PUT(Q53,W53);
                       Q53←Q53+1;
               ELSE DO;
                       VINSA←V53;
                       PUT(P53+FDISP(SL),PUT(P53+FDISP(SR),
                  I53+U(Q53-1,SIWWA)));
                       PUT(P53+FDISP(SW),PUT(P53+FDISP(SU),
                  W53+U(Q53-1,SIWWA)));
               ENDIF;
               IF L53#0 AND K53#0 DO;
* MUST BE LOCAL STRING ARRAY
                       PUT(L53,U(ATREL,IWTAG)+U(ARTSR,IWRT)+
                  U(Q53-1-L53,IWSRD));
               ENDIF;
               TSSC(A53,Q53,0:GARBAGE,GARBAGE);
               RETURN VINSA;
       ELSEIF T53=TTINT AND L53=0 AND
   (I53←A53.TOIV)>=-FRMASK(INSIMV)/2-1 AND I53<=FRMASK(INSIMV)/2 DO;
               RETURN (IQ(I53));
       ELSE DO;
               P53←TSGL(N53) IF L53=0 AND T53=TTINT;
               MS53←A53+FDISP(TO1);
       ENDIF;
       PUT(P53+I53,CONTENTS(MS53+I53)) FOR I53←0 TO N53-1;
       RETURN VINSA;
* ERROR CLEANUP
TFVE:  PUT(P53,U(1,IWTRAP));
       RETURN VINSA;

***
*** TFCIL(A,T,L,N)
***
* COLLECT INITIALIZATION VALUES OF TYPE T ON CHAIN A
* STORE AT ADDRESS L, ALLOW AT MOST N
* RETURN N - ACTUAL NUMBER OF VALUES COLLECTED



       PROGRAM TFCIL;
       INCLUDE SGEN';


FUNCTION TFCIL(POINTER A23,INTEGER T23,POINTER L23,INTEGER N23);
       RETURN N23 IF A23.TOPR=OPNIL;
* INITIALIZATION LIST TOO LONG ?
       (CERR(96) & RETURN 0) IF N23=0;* CONTINUES
       IF A23.TOPR#OPLIST DO;
               TFIV(A23,T23,L23);
               RETURN N23-1;
       ENDIF;
       A23←A23.TO1;
       WHILE A23.TOPR#OPNIL DO;
* INITIALIZATION LIST TOO LONG ?
               (CERR(96) & RETURN 0) IF N23=0;* CONTINUES
               TFIV(A23.TO1,T23,L23);
               N23←N23-1;
               L23←L23+(1 IF T23=TTSTR AND L23>=LITBUF
          AND L23<ELITBUF ELSE TTLTAB[T23] IF T23>=0 ELSE -T23);
               A23←A23.TO2;
       ENDFOR;
       RETURN N23;

***
*** TLSC(A)*
***
* COMPUTE LENGTH AND CHARACTER SIZE OF (CHAINED) STRING CONSTANT



       PROGRAM TLSC;
       INCLUDE SGEN';

       DI N24,F24,S24,T24;
       DP SP24;

FUNCTION TLSC(POINTER A24);
       N24←0;
       F24←-1;
       WHILE A24 DO;
            NODE←A24;
            S24←4-A24.TO2;
            IF F24=-1 DO;
                 F24←S24;
            ELSEIF S24#F24 DO;
* ATTEMPT TO MIX 6- AND 8-BIT STRINGS ?
                 CERR(177);* CONTINUES
                 S24←4;* JUST IN CASE
                 N24←N24+1;* DITTO
            ENDIF;
            N24←N24+A24.TO3;
            A24←(A24.TO2 IF A24.TOPR=OPSC ELSE 0);
       ENDFOR;
       RETURN (N24,F24);

***
*** TSSC(A,X,B)*
***
* STORE (CHAINED) STRING CONSTANT A IN USER SPACE STARTING AT
* WORD X, BIT B.  RETURN FIRST AVAILABLE X AND B



       PROGRAM TSSC;
       INCLUDE SGEN';

       DP P25;
       DI N25,F25,I25,S25,M25,MM25,BB25;
       DECLARE ARRAY MA25[2]←(77B6,776B5);
       DECLARE ARRAY BS25[2]←(6,8);

FUNCTION TSSC(POINTER A25,X25,INTEGER B25);
       TSSC(A25.TO4,X25,B25:X25,B25) IF A25.TOPR=OPSC;
       P25←STPTR(A25.TO1);
       F25←A25.TO2;
       N25←A25.TO3;
       S25←BS25[F25];
       MM25←M25←MA25[F25] RCY B25;
       BB25←B25;
       FOR I25←0 TO N25-1 DO;
            PUT(X25,GET(X25) AA NN M25 VV ($P25 RCY BB25)
          AA M25);
            M25←M25 RCY S25;
            (X25←X25+1 & B25←B25-24) IF (B25←B25+S25)>=24;
            P25←P25+1 IF M25=MM25;
       ENDFOR;
       RETURN (X25,B25);

***
*** TFGET(N)
***
* GET N WORDS IN THE LOCAL OR GLOBAL ENVIRONMENT
* RETURN THE APPROPRIATE MACHINE ADDRESS



       PROGRAM TFGET;
       INCLUDE SGEN';

       DI K55;

FUNCTION TFGET(N55);
       IF ABSLOC>=0 DO;
               VIWA←U(ATD,IWTAG)+U(VAA←ABSLOC,IWGD);
               ABSLOC←-1;
               RETURN VINSA←U(ATD,INSTAG)+U(VAA-GBASE,INSGD);
       ELSEIF ICTYPE=IBTFN DO;
               K55←BASLR;
               ICBA.IBBLR←CURLR←BASLR←BASLR+N55;
               MAXLR←CURLR IF CURLR>MAXLR;
               VIWA←U(ATREL,IWTAG)+U(ASTLR,IWST)+U(K55,IWLRD);
               RETURN VINSA←U(ATREL,INSTAG)+U(ASTLR,INSST)+U(K55,INSLRD);
       ELSE DO;
               TAW(N55);
               RETURN VINSA;
       ENDIF;

***
*** TSGL(N)
***
* ACQUIRE N WORDS IN THE LITERAL BUFFER
* RETURN THE ACTUAL ADDRESS IN THE BUFFER



       PROGRAM TSGL;
       INCLUDE SGEN';

       DI K20;

FUNCTION TSGL(N20);
       IF ABSLOC>=0 DO;
            TFGET(N20);
       ELSEIF ICTYPE=IBTCB DO;
            VAA←(K20←TAD(N20))+GBASE;
            VINSA←U(ATD,INSTAG)+U(K20,INSGD);
            VIWA←U(ATD,IWTAG)+U(VAA,IWGD);
       ELSE DO;
            LITLOC←LITLOC-N20;
            GOTO TSGLE IF (VAA←ELITBUF+LITLOC)<LITBUF;
            VINSA←U(ATREL,INSTAG)+U(ARTSR,INSRT)+U(LITLOC,INSSRD);
            VIWA←U(ATREL,IWTAG)+U(ARTSR,IWRT)+U(LITLOC,IWSRD);
       ENDIF;
       RETURN VAA;
* CONSTANT AREA FULL
TSGLE: CERR(105);

***
*** TFGSEQ(K,A,L,M)
***
* FIND FIRST SEQUENCE OF K 1'S IN BIT TABLE AT ADDRESS A
* START AT INDEX L IN THE TABLE, STOP AT (BEFORE) M
* CLEAR THE SEQUENCE AND RETURN THE INDEX IF FOUND
* FRETURN IF NO SEQUENCE FOUND
* IF K IS EVEN, FORCE THE RESULT TO START AT AN EVEN LOCATION



       PROGRAM TFGSEQ;
       INCLUDE SGEN';

       DP P62;
       DI I62,W62,B62,N62,S62;

FUNCTION TFGSEQ(K62,POINTER A62,INTEGER L62,M62), FRETURN;
       L62←L62+(L62 AA NN K62 AA 1);
       P62←A62+L62/24;
       I62←L62 MOD 24;
       L62←L62-I62;
       B62←(-1 IF K62 AA 1 ELSE 52525252B);
       W62←$P62 LSH I62;
       WHILE L62<M62 DO;
            P62←P62+1;
            S62 ← B62;
            WHILE W62 AA S62 DO;
                 IF W62>0 DO;
                      I62←I62+(N62←FLLO(W62 AA S62));
                      W62←W62 LSH N62;
                      S62 ← S62 LSH N62;
                 ENDIF;
                 IF K62<=24 AND (NN W62) RSH (24-K62)=0 DO;
TFGSX:                FRETN IF (L62←L62+I62)+K62>M62;
                      TFSSEQ(K62,A62,L62,0);
                      RETN L62;
                 ELSEIF (NN W62) RSH I62=0 DO;
                      FOR N62←K62+I62-24 BY -24 TO 24 DO;
                           GOTO TFGS1 IF $P62#-1;
                           P62←P62+1;
                      ENDFOR;
                      GOTO TFGSX IF (NN $P62) RSH (24-N62)=0;
                 ENDIF;
                 I62←I62+(N62←FLLO(NN W62));
                 W62←W62 LSH N62;
                 S62 ← S62 LSH N62;
            ENDFOR;
TFGS1:      L62←(P62-A62)*24;
            I62←0;
            W62←$P62;
       ENDFOR;
       FRETN;

***
*** TFSSEQ(K,A,L,V)
***
* SET K BITS IN THE BIT TABLE AT ADDRESS A TO V,
* STARTING AT INDEX L



       PROGRAM TFSSEQ;
       INCLUDE SGEN';

       DP P63;
       DI E63,I63,J63;

FUNCTION TFSSEQ(K63,POINTER A63,INTEGER L63,V63);
       V63←-1 IF V63;
       WHILE K63 DO;
            P63←A63+L63/24;
            J63←L63 MOD 24;
            I63←K63 IF (I63←24-J63)>K63;
            E63←(NN ((-1) RSH I63)) RSH J63;
            $P63←($P63 VV E63) AA (V63 VV NN E63);
            K63←K63-I63;
            L63←L63+I63;
       ENDFOR;
       RETURN;

***
*** TAD(N)
***
* ALLOCATE N WORDS IN RSGS
* ACQUIRE A NEW PAGE OF RSGS IF REQUIRED
* ERROR IF RSGS COLLIDES WITH WGS
* RETURN THE G-RELATIVE ADDRESS
* NOTE: BITS CORRESPOND TO CELLS IN *DESCENDING* ORDER



       PROGRAM TAD;
       INCLUDE SGEN',SDOPS;

       DI I80,J80,L80;

FUNCTION TAD(N80);
       RSGCTR←RSGCTR+N80;
TAD0:  RETURN ERSGA-N80-TFGSEQ(N80,RSGBIT,0,ERSGA-BRSGA//TAD1);
* READ-ONLY GLOBAL STORAGE FULL ?
TAD1:  CERR(115) IF BRSGA<=EWGA+MINSL OR BRSGA=LRSGA;
       I80←((GBASE+BRSGA-1) AA 3777B)+1;
       I80←LRSGA IF I80<LRSGA WHERE I80←BRSGA-I80;
       TFSSEQ(BRSGA-I80,RSGBIT,ERSGA-BRSGA,1);
       TFSSEQ((CODEBOT-FIXER),RSGBIT,0,0);
* RESET BITS CORRESPONDING TO TRANSFER VECTOR DESCRIPTORS
       FOR J80←0 TO NFLOC-1 DO;
            L80←TTVTAB[J80]$IWGD;
            L80←L80-GBASE IF TTVTAB[J80]>=0;
            TFSSEQ(2,RSGBIT,ERSGA-L80-2,0) IF L80>=LRSGA
          AND L80<BRSGA-1;
       ENDFOR;
       BRSGA←I80;
       GOTO TAD0;


***
*** TRD(N,L)
***
* RELEASE N WORDS OF RSGS AT G-RELATIVE ADDRESS L



       PROGRAM TRD;
       INCLUDE SGEN';


FUNCTION TRD(N81,L81);
* TRD ERROR ?
       CERR(119) IF N81<0 OR L81<BRSGA OR L81+N81>ERSGA;
       TFSSEQ(N81,RSGBIT,ERSGA-L81-N81,1);
       RETURN;

***
*** TNCA(A)*
***
* TEST IF THE TREE A CAN BE COMPUTED WITHOUT CLOBBERING (A)
* (THIS ROUTINE IS MORE CONSERVATIVE THAN NECESSARY)


       PROGRAM TNCA;
       INCLUDE SGEN';

       DI OP07;

FUNCTION TNCA(POINTER A07);
       IF TSMA(A07) DO;
          RETURN 1;
       ELSEIF (OP07←A07.TOPR)=OPNEG DO;
          RETURN (1 IF OP07.TTYPE=TTINT AND TNCA(A07.TO1) ELSE 0);
       ELSEIF OP07#OPBX AND OP07#OPPD DO;
          RETURN 0;
       ELSE DO;
          RETURN ((TSMA(A07.TO1)#0) A' (TSMA(A07.TO2)#0));
       ENDIF;

***
*** TSPP(A,B) ###
***
* GENERATE CODE FOR A IF B SIMPLE, FOR B IF A SIMPLE,
* AND (FOR B, STORE IN TEMP, FOR A) IF NEITHER SIMPLE
* RETURN (0 IF A LAST, 1 IF B) AND THE UNGENERATED OPERAND
***
*** TSPPZ(A,B,M)
***
* SAME AS TSPP, RESULT OF MODE M



       PROGRAM TSPP;
       INCLUDE SGEN';
* RECURSIVE LOCAL VARIABLES
       DECLARE INTEGER M08;


FUNCTION TSPP(POINTER A08,B08);
       M08←RVALA;
TSPP0: IF TSMA(B08) DO;
               TSCAN(A08,M08);
               RETURN (0,B08);
       ELSEIF TSMA(A08) DO;
               TSCAN(B08,M08);
               RETURN (1,A08);
       ELSE DO;
               A08←TSCAN(A08,RVALS);
               TSCAN(B08,M08);
               RETURN (1,A08);
       ENDIF;

ENTRY TSPPZ(A08,B08,M08);
       GOTO TSPP0;

***
*** TSTEMP(T)
***
* GENERATE A TEMPORARY OF TYPE T AND RETURN A NODE



       PROGRAM TSTEMP;
       INCLUDE SGEN';

       DI N15;
       DP A15;

FUNCTION TSTEMP(T15);
       N15←CURLR;
       CURLR←CURLR+TTLTAB[T15];
       MAXLR←CURLR IF CURLR>MAXLR;
       A15←TSGT(TOLE+1);
       E(A15,TO1,0);
       E(A15,TADDR,U(ATREL,INSTAG)+U(ASTLR,INSST)+U(N15,INSLRD));
       E(A15,TOPWORD,U(T15,TTYPE)+U(OPVAR,TOPR));
       RETURN A15;

***
*** TSWOP(A)
***
* GENERATE A TEMPORARY OF THE TYPE OF A
* STORE THE CENTRAL REGISTERS INTO IT
* AND LOAD THEM FROM A.TADDR
* RETURN THE TEMPORARY NODE



       PROGRAM TSWOP;
       INCLUDE SGEN';

       DP P19;

FUNCTION TSWOP(POINTER A19);
       TSSCR(P19←TSTEMP(A19.TTYPE));
       TSLCR(A19);
       RETURN P19;

***
*** TFGOTO(A)
***
* TEST IF THE NODE A IS A SIMPLE (BRU-TYPE) GOTO
* RETURN 1 AND THE LABEL NODE IF SO, 0 IF NOT



       PROGRAM TFGOTO;
       INCLUDE SGEN';

       DP P23;

FUNCTION TFGOTO(POINTER A23);
       P23←A23.TO1;
       IF A23.TOPR=OPGOTO AND TFLAB(P23)#0 DO;
               RETURN (1,P23);
       ELSE DO;
               RETURN (0,0);
        ENDIF;

***
*** TFIF(L,C)
***
* GENERATE NEW ENTRY ON IF STACK
* NEXT CLAUSE LABEL IS L, CONSTANT FLAG IS C
* ERROR IF THE TREE AREA IS FULL



       PROGRAM TFIF;
       INCLUDE SGEN';


FUNCTION TFIF(POINTER L24,INTEGER C24);
* BLOCK STACK FULL ?
       CERR(84) IF IFSTK-IFLE<TREETOP;
       IFSTK←IFSTK-IFLE;
       IFSTK.BSTKOP←OPENDIF;
       IFSTK.BSTKID←SSID;
       IFSTK.IFCLS←U(1,BACHN);
       IFSTK.IFNEXT←L24.BADWORD;
       IFSTK.IFCONST←C24;
       ILEV←ILEV+1;
       RETURN;

***
*** TFINC(X,Y)
***
* INCREMENT THE INTEGER VARIABLE WITH ADDRESS X
* BY THE QUANTITY WITH ADDRESS Y



       PROGRAM TFINC;
       INCLUDE SGEN';


FUNCTION TFINC(X25,Y25);
       IF Y25=IQ(1) DO;
            TSA(ZMIN,X25);
       ELSEIF Y25=IQ(-1) DO;
            TSA(ZMDC,X25);
       ELSE DO;
            TSA(ZLDA,Y25);
            TSA(ZADM,X25);
       ENDIF;
       RETURN;

***
*** TFFP(A)
***
* PROCESS THE VDEC OR VAR NODE A AS A FORMAL FUNCTION PARAMETER
* (OR POSSIBLY A STORE FOR A FUNCTION CALL)
* RETURN THE COMPLETE FORMAL PARAMETER WORD, EXCEPT FOR FPLAST



       PROGRAM TFFP;
       INCLUDE SGEN',SDOPS,SGTAB;

       DI T60,M60,PM60,R60;
       DP TP60,SP60;

FUNCTION TFFP(POINTER A60);
       PM60←FPMVAL;
       R60←FPCONT;
       IF A60.TOPR=OPVDEC DO;
               SSPTR(A60.TO1:TP60,SP60);
               T60←A60.TO2$DTYPE;
               M60←A60.TO2$DMODE;
               R60←FPADDR IF (A60.TO2)$DFREF;
       ELSEIF A60.TOPR=OPVAR DO;
               SSPTR(A60.TVTOKEN:TP60,SP60);
               T60←TP60.TKTYPE;
               M60←SP60.SYMODE;
       ELSE DO;
* STORE IS NOT INTO SIMPLE VARIABLE
               CERR(62);
       ENDIF;
       IF M60=SMARRAY OR M60=SMARR1 DO;
               PM60←FPMARR;
       ELSEIF M60#SMVALUE DO;
               T60←TMTTAB[M60];
       ENDIF;
       RETURN SP60.SYVAL+U(R60,FPADRF)+U(TFPTAB[T60],FPTYPE)+
   U(PM60,FPMODE);

***
*** TXVAR(A) ###
***
* CODE GENERATOR FOR VARIABLES



       PROGRAM TXVAR;
       INCLUDE SGEN';

       DI WX1;

FUNCTION TXVAR(POINTER AX1);
       IF AX1.TTYPE=TTLAB AND AX1.TDEF#0 DO;
               TSW(ZZCLA);
               TSW(ZZCAB);
               TSBI(ZEAX,AX1);
               TSW(ZZCXA);
               RETURN RVALA;
       ELSEIF AX1.TTYPE=TTFUNC AND AX1.TDEF#0 DO;
               TSI(ZEAX,AX1);
               RETURN RVALX;
       ELSE DO;
               RESULT←AX1;
               WX1←AX1.TADDR;
               RETURN (RVALS IF WX1$INSTAG=ATD OR WX1$INSTAG=ATREL AND
          (WX1$INSST=ASTLR OR WX1$INSRT=ARTSR) ELSE RADDR);
       ENDIF;

***
*** TXCON(A) ###
***
* CODE GENERATOR FOR CONSTANTS



       PROGRAM TXCON;
       INCLUDE SGEN';


FUNCTION TXCON(POINTER AX2);
       IF AX2.TADDR=0 OR AX2.TTYPE=TTFIELD AND AX2.TADDR=
   IQ(AX2.TADDR$INSIMV) DO;
               AX2.TADDR←TFIV(AX2,AX2.TTYPE,0);
       ENDIF;
       IF AX2.TTYPE=TTSTR AND AX2.TADDR$INSTAG=ATREL DO;
               TSI(ZEAX,AX2);
               TSW(ZZLSC);
               RETURN RVALA;
       ENDIF;
       RESULT←AX2;
       RETURN RVALS;

       COMMON PARSE';
       INCLUDE STBD,SCDEC,SCOPS,SDOPS,PSTO;

**************
* SPL PARSER *
*  STORAGE   *
**************


         DI T,I;

* NEED A GENERAL-PURPOSE POINTER
         DP PAGPTR;

* LABEL TO ALLOW CHKST TO RETURN TO PARSE
         DECLARE LABEL PARSXL;

* NEXT, CURRENT, AND PREVIOUS TOKENS UNDER CONSIDERATION
*        DI *NXTSYM,*THISYM,*PREVSYM;


       DECLARE EXTERNAL MCONNODE;



* THE PARSER IS CALLED BY
*      PARSE(SI FOR STATEMENT,TI WITHIN STATEMENT)
* IF THERE IS NO ERROR, IT RETURNS WITH THE CONSTRUCTED
* TREE NODE AS ITS VALUE.  IF THERE IS AN ERROR, IT
* ABORTS VIA CERR


* THE FOLLOWING FLAG IS A KLUDGE TO PREVENT EVALUATION OF ← IN AN
* EXPRESSION
         DI KNLARRF;
* FLAGS TO RESTRICT USE OF REGISTER SYMBOLS
* (G', L', R', X') TO MACHINE INSTRUCTIONS:
* BITS 0-3 OF THE WORD ALLOW THE RESPECTIVE SYMBOLS
         DI REGOK;


* WE DEFINE SYMBOLS FOR THE TERMINAL SYMBOL NUMBERS OF THE TERMINAL
* SYMBOLS

         DM DT(X)←DQ X←NTSI,NTSI←X+1;
         DQ NTSI←1;
DT(TSBEGIN);
DQ BEGUBOP←NTSI;
DT(TSPLUS); DT(TSMINUS); DT(TSDOLLAR); DT(TSAT);
DQ ENDUBOP←NTSI-1;
DT(TSNEQUAL); DT(TSAMPER); DT(TSLPAR);
DT(TSRPAR); DT(TSCOMMA);
DT(TSDOT); DT(TSCOLON); DT(TSSEMI);
DQ BEGDOP←NTSI;
DT(TSSTAR); DT(TSSLASH); DT(TSLESS);
DT(TSEQUAL); DT(TSGREATER);
DQ ENDDOP←NTSI-1;
DT(TSLBRAK); DT(TSRBRAK);
DT(TSLARR); DT(TSLAND);
DT(TSLNOT); DT(TSLOR); DT(TSLXOR);
DT(TSAND); DT(TSBY); DT(TSDO); DT(TSEOR); DT(TSELSE);
DT(TSFOR); DT(TSFRET); DT(TSGOTO); DT(TSIF); DT(TSLSH);
DT(TSLCY); DT(TSMOD); DT(TSNOT); DT(TSOR); DT(TSRSH);
DT(TSRCY); DT(TSRET); DT(TSTO); DT(TSVALUE); DT(TSWHERE);
DT(TSWHILE);
DQ BEGUOP←NTSI;
DT(TSUPLUS); DT(TSUMINUS); DT(TSUDOL); DT(TSUAT);
DQ ENDUOP←NTSI-1;
DT(TSSL2); DT(TSLTEQ); DT(TSGTEQ); DT(TSEXP);

* FIRST TOKEN WHICH IS A TERMINAL SYMBOL
         DQ BEGTST←6000B;

* RANGE OF TOKENS FOR CHARACTERS
         DQ BEGCHT←6000B, ENDCHT←6077B;

* TABLE TO TRANSLATE TOKENS NOT BASED ON SPECIAL CHARACTERS INTO TERMINAL
* SYMBOL NUMBERS (POSITIVE) OR OTHER THINGS (NEGATIVE)
* NEGATIVE ENTRIES  ARE FOR KEYWORDS WHICH ARE NOT ACCEPTABLE
* TO THE EXPRESSION PARSER.  THEY ARE DIVIDED INTO GROUPS AS FOLLOWS
* THE ORDERING OF GROUPS IS ASSUMED IN THE CODE

* TYPE WORDS.  THEY START AT
         DQ BEGTYPE←1;
* AND ARE DIVIDED INTO TWO CLASSES:  PURE AND IMPURE (I.E. ALSO MODES)
* WITH THE PURE ONES GROUPED AT THE BEGINNING
* THE SUB-TYPES OF INTEGER ARE AT THE BEGINNING OF THE PURE TYPES

         DM DK(X)←DQ X←NKI, NKI←X+1;
         DQ NKI←1;

DK(KWINTEGER); DK(KWCHAR); DK(KWOCTAL); DK(KWPOINTER);
         DQ ENDITYPE←NKI-1;
DK(KWCOMPLEX); DK(KWDOUBLE); DK(KWLABEL); DK(KWLONG);
DK(KWLNG2); DK(KWREAL); DK(KWSTRING); DK(KWUNKNOWN);
         DQ ENDPTYPE←NKI-1, BEGMODE←NKI;
DK(KWARRAY); DK(KWARY1); DK(KWFIELD); DK(KWFUNCTION); DK(KWSCALAR);
         DQ ENDTYPE←NKI-1;
DK(KWEXTERNAL);
         DQ ENDMODE←NKI-1;

* STATEMENT INITIATORS WHICH ARE NOT TYPES
         DQ BEGSI←NKI;

DK(KWELSF); DK(KWELSE); DK(KWENDFOR);
DK(KWENDIF); DK(KWEND); DK(KWENTRY); DK(KWFOR);
DK(KWIF);
* SI'S BEFORE THIS INTRODUCE STATEMENTS OF TYPE MISC, AFTER IT THOSE
* OF TYPE DEC
         DQ BEGDEC←NKI;
DK(KWCOMMON); DK(KWDECLARE); DK(KWFIXED); DK(KWINCLUDE); DK(KWMACRO);
DK(KWPROGRAM); DK(KWORIGIN);
* THE NEXT THREE MUST COME AT THE END OF THE SI'S SINCE THEY ARE
* GROUPED WITH THE FIRST THREE MKW'S
         DQ BEGFLOC←NKI;
DK(KWMONITOR); DK(KWPOP); DK(KWUTILITY);
         DQ ENDSI←NKI-1;

* MISCELLANEOUS KEYWORDS
         DQ BEGMKW←NKI;
DK(KWTRAPENTRY); DK(KWSYSPOP); DK(KWMTRAPENTRY); DK(KWSPENTRY);
         DQ ENDFLOC←NKI-1;
DK(KWSIGNED); DK(KWPARAM);
* MACHINE REGISTERS
         DQ BEGRKW←NKI;
DK(KWGREG); DK(KWLREG); DK(KWRREG); DK(KWXREG);
         DQ ENDRKW←NKI-1;
         DQ ENDMKW←NKI-1;

* TOKENS NOT BASED ON SPECIAL CHARACTERS FALL IN THE RANGE
         DQ BEGSPT←6400B, ENDSPT←6502B;
* AND ARE CONVERTED TO TS OR KW SYMBOLS BY THE FOLLOWING TABLE
         DA KWTSTR[ENDSPT-BEGSPT+1]←(
TSAND,-KWARY1,-KWARRAY,TSLAND,TSBY,-KWCHAR,-KWCOMPLEX,-KWCOMMON,-KWDECLARE,
-KWDOUBLE,TSDO,-KWELSF,TSELSE,-KWENTRY,-KWENDFOR,-KWENDIF,-KWEND,
TSFOR,-KWFIELD,-KWFIXED,TSFRET,-KWFUNCTION,-KWMTRAPENTRY,TSGOTO,TSIF,-KWINCLUDE,
-KWINTEGER,TSLSH,TSLCY,-KWLABEL,-KWLNG2,-KWLONG,-KWMACRO,TSMOD,
-KWMONITOR,TSNOT,TSLNOT,TSOR,-KWOCTAL,-KWPARAM,-KWPOP,-KWPOINTER,
TSRSH,TSRCY,TSRET,-KWREAL,-KWSTRING,-KWSCALAR,-KWSIGNED,-KWSYSPOP,TSTO,
-KWTRAPENTRY,-KWUTILITY,TSLOR,TSVALUE,TSWHERE,TSWHILE,TSLXOR,-KWPROGRAM,
-KWORIGIN,-KWGREG,-KWLREG,-KWRREG,-KWXREG,-KWUNKNOWN,-KWEXTERNAL,
-KWSPENTRY);

* INTERNAL ID FOR TYPE -> TT SYMBOL FOR CODE GENERATOR
         DA TYTTTR[ENDTYPE-BEGTYPE+1]←(
TTINT,TTINT,TTINT,TTINT,
TTCPLX,TTDBL,TTLAB,TTLONG,
TTLLONG,TTREAL,TTSTR,TTUND,
TTARRAY,TTARRAY,TTFIELD,TTFUNC,TTINT);

* INTERNAL ID FOR TYPE/MODE -> SM SYMBOL FOR CODE GENERATOR
          DA TYSMTR[ENDMODE-BEGMODE+1]←(
SMARRAY,SMARR1,SMFIELD,SMFUNC,SMVALUE,SMEXT);

* INTERNAL ID FOR INTEGER TYPE -> SD SYMBOL FOR CODE GENERATOR
         DA ITSDTR[ENDITYPE-BEGTYPE+1]←(
SDNOR,SDCHAR,SDOCTAL,SDPOINT);

* INTERNAL ID FOR FUNCTION LOC SYMBOL -> FL SYMBOL FOR CODE GENERATOR
         DA ITFLTR[ENDFLOC-BEGFLOC+1]←(
FLMONITOR,FLPOP,FLUTILITY,FLTRAP,FLSYSPOP,FLFTRAP,FLSP);



* 'NIL' FOR THE TREE ROUTINES IS HELD IN
*        DP *NULLCH;

       COMMON PRECTAB;
       INCLUDE PARSE';

* A TOKEN MAY REPRESENT A TERMINAL SYMBOL IF IT IS >BEGTST.
* SUCH TOKENS FALL INTO THREE CLASSES
* BEGCHT TO ENDCHT - TOKENS CORRESPONDING TO OPERATORS WITH SPECIAL CHARACTERS
* ENDCHT+1 TO BEGSPT-1 - TOKENS FOR FORTRAN KEYWORDS
* BEGSPT TO ENDSPT - TOKENS FOR SPL KEYWORDS
* THERE ARE TWO ARRAYS, CHTSTR AND RWTSTR, FOR TRANSLATING TOKENS
* OF CLASSES 1 AND 3 INTO TERMINAL SYMBOL NUMBERS. TOKENS OF CLASS
* TWO, OF COURSE, ARE ERRORS AND SHOULD NEVER OCCUR.
* THE TERMINAL SYMBOL NUMBERS ARE USED TO INDEX A COLLECTION OF
* OTHER ARRAYS.  A NEGATIVE TSN INDICATES A TOKEN WHICH IS NOT
* A TERMINAL SYMBOL FOR THE PRECEDENCE PART OF THE
* PARSER.

* THE TOTAL NUMBER OF TERMINAL SYMBOLS IS GIVEN BY
         DQ NTSYMS←55;

* PRECEDENCE IS SPECIFIED BY THE MATRIX PRMTX.  EACH ELEMENT OF
* THIS MATRIX IS 2 BITS. THE PRECEDENCE RELATION BETWEEN I AND J
* IS GIVEN BY
*        PRMTX[ROWIDX(I)+COLIDX(J)] RSH COLSHC(J) AND 3
* THE REASON FOR THIS SCHEME IS THAT MANY  TERMINAL SYMBOLS HAVE
* THE SAME PRECEDENCE.  A LOT OF SPACE IN PRMTX CAN THUS BE SAVED
* BY ROWIDX AND COLIDX, WHICH ESSENTIALLY SERVE TO SPECIFY THE
* EQUIVALENCE.  IN THE EXAMPLE I AND J ARE TERMINAL
* SYMBOL NUMBERS.
         DQ LTPREC←1,EQPREC←2,GTPREC←3;

* WHEN A PRIME PHRASE IS DETECTED (NEXT SYMBOL > $TTSFS), WE
* DISPATCH ON ITS LAST TERMINAL TO A COLLECTION OF ROUTINES
* WHICH  DECIDE WHAT TO DO NEXT.  THE ROUTINES ARE ACCESSED
* BY INDIRECTION THROUGH THE ARRAY PPXPAR. THE NUMBER (I.E. INDEX
* IN THIS ARRAY) OF THE ROUTINE TO USE IS GIVEN BY TSOPEX(TERMINAL).
* MANY OF THE ROUTINES HAVE A PARAMETER WHICH THEY EXPECT TO FIND IN
         DI OPVAL;
* THIS PARAMETER IS NORMALLY GIVEN BY TSOPV(TERMINAL).
* IN PARTICULAR, STANDARD UNARY AND BINARY OPERATORS ARE HANDLED
* BY ROUTINES SUOP AND SBOP, FOR WHICH THE PARAMETER IS THE NUMBER
* WHICH SPECIFIES THE OPERATOR TO THE TREE-BUILDER.  
* THE INDEX OF A ROUTINE IN PPXPAR IS THE VALUE OF 'X' ROUTINE, AND
* THE LABEL OF THE ROUTINE IS 'P' ROUTINE.  THUS, XSBOP AND PSBOP.

* MACROS FOR ACCESSING ALL THESE THINGS.  THIS PERMITS THE PROGRAM
* TO BE WRITTEN WITHOUT COMMITMENT ABOUT THE PACKING.
* TSOPV AND TSOPEX EACH OCCUPY A HALF WORD:
         DF TSOPVF(0:12,23),TSOPXF(0:0,11);
* IN THE ARRAY TSOPVX.  THE MACRO TO CONSTRUCT AN ENTRY IN THIS
* ARRAY IS THUS
**********: KLUDGE
         DM IVX(X,Y)←X V' Y LSH 12;
* ROWNO, COLWD AND COLSH ARE PACKED INTO ONE WORD:
         DF ROWNOF(0:0,11),COLWDF(0:12,17),COLSHF(0:18,23);
* IN THE ARRAY TSIDX WHICH IS CONTAINED IN THE INCLUDE FILE IPTAB

         DM ROWIDX(X)←TSIDX[X]$ROWNOF;
         DM COLIDX(X)←TSIDX[X]$COLWDF;
         DM COLSHC(X)←TSIDX[X]$COLSHF;
         DM PPEXEC(X)←GOTO LABEL'FIXER(PPXPAR[TSOPEX(X)]);
         DM TSOPV(X)←TSOPVX[X]$TSOPVF;
         DM TSOPEX(X)←TSOPVX[X]$TSOPXF;

* FIELDS FOR ACCESSING ENTRIES ON THE STACK
         DF STKE1(0),STKE2(-1),STKE3(-2),STKE4(-3),STKE5(-4);


* INDEXES INTO PPXPAR FOR OPERATOR PROCESSORS (#4 IS UNUSED)
         DQ XSBOP←0,XSUOP←1,XERROP←2,XRELOP←3,
            XRPAR←5,XCOMMA←6,XRBRAK←7,XELSEOP←8,XIFOP←9,
            XTOOP←10,XWHROP←11,XWHILOP←12,XUPLUS←13,XRETOP←14,
            XBEGOP←15,XCOLON←16;

         DA TSOPVX[NTSYMS]←(
IVX(0,XERROP),
IVX(0,XBEGOP),
IVX(OPPLUS,XSBOP),
IVX(OPMINUS,XSBOP),
IVX(OPBDOL,XSBOP),
IVX(OPUNTAIL,XSBOP),
IVX(ORNE,XRELOP),
IVX(OPSEQ,XSBOP),
IVX(0,XERROP),
IVX(0,XRPAR),
IVX(0,XCOMMA),
IVX(OPTAIL,XSBOP),
IVX(0,XCOLON),
IVX(0,XERROP),
IVX(OPTIMES,XSBOP),
IVX(OPQUOT,XSBOP),
IVX(ORLT,XRELOP),
IVX(OREQ,XRELOP),
IVX(ORGT,XRELOP),
IVX(0,XERROP),
IVX(0,XRBRAK),
IVX(OPSET,XSBOP),
IVX(OPLOGAND,XSBOP),
IVX(OPLOGNOT,XSUOP),
IVX(OPLOGOR,XSBOP),
IVX(OPLOGEOR,XSBOP),
IVX(OPAND,XSBOP),
IVX(0,XERROP),
IVX(0,XERROP),
IVX(0,XSBOP),
IVX(0,XELSEOP),
IVX(0,XERROP),
IVX(OPFRET,XRETOP),
IVX(OPGOTO,XSUOP),
IVX(0,XIFOP),
IVX(OPLSH,XSBOP),
IVX(OPLCY,XSBOP),
IVX(OPMOD,XSBOP),
IVX(OPNOT,XSUOP),
IVX(OPOR,XSBOP),
IVX(OPRSH,XSBOP),
IVX(OPRCY,XSBOP),
IVX(OPRET,XRETOP),
IVX(0,XTOOP),
IVX(0,XERROP),
IVX(0,XWHROP),
IVX(0,XWHILOP),
IVX(0,XUPLUS),
IVX(OPNEG,XSUOP),
IVX(OPINDIR,XSUOP),
IVX(OPREF,XSUOP),
IVX(0,XERROP),
IVX(ORLE,XRELOP),
IVX(ORGE,XRELOP),
IVX(OPPOW,XSBOP));


* GRAMMAR TABLES

         DECLARE ARRAY PRMTX[90]←(
        0B,        0B,        0B,
  5257765B,-12575253B, 20242400B,
 15757765B,-16001704B, -3105400B,
 17757774B, -3001704B, -3141400B,
  5157765B,-12141714B, -3105400B,
  5357765B,-12541213B, 34672400B,
  5254505B,  5202525B, 20262400B,
 17777777B, -3001704B, -3142000B,
  5256705B,-12577253B, 20472400B,
     6400B,        0B,    30400B,
 15757775B,-16001704B, -3105400B,
  5250405B,-32577253B, 20042400B,
 17747774B, -3001704B, -3142000B,
  5757765B,-12001714B, -3105400B,
 15757775B,-17001704B, -3105400B);
       DECLARE ARRAY PRMTX[45]←(
  5357765B,-12141713B, -3105400B,
  5250005B,  5200525B, 30042400B,
  5257765B,-12571253B, 34672400B,
     1000B,  4100000B, 10400400B,
  5357765B,-12541613B, 34672400B,
  1157761B,-17741720B, -3107400B,
  5257765B,-12551273B, 34672400B,
  5757765B,-16001704B, -3105400B,
  5357765B,-12141714B, -3105400B,
  5357765B,-12541713B, -3105400B,
  5257765B,-12571253B, 20642400B,
  5254105B,  5202525B, 20242400B,
  5257765B,-12541213B, 34672400B,
 17757775B, -3001704B, -3101400B,
  5254105B,  5202525B, 22242400B);

         DECLARE ARRAY TSIDX[57]←(
26B,30026B,60024B,60024B,110022B,110022B,140020B,170016B,220014B,250012B,
300010B,110022B,330006B,4B,360002B,360002B,140020B,140020B,140020B,410000B,
440126B,470124B,360002B,520122B,60024B,60024B,550120B,600116B,4B,26B,
630114B,660112B,710110B,740106B,770104B,360002B,360002B,1020102B,1050100B,1100226B,
360002B,360002B,710110B,1130224B,1160222B,1210016B,1130220B,520122B,520122B,1240216B,
1240216B,1270214B,140020B,140020B,360212B,250210B,26B);

* FIELDS FOR TERMINAL SYMBOL NUMBERS
         DF OPOSN(0:9,14),OPTSN(0:15,23);
* OPSWX VALUES (ALL @OPOSN)
         DQ CHUBO←1B3,CHDOP←2B3,CHLARR←3B3;

* TABLE TO TRANSLATE THESE TOKEN NUMBERS INTO TERMINAL SYMBOL NUMBERS
         DA CHTSTR[ENDCHT-BEGCHT+1]←(
0,0,0,TSNEQUAL,CHUBO+TSDOLLAR,0,TSAMPER,0,
TSLPAR,TSRPAR,CHDOP+TSSTAR,CHUBO+TSPLUS,
TSCOMMA,CHUBO+TSMINUS,TSDOT,CHDOP+TSSLASH,
0,0,0,0,0,0,0,0,
0,0,TSCOLON,TSSEMI,CHDOP+TSLESS,CHDOP+TSEQUAL,CHDOP+TSGREATER,0,
CHUBO+TSAT,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,TSLBRAK,0,TSRBRAK,0,CHLARR+TSLARR);

* TABLE OF SECOND HALVES OF DOUBLE OPERATORS
         DA DOPNXT[ENDDOP-BEGDOP+1]←(
TSTAR,TSLASH,TEQUAL,TLESS,TEQUAL);

* TABLE OF CORRESPONDING TERMINAL SYMBOLS
         DA DOPTS[ENDDOP-BEGDOP+1]←(
TSEXP,TSSL2,TSLTEQ,TSLTEQ,TSGTEQ);


* PARSER ERROR COMMENTS
* THESE MEAN
* 1: ILLEGAL EXPRESSION
* 2: ILLEGAL PARENTHESIZED OBJECT
* 3: BAD SYNTAX IN DECLARATION
* 4: EXPECTED 'D0'
* 5: EXPECTED NAME
* 6: ILLEGAL FUNCTION DECLARATION
* 7: ILLEGAL MACRO DEFINITION
* 8: MACRO STACK OVERFLOW
* 9: TOO MANY MACRO ARGUMENT SYMBOLS
* 10: END OF STATEMENT IN MACRO ACTUAL ARGUMENT LIST
* 11: TOO FEW ARGUMENTS FOR MACRO
* 12: MACRO BODY TOO LONG
* 13: EXPECTED , OR SEMICOLON
* 14: STATEMENT TOO COMPLEX
* 15: RAN OFF END OF PPT FOR BLOCK
* 16: MACRO ARGUMENT MUST NOT CROSS LINE BOUNDARY
* 17: TOO MANY ARGUMENTS FOR MACRO
* 18: ILLEGAL TOKEN NUMBER
* 19: EXPECTED STRING CONSTANT

       PROGRAM EXPR;
       INCLUDE PARSE',PRECTAB;
* PARSE EXPRESSION, STARTING AT CURRENT TOKEN, AND RETURN THE
* RESULTING TREE NODE
         DI HANDLE;
         DI ARG1,ARG2,ARG3,ARG4, ARGPTR, FNNODE;
         DI SFPTR,IPDISP;
         DI NXTOP;

* THE EXPRESSION PARSER HAS TWO STACKS:
*   SFSTK   SENTENTIAL FORM STACK, WHICH CONTAINS THE HEAD OF THE
*           SENTENTIAL FORM BEING PARSED.  TWO KINDS OF ENTITIES
*           APPEAR ON THIS STACK: TERMINALS AND NODE POINTERS FOR
*           THE CODE GENERATION TREE
**** IT IS ASSUMED THAT NODE POINTERS ARE ALWAYS >
         DQ MINNP←200B;
* BHSTK     BEGINNING-OF-HANDLE STACK, WHICH CONTAINS POINTERS INTO
*           SFSTK FOR THE TERMINALS WHICH ARE < THE NEXT TERMINAL
* THERE IS A STACK PARALLELING BHSTK TO RECORD THE POSITION
* IN THE INPUT STREAM OF THE TOKEN WHICH GAVE RISE TO THE
* CORRESPONDING ENTRY IN BHSTK: THIS IS TO ALLOW THE ERROR
* ROUTINE TO CORRELATE TREE NODES WITH SOURCE OPERATORS

* ALL POINTERS ARE IN THE FORM OF ADDRESSES, NOT OF INDEXES INTO THE
* ARRAYS WHICH CONSTITUTE THE STACKS

* THERE IS A TOP FOR EACH STACK
         DI TSFS,TBHS;
* AND A POINTER TO THE TOPMOST TERMINAL ON SFSTK
         DI TTSFS;

       DQ LSFS←160,LBHS←80;
       DA SFS[LSFS],BHS[LBHS],IPS[LBHS];
       DP ESFS,EBHS;

         DECLARE SWITCH PPXPAR[17]←(
PSBOP,PSUOP,PERROP,PRELOP,PERROP,
PRPAR,PCOMMA,PRBRAK,PELSEOP,PIFOP,
PTOOP,PWHROP,PWHILOP,PUPLUS,PRETOP,
PBEGOP,PCOLON);


         DECLARE SWITCH PRECSW[4]←(
          PRERR,PRLT,PREQ,PRGT);
       DECLARE SWITCH OPSWX[4]←(
        OSNOP,OSUBO,OSDOP,OSLARR);


       FUNCTION EXPR();

* INITIALIZE STACK WITH BEGIN SYMBOL
         ESFS←(TTSFS←TSFS←@SFS[0])+LSFS;
         $TSFS←TSBEGIN;
         EBHS←(TBHS←@BHS[0])+LBHS;
         PREVSYM←BEGCHT;
         IPDISP←@IPS[0]-@BHS[0];
         IPS[0]←CONTENTS(IDPTR);


PARSLP:  IF THISYM>=BEGCHT DO;
            NXTOP←(CHTSTR[THISYM-BEGCHT] IF THISYM<=ENDCHT ELSE
                    KWTSTR[THISYM-BEGSPT] IF THISYM>=BEGSPT AND
                                             THISYM<=ENDSPT ELSE
                    GOTO PSTRCON IF THISYM=TSTRCON ELSE
                    PCERR(18));
            IF NXTOP>0 DO;
* TERMINAL SYMBOL.  DISPATCH
               GOTO LABEL'FIXER(OPSWX[NXTOP$OPOSN]);
* STOP IF LEFT ARROW AND KLUDGE FLAG SET
OSLARR:        NXTOP←TSSEMI IF KNLARRF<0;
               GOTO OSOK;
* CONVERT BINARY OPERATOR TO UNARY IF NECESSARY
OSUBO:         IF PREVSYM>=BEGCHT AND PREVSYM#TRPAR
                AND PREVSYM#TRBRAK DO;
                  NXTOP←NXTOP+(BEGUOP-BEGUBOP);
               ENDIF;
               GOTO OSOK;
* CHECK FOR DOUBLE OPERATOR (KLUDGE)
OSDOP:         GOTO OSOK IF NXTSYM<BEGCHT;
               IF NXTSYM=DOPNXT[T←NXTOP$OPTSN-BEGDOP] DO;
                  NXTOP←DOPTS[T];
               ELSEIF THISYM=TEQUAL AND NXTSYM=TGREATER DO;
                  NXTOP←TSGTEQ;
               ELSE DO;
                  GOTO OSOK;
               ENDIF;
* DOUBLE OPERATOR DETECTED.  READ ANOTHER SYMBOL
               GETNEXT();
* COMPARE WITH PREDECESSOR FOR PRECEDENCE
OSOK:          NXTOP←NXTOP$OPTSN;
OSNOP:
TSLOOP:        GOTO LABEL'FIXER( PRECSW[(PRMTX[ROWIDX(T)+COLIDX(NXTOP)]
                RSH COLSHC(NXTOP)) A' 3]) WHERE T←$TTSFS;
* GREATER THAN.  WE HAVE PARSED A PRIME PHRASE.  PULL IT OFF AND PROCESS
* IT
PRGT:             OPVAL←TSOPV(T);
                  NODEID←TBHS[IPDISP];
                  SETIDN(CONTENTS(TBHS+IPDISP));
                  PPEXEC(T);
* NOW REPLACE IT BY THE HANDLE
PPXDONE:          T←TTSFS←$TBHS;
PPXD2:            TBHS←TBHS-1;
                  TSFS←T+1;
                  $TSFS←HANDLE;
                  GOTO TSLOOP;
* EQUAL.  ADD THE TERMINAL TO SFSTK
PREQ:             TTSFS←TSFS←TSFS+1;
                  PCERR(14) IF TSFS=ESFS;
                  $TSFS←NXTOP;
                  GOTO PNEXT;
* LESS THAN. ADD THE TERMINAL TO SFSTK AND BHSTK
PRLT:             TBHS←TBHS+1;
                  $TBHS←TTSFS;
                  TBHS[IPDISP]←CONTENTS(IDPTR);
                  TTSFS←TSFS←TSFS+1;
                  $TSFS←NXTOP;
                  PCERR(14) IF TBHS=EBHS OR TSFS=ESFS;
                  GOTO PNEXT;
* NO RELATION.
PRERR:            PCERR(1);
* RESERVED WORD, BUT NOT TERMINAL SYMBOL.  MAYBE A MACHINE REGISTER
            ELSEIF NXTOP>=-ENDRKW AND NXTOP<=-BEGRKW DO;
* YES.  MAKE A TREE NODE AS FOR A VARIABLE.  CHECK FIRST
               T←-BEGRKW-NXTOP;
               PCERR(1) IF TSFS#TTSFS OR REGOK LSH T>=0;
               TSFS←TSFS+1;
               $TSFS←TCN1(OPREG,T);
* NOT A MACHINE REGISTER.  MIGHT BE TYPE WORD USED AS FUNCTION
            ELSEIF NXTOP>=-ENDTYPE AND NXTOP<=-BEGTYPE
           AND NXTSYM=TLPAR DO;
* YES.  MAKE NODE FOR 'CHEATER' FUNCTION
               T←TYTTTR[-NXTOP-BEGTYPE];
               PCERR(1) IF TSFS#TTSFS;
               TSFS←TSFS+1;
               $TSFS←TCN1(OPCHEAT,T);
* NO.  SYNTAX ERROR
            ELSE DO;
               PCERR(1);
            ENDIF;
* SYMBOL IS NOT RESERVED WORD.  MAKE A TREE NODE, STACK IT AND
* CHARGE ON
         ELSE DO;
            PCERR(1) IF TSFS#TTSFS;
            TSFS←TSFS+1;
            SETID();
            $TSFS←(MCONNODE(THISYM) IF ISCON(THISYM) ELSE TCVC(THISYM));
            OUTREF(THISYM) IF XREF<0 AND THISYM<=TNLIM;
         ENDIF;
PNEXT:   NEXT;
         GOTO PARSLP;
* SPECIAL STRING CONSTANT COMING UP
PSTRCON:       PCERR(1) IF TSFS#TTSFS;
               NEXT;
               PCERR(19) IF NOT ISTRC(THISYM);
               TSFS←TSFS+1;
               $TSFS←MCONNODE(THISYM);
               WHILE PREVSYM=TSTRCON DO;
                  NEXT;  NEXT IF THISYM=TSTRCON;
                  PCERR(19) IF NOT ISTRC(THISYM);
                  $TSFS←TCN2(OPSC,MCONNODE(THISYM),$TSFS);
               ENDFOR;
         GOTO PNEXT;


* PROCESSORS FOR PRIME PHRASES

* FOR SIMPLE BINARY OPERATORS
PSBOP:    GOTO PERROP IF $TBHS+3#TSFS;
         HANDLE←TCN2(OPVAL,TSFS.STKE3,TSFS.STKE1);
         GOTO PPXDONE;

* FOR SIMPLE UNARY OPERATORS
PSUOP:   GOTO PERROP IF $TBHS+2#TSFS;
         HANDLE←TCN1(OPVAL,TSFS.STKE1);
         GOTO PPXDONE;

*FOR OPERATORS WHICH SHOULD NEVER APPEAR
PERROP:  PCERR(1);

* FOR RELATIONALS
PRELOP:  GOTO PERROP IF $TBHS+3#TSFS;
         HANDLE←TCN3(OPREL,TSFS.STKE3,TSFS.STKE1,TCIC(OPVAL));
         GOTO PPXDONE;

* FOR ')'. THIS IS PARENTHESIZED EXPRESSION (LIST) OR FUNCTION CALL,
*DEPENDING ON WHETHER THE ( IS IMMEDIATELY PRECEDED BY A NON-TERMINAL
* OR NOT
PRPAR:   IF $(SFPTR←$TBHS+1)=TSLPAR DO;
* NOT FUNCTION.  MUST BE (THING)
            IF SFPTR+2#TTSFS DO;
               PCERR(2);
* TACK ON OPLIST UNLESS RETURN PRECEDES (
            ELSEIF (T←$$TBHS)=TSRET OR T=TSFRET DO;
               HANDLE←MCHAIN(TTSFS.STKE2);
            ELSE DO;
               HANDLE←PAGPTR←TTSFS.STKE2;
               IF F(PAGPTR,TOPR)=OPCHAIN DO;
                  HANDLE←TCN1(OPLIST,HANDLE);
               ENDIF;
            ENDIF;
            GOTO PPXDONE;
* IS FUNCTION.  LOOK FOR OTHER STUFF.
         ELSE DO;
            SFPTR←SFPTR+2;
            ARG1←ARG2←ARG3←ARG4←NULLCH;
PFCALP:     T←$SFPTR;
            IF T=TSRPAR DO;
* COLLECTED EVERYTHING
               FNNODE←$($TBHS+1);
               HANDLE←(TCN2(OPNCALL,FNNODE,ARG1) IF
                ARG2=NULLCH AND ARG3=NULLCH AND ARG4=NULLCH
                ELSE TCN5(OPCALL,FNNODE,ARG1,ARG2,ARG3,ARG4));
               GOTO PPXDONE;
            ELSEIF T=TSSL2 DO;
* COLLECTED ARGPART.  LOOK AT FAILPART
               SFPTR←SFPTR+1;
               IF $SFPTR=TSVALUE DO;
                  ARG3←-1;
                  SFPTR←SFPTR+1;
               ENDIF;
               PCERR(1) IF $SFPTR<MINNP;
* DEAL WITH FAILURE VALUE: SUPPLY GOTO IF REQUIRED
               IF ARG3#-1 AND F((PAGPTR←$SFPTR),TOPR)=OPVAR DO;
                  ARG3←TCN1(OPGOTO,PAGPTR);
               ELSE DO;
                  ARG3←$SFPTR;
               ENDIF;
               SFPTR←SFPTR+1;
               IF $SFPTR#TSRPAR DO;
                  ARG4←$SFPTR;
                  SFPTR←SFPTR+1;
               ENDIF;
            ELSEIF T>MINNP DO;
* ARGPART HAS EXPL
               ARG1←MCHAIN(T);
               SFPTR←SFPTR+1;
               IF $SFPTR>MINNP DO;
* ARGPART HAS BOTH
                  ARG2←$SFPTR;
                  SFPTR←SFPTR+1;
               ENDIF;
            ELSE DO;
               PCERR(1);
            ENDIF;
            GOTO PFCALP;
         ENDIF;

* COLON SEPARATES THE TWO PARTS OF A FUNCTION CALL ARGPART OR
* FAILPART.  BOTH PARTS ARE LEFT ON THE STACK
PCOLON:  GOTO PERROP IF TTSFS+1#TSFS;
         HANDLE←MCHAIN(TSFS.STKE1);
         IF $TBHS+1=TTSFS DO;
* NOTHING PRECEDING COLON
            ARG1←NULLCH;
         ELSEIF $TBHS+2=TTSFS DO;
            ARG1←TSFS.STKE3;
         ELSE DO;
            PCERR(1);
         ENDIF;
         TTSFS←$TBHS;
         T←TTSFS+1;
         $T←ARG1;
         GOTO PPXD2;

* COMMA. AN EXPRESSION OR ID LIST IS THE ONLY POSSIBLE CONTEXT.
* MAKE THE FIRST ARGUMENT A CHAIN IF IT IS NOT ONE ALREADY
PCOMMA:  SFPTR←TSFS;
         IF $SFPTR=TSCOMMA DO;
            ARG2←NULLCH;
            SFPTR←SFPTR+1;
         ELSE DO;
            ARG2←MCHAIN(SFPTR.STKE1);
         ENDIF;
         IF $TBHS+2=SFPTR DO;
            ARG1←NULLCH;
         ELSE DO;
            ARG1←SFPTR.STKE3;
         ENDIF;
         HANDLE←TCN2(OPCHAIN,ARG1,ARG2);
         GOTO PPXDONE;

* RIGHT BRACKET.
PRBRAK:  GOTO PERROP IF $TBHS+4#TSFS;
         PAGPTR←TTSFS.STKE2;
         HANDLE←TCN2(OPSUB IF PAGPTR.TOPR=OPCHAIN ELSE OPNSUB,
          TTSFS.STKE4,PAGPTR);
         GOTO PPXDONE;

*ELSE
PELSEOP:  GOTO PERROP IF $TBHS+5#TSFS;
         HANDLE←TCN3(OPIF,TSFS.STKE3,TSFS.STKE5,TSFS.STKE1);
         GOTO PPXDONE;

* RETURN OR FRETURN.  DEAL WITH OPERAND
PRETOP:  IF TSFS=TTSFS DO;
            ARG1←NULLCH;
         ELSE DO;
            ARG1←MCHAIN(TSFS.STKE1);
         ENDIF;
         GOTO PERROP IF $TBHS+1#TTSFS;
         HANDLE←TCN1(OPVAL,ARG1);
         GOTO PPXDONE;

*  IF.  LIKE ELSE EXCEPT FOR NULL THIRD ARGUMENT
PIFOP:   GOTO PERROP IF $TBHS+3#TSFS;
         HANDLE←TCN3(OPIF,TSFS.STKE1,TSFS.STKE3,NULLCH);
         GOTO PPXDONE;

* TO. SET UP ARGS DEPENDING ON PRESENCE OR ABSENCE OF BY
PTOOP:   ARG4←TSFS.STKE1;
         ARGPTR←TSFS-2;
         IF TSFS.STKE4=TSBY DO;
            ARG3←TSFS.STKE3;
            ARGPTR←ARGPTR-2;
         ELSE DO;
            ARG3←TCIC(1);
         ENDIF;
* HAVE TO HANDLE BLOCK FOR AS WELL
         T←OPFORT;
PXFOR:   IF $TBHS+3#ARGPTR DO;
            GOTO PERROP IF $$TBHS#TSBEGIN;
            ARG1←TCN0(OPBLOCK);
         ELSE DO;
            ARG1←ARGPTR.STKE3;
         ENDIF;
         HANDLE←TCN4(T,ARG1,ARGPTR.STKE1,ARG3,ARG4);
         GOTO PPXDONE;

* WHERE.  A WHERE B BECOMES (SEQ B A)
PWHROP:  GOTO PERROP IF $TBHS+3#TSFS;
         HANDLE←TCN2(OPSEQ,TSFS.STKE1,TSFS.STKE3);
         GOTO PPXDONE;

* UNARY PLUS
PUPLUS:  GOTO PERROP IF $TBHS+2#TSFS;
         HANDLE←TSFS.STKE1;
         GOTO PPXDONE;

* WHILE. THREE CASES  A WHILE B, A FOR B WHILE C, A FOR B, C WHILE D
* FIRST LOOK FOR COMMA
PWHILOP: ARG4←TSFS.STKE1;
         ARGPTR←TSFS-2;
         IF TSFS.STKE4=TSCOMMA DO;
            ARG3←TSFS.STKE3;
            ARGPTR←ARGPTR-2;
         ELSE DO;
            ARG3←NULLCH;
         ENDIF;
         IF ARGPTR.STKE2=TSFOR DO;
* HAVE TO HANDLE BLOCK FOR ... WHILE AS WELL
            T←OPFORW;
            GOTO PXFOR;
         ELSE DO;
            GOTO PERROP IF $TBHS+1#ARGPTR;
            HANDLE←TCN2(OPWHILE,ARGPTR.STKE1,ARG4);
         ENDIF;
         GOTO PPXDONE;

*BEGIN. RETURN
PBEGOP:  GOTO PERROP IF TSFS=TTSFS;
         RETURN CONTENTS(TSFS);

       PROGRAM PARSE;
       INCLUDE PARSE';

* THE PARSER SEQUENCES THROUGH THE STATMENTS IN A FUNCTION.  FOR
* EACH ONE IT UNPACKS IT, THEN CLASSIFIES IT AS TO TYPE.
* IF IT STARTS WITH A STATEMENT INITIATOR, CONTROL GOES TO THE
* PROPER ROUTINE.  OTHERWISE THE EXPRESSION PARSER IS CALLED

* UNPACK AND PARSE STATEMENT

         DI STINIT,STREE;
         DI FCNTYPE,FCNPARS,FCNAME,FCNLOC,FCNINDEX,FCNFRET;
         DI MLOP;
* DISPATCH TABLE FOR STATEMENT INITIATORS.
* THE ORDER MUST MATCH THE ASSIGNMENT OF VALUES TO KW-SYMBOLS FOR
* STATEMENT INITIATORS.
         DECLARE SWITCH STIEX[ENDSI-BEGSI+1]←(
STELSF,STELSE,STENDFOR,
STENDIF,STEND,STENTRY,STFOR,
STIF,
STCOMMON,STDECLARE,STFIXED,STINCLUDE,STMACRO,
STPROGRAM,STORIGIN,
STMONITOR,STPOP,STUTILITY);

* STATEMENT TYPES FOR STATEMENT INITIATORS, PARALLELS STIEX
       DA STITY[ENDSI-BEGSI+1]←(
STMISC,STMISC,STMISC,
STMISC,STFIRST+STDEC+STMISC,STFD,STMISC,
STMISC,
STFIRST,STDEC,STORG,STFIRST,STDEC,
STFIRST,STORG,
STDEC,STDEC,STDEC);

* IF THE ACTUAL STATEMENT TYPE (STYPE)
* FAILS TO MATCH THE CURRENT SET OF ALLOWABLE TYPES (STYPES)
* THE PARSER SKIPS THE REST OF THE STATEMENT
* AND RETURNS ZERO: SEE PARSX0, CHKST

         
       FUNCTION PARSE(TCESSI,TCESTI);

         PARSXL←PARSX0;
         KNLARRF←REGOK←0;
         ISCAN();
         SETCISD(CURSI←CESSI←CFSSI←TCESSI,TCESTI);
GETSTAT: NXTSYM←BEGCHT;
         NEXT;
         IF NXTSYM=BEGCHT DO;
* RAN OFF END OF PPT
            CESTI←0;
            RETURN NULLCH;
         ELSEIF NXTSYM=TPPERR DO;
* PP ERROR.  PICK UP CHARACTER AND ERROR NUMBERS
            T←GUIT();
            I←GUIT();
            NXTSYM←TSEMI;
            SETEC(T);
            PCERR(I);
         ENDIF;
         NEXT;
         SETID();

* LOOK FOR STATEMENT INITIATOR
         IF THISYM>=BEGSPT DO;
            IF (STINIT←-KWTSTR[THISYM-BEGSPT])>0 DO;
               IF STINIT<=ENDTYPE DO;
*TYPE HEADER ON FUNCTION CALL
                  FCNTYPE←TYTTTR[STINIT-BEGTYPE];
                  GOTO STFCN1;
               ELSEIF STINIT<=ENDSI DO;
                  CHKST(STITY[STINIT-BEGSI]);
                  GOTO LABEL'FIXER(STIEX[STINIT-BEGSI]);
               ENDIF;
            ELSE DO;
               IF STINIT=-TSELSE DO;
                  GOTO STELSE;
               ELSEIF STINIT=-TSFOR DO;
                  GOTO STFOR;
               ELSEIF STINIT=-TSIF DO;
                  GOTO STIF;
               ELSEIF STINIT=-TSWHILE DO;
                  GOTO STWHILE;
               ENDIF;
            ENDIF;
         ELSEIF THISYM=TDOT DO;
* MACHINE LANGUAGE STATEMENT LIST
            REGOK←STREE←-1; CHKST(STEXPR);
MOLOOP:     NEXT;
            SETID();
            IF THISYM<BEGCHT DO;
               MLOP←(MCONNODE(THISYM) IF ISCON(THISYM) ELSE TCVC(THISYM));
            ELSEIF THISYM=TLPAR DO;
               MLOP←NEXPR();
               PCERR(5) IF THISYM#TRPAR;
            ELSE DO;
               PCERR(5);
            ENDIF;
            IF NXTSYM=TCOMMA OR NXTSYM=TSEMI DO;
               NEXT;
               MLOP←TCN2(OPMACH,MLOP,NULLCH);
            ELSE DO;
               MLOP←TCN2(OPMACH,MLOP,NEXPR());
            ENDIF;
            STREE←(MLOP IF STREE=-1 ELSE TCN2(OPSEQ,STREE,MLOP));
            GOTO ESTAT IF THISYM=TSEMI;
            PCERR(13) IF THISYM#TCOMMA;
            NEXT IF NXTSYM=TDOT;
            GOTO MOLOOP;
         ENDIF;
*NOT STATEMENT INITIATOR. CHECK FOR LABSYM
         IF NXTSYM=TCOLON DO;
            GOTO GETSTAT IF THISYM>TNLIM OR ISCON(THISYM);
            CHKST(STMISC);
            OUTDEF(THISYM) IF XREF<0;
            STREE←TCN1(OPLABEL,THISYM);
* PREVENT EXPANSION OF A FOLLOWING MACRO
            NXTSYM←TSEMI;
            NEXT;
            GOTO PARSEXIT;
         ENDIF;
* NO LABSYM EITHER. CALL EXPRESSION RECOGNIZER
         CHKST(STEXPR);
         STREE←EXPR();
* END OF STATEMENT
ESTAT:  PCERR(1) IF THISYM#TSEMI;
PARSEXIT: NPCHK();
         RETURN STREE;
PARSX0:  RETURN (STREE←0);


*FUNCTION DECLARATION
STFCN1:  IF NXTSYM=TENTRY OR NXTSYM=TFUNCTION DO;
            NEXT;
         ELSEIF NXTSYM>=BEGSPT AND (FCNLOC←-KWTSTR[NXTSYM-BEGSPT])
               >=BEGFLOC AND FCNLOC<=ENDSI DO;
            FCNLOC←ITFLTR[FCNLOC-BEGFLOC];
            NEXT; GOTO ISPEC1;
         ELSE DO;
            PCERR(6) IF FCNTYPE#TTFUNC;
STENTRY:    FCNTYPE←TTINT;
         ENDIF;
* NOW EXPECT TO SEE FUNCTION NAME AND PARAMETERS
STFCN2:  CHKST(STFD);
         FCNAME←GNAME(); NEXT;
         FCNLOC←FLNORMAL; FCNINDEX←NULLCH;
         FCNFRET←0;
         PCERR(6) IF THISYM#TLPAR;
         IF NXTSYM=TRPAR DO;
            FCNPARS←NULLCH;
            NEXT;
         ELSE DO;
            FCNPARS←DECPROC(-1);
            PCERR(6) IF THISYM#TRPAR;
         ENDIF;
* CHECK FOR FLOC
FMODLP:  IF NXTSYM=TCOMMA DO;
            NEXT; NEXT;
            IF THISYM=TFRETURN DO;
               FCNFRET←1; GOTO FMODLP;
            ENDIF;
            PCERR(6) IF THISYM<BEGSPT OR (FCNLOC←-KWTSTR[THISYM-BEGSPT])
               <BEGFLOC OR FCNLOC>ENDFLOC;
            FCNLOC←ITFLTR[FCNLOC-BEGFLOC];
            IF NXTSYM=TLARR DO;
               NEXT; FCNINDEX←NEXPR();
            ENDIF;
         ENDIF;
         STREE←TCN4(OPFDEC,FCNAME,U(FCNTYPE,DTYPE)+U(FENTRY,DFTYPE)
            +U(FCNLOC,DFLOC)+U(FCNFRET,DFRET),
            FCNPARS,FCNINDEX);
         GOTO NESTAT;

* DECLARE STATEMENT
STDECLARE: STREE←DECPROC(0);
         GOTO ESTAT;

* BLOCK START AND ORIGIN STATEMENTS
STFIXED: FCNTYPE←FFIXED;
STFX1:   NEXT;
         IF THISYM=TSEMI DO;
* NO ORIGIN
            FCNINDEX←NULLCH;
         ELSE DO;
* EXPECT ORIGIN
            IF FCNTYPE=FFIXED DO;
               NEXT; PCERR(6) IF THISYM#TORIGIN; NEXT;
            ENDIF;
            FCNINDEX←EXPR();
         ENDIF;
* CONSTRUCT FDEC NODE FOR THINGS WHICH ARE NOT FUNCTION DECLARATIONS
         FCNAME←1;
FDEC1:   STREE←TCN4(OPFDEC,FCNAME,U(FCNTYPE,DFTYPE),NULLCH,FCNINDEX);
         GOTO ESTAT;

STORIGIN: FCNTYPE←FORG; GOTO STFX1;

STCOMMON: FCNTYPE←FCSPL;
STCM1:   FCNINDEX←NULLCH;
         FCNAME←GNAME(); NEXT;
         GOTO FDEC1;

STPROGRAM: FCNTYPE←FPSPL; GOTO STCM1;


* IF STATEMENT. COLLECT EXPRESSION AND COMPILE
STIF:    STREE←TCN3(OPIF,NEXPR(),TCN0(OPBLOCK),NULLCH);
CHKDO:   PCERR(4) IF THISYM#TDO;
         CHKST(STMISC);
NESTAT:  NEXT; GOTO ESTAT;

* ELSEIF STATEMENT.  LIKE IF EXCEPT FOR
STELSF: STREE←NEXPR();
STELF1:  STREE←TCN1(OPELSEIF,STREE); GOTO CHKDO;

* ELSE STATEMENT.  LIKE ELSEIF 1;
STELSE:  NEXT; STREE←TCIC(1); GOTO STELF1;

* ENDIF STATEMENT
STENDIF: STREE←TCN0(OPENDIF); GOTO NESTAT;

* FOR STATEMENT
STFOR:   STREE←EXPR(); GOTO CHKDO;

* WHILE STATEMENT
STWHILE: STREE←TCN2(OPWHILE,TCN0(OPBLOCK),NEXPR());
       GOTO CHKDO;

* ENDFOR STATEMENT
STENDFOR: STREE←TCN0(OPENDFOR); GOTO NESTAT;

* INCLUDE STATEMENT
STINCLUDE: STREE←TCN1(OPINCLUDE,GNAME());
         WHILE NXTSYM#TSEMI DO;
            NEXT; PCERR(13) IF THISYM#TCOMMA;
            STREE←TCN2(OPSEQ,STREE,TCN1(OPINCLUDE,GNAME()));
         ENDFOR;
         GOTO NESTAT;

* MACRO STATEMENT
* COLLECT FORMAL ARGUMENTS, IF ANY
STMACRO: MACDEF();
       STREE←NULLCH;
       GOTO PARSEXIT;

* MONITOR STATEMENT
STMONITOR: FCNLOC←FLMONITOR;
ISPEC:   FCNTYPE←TTINT;
ISPEC1:  FCNAME←GNAME(); FCNINDEX←NULLCH;
         NEXT;
         IF THISYM=TLARR DO;
            FCNINDEX←NEXPR();
         ENDIF;
         STREE←TCN4(OPFDEC,FCNAME,U(FCNTYPE,DTYPE)+U(FSPEC,DFTYPE)+
               +U(FCNLOC,DFLOC),NULLCH,FCNINDEX);
         GOTO ESTAT;

* UTILITY STATEMENT
STUTILITY: FCNLOC←FLUTILITY; GOTO ISPEC;

* POP STATEMENT
STPOP:   FCNLOC←FLPOP; GOTO ISPEC;


* END STATEMENT
STEND:   STREE←TCN0(OPEND); GOTO NESTAT;

       COMMON DECVARS;
       INCLUDE PSTO;


* TWO VECTORS RECORD THE CURRENT PARAMETERS FOR
* THE DECLARATION AS A WHOLE AND FOR THE CURRENT NAME
         DECLARE ARRAY [LPARV] DCPAR,DNPAR;
*THE WORDS OF THESE ARRAYS ARE USED AS INDICATED BY
***      DQ DPDIM←0,DPSIZE←1,DPBSIZE←2,DPLENGTH←3,DPBASE←4,
***         DPFWNO←0,DPFIB←1,DPFFB←3;
* A FLAG RECORDS THE FACT THAT THE CURRENT PARAMETER NODE
         DI DECPAR;
*MUST BE RECOMPUTED
         DI PARCHANGE;
* WE ALSO NEED TO NOTE WHEN A NAME IS FOLLOWED BY PARAMETERS
          DI NAMPF;

       PROGRAM DECPROC;
       INCLUDE PARSE',DECVARS,COMM;

* DECLARATION PROCESSOR
*(REFER TO THE SPL MANUAL FOR THE SYNTAX OF DECLARATIONS)

* IF THIS IS CALLED FROM A FUNCTION DECLARATION WE MUST
* CHAIN THE DECLARE NODES, OTHERWISE CALL ZVDEC FOR EACH ONE.
* THE STATE IS RECORDED IN A COLLECTION OF VARIABLES
         DI DCTYPE,DCDTYPE,DCMODE;
* A FLAG TELLS WHETHER THE TYPE JUST SEEN IS A MODE ALSO
         DI MDTYPF;
* AND ITS KW NUMBER IS RECORDED IN CASE WE SEE ANOTHER MODE AND HAVE
* TO CHANGE IT TO TYPE
         DI MODEW;
* ANOTHER FLAG TELLS WHETHER FIELDS ARE FIXED
         DI FFFLG;
* ANOTHER FLAG FOR '@' IN A FORMAL PARAMETER
         DI ATFLG;
* GENERAL STORAGE
         DI DECKW,DECSYM,DECITEM,DECLIST,DNINIT,DNEQUIV,DNNONE;


       FUNCTION DECPROC(FDECF);
* INITIALIZE STATE
         DCTYPE←TTINT; DCDTYPE←SDNOR; DCMODE←SMVALUE;
         MDTYPF←FFFLG←0;
         CLRPAR();
         DECLIST←NULLCH;
* MAIN LOOP: GOBBLE KEYWORD, PARAMETER OR NAME
NDECLP:  DNNONE←1;
DECLP:   MDTYPF←MDTYPF+1;
         NEXT;
         IF (DECSYM←THISYM)>=BEGSPT DO;
            IF (DECKW←-KWTSTR[DECSYM-BEGSPT])>0 DO;
               IF DECKW<=ENDPTYPE DO;
*PURE TYPE WORD (OR MODE WORD USED AS TYPE)
                  DCMODE←SMVALUE;
PURETYPE:         DCTYPE←TYTTTR[DECKW-BEGTYPE];
                  CLRPAR(); TRYPAR(DCPAR,DCMODE,DCTYPE) IF DCTYPE=TTSTR;
                  DCDTYPE←(ITSDTR[DECKW-BEGTYPE] IF DECKW<=ENDITYPE ELSE
                     SDNOR);
               ELSEIF DECKW<=ENDMODE DO;
                  DCMODE←TYSMTR[DECKW-BEGMODE];
DECL1:            CLRPAR();
                  TRYPAR(DCPAR,DCMODE,DCTYPE);
                  IF MDTYPF<0 DO;
* WE JUST SAW A MODE WORD. CONVERT IT TO A TYPE
                     DECKW←MODEW;
                     GOTO PURETYPE;
                  ELSEIF DECKW<=ENDTYPE DO;
                     MDTYPF←-2;
                     MODEW←DECKW;
                  ENDIF;
               ELSEIF DECKW=KWSIGNED DO;
* MUST HAVE FIELD NEXT
                  PCERR(3) IF MDTYPF<0 OR (DECKW←NXTSYM)#TFIELD;
                  NEXT; DCMODE←SMSFIELD; GOTO DECL1;
               ELSEIF DECKW=KWFIXED DO;
                  FFFLG←1;
               ELSEIF DECKW=KWPARAM DO;
               ELSE DO;
                  PCERR(3);
               ENDIF;
            ELSE DO;
               PCERR(3);
            ENDIF;
            DNNONE←0;
            GOTO DECLP;
         ELSE DO;
* TRY FOR '@' IF FUNCTION DECLARATION
            IF FDECF<0 AND DECSYM=TAT DO;
               ATFLG←1;
               DECSYM←NEXT;
            ELSE DO;
               ATFLG←0;
            ENDIF;
* NAME
            PCERR(5) IF DECSYM>=TNLIM;
            OUTDEF(THISYM) IF XREF<0;
            DNINIT←DNEQUIV←NULLCH;
            BCOPY(@DNPAR[0],@DCPAR[0],LPARV);
            NAMPF←0;
            IF NXTSYM#TCOMMA DO;
* EXPECT PARAMETER, EQUIVALENCE OR INITIALIZATION
               TRYPAR(DNPAR,DCMODE,DCTYPE);
               NEXT;
               IF THISYM=TEQUAL DO;
* EQUIVALENCE.  ALLOW G' OR L' IN EXPRESSION BUT NOT ←
                  KNLARRF←-1;  REGOK←6B7;
                  DNEQUIV←NEXPR();
                  KNLARRF←REGOK←0;
               ENDIF;
               IF THISYM=TLARR DO;
* INITIALIZATION
                  DNINIT←NEXPR();
               ENDIF;
            ELSE DO;
               NEXT;
            ENDIF;
* COMPLETED ITEM
* CONSTRUCT PARAMETER CHAIN
            IF PARCHANGE<0 DO;
               DECPAR←TCN5(OPPARAM,DNPAR[DPDIM],DNPAR[DPSIZE],
                  DNPAR[DPBSIZE],DNPAR[DPLENGTH],DNPAR[DPBASE]);
               PARCHANGE←0 IF NAMPF>=0;
            ENDIF;
            SETID();
            DECITEM←TCN5(OPVDEC,DECSYM,U(DCTYPE,DTYPE)+
               U(DNNONE,DNONE)+U(FDECF,DFPAR)+U(ATFLG,DFREF)+
               U(DCDTYPE,DDTYPE)+U(DCMODE,DMODE)+U(FFFLG,DFXFD),
               DECPAR,DNINIT,DNEQUIV);
            IF FDECF<0 DO;
               DECLIST←TCN2(OPCHAIN,DECITEM,DECLIST);
            ELSE DO;
               TCPNT(DECITEM) IF TREEFLAG;
               TEVDEC(DECITEM);
            ENDIF;
            GOTO NDECLP IF THISYM=TCOMMA;
* COMPLETED DECLARATION
            RETURN DECLIST;
         ENDIF;

       PROGRAM GETPAR;
       INCLUDE PARSE',DECVARS;

*TRY FOR PARAMETERS (FORM,LENGTH,DIMENSION)
         FUNCTION TRYPAR(ARRAY PARVEC,INTEGER PARMODE,PARTYPE);
TRYPLP:  IF NXTSYM=TLPAR DO;
* FORM OR LENGTH
            NEXT;
            IF PARMODE=SMFIELD OR PARMODE=SMSFIELD DO;
*FORM
               PARVEC[DPFWNO]←NEXPR();
               IF THISYM=TCOLON DO;
                  PARVEC[DPFIB]←NEXPR();
                  PARVEC[DPFFB]←(NEXPR() IF THISYM=TCOMMA ELSE
                                 PARVEC[DPFIB]);
               ELSE DO;
                  PARVEC[DPFIB]←TCIC(0); PARVEC[DPFFB]←TCIC(23);
               ENDIF;
            ELSEIF PARTYPE=TTSTR AND (PARMODE=SMVALUE OR PARMODE=SMARRAY) DO;
*LENGTH
               PARVEC[DPLENGTH]←NEXPR();
               PARVEC[DPBASE]←NULLCH;
               IF THISYM=TCOLON DO;
                  IF NXTSYM=TCOMMA OR NXTSYM=TRPAR DO;
                     PARVEC[DPBSIZE]←TCIC(8);
                     NEXT;
                  ELSE DO;
                     PARVEC[DPBSIZE]←NEXPR();
                  ENDIF;
                  IF THISYM=TCOMMA DO;
                     PARVEC[DPBASE]←NEXPR();
                  ENDIF;
               ENDIF;
            ELSE DO;
               PCERR(3);
            ENDIF;
            PCERR(3) IF THISYM#TRPAR;
            GOTO GOTPAR;
         ELSEIF NXTSYM=TLBRAK DO;
            IF PARMODE=SMARRAY OR PARMODE=SMARR1 DO;
* DIMENSION
               NEXT;
               PARVEC[DPDIM]←PARVEC[DPBASE]←NULLCH;
DIMLP:         PARVEC[DPDIM]←TCN2(OPCHAIN,NEXPR(),PARVEC[DPDIM]);
               GOTO DIMLP IF THISYM=TCOMMA;
               IF THISYM=TCOLON DO;
                  PARVEC[DPSIZE]←NEXPR() IF NXTSYM#TCOMMA ELSE NEXT;
               ENDIF;
               PARVEC[DPBASE]←NEXPR() IF THISYM=TCOMMA;
            ELSE DO;
               PCERR(3);
            ENDIF;
            PCERR(3) IF THISYM#TRBRAK;
GOTPAR:     PARCHANGE←NAMPF←-1; GOTO TRYPLP;
         ENDIF;
         RETURN;


*CLEAR STATE OF PARAMETERS
         FUNCTION CLRPAR();
         BSET(@DCPAR[0],NULLCH,LPARV);
         PARCHANGE←0; DECPAR←NULLCH;
         RETURN;

       PROGRAM MISC'PARSE;
       INCLUDE PARSE';


*GET EXPRESSION STARTING AT NEXT TOKEN
         FUNCTION NEXPR();
         NEXT; RETURN EXPR();


* MAKE OPERAND A CHAIN IF IT IS NOT ALREADY ONE
         FUNCTION MCHAIN(POINTER MCHARG);
         IF (T←MCHARG.TOPR)#OPCHAIN AND T#OPNIL DO;
            MCHARG←TCN2(OPCHAIN,MCHARG,NULLCH);
         ENDIF;
         RETURN MCHARG;


* BUMP SOURCE AND COLLECT NAME
         FUNCTION GNAME();
         NEXT;
         SETID();
         PCERR(5) IF THISYM>=TNLIM;
         OUTDEF(THISYM) IF XREF<0;
         RETURN THISYM;


* CHECK STATEMENT FOR CORRECT TYPE
         FUNCTION CHKST(CHKSARG);
         STYPE←CHKSARG;
         RETURN IF (STYPE A' STYPES)#0;
         GOTO PARSXL;

* ERROR.  PASS IT ON.  NOTE LOCATION FIRST
         FUNCTION PCERR(CERRNO);
         SETID();
         CERR(CERRNO);* MAY CONTINUE
         RETURN;

* TEST TOKEN FOR CONSTANT, STRING CONSTANT
       FUNCTION ISCON(TKN);
       RETURN (TKN<0);
       FUNCTION ISTRC(TKN);
       RETURN (TKN=-TTSTR);
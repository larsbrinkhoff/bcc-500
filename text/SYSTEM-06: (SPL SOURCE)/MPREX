       COMMON PRE1';
       INCLUDE COMM,STDEC,KTDEC,STST,PRST;


* THIS FILE CONTAINS THE SPL PREPROCESSOR, UTILITY ROUTINES.







       PROGRAM PMAIN;
       INCLUDE PRE1';

* MAIN DRIVING FUNCTION FOR PREPROCESSOR. PMOPT1 SELECTS AMONGST
* VARIOUS PREPROCESSOR LANGUAGE OPTIONS, PMOPT2 SELECTS
* VARIOUS OPTIONS WITHIN THE SELECTED LANGUAGE. PMFIL IS THE INPUT
* TEXT FILE NUMBER. THE FOLLOWING DEFINES WHERE PREPROCESSED LINES GO:
* PLITN PLISI
*   N     M   INSERT IN IB N BEFORE SI M
*   0     M   ERROR
*   N     0   APPND TO THE END OF THE IB PRIOR TO IB N
*   0     0   APPND TO THE END OF THE LAST IB

FUNCTION ZPMAIN(PMFIL,PMOPT1,PMOPT2), FRETURN;
       PLFILE←PMFIL; PLTYP←PMOPT1;
       PLEXI(PMOPT1,PMOPT2); *INITIALIZE PREPROCESSOR
       PLERR←0;
       IF PLITN=0 DO;
          CERR(131) IF PLISI#0;
          SSELECT(0); SSELECT(ICLSTAT);
       ELSEIF PLISI#0 DO; SSELECT(PLITN);
       ELSE DO;
           PLITN←SGPREV(PLITN//PML7); * SELECT PREVIOUS BLOCK
           SSELECT(PLITN);
PML11: ENDIF;
       EDTERM←0;
PML1:  IFQUIT(//PML6);
       PMGT(PMFIL//PML5); * GET TEXT INTO STRING PIS
PML2:  PLEX(//PML4); GOTO PML1; * PREPROCESS AND REPEAT
PML4:  PLER(//PML6);
       GOTO PML2 IF LENGTH(PIS)#0;
       XS22(); GOTO PML1;
PML5:  PLCB(); RETN;
PML6:  PLCB(); CLOSE'SEQ'FILE(PLFILE)IF PLFILE>0; FRETN;
PML7:  CERR(129);



       PROGRAM PPDS;
       INCLUDE PRE1';

       DI PPDX1,PPDX2;

FUNCTION ZPPDS(STRING PPDSS,INTEGER PPDOPT), FRETURN;
       PLERR←0; PLFILE←-1;
       FRETN IF ICBA.IBFTYPE#IBFTSPL;
       PLEXI(0,PPDOPT);
       APPND(PIS,PPDSS//PPDL5);
PPDL3: GOTO PPDL6 IF PLFG$PLFG4#1;
       IF PLITN=0 DO;
          CERR(131) IF PLISI#0;
          SSELECT(0); SSELECT(ICLSTAT);
       ELSEIF PLISI#0 DO; SSELECT(PLITN);
       ELSE DO;
          PLITN←SGPREV(PLITN//PPDL7); * SELECT PREVIOUS BLOCK
           SSELECT(PLITN);
PPDL9: ENDIF;
PPDL6: PLEX(//PPDL4); RETN;
PPDL4: PLER(//PPDL5); GOTO PPDL6 IF LENGTH(PIS)>0;
PPDL5: FRETN;
PPDL7: CERR(129);

       PROGRAM PMGT;
       INCLUDE PRE1';

* THIS FUNCTION GETS A LINE OF TEXT FROM FILE PMFILE AND
* PUTS IT IN STRING PIS.  FRETN IF NO MORE.

FUNCTION PMGT(PMFILE), FRETURN;
       IF PMFILE=TTYIN DO;
           FRETN IF EDTERM='%';
           SETR(PIS,0);
          PIS←ZEDIT(PIS,0,4B7//PMGL6);
          FRETN IF EDTERM='%' AND LENGTH(PIS)=0;
          RETN;
       ENDIF;
       SETS(PIS);
       PIS←GCI'FROM'FILE(PMFILE, PIS//PMGL4);
       RETN;
PMGL4: CLOSE'SEQ'FILE(PMFILE); PLFILE←-2;
       FRETN;
PMGL6: PXERR(133);



       PROGRAM PLEX;
       INCLUDE PRE1';

       DECLARE INTEGER PLX1,PLX2;

FUNCTION PLEX(), FRETURN;
       PLIDF←PLBCT←PLBM←0;
       PLNI←@PLT[0];
       PPTB[0]←PPTB[1]←PPTB[2]←0;
       PIT←PTTO-1;
       SETS(PLSTR);
PL1:   PLCH←GCI(PIS//PL9);
PL2:   IF PLCH>77B DO;
          IF PLCH>=CHMB1 AND PLCH<=CHMB2 DO;
             PLBCT←PLBCT+PLCH-CHMB1-1;
             PLCHC←PCT[' '];
          ELSE DO;
             PLCHC←PCT[100B];
          ENDIF;
       ELSE DO;
       PLCHC←PCT[PLCH]; *GET CHARACTER CLASS
       ENDIF;
       GOTO PL4;
PL3:   PLNI←PLNI+2;
PL4:   GOTO PL3 IF (PLCHC AA $PLNI)=0;
       PLSN←(PLX2←PLNI←PLNI+1).PLF3;
       IF PLNI.PLF8 DO;
          WCI(PLCH,PLSTR//PL7);
       ENDIF;
       PLNI←@PLT[PLNI.PLF7];
       IF PLX1←PLX2.PLF6 DO;
          PLPAR←PLX2.PLF9;
          (PAT[PLX1])();
          SETS(PLSTR);
       ENDIF;
       FRETN  IF PLERR#0;
       GOTO PL1 IF PLSN ELSE GOTO PL4;
PL7:   PLERR←155;FRETN;
PL9:   IF PLCH#CHNL DO; *FAKE NEWLINE TO FORCE OUT LAST SYMBOL
           PLCH←CHNL;
           GOTO PL2;
       ENDIF;
       RETN;



       PROGRAM PLEXI;
       INCLUDE PRE1';

* THIS FUNCTION INITIALIZES THE PREPROCESSOR
       DI PLXIX1,PLXIX2;
       DS PLXIS1;
       DA PLXIAA[5]←(@PCT,@PAT,@PLT,@KWTB,@KWTBX);
       DECLARE ARRAY FIELD PLXIAF(0);

FUNCTION PLEXI(PLOPT,PLOPTF);
       SETS(PIS);
       PLXIX1←@PPOPT[PLOPT*PPOPTI];
       PLXIAA[PLXIX2].PLXIAF←PLXIX1[PLXIX2].PLXIAF FOR PLXIX2←0 TO 4;
       PLISI1←PLISI2←PLITN1←PLITN2←PLWDCT←0;
       PLLNCT←0; PLFG←(PPOPTF[PLOPTF]IF PLOPTF<8 ELSE PLOPTF);
       SETUP(PLIDS,SYMAXCN,@PLID[0],6);
       RETURN;



       PROGRAM KWTK;
       INCLUDE PRE1';

* THIS FUNCTION WILL SRETURN A TOKEN NUMBER IF THE KWTB KEYWORD TABLE
* CONTAINS THE CHARACTER STRING IN KWDS, OTHERWISE IT
* WILL RETURN.
       DI KWTX1,KWTX2,KWTX3;
       DFF KWTC0(0:0,5),KWTC3(0:18,23);

FUNCTION KWTK(), FRETURN;
       FRETN IF (PWFL←PLID[0]$KWTC0)>KWTBX[1]$KWF4;
       FRETN IF (KWTX3←PWFL-KWTBX[0]$KWF3)<0;
       FRETN IF(KWTX3←KWTBX[2+KWTX3]$KWF7)=0;
       KWTX1←PWLS RSH 2;
       PLID[KWTX1]$KWTC3←PWFL;
       PLID[0]$KWTC0←PWLS-1;
KWL3:  GOTO KWL4 IF KWTB[KWTX2+KWTX3]#PLID[KWTX2]FOR KWTX2←0 TO KWTX1;
       RETN KWTB[KWTX3-1]$KWF2+KWTBX[1]$KWF6;
KWL4:  GOTO KWL3 IF (KWTX3←KWTB[KWTX3-1]$KWF1)#0;
       PLID[0]$KWTC0←PWFL;
       PLID[KWTX1]$KWTC3←0;
       FRETN;



       PROGRAM PUTEXT;
       INCLUDE PRE1';

* THIS FUNCTION WILL PUT TEXT FROM PIS DIRECTLY INTO PPTB.
* IT IS USED FOR COMMENTS AND ERRORS.  THIS ROUTINE IGNORES ITS
* ONLY ERROR, PPTB OVERFLOW, TO AVOID A POSSIBLE INFINITE LOOP
* SINCE THIS ROUTINE IS USED TO PACK ERROR LINES.
       DS PUTST;
       DI PUTEX1,PUTEX2,PUTEX3;

FUNCTION PUTEXT(PTXFLG);
*****
*     5/16/73    JACK FREEMAN
*     KLUDGE TO AVOID EXTRA NEW-LINE AFTER COMMENTS
        PUTEX1←GCD(PIS//PUTL0);
        IF PUTEX1#CHNL DO;
           WCI(PUTEX1,PIS);
        ENDIF;
PUTL0:
*****
       PUTN(0); *RESERVE SPACE FOR NUMBER OF BYTES
       PUTEX1←PIT; *REMEMBER INDEX FOR NUMBER OF BYTES
       PUTN(0) IF (PIT AA 1)=0; *FILL OUT WORD IF NECESSARY
       SETUP(PUTST,3*ITLN,PPTA,8);
       SETS(PUTST,0,((PIT+1)*3+1)/2);
       SETR(PIS,GETR(PIS)-1); *ADJUST FOR TOKEN CHARACTER
       PUTEX2←GETW(PUTST); *SAVE FOR BYTE COUNT
       IF PTXFLG=0 DO; *IF COMMENT TEXT...
PUTL1:     WCI(PUTEX3,PUTST//PUTL3) WHILE (PUTEX3←GCI(PIS//PUTL2))#'*';
           WCI(PUTEX3,PUTST//PUTL3);
PUTL4:     WCI(PUTEX3←GCI(PIS//PUTL2),PUTST//PUTL3);
       GOTO PUTL4 IF PUTEX3='*' OR (GETW(PUTST) - PUTEX2) < 4;
           GOTO PUTL1 IF PUTEX3#'/'; *KEEP GOING IF COMMENT NOT TERMINATED
       ELSE DO; *COPY TO END OF STRING.
           WCI(GCI(PIS//PUTL2),PUTST//PUTL3) WHILE 1;
       ENDIF;
       GOTO PUTL2;
PUTL3: SETW(PIS,GETR(PIS)); *AVOIDS INFINITE LOOP
PUTL2: PUTEX2←GETW(PUTST)-PUTEX2; *COMPUTE NUMBER OF BYTES
       PHW(PPTB,PUTEX1,PUTEX2); *SET NUMBER OF BYTES
       PIT←PIT+(PUTEX2*2+2)/3;*INCREMENT INDEX
       RETURN;



       PROGRAM PLTN;
       INCLUDE PRE1';

* INSERTS TOKEN NUMBERS IN PPTB AND REMEMBERS END OF STATEMENT SENSED.
       DI PLTNX1,PLTNX2;

FUNCTION PLTN(PLTNN);
       GOTO PLTNL1 IF PLFG$PLFG6=1 OR PLBCT=(PLTNX1←PBLANK(PLTNN));
       IF PLBCT=1 DO;
          IF PLTNN>=TNRMIN AND PLTNN<TNKMIN DO;
             PLTNN$OPTLB←1;
          ELSEIF PLTNX2>=TNRMIN AND PLTNX2<=TNKMIN AND PLTNX2$
           OPTRB=0 WHERE PLTNX2←GHW(PPTB,PIT) DO;
             PHW(PPTB,PIT,(PLTNX2+U(1,OPTRB)));
          ELSE DO;
             GOTO PLTNL3;
          ENDIF;
          GOTO PLTNL1;
       ENDIF;
PLTNL3: WHILE PLBCT>=0 DO;
           IF (PIT←PIT+1)>ITNI DO;
               PLERR←156; RETURN;
           ENDIF;
           PHW(PPTB,PIT,TNBMAX) IF PLBCT>TNBMAX-TNBMIN ELSE
            PHW(PPTB,PIT,(TNBMIN+PLBCT));
           PLBCT←PLBCT-TNBMAX+TNBMIN;
       ENDFOR;
PLTNL1:PLBCT←0;
PLTNL2:
* ENTRY TO SUPPRESS INTERPRETATION OF TOKEN
ENTRY PUTN(PLTNN);
       IF(PIT←PIT+1)>ITNI DO; PLERR←156; RETURN;
       ENDIF;
       PHW(PPTB,PIT,PLTNN);
       RETURN;



       PROGRAM PLCB;
       INCLUDE PRE1';

* THIS FUNCTION CLOSES THE CURRENT IB.

FUNCTION PLCB();
       RETURN IF ICGTN=0; SFIN(10);
       RETURN;



       PROGRAM PLER;
       INCLUDE PRE1';

* THIS FUNCTION CREATES AN ERROR MESSAGE LINE
       DI PLERX1, PXERRN;

FUNCTION PLER(), FRETURN;
       FRETN IF PLFG$PLFG5=0;
       PLERX1←PLERR;
       PLERR←0;
       PIT←PTTO-1;
       PUTN(TKN55);
       PUTN(GETR(PIS)-1);
       PUTN(PLERX1);
       SETR(PIS,0);
       PUTEXT(1);
       RETN;

* ENTRY FOR PP ERROR ACTIONS:
* PLPAR=148: ILLEGAL 6 BIT CHARACTER
*       151: ILLEGAL D EXPONENT
*       152: ILLEGAL E EXPONENT

FUNCTION XSERR();
       PLERR←PLPAR;
       RETURN;


* A CATASTROPHIC ERROR WHICH CANNOT BE RECOVERED FROM GRACEFULLY
* HAS BEEN FOUND.  TRY TO PRESERVE THE CURRENT STATE PRIOR TO THE
* ERROR AND ABORT.

* ENTRY AS PP ACTION:
* PLPAR=137: IMPOSSIBLE ERROR
*       157: PROGRAM OR COMMON NOT FOLLOWED BY VALID IDENTIFIER

FUNCTION XSXERR();
       PXERRN←PLPAR;
FUNCTION PXERR(PXERRN);
       PLCB(); * CLOSE CURRENT IB
       CLOSE(PLFILE) IF PLFILE>0; * CLOSE INPUTE FILE IF OPEN
       CERR(PXERRN); * ABORT
       HALT();* CONTROL SHOULD NEVER REACH HERE

       PROGRAM PBLANK;
       INCLUDE PRE1';

***
*** PBLANK(N)
***
* GIVES THE NUMBER OF BLANKS (0 OR 1) TO BE INSERTED
* BETWEEN THE PREVIOUS TOKEN AND THE TOKEN N,
* WHEN STANDARD SPACING IS BEING USED.
* THIS IS DONE BY LOOKING UP [CLASS(PREVIOUS),CLASS(N)]
* IN A BINARY MATRIX.  CLASSES GO FROM 1-24 AND ARE:
* 1: IDENTIFIERS, CONSTANTS
* 2: COMMENTS, FORMAT EFFECTORS
* 3: RESERVED WORDS
* 4: OPERATOR CHARACTERS
* 5: BEGIN/END OF LINE (REPRESENTED BY 6000B TOKEN)
* 6: ([
* 7: )]
* 8: ;
* 9: N', NOT, TYPE WORDS
* 10: &
* 11: CONTINUE STRING

       DI PBC,PBVAL;
* DISPATCH ON TOP 4 BITS OF TOKEN
       DF PTDISC(0:12,15);
       DECLARE SWITCH PTDA[20B]←(PBI,PBI,PBI,PBI,PBI,PBI,PBI,PBI,
        PBI,PBI,PBI,PBI,PBOP,PBRW,PBI,PBF);
* DETERMINE CLASS FROM OPERATOR TOKEN
       DF PBONF(0:18,23);
       DA PBOCA[20B]←(
        05040004B,04041200B,06070404B,04040404B,
               0B,       0B,00000410B,04040404B,
        04000000B,       0B,       0B,       0B,
               0B,       0B,00000006B,04070404B);
* DETERMINE CLASS FROM RESERVED WORD TOKEN (BIT TABLE)
       DF PRWWF(0:16,19);
       DF PRWSF(0:20,23);
       DA PRWA[5]←(
        31140000B,11023400B,06443400B,00000000B,60000000B);
* DETERMINE CLASS FROM FUNNY TOKEN
       DF PBFNF(0:17,23);
       DA PBFCA[4]←(2,2,2,11);
* MAIN SPACING MATRIX
       DECLARE ARRAYONE PBBA[11]←(
        50160000B,       0B,55160000B,10040000B,
               0B,       0B,50160000B,55160000B,
        54160000B,55120000B,       0B);

FUNCTION PBLANK(PBTN);
       GOTO LABEL'FIXER(PTDA[PBTN$PTDISC]);
PBI:   PBC←1;
PBRET: PBVAL←(PLBM LCY PBC) A' 1;
       PLBM←PBBA[PBC];
       RETURN PBVAL;
PBF:   PBC←PBFCA[PBTN$PBFNF];
       GOTO PBRET;
PBOP:  PBC←$INCDES(40B6+@PBOCA[0],PBTN$PBONF);
       GOTO PBRET;
PBRW:  PBC←(9 IF PRWA[PBTN$PRWWF] LCY PBTN$PRWSF<0 ELSE 3);
       GOTO PBRET;

       PROGRAM PACK;
       INCLUDE PRE1';

* THIS FUNCTION PACKS 4-BIT BYTES INTO PPTB FROM STRING PACKS.
* PKCN SHOULD BE PRESET TO THE FIRST BYTE POSITION
* AND IS INCREMENTED FOR EACH BYTE STORED.
* PIT IS ALSO INCREMENTED PROPERLY.
       DA PAKCA[33B]←(KCPLUS,-1,KCMINUS,KCDOT,-1,
        0,1,2,3,4,5,6,7,8,9,-1,-1,-1,-1,-1,-1,
        -1,-1,KCB,-1,KCD,KCE);
       DI PAKX1,PAKX2;

FUNCTION PACK(STRING PACKS);
       PAKX2←@PPTB[PIT RSH 1];
       PHW(PPTB, PIT+1, 0) IF PKCN = 12;
       WHILE 1 DO;
           PAKX1←PAKCA[GCI(PACKS//RETURN)-'+'];
           (PLERR←148 & RETURN) IF PAKX1=-1;
           IF (PKCN←PKCN-4)<0 OR PKCN=8 DO;
               PIT←PIT+1;
               (RETURN WHERE PLERR←156) IF PIT>ITNI;
               ($(PAKX2←PAKX2+1)←0 & PKCN←20) IF PKCN<0;
           ENDIF;
           $PAKX2←$PAKX2+PAKX1 LSH PKCN;
       ENDFOR;

       PROGRAM PPCON;
       INCLUDE PRE1';

* THIS FUNCTION PACKS A CONSTANT HEADER INTO PPTB
* AND SETS UP PKCN FOR FUTURE CALLS OF PACK.
* A SECOND ENTRY ALSO CALLS PACK

       DS PPCS;
       DECLARE INTEGER SAVED'PIT;

FUNCTION PPCH(PPCTYP,PPCTKN,PPCCC);
       PPCTKN$KTTYPE←PPCTYP; PPCTKN←PPCTKN+KTMIN;
       IF PPCCC>FRMASK(KTSIZE) DO;
           PLTN(PPCTKN);
           PUTN(PPCCC);
       ELSE DO;
           PPCTKN$KTSIZE←PPCCC;
           PLTN(PPCTKN);
       ENDIF;
       SAVED'PIT←PIT;
       PUTN(0) IF( PPCTYP=KTSTR OR PPCTYP=KTCHAR) AND PIT A' 1=0;
       PKCN←(0 IF PIT A' 1 ELSE 12);
       RETURN (SAVED'PIT IF PPCTYP=KTSTR OR PPCTYP =KTCHAR ELSE PKCN);

* ENTRY AS PP ACTION

FUNCTION XSCON();
       PPCH(PLPAR,0,LENGTH(PLSTR));
       PACK(PLSTR);
       RETURN;



       PROGRAM XSOP;
       INCLUDE PRE1';

* THE BEGINNING OF COMMENT HAS BEEN DETECTED.  THIS
* FUNCTION PACKS THE COMMENT STRING IN PPTB, THREE CHARACTERS PER 
* WORD, AND RETURNS WITH CR AS NEXT CHARACTER.  MULTIPLE BLANKS
* ARE EXPANDED.

FUNCTION XS1();
       PLTN(TKN50); *PUT OUT COMMENT TOKEN
       PUTEXT(1); *PUT OUT COMMENT
       RETURN;


* A SINGLE OPERATOR HAS BEEN DETECTED

FUNCTION XS2();
       IF GC(PLSTR)='/' DO;*IF COMMENT....
           GOTO XS2L1 IF LENGTH(PIS)<=0 OR GC(PIS)#'*';
           PLTN(TKN50); *PUT OUT COMMENT TOKEN
           PUTEXT(0);
       ELSE DO;
XS2L1:     PLTN(TNRMIN+GCI(PLSTR));
       ENDIF;
       RETURN;


* BLANK CHARACTER SENSED.

FUNCTION XS10();
       PLBCT←PLBCT+1;
       RETURN;



       PROGRAM XS3;
       INCLUDE PRE1';

* AN IDENTIFIER OR KEYWORD HAS BEEN COLLECTED

       DECLARE INTEGER XS3X1,XS3X2;
       DS XS3S1;

FUNCTION XS3();
       XS3S1←PLSTR;
       PWLS←LENGTH(XS3S1);
       (RETURN WHERE PLERR←153) IF PWLS>SYMAXCN;
       PLID[PWLS RSH 2]←0;
       SETS(PLIDS);
       WCI(GCI(XS3S1//XS3L7),PLIDS) WHILE 1;
XS3L7: XS3X1←KWTK(//XS3L1);
       PXERR(136) IF PLIDF#0;
       IF (XS3X1=TKN1 OR XS3X1=TKN2) AND PLFG$PLFG2#2 DO;
          PLIBTP←(IBTFN IF XS3X1=TKN2 ELSE IBTCB);
          PLIDF←1; PLNI←@PLT[X23];
       ENDIF;
       GOTO XS3L2;
XS3L1: XS3X2←(PWLS+3) RSH 2;
       IF PLIDF DO;
          PLIDF←0;
          PXERR(134) IF PLFG$PLFG2=0;
          PLCB();
          SSELECT(0);
          PXERR(135) IF XS3X1←SSFIND(PLID,XS3X2);
          ZNEWIB(XS3X1←SSINS(GSLE),PLIBTP,
           SGNEXT(PLITN//VALUE 0) IF PLITN ELSE 0);
          SSELECT(XS3X1);
       ENDIF;
       RETURN IF PLERR#0;
       IF (XS3X1←SSFIND(PLID,XS3X2))=0 DO;
          IF PLFG$PLFG1=1 AND ICGTN#0 DO; XS3X1←SSINS(0);
          ELSE DO; PLERR←146; RETURN;
          ENDIF;
       ENDIF;
XS3L2: PLTN(XS3X1);
       RETURN;


* 8 BIT CHARACTER DETECTED.

FUNCTION XS17();
       IF PLCH=CHFF DO; *FORM FEED CHARACTER
           PLTN(TKNCL);
       ELSEIF PLCH=CHNL DO; *NEW LINE CHARACTER
           XS22();
       ENDIF; *IGNORE ALL OTHER EIGHT BIT CHARACTERS
XS17L1:RETURN;



       PROGRAM XS22;
       INCLUDE PRE1';

* THIS FUNCTION INSERTS THE TOKENS GATHERED IN PPTB INTO
* A BLOCK.
       DI XS22X1,XS22X2;
       DP XS22X3;

FUNCTION XS22();
       PPTA.PTSIZE←(PIT+2) RSH 1;
       PPTA.PTONT←PIT AA 1B;
       PPTA.PTRECOMP←1;
       PPTA.PTEOS ← 1;
       IF PLFG$PLFG4=0 DO; PLERR←158; RETURN;
       ENDIF;
       IF PLFG$PLFG4=1 DO;
          PXERR(138) IF ICGTN=0;
          PXERR(131) IF PLISI#0 AND ICGTN#PLITN;
          XS22X3←PSTINS(PLISI,PPTB);
       ENDIF;
       IF PLISI1=0 DO;
          PLISI1←XS22X3;
          PLITN1←ICGTN;
       ENDIF;
       PLISI2←XS22X3; PLITN2←ICGTN;
       PLLNCT←PLLNCT+1;
       IF PLFG$PLFG4=1 DO;
          PPTB[0]←PPTB[1]←PPTB[2]←0; PIT←PTTO-1;
       ENDIF;
       RETURN;



       PROGRAM XS24;
       INCLUDE PRE1';

* THIS FUNCTION CONVERTS SPL PSEUDO CHARACTERS INTO CHARACTERS
       DI XS24X1,XS24X2;

FUNCTION XS24(), FRETURN;
       IF(XS24X1←GCI(PIS//XS24L1))>='A' AND XS24X1<='Z' DO;
          RETN XS24X1+300B;
       ELSEIF XS24X1>='0' AND XS24X1<='3' DO;
          XS24X1←XS24X1-'0';
          GOTO XS24L1 IF(XS24X2←GCI(PIS//XS24L1))<'0' OR XS24X2>'7';
          XS24X1←(XS24X1 LSH 3)+XS24X2-'0';
          GOTO XS24L1 IF(XS24X2←GCI(PIS//XS24L1))<'0' OR XS24X2>'7';
          RETN ((XS24X1 LSH 3)+XS24X2-'0');
       ELSEIF XS24X1='&'' OR XS24X1='&"' OR XS24X1='&&' DO;
          RETN XS24X1;
       ELSEIF XS24X1='/' DO;
          RETN CHNL;
       ELSEIF XS24X1='%' DO;
          RETN CHFF;
       ENDIF;
XS24L1:PLERR←150; FRETN;



       PROGRAM XSSTR;
       INCLUDE PRE1';

* THIS FUNCTION CONVERTS STRING OR CHARACTER CONSTANTS
* AND PUTS THEM IN PPTB.  PLPAR=1 FOR STRING, 0 FOR CHAR.
* EXPECTS '6' OR '8', IF PRESENT, IN PLSTR.
* SETS PLERR IF ERROR ENCOUNTERED
       DI XSSX2,XSSX3,XSSX4,XSSX5,XSSX6,XSSX7;
       DS XSSS1;

FUNCTION XSSTR();
       XSSX2←('"' IF PLPAR ELSE '&'');
       XSSX3←1@KTCSIZE; XSSX4←8;
       IF (XSSX5←GCI(PLSTR//XSSL6))='6' DO;
          XSSX3←1@KT6V8; XSSX4←6;
       ELSEIF XSSX5='8' DO;
          XSSX3←1@KT6V8 V' 1@KTCSIZE;
       ELSE DO;
XSSL1:    PLERR←(154 IF PLPAR ELSE 147); RETURN;
       ENDIF;
XSSL6: XSSX6←PPCH(KTSTR IF PLPAR ELSE KTCHAR,XSSX3,FRMASK(KTSIZE)+1);
*****
* 5/8/73 JACK (SHERLOCK) FREEMAN
* THE FOLLOWING TWO USES OF SETUP CANNOT BE COM-
* BINED BECAUSE SPL REQUIRES THE CHARACTER SIZE GIVEN
* TO SETUP TO BE A CONSTANT.
*****
       IF XSSX4=6 DO;
          SETUP(XSSS1,(ITNI*12)/XSSX4,PPTA,6);
       ELSEIF XSSX4=8 DO;
          SETUP(XSSS1,(ITNI*12)/XSSX4,PPTA,8);
       ELSE DO;
          GOTO XSSL1;
       ENDIF;
       XSSX5←((PIT+1)*12+XSSX4-1)/XSSX4;
       SETS(XSSS1,0,XSSX5);
       WHILE (XSSX3←GCI(PIS//XSSL2))#XSSX2 DO;
          IF XSSX3='&&' DO;
             XSSX3←XS24(//XSSL1);
          ELSEIF XSSX3>=CHMB1 AND XSSX3<=CHMB2 DO;
             WCI(' ',XSSS1//XSSL5) FOR XSSX3←XSSX3-1 BY -1 TO CHMB1;
             GOTO XSSL3;
          ENDIF;
          GOTO XSSL1 IF XSSX3>77B AND XSSX4=6;
          WCI(XSSX3,XSSS1//XSSL5);
XSSL3: ENDFOR;
XSSL2: XSSX7←GETW(XSSS1)-XSSX5;
       PHW(PPTB,XSSX6,XSSX7);
       PIT←PIT+(XSSX7*XSSX4+11)/12;
       RETURN;
XSSL5: PLERR←156; RETURN;

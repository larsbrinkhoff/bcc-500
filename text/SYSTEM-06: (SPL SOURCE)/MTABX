       COMMON STAB';
       INCLUDE COMM,STDEC,STST;

* MACRO FOR CAREFUL ARRAY REFERENCES
       MACRO PUT'REF(PTR,ARR,I,FR)←
        .LDX I, EAX $(ARR$Z), TSB FR, STX PTR;
       DECLARE FIELD Z(0);* KLUDGE


*********************
* SPL TABLE MANAGER *
*********************




***
*** CERR(N)
***
* COMPILER ERROR MESSAGE N



       PROGRAM CERR;
       INCLUDE STAB';

       DECLARE INTEGER L0=L'[0],L1=L'[1];

       DECLARE STRING LS00←":&/",HS00←">HELP!< # # /";
       DECLARE INTEGER I00,F00,J00;
* 9/30/74  JACK FREEMAN: CHANGED THE FOLLOWING LABEL ARRAY
* SO THAT ERRORS OF "LEVEL 2" WILL BE TREATED LIKE ERRORS OF "LEVEL 1".
         DECLARE LABEL ARRAY EX00[3]←(CEX0,CEX1,CEX1);

FUNCTION CERR(N00);
       ERRPAR(N00:F00,I00);
       GOTO CERR3 IF NOERRP#0 AND I00#0;
       COUT('&/', -1);
       GOTO CERR1 IF F00#0;
       GOTO CERR1 IF N00=ERNB[J00] FOR J00←0 TO ERBC-1;
       F00←1;
       ERBP←ERBC←ERBC+1 IF ERBC<NERB
   ELSE ERBP←1 IF ERBP=NERB ELSE ERBP←ERBP+1;
       ERNB[ERBP-1]←N00;
CERR1: ERRMSG(N00,F00);
       CSOUT(LS00);
CERR3: GOTO LABEL'FIXER(EX00[I00]);
CEX0:  FMTO(HS00);
       OUT(L0);
       OUT(L1);
       GOTO CEX1;
CEX2:  CERRFN();
       RETURN;
CEX1:  CERRFN();
       GOTO CERRX;

***
*** ERBCLR()
***
* CLEAR ERROR BUFFER



       PROGRAM ERRSET;
       INCLUDE STAB', SCMWF;
       DECLARE OCTAL L'REGISTER;


FUNCTION ERBCLR();
       NOERRP←ERBP←ERBC←0;
       RETURN;


***
*** ERRSET(L)
***
* SET UP TO TRANSFER TO L ON ERRORS

FUNCTION ERRNIL();
       RETURN;

FUNCTION ERRSET(LABEL L00);
       CERRX←L00;
       CERRX$FDSTK ← 1;
       CERRX$FDUSTK ← 1;
       .CLA; .STA L'REGISTER;
       CERRX$FDNEWL ← L'REGISTER;
       CERRFN←ERRNIL;
       RETURN;

* SET UP LABEL TO GO TO ON QUIT.
FUNCTION QUIT'SET(LABEL L00);
       QUITGO ← L00;
       QUITGO$FDSTK ← 1;
       QUITGO$FDUSTK ← 1;
       .CLA; .STA L'REGISTER;
       QUITGO$FDNEWL ← L'REGISTER;
       RETURN;

***
*** SSELECT(T)
***
* SELECT AS CURRENT THE IB WHOSE TN IN THE GNT IS T
* IF T=0, SELECT THE GNT ITSELF
* RETURN NO VALUE
***
*** SSCB(T)
***
* SAME AS SSELECT, USING THE WINDOW NORMALLY RESERVED
* FOR THE FNT (FOR SSFGS AND INCLUDE PROCESSING)
***
*** SSELS(A)*
***
* SET UP THE SYMBOL AND TOKEN TABLES
* FOR THE IB AT ABSOLUTE ADDRESS A
***
*** SSELA(A)*
***
* PUT THE IB AT ABSOLUTE ADDRESS A INTO THE WINDOW



       PROGRAM SSELECT;
       INCLUDE STAB';

       DECLARE POINTER A01,W01;
       DECLARE INTEGER I01;

FUNCTION SSELECT(TN01);
       W01←(ATWBA IF TN01=1 ELSE TWBA);
       GOTO SSEL0;
ENTRY SSCB(TN01);
       W01←ATWBA;
SSEL0: W01←GTWBA IF TN01=0;
       RETURN IF TN01=ICGTN AND W01=ICWBA;
       ICWBA←W01;
       IF (ICGTN←TN01) DO;
               SSELS(AGW);
               SSPTR(TN01:,ICGSP);
               SSELA(ICGSP.GSIBA);
               ICTYPE←ICGSP.GSTYPE;
               ICLCODE←ICGSP.GSLCODE;
       ELSE DO;
               SSELA(AGLOB);
               ICTYPE←IBTGN;
               ICLCODE←0;
       ENDIF;
       A01←ICBA;
       ICRECOMP←A01.IBRECOMP;
       ICTFL←A01.IBTFL;
       ICLSU←A01.IBLSU;
       ICNXW←A01.IBNXW;
       ICFSTAT←A01.IBFSTAT;
       ICLSTAT←A01.IBLSTAT;
       SSELS(A01);
       IF ICTYPE#IBTGN DO;
               ICLBL←A01.IBLHEAD-IBOBT;
               ICECODE←A01.IBECODE;
               ICLLIT←A01.IBLLIT;
               ICNEWL←ICGSP.GSNEWL;
               ICBT←ARRDESC(A01+IBOBT,ICLBL,1,1);
               ICCODE←ARRDESC(ICGSP.GSADDR,ICLCODE,1,0);
       ELSE DO;
               ICNEWL←ICLBL←ICECODE←ICLLIT←0;
               ICBT←ICCODE←ARRDESC(0,0,1,1);
       ENDIF;
       ICFTYPE←A01.IBFTYPE;
       ICHT←ARRDESC(A01+IBOHT,IBLHT,1,0);
       RETURN;



       PROGRAM SSELS;
       INCLUDE STAB';


FUNCTION SSELS(POINTER P01);
       ICLTT←P01.IBLTT;
       ICLST←P01.IBSIZE-P01.IBLHEAD-ICLTT;
       ICTT←ARRDESC(P01+P01.IBLHEAD,ICLTT,1,1);
       ICST←ARRDESC(P01+P01.IBLHEAD+ICLTT,ICLST,1,1);
       RETURN;



       PROGRAM SSELA;
       INCLUDE STAB';

       DECLARE INTEGER B01,J01;

FUNCTION SSELA(AA01);
       ICAA←AA01;
       SMAP(B01←ICAA$VPA,RING,ICWBA);
       ICBA←ICWBA+ICAA$VWA;
       ICNPW←(ICAA+ICBA.IBSIZE-1)$VPA-B01+1;
       SMAP(B01+J01,RING,ICWBA+J01@VPA) FOR J01←1 TO ICNPW-1;
       RETURN;

***
*** SSFIND(A,M)
***
* LOOK UP SYMBOL IN CURRENT SYMBOL TABLE
* NAME IS FIRST M WORDS OF ARRAY A
* SET UP ICTOKEN IF FOUND & RETURN IT
* OTHERWISE SET TO 0 AND RETURN 0
***
*** SSINS(N)
***
* INSERT THE SYMBOL JUST LOOKED FOR UNSUCCESSFULLY
* ALLOCATE N EXTRA VALUE WORDS
* SET UP ICTOKEN & RETURN IT
* FATAL ERROR IF ICTOKEN#0 OR N#ICNXW



       PROGRAM SSFIND;
       INCLUDE STAB';

       DECLARE INTEGER TN02,W02,I02;
       DECLARE POINTER SP02,TP02,P02;
       DECLARE INTEGER SI02,L02;

FUNCTION SSFIND(ARRAY A02,INTEGER M02);
       SSFSYM←A02;  SSFSIZE←M02;
       SSFSIZE←SSFSIZE-1;
       W02←SSFSYM[0];
       SHCODE←W02 LCY 7 XOR W02+SSFSIZE;
       SHCODE←(SHCODE+SHCODE LCY 5+SHCODE RCY 5) RSH 1 MOD IBLHT;
       GOTO SSF0 IF (SHCHAIN←TN02←ICHT[SHCODE])=0;
SSF1:  SSPTR(TN02:TP02,SP02);
       IF SP02.SYLN=SSFSIZE AND SP02[SSNAME←SP02.SYSIZE-
        SSFSIZE-1]=W02 DO;
               P02←SP02+SSNAME;
               GOTO SSF2 IF P02[I02]#SSFSYM[I02] FOR I02←1 TO SSFSIZE;
               RETURN ICTOKEN←TN02;
       ENDIF;
SSF2:  GOTO SSF1 IF (TN02←SP02.SYHPTR)#0;
SSF0:  RETURN ICTOKEN←0;

ENTRY SSINS(N02);
* ICTOKEN#0 ?
       CERR(31) IF ICTOKEN;
* N#ICNXW ?
       CERR(38) IF N02#ICNXW;
       SI02←SGSYM(L02←N02+SSFSIZE+SYLE);
* GET A NEW TOKEN
       IF ICTFL=0 DO;
          SXPT(1);
          CERR(200) IF ICTFL=0;
          ENDIF;
       ICTOKEN←TN02←ICTFL;
       ICBA.IBTFL←ICTFL←ICTT[TN02];
       ICTT[TN02]←1@TKSYM+TTUND@TKTYPE+SI02@TKSI;
       SP02←STPTR(SI02);
       BSET(SP02,0,SSNAME←N02+(SYLE-1));
       BCOPY(SP02+SSNAME,@SSFSYM[0],SSFSIZE+1);
       SP02.SYSIZE←L02;
       SP02.SYLN←SSFSIZE;
       SP02.SYHPTR←SHCHAIN;
       ICHT[SHCODE]←TN02;
       SP02.SYTN←TN02;
       INSYMF←INSYMF+1;
       RETURN TN02;

***
*** SGSYM(N)
***
* ACQUIRE N WORDS OF SYMBOL TABLE SPACE
* RETURN THE SYMBOL INDEX OF THE FIRST ONE



       PROGRAM SGSYM;
       INCLUDE STAB';


FUNCTION SGSYM(N04);
       SXPS(N04) IF ICLST-ICLSU<N04;
       ICBA.IBLSU←ICLSU←ICLSU+N04;
       RETURN ICLSU-N04+1;


***
*** SGST(A)*
***
* ACQUIRE SPACE FOR AND COPY THE PPT AT A, RETURNING THE SI



       PROGRAM SGSPT;
       INCLUDE STAB';

       DECLARE INTEGER SI05,N05;
       DECLARE REFERENCE R05;

FUNCTION SGST(ARRAY A05);
       R05←@A05[0];
       N05←R05.PTSIZE;
       R05.BTYPE←BTTEXT;
       BCOPY(STPTR(SI05←SGSYM(N05)),R05,N05);
       RETURN SI05;


***
*** SRSYM(N,S)
***
* FREE N WORDS OF THE CURRENT IB'S SYMBOL TABLE AT SI S
* RETURN NO VALUE



       PROGRAM SRSYM;
       INCLUDE STAB';


FUNCTION SRSYM(N12,SI12);
       IF SI12+N12-1=ICLSU DO;
               ICBA.IBLSU←ICLSU←ICLSU-N12;
       ELSE DO;
               BSET(@ICST[SI12],0,N12);
       ENDIF;
       RETURN;

***
*** SSPTR(T)
***
* RETURN A TOKEN TABLE POINTER AND A SYMBOL TABLE POINTER FOR
* THE SYMBOL WITH TN T IN THE CURRENT IB



       PROGRAM SSPTR;
       INCLUDE STAB';

       DECLARE POINTER SP15,TP15;

FUNCTION SSPTR(TN15);
*****
* 5/6/73  JACK FREEMAN
* THE FOLLOWING BOUNDS CHECK ON TN15 CAN BE REMOVED WHEN ABE TRAP
* HANDLING IS INSTALLED.
       GOTO SSPT0 IF TN15<1 OR TN15>ICLTT;
*****
       PUT'REF(TP15,ICTT,TN15,SSPT0);
       SP15←STPTR(TP15.TKSI);
       RETURN (TP15,SP15);
* (COME HERE ON ABE)
* ILLEGAL TN
SSPT0: CERR(174);


***
*** SSPTS(T)
***
* RETURN TOKEN AND SYMBOL POINTERS
* FOR TN T.  FAIL IF TN T UNUSED.

ENTRY SSPTS(TN15), FRETURN;
*****
* 5/6/73  JACK FREEMAN
* THE FOLLOWING BOUNDS CHECK ON TN15 CAN BE REMOVED WHEN ABE TRAP
* HANDLING IS INSTALLED.
       GOTO SSPT0 IF TN15<1 OR TN15>ICLTT;
*****
       PUT'REF(TP15,ICTT,TN15,SSPT0);
       FRETURN IF TP15.TKFLAGS=0;
       RETURN (TP15,STPTR(TP15.TKSI));


       PROGRAM STPTR;
       INCLUDE STAB';

       DECLARE POINTER SP15X;

***
*** STPTR(S)
***
* RETURN POINTER TO WORD S OF CURRENT SYMBOL TABLE

FUNCTION STPTR(SI15);
*****
* 5/6/73  JACK FREEMAN
* THE FOLLOWING BOUNDS CHECK ON SI15 CAN BE REMOVED WHEN ABE TRAP
* HANDLING IS INSTALLED.
       GOTO STPT0 IF SI15<1 OR SI15>ICLST;
*****
       PUT'REF(SP15X,ICST,SI15,STPT0);
       RETURN SP15X;
* (COME HERE ON ABE)
* ILLEGAL SI
STPT0: CERR(176);

***
*** SNEXT(S)
***
* GET THE SI FOR THE PPT FOLLOWING THE ONE WITH SI S
***
*** SPREV(S)
***
* LIKE SNEXT, BUT PREVIOUS INSTEAD OF NEXT



       PROGRAM SNEXT;
       INCLUDE STAB';

       DECLARE POINTER SSP15;

FUNCTION SNEXT(SS15);
       SSP15←STPTR(SS15);
       RETURN SSP15.PTFP;

ENTRY SPREV(SS15);
       SSP15←STPTR(SS15);
       RETURN SSP15.PTBP;

***
*** SSFGS(S,B,F)
***
* LOOK UP THE SYMBOL OR CONSTANT WITH TN S IN THE CURRENT IB
* IN THE IB WITH GNT TN B
* AND RETURN THE TN IN THAT IB, LEAVING IT SSELECTED
* INSERT IT IF F=1 AND IT IS MISSING
* RETURN 0 IF F=0 AND IT IS MISSING



       PROGRAM SSFGS;
       INCLUDE STAB';

       DECLARE PARAMETER MAXCW←12;
       DECLARE ARRAY S16[MAXCW];
       DECLARE INTEGER N16,T16;
       DECLARE POINTER TP16,SP16;

FUNCTION SSFGS(STN16,BTN16,F16);
       SSPTR(STN16:TP16,SP16);
       N16←SP16.SYLN+1;
       HALT() IF N16>MAXCW;*** ***
       BCOPY(@S16[0],SP16+SP16.SYSIZE-N16,N16);
       SSCB(BTN16);
       IF SSFIND(S16,N16)=0 AND F16#0 DO;
            SSINS(ICNXW);
       ENDIF;
       RETURN ICTOKEN;

***
*** SWSYM(T,S)
***
* WRITE THE SYMBOL DESIGNATED BY T ONTO THE STRING S
* FRETURN IF STRING TOO SHORT WITH SYMBOL PARTIALLY WRITTEN
* RETURN STRING NORMALLY
* IF T>0, T IS A TN IN THE CURRENT IB
* IF T<0, T IS A TN IN THE GNT



       PROGRAM SWSYM;
       INCLUDE STAB';

       DECLARE INTEGER C28,I28;
       DECLARE POINTER SP28,Q28;
       DECLARE STRING SS28;

STRING FUNCTION SWSYM(TN28,STRING S28), FRETURN;
       IF TN28>0 DO;
            SSPTR(TN28:,SP28);
       ELSE DO;
            SSELS(AGW);
            SSPTR(-TN28:,SP28);
            SSELS(ICBA);
       ENDIF;
       Q28←SP28+SP28.SYSIZE-1;
       I28←SP28.SYLN;
       SETUP(SS28,4*(I28+1),Q28-I28,6);
       SS28$WP←SS28$EP;
       WCI(C28,S28//FRETURN) WHILE C28←GCI(SS28//SWS1);
SWS1:  RETURN S28;

***
*** SWEA(I,F,S)
***
* WRITE THE EDITOR ADDRESS FOR THE STATEMENT WITH LOCAL SI S
* ON THE STRING S; ONLY WRITE THE BLOCK NAME IF F=0
* FAIL IF THE STRING IS TOO SHORT, RETURN THE STRING NORMALLY



       PROGRAM SWEA;
       INCLUDE STAB';

       DECLARE INTEGER TN33,LN33;

STRING FUNCTION SWEA(SI33,F33,STRING S33), FRETURN;
       IF F33=0 DO;
            WCI('<',S33//FRETURN);
            S33←SWSYM(-ICGTN,S33//FRETURN);
            WCI('>',S33//FRETURN);
       ENDIF;
       ZEDSA(SI33:TN33,LN33//FRETURN);
       IF TN33 DO;
            S33←SWSYM(TN33,S33//FRETURN);
            WCI('+',S33//FRETURN) IF LN33;
       ELSE DO;
            WCI('#',S33//FRETURN);
       ENDIF;
       S33←FCNS(LN33,S33,0,10//FRETURN) IF LN33;
       RETURN S33;

***
*** SGNEXT(N)
***
* RETURN THE GLOBAL TN OF THE BLOCK FOLLOWING N,
* FAIL IF NONE



       PROGRAM SGNEXT;
       INCLUDE STAB';

       DECLARE POINTER DP34;

FUNCTION SGNEXT(TN34), FRETURN;
       DP34←ICGSP IF TN34=ICGTN ELSE (SSELECT(0) &
        SSPTS(TN34:,DP34//SGNX1));
       RETURN TN34 IF TN34←DP34.GSORD ELSE FRETURN;
* ILLEGAL TN IN SGNEXT
SGNX1: CERR(164);


***
*** SGPREV(N)
***
* RETURN THE GLOBAL TN OF THE BLOCK PRECEDING N,
* FAIL IF NONE



       PROGRAM SGPREV;
       INCLUDE STAB';

       DECLARE INTEGER TL35,TS35;

FUNCTION SGPREV(TN35), FRETURN;
       SSELECT(0);
       FRETURN IF TN35=(TL35←ICFSTAT);
       TL35←TS35 WHILE (TS35←SGNEXT(TL35//SGPR1))#TN35;
       RETURN TL35;
* TN NOT ON GSORD CHAIN
SGPR1: CERR(165);

***
*** UPTR(A,F)
***
* COMPUTE WINDOW POINTER TO ADDRESS A IN USER AREA, FILE F



       PROGRAM UPTR;
       INCLUDE STAB';

       DECLARE INTEGER VP30,I30,T30,J30;

FUNCTION UPTR(POINTER A30,INTEGER F30);
       RETURN ULBA+A30$VWA IF (VP30←A30$VPA)=ULVP AND F30=ULFN;
       ULVP←VP30;
       ULFN←F30;
       UPCTR←UPCTR+1;
       FOR I30←NUPW-1 BY -1 TO 0 DO;
UPTR1:      RETURN (A30$VWA+(ULBA←UWBA+I30@VPA WHERE
          UPTTAB[I30]←UPCTR)) IF UPPTAB[I30]=VP30
          AND UPFTAB[I30]=F30;
       ENDFOR;
       T30←4B7-1;
       FOR J30←NUPW-1 BY -1 TO 0 DO;
            (T30←UPTTAB[J30] & I30←J30) IF UPTTAB[J30]<T30;
       ENDFOR;
       SCPG(VP30,-1);
       SMAP(VP30,-1,UWBA+I30@VPA);
       UPPTAB[I30]←VP30;
       UPFTAB[I30]←F30;
       GOTO UPTR1;

***
*** GET(A)
***
* GET CONTENTS OF USER CELL A
***
*** PUT(A,W)
***
* PUT W INTO USER CELL A



       PROGRAM GET;
       INCLUDE STAB';

       DECLARE POINTER P30;

FUNCTION GET(POINTER U30);
       P30←UPTR(U30,-1);
       RETURN CONTENTS(P30);

ENTRY PUT(U30,W30);
       P30←UPTR(U30,-1);
       RETURN CONTENTS(P30)←W30;

***
*** COMMAND(S,A,F)
***
* LOOK UP THE COMMAND ON THE FRONT OF THE STRING S
* IN THE STRING ARRAY A
* FRETURN IF THE STRING DOES NOT MATCH
* RETURN PARTIALLY READ STRING, PREFIX, AND INDEX
* F=1 FOR EXPERT MODE, F=0 FOR BEGINNER MODE



       PROGRAM COMMAND;
       INCLUDE STAB';

       DECLARE INTEGER COWRD,COCHR,COIDX,COBUF,CONCH,COJDX,COLEN;
       DECLARE STRING COSTR,CORS;
       DECLARE ARRAY COIT, STRING ARRAY COTAB=COIT;
*      KLUDGE FOR ARRAY SIZE

STRING FUNCTION COMMAND(STRING COS,STRING ARRAY COTAB,INTEGER COEXP), FRETURN;
       COLEN←ARRAYSIZE(COIT)-1;
       COWRD←COIDX←CONCH←0;
COM1:  COCHR←GCI(COS//FRETURN);
       CONCH←CONCH+8;
       COWRD←COWRD+COCHR RCY CONCH;
       COJDX←-1;
       FOR COIDX←COIDX TO COLEN DO;
            SDCOPY(COSTR,COTAB[COIDX]);
            GOTO COM2 IF LENGTH(COSTR)=0;
            GOTO COM2 IF GCI(COSTR//COM2)#COBUF RSH 16
          FOR COBUF←COWRD,COBUF LSH 8 WHILE COBUF;
* CHECK FOR FIRST OR SECOND MATCH
            (GOTO COM1 WHERE COIDX←COJDX) IF COJDX>=0;
            COJDX←COIDX;
            SDCOPY(CORS,COSTR);
COM2:  ENDFOR;
       FRETURN IF COJDX<0 ELSE GOTO COM3 IF COEXP;
* VERIFY REMAINDER OF COMMAND FOR BEGINNER MODE
COM4:  COBUF←GCI(CORS//COM3);
       COCHR←GCI(COS//COMX);
       GOTO COM4 IF COBUF=COCHR ELSE GOTO COM3 IF COCHR=' '
   ELSE FRETURN IF COCHR>='A' AND COCHR<='Z' OR
   COCHR>='0' AND COCHR<='9' ELSE GOTO COM5;
* SKIP FOLLOWING BLANKS
COM3:  GOTO COM3 IF (COCHR←GCI(COS//COMX))=' ';
COM5:  WCD(COCHR,COS);
COMX:  RETURN (COS,COWRD LCY CONCH,COJDX);

***
*** FIOUT(N,F,W,R)
***
* OUTPUT N TO FILE F, WIDTH W, RADIX R - LIKE CNS



       PROGRAM FIOUT;
       INCLUDE STAB';

       DECLARE STRING FIOS(10);

FUNCTION FIOUT(FION,FIOF,FIOW,FIOR);
       SETS(FIOS,0,0);
       FIOS←FCNS(FION,FIOS,FIOW,FIOR//FTLERR);
       CSOUT(FIOS) IF FIOF=-1 ELSE FSOUT(FIOS,FIOF);
       RETURN;

***
*** FFMTO(S,F)
***
* PREPARE FOR OUTPUT ACCORDING TO THE FORMAT S ON FILE F
* *=DECIMAL INTEGER, /=NEW LINE, '=NEXT CHAR LITERALLY,
* #=OCTAL INTEGER, @=SYMBOL (USING SWSYM), OTHER=LITERAL
***
*** FMTO(S)
***
* FFMTO TO TELETYPE
***
*** OUT(X)
***
* TRANSMIT NEXT QUANTITY



       PROGRAM FFMTO;
       INCLUDE STAB';

       DECLARE INTEGER FMTX,FMTC;
       DECLARE STRING FMTWS(SYMAXCN);
       DECLARE LABEL ARRAY FMTSW[3]←(FMTIN,FMTSY,FMTIN);

FUNCTION FFMTO(STRING FMTSS,INTEGER FMTF);
FMT0:  SDCOPY(FOSTR,FMTSS);
       FOFILE←FMTF;
FMT1:  FMTC←GCI(FOSTR//RETURN);
       IF FMTC='/' DO;
            COUT('&/',FOFILE);
       ELSEIF FMTC='&'' DO;
            COUT(GCI(FOSTR),FOFILE);
       ELSEIF FMTC='*' OR FMTC='#' DO;
            FOSWI←(0 IF FMTC='#' ELSE 2);
            RETURN;
FMTIN:      FIOUT(FMTX,FOFILE,4B7 IF FMTX<-4B4 ELSE 0,8+FOSWI);
       ELSEIF FMTC='@' DO;
            FOSWI←1;
            RETURN;
FMTSY:      SETS(FMTWS,0,0);
            FSOUT(SWSYM(FMTX,FMTWS//FTLERR),FOFILE);
       ELSEIF FMTC<100B DO;
            COUT(FMTC,FOFILE);
       ENDIF;
       GOTO FMT1;

ENTRY FMTO(STRING FMTSS);
       FMTF←-1;
       GOTO FMT0;

ENTRY OUT(FMTX);
       GOTO LABEL'FIXER(FMTSW[FOSWI]);

***
*** ZNEWIB(N,T,M)
***
* CREATE A NEW INFORMATION BLOCK OF TYPE T WITH GNT TN N
* INSERT IT BEFORE THE ONE WITH TN M,
* OR AS LAST IF M=0, OR NOT ON CHAIN IF M=-1
* MAKE IT CURRENT AND RETURN NO VALUE



       PROGRAM ZNEWIB;
       INCLUDE STAB',SCMWF;

       DECLARE POINTER A06,P06,BA06;
       DECLARE INTEGER AA06,C06;

FUNCTION ZNEWIB(TN06,T06,TC06);
       AA06←STGET(IBLE+21);
       BA06←(TWBA IF TN06 ELSE GTWBA);
       SMAP(AA06$VPA,RING,BA06);
       SMAP(AA06$VPA+1,RING,BA06+1@VPA)
   IF (AA06+IBLE+20)$VPA#AA06$VPA;
       A06←BA06+AA06$VWA;
       BSET(A06,0,IBLE+21);
       A06.IBSIZE←IBLE+21;
       A06.IBLHEAD←IBLE;
       A06.IBLTT←1;
       A06.IBTFL←1;
       A06.IBGTN←TN06;
       ICGTN←-1;
       IF TN06=0 DO;
* GNT ALREADY EXISTS ?
               CERR(78) IF AA06#TABBOT;
               A06.IBNXW←GSLE;
       ELSE DO;
               A06.IBNXW←FSLE IF TN06=1;
               SSELECT(0);
               SSPTR(TN06:,P06);
* GSIBA#0 ?
               CERR(32) IF P06.GSIBA;
* CODE AREA FULL ?
               CERR(52) IF CODETOP>=CODELIM;
               P06.GSIBA←AA06;
               P06.GSADDR←CODETOP;
               P06.GSLCODE←1;
               CODETOP←CODETOP+1;
               P06.GSTYPE←T06;
               P06.GSNEWL←1@FWCLL+1@FWSTK;
               IF TC06=-1 DO;
               ELSEIF ICFSTAT=0 DO;
                  ICBA.IBFSTAT←TN06;
                  ICBA.IBLSTAT←TN06;
               ELSE DO;
                  IF TC06=0 DO;
                     C06←ICLSTAT;
                     ICBA.IBLSTAT←TN06;
                  ELSE DO;
                     C06←SGPREV(TC06//FTLERR);
                  ENDIF;
                  SSPTR(C06:,P06);
                  P06.GSORD←TN06;
                  SSPTR(TN06:,P06);
                  P06.GSORD←TC06;
               ENDIF;
       ENDIF;
       SSELECT(TN06);
       RETURN;

***
*** SXPT(M)*
***
* EXPAND THE TOKEN TABLE OF THE CURRENT IB BY AT LEAST M



       PROGRAM SXPT;
       INCLUDE STAB';

       DECLARE INTEGER I03,K03,L03;
       DECLARE POINTER P03;

FUNCTION SXPT(M03);
       K03←SEXP(M03,ICLTT+20);
       K03←L03 IF K03>20 AND (L03←ICLST RSH 2)<K03 AND ICLST>K03;
       K03←TNLIM-ICLTT IF K03+ICLTT>TNLIM;
       P03←@ICST[1];
       BCOPY(P03+K03,P03,ICLSU);
       ICBA.IBLTT←ICLTT←(L03←ICLTT)+K03;
       SSELS(ICBA);
       ICTT[I03]←I03+1 FOR I03←L03+1 TO ICLTT;
       ICTT[ICLTT]←ICTFL;
       ICBA.IBTFL←ICTFL←L03+1;
       RETURN;


***
*** SXPS(M)*
***
* EXPAND THE SYMBOL TABLE OF THE CURRENT IB BY AT LEAST M



       PROGRAM SXPS;
       INCLUDE STAB';

       DECLARE INTEGER K04;

FUNCTION SXPS(M04);
       K04←SEXP(M04,ICLST+20);
       SRSYM(K04,ICLST-K04+1);
       RETURN;

***
*** SEXP(N,K)*
***
* EXPAND THE CURRENT IB BY AT LEAST N WORDS
* USE MAX(N,K*XPANFAC/100) AS COUNT
* RETURN THE ACTUAL AMOUNT OF EXPANSION



       PROGRAM SEXP;
       INCLUDE STAB';

       DECLARE INTEGER I11,E11,TN11;
       DECLARE POINTER P11,SP11,Q11,B11,R11;

FUNCTION SEXP(N11,K11);
       N11←I11 IF (I11←K11*XPANFAC/100)>N11;
       IF (P11←Q11←ICAA+ICBA.IBSIZE)=TABTOP DO;
          STGET(N11);
       ELSE DO;
          TN11←ICGTN;
          ICWBA←TWBA;
          WHILE Q11<TABTOP AND Q11-P11<N11 DO;
             SSELA(Q11);
             Q11←Q11+ICBA.IBSIZE;
          ENDFOR;
          B11←(STGET(N11←Q11-P11) IF Q11-P11>=N11
          ELSE (P11+N11 WHERE STGET(N11)));
          R11←P11;
          WHILE R11<Q11 DO;
             SSELA(R11);
             SSELS(AGW);
             SSPTR(ICBA.IBGTN:,SP11);
             SP11.GSIBA←SP11.GSIBA+B11-P11;
             R11←R11+ICBA.IBSIZE;
          ENDFOR;
          WMOVE(B11,P11,Q11-P11);
          ICGTN←-1;
          SSELECT(TN11);
       ENDIF;
       ICBA.IBSIZE←ICBA.IBSIZE+N11;
       IF (E11←(ICAA+ICBA.IBSIZE-1)$VPA-ICAA$VPA+1)>ICNPW DO;
          SMAP(I11+ICAA$VPA,RING,ICWBA+I11@VPA)
           FOR I11←ICNPW TO E11-1;
          ICNPW←E11;
       ENDIF;
       SSELS(ICBA);
       RETURN N11;


***
*** STGET(N)
***
* ACQUIRE N WORDS AT TABTOP, UPDATE IT, AND RETURN THE OLD TABTOP
* ERROR IF TABLE SPACE EXCEEDED



       PROGRAM STGET;
       INCLUDE STAB';

       DECLARE INTEGER A17;

FUNCTION STGET(N17);
       IF TABTOP+N17<=TABLIM DO;
            A17←TABTOP;
            WHILE TABTOP$VPA<(TABTOP+N17)$VPA DO;
                 TABTOP←TABTOP+1@VPA;
                 SCPG(TABTOP$VPA,RING);
                 N17←N17-1@VPA;
            ENDFOR;
            TABTOP←TABTOP+N17;
            RETURN A17;
       ELSE DO;
* TABLE SPACE EXHAUSTED
            CERR(35);
       ENDIF;

***
*** SBCLEAR()
***
* CLEAR THE BLOCK LIST OF THE CURRENT FUNCTION
* RETURN NO VALUE
***
*** SBFI(T)
***
* LOOK UP, AND INSERT IF NECESSARY, GNT TN T IN THE
* BLOCK LIST OF THE CURRENT FUNCTION
* RETURN THE INDEX OF THE ENTRY IN THE BLOCK LIST



       PROGRAM SBCLEAR;
       INCLUDE STAB';

       DECLARE INTEGER I08,J08;
       DECLARE POINTER P08;

FUNCTION SBCLEAR();
       BSET(@ICBT[1],0,ICLBL);
       RETURN;

ENTRY SBFI(TN08);
SBF1:  J08←0;
       FOR I08←1 TO ICLBL DO;
               RETURN I08 IF ICBT[I08]=TN08
          ELSE J08←I08 IF J08=0 AND ICBT[I08]=0;
       ENDFOR;
       (ICBT[J08]←TN08 & RETURN J08) IF J08;
       SGSYM(1);
       SGSYM(-1);
       P08←@ICTT[1];
       BCOPY(P08+1,P08,ICLTT+ICLSU);
       $P08←0;
       ICBA.IBLHEAD←ICBA.IBLHEAD+1;
       I08←ICGTN;
       ICGTN←-1;
       SSELECT(I08);
       GOTO SBF1;

***
*** STDEL(S1,S2)
***
* DELETE ALL STATEMENTS FROM THE ONE WITH SI S1
* THROUGH THE ONE WITH SI S2
* FRETURN IF S2 PRECEDED S1, RETURN IF ALL WAS WELL
* ** ONLY TO BE USED FOR DIRECT STATEMENTS **



       PROGRAM STDEL;
       INCLUDE STAB';

       DECLARE INTEGER I310,R310;

FUNCTION STDEL(I110,I210), FRETURN;
       I310←SNEXT(I210);
       R310←ICRECOMP;
       ICRECOMP←1;* TO FOOL STDI
       STUI(I110,I210//FRETURN);
       STDC(I110,I210,I310);
       STDI(I110,I210);
       ICRECOMP←R310;
       RETURN;

***
*** STUI(S1,S2)*
***
* UNHOOK THE STATEMENTS WITH SI'S S1 THROUGH S2
* FROM THE CURRENT IB
* FRETURN IF S2 PRECEDED S1
* RETURN NUMBER OF LINES UNHOOKED IF ALL WAS WELL
* UPDATE NUMBER OF LINES IN GNT
***
*** STDI(S1,S2)*
***
* DELETE THE STATEMENTS WITH SI'S S1 THROUGH S2,
* WHICH ARE ASSUMED TO BE UNHOOKED
* UPDATE BREAKPOINT AND RECOMPILATION INFORMATION



       PROGRAM STUI;
       INCLUDE STAB';

       DECLARE INTEGER SJ10,S110,S210,NL10;
       DECLARE POINTER SP110,SP210,P10;

FUNCTION STUI(SI110,SI210), FRETURN;
       SJ10←SI110;
       WHILE SJ10#0 AND SJ10#SI210 DO;
            SJ10←SNEXT(SJ10);
       ENDFOR;
       FRETURN IF SJ10=0;
       SP110←STPTR(SI110);
       S110←SP110.PTBP;
       SP110.PTBP←0;
       SP210←STPTR(SI210);
       S210←SP210.PTFP;
       SP210.PTFP←0;
       IF S110 DO;
               SP110←STPTR(S110);
               SP110.PTFP←S210;
       ELSE DO;
               ICBA.IBFSTAT←ICFSTAT←S210;
       ENDIF;
       IF S210 DO;
               SP210←STPTR(S210);
               SP210.PTBP←S110;
       ELSE DO;
               ICBA.IBLSTAT←ICLSTAT←S110;
       ENDIF;
       NL10←0;
       NL10←NL10+1 FOR SJ10←SI110, SNEXT(SJ10) WHILE SJ10;
       ICGSP.GSNL←ICGSP.GSNL-NL10;
       RETURN NL10;



       PROGRAM STDI;
       INCLUDE STAB';

       DECLARE INTEGER SK10;
       DECLARE POINTER SQ10;

FUNCTION STDI(SJ110,SJ210);
STD1:  SQ10←STPTR(SJ110);
       SJ110←SNEXT(SK10←SJ110);
       IF SQ10.PTBKF DO;
           IF ICGSP.GSBMF = 1 DO;
               CERR(33) IF ICGSP.GSBKSI # SK10;* "GSBKSI WRONG"
               ICGSP.GSBMF ← 0;
               ICGSP.GSBKCT ← 0;
           ELSE DO;
               ICGSP.GSBKCT ← ICGSP.GSBKCT - 1 IF ICGSP.GSBKCT > 0;
           ENDIF;
       ENDIF;
       DBKSI←0 IF ICGTN=DBKTN AND SK10=DBKSI;
       BRKSI←0 IF ICGTN=BRKTN AND SK10=BRKSI;
       SRSYM(SQ10.PTSIZE, SK10);
       GOTO STD1 IF SK10#SJ210;
       IF ICRECOMP=0 DO;
            ICGSP.GSRECOMP←ICBA.IBRECOMP←ICRECOMP←RECOMPILE←1;
       ENDIF;
       RETURN;

***
*** STINS(S,P)
***
* INSERT THE STATEMENT AT ADDRESS P BEFORE THE ONE WITH SI S
* IF S=0, APPEND AT THE END
* RETURN THE SI OF THE STATEMENT
***
*** STII(S1,S2,S)*
***
* INSERT THE INTERVAL GIVEN BY SI'S S1,S2
* BEFORE THE ONE WITH SI S AS FOR STINS



       PROGRAM STINS;
       INCLUDE STAB';

       DECLARE INTEGER SY09;

FUNCTION STINS(SI09,ARRAY A09);
* SPECIAL ENTRY FOR PREPROCESSOR
ENTRY PSTINS(SI09,A09);
       SY09←SGST(A09);
       STII(SY09,SY09,SI09);
       RETURN SY09;



       PROGRAM STII;
       INCLUDE STAB';

       DECLARE INTEGER J09;
       DECLARE POINTER SP09,SQ09,SR09;

FUNCTION STII(SJ09,SK09,I09);
       SQ09←STPTR(SJ09);
       SR09←STPTR(SK09);
       IF ICLSTAT=0 DO;
               ICBA.IBLSTAT←ICLSTAT←SK09;
               ICBA.IBFSTAT←ICFSTAT←SJ09;
       ELSEIF I09=0 DO;
               SP09←STPTR(ICLSTAT);
               SQ09.PTBP←ICLSTAT;
               SP09.PTFP←SJ09;
               ICBA.IBLSTAT←ICLSTAT←SK09;
       ELSE DO;
               SP09←STPTR(I09);
               SR09.PTFP←I09;
               SQ09.PTBP←J09←SP09.PTBP;
               SP09.PTBP←SK09;
               (SP09.PTFP←SJ09 WHERE SP09←STPTR(J09))
          IF J09 ELSE ICBA.IBFSTAT←ICFSTAT←SJ09;
       ENDIF;
       IF ICRECOMP=0 DO;
               ICGSP.GSRECOMP←ICRECOMP←RECOMPILE←1;
       ENDIF;
       SK09←SR09.PTFP;
       WHILE SJ09#SK09 DO;
               SQ09←STPTR(SJ09);
               SQ09.PTRECOMP←1 IF ICRECOMP=0;
               ICGSP.GSNL←ICGSP.GSNL+1;
               SJ09←SQ09.PTFP;
       ENDFOR;
       RETURN;

***
*** SUDEL()
***
* DELETE THE UNHOOKED INTERVAL



       PROGRAM SUDEL;
       INCLUDE STAB';

       DECLARE INTEGER FTN19;

FUNCTION SUDEL();
       IF EDUTN DO;
            FTN19←ICGTN;
            SSELECT(EDUTN);
            STDC(EDUSI1,EDUSI2,EDUSI3);
            STDI(EDUSI1,EDUSI2);
            EDUTN←EDUSI1←EDUSI2←EDUSI3←0;
            SSELECT(FTN19);
       ENDIF;
       EDITN←EDISI1←EDISI2←0;
       RETURN;

***
*** SUINS()
***
* RE-INSERT THE UNHOOKED INTERVAL
* IN THE IB WITH GNT TN EDUTN; ERROR IF EDUTN=0



       PROGRAM SUINS;
       INCLUDE STAB';

       DECLARE INTEGER FTN20;

FUNCTION SUINS();
* NO UNHOOKED INTERVAL ?
       CERR(88) IF EDUTN=0;
       FTN20←ICGTN;
       SSELECT(EDUTN);
       STII(EDUSI1,EDUSI2,EDUSI3);
       EDITN←EDISI1←EDISI2←EDUSI3←EDUTN←EDUSI1←EDUSI2←0;
       SSELECT(FTN20);
       RETURN;

***
*** SUNHOOK(S1,S2)
***
* UNHOOK THE STATEMENTS S1 THROUGH S2 IN THE CURRENT IB
* PUT THE IB'S GNT TN IN EDUTN AND S1,S2 IN EDUSI1,EDUSI2
* PUT SUCCESSOR OF S2 IN EDUSI3
* ERROR IF THERE IS ALREADY AN UNHOOKED INTERVAL
* FRETURN IF THE STATEMENTS WERE OUT OF ORDER
* RETURN NUMBER OF LINES NORMALLY



       PROGRAM SUNHOOK;
       INCLUDE STAB';

       DECLARE INTEGER NL21;

FUNCTION SUNHOOK(SI121,SI221), FRETURN;
* EDUTN#0 ?
       CERR(89) IF EDUTN#0;
       EDUSI3←SNEXT(SI221);
       NL21←STUI(SI121,SI221//FRETURN);
       EDUTN←ICGTN;
       EDUSI1←SI121;
       EDUSI2←SI221;
       RETURN NL21;

***
*** SRING(N)
***
* SELECT RING N, AND ITS GNT
* ERROR IF RING DOES NOT EXIST



       PROGRAM SRING;
       INCLUDE STAB';

       DECLARE INTEGER I24,C24;

FUNCTION SRING(N24);
* RING DOES NOT EXIST ?
       CERR(179) IF N24>=0 AND REXISTS[N24]=0;
SRG0:  GOTO SRG1 IF RING=N24;
       BCOPY(VARA,BRVARS,NRVARS) IF RING>=0;
       IF N24>=0 DO;
SRG2:       RING←N24;
            REXISTS[N24]←1;
            C24←SGNP(-1,RING);
            FOR I24←TABBOT$VPA-1 BY -1 TO 0 DO;
                 SCPG(I24,RING) IF C24=-1;
                 SMAP(I24,RING,VARA+I24@VPA);
            ENDFOR;
            SCPG(TABBOT$VPA,RING);
            BCOPY(BRVARS,VARA,NRVARS);
            ICGTN←-1;
SRG1:       IF TABTOP>TABBOT DO;
                 SMAP(AGLOB$VPA,RING,GTWBA);
                 SMAP(AGLOB$VPA+I24,RING,GTWBA+I24@VPA)
               FOR I24←(AGLOB$VWA+AGW.IBSIZE-1)$VPA BY -1 TO 1;
                 SSELECT(0);
            ENDIF;
       ENDIF;
       RETURN;


***
*** SLRING(N)
***
* LOAD THE VARIABLES FOR RING N
* ** USE WITH CARE **

ENTRY SLRING(N24);
       GOTO SRG2;


***
*** SARING(N)
***
* SAME AS SRING, BUT WILL CREATE A NEW RING

ENTRY SARING(N24);
       GOTO SRG0;

***
*** STDC(S1,S2,S3)*
***
* DELETE THE CODE FOR STATEMENTS WITH SI'S S1 THROUGH S2
* THE INTERVAL IS ASSUMED TO BE UNHOOKED,
* WITH S3 BEING THE OLD SUCCESSOR OF S2



       PROGRAM STDC;
       INCLUDE STAB',SGDEC;

       DECLARE INTEGER R25,SI25,B25, GARBAGE;
       DECLARE POINTER C125,C225,SP25,P25;

FUNCTION STDC(S125,S225,S325);
       RETURN IF S325=0 OR ICTYPE#IBTFN;
       SFCA(S325,ICFSTAT,P25←ICLLIT+@ICCODE[0]:C125,B25);
       SFCA(0,S125,C125:C225,GARBAGE);
       IF S325=0 DO;
            IF B25=0 DO;
                 ICBA.IBECODE←ICECODE←C125-P25;
            ENDIF;
            RETURN;
       ELSEIF (SP25.PTCOS#0 WHERE SP25←STPTR(S325)) DO;
            R25←GET(C225)$INSSRD+C225-C125;
       ELSE DO;
            R25←C225-C125;
            RETURN IF R25=0;
            SP25.PTCOS←1;
       ENDIF;
       PUT(C125, ZBRU@INSOP+RQ(R25));
       RETURN;

***
*** SFCA(T,S,C)*
***
* FIND THE ADDRESS OF THE CODE FOR THE STATEMENT WITH SI T
* GIVEN THAT C IS THE CODE ADDRESS FOR THE STATEMENT WITH SI S
* RETURN THE ADDRESS, AND A FLAG INDICATING WHETHER
* THERE WERE ANY PATCHES IN THE CODE
* ** S MUST EQUAL OR PRECEDE T **



       PROGRAM SFCA;
       INCLUDE STAB',SCMWF;

       DECLARE POINTER SP26;
       DECLARE INTEGER B26;

FUNCTION SFCA(SJ26,SI26,POINTER C26);
       B26←0;
       WHILE SI26#SJ26 DO;
            SP26←STPTR(SI26);
            SI26←SP26.PTFP;
            IF SP26.PTCOS DO;
                 B26←1;
                 C26←C26+GET(C26)$INSSRD;
            ENDIF;
            C26←C26+SP26.PTLCODE;
       ENDFOR;
       RETURN (C26,B26);

***
*** SDMAC(T,R)
***
* DEFINE THE SYMBOL T AS A MACRO WITH PPT AT
* CORE ADDRESS R (PUT IN THE IB)



       PROGRAM SDMAC;
       INCLUDE STAB';

       DECLARE INTEGER SI18;
       DECLARE POINTER P18,TP18,SP18;

FUNCTION SDMAC(TN18,ARRAY R18);
       SI18←SGST(R18);
       P18←STPTR(SI18);
       SSPTR(TN18:TP18,SP18);
       TP18.TKTYPE←TTMAC;
       SP18.SYVAL←SI18;
       P18.PTBP←-1;
       P18.PTFP←TN18;
       RETURN;

***
*** SFIN(N)
***
* CLEAN UP THE CURRENT IB
* LEAVING NO MORE THAN N% UNUSED SPACE



       PROGRAM SFIN;
       INCLUDE STAB';

       DECLARE INTEGER L22;

FUNCTION SFIN(N22);
       L22←ICLSU+ICLSU*N22/100-ICLST;
       IF L22<0 AND ICAA+ICBA.IBSIZE=TABTOP DO;
          STGET(L22);
          ICBA.IBSIZE←ICBA.IBSIZE+L22;
          SSELS(ICBA);
       ENDIF;
       RETURN;

***
*** BMOVE(D,S,N,F)*
***
* MOVE N WORDS FROM S TO D, BREAKING UP THE TRANSFER
* INTO PIECES WHICH DO NOT CROSS A PAGE BOUNDARY.
* CALL F(D',S',N') FOR EACH PIECE



       PROGRAM BMOVE;
       INCLUDE STAB';

       DECLARE INTEGER F31,K31,NS31,ND31;

FUNCTION BMOVE(MD31,MS31,N31,FUNCTN FN31);
       IF MD31<MS31 OR MD31>=MS31+N31 DO;
            F31←0;
       ELSE DO;
            F31←-1;
            MD31←MD31+N31;
            MS31←MS31+N31;
       ENDIF;
BM1:   RETURN IF N31=0;
       K31←N31;
       IF F31=0 DO;
            NS31←1@VPA-MS31$VWA;
            ND31←1@VPA-MD31$VWA;
       ELSE DO;
            NS31←1+(MS31-1)$VWA;
            ND31←1+(MD31-1)$VWA;
       ENDIF;
       K31←NS31 IF K31>NS31;
       K31←ND31 IF K31>ND31;
       IF F31=0 DO;
            FN31(MD31,MS31,K31);
            MS31←MS31+K31;
            MD31←MD31+K31;
       ELSE DO;
            FN31(MD31←MD31-K31,MS31←MS31-K31,K31);
       ENDIF;
       N31←N31-K31;
       GOTO BM1;


***
*** UMOVE(D,S,N)
***
* MOVE N WORDS FROM S TO D IN THE USER AREA



       PROGRAM UMBLK;
       INCLUDE STAB';


FUNCTION UMBLK(TD31A,TS31A,M31A);
       BCOPY(UPTR(TD31A,-1),UPTR(TS31A,-1),M31A);
       RETURN;

FUNCTION UMOVE(MD31A,MS31A,N31A);
       BMOVE(MD31A,MS31A,N31A,UMBLK);
       RETURN;


***
*** UCLEAR(D,C,N)
***
* CLEAR N WORDS AT D TO C IN THE USER AREA



       PROGRAM UCBLK;
       INCLUDE STAB';


FUNCTION UCBLK(TD31B,TS31B,M31B);
       BSET(UPTR(TD31B,-1),CCONST,M31B);
       RETURN;

FUNCTION UCLEAR(MD31B,C31B,N31B);
       CCONST←C31B;
       BMOVE(MD31B,MD31B,N31B,UCBLK);
       RETURN;


***
*** WMOVE(D,S,N)
***
* MOVE N WORDS FROM S TO D IN THE CURRENT IB



       PROGRAM WMBLK;
       INCLUDE STAB';

       DECLARE INTEGER I32;

FUNCTION WMBLK(TD32,TS32,M32);
       I32←(1@VPA IF (TD32 E' TS32)$VPA ELSE 0);
       SMAP(TD32$VPA,RING,ICWBA);
       SMAP(TS32$VPA,RING,ICWBA+I32);
       BCOPY(ICWBA+TD32$VWA,ICWBA+I32+TS32$VWA,M32);
       RETURN;

FUNCTION WMOVE(MD32,MS32,N32);
       BMOVE(MD32,MS32,N32,WMBLK);
       SMAP(ICAA$VPA,RING,ICWBA);
       SMAP(ICAA$VPA+1 IF ICNPW>1 ELSE -1,RING,ICWBA+1@VPA);
       RETURN;

***
*** CPERR(S,T,F)
***
* PRINT THE STATEMENT WITH SI S WHICH JUST CAUSED A COMPILER ERROR
* BREAKING IT AT THE TOKEN WHOSE INDEX IS T
* IF T<0, BREAK AT CHARACTER (N' T)
* ONLY PRINT THE BLOCK NAME IF F=0, THE STATEMENT IF F>=0



       PROGRAM CPERR;
       INCLUDE STAB';

       DECLARE INTEGER I29,W29;
       DECLARE STRING LF29←"&J",FN29(2*SYMAXCN+12);

FUNCTION CPERR(SI29,TI29,F29);
       SETS(FN29,0,0);
       FN29←SWEA(SI29,F29,FN29//CPER2);
CPER2: CSOUT(FN29);
       COUT('&/', -1);
CPER4: RETURN IF F29<0;
       IF TI29<0 DO;
               ZUNPSI(SI29,ICGTN,0);
               I29←NN TI29;
       ELSE DO;
               I29←ZUNPSI(SI29,ICGTN,TI29-1);
       ENDIF;
       W29←LENGTH(UPS);
       I29←W29 IF I29<=0;
       SETW(UPS,I29);
       CSOUT(UPS);
       CSOUT(LF29);
       SETW(UPS,W29);
       SETR(UPS,I29);
       CSOUT(UPS);
       COUT('&/', -1);
CPER1: RETURN;
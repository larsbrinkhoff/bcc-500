       COMMON EDIT';
       INCLUDE COMM,STDEC,STST,EDST;


* THIS FILE CONTAINS THE SPL EDITOR


       DECLARE EXTERNAL EDLL,EDTK,EDSST; *SEARCH FUNCTIONS
*EX1
       DECLARE EXTERNAL ZPMAIN,ZPPDS;
*EX2



       PROGRAM EDINIT;
       INCLUDE EDIT', DBCOM;

* INITIALIZE ALL EDITOR VARIABLES. THIS FUNCTION IS
* CALLED PRIOR TO THE FIRST TIME THE EDITOR (EDCOM) IS CALLED.
       DI EINITX;

FUNCTION EDINIT();
       TABS[0]←8;
       TABS[EINITX]←TABS[EINITX-1]+5 FOR EINITX←1 TO LTABS;
       TABS[LTABS]←0;
       EDLANG←0; *THIS MUST BE FIXED--RIGHT NOW IT SAYS SPL UNSYMBOLLICALLY
       SETS(EDPSRS);
       SETS(EDPS);
       SETS(EDPST);
       EDUTN←EDUSI1←EDUSI2←EDUSI3←0;
       E1TN←E1SI←E2TN←E2SI←ECLTN←ECLSI←0;
       MODES[EINITX]←0 FOR EINITX←0 TO 6;
       MODES[4]←50;
       UMCONT←1;
       EFORMAT←4; *SET INDENTATION MODE TO STANDARD INDENTATION
       EMARGIN←8; *SET INDENTATION MARGIN
       EINDENT←4; *SET INCREMENTAL INDENTATION
       ECONTSP←1; *SET CONTINUATION INDENTATION INCREMENT
       SYMFT←940; *INDICATES 940 FILES FOR READING AND WRITING
       CODEFLAG ← PPTFLAG ← TREEFLAG ← BARE ← 0;
       STATFLAG ← 0;
       RETURN;



       PROGRAM EDCOM;
       INCLUDE EDIT', DBCOM;

* MAIN DRIVER FOR SPL EDITOR. CALLED FROM COMMAND LOOP.
       DECLARE ARRAY EDCAD[5]←(10000,1000,100,10,1);
* DISPATCH TABLE FOR EDITOR COMMANDS
       DECLARE SWITCH EDCMT[24]←(EDAPND,EDERR,EDCHNG,EDELET,
          EDEDIT,EDERR,EDERR,EDERR,EDINSR,EDERR,EDERR,EDLSTD,EDMODE,EDNEXT,EDERR,
          EDPREV,EDERR,EDREAD,EDSUB,EDTABS,EDUNDO,EDVAL,EDWRIT,EDXCHG);
       DP EDLXP;
       DI EDTBT1;
       DI EDCMCH,EDCZT,EDLXT;
       DQ EDCMIO←102B,EDCMIN←56110107B,EDCMDL←56000100B;
       DECLARE LABEL EDT4X←EDT4;* KLUDGE

FUNCTION EDCOM(), FRETURN;
       EDCZT←(0 IF HERALD='*' ELSE 1);
       COMMAND(CSTR,EDCMAR,EDCZT:CSTR,,EDCMCH//FRETN);
       E1TN←E2TN←ECLTN;
       E1SI←E2SI←ECLSI;
       MODES[7+EDCZT]←MODES[EDCZT] FOR EDCZT←0 TO 6;
       CSTR←EDGSP(CSTR);
       SDCOPY(EDLIST,CSTR);
EDCZ2: GOTO EDCZ2 IF (EDCZT←GCI(EDLIST//EDCZ3))#':' AND
        ((EDCZT>='A' AND EDCZT<='Z')OR(EDCZT>='0' AND EDCZT<='9')OR
        (EDCZT=' '));
       GOTO EDCZ3 IF EDCZT#':';
       EDCZT←GETW(CSTR);
       SETW(CSTR,GETR(EDLIST)-1);
       CSTR←EDMOD(CSTR,1//FRETN);
       SETW(CSTR,EDCZT);
       CSTR$SR ← INCDES(CSTR$SR, 1);
EDCZ3: CSTR←EDGSP(CSTR);
       IF (EDCMIO LSH EDCMCH)<0 DO;
          SETS(EDFNM);
          EDFNM←CGETF(EDFNM//FRETN);
          CSTR←EDGSP(CSTR);
          GOTO EDCZ9 IF LENGTH(CSTR)>0;
          IF EDCMCH='R'-'A' DO;
             E1TN←E1SI←E2SI←E2TN←0;
             GOTO EDCZ7;
          ENDIF;
          IF EDCMCH='W'-'A' DO;
             SSELECT(0);
             E1TN←ICFSTAT; E2TN←ICLSTAT;
             SSELECT(E1TN); E1SI←ICFSTAT;
             SSELECT(E2TN); E2SI←ICLSTAT;
             GOTO EDCZ7;
          ENDIF;
       ENDIF;
EDCZ9: CSTR←EDGSP(CSTR);
       CSTR←EDLJ(CSTR//FRETN) IF (EDCMIN LSH EDCMCH)<0;
       CSTR←EDGSP(CSTR);
EDCZ7: SUDEL() IF (EDCMDL LSH EDCMCH)<0;
       GOTO LABEL'FIXER(EDCMT[EDCMCH]);
EDERR: FRETN;
EDCHNG:FRETN IF E1TN#E2TN OR E2TN=0;
       SSELECT(E2TN);
       FRETN IF E1SI=ICFSTAT AND E2SI#ICLSTAT;
       EDLTN←E2TN; EDLSI←E2SI; EDISP(1,1//CHNG1);
       PLITN←EDLTN; PLISI←(EDLSI IF EDLTN=E2TN ELSE 0); GOTO CHNG2;
CHNG1: PLITN←PLISI←0;
CHNG2: EDXT(//FRETN);
       SSELECT(E2TN);
       EDCZT←SUNHOOK(E1SI,E2SI//CHNG3);
       IF EDINTV#0 DO;
          ENOUT(EDCZT); CSOUT(EDMS4);
       ENDIF;
       RETN;
* BAD INTERVAL SENT TO SUNHOOK.
CHNG3: CERR(124);
*      ******************************************************************
EDAPND:FRETN IF E2TN#E1TN OR E2SI#E1SI;
       GOTO APRD1 IF E2TN=0;
       EDLTN←E2TN; EDLSI←E2SI; EDISP(1,1//APRD1);
       PLITN←EDLTN; PLISI←(EDLSI IF EDLTN=E2TN ELSE 0); GOTO APRD2;
APRD1: PLITN←0; PLISI←0;
APRD2: EDXT(//FRETN);
       RETN;
*      ******************************************************************
EDEDIT:FRETN IF E1TN#E2TN; SSELECT(E2TN); FRETN IF E1SI=ICFSTAT;
       FRETN IF E2SI#E1SI; *REQUIRES ADDRESS INSTEAD OF INTERVAL
       FRETN IF E2TN=0;
       EDLTN←E1TN; EDLSI←E1SI;
       ERRSET(EDT4);
EDT1:  ZUNPP(EDLSI,EDLTN,EFORMAT);
       IF MODES[8]#0 DO; FSOUT(UPS,-1); COUT('&/',-1);
       ENDIF;
       UPS←ZEDIT(UPS,0,4B7//EDT4);
       IF MODES[7]#0 DO; FSOUT(UPS,-1); COUT('&/',-1); ENDIF;
       PLISI←E1SI; PLITN←E1TN;
       ZPPDS(UPS,10014000B//EDT4);
       GOTO EDT3 IF EDLSI=E2SI AND EDLTN=E2TN;
       IFQUIT(//EDT3);
       EDISP(1,0//EDT3); GOTO EDT1;
EDT3:  IF PLITN2#0 DO; ECLTN←PLITN2; ECLSI←PLISI2;
       ELSE DO;
       EDISP(-1,1//EDT5); GOTO EDT7;
EDT5:  EDISP(1,1//EDT6); GOTO EDT7;
EDT6:  ECLTN←ECLSI←0; GOTO EDT8;
EDT7:  ECLTN←EDLTN; ECLSI←EDLSI;
EDT8:  ENDIF;
       SSELECT(E1TN); SUNHOOK(E1SI,EDLSI//CHNG3);
       RETN;
EDT4:  EDISP(-1,0//FRETN);
       SSELECT(E1TN);
       SUNHOOK(E1SI,EDLSI//FRETN); ECLTN←E1TN; ECLSI←EDLSI;
       FRETN;
*      *****************************************************************
EDELET:FRETN IF E1TN#E2TN; FRETN IF E2TN=0;
       SSELECT(E2TN);
       FRETN IF E1SI=ICFSTAT AND E2SI#ICLSTAT;
       EDLTN←E1TN; EDLSI←E1SI; EDISP(-1,1//DELT1);
       ECLTN←EDLTN; ECLSI←EDLSI; GOTO DELT3;
DELT1: EDLTN←E2TN; EDLSI←E2SI; EDISP(1,1//DELT2);
       ECLTN←EDLTN; ECLSI←EDLSI; GOTO DELT3;
DELT2: ECLTN←0; ECLSI←0;
DELT3: SSELECT(E2TN); EDCZT←SUNHOOK(E1SI,E2SI//CHNG3);
       IF EDINTV#0 DO;
          ENOUT(EDCZT); CSOUT(EDMS3);
       ENDIF; RETN;
*      ******************************************************************
EDINSR:FRETN IF E1TN#E2TN OR E2SI#E1SI;
       PLITN←E2TN; SSELECT(E2TN); PLISI←(E2SI IF E2SI#ICFSTAT ELSE 0);
       EDXT(//FRETN);
       RETN;
*      ****************************************************************
EDMODE:CSTR←EDMOD(CSTR,0//FRETN); RETN;
*      ******************************************************************
EDREAD:FRETN IF E1TN#E2TN OR E1SI#E2SI;
       EDFN←OPEN'SEQ'FILE(EDFNM,0);
       PLITN←E2TN; SSELECT(E2TN); PLISI←(E2SI IF E2SI#ICFSTAT ELSE 0);
       ZPMAIN(EDFN,EDLANG,1//FRETN) IF PLISI=0
        ELSE ZPMAIN(EDFN,EDLANG,6//FRETN);
       IF PLITN2#0 DO; ECLTN←PLITN2; ECLSI←PLISI2;
       ENDIF;
       FMTO("* LINES/"); OUT(PLLNCT);
       RETURN;
*      *********************************************************************
EDSUB: SDCOPY(EDLIST,CSTR); EDLIST←EDGSP(EDLIST);
       EDSB←GCI(EDLIST//FRETN);
       FRETN IF EDSB#'/' AND EDSB#'*' AND  EDSB#'&'' AND EDSB#'"';
       SETS(EDSUBS); EDSUBS←EDGS(EDSB,EDSUBS//FRETN);
       EDPST←EDGS(EDSB,EDPST//FRETN); SDCOPY(EDTKNS,EDPST);
       FRETN IF LENGTH(EDPST)=0;
       EDLIST←EDLI(EDLIST//FRETN); FRETN IF LENGTH(EDLIST)>0;
       EDSB←('*'IF(EDSB='*' OR EDSB='/')ELSE '"');
       EDNSB←0; EDTKNO←0;
       EDLSI←E1SI; EDLTN←E1TN; EDLSSI←E2SI; EDLSTN←E2TN;
       EDSTN←EDABT2←EDABT1←EDNEWL←0; SSELECT(E1TN);
EDSUL1:EDSD(EDTK//EDSUL3) IF EDSB='*' ELSE EDSD(EDSST//EDSUL3);
EDSUL2:IF EDNSB>=MODES[11] DO;
          CSOUT(EDMS9); GOTO EDSUL3;
       ENDIF;
       EDSUX1←ZUNPSI(EDLSI,EDLTN,EDKT1);
       ZUNPSI(EDLSI,EDLTN,EDKT2); EDSUX2←UNCHNE;
       EDSUX2←LENGTH(UPS) IF EDSUX2=-1;
       EDRP(EDSUX1,EDSUX2//FRETN); EDNEWL←1;
       EDTKNO←EDKT3;
       GOTO EDSUL1;
EDSUL3:ENOUT(EDNSB); CSOUT(EDMS8);
       RETN;
*      *******************************************************************
EDTABS:IF LENGTH(CSTR)=0 DO;
*SET TABS ACCORDING TO STANDARD TERMINAL TABS.
          TABS[EDTBT1←0]←8;
          TABS[EDTBT1←EDTBT1+1]←TABS[EDTBT1-1]+5 WHILE EDTBT1<LTABS;
          TABS[LTABS]←0;
          RETN;
       ELSE DO;
*SET TABS ACCORDING TO LIST OF NUMBERS IN CSTR.
          SDCOPY(EDLIST,CSTR);
          EDNUM(//FRETN);
          FRETN IF EDLXV<1 OR EDLXV>80;
          TABS[0]←EDLXV;
          SDCOPY(CSTR,EDLIST); EDTBT1←0;
          WHILE GCI(EDLIST//EDTB1)=',' DO;
             EDNUM(//EDTB2);
             GOTO EDTB2 IF EDLXV>80 OR EDLXV<=TABS[EDTBT1];
             GOTO EDTB2 IF EDTBT1=(LTABS+2);
             TABS[EDTBT1←EDTBT1+1]←EDLXV;
             SDCOPY(CSTR,EDLIST);
          ENDFOR;
EDTB1:    TABS[EDTBT1+1]←0; RETN;
EDTB2:    TABS[EDTBT1+1]←0; FRETN;
       ENDIF;
*      ******************************************************************
EDUNDO:FRETN IF EDUTN=0; SUINS(); RETN;
*      *****************************************************************
EDXCHG:FRETN;
*      *****************************************************************
EDLSTD:EDLST(-1); RETN;
********************************************************************
EDVAL: FRETN IF E1TN#E2TN AND E1SI#E2SI;
       EDCZT←1;
       SSELECT(E1TN); EDLTN←E1TN; EDLSI←ICFSTAT;
       WHILE E1SI#EDLSI DO; EDISP(1,0//FRETN); EDCZT←EDCZT+1;
       ENDFOR;
       FMTO("<@>'#* = <>'#*/");
       OUT(-E1TN); OUT(EDCZT);
       SSELECT(0); EDLXT←ICFSTAT;
       WHILE EDLXT#E1TN DO;
           SSPTR(EDLXT:,EDLXP);
          EDCZT←EDCZT+EDLXP.GSNL; EDLXT←SGNEXT(EDLXT//FRETN);
       ENDFOR;
       OUT(EDCZT);
       ECLTN←E1TN; ECLSI←E1SI;
       RETN;
*      *****************************************************************
EDWRIT:EDLST(OPEN'SEQ'FILE(EDFNM,1)); RETN;
*      ******************************************************************
EDNEXT:EDGNP(//FRETN);
       EDLXV←1 IF EDLXV=0;
       EDPX(); RETN;
*      ******************************************************************
EDPREV:EDGNP(//FRETN);
       EDLXV←1 IF EDLXV=0;
       EDLXV←-EDLXV;
       EDPX(); RETN;



       PROGRAM EDLI;
       INCLUDE EDIT';

* READ FROM THE ARGUMENT STRING (AND DELETE IF SUCCESSFUL)
* AN EDITOR ADDRESS OR INTERVAL AND LEAVE THE RESULT IN
* E1TN,E1SI,E1LN AND E2TN,E2SI,E2LN. IF THE INTERVAL IS
* ONLY ONE LINE, E1=E2. FAILURE OCCURS IF AN IMPROPER
* CONSTRUCT IS PRESENTED.
       DI EDLIX1;

STRING FUNCTION EDLI (STRING EDLIS), FRETURN;
       EDLIX1←0; GOTO EDLIL1;
*THIS ENTRY COLLECTS E1,E2 INTERVAL AND ALSO THE E3,E4 INTERVAL; AND
*SETS THE MOVE FLAG(EDTFG) APPROPRIATLY.
STRING ENTRY EDLJ(EDLIS), FRETURN;
       EDLIX1←1;
EDLIL1:SDCOPY(EDLIST,EDLIS);
       EDLXCH←EDINTV←0;
       E3TN←E4TN←E3SI←E4SI←EDLSCP←EDTFG←0;
       EDLX(//FRETN); E1TN←EDLTN; E1SI←EDLSI;
       IF EDLXCH=',' DO; EDLZ(//FRETN); EDINTV←1;
       ENDIF;
       E2TN←EDLTN; E2SI←EDLSI;
       EDCK(E1TN,E1SI,E2TN,E2SI//FRETN);
       IF EDLIX1=0 DO; FRETN IF EDLXCH#-1 ELSE GOTO EDLI3;
       ENDIF;
       IF EDLXCH='=' DO; EDTFG←1; EDLIST←EDGSP(EDLIST);
          FRETN IF GCI(EDLIST//FRETN)#'['; GOTO EDLI2;
       ENDIF;
       IF EDLXCH='[' DO;
EDLI2:    EDLSCP←0; EDLX(//FRETN); E3TN←EDLTN; E3SI←EDLSI;
          EDLZ(//FRETN) IF EDLXCH=',';
          E4TN←EDLTN; E4SI←EDLSI;
          FRETN IF EDLXCH#']';
          EDCK(E3TN,E3SI,E4TN,E4SI//FRETN);
           FRETN IF E1TN=0 OR E2TN=0;
       ENDIF;
EDLI3: SDCOPY(EDLIS,EDLIST); RETN EDLIS;



       PROGRAM EDLA;
       INCLUDE EDIT';

* AS IN EDLI EXCEPT THAT ONLY ONE ADDRESS IS ACCEPTED
* AND THE RESULTS ARE LEFT IN E1TN,E1SI.

FUNCTION EDLA (STRING EDLAST), FRETURN;
       SDCOPY(EDLIST,EDLAST);
       EDLSCP←0;
       EDLX(//FRETN);
       E1TN←EDLTN; E1SI←EDLSI;
       FRETN IF EDLXCH#-1 AND EDLXCH#',';
       SDCOPY(EDLAST,EDLIST);
       RETN;



       PROGRAM EDLX;
       INCLUDE EDIT';
*****
* 5/3/73  JACK FREEMAN
* ARRAY FOR KLUDGE TO PASS ARRAY DESCRIPTOR (INSTEAD OF POINTER) TO
* SSFIND.  SEE BELOW.
       DECLARE ARRAY KLUDGE'EDID;
*****

* THIS FUNCTION COLLECTS AN EDITOR ADDRESS. THE RESULT
* IS LEFT IN EDLTN,EDLSI. FAILURE INDICATES
* THAT SOMETHING WAS WRONG WITH THE PRESENTED ADDRESS.

FUNCTION EDLX(), FRETURN;
       SSELECT(ECLTN); EDLTN←ECLTN; EDLSI←ECLSI;
       GOTO EDLXL1;
*THIS ENTRY IS FOR THE SECOND ADDRESS IN AN INTERVAL.
ENTRY EDLZ(), FRETURN;
       SSELECT(EDLTN);
EDLXL1:EDIR←1;
       EDLIST←EDGSP(EDLIST);
EDLX0: EDLXCH←GCI(EDLIST//RETN);
       IF EDLXCH='.' DO;
          EDLTN←ECLTN; EDLSI←ECLSI; SSELECT(EDLTN);
          GOTO EDLX7;
       ELSEIF EDLXCH='<' DO; EDLIST←EDGSP(EDLIST);
          IF(EDLXCH←GCI(EDLIST//FRETN))='>' DO;
             EDLSCP←1;
          ELSEIF EDLXCH>='A' AND EDLXCH<='Z' DO;
             EDLSCP←0; EDCL(//FRETN); SSELECT(0);
*****
* 5/3/73  JACK FREEMAN
* KLUDGE TO GIVE SSFIND THE ARRAY DESCRIPTOR IT REQUIRES.  PROPER
* FIX MIGHT BE TO STORE WHAT IS NOW STORED IN EDID[0] IN A GLOBAL
* SCALAR AND THEN STORE SYMBOL NAME IN EDID STARTING AT ELEMENT
* 0 INSTEAD OF 1.  THIS WOULD ALLOW PASSING EDID ITSELF TO SSFIND.
* THIS SAME KLUDGE IS USED BELOW IN EDLL.
             KLUDGE'EDID ← ARRDESC(@EDID[1], 4, 1, 0);
*****
             FRETN IF (EDLTN←SSFIND(KLUDGE'EDID,EDID[0]))=0;
             EDLIST←EDGSP(EDLIST);
             FRETN IF GCI(EDLIST//FRETN)#'>';
             SSELECT(EDLTN); EDLSI←ICFSTAT;
          ELSE DO; FRETN;
          ENDIF;
          EDLIST←EDGSP(EDLIST);
          EDLXCH←GCI(EDLIST//FRETN);
       ENDIF;
       IF EDLXCH='$' DO;
          IF EDLSCP=1 DO;
             SSELECT(0); EDLTN←ICLSTAT; SSELECT(EDLTN);
          ENDIF;
          EDLSI←ICLSTAT; GOTO EDLX7;
       ELSEIF EDLXCH='#' DO; EDLIST←EDGSP(EDLIST);
          IF EDLSCP=1 DO; SSELECT(0); EDLTN←ICFSTAT;
          ENDIF;
          SSELECT(EDLTN); EDLSI←ICFSTAT;
          EDNUM(//FRETN); EDISP(EDLXV-1,EDLSCP//FRETN);
          GOTO EDLX7;
       ELSEIF EDLANG=0 AND EDLXCH>='A' AND EDLXCH<='Z' DO;
          EDCL(//FRETN); EDSC(EDLL//FRETN); GOTO EDLX7;
       ELSEIF EDLXCH='-' DO; EDLIST←EDGSP(EDLIST);
          EDLXCH←GCI(EDLIST//FRETN); EDIR←-1;
       ENDIF;
       EDSR(//FRETN); EDIR←1;
EDLX7: EDLIST←EDGSP(EDLIST);
       IF LENGTH(EDLIST)=0 DO; EDLXCH←-1; RETN;
       ENDIF;
       EDLXCH←GCI(EDLIST//RETN);
       RETN IF EDLXCH=',' OR EDLXCH='[' OR EDLXCH=']' OR EDLXCH='=';
       IF EDLXCH='+' DO; EDLIST←EDGSP(EDLIST);
          EDNUM(//FRETN); EDISP(EDLXV,1//FRETN);
       ELSEIF EDLXCH='-' DO; EDLIST←EDGSP(EDLIST);
          IF(EDLXCH←GCI(EDLIST//FRETN))<='9' AND EDLXCH>='0' DO;
             EDLIST$SR ← INCDES(EDLIST$SR, -1);
             EDNUM(//FRETN); EDISP(-EDLXV,1//FRETN);
          ELSE DO;
             EDIR←-1; EDSR(//FRETN); EDIR←1;
          ENDIF;
       ELSE DO;
          EDSR(//FRETN);
       ENDIF;
       GOTO EDLX7;



       PROGRAM EDNUM;
       INCLUDE EDIT';

* COLLECT DECIMAL INTEGER FROM STRING EDLIST AND PUT ITS NUMERICAL
* VALUE IN EDLXV.
       DI EDLZCH,EDLXV1;

FUNCTION EDNUM(), FRETURN;
       EDLXV←EDLXV1←0;
EDNM1: EDLZCH←GCI(EDLIST//EDNM2);
       IF EDLZCH>='0' AND EDLZCH<='9' DO;
          FRETN IF EDLXV>838859;
          EDLXV←EDLXV*10+EDLZCH-'0';
           EDLXV1←1;
          GOTO EDNM1;
       ENDIF;
       EDLIST$SR ← INCDES(EDLIST$SR, -1);
EDNM2: FRETN IF EDLXV<0 OR EDLXV1=0;
       RETN;



       PROGRAM EDCK;
       INCLUDE EDIT';

*THIS FUNCTION CHECKS THE X1,X2 INTERVAL FOR X2>=X1.
       DI EDCKX1,EDCKX2;
       DP EDCKX3;

FUNCTION EDCK(X1TN,X1SI,X2TN,X2SI), FRETURN;
       RETN IF X1TN=0 AND X2TN=0;
       IF X1TN=X2TN DO;
          IF X1SI#X2SI DO;
             EDLTN←X1TN; EDLSI←X1SI;
EDCKL1:      EDISP(1,0//FRETN); GOTO EDCKL1 IF X2SI#EDLSI;
          ENDIF;
       ELSE DO;
          SSELECT(0);
          EDCKX1←X1TN;
EDCKL2:   EDCKX1←SGNEXT(EDCKX1//FRETN);
          GOTO EDCKL2 IF EDCKX1#X2TN;
       ENDIF;
       RETN;



       PROGRAM EDXT;
       INCLUDE EDIT';

* THIS FUNCTION GETS TEXTUAL INPUT FROM KEYBOARD OR SPECIFIED INTERVAL
* AND EXPECTS PLISI AND PLITN TO BE ALLREADY SETUP. ALSO SETS
* CURRENT LINE APPROPRIATELY.
       DI EDXTX1;

FUNCTION EDXT(), FRETURN;
       IF E4TN=0 DO;
          ZPMAIN(TTYIN,EDLANG,1//FRETN) IF PLISI=0
           ELSE ZPMAIN(TTYIN,EDLANG,6//FRETN);
       ELSE DO;
          FRETN IF E4TN#E3TN;
          EDLTN←E3TN; EDLSI←E3SI;
EDXTL1:   ZUNPP(EDLSI,EDLTN,2);
          ZPPDS(UPS,1//FRETN) IF PLISI=0 ELSE ZPPDS(UPS,6//FRETN);
          GOTO EDXTL2 IF EDLSI=E4SI AND EDLTN=E4TN;
          IFQUIT(//FRETN);
          EDISP(1,1//EDXTL3); GOTO EDXTL1;
EDXTL2:   SSELECT(E3TN);
          IF EDTFG=1 DO; EDXTX1←SUNHOOK(E3SI,E4SI//EDXTL4); SUDEL();
             ENOUT(EDXTX1); CSOUT(EDMS5);
          ENDIF;
       ENDIF;
       IF PLITN2=0 DO; ECLTN←E1TN; ECLSI←E1SI;
       ELSE DO; ECLTN←PLITN2; ECLSI←PLISI2;
       ENDIF;
       RETN;
EDXTL3:CERR(125); *FINAL LINE NO. FOR TEXT NOT FOUND
EDXTL4:CERR(124); *BAD INTERVAL SENT TO SUNHOOK



       PROGRAM EDLB;
       INCLUDE EDIT';

* RETN TOKEN OF LABEL IN LINE INDEXED BY EDLBSI, FRETN IF NONE.
       DI EDLBX1,EDLBX2,EDLBX3,EDLBX4,EDLBX5,EDLBX6;
       DP EDLBP;

FUNCTION EDLB(EDLBSI), FRETURN;
       FRETN IF ICGTN=0 OR EDLBSI<1;
       EDLBP←STPTR(EDLBSI);
       EDLBX6←(EDLBP.PTSIZE-1)*2+EDLBP.PTONT;
       IF ICBA.IBFTYPE=IBFTSPL DO;
          EDLBX2←0;
          FOR EDLBX1←PTTO TO EDLBX6 DO;
             EDLBX2←EDLBX2+1 IF(EDLBX3←GHW(EDLBP,EDLBX1))>0
              AND EDLBX3<TNBMIN;
             EDLBX4←EDLBX3 IF EDLBX2=1;
             IF EDLBX2=2 DO; EDLBX5←EDLBX3 A' OPTMSK; GOTO EDLBL1;
             ENDIF;
          ENDFOR; FRETN;
EDLBL1:   FRETN IF EDLBX5#TNRMIN+':';
          RETN EDLBX4;
       ELSE DO;
          FRETN;
       ENDIF;



       PROGRAM EDCL;
       INCLUDE EDIT';

* COLLECT IDENTIFIER FROM EDLIST AND LEAVE IT IN EDID WITH EDID[0]
* EQUAL TO THE NUMBER OF WORDS USED BY THE IDENTIFIER. FAIL IF ID TOO BIG.
* THE FIRST CHARACTER IS ALLREADY IN EDLXCH.
       DI EDCX1,EDCX2;

FUNCTION EDCL(), FRETURN;
       EDID[4]←EDID[2]←EDID[3]←0;
       EDID[1]←EDLXCH LSH 18; EDCX2←4;
       WHILE ((EDCX1←GCI(EDLIST//EDCL1))>='A' AND EDCX1<='Z')
        OR (EDCX1>='0' AND EDCX1<='9') OR (EDCX1='&'') DO;
          EDCX2←EDCX2+1;
          EDID[EDCX2 RSH 2]←(EDCX1 LSH EDCSH[EDCX2 AA 3B]) VV
           EDID[EDCX2 RSH 2] IF EDCX2<20;
       ENDFOR;
       EDLIST$SR ← INCDES(EDLIST$SR, -1);
EDCL1: EDID[0]←EDCX2 RSH 2; FRETN IF EDCX2>19;
       RETN;



       PROGRAM EDSR;
       INCLUDE EDIT';

* COLLECT STRING IN PREPARATION FOR SEARCH AND CALL
* PROPER SEARCH DRIVER WITH PROPER ENVIRONMENT.

FUNCTION EDSR(), FRETURN;
       FRETN IF ICGTN=0;
       IF EDLXCH='*' OR EDLXCH='/' DO;
          EDPSRS←EDGS(EDLXCH,EDPSRS//FRETN); FRETN IF LENGTH(EDPSRS)=0;
          SDCOPY(EDTKNS,EDPSRS);
          EDTKNO←0;
          EDSC(EDTK//FRETN); RETN;
       ELSEIF EDLXCH='&'' OR EDLXCH='"' DO;
          EDPSRS←EDGS(EDLXCH,EDPSRS//FRETN); FRETN IF LENGTH(EDPSRS)=0;
          SDCOPY(EDTKNS,EDPSRS);
          EDSC(EDSST//FRETN); RETN;
       ELSE DO;
          FRETN;
       ENDIF;



       PROGRAM EDSC;
       INCLUDE EDIT';

* THIS FUNCTION ACTS AS THE MAIN SEARCH DRIVER - PROVIDING THE
* EXTERNAL LINE SEQUENCING FOR FUNCTION EDFUN.  FAILURE AND SUCCESS
* FRETNS MEAN JUST THAT.
* EDIR DETERMINES THE LINE INCREMENT, EDLSCP THE IB SCOPE, AND EDLTN
* AND EDLSI DETERMINE THE ENDING POINT.  THE FIRST LINE EXAMINED IS
* ADJACENT TO THE ENDING LINE AND THE SEARCH IS CIRCULAR WITHIN THE
* SCOPE BOUNDARY.

FUNCTION EDSC(FUNCTN EDFUN), FRETURN;
       FRETN IF EDLTN=0;
       EDLSSI←EDLSI; EDLSTN←EDLTN;
       EDSTN←EDABT2←0;
EDSCL1:EDISP(EDIR,EDLSCP//EDSCL3);
EDSCL4:EDABT1←EDTKNO←EDNEWL←0;
       GOTO EDSCL5;
*ENTRY POINT TO CONTINUE WHERE LAST LEFT OFF.
ENTRY EDSD(EDFUN);
EDSCL5:IFQUIT(//FRETN);
       EDFUN(//EDSCL2); RETN;
EDSCL2:FRETN IF EDLSI=EDLSSI AND EDLTN=EDLSTN;
       IF EDABT1#0 DO; SSELECT(EDLTN);
          IF EDLTN=EDLSTN DO; FRETN IF EDABT2#0; EDABT2←1;
             FRETN IF EDLSCP=0;
             FRETN IF EDLSSI=ICLSTAT AND EDIR>0;
             FRETN IF EDLSSI=ICFSTAT AND EDIR<0;
          ENDIF;
          EDLSI←(ICFSTAT IF EDIR<0 ELSE ICLSTAT);
       ENDIF;
       GOTO EDSCL1;
EDSCL3:IF EDLSCP=1 DO;
          SSELECT(0); EDLTN←(ICFSTAT IF EDIR>0 ELSE ICLSTAT);
          SSELECT(EDLTN);
       ENDIF;
       EDLSI←(ICFSTAT IF EDIR>0 ELSE ICLSTAT);
       GOTO EDSCL4;



       PROGRAM EDSST;
       INCLUDE EDIT';

* RETN IF STRING EDPS IS IN LINE EDLTN, EDLSI; ELSE FRETN
       DS EDSER(0),EDSSTEST(0);
       DI EDSSX1,EDSSX2;

FUNCTION EDSST(), FRETURN;
       ZUNPP(EDLSI,EDLTN,EFORMAT);
       SDCOPY(EDSER,EDTKNS);
       SDCOPY(EDSSTEST,UPS);
       SETR(EDSSTEST,EDTKNO);
       EDSSX1←GCI(EDSER//FRETN);
EDSSL2:GOTO EDSSL4 IF EDSSX1#GCI(EDSSTEST//FRETN); *FIND FIRST LETTER
       EDSSX2←GETR(EDSSTEST);
EDSSL4:GOTO EDSSL4 IF GCI(EDSER//EDSSL6)=GCI(EDSSTEST//FRETN);
       SETR(EDSER,1); *RESET SEARCH STRING
       SETR(EDSSTEST,EDSSX2); *RESET TEST STRING
       GOTO EDSSL2; *TRYAGAIN
EDSSL6:EDKT1←EDSSX2-1; *SET FIRST CHARACTER NUMBER
       EDKT2←GETR(EDSSTEST)-1; *SET LAST CHARACTER NUMBER
       RETN;



       PROGRAM EDRP;
       INCLUDE EDIT', DBCOM;

* THIS FUNCTION REPLACES PORTIONS OF STRING UPS WITH STRING EDSUBS.
* FIRST CHAR. NO. IS EDRPP1, LAST-1 IS EDRPP2.
       DS EDRPS1(0),EDRPS2(100);
       DI EDRPX1,EDRPX2,EDRPX3;

FUNCTION EDRP(EDRPP1,EDRPP2), FRETURN;
       IF EDNEWL=0 AND (MODES[8]#0 OR MODES[9]#0) DO;
          CSOUT(UPS); COUT('&/', -1);
       ENDIF;
       EDRPX1←0; SETS(EDRPS2);
       WHILE EDRPX1<EDRPP1 DO; EDRPX2←GCI(UPS//FRETN);
          WCI(EDRPX2,EDRPS2//FRETN); EDRPX1←EDRPX1+1;
       ENDFOR;
       UPS$SR ← INCDES(UPS$SR,EDRPP2-EDRPP1); SDCOPY(EDRPS1,EDSUBS);
EDRPL1:APPND(EDRPS2,EDRPS1//FTLERR);
EDRPL8:EDRPX3←LENGTH(EDRPS2);
EDRPL2:APPND(EDRPS2,UPS//FTLERR);
EDRPL3:SETS(UPS);
EDRPL4:WHILE LENGTH(UPS)<EDRPX3 DO;
          EDRPX2←GCI(EDRPS2//EDRPL5); WCI(EDRPX2,UPS//FRETN);
       ENDFOR;
EDRPL5:PLISI←EDLSI; PLITN←EDLTN;
       ZPPDS(UPS,12220000B//FRETN);
       EDKT3←(PPTA.PTSIZE*2+PPTA.PTONT-PTTO-1 IF EDSB='*' ELSE
        EDRPP1+LENGTH(EDSUBS)+1);
       SETR(UPS,0); *RECLAIM STRING
EDRPL6:APPND(UPS,EDRPS2//FTLERR);
EDRPL7:IF MODES[9] DO;
EDRPL9:   CSOUT(EDMS10);
       EEES ← ZEDIT(EEES,0,4B7//EDRPL0);
EDRPL0:IF LENGTH(EEES)>0 DO;
           EDRPX2←GC(EEES);
       ELSE DO;
           EDRPX2←'N';
       ENDIF;
          IF EDRPX2#'Y' AND EDRPX2#'N' DO;
             CSOUT(EDMS12); CSOUT(EDMS11); GOTO EDRPL9;
          ENDIF;
          COUT('&/', -1);
          IF EDRPX2='N' DO; EDKT3←EDKT1+1; RETN;
          ENDIF;
       ENDIF;
       SSELECT(EDLTN);
       PLISI←EDLSI; PLITN←EDLTN;
       ZPPDS(UPS,10013000B//FRETN);
       IF PLITN2#0 DO; ECLTN←PLITN2; ECLSI←PLISI2; EDNSB←EDNSB+1;
       ENDIF;
       IF EDLSI=EDLSSI AND EDLTN=EDLSTN DO; EDLSSI←PLISI2;
       ENDIF;
       SUDEL();
       SUNHOOK(EDLSI,EDLSI//FRETN); SUDEL();
       EDLSI←PLISI2;
       IF MODES[7]#0 DO; SETR(EDRPS2,0);
          CSOUT(EDRPS2); COUT('&/', -1);
       ENDIF;
       RETN;



       PROGRAM EDLL;
       INCLUDE EDIT';
*****
* 5/3/73  JACK FREEMAN
* ARRAY FOR KLUDGE TO PASS ARRAY DESCRIPTOR (INSTEAD OF POINTER) TO
* SSFIND.  SEE BELOW.
       DECLARE ARRAY KLUDGE'EDID;
*****

* RETN IF LABEL IN EDID IS IN LINE EDLTN, EDLSI; ELSE FRETN.

FUNCTION EDLL(), FRETURN;
       IF EDLTN#EDSTN DO;* GET LABEL TOKEN FOR CURRENT IB
          EDSTN←EDLTN;
*****
* 5/3/73  JACK FREEMAN
* KLUDGE TO GIVE SSFIND THE ARRAY DESCRIPTOR IT REQUIRES.  PROPER
* FIX MIGHT BE TO STORE WHAT IS NOW STORED IN EDID[0] IN A GLOBAL
* SCALAR AND THEN STORE SYMBOL NAME IN EDID STARTING AT ELEMENT
* 0 INSTEAD OF 1.  THIS WOULD ALLOW PASSING EDID ITSELF TO SSFIND.
* THIS SAME KLUDGE IS USED ABOVE IN EDLX.
             KLUDGE'EDID ← ARRDESC(@EDID[1], 4, 1, 0);
*****
          EDSTK←SSFIND(KLUDGE'EDID,EDID[0]);
       ENDIF;
       IF EDSTK=0 DO; *ABORT SEARCH IN CURRENT IB
          EDABT1←1; FRETN;
       ENDIF;
       RETN IF EDLB(EDLSI//FRETN)=EDSTK;
       FRETN;



       PROGRAM EDGS;
       INCLUDE EDIT';

* COPY STRING IN EDLIST UP TO CHARACTER EDGSC INTO THE PERMANENT 
* STRING EDGSS UNLESS EDGSC IS THE FIRST CHARACTER ENCOUNTERED, IN 
* WHICH CASE EDGSS IS LEFT UNDISTURBED.
       DI EDGSX1;

STRING FUNCTION EDGS(EDGSC,STRING EDGSS), FRETURN;
       RETN EDGSS IF((EDGSX1←GCI(EDLIST//FRETN))=EDGSC);
       SETS(EDGSS);
EDGSL1:WCI(EDGSX1,EDGSS//FRETN);
       RETN EDGSS IF((EDGSX1←GCI(EDLIST//FRETN))=EDGSC);
       GOTO EDGSL1;



       PROGRAM EDTK;
       INCLUDE EDIT';

* RETN IF TOKENS IN EDTKNS STRING ARE IN LINE EDLTN, EDLSI; FRETN OTHERWISE.
*SEARCH  STARTS WITH TOKEN NUMBER EDTKNO (FIRST = 0).
       DS EDTKS(0);
       DP EDTKP;
       DI EDTKX1,EDTKX2,EDTKX3,EDTKX4,EDTKX5;

FUNCTION EDTK(), FRETURN;
       IF EDLTN#EDSTN DO;* SET UP FOR CURRENT IB
          EDSTN←EDLTN; SDCOPY(EDTKS,EDTKNS); SETS(UPS);
          EDTKX3←GCI(EDTKS//EDTKL1);
          IF EDTKX3='*' AND EDLANG=0 DO; WCI(' ',UPS//FRETN);
          ENDIF;
          WCI(EDTKX3,UPS//FRETN);
          APPND(UPS,EDTKS//FTLERR);
EDTKL1:   SSELECT(EDLTN);
          ZPPDS(UPS,02220100B//EDTKL2);
          EDTKX1←0; EDTKX2←(PPTA.PTSIZE-1)*2+PPTA.PTONT;
          FOR EDTKX3←PTTO TO EDTKX2 DO;
                EDTKX4←GHW(PPTB,EDTKX3);
                GOTO EDTKL3 IF (EDTKX1←EDTKX1+1)>10; *TOO MANY TOKENS
                EDTKM[EDTKX1]←(OPTMSK IF EDTKX4>=TNRMIN AND
                 EDTKX4<TNKMIN ELSE -1);
                EDTKA[EDTKX1]←EDTKX4; GOTO EDTKL4 IF EDTKX4=TKN50;
          ENDFOR;
EDTKL4:   GOTO EDTKL2 IF (EDTKA[0]←EDTKX1)=0; * NO TOKENS
       ENDIF;
       EDTKP←STPTR(EDLSI);
       EDTKX1←((EDTKP.PTSIZE-1)LSH 1)+EDTKP.PTONT;
       EDTKX3←0;
       FRETN IF GHW(EDTKP,PTTO)=TKN55; *ERROR LINE
       FOR EDTKX2←PTTO TO EDTKX1 DO;
          EDTKX3←EDTKX3+1;
          EDTKX4←GHW(EDTKP,EDTKX2); PHW(PPTB,EDTKX3,EDTKX4);
           IF EDTKX4=TKN50 DO; *IF COMMENT LINE THEN BLANK IT OUT
               EDTKX5←(((GHW(EDTKP,EDTKX2+1)+1)LSH 1)/3)
                +(EDTKX2 AA 1)+1; *NUMBER OF COMMENT HALF WORDS
               IF (EDTKX2←EDTKX2+EDTKX5)<EDTKX1 DO;
                   EDTKX5←EDTKX3+EDTKX5;
                   PHW(PPTB,EDTKX3,0)FOR EDTKX3←EDTKX3+1 TO EDTKX5;
                   EDTKX3←EDTKX5;
               ENDIF;
           ENDIF;
       ENDFOR;
       EDTKX1←EDTKX3;
EDTKL7:FOR EDTKX2←1+EDTKNO TO EDTKX1 DO;
          IF ((EDTKA[1] XOR GHW(PPTB,EDTKX2)) AA EDTKM[1])=0 DO;
             EDTKX5←EDTKX2;
             FOR EDTKX3←2 TO EDTKA[0] DO;
EDTKL8:         GOTO EDTKL5 IF(EDTKX5←EDTKX5+1)>EDTKX1;
                EDTKX4←GHW(PPTB,EDTKX5);
                GOTO EDTKL8 IF EDTKX4>=TNBMIN OR EDTKX4=0;
                GOTO EDTKL5 IF ((EDTKX4 XOR EDTKA[EDTKX3]) AA
                 EDTKM[EDTKX3])#0;
             ENDFOR;
             EDKT1←EDTKX2-1; EDKT2←EDTKX5-1;
             RETN;
EDTKL5:   ENDIF;
       ENDFOR;
       FRETN;
EDTKL2:EDABT1←1; EDSTN←0; FRETN;
* TOO MANY TOKENS IN TOKEN SEARCH
EDTKL3:CERR(120);
* CAN NOT SEARCH FOR COMMENT TOKEN
EDTKL6:CERR(121);



       PROGRAM EDISP;
       INCLUDE EDIT';

*  INCREMENTS OR DECREMENTS EDLTN, EDLSI, BY
*  THE NUMBER OF LINES SPECIFIED BY THE SIGNED VALUE OF
*  LINES.  IF EDISX=1, IB BOUNDARIES MAY BE CROSSED;
*  OTHERWISE NOT. FRETN IF EDISX=0 AND ATTEMPT IS
*  MADE TO CROSS BOUNDARY AND IF EDISX#0 AND ATTEMPT
*  IS MADE TO CROSS FIRST OR LAST BOUNDARY. FRETN WILL
*  LEAVE MAX OR MIN LEGAL VALUE IN EDLTN, EDLSI.
       DP EDIPP,EDIPQ;
       DI EDIST1;

FUNCTION EDISP(EDISL, EDISX), FRETURN;
       FRETN IF EDLTN=0;
       RETN IF EDISL=0;
       SSELECT(EDLTN);
       IF EDISL>0 DO;
          WHILE EDISL>0 DO;
             EDISL←EDISL-1;
             IF(EDIST1←SNEXT(EDLSI))=0 DO;
                 EDLTN←SGNEXT(EDLTN//EDIS3) IF EDISX=1 ELSE FRETN;
                 SSELECT(EDLTN);  EDLSI←ICFSTAT;
             ELSE DO; EDLSI←EDIST1;
             ENDIF;
          ENDFOR;
       ELSE DO;
          WHILE EDISL<0 DO;
              EDISL←EDISL+1;
              IF(EDIST1←SPREV(EDLSI))=0 DO;
                 EDLTN←SGPREV(EDLTN//EDIS3) IF EDISX=1 ELSE FRETN;
                 SSELECT(EDLTN);  EDLSI←ICLSTAT;
              ELSE DO; EDLSI←EDIST1;
              ENDIF;
          ENDFOR;
       ENDIF;
       RETN;
* GSORD=0 NOT EXPECTED
EDIS2: CERR(128);
EDIS3: SSELECT(EDLTN);
       FRETN;



       PROGRAM EDGSP;
       INCLUDE EDIT';

* GET (THUS DELETING) SPACES IN STRING EDGSX UP
* TO THE NEXT NON-BLANK CHARACTER

STRING FUNCTION EDGSP(STRING EDGSX);
EDGS1: GOTO EDGS1 IF GCI(EDGSX//EDGS2)=' ';
       EDGSX$SR ← INCDES(EDGSX$SR,-1);
EDGS2: RETURN EDGSX;



       PROGRAM EDLST;
       INCLUDE EDIT', DBCOM;

* LISTS ON DEVICE EDDEV THE E1-E2 INTERVAL.
* RETURN OCCURS IF QUIT OCCURS.
       DI EDLST3,EDLST4;

FUNCTION EDLST(EDDEV);
       UMCONT←(MODES[10] IF EDDEV=-1 ELSE 1);
       EDLST3←0;
       ECLTN←E1TN;  ECLSI←E1SI;
       SSELECT(E1TN);
       EDLST4←0;
EDLT2: ZUNPP(ECLSI,ECLTN,EFORMAT);
       FSOUT(UPS,EDDEV);
       COUT('&/',EDDEV);
       EDLST4←EDLST4+1;
       EDLST3←EDLST3+LENGTH(UPS)+2;
       IFQUIT(//EDLT8); 
       IF ECLSI=E2SI AND ECLTN=E2TN DO;
EDLT8:    IF EDDEV#-1 DO;
             EDLST3←(EDLST3+3)/3;
             CLOSE'SEQ'FILE(EDDEV);
             ENOUT(EDLST4); CSOUT(EDMS1);
             ENOUT(EDLST3); CSOUT(EDMS2);
          ENDIF;
          RETURN;
       ENDIF;
EDLT9: EDLTN←ECLTN; EDLSI←ECLSI;
       EDISP(1,1//EDLT6);
       ECLTN←EDLTN; ECLSI←EDLSI;
       GOTO EDLT2;
* FINAL LINE NUMBER FOR LINE NOT IN LINE SEQUENCE
EDLT6: CERR(123);



       PROGRAM ENOUT;
       INCLUDE EDIT';

* PRINTS ENOUTN ON THE TELETYPE, BASE TEN.

FUNCTION ENOUT(ENOUTN);
       FIOUT(ENOUTN,-1,0,10);
       RETURN;



       PROGRAM EDPX;
       INCLUDE EDIT';

*  LISTS THE NEXT OR PREVIOUS (EDLXV) LINES DEPENDING ON THE
*  SIGN OF EDLXV.  LEAVES THE LAST LISTED LINE AS CURRENT.

FUNCTION EDPX();
       EDLTN←ECLTN; EDLSI←ECLSI;
       EDISP(1 IF EDLXV>0 ELSE -1,1//EDPX1);
       ECLTN←EDLTN; ECLSI←EDLSI;
EDPX1: EDLXV←(EDLXV-1 IF EDLXV>0 ELSE EDLXV+1);
       EDCI(); EDLST(-1); RETURN;



       PROGRAM EDCI;
       INCLUDE EDIT';

*  SETS UP INTERVAL E1-E2 USING ECLTN,ECLSI
*  AND NUMBER OF LINES IN EDLXV.  INTERVAL IS ADJUSTED TO FIRST
*  OR LAST IB BOUNDARY IF REQUEST GOES BEYOND.

FUNCTION EDCI();
        EDLSI←ECLSI; EDLTN←ECLTN;
        IF EDLXV>0 DO;
           E1TN←ECLTN; E1SI←ECLSI;
           EDISP(EDLXV,1//EDCI1);
EDCI1:     E2TN←EDLTN; E2SI←EDLSI;
        ELSE DO;
           E2TN←ECLTN; E2SI←ECLSI;
           EDISP(EDLXV,1//EDCI2);
EDCI2:     E1TN←EDLTN; E1SI←EDLSI;
        ENDIF;
        RETURN;



       PROGRAM EDGNP;
       INCLUDE EDIT';

* GET VALUE FOR NEXT AND PREVIOUS COMMANDS.
       DI EDGNPT;

FUNCTION EDGNP(), FRETURN;
       EDGNPT←EDLXV←0;
       SDCOPY(EDLIST,CSTR);
       IF (EDLXCH←GCI(EDLIST//RETN))='-' DO;
          EDGNPT←EDLXCH;
          GOTO EDGN1;
       ELSEIF EDLXCH='+' DO;
          GOTO EDGN1;
       ENDIF;
       EDLIST$SR ← INCDES(EDLIST$SR, -1);
EDGN1: EDNUM(//FRETN);
       EDLXV←-EDLXV IF EDGNPT='-';
       SDCOPY(CSTR,EDLIST);
       RETN;



       PROGRAM EDMOD;
       INCLUDE EDIT', DBCOM;

* SCANS FROM EMODES STRING AND SETS MODES ACCORDINGLY.
* FRETN IF NO MODES OR NON-VALID MODE ENCOUNTERED, OTHERWISE
* RETN. IF EDMP=1 THEN SET TEMPORARY MODES, IF EDMP=0
* THEN SET PERMANENT MODES.
       DECLARE INTEGER EDMX1;

STRING FUNCTION EDMOD(STRING EMODES,INTEGER EDMP), FRETURN;
       EDMX1←1;
       EDMP←7*EDMP;
EDM1:  GOTO EDM1 IF(EDLXCH←GCI(EMODES//FRETN))=' '; GOTO EDM3;
EDM2:  GOTO EDM2 IF(EDLXCH←GCI(EMODES//EDM5))=' ';
EDM3:  IF EDLXCH='N' DO; EDMX1←0;
       ELSEIF EDLXCH='A' DO; MODES[0+EDMP]←EDMX1;
       ELSEIF EDLXCH='B' DO; MODES[1+EDMP]←EDMX1;
       ELSEIF EDLXCH='C' DO; MODES[2+EDMP]←EDMX1;
       ELSEIF EDLXCH='I' DO; MODES[3+EDMP]←EDMX1;
       ELSEIF EDLXCH>='0' AND EDLXCH<='9' DO;
          EMODES$SR ← INCDES(EMODES$SR,-1);
          EDNUM(//FRETN);
          MODES[4+EDMP]←EDLXV;
       ELSE DO; FRETN;
       ENDIF;
EDM4:  GOTO EDM2;
EDM5:  RETN EMODES;



       END;
       COMMON PMAC';
       INCLUDE COMM,STDEC,KTDEC,STST,PSTO;

**************
*    SPL     *
* STATEMENT  *
* SEQUENCING *
*  ROUTINES  *
**************




* WORKING VARIABLES
       DI T,I;
       DP PAGPTR;

* MACRO TO MOVE ISD'S
       DM MISD(X,Y)←BCOPY(Y,X,LISD);

* MINIMUM TOKEN REQUIRING SPECIAL ACTION BY GUIT
       DI GTFMIN;

* STATIC STORAGE FOR PMAC
       DM DISD(X,Y,RP,WP,MA)←DECLARE INTEGER Y←REF X[0],
   RP=X[FDISP(ISDRP)],WP=X[FDISP(ISDWP)],
   MA=X[FDISP(ISDMA)];
       DFA CISD[LISD];* CURRENT INPUT STREAM DESCRIPTOR
       DISD(CISD,CISA,CISDRP,CISDWP,CISDMA);
       DFA MCD[LISD];* MACRO CALL DESCRIPTOR
       DISD(MCD,MCA,MCNARGS,MCARGA,MCFLAG);
       DFA MCAISD[LISD];* MACRO ARGUMENT DESCRIPTOR
       DISD(MCAISD,MCAISA,MCAIRP,MCAIWP,MCAXXX);
       DFA MDISD[LISD];* MACRO DEFINITION DESCRIPTOR
       DISD(MDISD,MDISA,MDIWP,MDIEP,MDXXX);
       DFA MFD[LISD];* MACRO SKELETON DESCRIPTOR
       DISD(MFD,MFA,MFAIRP,MFAIWP,MFXXX);
       DI TOPISDS;* POINTER TO TOP OF ISD STACK
       DI MCNAME;* NAME OF MACRO BEING CALLED, OR 0

* ISD STACK
       DQ NISDS←20;
       DA ISDS[NISDS*LISD];
       DP ISDSTK←@ISDS[0],EISDS←ISDSTK+NISDS*LISD;

* IN ORDER TO AVOID UNPACKING THE ENTIRE SOURCE STATEMENT
* AT ONE TIME, THERE IS A FAIRLY INGENIOUS SCHEME FOR OBTAINING
* SOURCE TOKENS ON THE FLY.  THE 'GETTOKEN' FUNCTION COLLECTS THE
* NEXT TOKEN AND PUTS IT IN NXTSYM.  IT THEN RETURNS THE OLD
* CONTENTS OF NXTSYM AND ALSO LEAVES IT IN THISYM.  THIS OPERATION
* MAY TRIGGER A SIZABLE AMOUNT OF PROCESSING IF NXTSYM TURNS OUT
* TO BE A MACRO CALL OR ARGUMENT.  IN THIS CASE, OF COURSE,
* IT IS DEALT WITH IMMEDIATELY AND NEVER SEEN IN NXTSYM BY THE
* PARSER ITSELF
***      DI THISYM,NXTSYM,PREVSYM;

* THERE IS A SYSTEMATIC PROCEDURE FOR RECORDING THE POSITION IN THE
* CURRENT INPUT STREAM.  THIS IS DONE BY MEANS OF AN INPUT STREAM
* DESCRIPTOR (ISD) WHICH CONSISTS OF
*        A HALF-WORD ADDRESS FOR THE TOKEN JUST READ,
*           RELATIVE TO THE SYMBOL TABLE AREA (ICST)
*        A HALF-WORD ADDRESS FOR THE LAST TOKEN OF THE PPT
*           (THESE ARE CHARACTER DESCRIPTORS WITH BYTE SIZE=12)
*        THE ADDRESS OF THE MCD FOR THE CURRENT MACRO

* THERE IS A STACK OF ISD'S WHICH IS PUSHED DOWN WHENEVER A MACRO OR
* A MACRO ARGUMENT IS ENCOUNTERED, AND POPPED UP WHEN THE TOKEN
* COUNT OF THE CURRENT ISD RUNS OUT. AN ATTEMPT TO POP UP AN EMPTY
* STACK SIMPLY PRODUCES A STREAM OF REPETITIONS OF THE LAST TOKEN
* IN THE LAST ISD.
* AN ENTRY ON THIS STACK, BESIDES BEING AN ISD, MAY BE A MACRO CALL
* DESCRIPTOR (MCD).  THIS HAS
*        -1 (TO DISTINGUISH IT FROM OTHER ISD'S) IN ISDMA
*        THE STACK ADDRESS OF THE FIRST ARGUMENT IN ISDWP (MCDAA)
*        THE NUMBER OF ARGUMENTS IN ISDRP (MCDNA)

* WHEN A MACRO IS CALLED, ISD'S FOR ITS ACTUAL ARGUMENTS ARE PUSHED
* SUCCESSIVELY ONTO THE STACK, FOLLOWED BY THE ISD FOR THE THEN
* CURRENT INPUT AND FINALLY BY THE MCD FOR THE MACRO ITSELF.
* THE POP STACK OPERATION CHECKS TO SEE WHETHER IT IS POPPING A MCD
* AND TAKES APPROPRIATE ACTION
* IN ORDER TO MAKE THIS SCHEME WORK, IT IS NECESSARY TO FORBID POPPING
* THE STACK WHILE ACTUAL ARGUMENTS ARE BEING COLL CTED.  SINCE NO EXPANSION
* IS DONE DURING THIS PROCESS (SO THAT ONLY THE ISD'S FOR THE
* ARGUMENTS NEED TO BE SAVED) THIS SIMPLY MEANS THAT A MACRO BODY
* CANNOT START TO CALL ANOTHER MACRO WITHOUT FINISHING THE CALL.
* THIS RULE IS ENFORCED BY
***      DI MCNAME;
* WHICH IS ZERO EXCEPT WHEN ACTUAL ARGUMENTS ARE BEING COLLECTED.
* THEN IT IS THE MACRO NAME.

* THE ISD STACK HAS A POINTER TO ITS FIRST UNUSED ENTRY
***      DI TOPISDS;
* AND A POINTER TO ITS END: EISDS (ABOVE)

* THERE IS A LIMIT OF 32 MACRO ARGUMENTS
         DQ MAXNFA←32;
         DQ MAMLIM←7777B-MAXNFA;

* A MACRO DEFINITION (THE THING POINTED TO BY THE VALUE CELL IN THE
* SYMBOL TABLE ENTRY FOR A MACRO) HAS THE SAME FORM AS A STATEMENT.
* THE PTLCODE FIELD IS USED TO HOLD THE NUMBER OF FORMAL ARGUMENTS+1.
* 0 IN THIS FIELD MEANS THAT A ( AFTER A CALL OF THE MACRO SHOULD
* NOT BE INTERPRETED AS INTRODUCING ACTUAL ARGUMENTS.


* GET UNINTERPRETED TOKEN (NO CHECK FOR MACRO CALL OR ARGUMENT)


       PROGRAM NGUIT;
       INCLUDE PMAC';

         DI NSYM;
         DP ICSA;

         FUNCTION NGUIT();
GUITLP:  HWINC(CISA,ENDISD);
         ICSA←@ICST[1];
         RETURN (NXTSYM←NSYM) IF (NSYM←HWGET(ICSA,CISDRP))<GTFMIN
          ELSE GOTO RETGUIT;
* EXHAUSTED CURRENT ISD.  ERROR IF COLLECTING MACRO ARGUMENTS
ENDISD:     IF MCNAME#0 DO;
               PCERR(16);
            ELSEIF TOPISDS=ISDSTK DO;
* STACK IS EMPTY. MOVE TO NEXT PPT OF SOURCE
NEXTPPT:       IF (CESSI←SNEXT(CESSI))=0 DO;
* RAN OFF END OF PPT. ERROR UNLESS JUST ENTERED PARSER
                  PCERR(15) IF NXTSYM#BEGCHT;
                  RETURN NXTSYM;
               ELSE DO;
* DID NOT. SETUP CISD TO KEEP PROCESSING ON NEW PPT
                  SETCISD(CURSI←CESSI,0);
               ENDIF;
            ELSE DO;
* POP STACK
               TOPISDS←TOPISDS-LISD; MISD(TOPISDS,CISA);
* CHECK FOR END OF MACRO CALL
               IF CISDMA=-1 DO;
                  T←TOPISDS-LISD;
                  TOPISDS←CISA.MCDAA; MISD(T,CISA);
               ENDIF;
               IDPTR←@CISDRP IF TOPISDS=ISDSTK;
* OTHERWISE LOOP
            ENDIF;
         GOTO GUITLP;
* NO FUNNIES
RETGUIT:    IF (NSYM A' 7400B)=6000B DO;* OPERATOR TOKEN
               NSYM←NSYM A' 7477B;* REMOVE BLANK FLAGS
            ELSEIF NSYM>=TNBMIN AND NSYM<=TNBMAX DO;
* FILTER OUT BLANK TOKENS
               GOTO GUITLP;
            ELSEIF NSYM>=KTMIN AND NSYM<=KTMAX DO;
* LONG CONSTANT
               NSYM←LONGCON(NSYM);
            ELSEIF NSYM>=TNCMIN AND NSYM<=TNCMAX DO;
* SMALL INTEGER
               NSYM←SHORTCON(NSYM);
            ELSEIF NSYM=TCOMMENT DO;
* FILTER OUT COMMENTS.
               HWINC(CISA,ENDISD);
               NSYM←HWGET(ICSA,CISDRP);
               CISDRP←INCHW(CISDRP,(NSYM*2+5)/3-(HWPOS(CISDRP) AA 1));
               GOTO GUITLP;
            ENDIF;
            RETURN NXTSYM←NSYM;

* VERSION OF GUIT TO PRINT TOKENS AS THEY ARE READ


       PROGRAM PGUIT;
       INCLUDE PMAC';

         FUNCTION PGUIT();
         FIOUT(NGUIT(),-1,0,8);
         COUT('&/', -1);
         RETURN NXTSYM;

* GET TOKEN, INCLUDING HANDLING OF MACROS


       PROGRAM GETTOKEN;
       INCLUDE PMAC';

* TWO ISDS ARE REQUIRED DURING A MACRO CALL, ONE TO HOLD THE
* MACRO CALL DESCRIPTOR UNDER CONSTRUCTION,
* AND THE OTHER TO HOLD THE ISDS FOR THE ARGUMENTS AS THEY ARE
* COLLECTED
         DI MARGNO;
         DP MACTP,MACSP;

FUNCTION GETTOKEN();
         PREVSYM←THISYM;
         THISYM←NXTSYM;
GTKLOOP: GUIT() IF NXTSYM#TSEMI;
         IF NXTSYM<TNLIM AND NXTSYM>0 AND (MACTP.TKTYPE=TTMAC WHERE
          SSPTR(NXTSYM:MACTP,MACSP)) DO;
* MACRO CALL
            MACALL(NXTSYM,MACSP.SYVAL);
PUSH:       IDPTR←ISDSTK+FDISP(ISDRP);
            GOTO GTKLOOP;
         ELSEIF NXTSYM>=MAMLIM DO;
* MACRO ARGUMENT.
            MARGNO←NXTSYM-MAMLIM;
* PUSH OLD ISD AND GET NEW ONE
            PUSHIS(CISA);
            MISD(CISDMA.MCDAA+MARGNO*LISD,CISA);
* CHARGE ON
            GOTO PUSH;
         ELSE DO;
            RETURN THISYM;
         ENDIF;

* ENTRY TO LEAVE THISYM, PREVSYM ALONE
         ENTRY GETNEXT();
         GOTO GTKLOOP;


* PUSH ISDSTK FROM ISD ADDRESSED


       PROGRAM PUSHIS;
       INCLUDE PMAC';

FUNCTION PUSHIS(PPISA);
         PCERR(8) IF TOPISDS>EISDS-LISD;
         MISD(PPISA,TOPISDS);
         TOPISDS←TOPISDS+LISD;
         RETURN;

* INITIALIZE STATEMENT SCANNING MACHINERY


       PROGRAM ISCAN;
       INCLUDE PMAC';
       DECLARE EXTERNAL PGUIT,NGUIT;

FUNCTION ISCAN();
       MCNAME←CISDMA←0;
       TOPISDS←ISDSTK;
       IDPTR←@CISDRP;
       GUIT←PGUIT IF PPTFLAG ELSE GUIT←NGUIT;
       GTFMIN←TFMIN;
       RETURN;

* SET UP CISD.  CALLED BY PARSE AT ENTRY,
* BY GUIT WHEN CROSSING PPT BOUNDARIES, AND FOR MACRO CALLS


       PROGRAM SETCISD;
       INCLUDE PMAC';

         DI SCDTC;
         DP SCDTP,SCDA;

FUNCTION SETCISD(SCDSI,SCDTI);
       SCDA←CISA;
ENTRY SETISD(SCDA,SCDSI,SCDTI);
         SCDTP←STPTR(SCDSI);
         SCDTC←SCDTP.PTSIZE*2+SCDTP.PTONT-2;
         T←SCDSI*2-2;
         SCDA.ISDRP←HWPTR(T+SCDTI+(PTTO-1));
         SCDA.ISDWP←HWPTR(T+SCDTC);
         RETURN SCDTC;

* SET UP TOKEN ID FOR TREE GENERATOR


       PROGRAM SETID;
       INCLUDE PMAC';

       DI IDX;

FUNCTION SETID();
         IDX←$IDPTR;
FUNCTION SETIDN(IDX);
         NODEID←IDX;
         NODE←0;
         RETURN;

* SCAN TO END OF STATEMENT. LEAVE CURTI UNCHANGED


       PROGRAM ESSCAN;
       INCLUDE PMAC';

         DI OCURID,OCURSI;

FUNCTION ESSCAN();
         OCURSI←CURSI;
         OCURID←$IDPTR;
         MCNAME←0;
         WHILE NXTSYM#TSEMI DO;
            CISDRP←CISDWP IF TOPISDS#ISDSTK;
            GUIT();
         ENDFOR;
         NPCHK();
         CISDRP←OCURID;
         CURSI←OCURSI;
         RETURN;

* CHECK FOR TRANSITION TO NEW PPT AT END OF PARSING


       PROGRAM NPCHK;
       INCLUDE PMAC';

FUNCTION NPCHK();
       IF CISDRP#CISDWP DO;
          CESTI←HWPOS(CISDRP)-2*CESSI-(PTTO-3);
       ELSE DO;
          CESTI←0;
          PAGPTR←STPTR(CESSI);
          SETCISD(CESSI,0) IF CESSI←PAGPTR.PTFP;
       ENDIF;
       RETURN;

* SET ERROR CHARACTER (FOR PP ERRORS)


       PROGRAM SETEC;
       INCLUDE PMAC';

FUNCTION SETEC(SECC);
         IDPTR.ISDRP←IDPTR.ISDWP←HWPTR(SECC+2*ICLST);
         RETURN;




       PROGRAM CONVID;
       INCLUDE PMAC';

         DI TKNNO,TKNSI,TKNIN;

FUNCTION CONVID(TKNID), FRETURN;
         TKNNO←HWPOS(TKNID)+1;
         RETN (CFSSI,2*ICLST-TKNNO) IF TKNNO>2*ICLST;* SEE SETEC (ABOVE)
         FOR TKNSI←CFSSI, SNEXT(TKNSI) WHILE TKNSI DO;
            PAGPTR←STPTR(TKNSI);
            TKNIN←2*TKNSI+PTTO;
            RETN (TKNSI,TKNNO-TKNIN) IF TKNNO>=TKNIN AND TKNNO<=
             2*TKNSI+LASTHW(PAGPTR)+1;
         ENDFOR;
         FRETN;

       PROGRAM MACDEF;
       INCLUDE PMAC';

* DEFINE MACRO.  COLLECT TEMPLATE, THEN BODY
       DI EMFAT,MDNAME;
       DA MFAT[MAXNFA],MBB[FRMASK(PTSIZE)+1];
       DP MBBUF;
*STUFF TO COPY CONSTANTS INTO THE MACRO DEFINITION
       DI CONCS,CONTYPE,CONSIZE,MT,HWKNT;
       DM SHOVEIT←HWINC(MDISA,MBOVF);
       DM SHOVEIT2←HWPUT(MBBUF,MDIWP,NXTSYM);

FUNCTION MACDEF();
       NEXT;
       PCERR(7) IF (MDNAME←THISYM)>=TNLIM OR TDCHK(MDNAME)#0;
       EMFAT←0;
       MBBUF←@MBB[0];
       MDIWP←HWPTR(PTTO-1);
       MDIEP←HWPTR(FRMASK(PTSIZE)*2+1);
       THISYM←BEGCHT;
* COLLECT TEMPLATE AND FORMAL PARAMETER NAMES
MDLOOP: (THISYM←TLARR) IF NXTSYM=TLARR ELSE NEXT;
       IF THISYM<TNLIM DO;
           PCERR(7) IF PREVSYM<TNLIM;
           PCERR(9) IF EMFAT=MAXNFA;
           MFAT[EMFAT]←THISYM;
           EMFAT←EMFAT+1;
       ELSEIF THISYM=TSEMI DO;
           PCERR(7);
       ELSEIF THISYM=TLARR DO;
           MBBUF.PTLCODE←HWPOS(MDIWP)-4;
           GOTO GMBLP0;
       ENDIF;
       HWINC(MDISA,MBOVF);
       HWPUT(MBBUF,MDIWP,THISYM);
       GOTO MDLOOP;
* COLLECT MACRO BODY
GMBLP0: GTFMIN←TCOMMENT;*=7400B ALLOW ONLY OPERATORS, CONSTANTS, BLANKS
GMBLP: GUIT();
GMBLP1:IF (NXTSYM A' 7477B)=TSEMI AND
           (NXTSYM A' 7400B)=6000B DO;
           GOTO GMBLP2; ENDIF;
*      THE ABOVES FINISHES ON THE OPERATOR ';'
           IF NXTSYM<TNLIM DO;
               FOR I←0 TO EMFAT-1 DO;
                   NXTSYM←MAMLIM+I IF NXTSYM=MFAT[I];
               ENDFOR;
           ELSEIF (NXTSYM A' 7400B)=6000B DO;
               NXTSYM←NXTSYM A' 7477B;*REMOVE BLANK FLAGS
*          (2) OPERATOR TOKEN
           ELSEIF NXTSYM >=KTMIN AND NXTSYM<=KTMAX DO;
*          (3) LONG CONSTANTS, MUST FIND NUMBER OF BYTES TO COPY
               GTFMIN←10000B;* ACCEPT ALL TOKENS
               MT←NXTSYM$KTTYPE;
               CONCS← NXTSYM$KTCSIZE;
               SHOVEIT; SHOVEIT2;*STORE AWAY TOKEN
               IF (CONSIZE←NXTSYM$KTSIZE)=0 DO;
                   CONSIZE←GUIT();
                   SHOVEIT;SHOVEIT2;*EXTRA BYTE COUNT
               ENDIF;
               IF MT=KTSTR  OR MT=KTCHAR DO;
                   GUIT() IF ((HWPOS(CISDRP))AA 1)=0;*GET FROM FULLWORD
                   IF (HWPOS(MDIWP)AA 1)=0 DO;*GET TO FULLWORD
                       SHOVEIT;SHOVEIT2;*SKIP A SPACE
                   ENDIF;
               ENDIF;
               IF MT=KTSTR DO;
                   HWKNT←(CONSIZE*(8 IF CONCS ELSE 6)+11)/12;
               ELSEIF MT=KTCHAR DO;
                   HWKNT←1;
                   HWKNT←0 IF CONSIZE=0
                   ELSE HWKNT←2 IF CONSIZE+CONCS>2;
               ELSE DO;* MUST BE 4-BIT BYTES
                   HWKNT←(CONSIZE+2)/3;
               ENDIF;
*              NOW COLLECT
               FOR MT←1 TO HWKNT DO;
               GUIT();
               SHOVEIT;SHOVEIT2;
               ENDFOR;
               GTFMIN←TCOMMENT;
               GOTO GMBLP;
           ENDIF;
*          (4) OTHERS FALL THROUGH TO HERE, SHORT CONSTANTS AND
*          VARIABLE NAMES
           HWINC(MDISA,MBOVF);
           HWPUT(MBBUF,MDIWP,NXTSYM);
           GOTO GMBLP;
GMBLP2:
* COLLECTED ENTIRE BODY.  STORE AWAY
       T←HWPOS(MDIWP);
       MBBUF.PTSIZE←T/2+1;
       MBBUF.PTONT←T E' (PTTO-1);
       SDMAC(MDNAME,MBB);
       GTFMIN←TFMIN;
       RETURN;

MBOVF: PCERR(12);

       PROGRAM MACALL;
       INCLUDE PMAC';

* MACRO CALL.  COLLECT ACTUAL ARGUMENTS ACCORDING TO TEMPLATE
       DI MCPREV,MCTHIS,MAPARC;
       DP MCPTR,MICSA;
*STUF TO COPY CONSTANTS AS PART OF ARGUMENTS
       DI CONCS,CONTYPE,CONSIZE,MT,HWKNT;

FUNCTION MACALL(MACSYM,MACSI);
       MCNAME←MACSYM;
       SETISD(MFA,MACSI,0);
       MCPTR←STPTR(MACSI);
       MFAIWP←INCHW(MFAIRP,MCPTR.PTLCODE);
       MCPREV←BEGCHT;
       MCFLAG←-1;
       MCARGA←TOPISDS;
       MICSA←@ICST[1];
       GTFMIN←TNBMIN;*SHOVE IN OPERATORS, CONSTANTS
GMAL:  HWINC(MFA,ENDMCA);
       IF (MCTHIS←HWGET(MICSA,MFAIRP))<=TNLIM DO;
       ELSEIF MCPREV<=TNLIM DO;
           NPCHK() IF CISDRP=CISDWP;
           MISD(CISA,MCAISA);
           MAPARC←0;
IN:        NXTSYM←GUIT();
           NXTSYM←(NXTSYM A' 7477B) IF (NXTSYM A' 7400B)=6000B;
*          FIX UP OPERATORS
           GOTO OUT IF NXTSYM=MCTHIS AND MAPARC=0;
               IF NXTSYM=TLPAR OR NXTSYM=TLBRAK DO;
                   MAPARC←MAPARC+1;
               ELSEIF NXTSYM=TRPAR OR NXTSYM=TRBRAK DO;
                   PCERR(11) IF (MAPARC←MAPARC-1)<0;
               ELSEIF NXTSYM=TSEMI DO;
                   PCERR(10);
               ELSEIF NXTSYM>=KTMIN AND NXTSYM<=KTMAX DO;
*              LONG CONSTANTS, READ PAST THE RIGHT NUMBER
               GTFMIN←10000B;*ACCEPT EVERYTHING
               MT← NXTSYM$KTTYPE;
               CONCS←NXTSYM$KTCSIZE;
               IF (CONSIZE←NXTSYM$KTSIZE)=0 DO;
                   CONSIZE←GUIT();
               ENDIF;
               GUIT() IF (HWPOS(CISDRP)AA 1)=0 AND
                      (MT=KTSTR OR MT=KTCHAR);
               IF MT=KTSTR DO;
               HWKNT←(CONSIZE*(8 IF CONCS ELSE 6)+11)/12;
               ELSEIF MT=KTCHAR DO;
                   HWKNT←1;
                   HWKNT←0 IF CONSIZE =0
                   ELSE HWKNT←2 IF CONSIZE+CONCS>2;
               ELSE DO;* MUST BE 4-BIT BYTES
                   HWKNT←(CONSIZE+2)/3;
               ENDIF;
*              NOW STEP THROUGH
               FOR MT←1 TO HWKNT DO;
               GUIT();
               ENDFOR;
               GTFMIN←TNBMIN;
               ENDIF;
               GOTO IN;
OUT:       MCAIWP←INCHW(CISDRP,-1);
           PUSHIS(MCAISA);
       ELSE DO;
           PCERR(11) IF (GUIT() A' 7477B) #MCTHIS;*PURIFY OPERATORS
       ENDIF;
       MCPREV←MCTHIS;
       GOTO GMAL;
* END OF ARGUMENTS.  PUSH OLD ISD
ENDMCA:GTFMIN←TFMIN;
       PUSHIS(CISA);
* AND SET UP NEW ONE FOR MACRO BODY
       SETCISD(MACSI,0);
       CISDRP←MFAIWP;
       CISDMA←TOPISDS;
* PUSH MCD AND PROCEED
       PUSHIS(MCA);
       MCNAME←0;
       RETURN;

       COMMON CONV'COMMON;
       INCLUDE SPAR,SCOPS;

* BUFFER TO HOLD CONVERTED CONSTANT
         DA CONBUF[4];
         DI CONVALUE=CONBUF[0],REAL CONRVAL=CONBUF[0],CONIVAL=CONBUF[2];
         DI CONCS=CONBUF[1],CONNC=CONBUF[2];
* SIZE OF CONSTANT IN BYTES
         DI CONSIZE;
* COUNT-DOWN FOR 4-BIT BYTES IN 12-BIT TOKEN
         DI BCOUNT;
* BUFFER FOR TOKEN BEING UNPACKED
         DI BBUFFER;


       PROGRAM CONV'AUX;
       INCLUDE CONV'COMMON,PMAC';

* GET 4-BIT BYTE FROM TOKEN STRING.  FAIL IF COUNT EXHAUSTED

FUNCTION GET4BIT(), FRETURN;
         FRETURN IF (CONSIZE←CONSIZE-1)<0;
         IF (BCOUNT←BCOUNT-1)<0 DO;
            BBUFFER←GUIT() LSH 8;
            BCOUNT←2;
         ENDIF;
         RETURN ((BBUFFER←BBUFFER LSH 4) RSH 20);

* CONVERT SMALL INTEGER

FUNCTION SHORTCON(INTOKEN);
       CONVALUE←INTOKEN-TNCZRO;
       RETURN CONTK(TTINT);

* CONSTRUCT CONSTANT TOKEN FOR PARSER

FUNCTION CONTK(TYP);
       RETURN -TYP;

* MAKE CONSTANT NODE
FUNCTION MCONNODE(CNTYPE);
       CONBUF[3]←TCN0(OPNIL) IF -CNTYPE=TTSTR;
       RETURN TCC(-CNTYPE,@CONBUF[0]);

       PROGRAM LONGCON;
       INCLUDE CONV'COMMON,PMAC';

* CONVERT LONG CONSTANT AND RETURN TOKEN
         DI CONTYPE,CONBIN,CONEXP,CONNFRAC,CONXSIGN;
* POWER OF 10 TABLES
         DECLARE REAL ARRAY CONFAC,
          CONPOS[9]←(1E1,1E2,1E4,1E8,1E16,1E32,1E64,1E128,1E256),
          CONNEG[9]←(1E-1,1E-2,1E-4,1E-8,1E-16,1E-32,1E-64,1E-128,1E-256);
* CONVERT KTTYPE TO ORDINARY TYPE
       DA TKTTAB[6]←(
        TTINT,TTREAL,TTDBL,TTCPLX,TTSTR,TTINT);
        DECLARE INTEGER T1;

FUNCTION LONGCON(CONTOKEN);
         GTFMIN←10000B;* ACCEPT ALL TOKENS
         T←CONTOKEN$KTTYPE;
         CONTYPE←TKTTAB[T];
         CONSIZE←GUIT() IF (CONSIZE←CONTOKEN$KTSIZE)=0;
         CONCS←CONTOKEN$KTCSIZE;
         IF T=KTSTR DO;
* STRING.  JUST STORE SI AND LENGTH
            T1 ← 0;
            (GUIT() &T1←1) IF ((T←HWPOS(CISDRP)) AA 1)=0;
            CONVALUE←(T+3)/2 +T1;
            CONNC←CONSIZE;
            T←(CONSIZE*(8 IF CONCS ELSE 6)+11)/12;
            CISDRP←INCHW(CISDRP,T);
         ELSEIF T=KTCHAR DO;
            GUIT() IF (HWPOS(CISDRP) A' 1)=0;* CHAR CONSTANTS ALSO
*                                           MUST BE ON LINE BOUNDARY
* CHARACTER.  PICK UP CHARACTERS AND FORM INTO WORD
            CONVALUE←(GUIT() LSH 12 IF CONSIZE ELSE 0);
            CONVALUE←CONVALUE+GUIT() IF CONSIZE+CONCS>2;
            CONVALUE←CONVALUE RSH(((4-CONCS)-CONSIZE)*
                              (8 IF CONCS ELSE 6));
         ELSEIF T=KTINT DO;
* INTEGER.  CONVERT TO BINARY
            BCOUNT←0;
            CONVALUE←CONBIN←0;
INTLOOP:    T←GET4BIT(//ENDINT);
            IF T<10 DO;
               CONVALUE←CONVALUE*10+T;
               CONBIN←CONBIN LSH 3+T;
               GOTO INTLOOP;
            ELSEIF T=KCB DO;
               CONVALUE←CONBIN;
               CONVALUE←CONBIN LSH (3*GET4BIT(//ENDINT));
            ELSEIF T=KCD DO;
               CONVALUE←CONVALUE*10 FOR T←GET4BIT(//ENDINT)-1 BY -1 TO 0;
            ENDIF;
ENDINT:
         ELSE DO;
* REAL, DOUBLE, OR IMAGINARY.  ACCUMULATE INTEGER AND FRACTION PARTS
            BCOUNT←0;
            CONEXP←CONNFRAC←CONXSIGN←0;
            CONRVAL←0.0;
            CONRVAL←CONRVAL*10.0+FLOAT(T) WHILE (T←GET4BIT(//ENDREAL))<10;
            IF T=KCDOT DO;
               (CONRVAL←CONRVAL*10.0+FLOAT(T) & CONNFRAC←CONNFRAC+1)
              WHILE (T←GET4BIT(//ENDREAL))<10;
            ENDIF;
* T MUST BE 'E'.  ACCUMULATE EXPONENT
            CONXSIGN←-1 IF (T←GET4BIT(//FTLERR))=KCMINUS
           ELSE CONEXP←T IF T#KCPLUS;
            CONEXP←CONEXP*10+T WHILE (T←GET4BIT(//ENDREAL))<10;
* REAL CONVERSION FAILURE
            PCERR(250);
* ALL DONE.  MULTIPLY IN EXPONENT
ENDREAL:    CONEXP←(-CONEXP IF CONXSIGN<0 ELSE CONEXP)-CONNFRAC;
* EXPONENT OUT OF RANGE ?
            PCERR(251) IF CONEXP<-308 OR CONEXP>308;
            IF CONEXP>=0 DO;
               CONFAC←REAL'ARRAY'FIXER(CONPOS);
            ELSE DO;
               CONEXP←-CONEXP;
               CONFAC←REAL'ARRAY'FIXER(CONNEG);
            ENDIF;
            WHILE CONEXP DO;
               I←23-FLLO(CONEXP);
               CONRVAL←CONRVAL*CONFAC[I];
               CONEXP←CONEXP-1 LSH I;
            ENDFOR;
            IF CONTYPE = TTCPLX DO;
               CONIVAL←CONRVAL;
               CONRVAL←0.0;
            ENDIF;
         ENDIF;
         GTFMIN←TFMIN;* FILTER COMMENTS ETC.
         RETURN CONTK(CONTYPE);
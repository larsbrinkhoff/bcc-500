       COMMON SYSCALLS;

* MCALL DECLARATIONS


* CALLS TO MANIPULATE MIBS AND SIBS
       INTEGER MONITOR CREATE'MIB ← 190;
       UNKNOWN MONITOR READ'MIBOB'INDEX ← 0;
       UNKNOWN MONITOR READ'MIBOB'NAME ← 1;
       UNKNOWN MONITOR SET'MIBOB'NAME ← 2;
       UNKNOWN MONITOR SET'MIBOB'ACCESS ← 3;
       UNKNOWN MONITOR SET'LOCK'LIST ← 4;
       UNKNOWN MONITOR DELETE'MIBOB ← 5;
       INTEGER MONITOR CREATE'MIBOB ← 6;
       UNKNOWN MONITOR SET'MIB'ACCESS ← 10;
       INTEGER MONITOR READ'MIB'ACCESS ← 11;
       UNKNOWN MONITOR SET'MIBOB'VALUE ← 12;
       INTEGER MONITOR COPY'MIBOB ← 14;* UNIMPLEMENTED
       UNKNOWN MONITOR SET'NO'CHARGE ← 15;*** ???
       INTEGER MONITOR READ'MIB'SPACE ← 16;
       UNKNOWN MONITOR SET'FILE'LOCK ← 18;*?* UNIMPLEMENTED
       UNKNOWN MONITOR SET'DURABILITY ← 28;*** ???

* OFT CALLS
       INTEGER MONITOR MOPEN'FILE ← 19;
       UNKNOWN MONITOR MREAD'OFT ← 20;
       UNKNOWN MONITOR SET'OFT'AL ← 21;
       INTEGER MONITOR MSET'OFT'CL ← 22;
       UNKNOWN MONITOR SET'FILE'LENGTH ← 23;* IMPROVE THIS FOR UTS
       INTEGER MONITOR CR'FILE'PAGE ← 24;
       INTEGER MONITOR DEL'FILE'PAGE ← 25;
       INTEGER MONITOR NEXT'FILE'PAGE ← 26;
       UNKNOWN MONITOR MOVE'PAGE'PMT ← 27;

* PMT CALLS
       INTEGER MONITOR ACQUIRE'PMT ← 50;
       UNKNOWN MONITOR NEW'PMT'PAGE ← 51;
       UNKNOWN MONITOR CLEAR'PMT ← 53;
       UNKNOWN MONITOR DELETE'PMT ← 54;
       UNKNOWN MONITOR SET'PMT'AL ← 55;
       UNKNOWN MONITOR SET'PMT'CL ← 56;
       UNKNOWN MONITOR SET'PMT'RO ← 57;
       UNKNOWN MONITOR READ'PMT ← 58;

* WORKING SET CALLS
       UNKNOWN MONITOR PUT'PAGE'DWS ← 65;
       UNKNOWN MONITOR PUT'PAGE'CWS ← 66;
       INTEGER MONITOR DEL'PAGE'DWS ← 67;
       INTEGER MONITOR DEL'PAGE'CWS ← 68;
       INTEGER MONITOR READ'LWS ← 70;
       UNKNOWN MONITOR SET'LWS ← 71;

* SPT CALLS
       INTEGER MONITOR MCREATE'SP ← 90;
       UNKNOWN MONITOR MDESTROY'SP ← 91;
       UNKNOWN MONITOR MREAD'SPT ← 95;
       UNKNOWN MONITOR READ'SPCS ← 96;
       INTEGER MONITOR MRD'SPT'FIELD ← 97;
       UNKNOWN MONITOR MST'SPT'FIELD ← 98;
       UNKNOWN MONITOR READ'MAP ← 99;
       UNKNOWN MONITOR SET'MAP ← 100;
       INTEGER MONITOR READ'MAP'BYTE ← 101;
       UNKNOWN MONITOR SET'MAP'BYTE ← 102;
       INTEGER MONITOR READ'SPS'PARAM ← 106;

* SPCS CALLS
       UNKNOWN MONITOR SP'CALL ← 111;
       UNKNOWN MONITOR SP'JUMP ← 112;
       UNKNOWN MONITOR SP'TRAP ← 113;
       UNKNOWN MONITOR TRAP'RETURN ← 114;
       UNKNOWN MONITOR SP'BRANCH ← 115;
       UNKNOWN MONITOR SP'RETURN ← 116;
       UNKNOWN MONITOR JUMP'RETURN ← 117;
       UNKNOWN MONITOR MARK'CALL ← 118;
       UNKNOWN MONITOR DELETE'CALL ← 119;
       UNKNOWN MONITOR MODIFY'CALL ← 120;

* PROCESS CALLS
       INTEGER MONITOR COPY'PMT'PROC ← 130;
       INTEGER MONITOR ACTIVATE'PROC ← 132;
       UNKNOWN MONITOR TRANSFER'TERM ← 133;
       UNKNOWN MONITOR MAKE'DORMANT ← 134;
       UNKNOWN MONITOR INIT'PROC'PAGE ← 135;
       UNKNOWN MONITOR INIT'PROC'MAP ← 136;
       UNKNOWN MONITOR INIT'SPT ← 137;
       INTEGER MONITOR READ'PROC'PARAM ← 211;

* IWS CALLS
       UNKNOWN MONITOR SET'PROC'INT ← 163;
       UNKNOWN MONITOR QUIT'BLOCK ← 164;
       INTEGER MONITOR GET'INT'NO ← 165;
       UNKNOWN MONITOR READ'ICT ← 166;
       UNKNOWN MONITOR ALLOW'INTS ← 168;
       UNKNOWN MONITOR REFUSE'INTS ← 169;
       UNKNOWN MONITOR BLOCK ← 170;
       UNKNOWN MONITOR SET'ICT ← 172;
       UNKNOWN MONITOR SET'ICT'CL ← 173;
       INTEGER MONITOR ACQUIRE'ICT ← 174;

* CHIO CALLS
       UNKNOWN MONITOR SET'LINE'FIELD ← 180;
       UNKNOWN MONITOR READ'LINE'TABLE ← 181;
       UNKNOWN MONITOR READ'STRING'BRK ← 182;
       UNKNOWN MONITOR WRITE'STRING ← 183;

* MISCELLANEOUS
       LONG MONITOR  READ'CLOCK ← 210;

* UCALL DECLARATIONS


* MISCELLANEOUS UCALLS
       UNKNOWN UTILITY BREAK'POINT ← 0;*             UCALL FOR DEBUGGING PROGRAMS
       STRING UTILITY ERRORMSG ← 1;*                RETURN SYSTEM ERROR MESSAGE
       STRING UTILITY GET'PARAM ← 2;*               STRIP PARAMETER FROM STRING
       STRING UTILITY GET'COM'LINE ← 3;*            GET CURRENT COMMAND LINE FROM UTS
       INTEGER UTILITY ABRV'LKP ← 4;*                LOOK UP ABBREVIATED NAME IN STARY
       INTEGER UTILITY CON'ABRV'LKP ← 5;*            CONTINUE SAME IN NEW STARY

* FILE SYSTEM CALLS
       UNKNOWN UTILITY NAME'SEARCH ← 10;*            CONVERT FILE ST TO UTS NAME
       UNKNOWN UTILITY SPECIAL'SEARCH ← 11;*         VARIATION OF ABOVE
       INTEGER UTILITY CONV'NAME ← 12;*              CONVERT FROM UTS TO MON FILE NAME
       LONG UTILITY SPREAD'NAME ← 13;*            SPLIT FILE NAME STRING INTO COMP.
       UNKNOWN UTILITY READ'MIBOB'VALUE ← 14;*       READ 'VALUE' OF MIB OBJECT
       UNKNOWN UTILITY DELETE'FILE ← 15;*            DELETE FILE AND CONTENTS
       INTEGER UTILITY OPEN'FILE ← 16;*              OPEN FILE W/WO LOCKING
       UNKNOWN UTILITY CLOSE'FILE ← 17;*             CLOSE AND UNLOCK FILE
       UNKNOWN UTILITY READ'OFT ← 18;*               READ OFT
       INTEGER UTILITY READ'OFT'FIELD ← 19;*         READ OFT FIELD
       UNKNOWN UTILITY SET'OFT'CL ← 20;*             SET OFT CONTROL LOCK
       INTEGER UTILITY CONV'KEY ← 21;*               CONVERT DEFAULT ACCESS KEY

* EXTENDED SPS CALLS
       INTEGER UTILITY CREATE'SSP ← 30;*             CREATE SUBSIDIARY SUB-PROCESS
       INTEGER UTILITY CREATE'PSP ← 31;*             CREATE PARALLEL SUB-PROCESS
       UNKNOWN UTILITY ATTACH ← 32;*                 ATTACH PI FILE TO SUB-PROCESS
       UNKNOWN UTILITY DESTROY'SP ← 33;*             DESTROY SUB-PROCESSES
       UNKNOWN UTILITY READ'SPT ← 34;*               READ SPT
       INTEGER UTILITY READ'SPT'FIELD ← 35;*         READ SPT FIELD
       UNKNOWN UTILITY SET'SPT'FIELD ← 36;*          SET SPT FIELD
       STRING UTILITY READ'SPNAME ← 37;*            READ SUB-PROC NAME
       UNKNOWN UTILITY SET'SPNAME ← 38;*             SET SUB-PROC NAME
       INTEGER UTILITY SPNAME'SEARCH ←39;*           LOOK UP SP NAME

* CIOS MANIPULATION
       INTEGER UTILITY CREATE'CIOS ← 40;*            CREATE CONTROL I/O STREAM
       INTEGER UTILITY READ'CIOS'FIELD ← 41;*        READ CIOS FIELD
       UNKNOWN UTILITY SET'CIOS'FIELD ← 42;*         SET (SOME) CIOS FIELDS
       UNKNOWN UTILITY SET'CIOS'INPUT ← 43;*         SET UP FOR INPUT
       UNKNOWN UTILITY SET'CIOS'OUTPUT ← 44;*        SET UP FOR OUTPUT

* CIOS INPUT/OUTPUT
       UNKNOWN UTILITY PRINT'STRING ← 45;*           WRITE STRING ON CIOS
       UNKNOWN UTILITY PRINT'CHAR ← 46;*             WRITE (= BUFFER) CHAR ON CIOS
       UNKNOWN UTILITY START'OUTPUT ← 47;*           DUMP OUTPUT BUFFER
       STRING UTILITY READ'LINE ← 48;*              READ NEXT INPUT LINE
       STRING UTILITY EDIT'LINE ← 49;*              EDIT CURRENT LINE
       CHARACTER UTILITY READ'CHAR ← 50;*              READ NEXT CHARACTER
       UNKNOWN UTILITY BLOCK'OB'EMPTY ← 51;*         WAIT UNTIL OUT BUFFER IS EMPTY

* USER, ACCOUNT, AND GROUP PROFILES
       STRING UTILITY READ'UP'ITEM ← 60;*           READ ITEM FROM USER PROFILE
       STRING UTILITY READ'UP'NAMES ← 61;*          READ NAMES OF UP ITEMS
       UNKNOWN UTILITY SET'UP'ITEM ← 62;*            SET (CREATE) VALUE OF UP ITEM
       UNKNOWN UTILITY SET'UP'ACCESS ← 63;*          SET ACCESS TO UP ITEM
       LONG UTILITY FIND'MIB ← 64;*               CONVERT USER NAME/NUMBER TO MIB ADDR
       INTEGER UTILITY CREATE'UP'ENTRY ← 65;*        CREATE USER/UP ENTRY
       UNKNOWN UTILITY DELETE'UP'ENTRY ← 66;*        DELETE USER/UP ENTRY

* PROCESSES, AND PROCESS PROFILE
       UNKNOWN UTILITY CREATE'PROCESS ← 70;*         CREATE/INITIALIZE PROCESS
       STRING UTILITY READ'PP'ITEM ← 71;*           READ ITEM FROM PROCESS PROFILE
       STRING UTILITY READ'PP'NAMES ← 72;*          READ NAMES OF PP ITEMS
       UNKNOWN UTILITY SET'PP'ITEM ← 73;*            SET (CREATE) VALUE OF PP ITEM

       COMMON M1'COMM;
       INCLUDE COMM,SYSCALLS;
*
* COMMON STORAGE FOR MRUN
*
       DA RING'FILES[NRINGS+2];* FILES FOR RING DATA
       DI CODE'FILE=RING'FILES[NRINGS];* FILE FOR CODE
       DI BARE'FILE=RING'FILES[NRINGS+1];* FILE FOR ABSOLUTE CORE
       DI REAL'FILE;* REAL FILE NUMBER
       DA NAME'BUF[8];* BUFFER FOR FILE NAME
       DI M1'FILE'TYPE=NAME'BUF[7];
       DA FILE'TYPES[5]←(6'',6'9SAV',6'9BIN',6'9SYM',6'9DMP');
*              940 FILE TYPES
       DA PMT'BYTES[64];* PMT BYTES
       DA PMT'USE[64];* BOOK-KEEPERS FOR PMT'BYTES
       DF PMT'FILE(0:0,11), PMT'PAGE(0:12,23);
       DECLARE INTEGER ERMSNO, CHARACTER ERCODE;* SYSTEM ERROR CODES
       DM SYSEC←ERCODE,ERMSNO;* FOR FAILURE RETURNS
       DM SYSERR←VALUE SYS'ERR():SYSEC;
       DI SP'=G'[2],SL'=G'[3];* STACK POINTER AND LIMIT
       DECLARE ARRAY STACK [4000B];* HOPEFULLY, UNNECESSARILY LARGE
       DI INIT'SP←@STACK[0],INIT'SL←@STACK[3777B];* STACK BOUNDS

       PROGRAM MISC'RUN;
       INCLUDE M1'COMM;

       DECLARE STRING S,S', INTEGER FILE,X,Y,K,L,M,N, POINTER S1,S2;
       DECLARE OCTAL LSUB0=L'[0];
       DECLARE ARRAY DIGITS[25];
       DECLARE FIELD WD0(0),WD1(1);
       DFF ST'CSIZE(0:2,3);
       DECLARE STRING FIELD STRING'F(0);

* OUTPUT STRING TO TERMINAL
       FUNCTION CSOUT(S);
SOUT:  PRINT'STRING(-1,S,0//SOS:S,SYSEC);
       RETURN;
SOS:   SYS'ERR() IF ERCODE # 'QIT';
       GOTO QUITGO IF
           (QUITMODE = 1 OR (QUITF ← QUITF + 1) >= QUIT'ABORT'LEVEL);
       RETURN IF LENGTH(S) = 0 ELSE GOTO SOUT;

* OUTPUT STRING TO FILE
       FUNCTION COUT(X,FILE);
       SETUP(S,3,@X);
       SETS(S,2,3);
       FUNCTION FSOUT(S,FILE);
       GOTO SOUT IF FILE=-1;* TELETYPE
       WCI'TO'FILE(FILE,S);
       RETURN;

* SYSTEM FAILURES
       FUNCTION RUNTIME'FAILURE();
       FMTO("/RUNTIME FAILURE AT P = #B/"); OUT(LSUB0);
       EXIT();
       .HLT 2;
       FUNCTION SYS'ERR();
       CSOUT("&/SYSTEM CALL FAILED: CODE = ");
       SETUP(S, 3, @ERCODE);
       SETS(S, 0, 3);
       CSOUT(S);
       FMTO(", NUMBER = */"); OUT(ERMSNO);
       FMTO("AT P =#B/"); OUT (LSUB0);
       EXIT();
       .HLT 3;
       FUNCTION FATAL'ERROR();
       FMTO("/FATAL ERROR AT P = #B/"); OUT(LSUB0);
       EXIT();
       .HLT 4;

* LOCATE LEADING ONE
       FUNCTION FLLO(X);
       .LDA X, BGT R'[2], ZAB, LLT, STX X;
       RETURN X;

* COUNT ONE-BITS
       FUNCTION FCOB(X);
       .LDA X, ZOB, COB, STX X;
       RETURN X;

* APPEND STRING TO STRING
       FUNCTION SCOPY(STRING @S1,S), FRETURN;
       S1.WP←S1.RP←S1.BP;
       FUNCTION APPEND(STRING @S1,S), FRETURN;
       FUNCTION APPND(STRING @S1,S), FRETURN;
       S'←S1.STRING'F;
       FRETURN IF LENGTH(S)>LNGDES(S'$WP,S'$EP);
       FATAL'ERROR() IF S$ST'CSIZE#S'$ST'CSIZE;
APP1:  WCI(GCI(S//APP2),S');
       GOTO APP1;
APP2:  S1.WP←S'$WP;
       RETURN;

* CONVERT NUMBER TO STRING
       STRING FUNCTION CNS(X,STRING @S1,INTEGER L,N), FRETURN;
       STRING FUNCTION FCNS(X,STRING @S1,INTEGER L,N), FRETURN;
       RUNTIME'FAILURE() IF N<2 OR N>400B;
       S←S1.STRING'F;
       Y←(X IF X>=0 OR L<0 ELSE -X);
       K←0;
CNS1:  .LDA Y, LSHD -23, DIV N, STA Y, STB M;
       DIGITS[K]←M+'0';
       K←K+1;
       GOTO CNS1 IF Y;
       IF X<0 AND L>=0 DO;
          DIGITS[K]←'-';
          K←K+1;
       ENDIF;
       K←M IF (M←L A' 77B)#0 AND M<K;
       WCI(DIGITS[K],S//FRETURN) FOR K←K-1 BY -1 TO 0;
       S1.WP←S$WP;
       RETURN S;


* CALCULATE COMPUTE TIME IN MILLISECONDS FROM 2 48-BIT
* COMPUTE TIME CLOCK VALUES.
      FUNCTION MS'COMPUTE'TIME(LONG TIME'1,TIME'2);
          .LDA TIME'2$WD1,.SUB TIME'1$WD1,.CAB;
          .LDA TIME'2$WD0,.SUC TIME'1$WD0;
          .DIV 50;*CONVERTING FROM 10 MICROSECS TO MILLISECS
          .STA X;
          RETURN X;

* READ NUMBER OF PAGE FAULTS.
       FUNCTION PAGE'FAULTS();
       RETURN READ'PROC'PARAM('PFC'//SYSERR);
       END;*
       PROGRAM EXIT;
       INCLUDE M1'COMM;
       DECLARE INTEGER
          CURRENT'SPCSL, LEVEL, CURRENT'L'REG, CURRENT'G'REG;

       FUNCTION EXIT();
* UNWIND SUB-PROCESS CALL STACK IF NECESSARY.
       CURRENT'SPCSL ← READ'SPS'PARAM('CSL'//SYSERR);
       IF CURRENT'SPCSL # SPL'SPCSL DO;
          LEVEL ← CURRENT'SPCSL - SPL'SPCSL - 1;
          .CLA; .STA CURRENT'L'REG; .CGA; .STA CURRENT'G'REG;
          MODIFY'CALL(LEVEL, @RE'ENTRY'POINT, CURRENT'L'REG, CURRENT'G'REG, 0//SYSERR);
          JUMP'RETURN(LEVEL//SYSERR);
       ENDIF;
RE'ENTRY'POINT:
* SET OLCWS AND OLDWS BACK TO WHAT THEY WERE WHEN SPL WAS ENTERED.
       SET'WS'SIZE(SAVED'OLCWS, SAVED'OLDWS);
* EXIT.
       SP'RETURN(//VALUE HALT(): SYSEC);

       FUNCTION HALT();
       .HLT 0;
       END;*
       PROGRAM ZEDIT;
* EDIT (COLLECT) LINE
       INCLUDE M1'COMM;
       DECLARE STRING S, S', NS(200);
       DECLARE INTEGER DUM1;

* 7/14/73  JACK FREEMAN
* THIS FUNCTION SHOULD EVENTUALLY BE CHANGED IN A NUMBER OF WAYS:
* (1) THE LOCAL STRING NS (200 CHARACTERS!) SHOULD BE GOTTEN RID OF.
*     IT SHOULD BE PASSED AS AN ARGUMENT.
* (2) SOME OF THE CALLERS OF ZEDIT SHOULD PROBABLY CALL EDIT'LINE
*     DIRECTLY INSTEAD.
* (3) THE CALL BELOW ON EDIT'LINE SHOULD PASS REALISTIC VALUES FOR
*     INSERT'MODE (THE 1ST 0) AND QUIT'FLAG (THE 2ND 0).  DUM1 IN THE
*     FAILURE RETURN LIST SHOULD BE SOME SORT OF INSERT'MODE VARIABLE.
* (4) SOMETHING MORE REASONABLE SHOULD BE DONE ABOUT FAILURES OF
*     EDIT'LINE, IN PARTICULAR THE ONE DUE TO QUIT.
* (5) A MORE REASONABLE CHARACTER THAN '%' SHOULD BE USED TO TERMINATE
*     EDITS.

       STRING FUNCTION ZEDIT(S,N,X),FRETURN;
       SETUP(S',1,@X);
       WCI(X,S') IF X>=0;
       SETS(NS);
       NS ← EDIT'LINE(-1, S, NS, 0, S', 0//EDIT1:S, NS, DUM1, SYSEC);
       SCOPY(S, NS//EDIT1);
       EDTERM ← GCD(S//VALUE RETURN S);
       IF EDTERM # '%' DO;
           WCI(EDTERM,S//VALUE RUNTIME'FAILURE());
       ENDIF;
       RETURN S;
EDIT1: SYS'ERR() IF ERCODE#'QIT';
*** PUNT FOR NOW
       EXIT();
       END;*
       PROGRAM ARRAY'RUN;
       INCLUDE SCMWF;
       DECLARE INTEGER LARGE'ELEMENT, UPPER'BOUND, KLUDGE;
       DECLARE FIELD MULTIPLIER, UPPER'LIMIT;
       DECLARE ARRAY DESCRIPTOR;

       ARRAY FUNCTION ARRDESC(BASE'ADDRESS, NO'OF'ELEMENTS,
                              ELEMENT'SIZE, LOWER'BOUND);
* CONSTRUCT ARRAY DESCRIPTOR WITH GIVEN BASE ADDRESS, NUMBER OF ELEMENTS,
* ELEMENT SIZE, AND LOWER BOUND.

* CHECK BASE'ADDRESS, ELEMENT'SIZE, AND LOWER'BOUND.
       RUNTIME'FAILURE() IF
          (BASE'ADDRESS<0 OR BASE'ADDRESS>(-1)$IWGD) OR
          (ELEMENT'SIZE<1 OR ELEMENT'SIZE>(-1)$AIWLMULT+1) OR
          (LOWER'BOUND<0 OR LOWER'BOUND>1);
* SET UP FOR LARGE OR SMALL ELEMENT CASE.
       IF ELEMENT'SIZE<=4 DO;
          LARGE'ELEMENT ← 0;
          MULTIPLIER ←  AIWNMULT;
          UPPER'LIMIT ← AIWNLIM;
       ELSE DO;
          LARGE'ELEMENT ← 1;
          MULTIPLIER ← AIWLMULT;
          UPPER'LIMIT ← AIWLLIM;
       ENDIF;
* COMPUTE AND CHECK UPPER'BOUND.  NOTE THE SPECIAL KLUDGERY FOR
* THE CASE WHERE THE NUMBER OF ELEMENTS IS ZERO.
       UPPER'BOUND ←
          LOWER'BOUND+(NO'OF'ELEMENTS-1 IF NO'OF'ELEMENTS>0 ELSE 0);
       KLUDGE ← -1;* BECAUSE (-1)$UPPER'LIMIT COMPILES WRONG.
       RUNTIME'FAILURE() IF
          UPPER'BOUND<LOWER'BOUND OR UPPER'BOUND>KLUDGE$UPPER'LIMIT;
* CONSTRUCT AND RETURN THE DESCRIPTOR.
       DESCRIPTOR$IWTYPE ← IWTARR;
       DESCRIPTOR$AIWORG ← LOWER'BOUND;
       DESCRIPTOR$AIWMIB ← 0;
       DESCRIPTOR$AIWLEB ← LARGE'ELEMENT;
       DESCRIPTOR$MULTIPLIER ← ELEMENT'SIZE - 1;
       DESCRIPTOR$UPPER'LIMIT ← UPPER'BOUND;
       DESCRIPTOR$AIWADDR ←
           IWTNOR@IWTYPE V' ATX@IWTAG V' 0@IWTRAP V' BASE'ADDRESS@IWGD;
       RETURN DESCRIPTOR;

       FUNCTION ARRAYSIZE(DESCRIPTOR);

* COMPUTE THE NUMBER OF ELEMENTS IN AN ARRAY.  NOTE THAT THIS IS THE
* SAME AS THE NUMBER OF WORDS OCCUPPIED BY THE ARRAY ONLY IF THE
* ELEMENTS OF THE ARRAY ARE 1 WORD IN SIZE.
       UPPER'LIMIT ← (AIWLLIM IF DESCRIPTOR$AIWLEB ELSE AIWNLIM);
       RETURN (DESCRIPTOR$UPPER'LIMIT - DESCRIPTOR$AIWORG + 1);
       END;*
       PROGRAM FILE'RUN;
       INCLUDE M1'COMM;

       DECLARE OCTAL PMT'BYTE;
       DECLARE STRING S;
       DECLARE POINTER SP;
       DECLARE FIELD PMT'INDEX(0:16,23);
       MACRO M1←(FILE=-1 AND M1MODE#0);

* GET M1 FILE CORRESPONDING TO GIVEN FILE
       FUNCTION M1'FILE(FILE);
       RETURN (CODE'FILE IF FILE=-1 ELSE BARE'FILE IF FILE=-2
   ELSE REAL'FILE IF FILE=4B7 ELSE RING'FILES[FILE]);

* FIND NEXT PAGE OF FILE
       FUNCTION SGNP'(N,REAL'FILE);  FILE←4B7;
       FUNCTION SGNP(N,FILE);
       IF M1 DO;
            WHILE (N←N+1)<64 DO;
                 RETURN N IF READ'MAP'BYTE(USPNO,N//SYSERR)$PMT'INDEX#0;
            ENDFOR;
            RETURN -1;
       ELSE DO;
            RETURN NEXT'FILE'PAGE(M1'FILE(FILE),N//SYSERR);
       ENDIF;
       HALT();* CONTROL SHOULD NEVER REACH HERE

* DELETE PAGE OF FILE (MAY NOT EXIST)
       FUNCTION SDPG'(N,REAL'FILE);  FILE←4B7;
       FUNCTION SDPG(N,FILE);
       IF M1 DO;
            IF PMT'BYTE←READ'MAP'BYTE(USPNO,N//SYSERR)$PMT'INDEX DO;
                 DELETE'PMT(PMT'BYTE//SYSERR);
            ENDIF;
       ELSE DO;
            DEL'FILE'PAGE(M1'FILE(FILE),N//SYSERR);
       ENDIF;
       RETURN;

* CREATE PAGE OF FILE (MAY ALREADY EXIST)
       FUNCTION SCPG'(N,REAL'FILE);  FILE←4B7;
       FUNCTION SCPG(N,FILE);
       IF M1 DO;
            IF (PMT'BYTE←READ'MAP'BYTE(USPNO,N//SYSERR)$PMT'INDEX)=0 DO;
                 PMT'BYTE←ACQUIRE'PMT(-1//SYSERR);
                 NEW'PMT'PAGE(PMT'BYTE//SYSERR);
                 SET'PMT'CL(PMT'BYTE,((1 LSH USPNO) V' (1 LSH SSPNO))
                 //SYSERR);
                 SET'MAP'BYTE(USPNO,N,PMT'BYTE//SYSERR);
            ENDIF;
       ELSE DO;
            CR'FILE'PAGE(M1'FILE(FILE),N//CRE:SYSEC);
       ENDIF;
       RETURN;
CRE:   RETURN IF ERCODE='FPE' ELSE SYS'ERR();

* COLLECT FILE NAME FROM COMMAND STRING AND WRITE IT ON STRING.
* FAIL IF NO NAME OR STRING TOO SHORT, OTHERWISE RETURN STRING
       STRING FUNCTION CGETF(STRING S), FRETURN;
       APPEND(S,GET'PARAM(CSTR)//FRETURN);
       FRETURN IF LENGTH(S)=0;
       RETURN S;

* CONVERT FILE NAME TO M1 NAME
       FUNCTION M1'FNAME(S,N,NEW'OK), FRETURN;
       NAME'SEARCH(S,NAME'BUF,NEW'OK,FILE'TYPES[N A' 7],-1//FRETURN:SYSEC);
       RETURN;

* OPEN FILE FOR INPUT AND CHECK TYPE
       FUNCTION OIF(S,N), FRETURN;
       M1'FNAME(S,N,0//FRETURN);
       FRETURN IF M1'FILE'TYPE#FILE'TYPES[N A' 7];
       RETURN OPEN'FILE(-1,NAME'BUF,'RU',-1//FRETURN:SYSEC);

* OPEN FILE FOR OUTPUT AND SET TYPE. SET WORD NUMBER PART OF 
* FILE LENGTH TO MAX VALUE.
       FUNCTION OOF(S,N), FRETURN;
       M1'FNAME(S,N,1//FRETURN);
       FILE← OPEN'FILE(-1,NAME'BUF,'WU',-1//FRETURN:SYSEC);
       SET'FILE'LENGTH(FILE,3777B//SYSERR);
       RETURN FILE;

* CLOSE FILE, ALL FILES
       FUNCTION CLOSALL();
       FILE←-1;
       FUNCTION CLOSE(FILE);
       CLOSE'FILE(FILE//SYSERR);
       RETURN;
       END;*
       PROGRAM SMAP;
       INCLUDE M1'COMM;

       DECLARE OCTAL PMT'BYTE, I, FILE;
       DECLARE FIELD PMT'INDEX(0:16,23);

* PUT PAGE OF FILE IN MAP - FIRST PASS
       FUNCTION SMAP'(N,REAL'FILE,X);  FILE←4B7;
       FUNCTION SMAP(N,FILE,X);
       X←X RSH 11;
       PMT'BYTE←PMT'BYTES[X];
       IF N=-1 DO;
           RETURN IF PMT'BYTE<=0;
           CLEAR'PMT(PMT'BYTE//SYSERR);
           PMT'USE[X]$PMT'FILE ← PMT'USE[X]$PMT'PAGE ← 0;
           PMT'BYTE←0;
       ELSEIF M1MODE=0 OR FILE#-1 DO;
           IF PMT'BYTE<=0 DO;
               PMT'BYTES[X]←PMT'BYTE←ACQUIRE'PMT(-1//SYSERR);
           ELSE DO;
               SMAP'COUNTER ← SMAP'COUNTER + 1;
               RETURN IF SMAP'CHECK(M1'FILE(FILE), N, X);
               CLEAR'PMT(PMT'BYTE//SYSERR);
               PMT'USE[X]$PMT'FILE ← PMT'USE[X]$PMT'PAGE ← 0;
           ENDIF;
           MOVE'PAGE'PMT(M1'FILE(FILE),N,PMT'BYTE//SYSERR);
           PMT'USE[X]$PMT'FILE ← M1'FILE(FILE);
           PMT'USE[X]$PMT'PAGE ← N;
           PUT'PAGE'CWS(PMT'BYTE//SYSERR);
       ELSE DO;
           PMT'BYTE←READ'MAP'BYTE(USPNO,N//SYSERR)$PMT'INDEX;
           FATAL'ERROR() IF PMT'BYTE=0;
       ENDIF;
       SET'MAP'BYTE(-1,X,PMT'BYTE//SYSERR);
       RETURN;

* INITIALIZE PMT BOOK-KEEPING.
       FUNCTION SMAP'INIT();
       FOR I ← 0 TO 63 DO;
           PMT'USE[I]$PMT'FILE ← PMT'USE[I]$PMT'PAGE ← 0;
       ENDFOR;
       RETURN;

* CHECK TO SEE IF PAGE IS ALREADY MAPPED IN.
       FUNCTION SMAP'CHECK(FILE, PAGE, I);
       IF FILE = PMT'USE[I]$PMT'FILE AND PAGE = PMT'USE[I]$PMT'PAGE DO;
           REDUNDANT'SMAPS ← REDUNDANT'SMAPS + 1;
           RETURN 1;
       ELSE DO;
           RETURN 0;
       ENDIF;
       END;*
       COMMON SEQ'FILE;
       INCLUDE M1'COMM, PPDEC, STBD;



       DECLARE PARAMETER N'SEQ'FILES ← 3;
       DECLARE ARRAY SEQ'FILE'TABLE[N'SEQ'FILES:21];
       DECLARE SIGNED FIELD PAGE'IN'WINDOW (0:0,11);
       DECLARE FIELD PMT'INDX (0:12,19);
       DECLARE FIELD IN'USE (0:20,20);
       DECLARE FIELD LARGE'OR'SMALL (0:21,21);
       DECLARE FIELD INPUT'OR'OUTPUT (0:22,22);
       DECLARE FIELD BYTE'SIZE (1:0,4);
       DECLARE FIELD NAME'STORAGE (2);
       DECLARE STRING FIELD INPUT'DESCRIPTOR(10);
       DECLARE STRING FIELD OUTPUT'DESCRIPTR (14);
       DECLARE FIELD LENGTH'IN'CHARS (18);
       DECLARE FIELD FL'NMBR (19:1,5);
       DECLARE FIELD WINDOW'ADDR (19:6,23);
       DECLARE FIELD CHARS'LEFT (20);
       DECLARE ARRAY SEQ'FILE'WINDOWS[N'SEQ'FILES] ←
            (200000B, 204000B, 210000B);
       DECLARE ARRAYONE OPEN'FILES[16];
       DECLARE INTEGER CHLF←310B;* SHOULD BE DECLARED IN PPDEC, BUT ISN'T
       DECLARE FIELD VTA (0:0,12), VPN(0:6,12);
       END;*
       PROGRAM OPEN'SEQ'FILE;
        INCLUDE SEQ'FILE;



       DECLARE GARBAGE;
        DECLARE INTEGER SMALL'FILE←0,LARGE'FILE←1;
       DECLARE INTEGER SEQ'FILE'NUMBER,IOFLAG,NEW'FILE'OK,LENGTH'IN'CHAR,
        OBJECT'TYPE,ACCESS'KEY,FILE'NUMBER,PAGE'NUMBER,PMT'INDEX, NUTS;
       DECLARE STRING FILE'NAME, S;
       DECLARE FIELD LENGTH'FIELD (2:2,23);
       DECLARE POINTER FILE,WINDOW'ADDRESS;
       DECLARE ARRAY FORMATTED'NAME;
       DECLARE ARRAY LENGTH'WORD[3];


*IOFLAG=0 FOR INPUT, 1 FOR OUTPUT

        FUNCTION OPEN'SEQ'FILE(FILE'NAME,IOFLAG);

        FOR SEQ'FILE'NUMBER←0 TO N'SEQ'FILES-1 DO;
           GOTO SET IF SEQ'FILE'TABLE[SEQ'FILE'NUMBER]$IN'USE=0;
       ENDFOR;
       CERR(139);* TOO MANY SEQUENTIAL FILES OPEN
SET:   SEQ'FILE'TABLE[SEQ'FILE'NUMBER]$IN'USE←1;
       FILE←@SEQ'FILE'TABLE[SEQ'FILE'NUMBER];
       FORMATTED'NAME←ARRDESC(@(FILE.NAME'STORAGE),8,1,0);
       NEW'FILE'OK←IOFLAG;
       NAME'SEARCH(FILE'NAME, FORMATTED'NAME,NEW'FILE'OK,6'9SYM',-1//
            VALUE GOTO READ'FROM'FILE: ERCODE, ERMSNO);
       ACCESS'KEY←('WU' IF IOFLAG ELSE 'RU');
       IF FORMATTED'NAME[2]=-1 DO;
           FILE'NUMBER←OPEN'FILE(-1,FORMATTED'NAME,ACCESS'KEY,-1//
               VALUE GOTO ABORT: ERCODE, ERMSNO);
           LENGTH'IN'CHAR←0;
           OBJECT'TYPE←SMALL'FILE;
       ELSE DO;
           CONV'NAME(FORMATTED'NAME, FORMATTED'NAME,-1:
               GARBAGE,OBJECT'TYPE,GARBAGE//
               VALUE GOTO ABORT: ERCODE, ERMSNO);
           IF (OBJECT'TYPE#SMALL'FILE) AND (OBJECT'TYPE#LARGE'FILE) DO;
               FILE.IN'USE←0;
               CERR(140);* FILE OF IMPROPER TYPE
           ELSE DO;
               READ'MIBOB'VALUE(FORMATTED'NAME,1,LENGTH'WORD,2,-1//
                               VALUE GOTO ABORT: ERCODE, ERMSNO);
               FILE'NUMBER←OPEN'FILE(-1,FORMATTED'NAME,ACCESS'KEY,-1//
                               VALUE GOTO ABORT: ERCODE, ERMSNO);
               LENGTH'IN'CHAR←(0 IF NEXT'FILE'PAGE(FILE'NUMBER,-1//
                               SYSERR)=-1 ELSE 3*
       ((2048*((LENGTH'WORD[2]$VTA)-1))+(LENGTH'WORD[2]$VWA)+1));
               IF (LENGTH'IN'CHAR) AND (IOFLAG) DO;
                   PAGE'NUMBER←-1;
                   WHILE PAGE'NUMBER←NEXT'FILE'PAGE(
                    FILE'NUMBER,PAGE'NUMBER//SYSERR)#-1 DO;
                       DEL'FILE'PAGE(FILE'NUMBER,PAGE'NUMBER//SYSERR);
                   ENDFOR;
                   SET'FILE'LENGTH(FILE'NUMBER,0//SYSERR);
                   LENGTH'IN'CHAR←0;
               ENDIF;
           ENDIF;
       ENDIF;
       FILE.PMT'INDX←ACQUIRE'PMT(-1//SYSERR);
       FILE.WINDOW'ADDR←SEQ'FILE'WINDOWS[SEQ'FILE'NUMBER];
       NUTS←FILE.WINDOW'ADDR$VPN;
       SET'MAP'BYTE(-1,NUTS,FILE.PMT'INDX//SYSERR);
       OPEN'FILES[FILE'NUMBER]←SEQ'FILE'NUMBER;
       SETUP(S,0,FILE.WINDOW'ADDR,8);
       FILE.OUTPUT'DESCRIPTR←S;
       FILE.INPUT'DESCRIPTOR←S;
       FILE.FL'NMBR←FILE'NUMBER;
       FILE.LARGE'OR'SMALL←(0 IF OBJECT'TYPE=SMALL'FILE ELSE 1);
       FILE.LENGTH'IN'CHARS←LENGTH'IN'CHAR;
       FILE.CHARS'LEFT←LENGTH'IN'CHAR;
       FILE.BYTE'SIZE←8;
       FILE.PAGE'IN'WINDOW←-1;
       FILE.INPUT'OR'OUTPUT←IOFLAG;
       RETURN FILE'NUMBER;
READ'FROM'FILE:FILE.IN'USE←0;
       CERR(141);* ATTEMPT TO READ FROM NON-EXISTENT FILE
ABORT:
        FILE.IN'USE←0;
       SYS'ERR();
       END;*
       PROGRAM GCI'FROM'FILE;

        INCLUDE SEQ'FILE;


        DECLARE POINTER FILE;
       DECLARE STRING OUTPUT'LINE,J,S;
       DECLARE INTEGER CHAR,FILE'NUMBER,NEXT'PAGE,I;

        STRING FUNCTION GCI'FROM'FILE(FILE'NUMBER, STRING OUTPUT'LINE),
        FRETURN;

        FILE←@SEQ'FILE'TABLE[OPEN'FILES[FILE'NUMBER]];
READ:       J←FILE.INPUT'DESCRIPTOR;
        CHAR←GCI(J//VALUE NEW'PAGE(FILE//CHECK)
        & GOTO READ) A' 177B;
       FILE.INPUT'DESCRIPTOR←J;
       IF CHAR<135B DO;
           WCI(CHAR,OUTPUT'LINE//VALUE PXERR(132));
       ELSE DO;
           IF CHAR=135B DO;*MULTIPLE BLANKS
BLANKS:        J←FILE.INPUT'DESCRIPTOR;
                CHAR←CHMB1+(GCI(J//VALUE
                NEW'PAGE(FILE//ZERO) & GOTO BLANKS)) A' 77B;
               FILE.INPUT'DESCRIPTOR←J;
           ELSEIF CHAR=155B DO;*CARRAIGE RETURN
CARRAIGE:        J←FILE.INPUT'DESCRIPTOR;
                IF (GCI(J//VALUE NEW'PAGE(FILE//
                CARR) & GOTO CARRAIGE)) A' 177B=152B DO;
               FILE.INPUT'DESCRIPTOR←J;
                   CHAR←CHNL;
               ELSE DO;
                   CHAR←CHAR V' 200B;
                   J←FILE.INPUT'DESCRIPTOR;
                   J$RP ← INCDES(J$RP,-1);
                   FILE.INPUT'DESCRIPTOR←J;
               ENDIF;
           ELSEIF CHAR=152B DO;
               CHAR←CHLF;*310B
           ELSEIF CHAR>140B DO;
               CHAR←CHAR V' 200B;
           ENDIF;
           WCI(CHAR, OUTPUT'LINE//VALUE PXERR(132));
           RETURN OUTPUT'LINE IF CHAR=CHNL;
       ENDIF;
       GOTO READ;
ZERO:
        WCI(200B, OUTPUT'LINE//VALUE PXERR(132));
       RETURN OUTPUT'LINE;
CARR:
        WCI(355B, OUTPUT'LINE//VALUE PXERR(132));
       RETURN OUTPUT'LINE;
CHECK:
        RETURN OUTPUT'LINE IF LENGTH(OUTPUT'LINE)>0;
       FRETURN;






        FUNCTION NEW'PAGE(FILE),FRETURN;

        RUNTIME'FAILURE() IF FILE.IN'USE=0;
       CERR(142) IF FILE.INPUT'OR'OUTPUT;* FILE NOT OPEN FOR INPUT
       IF FILE.CHARS'LEFT<=0 DO;
           FRETURN;
       ELSE DO;
           NEXT'PAGE←FILE.PAGE'IN'WINDOW+1;
           CLEAR'PMT(FILE.PMT'INDX//SYSERR);
           MOVE'PAGE'PMT(FILE.FL'NMBR,NEXT'PAGE,FILE.PMT'INDX//SYSERR);
           FILE.PAGE'IN'WINDOW←NEXT'PAGE;
           IF FILE.CHARS'LEFT>3*4000B DO;*MORE THAN 1 PAGE LEFT
           SETUP(S,3*4000B,FILE.WINDOW'ADDR,8);
               FILE.INPUT'DESCRIPTOR←S;
               FILE.INPUT'DESCRIPTOR$WP←FILE.INPUT'DESCRIPTOR$EP;
               FILE.CHARS'LEFT←FILE.CHARS'LEFT-3*4000B;
           ELSE DO;*LAST PAGE
           SETUP(S,FILE.CHARS'LEFT,FILE.WINDOW'ADDR,8);
               S$WP ← S$EP;
               S$RP ← INCDES(S$EP, -3);
               FOR I ← 1 TO 3 DO;
                   GOTO END'OF'FILE IF (CHAR ← (GCI(S) A' 177B) = 137B);
               ENDFOR;
END'OF'FILE:   S$WP ← INCDES(S$RP, -1) IF CHAR = 137B;
               SETR(S, 0);
               FILE.INPUT'DESCRIPTOR ← S;
               FILE.CHARS'LEFT ← 0;
           ENDIF;
       ENDIF;
       RETURN;
       END;*
       PROGRAM WCI'TO'FILE;

        INCLUDE SEQ'FILE;


        DECLARE POINTER FILE;
       DECLARE INTEGER FILE'NUMBER,CHAR,NEXT'PAGE;
       DECLARE STRING INPUT'LINE,T,S;

        FUNCTION WCI'TO'FILE(FILE'NUMBER,STRING INPUT'LINE);

        FILE←@SEQ'FILE'TABLE[OPEN'FILES[FILE'NUMBER]];
RD:
        CHAR←GCI(INPUT'LINE//RETURN);
       IF CHAR>340B DO;
           CHAR←CHAR A' 177B;
       ELSEIF ((CHAR>=200B) AND (CHAR<=277B)) DO;
MB:
               T←FILE.OUTPUT'DESCRIPTR;
            WCI(135B,T//VALUE CREATE(FILE) & GOTO MB);
               FILE.OUTPUT'DESCRIPTR←T;
           CHAR←CHAR A' 77B;
       ELSEIF CHAR=307B DO;
NL:
       T←FILE.OUTPUT'DESCRIPTR;
            WCI(155B,T//VALUE CREATE(FILE) & GOTO NL);
       FILE.OUTPUT'DESCRIPTR←T;
           CHAR←152B;
       ELSEIF CHAR=310B DO;
           CHAR←152B;
       ENDIF;
WT:
       T←FILE.OUTPUT'DESCRIPTR;
        WCI(CHAR,T//VALUE CREATE(FILE) & GOTO WT);
       FILE.OUTPUT'DESCRIPTR←T;
       GOTO RD;




        FUNCTION CREATE(FILE);


        RUNTIME'FAILURE() IF FILE.IN'USE=0;
       CERR(143) IF FILE.INPUT'OR'OUTPUT=0;* FILE NOT OPEN FOR OUTPUT
       NEXT'PAGE←FILE.PAGE'IN'WINDOW+1;
       CR'FILE'PAGE(FILE.FL'NMBR,NEXT'PAGE//SYSERR);
       CLEAR'PMT(FILE.PMT'INDX//SYSERR);
       MOVE'PAGE'PMT(FILE.FL'NMBR,NEXT'PAGE,FILE.PMT'INDX//SYSERR);
       FILE.PAGE'IN'WINDOW←NEXT'PAGE;
       SETUP(S,3*4000B,FILE.WINDOW'ADDR,8);
       FILE.OUTPUT'DESCRIPTR←S;
       IF NEXT'PAGE DO;
           FILE.LENGTH'IN'CHARS←FILE.LENGTH'IN'CHARS + 3*4000B;
       ENDIF;
       RETURN;
       END;*
       PROGRAM CLOSE'SEQ'FILE;


        INCLUDE SEQ'FILE;


        DECLARE STRING END'FILE←"&137";
       DECLARE INTEGER FILE'NMBR,ND,EF;
       DECLARE POINTER FILE;
       DECLARE INTEGER LENGTH'IN'WORDS;


               DECLARE STRING W;
 
 
        FUNCTION CLOSE'SEQ'FILE(FILE'NMBR);


        FILE←@SEQ'FILE'TABLE[OPEN'FILES[FILE'NMBR]];
       CERR(144) IF FILE.IN'USE=0;* ATTEMPT TO RECLOSE CLOSED FILE
       IF FILE.INPUT'OR'OUTPUT DO;*OUTPUT FILE
           WCI'TO'FILE(FILE'NMBR, END'FILE);
           W ← FILE.OUTPUT'DESCRIPTR;
           ND ← LENGTH(W);
           LENGTH'IN'WORDS ← (ND*(FILE.BYTE'SIZE) + 23)/24;
           SET'FILE'LENGTH(FILE'NMBR, LENGTH'IN'WORDS - 1//SYSERR);
       ENDIF;
       CLOSE'FILE(FILE'NMBR//SYSERR);
       FILE.IN'USE←0;
       OPEN'FILES[FILE'NMBR]←-1;
       DELETE'PMT(FILE.PMT'INDX//SYSERR);
       RETURN;
       END;*
       PROGRAM SEQ'IO'INIT;


        INCLUDE SEQ'FILE;
       DECLARE INTEGER SEQ'FILE'NUM,OPEN'FILE'NUM;




        FUNCTION SEQ'IO'INIT();

        FOR SEQ'FILE'NUM←0 TO N'SEQ'FILES-1 DO;
           SEQ'FILE'TABLE[SEQ'FILE'NUM]$IN'USE←0;
       ENDFOR;
       FOR OPEN'FILE'NUM←1 TO 16 DO;
           OPEN'FILES[OPEN'FILE'NUM]←-1;
       ENDFOR;
       RETURN;

        END;*
       PROGRAM SP'ENTRIES;
       INCLUDE M1'COMM;

* INITIAL ENTRY POINT
       FUNCTION I'E(), SP'ENTRY←2;
       SP'←INIT'SP;
       SL'←INIT'SL;
       SPL'INIT();

* CONTINUE ENTRY POINT
       FUNCTION C'E(), SP'ENTRY←3;
       SP'←INIT'SP;
       SL'←INIT'SL;
       SPL'CONT();

       PROGRAM SPL'INIT;
       INCLUDE M1'COMM;

       DECLARE INTEGER I;

* INITIALIZE SPL
       FUNCTION SPL'INIT();
       PMT'BYTES[I] ← 0 FOR I ← 0 TO 63;
       SMAP'INIT();
       SMAP'COUNTER ← REDUNDANT'SMAPS ← 0;
       SEQ'IO'INIT();
       SSPNO← READ'SPS'PARAM('CSP'//FTLERR: SYSEC);
       SPL'SPCSL ← READ'SPS'PARAM('CSL'//SYSERR);
       PROCNO ← READ'PROC'PARAM('PRT'//FTLERR: SYSEC);
       CREATE'RING'FILE(0);
       SAVED'OLCWS ← READ'LWS('OCW'//SYSERR);
       SAVED'OLDWS ← READ'LWS('ODW'//SYSERR);
       DESIRED'OLCWS ← OPTIMAL'OLCWS;
       DESIRED'OLDWS ← OPTIMAL'OLDWS;
       SET'WS'SIZE(DESIRED'OLCWS, DESIRED'OLDWS);
       M1MODE←1;
*** NOW WHAT ?
       SPL();
* CONTINUE SPL
       FUNCTION SPL'CONT();
       SET'WS'SIZE(DESIRED'OLCWS, DESIRED'OLDWS);
       CSPL();

       PROGRAM CREATE'RING'FILE;
       INCLUDE M1'COMM;
       DECLARE STRING FILE'NAME(30);
       DECLARE CHARACTER ARRAY RINGS[NRINGS] ← ('0', '1', '2');
       DECLARE INTEGER FILE'NUMBER, OBJECT'TYPE, GARBAGE;
       DECLARE PARAMETER SMALL'FILE ← 0, LARGE'FILE ← 1;

       FUNCTION CREATE'RING'FILE(RING'NUMBER);
* CONSTRUCT FILE NAME.  THIS NAME HAS THE FORM:
*  "RING-<RING-NUMBER>-DATA-<PROCESS-NUMBER>-<SUB-PROCESS-NUMBER>:RING"
* WHERE <RING-NUMBER> IS THE ARGUMENT PASSED TO CREATE'RING'FILE;
*       <PROCESS-NUMBER> IS THE (DECIMAL) PRT INDEX OF THE PROCESS
*              WE'RE RUNNING IN, TRUNCATED TO 2 DIGITS;
*       <SUB-PROCESS-NUMBER> IS THE (DECIMAL) SUB-PROCESS NUMBER OF
*              SPL, TRUNCATED TO 1 DIGIT.
* A TYPICAL FILE NAME WILL BE:
*  "RING-0-DATA-9-2:RING".
       SETS(FILE'NAME);
       SCOPY(FILE'NAME, "&"RING-"//VALUE RUNTIME'FAILURE());
       WCI(RINGS[RING'NUMBER], FILE'NAME);
       APPEND(FILE'NAME, "-DATA-"//VALUE RUNTIME'FAILURE());
       CNS(PROCNO, FILE'NAME, 2, 10//VALUE RUNTIME'FAILURE());
       WCI('-', FILE'NAME);
       CNS(SSPNO, FILE'NAME, 1, 10//VALUE RUNTIME'FAILURE());
       APPEND(FILE'NAME, ":RING&""//VALUE RUNTIME'FAILURE());
* SEE IF THERE'S ALREADY AN OBJECT WITH THIS NAME.
       NAME'SEARCH(FILE'NAME, NAME'BUF, 1, 6'RING', -1//SYSERR);
       IF NAME'BUF[2] # -1 DO;* OLD FILE
           CONV'NAME(NAME'BUF, NAME'BUF, -1:GARBAGE,OBJECT'TYPE,GARBAGE//SYSERR);
           FATAL'ERROR() IF
               (OBJECT'TYPE # SMALL'FILE AND OBJECT'TYPE # LARGE'FILE);
           DELETE'FILE(NAME'BUF, -1//SYSERR);
       ENDIF;
* CREATE A LARGE FILE.
       CREATE'MIBOB(NAME'BUF, LARGE'FILE, CONV'KEY(-1//SYSERR)//SYSERR);
       NAME'BUF[2] ← 0;
       FILE'NUMBER ← OPEN'FILE(-1, NAME'BUF, 'WU', -1//SYSERR);
       SET'FILE'LENGTH(FILE'NUMBER, 3777B//SYSERR);
       RING'FILES[RING'NUMBER] ← FILE'NUMBER;
       RETURN;
       END;

       PROGRAM SET'WS'SIZE;
       INCLUDE M1'COMM;

       DECLARE INTEGER MAX'CWS, MAX'DWS;

       FUNCTION SET'WS'SIZE(TARGET'OLCWS, TARGET'OLDWS);
* READ MAXIMUM ALLOWED VALUES FOR OLCWS AND OLDWS.
       MAX'CWS ← READ'LWS('MCW'//SYSERR);
       MAX'DWS ← READ'LWS('MDW'//SYSERR);
* ADJUST TARGET VALUES IF NECESSARY.
       TARGET'OLCWS ←
           (TARGET'OLCWS IF TARGET'OLCWS <= MAX'CWS ELSE MAX'CWS);
       TARGET'OLDWS ←
           (TARGET'OLDWS IF TARGET'OLDWS <= MAX'DWS ELSE MAX'DWS);
* REDUCE THE WORKING SETS IF THEY'RE LARGER THAN THE TARGET LENGTHS.
       DEL'PAGE'CWS(-1//SYSERR) WHILE TARGET'OLCWS < READ'LWS('CWS'//SYSERR);
       DEL'PAGE'DWS(-1//SYSERR) WHILE TARGET'OLDWS < READ'LWS('DWS'//SYSERR);
* SET NEW OVERFLOW LENGTHS.
       IF TARGET'OLCWS >= READ'LWS('OCW'//SYSERR) DO;
           SET'LWS('ODW', TARGET'OLDWS//SYSERR);
           SET'LWS('OCW', TARGET'OLCWS//SYSERR);
       ELSE DO;
           SET'LWS('OCW', TARGET'OLCWS//SYSERR);
           SET'LWS('ODW', TARGET'OLDWS//SYSERR);
       ENDIF;
       RETURN;
       END;

       PROGRAM SUBSTITUTES;
       INCLUDE M1'COMM;

* CREATE USER SUBPROCESS
       FUNCTION ZDEM1(FLG);
       IF FLG=0 DO;
       USPNO←CREATE'SSP(-1//SYSERR);
       ENDIF;
       RETURN;
* LABEL FIXER NEEDED FOR CPU 1.0
       LABEL FUNCTION LABEL'FIXER(LABEL FIX'ME'LABEL);
       RETURN FIX'ME'LABEL;
* ARRAY DESCRIPTOR FIXER
       ARRAY FUNCTION ARRAY'FIXER(ARRAY FIX'ME'ARRAY);
       RETURN FIX'ME'ARRAY;
* REAL ARRAY DESCRIPTOR FIXER
       ARRAY FUNCTION REAL'ARRAY'FIXER(REAL ARRAY REAL'ARRAY);
       RETURN REAL'ARRAY;

* QUIT FLAG TESTER
       FUNCTION IFQUIT(), FRETURN;
       FRETURN IF QUITF#0 ELSE RETURN;

       PROGRAM TOOLS;
       INCLUDE M1'COMM;

       DI I,J,K;
       DA PMTE[5],MIBE[10];
       DP PMTA;
       DS MIBS;
       DI PMTX,MAPX,SPTX,OBTX;
       DI OLDCL,OLDAL,NEWCL,NEWAL,OLDUN1,OLDUN2,NEWUN1,NEWUN2;
       DECLARE LONG UNDK←(-1,0);
       DS PMTS1←"#: #",PMTSL←" CL=# AL=#",PMTS2←" RO";
       DS PMTS3←": ",PMTS4←",*",PMTS5←" --";

       DF PMTCL(3:15,23),PMTAL(3:3,11),PMTRO(3:0,0),PMTFP(2:0,0);
       DF PMTUN1(0),PMTUN2(1),UN1F(0:2,23),UN2F(0:0,15),UN2I(0:16,23);

* LIST MAP FOR GIVEN SUBPROCESS
       FUNCTION LM(SPTX);
       SPTX←USPNO IF SPTX=0;
       PMTA←@PMTE[0];
       SETUP(MIBS,20,@MIBE[2],6);
       OLDCL←OLDAL←OLDUN1←OLDUN2←-1;
       FOR MAPX←0 TO 77B DO;
           IF PMTX←READ'MAP'BYTE(SPTX,MAPX//SYSERR) DO;
               READ'PMT(PMTX A' 377B,PMTE//SYSERR);
               FMTO(PMTS1); OUT(MAPX); OUT(PMTX);
               NEWCL←PMTA.PMTCL; NEWAL←PMTA.PMTAL;
               IF NEWCL#OLDCL OR NEWAL#OLDAL DO;
                   FMTO(PMTSL); OUT(OLDCL←NEWCL); OUT(OLDAL←NEWAL);
               ELSE DO;
                   CSOUT(PMTS5);
               ENDIF;
               CSOUT(PMTS2) IF PMTA.PMTRO;
               IF PMTA.PMTFP DO;
                   CSOUT(PMTS3);
                   NEWUN1←PMTA.PMTUN1$UN1F;
                   NEWUN2←PMTA.PMTUN2$UN2F;
                   GOTO RSAME IF NEWUN1=OLDUN1 AND NEWUN2=OLDUN2;
                   FOR OBTX←0 TO 177B DO;
                       READ'MIBOB'INDEX(UNDK,8,MIBE,OBTX,0//RFAIL:SYSEC);
                       GOTO RFOUND IF MIBE[8]$UN1F=NEWUN1
                        AND MIBE[9]$UN2F=NEWUN2;
RFAIL:             ENDFOR;
RRET:          ENDIF;
               CSOUT("&/");
           ENDIF;
       ENDFOR;
       RETURN;
RFOUND:OLDUN1←NEWUN1; OLDUN2←NEWUN2;
       SETS(MIBS,0,16);
       COUT(I,-1) WHILE I←GCI(MIBS//RTYPE);
RTYPE: COUT(':',-1);
       SETS(MIBS,16,20);
       CSOUT(MIBS);
RPAGE: FMTO(PMTS4); OUT(PMTA.PMTUN2$UN2I);
       GOTO RRET;
RSAME: CSOUT(PMTS5);
       GOTO RPAGE;
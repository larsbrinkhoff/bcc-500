       COMMON SCTRE';
       INCLUDE SCDEC,SCMWF,COMM,STST,SCST,PSTO;

********************
* SPL TREE BUILDER *
********************

       COMMON TCTAB;
       INCLUDE STDEC,SCDEC,SCST;

***
*** OPERATOR PROPERTY TABLE
***

* * COMPUTED BY HAND BECAUSE OF QSPL LIMITATIONS   * *
       DECLARE ARRAY TOPTAB[OPQCOUNT+1]←(-1,
   00042401B,34040407B,27043401B,00001400B,00021400B,00004403B,
   00602401B,00002401B,
   -1,
   32403020B,31403020B,32403020B,03403020B,
   07403050B,10603020B,11402030B,
   -1,-1,-1,-1,-1,-1,
   15403010B,15403010B,15403010B,04402070B,
   16403010B,22403010B,16403010B,22403010B,
   -1,-1,-1,
   17403010B,17403010B,-1,05402070B,20404040B,00404000B,
   -1);
       DECLARE ARRAY TOPTAB[41]←(
   12643120B,21243100B,06423060B,14202000B,02042070B,
   02003000B,23603100B,-1,00623401B,
   33243130B,00002000B,13623400B,01243000B,13626400B,
   00243000B,00243000B,
   30003000B,30405000B,30405000B,00421000B,
   24004070B,-1,02022110B,00422000B,00422000B,
   25023000B,-1,-1,00422000B,00021400B,
   -1,
   00022401B,00026402B,00026400B,00625402B,
   -1,-1,-1,00022401B,00021400B);


*** TYPE TABLES
***

* MACROS
       DM NT2ENT(T,X,Z,Y)←(U(T,ACTYPE)+U(X,ACTNO))*1B4+
        (U(Z,ACTYPE)+U(Y,ACTNO));
       DM STENT(X,Y,Z,T,N)←X,Y,U(Z,STCOMM)+
        U(U(T,ACTYPE)+U(N,ACTNO),STACT);


* TYPE TABLE FOR ARITHMETIC OPERATORS (+ - * /)
       DQ NTARM←1 LSH TTUND+1 LSH TTINT+1 LSH TTREAL+
        1 LSH TTDBL+1 LSH TTCPLX;
       DECLARE ARRAY NTARA[NTORG+8]←(
        NTARM, NTARM, U(NTTCBO,NTTT)+U(5,NTNT2), 0,
        NT2ENT(ATE,114,ATC,0), NT2ENT(ATC,0,ATC,0),
        NT2ENT(ATC,0,ATS,0), NT2ENT(ATC,2,ATC,3),
        NT2ENT(ATC,4,ATS,1), NT2ENT(ATC,5,ATC,6),
        NT2ENT(ATS,2,ATE,49), NT2ENT(ATS,3,0,0));
* TYPE TABLE FOR NEGATION
       DECLARE ARRAY NTNGA[NTORG+3]←(
        NTARM, NTARM, U(NTTUO,NTTT)+U(5,NTNT2), 0,
        NT2ENT(ATC,1,ATS,0), NT2ENT(ATS,1,ATS,2),
        NT2ENT(ATS,3,0,0));
* TYPE TABLE FOR RELATIONS AND MOD
       DQ NTRLM←NTARM-1 LSH TTCPLX;
       DECLARE ARRAY NTRLA[NTORG+5]←(
        NTRLM, NTRLM, U(NTTCBO,NTTT)+U(4,NTNT2), 0,
        NT2ENT(ATE,114,ATC,0), NT2ENT(ATC,0,ATC,0),
        NT2ENT(ATS,0,ATC,2), NT2ENT(ATC,3,ATS,1),
        NT2ENT(ATC,4,ATS,2));
       DECLARE ARRAY STRLA[2*STLE]←(
        STENT(1 LSH TTUND,-1,1,ATC,0),
        STENT(-1,-1,0,ATS,4));
       DECLARE ARRAY NTMDA=NTRLA;
* TYPE TABLE FOR ANYTHING ALLOWING 2 INTEGERS ONLY
       DQ NTIM←1 LSH TTUND+1 LSH TTINT;
       DECLARE ARRAY NTIA[NTORG+2]←(
        NTIM, NTIM, U(NTTCBO,NTTT)+U(2,NTNT2), 0,
        NT2ENT(ATE,114,ATC,0), NT2ENT(ATS,0,0,0));
* TYPE TABLE FOR ASSIGNMENT
       DECLARE ARRAY NTASA[NTORG+13]←(
        NTARM, NTARM, U(NTTBO,NTTT)+U(5,NTNT2), 0,
        NT2ENT(ATE,114,ATC,0), NT2ENT(ATC,0,ATC,0),
        NT2ENT(ATC,0,ATC,0), NT2ENT(ATS,0,ATE,40),
        NT2ENT(ATE,40,ATE,40), NT2ENT(ATC,0,ATC,2),
        NT2ENT(ATS,1,ATE,40), NT2ENT(ATE,40,ATC,0),
        NT2ENT(ATC,3,ATC,5), NT2ENT(ATS,2,ATE,49),
        NT2ENT(ATC,0,ATC,4), NT2ENT(ATC,6,ATE,49),
        NT2ENT(ATS,3,0,0));
       DECLARE ARRAY STASA[3*STLE]←(
        STENT(1 LSH TTLAB,1 LSH TTUND,0,ATC,7),
        STENT(1 LSH TTUND,-1,1,ATC,0),
        STENT(-1,-1,0,ATS,4));
* TYPE TABLE FOR ANYTHING WITH 1 INTEGER ONLY
       DECLARE ARRAY NT1IA[NTORG+1]←(
        NTIM, NTIM, U(NTTUO,NTTT)+U(2,NTNT2), 0,
        NT2ENT(ATC,1,ATS,0));
* TYPE TABLE FOR TAILING
       DECLARE ARRAY NTTLA[NTORG+1]←(
        NTIM, 1 LSH TTFIELD, U(NTTBO,NTTT)+U(1,NTNT2), 0,
        NT2ENT(ATC,1,ATS,0));
* TYPE TABLE FOR GOTO
       DQ NTGOM←1 LSH TTUND+1 LSH TTLAB;
       DECLARE ARRAY NTGOA[NTORG+1]←(
        NTGOM, NTGOM, U(NTTUO,NTTT)+U(2,NTNT2), 0,
        NT2ENT(ATC,7,ATS,0));
* TYPE TABLE FOR BINARY $
       DECLARE ARRAY NTBDA[NTORG]←(
        0, 0, 0, 0);
       DECLARE ARRAY STBDA[STLE]←(
        STENT(-1,1 LSH TTFIELD,0,ATS,0));
* TYPE TABLE FOR SIMPLE SUBSCRIPTING
       DECLARE ARRAY NTNSA[NTORG+2]←(
        1 LSH TTINT+1 LSH TTARRAY, 1 LSH TTUND+1 LSH TTINT,
         U(NTTBO,NTTT)+U(2,NTNT2), 0,
        NT2ENT(ATC,0,ATS,0), NT2ENT(ATC,0,ATS,1));


* TYPE ARRAY ARRAYS
       DECLARE ARRAY NTAA[12]←(
        0,REF NTIA,REF NTARA,REF NTNGA,REF NTRLA,
        REF NTMDA,REF NTASA,REF NT1IA,REF NTTLA,REF NTGOA,
        REF NTBDA,REF NTNSA);
       DECLARE ARRAY STAA[12]←(
        0,0,0,0,REF STRLA,
        0,REF STASA,0,0,0,
        REF STBDA,0);

***
*** TCN0(OP) ... TCN5(OP,A1,A2,A3,A4,A5)
***
* CREATE A TREE NODE WITH OPERATOR OP AND OPERANDS A1...A5
* RETURN THE ADDRESS
* IF THE NODE ALREADY EXISTS, INCREMENT ITS REFERENCE COUNT
* AND RETURN ITS ADDRESS



       PROGRAM TCNN;
       INCLUDE SCTRE',TCTAB;

* NODE GENERATION FUNCTIONS
       DECLARE SWITCH TOPGFT[29]←(
   TGXNULL,TGXSUB,TGXU,TGXARITH,TGXLNOT,TGXNOT,TGXSET,
   TGXMOD,TGXPOW,TGXNEG,TGXBDOL,TGXCALL,TGXREF,
   TGXLOG,TGXLSFT,TGXBOOL,TGXREL,TGXTAIL,TGXRSFT,
   TGXUNTL,TGXIF,TGXSEQ,TGXERR,TGXSC,TGXFOR,TGXMINUS,
   TGXCAR,TGXNSUB,TGXCON);
*
*
***
*** DISPATCH TABLES FOR TGX ROUTINES
***
* ORDER OF ARITHMETIC TYPES: INTEGER, REAL, DOUBLE, COMPLEX
       DQ TCNNT←4;
*
* RELATIONS
       DECLARE SWITCH TGRTAB[TCNNT]←(
   TGRI,TGRR,TGRD,TGXERR);
* ARITHMETIC OPERATORS
       DECLARE SWITCH TGATAB[TCNNT*4]←(
   TGAPI,TGXERR,TGATI,TGAQI,
   TGAPR,TGXERR,TGATR,TGAQR,
   TGAPD,TGXERR,TGATD,TGAQD,
   TGAPC,TGXERR,TGATC,TGAQC);
* NEGATION
       DECLARE SWITCH TGNTAB[TCNNT]←(
   TGNI,TGNR,TGND,TGNC);
* SUBSCRIPTING OF MACHINE REGISTER
       DECLARE SWITCH TRSTAB[5]←(
   TGSGR,TGSLR,TGSRR,TGSXR,TGSIX);
       DECLARE ARRAY TMSMA[5]←(
        FMASK(INSGD),FMASK(INSLRD),FMASK(INSSRD),
        FMASK(INSGD),FRMASK(BXDDISP));
       DECLARE ARRAY TMSTA[5]←(
        U(ATD,INSTAG),U(ATREL,INSTAG)+U(ASTLR,INSST),
        U(ATREL,INSTAG)+U(ARTSR,INSRT),U(ATX,INSTAG),
        U(ATBXD,INSTAG)+U(BXDNX,BXDINDEX));
* SUBSCRIPTING SEMANTICS
       DECLARE SWITCH TSSTAB[2]←(TGEPD,TGEBX);
* SPECIAL FUNCTION INDICIES FOR ↑
       DECLARE ARRAY TCTPTB[4]←(
        0,0,0,0);*** SOMEDAY
*
*
*** THE FOLLOWING LINE DEPENDS ON
*** THE COMPILER ALLOCATING SCALARS SEQUENTIALLY
       DP A103,A203,A303,A403,A503;
       DP Q03,P03,S03,D03;
       DI N03,H03,J03,U03,V03,W03,AD03,GARBAGE;
       DI T103,T203,Y03,F03;
       DI T03,LONGLONG LL03,INTEGER TL03=LL03;
       DECLARE REAL TR03=LL03,DOUBLE TD03=LL03,COMPLEX TC03=LL03;
       DECLARE INTEGER ARRAY TA03;

ENTRY TCN5(OP03,A103,A203,A303,A403,A503);
       GOTO TCNEE WHERE N03←5;

ENTRY TCN4(OP03,A103,A203,A303,A403);
       GOTO TCNEE WHERE N03←4;

ENTRY TCN3(OP03,A103,A203,A303);
       GOTO TCNEE WHERE N03←3;

ENTRY TCN2(OP03,A103,A203);
       GOTO TCNEE WHERE N03←2;

ENTRY TCN1(OP03,A103);
       GOTO TCNEE WHERE N03←1;

ENTRY TCN0(OP03);
       A103←-1;
       GOTO TCNEE WHERE N03←0;


ENTRY TCNN(OP03,N03,REFERENCE R03);
       GOTO TCNNE;

*
TCNEE: R03←@A103;
TCNNE:
* WRONG NUMBER OF OPERANDS ?
TCND:  CERR(36) IF (J03←TOPTAB[OP03]$TOOC)>0
   AND J03#N03+1;
       IF T03←(F03←TOPTAB[OP03])$TOTAI DO;
            A203←A103 IF N03<2;
            TA03←$NTAA[T03];
            TCTAT(TA03,STAA[T03],@A103,@A203:
             Y03,J03//TCNF);
            IF (H03←((A103.TOPR=OPCON) A' (A203.TOPR=OPCON)))#0
             AND Y03=TTINT DO;
                 V03←A103.TOIV;
                 W03←A203.TOIV;
            ENDIF;
       ENDIF;
       GOTO LABEL'FIXER(TOPGFT[T03]) IF T03←F03$TOGFI;
TGXNULL:
TCNRI: Y03←TTINT;
TCNR:  P03←@TGHT[(A103 LCY 3+OP03) RSH 1 MOD TGLHT];
       WHILE (P03←S03.THPTR WHERE S03←P03) DO;
               IF P03.TOPR=OP03 DO;
                       Q03←P03+TOLE;
                       FOR J03←0 TO N03-1 DO;
                               GOTO TCNX1 IF (T03←R03[J03])#Q03[J03];
                       ENDFOR;
                       P03.TREF←P03.TREF+1;
                       GOTO TCNX0;
TCNX1:         ENDIF;
       ENDFOR;
       P03←TCGET(N03+TOLE);
       BCOPY(P03+TOLE,R03,N03);
       P03.TOPWORD←F03 A' (FMASK(TFLAGS)-FMASK(TDEF));
       P03.TOPR←OP03;
       P03.TTYPE←Y03;
       S03.THPTR←P03;
TCNX0: P03.TICID←NODEID;
       RETURN NODE←P03;
*
TGXU:
TCNRU: Y03←TTUND;
       GOTO TCNR;
* ILLEGAL OPERAND TYPE(S)
TCNF:  CERR(29);


* NODE GENERATION ROUTINES:
* Y03 HAS RESULT TYPE (FROM TCTAT),
* J03 HAS SEMANTIC OP #,
* H03 HAS CONSTANCY FLAG

* TGX ERROR
TGXERR: CERR(37);

* CONSTANT
TGXCON: Y03←(R03)[N03-1];
       GOTO TCNR;

* FUNCTION CALL
TGXCALL: Y03←TTUND;
       T103←A103.TTYPE;
       Q03←TCSE(A203);
       IF T103=TTFIELD AND Q03#0 AND OP03=OPNCALL DO;
            RETURN TCN2(OPTAIL,Q03,A103);
       ELSEIF A103.TOPR=OPVAR DO;
            GOTO TCNR IF (U03←A103.TVTOKEN)=0;
            SSPTR(U03:P03,S03);
            IF T103=TTFUNC DO;
                 Y03←P03.TKTYPE IF S03.SYMODE=SMFUNC;
            ELSEIF S03.SYVAL=0 DO;
                 YGFD(U03:,P03,S03);
                 Y03←P03.TKTYPE;
                 P03.TKPARAM←1;
                 A103←TCVC(U03);
                 GOTO TCNR;
            ELSE DO;
* OBJECT PRECEDING ( IS NOT FUNCTION
TGCE:           CERR(166);
            ENDIF;
       ELSEIF A103.TOPR=OPCHEAT DO;
            V03←TOPTAB[A203.TOPR]$TOOC;
* ILLEGAL USE OF 'CHEATER' FUNCTION ?
            CERR(175) IF V03=0 OR (A203←TCSE(A203))=0;
            V03←V03+TOLE-1;
            MOVE(A203,P03←TCGET(V03),V03);
            P03.TREF←1;
            P03.TTYPE←A103.TO1;
            A203.THPTR←P03;
            GOTO TCNX0;
       ENDIF;
       GOTO TGCE IF T103#TTFUNC ELSE GOTO TCNR;

* SUBSCRIPTING
* MULTI-DIMENSIONAL ARRAYS ARE NOT IMPLEMENTED
TGXSUB: CERR(61);
*
TGXNSUB: Q03←(A203 IF A203.TOPR=OPCON ELSE 0);
       Y03←TTUND;
       IF A103.TOPR=OPREG DO;
* ADDRESS IS NOT SIMPLE ?
               CERR(101) IF Q03=0;
               V03←Q03.TOIV;
               W03←NN TMSMA[U03←A103.TO1];
               GOTO LABEL'FIXER(TRSTAB[U03]);
       ENDIF;
       GOTO LABEL'FIXER(TSSTAB[J03]);
TGEPD: OP03←OPPD;
       GOTO TCNR IF H03=0;
       RETURN TCN1(OPINDIR,TCIC((V03+W03)$IWGD));
TGEBX: OP03←OPBX;
       GOTO TCNR IF A103.TOPR#OPVAR;
       SSPTR(U03←A103.TVTOKEN:P03,S03);
       Y03←P03.TKTYPE IF S03.SYMODE=SMARRAY;
       GOTO TCNR IF A103.TDEF=0 OR Q03=0;
       H03←Q03.TOIV;
       J03←S03.SYVAL;
       IF J03$INSTAG=ATD DO;
            P03←GBASE+J03$INSGD;
       ELSEIF J03$INSTAG=ATREL AND J03$INSRT=ARTSR
   AND (W03←SE(J03$INSSRD,INSSRD))<0 DO;
            P03←ELITBUF+W03;
       ELSE DO;
            GOTO TCNR;
       ENDIF;
       AD03←GET(P03);
       W03←GET(P03+FDISP(AIWADDR));
       IF H03<AD03$AIWORG DO;
* CONSTANT SUBSCRIPT OUT OF RANGE
TGSE:       CERR(163);
       ENDIF;
       IF AD03$AIWLEB DO;
            GOTO TGSE IF H03>AD03$AIWLLIM;
            U03←AD03$AIWLMULT+1;
       ELSE DO;
            GOTO TGSE IF H03>AD03$AIWNLIM;
            U03←AD03$AIWNMULT+1;
       ENDIF;
       H03←(H03-AD03$AIWORG)*U03;
       IF W03$IWTAG=ATX OR W03$IWTAG=ATROX DO;
            V03←W03$IWGD+H03-GBASE;
            GOTO TCNR IF V03>FRMASK(INSGD);
            W03←U(ATD,INSTAG)+U(V03,INSGD);
       ELSEIF W03$IWTAG#ATREL OR W03$IWRELX=0 DO;
            GOTO TCNR;
       ELSEIF W03$IWST=ASTLR DO;
            V03←W03$IWLRD+H03;
            GOTO TCNR IF V03>FRMASK(INSLRD);
            W03←U(ATREL,INSTAG)+U(ASTLR,INSST)+U(V03,INSLRD);
       ELSEIF W03$IWRT=ARTSR DO;
            V03←SE(W03$IWSRD,IWSRD)+H03+FDISP(AIWADDR);
            IF J03$INSTAG=ATD DO;
                 GOTO TCNR IF (V03←V03+J03$INSGD)>FRMASK(INSGD);
                 W03←U(ATD,INSTAG)+U(V03,INSGD);
            ELSE DO;* MUST BE NEGATIVE SOURCE-RELATIVE
                 W03←U(ATREL,INSTAG)+U(ARTSR,INSRT)+
               U(V03+P03-ELITBUF,INSSRD);
            ENDIF;
       ELSE DO;
            GOTO TCNR;
       ENDIF;
       RETURN TCMA(W03,Y03);
TGSIX:
TGSRR: V03←(V03 XOR T03)-T03 WHERE T03←W03/2;
TGSGR:
TGSLR:
TGSXR: GOTO TGSE IF (V03 AA W03)#0;
       V03←V03 LSH FSHIFT(BXDDISP) IF U03=4;
       RETURN TCMA(TMSTA[U03]+V03,TTUND);

* +, -, *, /
TGXMINUS: IF A203.TOPR=OPCON DO;
            A203←TCN1(OPNEG,A203);
            OP03←OPPLUS;
            GOTO TCND;
       ENDIF;
       GOTO TGXARITH;
TGXCAR: IF A203.TOPR=OPCON AND A103.TOPR=OP03 AND (Q03.TOPR=OPCON
        WHERE Q03←A103.TO2) DO;
            A203←TCN2(OP03,Q03,A203);
            A103←A103.TO1;
            GOTO TCND;
       ELSEIF A103.TOPR=OPCON DO;
            Q03←A103;
            A103←A203;
            A203←Q03;
       ENDIF;
TGXARITH: GOTO TCNR IF H03=0
   ELSE GOTO LABEL'FIXER(TGATAB[J03*4+OP03-OPPLUS]);
TGAPI: RETURN TCIC(F(A103,TOIV)+F(A203,TOIV));
TGATI: RETURN TCIC(F(A103,TOIV)*F(A203,TOIV));
TGAQI: RETURN TCIC(F(A103,TOIV)/F(A203,TOIV));
TGAPR: TR03←F(A103,TORV)+F(A203,TORV);
TGAXR: RETURN TCC(TTREAL,@TR03);
TGATR: TR03←F(A103,TORV)*F(A203,TORV);
       GOTO TGAXR;
TGAQR: TR03←F(A103,TORV)/F(A203,TORV);
       GOTO TGAXR;
TGAPD: TD03←F(A103,TODV)+F(A203,TODV);
TGAXD: RETURN TCC(TTDBL,@TD03);
TGATD: TD03←F(A103,TODV)*F(A203,TODV);
       GOTO TGAXD;
TGAQD: TD03←F(A103,TODV)/F(A203,TODV);
       GOTO TGAXD;
TGAPC: TC03←F(A103,TOCV)+F(A203,TOCV);
TGAXC: RETURN TCC(TTCPLX,@TC03);
TGATC: TC03←F(A103,TOCV)*F(A203,TOCV);
       GOTO TGAXC;
TGAQC: TC03←F(A103,TOCV)/F(A203,TOCV);
       GOTO TGAXC;

* LOGICAL NOT
TGXLNOT: RETURN TCIC(NN A103.TOIV) IF H03 ELSE GOTO TCNRI;

* PREDICATE NOT
TGXNOT: RETURN TCIC(V03=0) IF H03 ELSE GOTO TCNRI;

* ASSIGNMENT
* INCOMPATIBLE TYPES ?
TGXSET: CERR(39) IF J03=4 AND Y03#A203.TTYPE;
       GOTO TCNR;

* MOD
TGXMOD: IF Y03=TTINT DO;
               RETURN TCIC(V03 MOD W03) IF H03 ELSE GOTO TCNR;
       ELSE DO;
               RETURN TCN2(OPMINUS,A103,TCN2(OPTIMES,A203,
   TCSF(FNVEC[0],TCCH(TCN2(OPQUOT,A103,A203)))));
       ENDIF;

* **
TGXPOW: GOTO TGWIC IF Y03=TTINT AND H03#0;
       Y03←TTCPLX IF A203.TTYPE#TTINT AND (A103.TOPR#OPCON
   OR A103.TO1<0);
       RETURN TCSF(FNVEC[TCTPTB[J03]],TCN2(OPCHAIN,A103,TCCH(A203)));
TGWIC: RETURN TCIC(0) IF W03<-1 OR V03=0 OR (W03=-1 AND V03#1);
       RETURN TCIC(1) IF W03=0 OR W03=-1;
       J03←1;
       J03←J03*V03 FOR W03←W03-1 BY -1 TO 0;
       RETURN TCIC(J03);

* NEGATE
TGXNEG: GOTO TCNR IF H03=0 ELSE GOTO LABEL'FIXER(TGNTAB[J03]);
TGNI:  RETURN TCIC(-F(A103,TOIV));
TGNR:  TR03←-F(A103,TORV);
       GOTO TGAXR;
TGND:  TD03←-F(A103,TODV);
       GOTO TGAXD;
TGNC:  TC03←-F(A103,TOCV);
       GOTO TGAXC;

* LOGICAL AND, OR, EOR
TGXLOG: RETURN TCIC(V03 AA W03 IF OP03=OPLOGAND
   ELSE V03 VV W03 IF OP03=OPLOGOR ELSE V03 XOR W03)
   IF H03 ELSE GOTO TCNRI;

* RIGHT SHIFT AND CYCLE
TGXRSFT: A203←TCN1(OPNEG,A203);
       OP03←(OPLSH IF OP03=OPRSH ELSE OPLCY);
       GOTO TCND;
* LEFT SHIFT AND CYCLE
TGXLSFT: GOTO TCNRI IF H03=0;
       IF W03>=0 DO;
            V03←(V03 LSH W03 IF OP03=OPLSH ELSE V03 LCY W03);
       ELSE DO;
            W03←-W03;
            V03←(V03 RSH W03 IF OP03=OPLSH ELSE V03 RCY W03);
       ENDIF;
       RETURN TCIC(V03);

* PREDICATE AND, OR
TGXBOOL: RETURN (TCIC(V03 A' W03 IF OP03=OPAND
   ELSE V03 V' W03) WHERE (V03←(V03#0) & W03←(W03#0)))
   IF H03 ELSE GOTO TCNRI;

* RELATIONS
TGXREL: U03←A303.TOIV;
       IF J03=4 DO;
               IF Y03=A203.TTYPE AND (U03=OREQ OR U03=ORNE) DO;
                       OP03←OPLREL;
                       GOTO TCNRI;
               ELSE DO;
* TYPES DO NOT MATCH
                       CERR(42);
               ENDIF;
       ENDIF;
       GOTO TCNRI IF H03=0
   ELSE GOTO LABEL'FIXER(TGRTAB[J03]);
TGRI:  TL03←A103.TOIV-A203.TOIV;
TGRX:  RETURN TCIC((U03 IF TL03<0 ELSE U03 RSH 2 IF TL03>0
   ELSE U03 RSH 1) AA 1);
TGRR:  TR03←A103.TORV-A203.TORV;
       GOTO TGRX;
TGRD:  TD03←A103.TODV-A203.TODV;
       GOTO TGRX;

* TAILING
TGXTAIL: Y03←TTUND;
       IF A203.TOPR=OPCON DO;
               J03←A203.TO2;
       ELSEIF A203.TOPR=OPVAR DO;
               J03←A203.TVTOKEN;
       ELSE DO;
               GOTO TGTL;
       ENDIF;
       SSPTR(J03:P03,S03);
       Y03←P03.TKTYPE IF S03.SYMODE=SMFIELD;
TGTL:  IF A203.TOPR=OPCON AND (J03$FIWBL=24 WHERE J03←A203.TOIV) DO;
*** THIS ISN'T QUITE RIGHT
            A203←TCIC(J03$FIWDISP);
            OP03←OPPD;
            GOTO TCNR;
       ELSE DO;
            OP03←OPBX;
            Q03←A103;
            A103←A203;
            A203←Q03;
       ENDIF;
       GOTO TCNR;

* UNTAILING
TGXUNTL: GOTO TCNRI IF H03=0;
       W03←A203.TOIV;
       RETURN TCIC(A103.TOIV LSH (24-W03$FIWBL) RSH W03$FIWBA);

* BINARY $
TGXBDOL: GOTO TGBD1 IF A203.TOPR#OPCON OR (A103.TOPR#OPCON
   AND A103.TOPR#OPVAR);
       W03←A203.TOIV;
       Y03←W03$FIWDISP;
       T103←A103.TTYPE;
* WORD DISPLACEMENT OUT OF RANGE ?
       CERR(91) IF T103#TTUND AND (Y03<0 OR Y03>=TTLTAB[T103]);
       J03←24-W03$FIWBL;
       IF A103.TOPR=OPCON DO;
            V03←A103[FDISP(TO1)+Y03] LSH W03$FIWBA RSH J03;
            RETURN TCIC(V03 IF W03$FIWSIGN=0 OR
          V03 LSH J03>=0 ELSE V03-2 LSH J03);
       ELSEIF J03=0 DO;
            SSPTR(A203.TO2:P03,GARBAGE);
            RETURN TCMA(A103.TADDR+Y03,P03.TKTYPE);
       ELSE DO;
TGBD1:      RETURN TCN2(OPTAIL,TCN1(OPREF,A103),A203);
       ENDIF;

* IF
TGXIF: RETURN (A203 IF V03 ELSE A303) IF H03;
       Y03←A203.TTYPE;
       F03$TWFF←1 IF A203.TEFF#0 AND (A303.TEFF#0 OR A303.TOPR=OPNIL);
       GOTO TCNR;

* &
TGXSEQ: RETURN A203 IF A103.TOPR=OPCON;
       Y03←F(A203,TTYPE);
* OPERAND OF & OR WHERE HAS NO EFFECT ?
       CERR(171) IF A103.TEFF=0;
       F03$TWFF←0 IF A203.TEFF=0;
       GOTO TCNR;

* CHAINED STRING CONSTANTS
TGXSC: Y03←TTSTR;
       GOTO TCNR;

* REFERENCE
TGXREF: GOTO TCNRI IF A103.TOPR#OPVAR
   ELSE GOTO TGG IF A103.TTYPE=TTUND AND A103.TVTOKEN#0
   ELSE (GOTO TCNRI IF W03#W03$INSGD+U(ATD,INSTAG)
   WHERE W03←A103.TADDR);
       RETURN TCIC(W03$INSGD+GBASE);
TGG:   A103←TCLAB(A103);
       GOTO TCNRI;

* FOR, WHILE
TGXFOR: F03$TWFF←1 IF A103.TEFF;
       GOTO TCNRU;

***
*** TCINIT(K)
***
* INITIALIZE THE TREE BUILDER
* SET THE SIZE OF TGHT TO K AND THE SIZE OF TVHT
* TO THE LARGEST POWER OF 2 THAT IS LESS THAN K



       PROGRAM TCINIT;
       INCLUDE SCTRE';


FUNCTION TCINIT(K01);
       TGLHT←K01;
       TVLHM←(TVLHT←4B7 RSH FLLO(K01-1))-TVHLE;
       TGHT←ARRDESC(TREEBOT,TGLHT,1,0);
       TVHTE←(TVHTB←TREEBOT+TGLHT)+TVLHT;
       CLEAR(TREEBOT,0,TGLHT+TVLHT+TOLE);
       TREETOP←(NULLCH←TREEBOT+TGLHT+TVLHT)+TOLE;
       NULLCH.TOPWORD←TONIL;
       RETURN;

***
*** TCGET(K)
***
* GET K WORDS OF TREE SPACE, RETURNING THE ABSOLUTE ADDRESS
* ERROR IF SPACE EXHAUSTED



       PROGRAM TCGET;
       INCLUDE SCTRE';

       DP A02;

FUNCTION TCGET(K02);
       GOTO TCGTE IF (A02←TREETOP)+K02>TREEMEM;
       TREETOP←TREETOP+K02;
       CLEAR(A02,0,K02);
       RETURN A02;
* TREE AREA FULL
TCGTE: CERR(86);

***
*** TCVC(T)
***
* CREATE A NODE FOR THE VARIABLE WITH TN T
* RETURN THE ABSOLUTE ADDRESS



       PROGRAM TCVC;
       INCLUDE SCTRE';

       DP TP04,SP04,HP04,P04;
       DI M04,I04,V04,W04,T04,ARRAY C04[4];
       DM Z04←C04[0];

FUNCTION TCVC(TN04);
       SSPTR(TN04:TP04,SP04);
       TP04.TKUSE←1;
       T04←TP04.TKTYPE;
       V04←SP04.SYVAL;
       M04←SP04.SYMODE;
       T04←TMTTAB[M04] IF M04#SMVALUE;
       IF TP04.TKPARAM#0 AND (M04=SMVALUE OR M04=SMFIELD)
   AND T04#TTLAB DO;
            IF V04$INSTAG=ATREL AND V04$INSST=ASTIM DO;
                 Z04←SE(V04$INSIMV,INSIMV);
                 Z04←U(IWTFLD,IWTYPE)+U(24,FIWBL)+U(Z04,FIWDISP)
               IF T04=TTFIELD;
            ELSE DO;
                 IF V04$INSTAG=ATD DO;
                      P04←GBASE+V04$INSGD;
                 ELSEIF V04$INSTAG=ATREL AND V04$INSRT=ARTSR DO;
                      W04←SE(V04$INSSRD,INSSRD);
                      P04←ELITBUF+W04 IF W04<0 ELSE GOTO TCV1;
                 ENDIF;
                 C04[I04]←GET(P04+I04) FOR I04←TTLTAB[T04]-1 BY -1 TO 0;
            ENDIF;
            P04←(TCC(T04,@C04[0]) IF T04#TTFIELD
          ELSE TCN3(OPCON,Z04,TN04,T04));
            GOTO TCVX;
       ENDIF;
TCV1:  IF (HP04←TCVFI(TN04))=0 DO;
               P04←TCGET(TOLE+1);
               P04.TVTOKEN←TN04;
       ELSEIF (P04←F(HP04,TVHNODE))=0 DO;
               HP04.TVHNODE←P04←TCGET(TOLE+1);
               P04.TO1←HP04.TVHVAL;
       ELSE DO;
               GOTO TCVX;
       ENDIF;
       P04.TOPWORD←TOVAR;
       P04.TICID←NODEID;
TCVX:  E(P04,TTYPE,T04);
       P04.TADDR←V04;
       P04.TDEF←TP04.TKPARAM;
       RETURN P04;

       PROGRAM TCVFI;
       INCLUDE SCTRE';

       DP P05,Q05;
       DI N05;

***
*** TCASG(T)
***
* INCREMENT THE SEQUENCE NUMBER OF THE VARIABLE
* WHICH IS THE NODE AT ABSOLUTE ADDRESS T, IF IT IS ONE

FUNCTION TCASG(Q05);
       IF Q05.TOPR=OPVAR DO;
               RETURN IF (P05←TCVFI(Q05.TVTOKEN))=0;
               P05.TVHSEQ←P05.TVHSEQ+1;
               P05.TVHNODE←0;
       ENDIF;
       RETURN;


***
*** TCVFI(T)
***
* FIND THE VARIABLE WITH TN T IN THE VARIABLE SEQUENCE HT
* INSERT IT IF ABSENT.  IN EITHER CASE RETURN THE ABSOLUTE
* ADDRESS OF THE ENTRY.  RETURN 0 IF HT FULL AND VARIABLE ABSENT

FUNCTION TCVFI(TN05);
       P05←Q05←TVHTB+((TN05 LSH TVLLE) AA TVLHM);
TCVF0: RETURN P05 IF (N05←F(P05,TVHTOKEN))=TN05
   ELSE GOTO TCVF1 IF N05;
       E(P05,TVHTOKEN,TN05);
       E(P05,TVHSEQ,1);
       RETURN P05;
TCVF1: P05←TVHTB IF (P05←P05+TVHLE)=TVHTE;
       GOTO TCVF0 IF P05#Q05;
       RETURN 0;

***
*** TCIC(N)
***
* CREATE A NODE FOR THE INTEGER CONSTANT N
* RETURN THE ABSOLUTE ADDRESS
***
*** TCC(T,R)
***
* CREATE A NODE FOR THE CONSTANT OF TYPE T WHICH IS
* IN THE VARIABLE WHOSE ADDRESS IS R
* RETURN THE ABSOLUTE ADDRESS OF THE NODE



       PROGRAM TCIC;
       INCLUDE SCTRE';

       DI N08;
       DA C08[5];

FUNCTION TCIC(N08);
       RETURN TCN2(OPCON,N08,TTINT);

ENTRY TCC(T08,REFERENCE R08);
       N08←TTLTAB[T08];
       BCOPY(@C08[0],R08,N08);
       C08[N08]←T08;
       RETURN TCNN(OPCON,N08+1,@C08[0]);

***
*** TCTAT(A,R,A1,A2)*
***
* CHECK THE NODES AT $A1 AND $A2 FOR TYPE COMPATIBILITY
* USING THE NORMAL TYPE TABLE A
* AND THE SPECIAL TYPE TABLE $R IF R#0:
* RETURN THE TYPE OF THE RESULT
* AND THE SEMANTIC OPERATOR INDEX.
* FAIL IF THE TYPES ARE ILLEGAL



       PROGRAM TCTAT;
       INCLUDE SCTRE';

       DI T110,T210,V10,X10,T10;
       DECLARE REFERENCE R10,RV10;
       DECLARE POINTER A10,A110,A210;
       DECLARE ARRAY Z10[4]←(0,0,0,0);
* TABLE OF CONVERSION ROUTINES (SEE SINIT ALSO)
       DECLARE SWITCH TMRTAB[8]←(
        TMCU,TMCUI,TMCAR,TMCAR,TMCAR,
        TMCAR,TMCAR,TMCLB);
       DECLARE ARRAY TMFTAB[8]←(
        0,0,1,2,1,2,4,0);

FUNCTION TCTAT(ARRAY Y10,REFERENCE RA10,RA110,RA210), FRETURN;
       R10←@Y10[0];
       RA210←RA110 IF R10.NTTT=NTTUO;
TCTAE: T110←A110.TTYPE WHERE A110←$RA110;
       T210←A210.TTYPE WHERE A210←$RA210;
       IF T110>T210 AND R10.NTTT=NTTCBO DO;
          X10←1;
          V10←TCNTT(T210,T110,R10,Y10//TCTY1);
       ELSE DO;
          X10 ← (0 IF T110 <= T210 ELSE 1);*SEE SPL LOG, VOL. 1, P. 100-101.
          V10←TCNTT(T110,T210,R10,Y10//TCTY1);
       ENDIF;
       GOTO TCTYR;
* NOT IN STANDARD TABLE.  TRY FOR FUNNIES
TCTY1: IF R10.NTSTY DO;
          Y10←$(R10.NTSTY);
          TCSTT(T110,T210,Y10:V10,X10//TCTY2);
          GOTO TCTYR;
       ENDIF;
TCTY2: IF RA10 DO;
          Y10←$RA10;
          TCSTT(T110,T210,Y10:V10,X10//FRETN);
       ELSE DO;
          FRETN;
       ENDIF;
TCTYR: IF V10$ACTYPE=ATE DO;
* *** SEE TYPE TABLES ***
          CERR(V10$ACTNO);
       ELSEIF V10$ACTYPE=ATC DO;
          GOTO LABEL'FIXER(TMRTAB[V10$ACTNO]);
       ENDIF;
TCTAR: RETN (T110,V10$ACTNO);

* CONVERSION ROUTINES

TMCU:  IF (T10←T210)=TTUND DO;
          RV10←RA210;
          T10←T110;
       ELSE DO;
          RV10←RA110;
       ENDIF;
       GOTO TCTAE IF (T110←TCOA(CONTENTS(RV10),T10))#TTUND;
* UNDECLARED VARIABLE
TCTAU: CERR(43);* CONTINUES
       $RV10←TCC(T10,@Z10[0]);
       GOTO TCTAR;

TMCUI: RETN (TTINT,0) IF TCOA(A110,T10←TTINT)=TTINT;
       RV10←RA110;
       GOTO TCTAU;

TMCAR: V10←FNVEC[TMFTAB[V10$ACTNO]];
       IF X10 DO;
          $RA210←TCSF(V10,TCCH(A210));
       ELSE DO;
          $RA110←TCSF(V10,TCCH(A110));
       ENDIF;
       GOTO TCTAE;

TMCLB: T110←(RA110 IF T110=TTUND ELSE RA210);
       A10←$T110;
       $T110←TCLAB(A10) IF A10.TOPR=OPVAR ELSE FRETN IF
        TCOA(A10,TTLAB)#TTLAB;
       T110←TTLAB;
       GOTO TCTAE;

***
*** TCNTT(T1,T2,R,Y)*
***
* LOOK UP <T1,T2> IN TYPE MATRIX AT R AND Y:
* IF COMMUTATIVE (TRIANGULAR), T1<=T2;
* FAIL IF ILLEGAL



       PROGRAM TCNTT;
*****
* 5/4/73  JACK FREEMAN
* HAD TO ADD STDEC TO THE FOLLOWING INCLUDE LIST ONLY BECAUSE TCNTT
* USES THE MACRO GHW, WHICH IS DEFINED IN STDEC.
*****
       INCLUDE SCTRE', STDEC;

       DI I110A,I210A,V10A;
       DECLARE SWITCH TTNTAB[3]←(TTN0,TTN1,TTN2);

FUNCTION TCNTT(T110A,T210A,REFERENCE R10A,ARRAY Y10A), FRETURN;
       I110A←1 LSH T110A;
       FRETN IF (R10A.NTM1 AA I110A)=0;
       I210A←1 LSH T210A;
       FRETN IF (R10A.NTM2 AA I210A)=0;
       I110A←FCOB(R10A.NTM1 AA (I110A-1));
       GOTO LABEL'FIXER(TTNTAB[R10A.NTTT]);
TTN0:  V10A←I110A*R10A.NTNT2;
       GOTO TTNBR;
TTN1:  V10A←I110A*(2*R10A.NTNT2-I110A-1)/2;
TTNBR: I210A←FCOB(R10A.NTM2 AA (I210A-1));
       V10A←2*NTORG+I210A+V10A;
TTNR:  V10A←GHW(Y10A,V10A);
       FRETN IF V10A=U(ATE,ACTYPE) ELSE RETN V10A;
TTN2:  V10A←2*NTORG+I110A;
       GOTO TTNR;

***
*** TCSTT(T1,T2,Y)*
***
* LOOK UP <T1,T2> IN SPECIAL TYPE TABLE Y
* FAIL IF MISSING



       PROGRAM TCSTT;
       INCLUDE SCTRE';

       DI I10B;
       DECLARE REFERENCE R10B,E10B,Q10B;

FUNCTION TCSTT(T110B,T210B,ARRAY Y10B), FRETURN;
       T110B←1 LSH T110B;
       T210B←1 LSH T210B;
       R10B←@Y10B[0];
       E10B←R10B+ARRAYSIZE(Y10B)-STLE;
       FOR Q10B←R10B BY STLE TO E10B DO;
          IF (Q10B.STT1 AA T110B)#0 AND (Q10B.STT2 AA T210B)#0 DO;
             RETN (Q10B.STACT,0);
          ELSEIF Q10B.STCOMM#0 AND (Q10B.STT2 AA T110B)#0 AND
           (Q10B.STT1 AA T210B)#0 DO;
             RETN (Q10B.STACT,1);
          ENDIF;
       ENDFOR;
       FRETN;

***
*** TCOA(A,T)
***
* CHECK THAT THE TYPE OF THE NODE AT A IS T
* (MAKE IT T IF IT IS UNDEFINED AND NOT A VARIABLE)
* RETURN THE ULTIMATE TYPE OF A



       PROGRAM TCOA;
       INCLUDE SCTRE';

       DI V11;

FUNCTION TCOA(POINTER A11,INTEGER T11);
       IF (V11←A11.TTYPE)=TTUND DO;
               A11.TTYPE←V11←T11 IF A11.TOPR#OPVAR
          OR A11.TVTOKEN=0;
       ENDIF;
       RETURN V11;

***
*** TCSF(P,C) ###
***
* CONSTRUCT A SPECIAL FUNCTION CALL NODE
* SPECIAL FUNCTION NUMBER P, OPERAND CHAIN C
***
*** TCCH(A)
***
* MAKE A CHAIN OUT OF THE NODE A



       PROGRAM TCSF;
       INCLUDE SCTRE';

       DI W12,T12,GARBAGE;
       DP P12;

FUNCTION TCSF(J12,POINTER C12);
       YGFD(-J12:W12,T12,GARBAGE);
       P12←TCN2(OPNCALL,TCMA(W12,TTFUNC),C12);
       P12.TTYPE←T12;
       RETURN P12;


FUNCTION TCCH(POINTER A12);
       RETURN TCN2(OPCHAIN,A12,TCN0(OPNIL));

***
*** TCSE(A)*
***
* IF A IS A CHAIN WITH A SINGLE ELEMENT,
* RETURN THE ELEMENT, OTHERWISE RETURN 0



       PROGRAM TCSE;
       INCLUDE SCTRE';

       DP P13;

FUNCTION TCSE(POINTER A13);
       RETURN 0 IF A13.TOPR#OPCHAIN;
       P13←A13.TO2;
       RETURN (0 IF P13.TOPR#OPNIL ELSE A13.TO1);

***
*** TCMA(W,T)*
***
* CREATE A NODE WITH OP=VAR, ADDRESS=W, TYPE=T



       PROGRAM TCMA;
       INCLUDE SCTRE';

       DP P14;

FUNCTION TCMA(W14,T14);
       P14←TCN1(OPVAR,-1);
       P14.TVTOKEN←0;
       P14.TADDR←W14;
       P14.TTYPE←T14;
       RETURN P14;

***
*** TCLAB(A)*
***
* MAKE THE VARIABLE IN THE NODE A INTO A LABEL
* RETURN A NEW VARIABLE NODE



       PROGRAM TCLAB;
       INCLUDE SCTRE';

       DI TN17;
       DP TP17,SP17;

FUNCTION TCLAB(POINTER A17);
       SSPTR(TN17←A17.TVTOKEN:TP17,SP17);
       SP17.SYVAL←U(1,BACHN);
       TP17.TKTYPE←TTLAB;
       TP17.TKIMPL←1;
       TP17.TKPARAM←1;
       RETURN TCVC(TN17);

***
*** TCPNT(A)*
***
* A DEBUGGING ROUTINE TO PRINT THE TREE AT ADDRESS A



       PROGRAM TCPNT;
       INCLUDE SCTRE';


FUNCTION TCPNT(POINTER P1X);
       TPSUB(P1X,0);
       COUT('&/', -1);
       RETURN;



       PROGRAM TPSUB;
       INCLUDE SCTRE',TCTAB;
* RECURSIVE LOCAL VARIABLES
       DECLARE INTEGER I1X;

       DI N1X,V1X;

FUNCTION TPSUB(POINTER A1X,INTEGER L1X);
       FMTO("/#"); OUT(A1X);
       (CSOUT("****") & RETURN) IF L1X=40;
       CSOUT(" ") FOR N1X←0 TO L1X;
       FMTO("#:"); OUT(A1X.TOPWORD);
       I1X←0;
TPS2:  RETURN IF I1X>=TOPTAB[A1X.TOPR]$TOOC-1;
       V1X←A1X[I1X+TOLE];
       IF I1X<TOPTAB[A1X.TOPR]$TOAOC DO;
               FMTO(" #"); OUT(V1X);
       ELSE DO;
               TPSUB(V1X,L1X+2);
       ENDIF;
       I1X←I1X+1;
       GOTO TPS2;
        COMMON ENTRY'DEFS;

*      THIS COMMON BLOCK CONTAINS THE VARIABLES NECESSARY FOR THE
* PROGRAM BLOCK ENTRIES, SUCH THINGS AS THE SIZE OF THE STACK, THE
* STACK BOUNDS, STACK POINTER, AND STACK LIMIT.

         DECLARE PARAMETER
         STACK'SIZE ← 3000B;

         DECLARE ARRAY
         STACK[STACK'SIZE];

         DECLARE ARRAY
         STATE[10];         /* THE SAVED STATE KEPT BY THE MONITOR   */

         DECLARE PARAMETER
         STACK'POINTER = G' [2],
         STACK'LIMIT = G' [3],
         INITIAL'SP ← @STACK[0],
         INITIAL'SL ← @STACK[STACK'SIZE - 1];

         DECLARE PARAMETER /* INDEXES INTO STATE                    */
         P'INDEX ← 0,       /* PROGRAM COUNTER                       */
         L'INDEX ← 7,       /* LOCAL REGISTER                        */
         G'INDEX ← 8;       /* GLOBAL REGISTER                       */

         DECLARE FIELD /* FOR A SPCS ENTRY                      */
         PC (0:6,23),       /* THE SAVED P-COUNTER                   */
         LR (1:6,23),       /* THE SAVED L-REGISTER                  */
         GR (2:6,23);       /* THE SAVED G-REGISTER                  */

         MACRO SAVE'STATE (CURRENT'STATE) ← .STX CURRENT'STATE[6],
         .EAX CURRENT'STATE[0], .STORS;



         END;

        COMMON MONITOR'CALLS;


******************************
*
* CALLS TO MANIPULATE MULTI-INDEX BLOCKS (MIBS) AND SUB-INDEX BLOCKS (SIBS)
*
******************************

         INTEGER MONITOR CREATE'MIB ← 190;
        UNKNOWN MONITOR READ'MIBOB'INDEX ← 0;     * READ CONTENTS OF ENTRY
        UNKNOWN MONITOR READ'MIBOB'NAME ← 1;      * READ ENTRY
        UNKNOWN MONITOR SET'MIBOB'NAME ← 2;       * SET NAME OF ENTRY
        UNKNOWN MONITOR SET'MIBOB'ACCESS ← 3;     * SET PUBLIC, FRIEND AND OWENER ACCESS OF OBJECT
        UNKNOWN MONITOR SET'LOCK'LIST ← 4;        * SET LOCK AND ACCESS FOR LOCK
        UNKNOWN MONITOR DELETE'MIBOB ← 5;         * DELETE ENTRY
        INTEGER MONITOR CREATE'MIBOB ← 6;         * CREATE NEW ENTRY
        UNKNOWN MONITOR MERGE'MCW ← 9;            * READ OR MERGE THE MIB CAPABILITY WORK (MCW) INTO SPT
        UNKNOWN MONITOR SET'MIB'ACCESS ← 10;      * COPY MIB CAPABILITIES WORD FROM ONE MIB TO ANOTHER
        INTEGER MONITOR READ'MIB'ACCESS ← 11;     * READ MIB ACCESS
        UNKNOWN MONITOR SET'MIBOB'VALUE ← 12;     * SET VALUE OF OBJECT
        INTEGER MONITOR COPY'MIBOB ← 14;          * COPY ACCESS KEY FROM ONE MIB TO ANOTHER (NOT IMPLEMENTED)
        UNKNOWN MONITOR SET'NO'CHARGE ← 15;       * SET NO DRUM CHARGE FLAG FOR FILE
        INTEGER MONITOR READ'MIB'SPACE ← 16;      * READ AVAILABLE SPACE IN MIB
        UNKNOWN MONITOR SET'FILE'LOCK ← 18;       * SET WRITTEN AND REFERENCE DATE ON FILE (NOT IMPLEMENTED)
        UNKNOWN MONITOR SET'DURABILITY ← 28;      * SET THE DURABILITY FIELD OF THE MIB





******************************
*
* OPEN FILE TABLE (OFT) CALLS
*
******************************

         INTEGER MONITOR MON'OPEN'FILE ← 19;       * OPEN OBJECT
        UNKNOWN MONITOR MON'READ'OFT ← 20;        * READ OFT ENTRY
        UNKNOWN MONITOR MON'SET'OFT'AC ← 21;      * SET OFT ACCESS LOCK
        UNKNOWN MONITOR MON'SET'OFT'CL ← 22;      * SET OFT CONTROL LOCK
        UNKNOWN MONITOR SET'FILE'LENGTH ← 23;     * SET WORD LENGTH FOR OFT ENTRY
        INTEGER MONITOR CREATE'FILE'PAGE ← 24;    * CREATE A PRIVATE MEMORY PAGE
        INTEGER MONITOR DEL'FILE'PAGE ← 25;       * DELETE A PAGE OF AN OBJECT
        INTEGER MONITOR NEXT'FILE'PAGE ← 26;      * GET NEXT PAGE OF FILE
        UNKNOWN MONITOR MOVE'PAGE'PMT ← 27;       * PUT REAL NAME OF A PAGE OF A FILE INTO A PMT ENTRY

******************************
*
* PROCESS MEMORY TABLE (PMT) CALLS
*
******************************

         INTEGER MONITOR ACQUIRE'PMT ← 50;         * ACQUIRE AND INITIALIZE A PMT ENTRY
        UNKNOWN MONITOR NEW'PMT'PAGE ← 51;        * CREATE A PRIVATE MEMORY PAGE AND PUT ITS REAL NAME INTO PMT
        UNKNOWN MONITOR COPY'RN'PMT ← 52;         * PUT SPECIFIED REAL NAME INTO A PMT ENTRY
        UNKNOWN MONITOR CLEAR'PMT ← 53;           * RELEASE PAGE FROM PMT ENTRY
        UNKNOWN MONITOR DELETE'PMT ← 54;          * RELEASE PMT ENTRY (RELEASE PAGE FROM PMT ENTRY
        UNKNOWN MONITOR SET'PMT'ACC'LOCK ← 55;    * SET THE ACCESS LOCK OF A PMT ENTRY
        UNKNOWN MONITOR SET'PMT'CON'LOCK ← 56;    * SET THE CONTROL LOCK OF AN PMT ENTRY
        UNKNOWN MONITOR SET'PMT'RO ← 57;          * SET THE READ ONLY BIT IN A PMT ENTRY
        UNKNOWN MONITOR READ'PMT ← 58;            * READ A PMT ENTRY



******************************
*
* WORKING SET CALLS
*
******************************

         UNKNOWN MONITOR PUT'PAGE'DWS ← 65;        * PUT PAGE IN THE DRUM WORKING SET
        UNKNOWN MONITOR PUT'PAGE'CWS ← 66;        * PUT A PAGE IN THE CORE WORKING SET
        INTEGER MONITOR DEL'PAGE'DWS ← 67;        * DELETE A PAGE FROM THE DWS
        INTEGER MONITOR DEL'PAGE'CWS ← 68;        * DELETE A PAGE FROM THE CWS
        INTEGER MONITOR READ'LEN'WS ← 70;         * READ THE LENGTH OF A SPECIFIED THE WORKING SET
        UNKNOWN MONITOR SET'LEN'WS ← 71;          * SET THE OVERFLOW LENGTH OF A SPECIFIED WS



******************************
*
* SUB-PROCESS TABLE (SPT) CALLS
*
******************************

         INTEGER MONITOR MON'CREATE'SP ← 90;       * ACQUIRE AND INITIALIZE AN SPT ENTRY
        UNKNOWN MONITOR MON'DESTROY'SP ← 91;      * DELETE THE CONTENTS OF AN SPT ENTRY
        UNKNOWN MONITOR MON'READ'SPT ← 95;        * READ AN SPT ENTRY
        UNKNOWN MONITOR MON'READ'SPCS ← 96;       * READ AN SPCS ENTRY
        INTEGER MONITOR MON'READ'SPT'FLD ← 97;    * READ A SELECTED FIELD OF AN SPT ENTRY
        UNKNOWN MONITOR MON'SET'SPT'FLD ← 98;     * SET THE VALUE OF A SPECIFIED FIELD OF AN SPT ENTRY
        UNKNOWN MONITOR READ'SPT'MAP ← 99;        * READ THE MAP OF AN SPT ENTRY
        UNKNOWN MONITOR SET'SPT'MAP ← 100;        * SET THE MAP OF AN SPT ENTRY
        INTEGER MONITOR READ'MAP'BYTE ← 101;      * READ A BYTE IN THE MAP OF AN SPT ENTRY
        UNKNOWN MONITOR SET'MAP'BYTE ← 102;       * SET A BYTE IN THE MAP OF AN SPT ENTRY
        UNKNOWN MONITOR READ'ACCESS'KEY ← 103;    * READ AN ACCESS KEY FROM AN SPT ENTRY
        UNKNOWN MONITOR COPY'ACCESS'KEY ← 104;    * COPY AN ACCESS KEY FROM ONE SPT ENTRY TO ANOTHER
        UNKNOWN MONITOR COPY'TAK ← 105;           * COPY THE TEMPORARAY ACCESS KEY
        INTEGER MONITOR READ'SPS'PARAM ← 106;

******************************
*
* SUB-PROCESS CALL STACK (SPCS) CALLS
*
******************************

         UNKNOWN MONITOR SP'CALL ← 111;            * CALL A SUB-PROCESS
        UNKNOWN MONITOR SP'JUMP ← 112;            * JUMP TO A SUB-PROCESS
        UNKNOWN MONITOR SP'TRAP ← 113;            * GENERATE A SOFTWARE TRAP
        UNKNOWN MONITOR TRAP'RETURN ← 114;        * POP UP SUB-PROCESS CALL STACK & GENERATE A SOFTWARE TRAP
        UNKNOWN MONITOR SP'BRANCH ← 115;          * BRANCH INTO A SUB-PROCESS
        UNKNOWN MONITOR SP'RETURN ← 116;          * RETURN TO A CALLING SUB-PROCESS
        UNKNOWN MONITOR JUMP'RETURN ← 117;        * RETURN TO A SPECIFIED LEVEL IN THE SUB-PROCESS CALL STACK
        UNKNOWN MONITOR MARK'CALL ← 118;          * RECORD A FUNCTION CALL ON THE SPCS
        UNKNOWN MONITOR DELETE'CALL ← 119;        * DELETE A FUNCTION CALL FROM THE SPCS
        UNKNOWN MONITOR MODIFY'CALL ← 120;        * CHANGE A FUNCTION CALL ON THE SPCS



******************************
*
* PROCESS CALLS
*
******************************

         INTEGER MONITOR COPY'PMT'PROC ← 130;      * COPY A PMT ENTRY FROM ONE PROCESS TO ANOTHER
        INTEGER MONITOR ACTIVATE'PROC ← 132;      * ACTIVATE A PROCESS
        UNKNOWN MONITOR TRANSFER'TERM ← 133;      * TRANSFER A TERMINAL
        UNKNOWN MONITOR MAKE'DORMANT ← 134;       * MAKE A PROCESS DORMANT
        UNKNOWN MONITOR INIT'PROC'PAGE ← 135;     * INITIALIZE THE UTILITY AREA OF THE CONTEXT BLOCK OR A
*                                                *   PRIVATE MEMORY PAGE IN A NEW PROCESS
         UNKNOWN MONITOR INIT'PROC'MAP ← 136;
        UNKNOWN MONITOR INIT'SPT ← 137;
        INTEGER MONITOR READ'PROC'PARAM ← 211;



******************************
*
* RESOURCE CALLS
*
******************************

* I BELIEVE ONE MOVE'DISK'RES IS IMPLEMENTED, AND WHO CARES?
         UNKNOWN MONITOR READ'RESOURCES ← 145;     * READ THE ITEMS OF THE RESOURCE ALLOCATION
        UNKNOWN MONITOR MOVE'RESOURCES ← 146;     * MOVE RESOURCES FROM ONE OBJECT TO ANOTHER
        UNKNOWN MONITOR SPLIT'TIME ← 147;         * SPLIT RESOURCES FOR TIME
        UNKNOWN MONITOR MERGE'TIME ← 148;         * MERGE RESOURCES FOR TIME
        MONITOR MOVE'DISK'RES ← 149;              * MOVE DISK RESOURCES
*      UNKNOWN MONITOR SPLIT'RESOURCES;
*      UNKNOWN MONITOR MERGE RESOURCES;

******************************
*
* OPERATIONS ON INTERRUPT CHANNEL TABLE (ICT)
*
******************************

         UNKNOWN MONITOR SET'PROC'INT ← 163;       * SET PIW BITS
        INTEGER MONITOR QUIT'BLOCK ← 164;
        INTEGER MONITOR GET'INT'NUM ← 165;        * CONVERT INTERRUPT CHARACTER CONSTANT TO INTERRUPT NUMBER
        INTEGER MONITOR READ'ICT ← 166;           * READ INTERRUPT CELL
        INTEGER MONITOR READ'PIW ← 167;           * READ PROGRAM INTERRUPT WORD (PIW)
        UNKNOWN MONITOR ALLOW'INTS ← 168;         * RESET NON-INTERRUPTABILITY
        UNKNOWN MONITOR REFUSE'INTS ← 169;        * MAKE NON-INTERRUPTABLE
        UNKNOWN MONITOR BLOCK ← 170;              * BLOCK THE PROCESS
        UNKNOWN MONITOR CLEAR'PIW ← 171;          * CLEAR PIW BITS
        UNKNOWN MONITOR SET'ICT ← 172;            * SET INTERRUPT CELL
        UNKNOWN MONITOR SET'ICT'CON'LOCK ← 173;   * SET CONTROL LOCK IN INTERRUPT CELL
        INTEGER MONITOR ACQUIRE'ICT ← 174;        * ACQUIRE INTERRUPT CELL



******************************
*
* CHIO CALLS
*
******************************

         UNKNOWN MONITOR SET'LINE'FIELD ← 180;     * SET THE VALUE OF A PARAMETER FOR THE CHIO LINE
        UNKNOWN MONITOR READ'LINE'TABLE ← 181;    * READ CHIO LINE TABLE
        STRING MONITOR READ'STRING ← 182;         * INPUT STRING FROM CHIO LINE
        STRING MONITOR WRITE'STRING ← 183;        * OUTPUT A STRING ONTO A CHIO LINE



******************************
*
* MISCELLANEOUS
*
******************************

         MONITOR ACQUIRE'SEM ← 29;                 * ACQUIRE SEMAPHORE (NOT IMPLEMENTED)
        MONITOR RELEASE'SEM ← 30;                 * (NOT IMPLEMENTED)
        MONITOR DIAGNOSTIC'DIO ← 59;              * DIRECT INPUT/OUTPUT?
        MONITOR KLUDGE'IO ← 128;                  * VARIATION OF DIAGNOSTIC'DIO?
        UNKNOWN MONITOR DO'POT'PIN ← 129;         * HARDWARE KLUDGE
        LONG MONITOR READ'CLOCK ← 210;            * READ REAL-TIME CLOCK
        MONITOR READ'WRITE'CM ← 255;              * READS AND WRITES INTO CENTRAL MEMORY


         END;

        COMMON UTILITY'CALLS;

******************************
*
* MISCELLANEOUS UCALLS
*
******************************

         UNKNOWN UTILITY BREAK'POINT ← 0;          * UCALL FOR DEBUGGING PROGRAMS
        STRING UTILITY ERRORMSG ← 1;              * RETURN SYSTEM ERROR MESSAGE
        STRING UTILITY GET'PARAM ← 2;             * STRIP PARAMETER FROM STRING
        STRING UTILITY GET'COM'LINE ← 3;          * GET CURRENT COMMAND LINE FROM UTS
        INTEGER UTILITY ABRV'LKP ← 4;             * LOOK UP ABBREVIATED NAME IN STRING ARRAY
        INTEGER UTILITY CON'ABRV'LKP ← 5;         * CONTINUE SAME IN NEW STRING ARRAY
        STRING UTILITY GET'CMP'COMLINE ← 6;       * GET SAVED COMMAND LINE AND USER NUMBER OF ATTACHED FILE
        UNKNOWN UTILITY SET'COM'LINE ← 7;         * SET THE SAVED COMMAND LINE

******************************
*
* FILE SYSTEM CALLS
*
******************************

         UNKNOWN UTILITY NAME'SEARCH ← 10;         * CONVERT FILE ST TO UTS NAME
        UNKNOWN UTILITY SPECIAL'SEARCH ← 11;      * VARIATION OF ABOVE
        INTEGER UTILITY CONV'NAME ← 12;           * CONVERT FROM UTS TO MON FILE NAME
        LONG UTILITY SPREAD'NAME ← 13;            * SPLIT FILE NAME STRING INTO COMP.
        UNKNOWN UTILITY READ'MIBOB'VALUE ← 14;    * READ 'VALUE' OF MIB OBJECT
        UNKNOWN UTILITY DELETE'FILE ← 15;         * DELETE FILE AND CONTENTS
        INTEGER UTILITY OPEN'FILE ← 16;           * OPEN FILE W/WO LOCKING
        UNKNOWN UTILITY CLOSE'FILE ← 17;          * CLOSE AND UNLOCK FILE
        UNKNOWN UTILITY READ'OFT ← 18;            * READ OFT
        INTEGER UTILITY READ'OFT'FIELD ← 19;      * READ OFT FIELD
        UNKNOWN UTILITY SET'OFT'CL ← 20;          * SET OFT CONTROL LOCK
        INTEGER UTILITY CONV'KEY ← 21;            * CONVERT DEFAULT ACCESS KEY


******************************
*
* EXTENDED SUB-PROCESS SYSTEM (SPS) CALLS
*
******************************

         INTEGER UTILITY CREATE'SSP ← 30;          * CREATE SUBSIDIARY SUB-PROCESS
        INTEGER UTILITY CREATE'PSP ← 31;          * CREATE PARALLEL SUB-PROCESS
        UNKNOWN UTILITY ATTACH ← 32;              * ATTACH PIF FILE TO SUB-PROCESS
        UNKNOWN UTILITY DESTROY'SP ← 33;          * DESTROY SUB-PROCESSES
        UNKNOWN UTILITY READ'SPT ← 34;            * READ SPT
        INTEGER UTILITY READ'SPT'FIELD ← 35;      * READ SPT FIELD
        UNKNOWN UTILITY SET'SPT'FIELD ← 36;       * SET SPT FIELD
        STRING UTILITY READ'SPNAME ← 37;          * READ SUB-PROC NAME
        UNKNOWN UTILITY SET'SPNAME ← 38;          * SET SUB-PROC NAME
        INTEGER UTILITY SPNAME'SEARCH ←39;        * LOOK UP SP NAME

******************************
*
* CONTROL INPUT/OUTPUT STREAMS (CIOS) MANIPULATION
*
******************************

         INTEGER UTILITY CREATE'CIOS ← 40;         * CREATE CONTROL I/O STREAM
        INTEGER UTILITY READ'CIOS'FIELD ← 41;     * READ CIOS FIELD
        UNKNOWN UTILITY SET'CIOS'FIELD ← 42;      * SET (SOME) CIOS FIELDS
        UNKNOWN UTILITY SET'CIOS'INPUT ← 43;      * SET UP FOR INPUT
        UNKNOWN UTILITY SET'CIOS'OUTPUT ← 44;     * SET UP FOR OUTPUT



******************************
*
* CIOS INPUT/OUTPUT
*
******************************

         UNKNOWN UTILITY PRINT'STRING ← 45;        * WRITE STRING ON CIOS
        UNKNOWN UTILITY PRINT'CHAR ← 46;          * WRITE CHAR ON CIOS
        UNKNOWN UTILITY START'OUTPUT ← 47;        * DUMP OUTPUT BUFFER
        STRING UTILITY READ'LINE ← 48;            * READ NEXT INPUT LINE
        STRING UTILITY EDIT'LINE ← 49;            * EDIT CURRENT LINE
        CHARACTER UTILITY READ'CHAR ← 50;         * READ NEXT CHARACTER
        UNKNOWN UTILITY BLOCK'OB'EMPTY ← 51;      * WAIT UNTIL OUT BUFFER IS EMPTY



******************************
*
* USER, ACCOUNT, AND GROUP PROFILES
*
******************************

         STRING UTILITY READ'UP'ITEM ← 60;         * READ ITEM FROM USER PROFILE
        STRING UTILITY READ'UP'NAMES ← 61;        * READ NAMES OF UP ITEMS
        UNKNOWN UTILITY SET'UP'ITEM ← 62;         * SET (CREATE) VALUE OF UP ITEM
        UNKNOWN UTILITY SET'UP'ACCESS ← 63;       * SET ACCESS TO UP ITEM
        LONG UTILITY FIND'MIB ← 64;               * CONVERT USER NAME/NUMBER TO MIB ADDR
        INTEGER UTILITY CREATE'UP'ENTRY ← 65;     * CREATE USER/UP ENTRY
        UNKNOWN UTILITY DELETE'UP'ENTRY ← 66;     * DELETE USER/UP ENTRY

******************************
*
* PROCESSES, AND PROCESS PROFILE
*
******************************

         UNKNOWN UTILITY CREATE'PROCESS ← 70;      * CREATE/INITIALIZE PROCESS
        STRING UTILITY READ'PP'ITEM ← 71;         * READ ITEM FROM PROCESS PROFILE
        STRING UTILITY READ'PP'NAMES ← 72;        * READ NAMES OF PP ITEMS
        UNKNOWN UTILITY SET'PP'ITEM ← 73;         * SET (CREATE) VALUE OF PP ITEM
        UNKNOWN UTILITY DESTROY'PROCESS ← 74;     * DESTROY THIS PROCESS



******************************
*
* TIME CALCULATIONS
*
******************************

         INTEGER UTILITY SYS'TIME'NUM ← 80;        * NUMERICAL SYSTEM TIMES
        INTEGER UTILITY ANY'TIME'NUM ← 81;        * CHARACTER SPECIFIC TIMES
        STRING UTILITY ANY'TIME'CHAR ← 82;        * CHARACTER SPECIFIC TIMES 


         END;

        COMMON SEQ'FILE'DEFS;

*      THIS COMMON BLOCK CONTAINS THE DECLARATIONS OF IDENTIFIERS
* USED IN FILE HANDLING OPERATIONS.

         DECLARE ARRAYONE /* ARRAY DETERMINING WHICH FILES ARE OPEN */
         OPEN'FILE'TABLE[16];

         DECLARE FIELD
         PAGE'NUM'ADDR /* THE PAGE NUMBER OF THE ADDRESS         */
         (0:6,12),
         PAGES'IN'FILE /* NUMBER OF PAGES IN THE FILE            */
         (0:2,12),
         WORDS'IN'PAGE /* WORD NUMBER IN THE LAST PAGE           */
         (0:13,23);

         DECLARE PARAMETER
         A'PAGE ← 2048;   /* WORDS TO A PAGE                        */

         DECLARE PARAMETER /* FOR IOFLAG VALUES                      */
         READ'FILE ← 0,
         WRITE'FILE ← 1,
         APPEND'FILE ← 2;

         DECLARE PARAMETER /* FOR OBJECT TYPES                       */
         SMALL'FILE ← 0,
         LARGE'FILE ← 1;

         DECLARE PARAMETER /* FOR FILE TYPES                         */
         SUBCOMMAND'FILE ← 6'9SUB',
         SAVE'FILE ← 6'9SAV',
         BINARY'FILE ← 6'9BIN',
         SYMBOLIC'FILE ← 6'9SYM',
         DUMP'FILE ← 6'9DMP',
         UNKNOWN'FILE ← 6'    ';

         DECLARE PARAMETER /* FOR THE MAXIMUM LENGTH OF FILENAMES    */
         LENGTH'PFS'NAMES ← 13,
         LENGTH'TSS'NAMES ← 16;



         END;

        COMMON WINDOW'DEFS;

* THIS COMMON BLOCK DECLARES THE STRUCTURE OF A WINDOW DESCRIPTOR

         DECLARE PARAMETER
         NUM'SEQ'FILES ← 6;

         DECLARE ARRAY
         SEQ'FILE'TABLE[NUM'SEQ'FILES:21];

         DECLARE SIGNED FIELD
         PAGE'IN'WINDOW (0:0,11); /* PAGE NUMBER OF THE FILE        */

         DECLARE FIELD
         PMT'INDEX (0:12,19),     /* PMT INDEX OF THE FILE          */
         WINDOW'IN'USE (0:20,20), /* BIT SIGNALING THE WINDOW IS IN */
/*     USE                        */
         LARGE'OR'SMALL (0:21,21),/* LARGE OR SMALL FILE            */
         OPERATION (0:22,23),     /* BITS REPRESENTING WHAT WILL BE */
/*   DONE TO THE FILE             */
         FILE'NUM (1:1,5),        /* NUMBER OF THE FILE             */
         WINDOW'ADDRESS (1:6,23), /* ADDRESS OF THE WINDOW IN USE   */
         CHARACTER'SIZE (2:0,5),  /* NUMBER OF BITS PER CHARACTER   */
         CHARS'PER'WORD (2:6,8),  /* NUMBER OF CHARACTERS PER WORD  */
         CHARS'PER'PAGE (2:9,23), /* NUMBER OF CHARACTERS PER PAGE  */
         NAME'STORAGE (3);        /* STORAGE FOR THE M1 FORMATTED   */
/*   NAME                         */

         DECLARE STRING FIELD
         READ'DESC (11);          /* STRING DESCRIPTOR FOR A FILE   */
/*   WHICH WILL BE READ           */

         DECLARE FIELD
         CHARS'LEFT (15);         /* NUMBER OF CHARACTERS YET TO BE */
/*  READ FROM THE FILE (AFTER THE */
/*  CURRENT PAGE HAS BEEN READ)   */

         DECLARE STRING FIELD
         WRITE'DESC (16);         /* STRING DESCRIPTOR OF A FILE    */
/*   WHICH WILL BE READ           */

         DECLARE FIELD
         LENGTH'IN'CHARS (20);    /* NUMBER OF CHARACTERS ALREADY   */
/*   WRITTEN INTO THE FILE (AFTER */
/*   THE LAST PAGE HAD BEEN       */
/*   WRITTEN)                     */

         DECLARE ARRAY
         SEQ'FILE'WINDOWS[NUM'SEQ'FILES] ← (100000B, 104000B, 110000B,
         114000B, 120000B, 124000B);



         END;

        COMMON ERROR'DEFS;

*      THIS COMMON BLOCK DECLARES ALL THE VARIABLES USED TO PRINT OUT
* ERROR MESSAGES AND THE MACROS USED IN THE FAILURE RETURN FIELD OF
* FUNCTION CALLS.

* BE CAREFUL, MACROS!
         MACRO WARNING ← RUNTIME'FAILURE() & FRETURN;
        MACRO CATASTROPHE ← FATAL'ERROR() & FRETURN;
        MACRO DISTRESS ← SYSTEM'ERROR() & FRETURN :
         ERROR'CODE, ERROR'NUMBER;

         DECLARE PARAMETER
         DEBUGGING ← -1;    /* A FLAG WHICH WHEN SET CAUSES NOTIFI- */
/* CATION OF MOST FAILURES TO BE PRINT- */
/*  ED OUT AT THE LOWEST POSSIBLE LEVEL */

         DECLARE INTEGER
         ERROR'CODE,        /* CHARACTER CODE OF ERROR              */
         ERROR'FILE'NUM,    /* THE FILE NUMBER USED BY THE FORMAT-  */
/*  TING OUTPUT FUNCTIONS               */
         ERROR'NUMBER,      /* NUMERICAL CODE OF ERROR              */
         RADIX;             /* THE RADIX OF NUMBERS OUTPUT BY THE   */
/*   FORMATTING OUTPUT FUNCTIONS        */

         DECLARE STRING
         ERROR'STRING (200);/* THE STRING USED BY THE FORMATTING    */
/*   OUTPUT FUNCTIONS                   */



         END;

        COMMON STRING'DEFS;

*      THIS COMMON BLOCK DEFINES ALL THE FIELDS USED TO MANIPULATE
* STRINGS WITH.

         INCLUDE ERROR'DEFS;

         DECLARE FIELD
         BP (0),            /* BEGIN POINTER                         */
         RP (1),            /* READ POINTER                          */
         WP (2),            /* WRITE POINTER                         */
         EP (3);            /* END POINTER                           */

         DECLARE FIELD
         CHAR'SIZE (0:2,3), /* THE SIZE OF CHARACTERS IN THE STRING  */
/*   (0 = 6 BITS, 1 = 8 BITS,            */
/*   2 = 12 BITS, AND 3 = 24 BITS)       */
         CHAR'POSITION /* THE CHARACTER POSITION IN THE WORD    */
         (0:4,5),
         CHAR'ADDRESS /* THE ADDRESS OF THE STRING POINTER     */
         (0:6,23);

         DECLARE FIELD /* FOR 6 BIT CHARACTERS                  */
         CHAR6'0 (0:0,5),
         CHAR6'1 (0:6,11),
         CHAR6'2 (0:12,17),
         CHAR6'3 (0:18,23);

         DECLARE FIELD /* FOR 8 BIT CHARACTERS                  */
         CHAR8'0 (0:0,7),
         CHAR8'1 (0:8,15),
         CHAR8'2 (0:16,23);

         DECLARE FIELD /* FOR 12 BIT CHARACTERS                 */
         CHAR12'0 (0:0,11),
         CHAR12'1 (0:12,23);

         DECLARE STRING FIELD /* A KLUDGE SO THAT WHEN THE POINTER TO  */
         STRING'DESC (0);   /*   ONE STRING DESCRIPTOR IS ASSIGNED   */
/*   TO ANOTHER, SPL WILL DO THE RIGHT   */
/*   THING (MOVE 4 WORDS)                */

* THIS ALLOWS PROGRAM BLOCKS TO USE SOMETHING OTHER THAT LARGE LOCAL
* STRINGS FOR TEMPORARY STORAGE
         DECLARE ARRAY
         TEMP'STRING'STOR[100];

         DECLARE PARAMETER ARRAY
         POSS'CHAR'SIZES[4] ← (6, 8, 12, 24);



         END;

        COMMON SPECIAL'CHARS;

*      THIS COMMON BLOCK DECLARES ALL THE SPECIAL CHARACTERS USED IN
* THIS PROGRAM OTHER THAN THOSE NEED BY THE DTP FUNCTIONS.

         DECLARE PARAMETER /* FOR 940 CHARACTER CONSTANTS          */
         BLANK ← 0,
         MB ← 135B,          /*   940 MULTIPLE BLANK CHARACTER       */
         EOF ← 137B,         /*   940 END OF FILE CHARACTER          */
         NULL ← 140B,        /*   940 NULL CHARACTER                 */
         LF ← 152B,          /*   940 LINE FEED                      */
         CNTL'A ← 225,       /*   940 CONTROL-A                      */
         CR ← 155B;          /*   940 CARRIAGE RETURN                */

         DECLARE PARAMETER /* FOR M1 CHARACTER CONSTANTS           */
         ESCAPE'CHAR ← 37B,  /*   FOR I/O THROUGH THE CHIO           */
         M1'MB ← 200B,       /*   M1 MULTIPLE BLANK CHARACTER        */
         M1'NULL ← 300B,     /*   M1 NULL CHARTER                    */
         M1'NL ← 307B,       /*   M1 NEW LINE CHARACTER (A 940 CRLF) */
         M1'LF ← 310B,       /*   M1 LINE FEED                       */
         INQUISITION'CHAR ← 345B,
/* THE CHARACTER SEND BY THE INQUISITOR */
         M1'CR ← 355B;       /*   M1 CARRIAGE RETURN                 */

         DECLARE PARAMETER
         ASCII'NULL ← 0,
         ASCII'LF ← 12B,
         ASCII'CR ← 15B,
         ASCII'BLANK ← 40B;


         END;

        COMMON ARRAY'DEFS;

*      THIS COMMON BLOCK DEFINES ALL THE FIELDS USED TO MANIPULATE
* ARRAYS WITH.

         DECLARE FIELD /* FOR THE ARRAY DESCRIPTOR ITSELF       */
         INDEXING'ORIGIN (0:2,2),
         ARRAY'TRAP'BIT (0:3,3),
         LEB (0:4,4),
         ITEM'SIZE'LEB0 (0:5,6),
         ITEM'SIZE'LEB1 (0:5,10),
         UPPER'BOUND'LEB0 (0:7,23),
         UPPER'BOUND'LEB1 (0:11,23),
         ARRAY'DESC'ADDR (1);

         DECLARE FIELD /* FOR GENERAL INDIRECT ADDRESS WORDS    */
         IAW'TYPE (0:0,1),
         IAW'TAG (0:2,4),
         IAW'TRAP (0:5,5),
         IAW'ADDRESS (0:6,23);

         DECLARE PARAMETER /* FOR IAW'TYPE                          */
         NORMAL'IAW ← 0,
         FIELD'IAW ← 1,
         STRING'IAW ← 2,
         ARRAY'IAW ← 3;

         DECLARE PARAMETER /* FOR IAW'TAG                           */
         DIRECT ← 0,
         INDIRECT ← 1,
         INDEXED ← 2,
         BASE'INDEXED ← 3,
         POINTER'DISP ← 4,
         IND'PTR'DISP ← 5,
         BASE'INDEX'DISP ← 6,
         RELATIVE ← 7;


         END;

        COMMON GLOBAL'VARIABLES;

* THIS BLOCK CONTAINS GENERAL CONSTANTS AND VARIABLES USED THROUGHOUT
*   THE PROGRAM

         INCLUDE MONITOR'CALLS, UTILITY'CALLS, STRING'DEFS,
         SEQ'FILE'DEFS, WINDOW'DEFS, ERROR'DEFS,
         SPECIAL'CHARS;

         DECLARE PARAMETER /* FOR SETTING FLAGS */
         NO ← 0,
         YES ← 1;

         DECLARE INTEGER
         INIT'STACK'LEVEL,  /* STACK LEVEL UPON ENTRY */
         THIS'SUB'PROCESS;  /* CURRENT SUB-PROCESS INDEX INTO THE SPT*/


         END;

        PROGRAM INITIALIZE;

*      THIS FUNCTION SETS UP THE TABLES SHOWING HOW MANY FILES ARE OPEN
* (THIS IS FOR THE USE OF THE FILE HANDLING FUNCTIONS, IT DOESN'T HAVE 
* TO BE CORRECT AND KNOW ABOUT ALL THE FILES A USER HAS OPEN.  THE MON-
* TOR HAS THE TRUTH COPY.) AND THE WINDOWS IN USE.
*      THE FUNCTION ALSO INITIALIZES THE GLOBAL VARIABLES USED BY THIS
* THIS PROGRAM.

         INCLUDE GLOBAL'VARIABLES;

         DECLARE ARRAY
         FORMATTED'NAME[8]; /* THE MONITOR FORMATTED NAME OF THE     */
/*   EMULATOR                            */

         DECLARE INTEGER
         FLAG,
         OPEN'FILE'NUM,
         SEQ'FILE'NUM,
         TM'BITS'SET,       /* THE TRAPS WHICH THE USER IS ALLOWED   */
/*   TO HANDLE                           */
         USER'ACCESS'KEY;

         DECLARE LONG
         DISK'ADDRESS /* ONLY USEFUL WHEN THE CELL IS USED AS A*/
         ← (0, 0);        /*   TIMER                               */


         FUNCTION INITIALIZE(FLAG);

* DETERMINE STACK LEVEL UPON ENTRY
         INIT'STACK'LEVEL ← READ'SPS'PARAM('CSL'//
         INIT'FAIL: ERROR'CODE, ERROR'NUMBER);

* DETERMINE CURRENT SUB-PROCESS NUMBER
         THIS'SUB'PROCESS ← READ'SPS'PARAM('CSP'//
         INIT'FAIL: ERROR'CODE, ERROR'NUMBER);
        ALLOW'INTS();

* SET UP A LOOP TO SHOW THAT EACH WINDOW IS AVAILABLE FOR USE
         FOR SEQ'FILE'NUM ← 0 TO NUM'SEQ'FILES-1 DO;
            SEQ'FILE'TABLE[SEQ'FILE'NUM]$WINDOW'IN'USE ← NO;
        ENDFOR;

*      SET THE FILE NUMBERS TO -1 (IF OPEN'FILE'TABLE[OPEN'FILE'NUM]
* # -1 IT CONTAINS THE NUMBER OF THE WINDOW THE FILE USES)
         FOR OPEN'FILE'NUM ← 1 TO 16 DO;
            OPEN'FILE'TABLE[OPEN'FILE'NUM] ← -1;
        ENDFOR;

*      INSERT FUNCTION ENTRY HERE!!!!!!!!!!!!!!!!!!!!!!!
         DEBUGGER(FLAG);

INIT'FAIL:EXIT();

         END;

        PROGRAM FAILURES;

*      THIS PROGRAM BLOCK CONTAINS THE FUNCTIONS CALLED WHEN SOMETHING
* GOES WRONG

         INCLUDE GLOBAL'VARIABLES;

         DECLARE INTEGER
         ERROR'ADDR = L' [0];   /* ADDRESS OF CALLING STATEMENT      */
/*   (WHERE FAILURE OCCURRED)        */

         DECLARE STRING
         EXPLANATION;           /* JUST A STRING USED TO WRITE INTO  */



*      RUNTIME FAILURE IS CALLED WHEN THE PROGRAM ARRIVES SOMEWHERE IT
* ISN'T SUPPOSED TO, USUALLY CAUSED BY SEVERAL UNFORTUNATE CIRCUMSTANCES
* (SUCH AS TRYING TO CLOSE A FILE THAT'S ALREADY CLOSED OR TRYING TO
* TO WRITE MORE CHARACTERS INTO A STRING THAN WILL FIT)
         UNKNOWN FUNCTION RUNTIME'FAILURE();
        RETURN IF NOT DEBUGGING;
        PUTA("&307RUNTIME FAILURE AT P = ",0);
        OUTPUT'NUMBER (ERROR'ADDR);
        OUTPUT'STRING("&307");
        EXIT();


* SYSTEM'ERROR IS CALLED WHEN A MONITOR OR UTILITY CALL HAS FAILED
         UNKNOWN FUNCTION SYSTEM'ERROR();
        RETURN IF NOT DEBUGGING;
        OUTPUT'STRING("&307SYSTEM CALL FAILED: CODE = ");
        SETUP (EXPLANATION, 3, @ERROR'CODE);
        SETS (EXPLANATION, 0, 3);
        OUTPUT'STRING(EXPLANATION);
        PUTA (", NUMBER = ",0);
        OUTPUT'NUMBER (ERROR'NUMBER);
        PUTA (" AT P = ",0);
        OUTPUT'NUMBER (ERROR'ADDR);
        OUTPUT'STRING("&307");
        EXIT();


*      FATAL'ERROR IS CALLED WHEN AN ERROR OCCURS THAT WILL ALWAYS OCCUR
* EVEN IF RERUN (SUCH AS COMPARING THE LENGTH OF TWO STRINGS WITH DIF-
* FERENT CHARACTER SIZES)
         UNKNOWN FUNCTION FATAL'ERROR();
        RETURN IF NOT DEBUGGING;
        PUTA ("&307FATAL ERROR AT P = ",0);
        OUTPUT'NUMBER (ERROR'ADDR);
        OUTPUT'STRING("&307");
        EXIT();

         END;

        PROGRAM EXIT;

* THIS PROGRAM PERFORMS THE RETURN TO THE EXECUTIVE

         INCLUDE GLOBAL'VARIABLES;

         UNKNOWN FUNCTION EXIT();
        SP'RETURN(// VALUE HALT(): ERROR'CODE, ERROR'NUMBER);

         UNKNOWN FUNCTION HALT();
        .HLT 0;





         END;

        PROGRAM OPEN'SEQ'FILE;

*      THIS FUNCTION OPENS A FILE SPECIFIED BY THE ARGUMENT FILE'NAME
* FOR INPUT OR OUTPUT DEPENDING ON THE SECOND ARGUMENT, IOFLAG.  THE
* THIRD ARGUMENT, CHAR'LENGTH DETERMINES WHAT THE SIZE OF THE CHAR-
* ACTERS READ FROM OR WRITTEN INTO THE FILE ARE.  THIS FUNCTION WILL
* FAIL FOR MANY REASONS, SUCH AS IF ANY OF THE SYSTEM CALLS IT USES
* FRETURNS.  HOWEVER, THE USER CAN CAUSE THE FUNCTION TO FAIL BY PAS-
* SING A BAD FILE NAME, OR BY SPECIFYING AN OBJECT WHICH REALLY ISN'T A
* FILE.  THIS FUNCTION ALSO FAILS IF THE USER TRIES TO OPEN A FILE WHEN
* HE ALREADY HAS THE MAXIMUM ALLOWABLE NUMBER OF FILES OPEN.

         INCLUDE GLOBAL'VARIABLES;

         DECLARE ARRAY
         FORMATTED'NAME,    /* M1 FORMATTED NAME                     */
         LENGTH'WORD[3];    /* VALUE OF THE M1 FORMATTED NAME        */


         DECLARE INTEGER
         ACCESS'SPEC,       /* ACCESS SPECIFICATION TO THE FILE      */
         CHAR'LENGTH,       /* LENGTH OF A CHARACTER IN BITS         */
         FILE'LENGTH,       /* LENGTH OF FILE IN CHARACTERS          */
         FILE'NUMBER,       /* TSS FILE NUMBER                       */
         FILE'TYPE,         /* TYPE OF FILE: SYMBOLIC, BINARY, ETC.  */
/*   (FILE TYPES DEFINED IN FILE'DEFS)   */
         IOFLAG,            /* OPERATION TO BE PERFORMED ON THE FILE */
/*   (0-RETRIEVE, 1-STORE, 2-APPEND)     */
         GARBAGE,           /* UNNECESSARY RETURNED VALUES           */
         LAST'PAGE,         /* LAST PAGE OF THE FILE                 */
         LAST'WORD,         /* LAST WORD OF THE LAST PAGE OF THE FILE*/
         OBJECT'TYPE,       /* TYPE OF FILE                          */
/*  (0 - SMALL FILE, 1 - LARGE FILE)     */
         PAGE'NUMBER,       /* PAGE NUMBER OF THE FILE               */
         SEQ'FILE'NUM;      /* NUMBER OF SEQUENTIAL FILES OPEN       */

         DECLARE POINTER
         FILE;              /* A POINTER TO THE FILE WINDOW          */

         DECLARE STRING
         NULL'STRING,       /* JUST A NULL STRING                    */
         FILE'NAME;         /* FILE THE USER WANTS TO OPEN           */




         FUNCTION OPEN'SEQ'FILE(FILE'NAME, IOFLAG, FILE'TYPE, CHAR'LENGTH),
         FRETURN;

* CAN THE USER OPEN A FILE?
         FOR SEQ'FILE'NUM ← 0 TO NUM'SEQ'FILES - 1 DO;
            GOTO SET IF NOT SEQ'FILE'TABLE[SEQ'FILE'NUM]$WINDOW'IN'USE;
        ENDFOR;
        WARNING;

* SET UP A POINTER TO THE FILE'S WINDOW DESCRIPTOR
SET:     FILE ← @SEQ'FILE'TABLE[SEQ'FILE'NUM];

* SET UP AN ARRAY DESCRIPTOR
         FORMATTED'NAME ← CONS'ARRAY'DESC(@(FILE.NAME'STORAGE), 8, 1, 0 //
         FRETURN);

* GET THE M1 FORMATTED NAME FROM THE FILE NAME TYPED IN BY THE USER
         NAME'SEARCH(FILE'NAME, FORMATTED'NAME, IOFLAG, FILE'TYPE, -1//
         FRETURN : ERROR'CODE, ERROR'NUMBER);

* MAY HAVE TO BE CHANGED FOR THE APPEND
         ACCESS'SPEC ← ('WU' IF IOFLAG ELSE 'RU');

* IS THE FILE NEW (FORMATTED'NAME[2] = -1)?
         IF FORMATTED'NAME[2] = -1 DO;
            FILE'NUMBER ← OPEN'FILE(-1, FORMATTED'NAME, ACCESS'SPEC, -1//
             DISTRESS);
            FILE'LENGTH ← 0;
            OBJECT'TYPE ← SMALL'FILE;

         ELSE DO;
*       THE FILE ALREADY EXISTS.  DO THIS TO BE SAFE, THE OLD NAME MAY
* NOT HAVE BEEN A MONITOR FORMATTED NAME.
             CONV'NAME(FORMATTED'NAME, FORMATTED'NAME, -1:
             GARBAGE, OBJECT'TYPE, GARBAGE//DISTRESS);
            IF (OBJECT'TYPE = SMALL'FILE) OR (OBJECT'TYPE = LARGE'FILE) DO;
                READ'MIBOB'VALUE(FORMATTED'NAME, 1, LENGTH'WORD, 2, -1//
                 DISTRESS);
                FILE'NUMBER ← OPEN'FILE(-1, FORMATTED'NAME, ACCESS'SPEC, -1//
                 DISTRESS);
                LAST'PAGE ← LENGTH'WORD[2]$PAGES'IN'FILE - 1;
                LAST'WORD ← LENGTH'WORD[2]$WORDS'IN'PAGE + 1;
                FILE'LENGTH ← (0 IF NEXT'FILE'PAGE(FILE'NUMBER, -1//
                 SYSTEM'ERROR() & GOTO ABORT: ERROR'CODE, ERROR'NUMBER) = -1
                 ELSE (24/CHAR'LENGTH)*((2048*LAST'PAGE) + LAST'WORD));

                 IF FILE'LENGTH AND IOFLAG = WRITE'FILE DO;
                    DEL'SEQ'FILE(FILE'NUMBER//ABORT);
                    FILE'LENGTH ← 0;
                ENDIF;
            ELSE DO;
                FRETURN;

             ENDIF;

         ENDIF;

* FILL UP THE WINDOW
         FILE.PAGE'IN'WINDOW ← -1;
        FILE.PMT'INDEX ← ACQUIRE'PMT(-1//SYSTEM'ERROR() &
         GOTO ABORT: ERROR'CODE, ERROR'NUMBER);
        FILE.WINDOW'IN'USE ← 1;
        FILE.LARGE'OR'SMALL ← (0 IF OBJECT'TYPE = SMALL'FILE ELSE 1);
        FILE.OPERATION ← IOFLAG;
        FILE.FILE'NUM ← FILE'NUMBER;
        FILE.WINDOW'ADDRESS ← SEQ'FILE'WINDOWS[SEQ'FILE'NUM];
        FILE.CHARACTER'SIZE ← CHAR'LENGTH;
        FILE.CHARS'PER'WORD ← 24/CHAR'LENGTH;
        FILE.CHARS'PER'PAGE ← 4000B*24/CHAR'LENGTH;
        FILE.CHARS'LEFT ← FILE'LENGTH;
        FILE.LENGTH'IN'CHARS ← FILE'LENGTH;

         SET'MAP'BYTE(THIS'SUB'PROCESS, FILE.WINDOW'ADDRESS$PAGE'NUM'ADDR,
         FILE.PMT'INDEX//SYSTEM'ERROR() & GOTO ABORT:
         ERROR'CODE, ERROR'NUMBER);

*      THIS IS RIDICULOUS.  THE STATEMENT SHOULD BE 
*         SETUP(NULL'STRING, 0, FILE.WINDOW'ADDRESS, CHAR'LENGTH);
* EXCEPT THAT SPL WON'T TAKE A VARIABLE CHARACTER LENGTH.
* (THERE ARE SIMILAR STATEMENTS IN MAP'IN'NEXT'PAGE AND CREATE'PAGE)
         SETUP'KLUDGE(NULL'STRING, 0, FILE.WINDOW'ADDRESS,
         FILE.CHARACTER'SIZE//ABORT);
        FILE.READ'DESC ← NULL'STRING;
        FILE.WRITE'DESC ← (PREPARE'APPEND(FILE, LAST'PAGE//ABORT) IF
         IOFLAG = APPEND'FILE ELSE NULL'STRING);
        OPEN'FILE'TABLE[FILE'NUMBER] ← SEQ'FILE'NUM;
        RETURN FILE'NUMBER;

* SOMETHING WENT WRONG, SO RESET THINGS
ABORT:   FILE.WINDOW'IN'USE ← 0;
        CLOSE'SEQ'FILE(FILE'NUMBER// FRETURN);
        FRETURN;



         END;

        PROGRAM CLOSE'SEQ'FILE;

*      THIS FUNCTION CLOSES THE FILE SPECIFIED BY ITS ONLY ARGUMENT.
* IT IS CALLED TO CLOSE BOTH FILES WHICH WERE OPENED FOR INPUT AND OUT-
* PUT.  HOWEVER, FOR FILES WHICH HAVE BEEN OPENED FOR OUTPUT, IT MUST
* DETERMINE THE EXACT LENGTH OF THE FILE AND LET THE MONITOR KNOW ABOUT
* IT.  THE FUNCTION FAILS ONLY FOR INTERNAL REASONS: THE FILE IS ALREADY
* CLOSED, OR ONE OF THE MONITOR CALLS IT USES FAILS.

         INCLUDE GLOBAL'VARIABLES;

         DECLARE INTEGER
         FILE'NUMBER,
         LENGTH'IN'WORDS;   /* LENGTH OF THE FILE IN WORDS           */

         DECLARE POINTER
         FILE;              /* A POINTER TO THE FILE WINDOW          */



         UNKNOWN FUNCTION CLOSE'SEQ'FILE(FILE'NUMBER), FRETURN;

         FILE ← @SEQ'FILE'TABLE[OPEN'FILE'TABLE[FILE'NUMBER]];
* CHECK TO SEE IF WHAT IT IS GOING TO BE CLOSED ALREADY IS
         WARNING IF NOT FILE.WINDOW'IN'USE;
        IF FILE.OPERATION DO;
            OUTPUT'SEQ'FILE(FILE'NUMBER, "&137"// FRETURN);
            LENGTH'IN'WORDS ←
             (LENGTH(FILE.WRITE'DESC)*(FILE.CHARACTER'SIZE) + 23)/24;
            SET'FILE'LENGTH(FILE'NUMBER, LENGTH'IN'WORDS -1//
             DISTRESS);
        ENDIF;

* FREE THE WINDOW
         CLOSE'FILE(FILE'NUMBER//DISTRESS);
        FILE.WINDOW'IN'USE ← 0;
        OPEN'FILE'TABLE[FILE'NUMBER] ← -1;
        DELETE'PMT(FILE.PMT'INDEX//DISTRESS);

         RETURN;



         END;

        PROGRAM INPUT'SEQ'FILE;

*      THIS FUNCTION READS A LINE FROM A SPECIFIED FILE AND RETURNS IT
* TO THE CALLING FUNCTION.  A "LINE" IS A STRING OF CHARACTERS ENDING
* WITH A CARRIAGE RETURN LINEFEED, A CARRIAGE RETURN, OR A LINEFEED.
* THE LINE THE FUNCTION RETURNS HAS HAD ANY MULTIPLE BLANK CHARACTERS
* REMOVED AND THE APPROPRIATE NUMBER OF BLANKS INSERTED.
*      WHEN THIS FUNCTION IS CALLED THE FIRST TIME AFTER OPENING THE
* FILE, THE GCI AT READ FAILS BECAUSE FILE.READ'DESC WAS SET UP TO A
* LENGTH OF ZERO.  THE WAY END-OF-FILE IS SIGNALED IN THIS FUNCTION IS
* WHEN IT RETURNS A STRING OF LENGTH ZERO, SO THAT MUST CONSTANTLY BE
* TESTED FOR.

         INCLUDE GLOBAL'VARIABLES;

         DECLARE INTEGER
         CHAR,              /* A CHARACTER READ FROM THE FILE        */
         COUNT,             /* JUST A COUNTER FOR A FOR LOOP         */
         FINISHED,          /* A FLAG SIGNALING THAT THE FILE HAS    */
/*   BEEN COMPLETELY READ                */
         FILE'NUMBER;       /* THE NUMBER OF THE FILE                */

         DECLARE POINTER
         FILE;              /* A POINTER TO THE FILE WINDOW          */

         DECLARE STRING
         INPUT'DUMMY,       /* A STRING CONTAINING A PAGE OF THE FILE*/
/*   UNLESS IT IS THE LAST PAGE WHEN IT  */
/*   CONTAINS THE REMAINDER OF THE FILE  */
         OUTPUT'LINE;       /* THE STRING RETURNED WITH A LINE READ  */
/*   FROM THE FILE                       */



         STRING FUNCTION INPUT'SEQ'FILE(FILE'NUMBER, OUTPUT'LINE), FRETURN;

         SETS(OUTPUT'LINE);
* SET UP THE POINTER TO THE FILE
         FILE ← @SEQ'FILE'TABLE[OPEN'FILE'TABLE[FILE'NUMBER]];

* MAKE A DUMMY ASSIGNMENT OF THE STRING DESCRIPTOR TO KEEP SPL HAPPY
*   (REMEMBER TO REASSIGN FILE.READ'DESC BEFORE RETURNING)
         INPUT'DUMMY ← FILE.READ'DESC;

         FINISHED ← NO;
        WHILE 1 DO;
READ:       GOTO PAU IF FINISHED;
            CHAR ← GCI(INPUT'DUMMY//
             MAP'IN'NEXT'PAGE(FILE:INPUT'DUMMY, FINISHED// FRETURN) &
             GOTO READ) A' 177B;

* IS IT A MULTIPLE BLANK CHAR
             IF CHAR = MB DO;
BLANKS:         GOTO PAU IF FINISHED;
                CHAR ← GCI(INPUT'DUMMY//
                 MAP'IN'NEXT'PAGE(FILE:INPUT'DUMMY, FINISHED// FRETURN) &
                 GOTO BLANKS) A' 77B;
                WCI(BLANK, OUTPUT'LINE//WARNING) FOR
                 COUNT ← 1 TO CHAR - 1;
                CHAR ← BLANK;

* TEST FOR END OF LINE CHARACTER/CHARACTERS
             ELSEIF CHAR = CR DO;
C'RET:          GOTO PAU IF FINISHED;
                CHAR ← GCI(INPUT'DUMMY//
                 MAP'IN'NEXT'PAGE(FILE: INPUT'DUMMY, FINISHED// FRETURN) &
                 GOTO C'RET) A' 177B;

                 IF CHAR = LF DO;
                    WCI(CR, OUTPUT'LINE//WARNING);
                ELSE DO;
                    CHAR ← CHAR V' 200B;
                    INPUT'DUMMY$RP ← INCDES(INPUT'DUMMY$RP, -1);
                ENDIF;
            ENDIF;
            WCI(CHAR, OUTPUT'LINE//WARNING);
            IF CHAR = LF OR CHAR = CR DO;
PAU:            FILE.READ'DESC ← INPUT'DUMMY;
                RETURN OUTPUT'LINE;
            ENDIF;
        ENDFOR;

CARR:    WCI(CR, OUTPUT'LINE// FRETURN);
        FILE.READ'DESC ← INPUT'DUMMY;
        RETURN OUTPUT'LINE;




         END;

        PROGRAM OUTPUT'SEQ'FILE;

*      THIS FUNCTION APPENDS THE STRING SPECIFIED BY ITS SECOND ARGUMENT
* TO THE FILE SPECIFIED BY THE SECOND ARGUMENT.  THE FIRST TIME THIS 
* FUNCTION IS CALLED AFTER OPENING THE FILE, ONE OF THE WCI'S WILL FAIL
* BECAUSE FILE.WRITE'DESC WAS SETUP WITH A LENGTH OF ZERO.  CREATE'NEW'-
* PAGE IS THEN CALLED TO CREATE ANOTHER FILE PAGE.  IT IS EXPECTED THAT
* INPUT'LINE WILL BE A STRING IN THE 940 CHARACTER SET, SO THAT THE
* STRING CAN SIMPLY BE WRITTEN INTO THE FILE.  THIS FUNCTION FAILS ONLY
* IF CREATE'NEW'PAGE FAILS.

         INCLUDE GLOBAL'VARIABLES;

         DECLARE INTEGER
         CHAR,              /* A CHARACTER TO BE WRITTEN INTO A FILE */
         FILE'NUMBER;       /* THE NUMBER OF THE FILE                */

         DECLARE POINTER
         FILE;              /* A POINTER TO THE FILE WINDOW          */

         DECLARE STRING
         INPUT'LINE,        /* THE STRING FROM WHICH CHARACTERS ARE  */
/*   WRITTEN INTO THE FILE               */
         OUTPUT'DUMMY;      /* A WORKING STRING                      */



         FUNCTION OUTPUT'SEQ'FILE(FILE'NUMBER, INPUT'LINE), FRETURN;

         FILE ← @SEQ'FILE'TABLE[OPEN'FILE'TABLE[FILE'NUMBER]];
        OUTPUT'DUMMY ← FILE.WRITE'DESC;
        WHILE 1 DO;
            CHAR ← GCI(INPUT'LINE//
             FILE.WRITE'DESC ← OUTPUT'DUMMY & RETURN);
WRITE'CHAR:
            WCI(CHAR, OUTPUT'DUMMY//OUTPUT'DUMMY ←
             CREATE'NEW'PAGE(FILE// FRETURN) & GOTO WRITE'CHAR);
        ENDFOR;



         END;

        PROGRAM DEL'SEQ'FILE;

*      THIS FUNCTION DELETES ALL THE PAGES OF AN EXISTING FILE WHICH HAS
* BEEN OPENED FOR OUTPUT.  THE FUNCTION FAILS ONLY IF ONE OF THE MONITOR
* CALLS IT USES FAILS.  THE NAME OF THIS FUNCTION ISN'T EXACTLY AC-
* CURATE, BECAUSE IT ACTUALLY ONLY DELETES THE EXISTING PAGES OF THE
* FILE BUT DEL'FILE'PAGES IS EASILY CONFUSED WITH DEL'FILE'PAGE.

         INCLUDE GLOBAL'VARIABLES;

         DECLARE INTEGER
         FILE'NUMBER,       /* TSS FILE NUMBER                       */
         PAGE'NUMBER;       /* PAGE (MEMORY PAGE) NUMBER OF THE FILE */



         FUNCTION DEL'SEQ'FILE(FILE'NUMBER), FRETURN;

         PAGE'NUMBER ← 0;
        WHILE PAGE'NUMBER # -1 DO;
            DEL'FILE'PAGE(FILE'NUMBER, PAGE'NUMBER//
             DISTRESS);
            PAGE'NUMBER ← NEXT'FILE'PAGE(FILE'NUMBER, PAGE'NUMBER//
             DISTRESS);
        ENDFOR;
        SET'FILE'LENGTH(FILE'NUMBER, 0//DISTRESS);

         RETURN;


         END;

        PROGRAM MAP'IN'NEXT'PAGE;

*      THIS FUNCTION SETS THINGS UP SO THAT ANOTHER PAGE MAY BE READ BY
* ACQUIRING A PMT INDEX FOR THE NEXT PAGE AND MAPPING IT IN.  IF IT IS
* SUCCESSFUL IN DOING THAT, THE FUNCTION RETURNS THE STRING DESCRIPTOR
* FOR THE STRING WHICH OVERLAYS THE PAGE OF THE FILE AND A FLAG SIGNAL-
* WHETHER THE FILE HAS BEEN FULLY READ.  THIS FUNCTION FAILS ONLY ON
* INTERNAL ERRORS.

         INCLUDE GLOBAL'VARIABLES;

         DECLARE INTEGER
         CHAR;              /* A CHARACTER READ FROM THE FILE        */

         DECLARE POINTER
         FILE;              /* POINTER TO THE FILE WINDOW            */

         DECLARE STRING
         INPUT'DUMMY;       /* STRING THAT CHARACTERS ARE READ FROM  */




         STRING FUNCTION MAP'IN'NEXT'PAGE(FILE), FRETURN;

* IS THE FILE WINDOW AVAILABLE?  IS THE FILE OPEN FOR INPUT?
         WARNING IF NOT FILE.WINDOW'IN'USE OR FILE.OPERATION
         OR FILE.CHARS'LEFT < 0;

         IF FILE.CHARS'LEFT = 0 DO;
            SETUP'KLUDGE(INPUT'DUMMY, 0, FILE.WINDOW'ADDRESS,
             FILE.CHARACTER'SIZE// FRETURN);
            RETURN (INPUT'DUMMY, YES);
        ENDIF;
        FILE.PAGE'IN'WINDOW ← FILE.PAGE'IN'WINDOW + 1;
        CLEAR'PMT(FILE.PMT'INDEX//DISTRESS);
        MOVE'PAGE'PMT(FILE.FILE'NUM, FILE.PAGE'IN'WINDOW, FILE.PMT'INDEX//
         DISTRESS);

* IF THERE'S MORE THAN A PAGE LEFT
         IF FILE.CHARS'LEFT > FILE.CHARS'PER'PAGE DO;
            SETUP'KLUDGE(INPUT'DUMMY, FILE.CHARS'PER'PAGE,
             FILE.WINDOW'ADDRESS, FILE.CHARACTER'SIZE// FRETURN);
            INPUT'DUMMY$WP ← INPUT'DUMMY$EP;
            FILE.CHARS'LEFT ← FILE.CHARS'LEFT - FILE.CHARS'PER'PAGE;

* IF IT'S THE LAST PAGE
         ELSE DO;
            INPUT'DUMMY ← DET'END'OF'FILE(FILE// FRETURN);
        ENDIF;
        RETURN (INPUT'DUMMY, NO);


         END;

        PROGRAM CREATE'NEW'PAGE;

*      THIS FUNCTION CREATES A NEW FILE PAGE SO THAT MORE CHARACTERS CAN
* BE WRITTEN OUT TO THE FILE.  IT RESETS THE STRING OUTPUT'DUMMY SO MORE
* CHARACTERS CAN BE WRITTEN INTO IT AND OVERLAYS THE STRING ON THE PAGE
* IT HAS JUST CREATED.  THE LENGTH OF THE FILE KEPT IN THE WINDOW IS
* INCREMENTED BY A PAGE WORTH OF CHARACTERS.  IF THE PAGE ISN'T FILLED,
* CLOSE'SEQ'FILE SETS THE EXACT LENGTH WHEN IT TRIES TO CLOSE THE FILE.
* THIS FUNCTION FAILS IF ANY OF THE MONITOR CALLS IT USES FAILS.

         INCLUDE GLOBAL'VARIABLES;

         DECLARE POINTER
         FILE;              /* A POINTER TO THE FILE WINDOW          */

         DECLARE STRING
         OUTPUT'DUMMY;      /* THE STRING THAT THE CHARACTERS WILL   */
/*   BE WRITTEN INTO                     */



         STRING FUNCTION CREATE'NEW'PAGE(FILE), FRETURN;

* IS THE FILE REALLY OPEN?  IS IT OPEN FOR OUTPUT?
         WARNING IF NOT FILE.WINDOW'IN'USE OR NOT FILE.OPERATION;

* DO THINGS TO MAP IN A NEW PAGE INTO THE WINDOW
         FILE.PAGE'IN'WINDOW ← FILE.PAGE'IN'WINDOW + 1;
        CREATE'FILE'PAGE(FILE.FILE'NUM, FILE.PAGE'IN'WINDOW//
         DISTRESS);
        CLEAR'PMT(FILE.PMT'INDEX//DISTRESS);
        MOVE'PAGE'PMT(FILE.FILE'NUM, FILE.PAGE'IN'WINDOW, FILE.PMT'INDEX//
         DISTRESS);
        SETUP'KLUDGE(OUTPUT'DUMMY, FILE.CHARS'PER'PAGE,
         FILE.WINDOW'ADDRESS, FILE.CHARACTER'SIZE// FRETURN);

         FILE.LENGTH'IN'CHARS ← FILE.PAGE'IN'WINDOW*FILE.CHARS'PER'PAGE;
        RETURN OUTPUT'DUMMY;



         END;

        PROGRAM PREPARE'APPEND;

*      THIS FUNCTION IS A SPECIAL CASE OF MAP'IN'NEXT'PAGE WHERE THE
* PAGE WHICH WILL BE MAPPED INTO THE WINDOW IS THE LAST PAGE OF THE FILE.

         INCLUDE GLOBAL'VARIABLES;

         DECLARE INTEGER
         LAST'PAGE;         /* THE LAST PAGE OF THE FILE             */

         DECLARE POINTER
         FILE;              /* A POINTER TO THE FILE WINDOW          */

         DECLARE STRING
         APPEND'DESC;       /* THE STRING DESCRIPTOR SET UP SO THAT  */
/*   THE FILE CAN HAVE MORE CHARACTERS   */
/*   APPENDED TO IT                      */




         STRING FUNCTION PREPARE'APPEND(FILE, LAST'PAGE), FRETURN;

* IS THE FILE REALLY OPEN?  IS IT OPEN FOR OUTPUT?
         WARNING IF NOT FILE.WINDOW'IN'USE OR
         FILE.OPERATION # APPEND'FILE;

* DO THINGS TO MAP IN A NEW PAGE INTO THE WINDOW
         FILE.PAGE'IN'WINDOW ← LAST'PAGE;
        CLEAR'PMT(FILE.PMT'INDEX//DISTRESS);
        MOVE'PAGE'PMT(FILE.FILE'NUM, FILE.PAGE'IN'WINDOW, FILE.PMT'INDEX//
         DISTRESS);
*      CHANGE THE CHARACTER COUNT SO DET'END'OF'FILE DOESN'T CREATE A
* STRING OVER A PAGE LONG.
         FILE.CHARS'LEFT ← FILE.CHARS'LEFT - FILE.CHARS'PER'PAGE*LAST'PAGE;
        APPEND'DESC ← DET'END'OF'FILE(FILE// FRETURN);
*      MOVE THE END POINTER OF THE STRING SO THAT THE STRING IS A WHOLE
* PAGE LONG.
         APPEND'DESC$EP ← INCDES(APPEND'DESC$BP, FILE.CHARS'PER'PAGE);
        FILE.LENGTH'IN'CHARS ← FILE.CHARS'PER'PAGE*(FILE.PAGE'IN'WINDOW);

         RETURN APPEND'DESC;



         END;

        PROGRAM MY'TERMINAL'''IO;

*      THIS PROGRAM BLOCK CONTAINS THE TERMINAL INPUT AND OUTPUT
* FUNCTIONS.  THESE FUNCTIONS DON'T HAVE FRETURNS, BUT CALL THE FUNCTION
* SYSTEM'ERROR WHICH WILL RETURN IMMEDIATELY IF THE FLAG DEBUGGING ISN'T
* SET, WHICH MAY TOTALLY SCREW THINGS UP.  HOWEVER, ALL CALLS TO THESE
* FUNCTION ARE MADE ONLY IF DEBUGGER HAS BEEN SET.

         INCLUDE GLOBAL'VARIABLES;

         DECLARE CHARACTER
         CHAR;              /* THE CHARACTER TO INPUT OR OUTPUT      */

         DECLARE STRING
         INPUT,             /* THE STRING READ IN FROM THE TERMINAL  */
         OUTPUT;            /* THE STRING TO OUTPUT TO THE TERMINAL  */



* IF THE FUNCTION FAILS, THE CHARACTER RETURNED WILL BE A BLANK
         CHARACTER FUNCTION INPUT'CHARACTER();

         CHAR ← READ'CHAR(-1, 0//
         ERROR'MESSAGE(7) & RETURN 307B:ERROR'CODE,ERROR'NUMBER);
        PRINT'CHAR(-1, CHAR,0//
         SYSTEM'ERROR(): CHAR,ERROR'CODE,ERROR'NUMBER);
        START'OUTPUT(-1,0//SYSTEM'ERROR(): ERROR'CODE, ERROR'NUMBER);
        RETURN CHAR;

         UNKNOWN FUNCTION OUTPUT'CHARACTER(CHAR);
        PRINT'CHAR(-1, CHAR, 0//
         SYSTEM'ERROR(): CHAR, ERROR'CODE, ERROR'NUMBER);
        START'OUTPUT(-1, 0//SYSTEM'ERROR(): ERROR'CODE, ERROR'NUMBER);
        RETURN;



*      IF THE FUNCTIONS FAILS, THE STRING RETURNED WILL BE WHATEVER
* WAS IN INPUT AT THAT POINT
         STRING FUNCTION INPUT'STRING(INPUT);
        INPUT ← READ'LINE(-1, INPUT, "", 0//
         SYSTEM'ERROR() & INPUT: INPUT, ERROR'CODE, ERROR'NUMBER);
        RETURN INPUT;


         UNKNOWN FUNCTION OUTPUT'STRING(OUTPUT);
        PRINT'STRING(-1, OUTPUT, 0//
         SYSTEM'ERROR(): OUTPUT, ERROR'CODE, ERROR'NUMBER);
        RETURN;


         END;

        PROGRAM OUTPUT'NUMBER;

*       PROGRAM PRINTS OUT THE NUMBER PASSED TO IT ON THE TTY IN
* BASE 10.


         DECLARE INTEGER NUMBER;            /* THE NUMBER TO BE PRINTED */

         DECLARE STRING S(10);              /* STRING TO BE PRINTED     */

         FUNCTION OUTPUT'NUMBER(NUMBER);

         CNS(NUMBER,S,0,10//EXIT());

         PUTA(S,0);

         RETURN;

         END;

        PROGRAM PUTA;

*      THIS PROGRAM TYPES OUT THE STRING PASSED TO IT TO THE TELETYPE
*  FOLLOWED BY A NUMBER OF LINE FEEDS, SPECIFIED BY THE SECOND ARGUMENT.

         DECLARE STRING S, TEMP(200);

         DECLARE INTEGER
         I,
         N;

         DECLARE CHARACTER
         CHAR,
         CR ← 155B,
         LF ← 152B;


         UNKNOWN MONITOR SP'RETURN ← 116;


         FUNCTION PUTA(S,N);

         FOR I ← 1 TO LENGTH(S) DO;
            CHAR ← GCI(S//FAILED);
            WCI(CHAR,TEMP//FAILED);
        ENDFOR;

         WCI(CR,TEMP//FAILED) IF N # 0;

         FOR I ← 1 TO N DO;
            WCI(LF,TEMP//FAILED);
        ENDFOR;

         OUTPUT'STRING(TEMP);

         RETURN;

FAILED:  OUTPUT'STRING("",2//BAD);
        OUTPUT'STRING("OUTPUT FAILURE",1//BAD);

*      RETURN TO MONITOR

         SP'RETURN(//BAD);

BAD:     EXIT();

         END;

        PROGRAM SETUP'KLUDGE;

*      THIS FUNCTION DOES WHAT SETUP OUGHT TO DO -- TAKE A VARIABLE
* CHARACTER SIZE.  UNFORTUNATELY, THE ONLY WAY IT CAN DO IT IS BY DOING
* A SETUP FOR EACH POSSIBLE CHARACTER SIZE.

         INCLUDE STRING'DEFS;

         DECLARE INTEGER
         BEGIN'ADDRESS,
         CHARACTER'SIZE,
         LENGTH;

         DECLARE STRING
*         KLUDGE,
         WORKING'NAME;



         UNKNOWN FUNCTION SETUP'KLUDGE(STRING @KLUDGE, LENGTH, BEGIN'ADDRESS,
         CHARACTER'SIZE), FRETURN;

         WORKING'NAME ← KLUDGE.STRING'DESC;
        IF CHARACTER'SIZE = 6 DO;
            SETUP(WORKING'NAME, LENGTH, BEGIN'ADDRESS, 6);
        ELSEIF CHARACTER'SIZE = 8 DO;
            SETUP(WORKING'NAME, LENGTH, BEGIN'ADDRESS, 8);
        ELSEIF CHARACTER'SIZE = 12 DO;
            SETUP(WORKING'NAME, LENGTH, BEGIN'ADDRESS, 12);
        ELSEIF CHARACTER'SIZE = 24 DO;
            SETUP(WORKING'NAME, LENGTH, BEGIN'ADDRESS, 24);
        ELSE DO;
            FRETURN;
        ENDIF;
        KLUDGE.STRING'DESC ← WORKING'NAME;

         RETURN;



         END;

        PROGRAM CNS;

*      THIS FUNCTION APPENDS A SINGLE PRECISION INTEGER TO A STRING
* AFTER CONVERTING THE INTEGER FROM INTERNAL REPRESENTATION TO CHAR-
* ATER REPRESENTATION.  THIS FUNCTION FAILS IF THE BASE THE NUMBER WILL
* BE CONVERTED TO IS OUTSIDE THE ALLOWABLE RANGE OF 2 TO 36, INCLUSIVE,
* OR IF THE STRING PASSED TO IT CAN'T HOLD ALL THE CHARACTERS OF THE 
* BER.

         INCLUDE STRING'DEFS;

         DECLARE INTEGER
         BASE,              /* THE BASE THE NUMBER WILL BE CONVERTED */
/*   TO                                  */
         CHAR,              /* THE CHARACTER TO WRITE INTO THE STRING*/
         COUNTER,           /* JUST A COUNTER                        */
         LENGTH'TEMP,       /* LENGTH OF THE STRING TEMP             */
         NUMBER,            /* THE NUMBER TO CONVERT                 */
         NUMBER'OF'CHARS,   /* BITS (18-23) OF SIGN'NUM'CHARS        */
         SIGN'FLAG,         /* SET IF NEGATIVE NUMBERS ARE TO BE     */
/*   CONVERTED SIGNED                    */
         SIGN'NUM'CHARS;    /* DETERMINES IF THE NUMBER WILL BE      */
/*   SIGNED AND HOW MANY CHARACTERS TO   */
/*   GENERATE.  IF IT IS 0, IT WILL BE   */
/*   CONVERTED SIGNED AND WITHOUT PAD-   */
/*   DING OR TRUNCATION                  */

         DECLARE STRING
         TEMP (24),         /* A TEMPORARY STRING EACH DIGIT IS      */
         WORKING'NAME;      /* TO KEEP SPL HAPPY                     */
/*   WRITTEN INTO                        */



         UNKNOWN FUNCTION CNS(NUMBER, STRING @STRING'CREATED,
         SIGN'NUM'CHARS, BASE), FRETURN;

         FRETURN IF BASE < 2 OR BASE > 36;
        WORKING'NAME ← STRING'CREATED.STRING'DESC;
        SIGN'FLAG ← (-1 IF SIGN'NUM'CHARS >= 0 AND NUMBER < 0 ELSE 0);
        NUMBER ← -NUMBER IF SIGN'FLAG;

* BE CLEVER AND WRITE THE STRING BACKWARDS
         TEMP$RP ← TEMP$WP ← TEMP$EP;

         IF NUMBER # 0 DO;
            WHILE NUMBER # 0 DO;
* TRIED TO USE MOD HERE, BUT FOR SOME REASON, IT DIDN'T WORK OUT RIGHT
                 .LDA NUMBER, LSHD -23, DIV BASE, STA NUMBER, STB CHAR;
                WCD(CHAR + ('0' IF CHAR < 10 ELSE 'A' - 10), TEMP);
            ENDFOR;
        ELSE DO;
            WCD('0', TEMP);
        ENDIF;

         WCD('-', TEMP) IF SIGN'FLAG;

* ALL WE NEED NOW IS HOW MANY CHARACTERS TO GENERATE
         NUMBER'OF'CHARS ← SIGN'NUM'CHARS A' 77B;
        LENGTH'TEMP ← LENGTH(TEMP);

* TRUNCATE CHARACTERS IF NECESSARY
         IF NUMBER'OF'CHARS # 0 AND NUMBER'OF'CHARS < LENGTH'TEMP DO;
            TEMP$RP ← INCDES(TEMP$EP, -NUMBER'OF'CHARS);

* OR PAD
         ELSEIF NUMBER'OF'CHARS # 0 AND NUMBER'OF'CHARS > LENGTH'TEMP DO;
            FOR COUNTER ← LENGTH'TEMP + 1 TO NUMBER'OF'CHARS DO;
                WCI(' ', WORKING'NAME// FRETURN);
            ENDFOR;
        ENDIF;

         FOR COUNTER ← 1 TO LENGTH(TEMP) DO;
            CHAR ← GCI(TEMP);
            WCI(CHAR, WORKING'NAME// FRETURN);
        ENDFOR;

FINISH:  STRING'CREATED.WP ← WORKING'NAME$WP;
        RETURN;


         END;

        PROGRAM CSN;

*      THIS FUNCTION TAKES AS ITS FIRST ARGUMENT A STRING WHICH IT
* ATTEMPTS TO CONVERT FROM THE BASE SPECIFIED IN THE SECOND ARGUMENT TO
* AN INTEGER.  THIS FUNCTION FRETURNS IF THE BASE IS ILLEGAL, IF THE
* STRING IS BLANK, OR THE FIRST CHARACTER ENCOUNTERED CAN'T BE PART
* OF A NUMBER.

         INCLUDE STRING'DEFS;

         DECLARE INTEGER
         BASE,              /* THE RADIX THE REPRESENTATION OF THE   */
/*   NUMBER WILL BE IN                   */
         BEGINNING'OF'NUM,  /* THE FIRST CHARACTER POSITION IN THE   */
/*   STRING WHICH IS PART OF THE NUMBER  */
         CHAR,              /* JUST A CHARACTER FROM THE STRING      */
         COUNTER,           /* JUST A COUNTER FOR A LOOP             */
         DIGIT,             /* ONE CHARACTER TO BE WRITTEN INTO THE  */
/*    STRING                             */
         NEGATIVE'NUM,      /* FLAG SET IF THE NUMBER IS NEGATIVE    */
         NUMBER,            /* THE NUMBER THE STRING WILL BE         */
/*   CONVERTED TO                        */
         POWER,             /* SPECIFIES THE EXPONENT TO THE BASE    */
         POWER'DONE;        /* FLAG SET WHEN THE POWER IS CALCULATED */
/*   FOR THE FIRST TIME                  */

         DECLARE STRING
*         OBJECT,
         WORKING'NAME;      /* TO KEEP SPL HAPPY                     */



         FUNCTION CSN(STRING @OBJECT, BASE), FRETURN;

         FRETURN IF BASE < 2 OR BASE > 36;
        WORKING'NAME ← OBJECT.STRING'DESC;

* INITIALIZE FLAGS
         NEGATIVE'NUM ← POWER'DONE ← 0;

* INITIALIZE VARIABLES
         POWER ← 0;
        CHAR ← ' ';

* SKIP OVER LEADING BLANKS
         CHAR ← GCI(WORKING'NAME// FRETURN) WHILE CHAR = ' ';

* DETERMINE THE SIGN OF THE NUMBER
         IF CHAR = '-' DO;
            NEGATIVE'NUM ← -1;
        ELSEIF CHAR # '+' DO;
            WCD (CHAR, WORKING'NAME);
        ENDIF;

* REMEMBER WHERE WE ARE IN CASE WE HAVE TO DO IT OVER
         BEGINNING'OF'NUM ← WORKING'NAME$RP;

*      GET A CHARACTER, CONVERT IT TO A NUMBER AND ADD IT TO A SUM
* (CONTROL PASSES BACK TO HERE IF WE FIND OUT THAT WE HAVE BEEN
* ASSUMING THE WRONG BASE)
AGAIN:   NUMBER ← 0;
        WHILE 1 DO;
            CHAR ← GCI(WORKING'NAME//PAU);
            IF CHAR >= '0' AND CHAR <= '9' DO;
                DIGIT ← CHAR - '0';
            ELSEIF CHAR >= 'A' AND CHAR <='Z' DO;
                DIGIT ← CHAR - ('A' - 10);
            ELSE DO;
                FRETURN IF LNGDES(BEGINNING'OF'NUM, WORKING'NAME$RP) = 1
                 ELSE GOTO INVALID;
            ENDIF;
            GOTO INVALID IF DIGIT >= BASE;
            NUMBER ← NUMBER*BASE + DIGIT;
        ENDFOR;

* TEST ALL CHARACTERS WHICH AREN'T DIGITS OF THE NUMBER
INVALID:
        IF BASE <= 10 AND CHAR = 'B' OR CHAR = 'D' DO;
            IF POWER'DONE DO; * DO WE KNOW WHAT THE NEXT CHARACTER IS
            CHAR ← GCI(WORKING'NAME);
            ELSE DO; * NO, WE HAVEN'T BEEN THROUGH HERE BEFORE
            POWER'DONE ← -1;
                POWER ← GCI(WORKING'NAME//NO'POWER);
                IF POWER >= '0' AND POWER <= '9' DO;
                    POWER ← POWER - '0';
                ELSE DO;
                    WCD(POWER, WORKING'NAME);
                ENDIF;
NO'POWER:       IF CHAR = 'B' AND BASE # 8 DO;
                    BASE ← 8;
                ELSEIF CHAR = 'D' AND BASE # 10 DO;
                    BASE ← 10;
                ELSE DO;
                    GOTO PAU;
                ENDIF;
                WORKING'NAME$RP ← BEGINNING'OF'NUM;
                GOTO AGAIN;
            ENDIF;
        ELSE DO;
            WCD(CHAR, WORKING'NAME);
        ENDIF;

PAU:     NUMBER ← NUMBER*BASE FOR COUNTER ← 1 TO POWER;
        OBJECT.RP ← WORKING'NAME$RP;
        RETURN (-NUMBER IF NEGATIVE'NUM ELSE NUMBER);


         END;

        PROGRAM APPEND;

*      THIS PROGRAM BLOCK TAKES AS ITS ARGUMENTS TWO STRINGS WHICH IT
* ATTEMPTS TO CONCATENATE TOGETHER.  THERE ARE TWO ENTRY POINTS TO THE
* PROGRAM, SCOPY, AND APPEND.  SCOPY IS JUST A SPECIAL CASE OF APPEND
* IN WHICH ONE STRING WILL BE COPIED TO THE BEGINNING OF THE OTHER
* STRING.
*      I TRIED TO BE CONSISTENT AND DECLARE ALL VARIABLES EXPLICITLY,
* IN "DECLARE" STATEMENTS, BUT THERE SEEM TO BE PROBLEMS WITH DECLARING
* A STRING WHICH WILL BE AN ARGUMENT TO A FUNCTION AND LATER IN THE
* FUNCTION DEFINITION, INFORMING SPL THAT THAT STRING WILL BE CALLED
* BY WHAT I CONSIDER TO BE CALL BY NAME.
*      THIS FUNCTION FAILS IF THE TWO STRINGS HAVE DIFFERENT CHARACTER
* SIZES OR THE FIRST STRING ISN'T LARGE ENOUGH TO HOLD THE SECOND.  IF
* THE FUNCTION DOES FAIL, NONE OF THE ARGUMENTS TO THE FUNCTION ARE
* CHANGED, IF IT SUCCEEDS, ONLY THE FIRST IS CHANGED.  THIS WILL BE
* STANDARD FOR MOST STRING MANIPULATION FUNCTIONS.
*      THE STRING MANIPULATION FUNCTIONS WILL FAIL TO DO WHAT THE PRO-
* GRAMMER WANTS IF THE ARGUMENT IS BEING CALLED BY NAME AND IT IS COM-
* PLEX (SUCH AS AN ELEMENT OF A STRING ARRAY).  THE REASON IS THAT SPL
* WILL CREATE A TEMPORAY STRING DESCRIPTOR AND PASS THAT AS THE ARGUMENT.

         INCLUDE STRING'DEFS;

         DECLARE STRING
         ADDENDUM,          /* THE STRING FROM WHICH CHARACTERS ARE  */
/*   COPIED INTO THE FIRST ARGUMENT      */
*         OBJECT,            /* THE STRING TO WHICH CHARACTERS WILL   */
/*   BE COPIED                           */
         WORKING'NAME;      /* TO KEEP SPL HAPPY                     */

         DECLARE INTEGER
         COUNTER,
         LENGTH'ADDENDUM;   /* LENGTH OF THE STRING ADDENDUM         */



* SCOPY - COPY THE SECOND STRING INTO THE FIRST
         UNKNOWN FUNCTION SCOPY(STRING @OBJECT, ADDENDUM), FRETURN;
        OBJECT.WP ← OBJECT.RP ← OBJECT.BP;

* APPEND - APPEND THE SECOND STRING TO THE FIRST
         UNKNOWN FUNCTION APPEND(STRING @OBJECT, ADDENDUM), FRETURN;
        WORKING'NAME ← OBJECT.STRING'DESC;
        FRETURN IF ADDENDUM$CHAR'SIZE # WORKING'NAME$CHAR'SIZE;
        LENGTH'ADDENDUM ← LENGTH(ADDENDUM);
        FRETURN IF /* THE STRING WON'T FIT INTO OBJECT      */
         LENGTH'ADDENDUM > LNGDES(WORKING'NAME$WP, WORKING'NAME$EP);
        WCI(GCI(ADDENDUM), WORKING'NAME) FOR COUNTER ← 1 TO LENGTH'ADDENDUM;
        OBJECT.WP ← WORKING'NAME$WP;
        RETURN;


         END;

        PROGRAM LEXICAL'COMPARES;

*       THIS PROGRAM BLOCK CONTAINS THE FUNCTIONS WHICH PERFORM STRING
* COMPARISONS. THE MAJOR FUNCTION IS LGT WHICH TAKES AS ITS ARGUMENTS
* TWO STRINGS WHICH IT COMPARES TO SEE IF THE FIRST IF LEXICALLY GREATER
* THAN THE SECOND. IT DETERMINES THIS BY COMPARING THE 940 CHARCTER
* CODES OF THEIR CHARACTERS. THE FUNCTION FAILS IF THE TWO STRINGS HAVE
* DIFFERENT CHARACTER SIZES. IF THE SECOND STRING IS LEXICALLY LESS
* THAN THE FIRST, THE FUNCTION RETURNS -1, OTHERWISE 0.

         INCLUDE STRING'DEFS;

         DECLARE CHARACTER
         CHAR1,
         CHAR2;

         DECLARE STRING
         A'STRING,
         A'LESSER'STRING;   /* FOR THE FUNCTION TO RETURN -1 ANYWAY   */


         FUNCTION LGT(A'STRING, A'LESSER'STRING), FRETURN;

         FRETURN IF A'STRING$CHAR'SIZE # A'LESSER'STRING$CHAR'SIZE;

         WHILE 1 DO;
* READ FROM THE SUPPOSEDLY GREATER ONE FIRST TO TAKE CARE OF THE
* EQUALITY CONDITION

             CHAR1 ← GCI(A'STRING// RETURN 0);
            CHAR2 ← GCI(A'LESSER'STRING// RETURN -1);
            IF CHAR1 > CHAR2 DO;
                RETURN -1;
            ELSEIF CHAR1 < CHAR2 DO;
                RETURN 0;
            ENDIF;

         ENDFOR;


         FUNCTION LLE(A'STRING, A'LESSER'STRING), FRETURN;
        RETURN (N' LGT(A'STRING, A'LESSER'STRING// FRETURN));


         FUNCTION LLT(A'LESSER'STRING, A'STRING), FRETURN;
        RETURN LGT(A'STRING, A'LESSER'STRING// FRETURN);


         FUNCTION LGE(A'LESSER'STRING, A'STRING), FRETURN;
        RETURN (N' LGT(A'STRING, A'LESSER'STRING// FRETURN));


         END;

        PROGRAM REPEAT;

*      THIS FUNCTION TAKES THREE ARGUMENTS, THE FIRST OF WHICH SPECIFIES
* THE STRING TO BE WRITTEN INTO AND THE SECOND SPECIFIES THE STRING TO
* BE COPIED, AND THE THIRD SPECIFIES HOW MANY TIMES THE SECOND ARGUMENT
* IS TO BE COPIED INTO THE SECOND.  THE FUNCTION FAILS IF THE STRINGS
* HAVE DIFFERENT CHARACTER SIZES OR THE FIRST ARGUEMENT ISN'T LONG
* ENOUGH TO HOLD THE SECOND ARGUMENT THE SPECIFIED NUMBER OF TIMES.
* THE USUAL CONVENTIONS ABOUT THE STATUS OF THE ARGUMENTS HOLD.

         INCLUDE STRING'DEFS;

         DECLARE INTEGER
         COUNTER0,
         COUNTER1,
         LENGTH'REFERENCE,
         NUMBER'OF'CHARS,   /* THE TOTAL NUMBER OF CHARACTERS TO BE  */
/*   WRITTEN INTO THE FIRST ARGUMENT     */
         NUMBER'OF'TIMES,
         REFERENCE'SAVE;

         DECLARE STRING
*         OBJECT,            /* STRING TO APPEND TO                   */
         REFERENCE,         /* STRING TO COPY FROM                   */
         WORKING'NAME;



         UNKNOWN FUNCTION REPEAT(STRING @OBJECT, REFERENCE,
         NUMBER'OF'TIMES), FRETURN;

         FRETURN IF NUMBER'OF'TIMES < 0;
        WORKING'NAME ← OBJECT.STRING'DESC;
        FRETURN IF REFERENCE$CHAR'SIZE # WORKING'NAME$CHAR'SIZE;

         LENGTH'REFERENCE ← LENGTH(REFERENCE);
        NUMBER'OF'CHARS ← NUMBER'OF'TIMES*LENGTH(REFERENCE);
        FRETURN IF LNGDES(WORKING'NAME$WP, WORKING'NAME$EP) <
         NUMBER'OF'CHARS;

         RETURN IF NUMBER'OF'CHARS = 0;
        REFERENCE'SAVE ← REFERENCE$RP;
        FOR COUNTER0 ← 1 TO NUMBER'OF'TIMES DO;
            WCI(GCI(REFERENCE), WORKING'NAME) FOR
             COUNTER1 ← 1 TO LENGTH'REFERENCE;
            REFERENCE$RP ← REFERENCE'SAVE;
        ENDFOR;

         OBJECT.WP ← WORKING'NAME$WP;

         RETURN;


         END;

        PROGRAM COMPARE'STRING;

*      THIS FUNCTION COMPARES TWO STRING AND RETURNS -1 IF THEY ARE
* IDENTICAL AND 0 IF THEY AREN'T.  THIS FUNCTION FAILS IF THE TWO STRINGS
* DON'T HAVE THE SAME CHARACTER SIZES.

         INCLUDE STRING'DEFS;

         DECLARE INTEGER
         CHAR1,            /* A CHARACTER READ FROM THE STRING FIRST */
         CHAR2,            /* A CHARACTER READ FROM THE STRING       */
/*   SECOND                               */
         COUNT,            /* JUST A COUNTER FOR A FOR LOOP          */
         LENGTH'FIRST;     /* THE LENGTH OF THE STRING FIRST         */

         DECLARE STRING
         FIRST,
         SECOND;


         FUNCTION COMPARE'STRING(FIRST, SECOND), FRETURN;

         CATASTROPHE IF FIRST$CHAR'SIZE # SECOND$CHAR'SIZE;
        LENGTH'FIRST ← LENGTH(FIRST);

         IF LENGTH'FIRST # LENGTH(SECOND) DO;
            RETURN 0;
        ELSE DO;
            FOR COUNT ← 1 TO LENGTH'FIRST DO;
                CHAR1 ← GCI(FIRST);
                CHAR2 ← GCI(SECOND);
                RETURN 0 IF CHAR1 # CHAR2;
            ENDFOR;
            RETURN -1;
        ENDIF;



         END;

        PROGRAM DET'END'OF'FILE;

*      THIS FUNCTION DETERMINES WHERE THE LAST ACTUAL CHARACTER OF THE
* FILE IS.  THE MONITOR KNOWS THE LENGTH OF THE FILE IN WORDS.  THE
* REASON THINGS ARE SO INEXACT IS BECAUSE NO ONE KNEW HOW MANY EOF'S OLD
* SPL WROTE INTO FILES.  THIS FUNCTION WILL SET THE WRITE POINTER OF
* THE STRING TO THE RIGHT PLACE IF THE FIRST EOF IS ANYWHERE IN THE LAST
* WORD OR EVEN IF THERE IS NO EOF WRITTEN.  THE FUNCTION RETURNS A
* STRING DESCRIPTOR SETUP TO READ HOWEVER MANY CHARACTERS ARE LEFT IN
* THE FILE.

         INCLUDE GLOBAL'VARIABLES;

         DECLARE INTEGER
         CHAR,              /* A CHARACTER READ FROM THE STRING      */
         COUNT;             /* JUST A COUNTER FOR A FOR LOOP        */

         DECLARE PARAMETER
         CHARS'TO'CHECK ← 3;/* THE SPAN OF CHARACTERS CHECKED WHILE  */
/*   LOOKING FOR THE EOF CHARACTER       */

         DECLARE POINTER
         FILE;              /* A POINTER TO THE WINDOW IN USE        */

         DECLARE STRING
         LAST'FILE'PAGE;    /* THE STRING WHICH OVERLAYS THE WORDS   */
/*   OF THE FILE                         */



         STRING FUNCTION DET'END'OF'FILE(FILE), FRETURN;

         SETUP'KLUDGE(LAST'FILE'PAGE, FILE.CHARS'LEFT,
         FILE.WINDOW'ADDRESS, FILE.CHARACTER'SIZE// FRETURN);
        LAST'FILE'PAGE$WP ← LAST'FILE'PAGE$EP;
        LAST'FILE'PAGE$RP ← INCDES(LAST'FILE'PAGE$EP, -CHARS'TO'CHECK);

         FOR COUNT ← 1 TO CHARS'TO'CHECK DO;
            GOTO END'OF'FILE IF (CHAR ← GCI(LAST'FILE'PAGE) A' 177B = EOF);
        ENDFOR;
END'OF'FILE:
        LAST'FILE'PAGE$WP ← INCDES(LAST'FILE'PAGE$RP, -1) IF CHAR = EOF;
        SETR(LAST'FILE'PAGE, 0);
        FILE.CHARS'LEFT ← 0;

         RETURN LAST'FILE'PAGE;


         END;

        PROGRAM CONS'ARRAY'DESC;

*      THIS FUNCTION CREATES AN ARRAY DESCRIPTOR GIVEN THE BASE ADDRESS,
* THE NUMBER OF ELEMENTS, ELEMENT SIZE, AND LOWER BOUND.  THIS FUNCTION
* FAILS IF ONE THE THE ARGUMENTS ARE INVALID.

         INCLUDE ARRAY'DEFS;

         DECLARE ARRAY
         ARRAY'DESC;

         DECLARE FIELD
         MULTIPLIER,        /* WHAT IT IS DEPENDS ON LEB             */
         UPPER'LIMIT;       /* WHAT IT IS DEPENDS ON LEB             */

         DECLARE INTEGER
         BASE'ADDRESS,      /* FIRST ADDRESS THAT STORAGE BEGINS IN  */
         ELEMENT'SIZE,      /* NUMBER OF WORDS PER ENTRY             */
         KLUDGE,
         LARGE'ELEMENT,
         LOWER'BOUND,       /* AN ARRAY OR AN ARRAYONE               */
         NO'OF'ELEMENTS,    /* NUMBER OF ELEMENTS                    */
         UPPER'BOUND;       /* HIGHEST VALID SUBSCRIPT               */



         ARRAY FUNCTION CONS'ARRAY'DESC(BASE'ADDRESS, NO'OF'ELEMENTS,
         ELEMENT'SIZE, LOWER'BOUND), FRETURN;

* CHECK THE PARAMETERS PASSED TO SEE IF THEY ARE VALID
         FRETURN IF (BASE'ADDRESS < 0 OR BASE'ADDRESS > (-1)$IAW'ADDRESS);
        FRETURN IF NO'OF'ELEMENTS < 0;
        FRETURN IF (ELEMENT'SIZE < 1 OR ELEMENT'SIZE >
         (-1)$ITEM'SIZE'LEB1 + 1);
        FRETURN IF (LOWER'BOUND # 0 AND LOWER'BOUND # 1);

* SET UP THE FIELDS FOR SMALL OR LARGE ELEMENT CASES
         IF ELEMENT'SIZE <= 4 DO;
            LARGE'ELEMENT ← 0;
            MULTIPLIER ← ITEM'SIZE'LEB0;
            UPPER'LIMIT ← UPPER'BOUND'LEB0;
        ELSE DO;
            LARGE'ELEMENT ← 1;
            MULTIPLIER ← ITEM'SIZE'LEB1;
            UPPER'LIMIT ← UPPER'BOUND'LEB1;
        ENDIF;

* COMPUTE AND CHECK UPPER'BOUND
         UPPER'BOUND ← LOWER'BOUND + NO'OF'ELEMENTS - 1;
*      A CONSTANT OR PARAMETER TAILED WITH A VARIABLE FIELD CAUSES SPL
* TO GENERATE INCORRECT CODE, SO HERE'S THE KLUDGE.
         KLUDGE ← -1;
        FRETURN IF UPPER'BOUND > KLUDGE$UPPER'LIMIT;

* CONSTRUCT AND RETURN THE DESCRIPTOR
         ARRAY'DESC$IAW'TYPE ← ARRAY'IAW;
        ARRAY'DESC$INDEXING'ORIGIN ← LOWER'BOUND;
        ARRAY'DESC$ARRAY'TRAP'BIT ← 0;
        ARRAY'DESC$LEB ← LARGE'ELEMENT;
        ARRAY'DESC$MULTIPLIER ← ELEMENT'SIZE - 1;
        ARRAY'DESC$UPPER'LIMIT ← UPPER'BOUND;
        ARRAY'DESC$ARRAY'DESC'ADDR ← NORMAL'IAW@IAW'TYPE V'
         INDEXED@IAW'TAG V' 0@IAW'TRAP V' BASE'ADDRESS@IAW'ADDRESS;

         RETURN ARRAY'DESC;


         END;

        PROGRAM LONG'COMPARE;

*      THIS PROGRAM BLOCK CONTAINS TWO FUNCTIONS WHICH COMPARE TWO
* OBJECT OF LENGTH GREATER THAN ONE WORD.  THE FIRST FUNCTION, LONG'-
* COMPARE IS INTENDED TO JUST COMPARE LONGS.  THE SECOND FUNCTION IS
* MORE GENERAL AND WILL COMPARE BLOCKS OF WORDS STARTING AT THE FIRST
* ARGUMENT AGAINST THOSE STARTING AT THE SECOND ARGUMENT FOR THE NUMBER
* OF WORDS SPECIFIED BY THE THIRD ARGUMENT.

         DECLARE FIELD
         W0(0),
         W1(1);

         DECLARE INTEGER
         CNTRLED'VARIABLE;

         DECLARE LONG
         X,
         Y;

         DECLARE POINTER
         THIS,
         THAT;


         FUNCTION LONG'COMPARE(X, Y);

         IF X$W0 = Y$W0 AND X$W1 = Y$W1 DO;
            RETURN -1;
        ELSE DO;
            RETURN 0;
        ENDIF;



         FUNCTION BLOCK'COMPARE(@THIS, @THAT, THIS'MANY);

         FOR CNTRLED'VARIABLE ← 1 TO THIS'MANY DO;
            RETURN 0 IF THIS[CNTRLED'VARIABLE].W0 #
             THAT[CNTRLED'VARIABLE].W0;
        ENDFOR;
        RETURN -1;


         END;

        PROGRAM ENTRIES;

* THIS PROGRAM BLOCK CONTAINS THE ENTRY POINTS TO THE WHOLE PROGRAM

         INCLUDE ENTRY'DEFS;

         DECLARE INTEGER
         SP'INT'NO = L' [0],
         SP'TRAP'NO = L' [0],
         SP'TRAP'PARAM = L' [1];



* SUB-PROCESS TRAP ENTRY POINT
         FUNCTION SP'TRAP'ENTRY(), SP'ENTRY ← 0;
        SAVE'STATE(STATE);
        EXIT();



* INTERRUPT ENTRY POINT
         FUNCTION INTERRUPT'ENTRY(), SP'ENTRY ← 1;
        SAVE'STATE(STATE);
        EXIT();



* INITIAL ENTRY POINT
         FUNCTION INITIAL'ENTRY(), SP'ENTRY ← 2;
        STACK'POINTER ← INITIAL'SP;
        STACK'LIMIT ← INITIAL'SL;
        INITIALIZE(1);
        EXIT();



* CONTINUE ENTRY POINT
         FUNCTION CONTINUE'ENTRY(), SP'ENTRY ← 3;
        STACK'POINTER ← INITIAL'SP;
        STACK'LIMIT ← INITIAL'SL;
/*CONTINUE'*/INITIALIZE(0);
        EXIT();



         END;

        PROGRAM HELP;
        FUNCTION HELP();
        PUTA("HELP!!!!!!!", 1);
BREAK:  EXIT();
        END;

        COMMON FIELD'DESC;

         DECLARE FIELD

         OLD'DATA(0:0,7),
         OLD'COUNT(0:8,11),
         OP'SORT(0:3,10),
         INCRE(0:0,2),
         B'7'7 (0:7,7),
         B'16'19 (0:16,19),
         B'21'23 (0:21,23),
         B'18'19 (0:18,19),
         B'8'23 (0:8,23),
         PSW (0:0,7),
         REG'A (0:8,15),
         REG'B (1:0, 7),
         REG'C (1:8,15),
         REG'D (2:0,7),
         REG'E (2:8,15),
         REG'H (3:0,7),
         REG'L (3:8,15),
         REG'B'C (1:0,15),
         REG'D'E (2:0,15),
         REG'H'L (3:0,15),
         B'20'23 (0:20,23),
         B'23'23 (0:23,23),
         B'15'15 (0:15,15),
         B'16'16 (0:16,16),
         B'19'19 (0:19,19),
         B'16'23 (0:16,23),
         B'8'15 (0:8,15),
         B'0'7 (0:0,7),
         CARRY'BIT (0:7,7),
         SIGN'BIT (0:0,0),
         ZERO'BIT (0:1,1),
         AUX'CARRY (0:3,3),
         PARITY'BIT (0:5,5),
         B'18'20 (0:18,20);


         END;  /*  END FIELD'DESC.  */

        COMMON SIMU'VARS;
*
*  THIS COMMON BLOCK DEFINES ALL GLOBAL VARIABLES USED IN
*  THE SIMULATOR.  ALL PERMANENT STORAGE IS DECLARED IN THIS BLOCK.
*
*

*  THIS DECLARES THE INSTRUCTION OPCODES AND THEIR LENGTH.
*
         DECLARE INTEGER ARRAY INSTR'DATA[256] ←
         (16340000B,34360000B,14200000B,14220000B,14240000B,14260000B,24300000B,14320000B);
        DECLARE INTEGER ARRAY INSTR'DATA[8] ←
         (-3440000B,14160000B,14000000B,14020000B,14040000B,14060000B,24100000B,14120000B);
        DECLARE INTEGER ARRAY INSTR'DATA[16] ←
         (-3640000B,36140000B,15160000B,15000000B,15020000B,15040000B,25060000B,15100000B);
        DECLARE INTEGER ARRAY INSTR'DATA[24] ←
         (-2660000B,15140000B,17140000B,16320000B,16700000B,17700000B,21360000B,11760000B);
        DECLARE INTEGER ARRAY INSTR'DATA[32] ←
         (-2020000B,35600000B,35620000B,15640000B,15660000B,15700000B,25720000B,15740000B);
        DECLARE INTEGER ARRAY INSTR'DATA[40] ←
         (-1300000B,16100000B,37500000B,17300000B,17740000B,17100000B,26300000B,11160000B);
        DECLARE INTEGER ARRAY INSTR'DATA[48] ←
         (-7560000B,30620000B,31220000B,11620000B,11720000B,10120000B,20320000B,10520000B);
        DECLARE INTEGER ARRAY INSTR'DATA[56] ←
         (-7060000B,11120000B,31320000B,11520000B,10260000B,10660000B,21260000B,11660000B);
        DECLARE INTEGER ARRAY INSTR'DATA[64] ←
         (17460000B,17660000B,13540000B,16660000B,11700000B,10100000B,10300000B,10500000B);
        DECLARE INTEGER ARRAY INSTR'DATA[72] ←
         (10700000B,11100000B,11300000B,11500000B,10060000B,10460000B,11060000B,11460000B);
        DECLARE INTEGER ARRAY INSTR'DATA[80] ←
         (16640000B,17640000B,16060000B,16440000B,16040000B,17440000B,17240000B,17040000B);
        DECLARE INTEGER ARRAY INSTR'DATA[88] ←
         (16240000B,11640000B,10240000B,10640000B,11240000B,10020000B,10420000B,11020000B);
        DECLARE INTEGER ARRAY INSTR'DATA[96] ←
         (11420000B,13760000B,13600000B,13620000B,13640000B,13660000B,13700000B,13720000B);
        DECLARE INTEGER ARRAY INSTR'DATA[104] ←
         (13740000B,12160000B,12000000B,12020000B,12040000B,12060000B,12100000B,12120000B);
        DECLARE INTEGER ARRAY INSTR'DATA[112] ←
         (12140000B,12360000B,12200000B,12220000B,12240000B,12260000B,12300000B,12320000B);
        DECLARE INTEGER ARRAY INSTR'DATA[120] ←
         (12340000B,12560000B,12400000B,12420000B,12440000B,12460000B,12500000B,12520000B);
        DECLARE INTEGER ARRAY INSTR'DATA[128] ←
         (12540000B,12760000B,12600000B,12620000B,12640000B,12660000B,12700000B,12720000B);
        DECLARE INTEGER ARRAY INSTR'DATA[136] ←
         (12740000B,13160000B,13000000B,13020000B,13040000B,13060000B,13100000B,13120000B);
        DECLARE INTEGER ARRAY INSTR'DATA[144] ←
         (13140000B,13360000B,13200000B,13220000B,13240000B,13260000B,13300000B,13320000B);
        DECLARE INTEGER ARRAY INSTR'DATA[152] ←
         (13340000B,13560000B,13400000B,13420000B,13440000B,13460000B,13500000B,13520000B);
        DECLARE INTEGER ARRAY INSTR'DATA[160] ←
         (11740000B,10140000B,10340000B,10540000B,10740000B,11140000B,11340000B,11540000B);
        DECLARE INTEGER ARRAY INSTR'DATA[168] ←
         (10000000B,15560000B,15400000B,15420000B,15440000B,15460000B,15500000B,15520000B);
        DECLARE INTEGER ARRAY INSTR'DATA[176] ←
         (15540000B,17540000B,16460000B,17220000B,16020000B,16420000B,17020000B,17420000B);
        DECLARE INTEGER ARRAY INSTR'DATA[184] ←
         (16120000B,16520000B,17120000B,17520000B,10560000B,10760000B,16600000B,16220000B);
        DECLARE INTEGER ARRAY INSTR'DATA[192] ←
         (10160000B,17600000B,36400000B,36000000B,37400000B,17200000B,27000000B,10360000B);
        DECLARE INTEGER ARRAY INSTR'DATA[200] ←
         (16160000B,16360000B,36560000B,-1020000B,37160000B,37360000B,27560000B,17760000B);
        DECLARE INTEGER ARRAY INSTR'DATA[208] ←
         (16200000B,14760000B,34600000B,24620000B,34640000B,14660000B,24700000B,14720000B);
        DECLARE INTEGER ARRAY INSTR'DATA[216] ←
         (14740000B,-1040000B,31040000B,27620000B,31440000B,-7740000B,20440000B,11560000B);
        DECLARE INTEGER ARRAY INSTR'DATA[224] ←
         (14560000B,14400000B,34420000B,14440000B,34460000B,14500000B,24520000B,14540000B);
        DECLARE INTEGER ARRAY INSTR'DATA[232] ←
         (16540000B,10200000B,30400000B,10600000B,31000000B,-6600000B,21400000B,11600000B);
        DECLARE INTEGER ARRAY INSTR'DATA[240] ←
         (16260000B,16620000B,36720000B,17320000B,37720000B,17260000B,25360000B,15200000B);
        DECLARE INTEGER ARRAY INSTR'DATA[248] ←
         (15220000B,15240000B,35260000B,15300000B,35320000B,-2440000B,37340000B,17060000B);
        DECLARE INTEGER ARRAY INSTR'DATA[248] ←
         (15220000B,15240000B,35260000B,15300000B,35320000B,-2440000B,37340000B,17060000B);

*  THIS STRING ARRAY IS USED TO DUMP CORE IN MNEMONIC FORM.
*
         DECLARE STRING(8) ARRAY INSTR'MNEMONICS[256] ←
         ("NOP", "LXI B", "STAX B", "INX B", "INR B", "DCR B", "MVI B", "RLC");
        DECLARE STRING(8) ARRAY INSTR'MNEMONICS[8] ←
         ("TRAP", "DAD B", "LDAX B", "DCX B", "INR C", "DCR C", "MVI C", "RRC");
        DECLARE STRING(8) ARRAY INSTR'MNEMONICS[16] ←
         ("TRAP", "LXI D", "STAX D", "INX D", "INR D", "DCR D", "MVI D", "RAL");
        DECLARE STRING(8) ARRAY INSTR'MNEMONICS[24] ←
         ("TRAP", "DAD D", "LDAX D", "DCX D", "INR E", "DCR E", "MVI E", "RAR");
        DECLARE STRING(8) ARRAY INSTR'MNEMONICS[32] ←
         ("TRAP", "LXI H", "SHLD", "INX H", "INR H", "DCR H", "MVI H", "DAA");
        DECLARE STRING(8) ARRAY INSTR'MNEMONICS[40] ←
         ("TRAP", "DAD H", "LHLD", "DCX H", "INR L", "DCR L", "MVI L", "CMA");
        DECLARE STRING(8) ARRAY INSTR'MNEMONICS[48] ←
         ("TRAP", "LXI SP", "STA", "INX SP", "INR M", "DCR M", "MVI M", "STC");
        DECLARE STRING(8) ARRAY INSTR'MNEMONICS[56] ←
         ("TRAP", "DAD SP", "LDA", "DCX SP", "INR A", "DCR A", "MVI A", "CMC");
        DECLARE STRING(8) ARRAY INSTR'MNEMONICS[64] ←
         ("MOV B,B", "MOV B,C", "MOV B,D", "MOV B,E", "MOV B,H", "MOV B,L", "MOV B,M", "MOV B,A");
        DECLARE STRING(8) ARRAY INSTR'MNEMONICS[72] ←
         ("MOV C,B", "MOV C,C", "MOV C,D", "MOV C,E", "MOV C,H", "MOV C,L", "MOV C,M", "MOV C,A");
        DECLARE STRING(8) ARRAY INSTR'MNEMONICS[80] ←
         ("MOV D,B", "MOV D,C", "MOV D,D", "MOV D,E", "MOV D,H", "MOV D,L", "MOV D,M", "MOV D,A");
        DECLARE STRING(8) ARRAY INSTR'MNEMONICS[88] ←
         ("MOV E,B", "MOV E,C", "MOV E,D", "MOV E,E", "MOV E,H", "MOV E,L", "MOV E,M", "MOV E,A");
        DECLARE STRING(8) ARRAY INSTR'MNEMONICS[96] ←
         ("MOV H,B", "MOV H,C", "MOV H,D", "MOV H,E", "MOV H,H", "MOV H,L", "MOV H,M", "MOV H,A");
        DECLARE STRING(8) ARRAY INSTR'MNEMONICS[104] ←
         ("MOV L,B", "MOV L,C", "MOV L,D", "MOV L,E", "MOV L,H", "MOV L,L", "MOV L,M", "MOV L,A");
        DECLARE STRING(8) ARRAY INSTR'MNEMONICS[112] ←
         ("MOV M,B", "MOV M,C", "MOV M,D", "MOV M,E", "MOV M,H", "MOV M,L", "HLT", "MOV M,A");
        DECLARE STRING(8) ARRAY INSTR'MNEMONICS[120] ←
         ("MOV A,B", "MOV A,C", "MOV A,D", "MOV A,E", "MOV A,H", "MOV A,L", "MOV A,M", "MOV A,A");
        DECLARE STRING(8) ARRAY INSTR'MNEMONICS[128] ←
         ("ADD B", "ADD C", "ADD D", "ADD E", "ADD H", "ADD L", "ADD M", "ADD A");
        DECLARE STRING(8) ARRAY INSTR'MNEMONICS[136] ←
         ("ADC B", "ADC C", "ADC D", "ADC E", "ADC H", "ADC L", "ADC M", "ADC A");
        DECLARE STRING(8) ARRAY INSTR'MNEMONICS[144] ←
         ("SUB B", "SUB C", "SUB D", "SUB E", "SUB H", "SUB L", "SUB M", "SUB A");
        DECLARE STRING(8) ARRAY INSTR'MNEMONICS[152] ←
         ("SBB B", "SBB C", "SBB D", "SBB E", "SBB H", "SBB L", "SBB M", "SBB A");
        DECLARE STRING(8) ARRAY INSTR'MNEMONICS[160] ←
         ("ANA B", "ANA C", "ANA D", "ANA E", "ANA H", "ANA L", "ANA M", "ANA A");
        DECLARE STRING(8) ARRAY INSTR'MNEMONICS[168] ←
         ("XRA B", "XRA C", "XRA D", "XRA E", "XRA H", "XRA L", "XRA M", "XRA A");
        DECLARE STRING(8) ARRAY INSTR'MNEMONICS[176] ←
         ("ORA B", "ORA C", "ORA D", "ORA E", "ORA H", "ORA L", "ORA M", "ORA A");
        DECLARE STRING(8) ARRAY INSTR'MNEMONICS[184] ←
         ("CMP B", "CMP C", "CMP D", "CMP E", "CMP H", "CMP L", "CMP M", "CMP A");
        DECLARE STRING(8) ARRAY INSTR'MNEMONICS[192] ←
         ("RNZ", "POP B", "JNZ", "JMP", "CNZ", "PUSH B", "ADI", "RST 0");
        DECLARE STRING(8) ARRAY INSTR'MNEMONICS[200] ←
         ("RZ", "RET", "JZ", "TRAP", "CZ", "CALL", "ACI", "RST 1");
        DECLARE STRING(8) ARRAY INSTR'MNEMONICS[208] ←
         ("RNC", "POP D", "JNC", "OUT", "CNC", "PUSH D", "SUI", "RST 2");
        DECLARE STRING(8) ARRAY INSTR'MNEMONICS[216] ←
         ("RC", "TRAP", "JC", "IN", "CC", "TRAP", "SBI", "RST 3");
        DECLARE STRING(8) ARRAY INSTR'MNEMONICS[224] ←
         ("RPO", "POP H", "JPO", "XTHL", "CPO", "PUSH H", "ANI", "RST 4");
        DECLARE STRING(8) ARRAY INSTR'MNEMONICS[232] ←
         ("RPE", "PCHL", "JPE", "XCHG", "CPE", "TRAP", "XRI", "RST 5");
        DECLARE STRING(8) ARRAY INSTR'MNEMONICS[240] ←
         ("RP", "POP PSW", "JP", "DI", "CP", "PUSH PSW", "ORI", "RST 6");
        DECLARE STRING(8) ARRAY INSTR'MNEMONICS[248] ←
         ("RM", "SPHL", "JM", "EI", "CM", "TRAP", "CPI", "RST 7");

         DECLARE INTEGER ARRAY INSTR'INCRE[256];

         DECLARE INTEGER ARRAY INSTR'INCRE[0] ←
         (1,3,1,1,1,1,2,1);
        DECLARE INTEGER ARRAY INSTR'INCRE[8] ←
         (-1,1,1,1,1,1,2,1);
        DECLARE INTEGER ARRAY INSTR'INCRE[16] ←
         (-1,3,1,1,1,1,2,1);
        DECLARE INTEGER ARRAY INSTR'INCRE[24] ←
         (-1,1,1,1,1,1,2,1);
        DECLARE INTEGER ARRAY INSTR'INCRE[32] ←
         (-1,3,3,1,1,1,2,1);
        DECLARE INTEGER ARRAY INSTR'INCRE[40] ←
         (-1,1,3,1,1,1,2,1);
        DECLARE INTEGER ARRAY INSTR'INCRE[48] ←
         (-1,3,3,1,1,1,2,1);
        DECLARE INTEGER ARRAY INSTR'INCRE[56] ←
         (-1,1,3,1,1,1,2,1);
        DECLARE INTEGER ARRAY INSTR'INCRE[64] ←
         (1,1,1,1,1,1,1,1);
        DECLARE INTEGER ARRAY INSTR'INCRE[72] ←
         (1,1,1,1,1,1,1,1);
        DECLARE INTEGER ARRAY INSTR'INCRE[80] ←
         (1,1,1,1,1,1,1,1);
        DECLARE INTEGER ARRAY INSTR'INCRE[88] ←
         (1,1,1,1,1,1,1,1);
        DECLARE INTEGER ARRAY INSTR'INCRE[96] ←
         (1,1,1,1,1,1,1,1);
        DECLARE INTEGER ARRAY INSTR'INCRE[104] ←
         (1,1,1,1,1,1,1,1);
        DECLARE INTEGER ARRAY INSTR'INCRE[112] ←
         (1,1,1,1,1,1,1,1);
        DECLARE INTEGER ARRAY INSTR'INCRE[120] ←
         (1,1,1,1,1,1,1,1);
        DECLARE INTEGER ARRAY INSTR'INCRE[128] ←
         (1,1,1,1,1,1,1,1);
        DECLARE INTEGER ARRAY INSTR'INCRE[136] ←
         (1,1,1,1,1,1,1,1);
        DECLARE INTEGER ARRAY INSTR'INCRE[144] ←
         (1,1,1,1,1,1,1,1);
        DECLARE INTEGER ARRAY INSTR'INCRE[152] ←
         (1,1,1,1,1,1,1,1);
        DECLARE INTEGER ARRAY INSTR'INCRE[160] ←
         (1,1,1,1,1,1,1,1);
        DECLARE INTEGER ARRAY INSTR'INCRE[168] ←
         (1,1,1,1,1,1,1,1);
        DECLARE INTEGER ARRAY INSTR'INCRE[176] ←
         (1,1,1,1,1,1,1,1);
        DECLARE INTEGER ARRAY INSTR'INCRE[184] ←
         (1,1,1,1,1,1,1,1);
        DECLARE INTEGER ARRAY INSTR'INCRE[192] ←
         (1,1,3,3,3,1,2,1);
        DECLARE INTEGER ARRAY INSTR'INCRE[200] ←
         (1,1,3,-1,3,3,2,1);
        DECLARE INTEGER ARRAY INSTR'INCRE[208] ←
         (1,1,3,2,3,1,2,1);
        DECLARE INTEGER ARRAY INSTR'INCRE[216] ←
         (1,-1,3,2,3,-1,2,1);
        DECLARE INTEGER ARRAY INSTR'INCRE[224] ←
         (1,1,3,1,3,1,2,1);
        DECLARE INTEGER ARRAY INSTR'INCRE[232] ←
         (1,1,3,1,3,-1,2,1);
        DECLARE INTEGER ARRAY INSTR'INCRE[240] ←
         (1,1,3,1,3,1,2,1);
        DECLARE INTEGER ARRAY INSTR'INCRE[248] ←
         (1,1,3,1,3,-1,2,1);

*  THESE VARIABLES DECLARE THE STRING MESSAGES
*  TO BE ISSUED DURING ERROR CONDITIONS.
*
         DECLARE STRING(30) ARRAY MESS1[11] ←
         ("BREAK POINT",
         "NON-EXISTENT INSTRUCTION",
         "MEMORY WRITE ERROR",
         "MEMORY READ ERROR",
         "I/O PORT NOT SUPPORTED",
         "PROGRAM HALT",
         "INTERRUPT INSTRUCTION IGNORED",
         "CNTL-K ON INPUT",
         "CNTL-K ON OUTPUT",
         "CONTROL BREAK",
         "CONTROL TRACE");

         DECLARE STRING(30) ARRAYONE MESS2[9] ←
         ("IMPROPER OBJECT FILE FORMAT",
         "CONVERSION ERROR",
         "UNEXPECTED EOF DURING LOADING",
         "CHECK SUM ERROR",
         "COMMAND NOT IMPLEMENTED",
         "WHAT?",
         "BREAK POINT NOT FOUND");

         DECLARE STRING(30) ARRAYONE MESS2[8] ←
         ("EXPRESSION ERROR",
         "MNEMONIC ERROR");

         DECLARE PARAMETER
         MAX'MEM ← 65536, /* DEFINES THE MAXIMUM MEMORY SIZE */
         ACC ← 7;

         DECLARE STRING
         MEMORY;           /* THE 8080'S MEMORY */

         DECLARE INTEGER ARRAY
*        SYMBOL TABLE STRING SPACE
         SYMBOL'SPACE[2000],
*        VALUES OF SYMBOLS
         VALUES[1000],
*        SORT POINTERS
         SORT'PTRS[1000],
         B'P'TABLE[100],  /*  BREAK POINT TABLE  */
         OLD'STORE[8],  /*  FOR THE DUMP ROUTINE  */
*                          CONTAINS THE OLD CONTENTS OF REGISTERS
         REG'STORE[8];   /*  REGISTER FILE  */

         DECLARE INTEGER
         DUMP'BREAK,
         CONTROL'TRACE,  /*  CONTROLS THIS FEATURE  */
         CONTROL'BREAK,  /*  SIMILAR TO ABOVE  */
         CURRENT'LINE,   /*  VALUE OF PREVIOUS  EXPRESSION  */
         SYMBOL'START ← @SYMBOL'SPACE[0],
*        THIS IS A POINTER TO THE START OF THE SYMBOL STRING.
         LAST'SYMBOL,      /*  LAST SYMBOL IN SYMBOL TABLE  */
         MODE,             /*  MODE OF OUTPUT  */
         REG'AREA ← @REG'STORE[0],
         NEXT'B'P,        /*  POINTER TO NEXT ELEMENT IN  */
*                             BREAK POINT TABLE.
         P'COUNTER,        /*  PROGRAM COUNTER  */
         CURRENT'INSTR,    /*  CURRENT INSTRUCTION BEING EXECUTED.  */
         STACK;            /*  STACK POINTER  */

         END;  /*  END SIMU'VARS.  */

        COMMON MESSAGE'BLOCK;

         DECLARE STRING(60) ARRAYONE MESSAGES[12];
        DECLARE STRING(60) ARRAYONE MESSAGES[1] ←

         ("SYMBOL WAS NOT FOUND.",
         "CONVERSION ERROR FOR HEX NUMBER.",
         "CONVERSION ERROR FOR DECIMAL NUMBER.",
         "LITERAL DID NOT FOLLOW AFTER QUOTE.",
         "LABEL IS GREATER THAN 5 CHARACTERS LONG.",
         "LABEL STARTS WITH A NUMBER.",
         "DUPLICATE LABEL FOUND.",
         "NO OPCODE FIELD FOUND.");

         DECLARE STRING(60) ARRAYONE MESSAGES[9] ←
         ("ILLEGAL OPCODE IN STATEMENT.",
         "2 OPERANDS REQUIRED.  ONLY ONE FOUND.",
         "REGISTER VALUE SPECIFIED OUT OF RANGE.",
         "OPERAND IS LARGER THAN 8 BITS.");
        END;

        PROGRAM ALU;
*
*  THIS PROGRAM BLOCK CONTAINS ALL THE FUNCTIONS NECESSARY TO
*  CARRY OUT ALL OF THE 8080 ARITHMETIC AND LOGIC FUNCTIONS.
*

         INCLUDE SIMU'VARS, FIELD'DESC;

         DECLARE INTEGER
         DATA,
         I1, I2, I3, I4;

         FUNCTION ADD(DATA);

         I1 ← REG'AREA.REG'A;
        I2 ← I1 + DATA;
        I3 ← I1$B'20'23 + DATA$B'20'23;
        SET'STATUS(I2, I3);
        REG'AREA.REG'A ← I2;
        RETURN;

         FUNCTION ADC(DATA);

         I1 ← REG'AREA.REG'A;
        I2 ← I1 + DATA + REG'AREA.CARRY'BIT;
        I3 ← I1$B'20'23 + DATA$B'20'23 + REG'AREA.CARRY'BIT;
        SET'STATUS(I2, I3);
        REG'AREA.REG'A ← I2;
        RETURN;

         FUNCTION SUB(DATA);

         I4 ← (N' DATA)$B'16'23;
        I1 ← REG'AREA.REG'A;
        I2 ← I1 + I4 + 1;
        I3 ← I1$B'20'23 + I4$B'20'23 + 1;
        SET'STATUS(I2, I3);
*       REVERSE THE SENSE OF THE CARRY BIT SINCE
*       THIS IS A SUBTRACTION.
         REG'AREA.CARRY'BIT ← N' REG'AREA.CARRY'BIT;
        REG'AREA.REG'A ← I2;
        RETURN;

         FUNCTION SBB(DATA);

         I1 ← REG'AREA.REG'A;
        I4 ← (DATA + REG'AREA.CARRY'BIT)$B'16'23;
        I2 ← ((N' I4)+1)$B'16'23 + I1;
        I3 ← I1$B'20'23 + I4$B'20'23 + REG'AREA.CARRY'BIT + 1;
        SET'STATUS(I2, I3);
*       REVERSE THE SENSE OF THE CARRY BIT SINCE
*       THIS IS A SUBTRACTION.
         REG'AREA.CARRY'BIT ← N' REG'AREA.CARRY'BIT;
        REG'AREA.REG'A ← I2;
        RETURN;

         FUNCTION ANA(DATA);

         I2 ← REG'AREA.REG'A A' DATA;
        SET'STATUS(I2, 0);
        REG'AREA.REG'A ← I2;
        REG'AREA.CARRY'BIT ← 0;
        RETURN;

         FUNCTION XRA(DATA);

         I2 ← REG'AREA.REG'A E' DATA;
        SET'STATUS(I2, 0);
        REG'AREA.REG'A ← I2;
        REG'AREA.CARRY'BIT ← 0;
        RETURN;

         FUNCTION ORA(DATA);

         I2 ← REG'AREA.REG'A V' DATA;
        SET'STATUS(I2, 0);
        REG'AREA.REG'A ← I2;
        REG'AREA.CARRY'BIT ← 0;
        RETURN;

         FUNCTION CMP(DATA);

         I4 ← (N' DATA)$B'16'23;
        I1 ← REG'AREA.REG'A;
        I2 ← I1 + I4 + 1;
        I3 ← I1$B'20'23 + I4$B'20'23+1;
        SET'STATUS(I2, I3);
*       REVERSE THE SENSE OF THE CARRY BIT SINCE
*       THIS IS A SUBTRACTION.
         REG'AREA.CARRY'BIT ← N' REG'AREA.CARRY'BIT;
        RETURN;


         END;  /*  END ALU.  */

        PROGRAM CONTROL'INSTR;
*
*  THIS BLOCK CONTAINS ALL OF THE FUNCTIONS WHICH IMPLEMENT TRANSFER
*  OF CONTROL INSTRUCTIONS (E.G. JMP, CALL, RET).
*

         INCLUDE SIMU'VARS, FIELD'DESC;

         DECLARE INTEGER
         I1;

         FUNCTION RST'ADDRS(), FRETURN;

         IF CONTROL'BREAK
         DO;
            ERROR'MESSAGE(9);
            DUMP'REG() IF DUMP'BREAK;
            FRETURN;
        ELSEIF CONTROL'TRACE
         DO;
            ERROR'MESSAGE(10);
        ENDIF;
        I1 ← P'COUNTER+1;
        PUT'M(I1$B'8'15, STACK-1// FRETURN);
        PUT'M(I1$B'16'23,STACK-2// FRETURN);
        STACK ← STACK - 2;
        P'COUNTER ← CURRENT'INSTR$B'18'20 LSH 3;
        P'COUNTER ← P'COUNTER - 1;
        RETURN;

         FUNCTION PCHL'ADDR();

         IF CONTROL'BREAK
         DO;
            ERROR'MESSAGE(9);
            DUMP'REG() IF DUMP'BREAK;
            FRETURN;
        ELSEIF CONTROL'TRACE
         DO;
            ERROR'MESSAGE(10);
        ENDIF;
        P'COUNTER$B'8'15 ← REG'AREA.REG'H;
        P'COUNTER$B'16'23 ← REG'AREA.REG'L;
        P'COUNTER ← P'COUNTER - 1;
        RETURN;

         FUNCTION JUMP(), FRETURN;

         IF CONTROL'BREAK
         DO;
            ERROR'MESSAGE(9);
            DUMP'REG() IF DUMP'BREAK;
            FRETURN;
        ELSEIF CONTROL'TRACE
         DO;
            ERROR'MESSAGE(10);
        ENDIF;
        I1 ← 0;
        I1$B'16'23 ← GET'M(P'COUNTER + 1// FRETURN);
        I1$B'8'15 ← GET'M(P'COUNTER + 2// FRETURN);
        P'COUNTER ← I1 - 3;
        RETURN;

         FUNCTION CALL'ADDR(), FRETURN;

         IF CONTROL'BREAK
         DO;
            ERROR'MESSAGE(9);
            DUMP'REG() IF DUMP'BREAK;
            FRETURN;
        ELSEIF CONTROL'TRACE
         DO;
            ERROR'MESSAGE(10);
        ENDIF;
        I1 ← P'COUNTER + 3;
        PUT'M(I1$B'16'23, STACK - 2// FRETURN);
        PUT'M(I1$B'8'15, STACK - 1// FRETURN);
        STACK ← STACK - 2;
        I1 ← P'COUNTER;
        P'COUNTER$B'16'23 ← GET'M(I1+1// FRETURN);
        P'COUNTER$B'8'15 ← GET'M(I1+2// FRETURN);
        P'COUNTER ← P'COUNTER - 3;
        RETURN;

         FUNCTION RET'P(), FRETURN;

         IF CONTROL'BREAK
         DO;
            ERROR'MESSAGE(9);
            DUMP'REG() IF DUMP'BREAK;
            FRETURN;
        ELSEIF CONTROL'TRACE
         DO;
            ERROR'MESSAGE(10);
        ENDIF;
        P'COUNTER$B'16'23 ← GET'M(STACK// FRETURN);
        P'COUNTER$B'8'15 ← GET'M(STACK+1// FRETURN);
        STACK ← STACK + 2;
        P'COUNTER ← P'COUNTER - 1;
        RETURN;

         END;  /*  END CONTROL'INSTR.  */

        PROGRAM GET'D;
*
*  THIS DOES THE OPPOSITE OF PUT'D.
*

         INCLUDE SIMU'VARS, FIELD'DESC;

         DECLARE INTEGER
         RP;

         DECLARE LABEL ARRAY CASE[4] ←
         (CASE0, CASE1, CASE2, CASE3);

         FUNCTION GET'D(RP);

/*   HELP() IF RP < 0 OR RP > 3; */

         GOTO CASE[RP];

         CASE0:
        RETURN REG'AREA.REG'B'C;
        CASE1:
        RETURN REG'AREA.REG'D'E;
        CASE2:
        RETURN REG'AREA.REG'H'L;
        CASE3:
        RETURN STACK$B'8'23;

         END;  /*  END GET'D.  */

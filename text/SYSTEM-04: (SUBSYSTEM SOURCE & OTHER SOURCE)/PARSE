PARSE  IDENT
* PARAMETERS

BOXRATE EQU 1000               COST OF PRINTER PAPER IN CENTS/BOX
BOXSIZE EQU 3000               # SHEETS/BOX
PAPRATE EQU 2↑12*BOXRATE/BOXSIZE  SCALED UP BY 2↑12
CPRATE EQU 1138                =$10.00/HR, SCALED UP BY 2↑12 (WAS 5690, $50)
ONRATE EQU 114                 =$1.00/HR, SCALED UP BY 2↑12  (WAS 575,  $5)
NOTERM EQU 100

MSG    MACRO D,G,2; LDA =G(1); LDB =-1; LDX =1; BRS 34; BRU G(2)
G(1)   ASC '$.&D(1).&/'
G(2)   EQU *; ENDM

SKNE   MACRO D; SKE D(1); BRU *+2; ENDM

ERRMSG MACRO; BRM ERRORM; ENDM

PUNT   MACRO; BRM PUNTR; ENDM

TAB    MACRO; LDA =' '; CIO OUTFIL; CIO OUTFIL; ENDM

TEST   MACRO D; SKE ='D(1)'; BRU *+2; BRU D(1).&H; ENDM

COUT   MACRO D; LDA =D(1); CIO OUTFIL; ENDM

NOUT   MACRO D
VV     NARG
       IF VV>0; LDA D(1); ENDF
       LDB =10; LDX OUTFIL; BRS 36; FRGT VV; ENDM

SOUT   MACRO D
XX     NARG
       LDA =D(1)
       IF XX>1
       LDB =D(2)
       ELSE
       LDB =-1
       ENDF
       BRM OUTSTR; FRGT XX; ENDM

HOUT   MACRO D,F,2; LDA =F(1); LDB =-1; LDX OUTFIL; BRS 34; BRU F(2)
F(1)   ASC "D(1).&/"
F(2)   EQU *; ENDM


PUT    MACRO D
       IF D(2$1)=1; LDA D(1); STA /0; EAX /1; ENDF
       IF D(2$1)=2; LDP D(1); STP /0; EAX /2; ENDF
       ENDM

GET    MACRO D
       IF D(2)=1; LDA /0; STA D(1); EAX /1; ENDF
       IF D(2)=2; LDP /0; STP D(1); EAX /2; ENDF
       ENDM

OPEN   MACRO D,H,3; LDA =13B6; LDB =H(2); CLX
       BRS 16; ZRO *; STA D(2); BRU H(3)
WW     NCHR D(1)
H(1)   ASC "D(1)"
H(2)   DATA 3*H(1)-1,3*H(1)-1+WW
H(3)   EQU *; FRGT WW; ENDM

CRLF   MACRO D; COUT 155B; COUT 152B; ENDM

SPACE  MACRO D
UU     NARG
       BRM BLANK
       IF UU>0
           IF ($D(1))>1
               RPT D(1)-1; BRM BLANK; ENDR
           ENDF
       ENDF
       ENDM

START  MSG (INPUT FILE: ); CLEAR; BRS 15; BRU START; STA IFNO
       TCO =155B; TCO =152B
       OPEN (ACCNT-SYSTEM),SYSFIL
       OPEN (ACCNT-USERS),USRFIL
       LDA =1; STA LINENO
       LDA =GNC1-1; STA GNCM
S0     LDA =-1; LDX =-NOTERM*2
       STA /TSTATE+NOTERM*2; EAX /1; BRX *-2
LOOP   BRM GNC; SKG =' '; BRU L1; SKG ='9'; SKG ='0'-1; BRU L2; SUB =20B
L1     STA LINCNT
       BRM GNC; TEST I; TEST K; TEST N; TEST P; TEST E; TEST O; TEST S
       LDA =INVACC; ERRMSG
L2     SKNE =137B; BRU *+3; LDA =NOEOF; ERRMSG;
       CIO SYSFIL; CIO USRFIL; BRS 17
       MSG (PAU!!!!); BRS 10

* I-HANDLER CODE:

IH     BRM GTTIME
       LDA SYSFIL; STA OUTFIL
       COUT 'I'; SPACE 2; SOUT DAY; SPACE; NOUT DATE; SPACE
       SOUT MONTH; SPACE; NOUT YEAR; SPACE 4
       LDA HOUR; SKG =9; BRM BLANK; NOUT; COUT ':'
       LDA MIN; SKG =9; BRM ZERO; NOUT; COUT ':'
       LDA SEC; SKG =9; BRM ZERO; NOUT; CRLF; BRU S0

* K-HANDLER CODE:   BECAUSE PROCESS NUMBER IS 0 ON CNTL-K'S AND THUS
*                   CANNOT BE USED TO INDEX THE STATUS TABLE, K-HANDLR
*                   WAS MODIFIED TO DO NOTHING SINCE NOT REALLY NECESSARY.

KH     BRM GTLNO; BRM GTTIME; BRU LOOP


* N-HANDLER CODE:

NH     LDA =NAME; STA GNPTR; LDX =NSINIT; LDP /0; STP ←GNPTR
       BRM GNC; BRM GNC; BRM GNC; BRM GNP; LDP ASINIT; STP ACCNT
       BRM GTLNO; BRM GTTIME; LDA SYSFIL; STA OUTFIL
       LDA NAME; ADD =1; SKNE NAME+1; BRU NH2
       ADD =2; SKNE NAME+1; BRU NH1
NH0    COUT 'N'; SPACE 2; SOUT DAY; SPACE; NOUT DATE; SPACE
       SOUT MONTH; SPACE; NOUT YEAR; SPACE 4
       LDA HOUR; SKG =9; BRM BLANK; NOUT; COUT ':'
       LDA MIN; SKG =9; BRM ZERO; NOUT; COUT ':'
       LDA SEC; SKG =9; BRM ZERO; NOUT; SPACE 5
       BRM PTLNO; SPACE 5; SOUT NAME; CRLF; BRU LOOP
NH1    LDA NSTR; SKNE ="FIN"; BRU LOOP; SKNE ="LOG"; BRU LOOP; BRU NH0
NH2    LDA NSTR; ETR =377B*2↑16; SKNE ="   "; BRU LOOP; BRU NH0

* P-HANDLER CODE:

PH     BRM GTUNO; BRM GTNAME; BRM GTPASS; BRM GTLNO; BRM GTTIME
       LDA SYSFIL; STA OUTFIL
       COUT 'P'; SPACE 2; SOUT DAY; SPACE; NOUT DATE; SPACE
       SOUT MONTH; SPACE; NOUT YEAR; SPACE 4
       LDA HOUR; SKG =9; BRM BLANK; NOUT; COUT ':'
       LDA MIN; SKG =9; BRM ZERO; NOUT; COUT ':'
       LDA SEC; SKG =9; BRM ZERO; NOUT; SPACE 5
       BRM PTLNO; SPACE 5
       SOUT NAME,16; SPACE 2
       SOUT PASS; CRLF; BRU LOOP

* E-HANDLER CODE:

EH     BRM GTUNO; BRM GTNAME; BRM GTLNO; BRM GTTIME
       LDA PROCNO; CLB; LSH 1; CAX
       LDA UNO; XMA /TSTATE; SKNE =-1; BRU *+6;
       LDA LINENO; SUB =1; STA LINENO; LDA =NOTLOG; ERRMSG
       EAX /←TSTATE+1
       LDA =0; STA PAPER; PUT PAPER,1
       PUT DATE,1; PUT YEAR,1; PUT HOUR,1; PUT MIN,1
       PUT SEC,1; PUT DSTR,2; PUT MSTR,2
       CXA; ETR =37777B; MUL =3; LSH 23; SUB =1
       STA SPTR; STA SPTR+1
       LDA =NAME; BRM SPUT
       LDA =ACCNT; BRM SPUT; BRU LOOP

* S-HANDLER CODE

SH     BRM GTUNO; BRM GTNAME; BRM GTLNO; BRM GTFNAM; BRM GTPAPR; BRM GTTIME
       LDA PROCNO; CLB; LSH 1; CAX
       LDA UNO; XMA /TSTATE; SKNE UNO; BRU *+6;
       LDA LINENO; SUB =1; STA LINENO; LDA =NOLOGN; ERRMSG
       EAX /←TSTATE+1
       LDA /0; ADD PAPER; STA /0
       BRU LOOP

* O-HANDLER CODE:

OH     BRM GTUNO; BRM GTNAME; BRM GTLNO; BRM GTPF; BRM GTCPUT; BRM GTTIME
       LDA PROCNO; CLB; LSH 1; CAX
       LDA USRFIL; STA OUTFIL
       LDA =-1; XMA /TSTATE; SKNE UNO; BRU *+6
       LDA LINENO; SUB =1; STA LINENO; LDA =ATTLGO; ERRMSG
       EAX /←TSTATE+1; GET USEPPR,1; GET ONDATE,1; GET ONYEAR,1
       GET ONHOUR,1; GET ONMIN,1; GET ONSEC,1; GET ODSTR,2
       GET OMSTR,2; LDP ODSINIT; STP ONDAY; LDP OMSINIT; STP ONMONTH
       LDA =72; ADM ONDAY+1; ADM ONMONTH+1
       CXA; ETR =37777B; MUL =3; LSH 23; SUB =1
       STA SPTR; ADD =72; STA SPTR+1
       LDP NSINIT; STP NAME;
       LDA =NAME; BRM SGET
       LDP ASINIT; STP ACCNT
       LDA =ACCNT; BRM SGET
       BRM PTUNO; SPACE 2
       SOUT NAME; SPACE 2
       BRM PTDATE; SPACE 2
       BRM PTLNO; SPACE 2
       BRM PTOTIM; SPACE 2
       BRM PTTIME; SPACE 2
       BRM PTCTIM; SPACE 2
       BRM PTCPUT; SPACE 2
       BRM PTPF; SPACE 2
       BRM PTPAPR; SPACE 2
       BRM PTCHG; SPACE 2
       SOUT ACCNT; CRLF; BRU LOOP

* ROUTINE GNE:  ENTER W/ NAME OF STR PTR IN A & NAME OF INITIALIZED
*     STRING PTR IN X.  SKIPS LEADING BLANKS, READS ELEMENT INTO STRING
*     AND RETURNS TERMINATOR IN A.  TERMINATORS ARE BLANK, [, ], AND
*     CR-LF, WHERE N CR-LFS ARE STRIPPED AND N IS CONTAINED IN LINCNT.
*     LF IS ACTUALLY RETURNED WHEN LINCNT HOLDS ZERO.

GNE    ZRO
       STA GNPTR; LDP /0; STP ←GNPTR
GNE1   BRM GNC; SKNE =' '; BRU GNE1
GNE2   SKNE =152B; BRR GNE
       SKNE ='['; BRR GNE
       SKNE =']'; BRR GNE
       WCI ←GNPTR; BRM GNC
       SKNE =' '; BRR GNE; BRU GNE2


* ROUTINE GNP:  ALTERNATE ENTRY POINT INTO GNE.  AVOIDS STRING POINTER
*     INITIALIZATION AND SO ALLOWS NEW CHARACTERS READ TO BE APPENDED
*     TO THE PREVIOUS STRING.

GNP    ZRO
       LDB GNP; STB GNE; BRU GNE2


* ROUTINE GNC:  GETS THE NEXT CHARACTER WITH DUE REGARD FOR STRIPPING
*     OFF CONTINUATION CR-LFS AND COUNTING LINES.  THE LATTER IS DONE
*     FOR DIAGNOSTIC PURPOSES.

GNC    ZRO
       BRR GNCM
GNCM   ZRO
       BRR GNC
GNC1   CIO IFNO; SKE =135B; BRU GNC3; CIO IFNO; STA BLKCNT
GNC2   SKR BLKCNT; BRU *+2; BRU GNC1
       LDA =' '; BRM GNCM; BRU GNC2
GNC3   SKE =155B; BRU GNC4; CIO IFNO
       MIN LINENO; SKR LINCNT; BRU GNC1; CLB; STB LINCNT
GNC4   BRM GNCM; BRU GNC1


* ROUTINE GTPASS:  READS PASSWORD INTO APPROPRIATE STRING.

GTPASS ZRO
       LDA =PASS; STA GNPTR; LDP PSINIT; STP PASS
       BRM GNC; BRM GNC; BRM GNP; BRR GTPASS


* ROUTINE GTNAME:  READS NAME AND ACCOUNT ENTRIES INTO APPROPRIATE
*     STRINGS.

GTNAME ZRO
       LDA =NAME; LDX =NSINIT; BRM GNE; SKE =' '; BRU GTNM1
       LDP ASINIT; STP ACCNT; LDA =' '; BRR GTNAME
GTNM1  LDA =ACCNT; LDX =ASINIT; BRM GNE; BRU *+2
GTNM2  BRM GNP; SKE =']'; BRU GTNM2; BRR GTNAME


* ROUTINE GTFNAM: SUPPOSED TO READ THE FILE NAME PRINTED ON THE LINE
*     PRINTER INTO A STRING, BUT SINCE IT'S NOT NEEDED, JUST READ INTO
*     TEMP STRING AND FORGET ABOUT IT.

GTFNAM ZRO
       LDA =TEMPST; LDX =TSINIT; BRM GNE
       BRR GTFNAM


* ROUTINE GTLNO:  READS LINE NUMBER INTO APPROPRIATE INTEGER VALUE.

GTLNO  ZRO
       LDA =TEMPST; LDX =TSINIT; BRM GNE;
*      SAVE THE CONTENTS OF TEMPST SO CAN ACCESS THEM LATER.
       LDP TEMPST; STP SVTEMP;
       GCI TEMPST; PUNT; SKNE ='L'; BRU *+3; LDA =NOPRML; ERRMSG
       GCD TEMPST; BRU PRERR; SKE ='-'; BRU *-3
       BRM GTNUM; STA LINE
*      NOW RESTORE THE STRING AND GET THE PROCESS NUMBER
       LDP SVTEMP; STP TEMPST;
       GCI TEMPST; BRU PRERR; SKE ='-'; BRU *-3
       BRM GTNUM; STA PROCNO; BRR GTLNO;

PRERR  LDA =NOPROC; ERRMSG


* ROUTINE GTUNO:  READS USER NUMBER INTO INTEGER VALUE.

GTUNO  ZRO
       LDA =TEMPST; LDX =TSINIT; BRM GNE
       GCI TEMPST; PUNT; SKNE ='U'; BRU *+3; LDA =NOPRMU; ERRMSG
       BRM GTNUM; STA UNO; BRR GTUNO


* ROUTINE GTPAPR: READS THE NUMBER OF PAGES PRINTED INTO A INTEGER VALUE

GTPAPR ZRO
       LDA =TEMPST; LDX =TSINIT; BRM GNE
       GCI TEMPST; PUNT; SKNE ='P'; BRU *+3; LDA =NOPRMP; ERRMSG
       BRM GTNUM; STA PAPER; BRR GTPAPR


* ROUTINE GTNUM:  CONVERTS THE CONTENTS OF TEMPST INTO A DECIMAL NUMBER.

GTNUM  ZRO
       CLA; STA VALUE
GTNUM1 GCI TEMPST; BRU GTNUM2; SKG ='9'; SKG ='0'-1; BRU GTNUM2
       SUB =20B; STA DIGIT
       LDA VALUE; MUL =10; LSH 23; ADD DIGIT
       STA VALUE; BRU GTNUM1
GTNUM2 LDA VALUE; BRR GTNUM


* ROUTINE GTPF:  READS IN THE NUMBER OF PAGE FAULTS.

GTPF   ZRO
       LDA =TEMPST; LDX =TSINIT; BRM GNE
       GCI TEMPST; PUNT; GCI TEMPST; PUNT; SKNE ='F'; BRU *+3; LDA =NOPRMF; ERRMSG
       BRM GTNUM; STA PFAULT; BRR GTPF


* ROUTINE GTCPUT:  READS IN THE ELAPSED CPU TIME.

GTCPUT ZRO
       LDA =TEMPST; LDX =TSINIT; BRM GNE
       GCI TEMPST; PUNT; SKNE ='T'; BRU *+3; LDA =NOPRMT; ERRMSG
       BRM GTNUM; STA CPHR
       BRM GTNUM; STA CPMIN
       BRM GTNUM; STA CPSEC; BRR GTCPUT


* ROUTINE GTTIME:  READS IN THE DATE AND TIME OF DAY.


GTTIME ZRO
       LDA =DAY; LDX =DSINIT; BRM GNE; LDA ='/'; WCI ←GNPTR
       LDA =TEMPST; LDX =TSINIT; BRM GNE
       BRM GTNUM; STA DATE
       LDA =MONTH; LDX =MSINIT; BRM GNE; LDA ='/'; WCI ←GNPTR
       LDA =TEMPST; LDX =TSINIT; BRM GNE
       BRM GTNUM; STA YEAR
       LDA =TEMPST; LDX =TSINIT; BRM GNE
       BRM GTNUM; STA HOUR
       BRM GTNUM; STA MIN
       BRM GTNUM; STA SEC; BRR GTTIME


PTUNO  ZRO
       LDA UNO; SKG =99; BRM BLANK; SKG =9; BRM BLANK
       NOUT; BRR PTUNO


PTLNO  ZRO
       LDA LINE; SKG =9; BRM BLANK; NOUT; BRR PTLNO


PTPAPR ZRO
       LDA USEPPR; SKG =999; BRM BLANK; SKG =99; BRM BLANK;
       SKG =9; BRM BLANK; NOUT; BRR PTPAPR


PTDATE ZRO
       SOUT ONDAY; SPACE; LDA ONDATE; SKG =9; BRM BLANK; NOUT; SPACE
       SOUT ONMONTH; SPACE; NOUT ONYEAR; BRR PTDATE


PTOTIM ZRO
       LDA ONHOUR; SKG =9; BRM BLANK; NOUT; COUT ':'
       LDA ONMIN; SKG =9; BRM ZERO; NOUT; COUT ':'
       LDA ONSEC; SKG =9; BRM ZERO; NOUT; BRR PTOTIM


PTTIME ZRO
       LDA HOUR; SKG =9; BRM BLANK; NOUT; COUT ':'
       LDA MIN; SKG =9; BRM ZERO; NOUT; COUT ':'
       LDA SEC; SKG =9; BRM ZERO; NOUT; BRR PTTIME


PTCTIM ZRO
       LDA ONHOUR; MUL =60; LSH 23
       ADD ONMIN; MUL =60; LSH 23
       ADD ONSEC; STA ONTIME
       LDA HOUR; MUL =60; LSH 23
       ADD MIN; MUL =60; LSH 23
       ADD SEC; SUB ONTIME
       SKG =-1; ADD =24*60*60; STA ONTIME
       RSH 23; DIV =60; STB SEC; CLB
       RSH 23; DIV =60; STB MIN; STA HOUR
       LDA HOUR; SKG =9; BRM BLANK; NOUT; COUT ':'
       LDA MIN; SKG =9; BRM ZERO; NOUT; COUT ':'
       LDA SEC; SKG =9; BRM ZERO; NOUT; BRR PTCTIM


PTCPUT ZRO
       LDA CPHR; SKG =9; BRM BLANK; NOUT; COUT ':'
       LDA CPMIN; SKG =9; BRM ZERO; NOUT; COUT ':'
       LDA CPSEC; SKG =9; BRM ZERO; NOUT; BRR PTCPUT


PTPF   ZRO
       LDA PFAULT; SKG =999999; BRM BLANK; SKG =99999; BRM BLANK; SKG =9999
       BRM BLANK; SKG =999; BRM BLANK; SKG =99; BRM BLANK; SKG =9; BRM BLANK
       NOUT; BRR PTPF


* THE FORMULA FOR CPU CHARGES IS BASED ON THE AVERAGE PAGE FAULT RATE,
*      I.E., TOTAL # OF PAGE FAULTS / CPU SECONDS.

*      FOR PFR < 10 (PP/SEC), THE CPU RATE IS THE NOMINAL CPRATE.
*      FOR 10<= PFR <40, THE RATE RISES LINEARLY OVER THIS RANGE TO
*              TWICE CPRATE.
*      FOR PFR >= 40, THE RATE RISES LINEARLY AT TWICE THE PREVIOUS SLOPE.

PTCHG  ZRO
       LDA CPHR; MUL =60; LSH 23
       ADD CPMIN; MUL =60; LSH 23
       ADD CPSEC; STA CPTIME
       LDA ONTIME; MUL =ONRATE; STP CHARGE
       LDA PFAULT; RSH 23; DIV CPTIME
       SKG =10; BRU PTCHG1
       SKG =40; BRU PTCHG2
       SUB =40; MUL =CPRATE; DIV =20
       ADD =CPRATE; ADD =CPRATE; STA CPURATE
PTCHG0 LDA CPTIME; MUL CPURATE
       XAB; ADD CHARGE+1; XAB; ADC CHARGE; STP CHARGE
       LDA USEPPR; MUL =PAPRATE; XAB; ADD CHARGE+1
       XAB; ADC CHARGE
       RSH 12; DIV =100; STA DOLLAR; STB CENTS
       LDA DOLLAR; SKG =99; BRM BLANK; SKG =9; BRM BLANK; COUT '$'; LDA DOLLAR
       NOUT; COUT '.'; LDA CENTS; SKG =9; BRM ZERO; NOUT; BRR PTCHG
PTCHG1 LDA =CPRATE; STA CPURATE; BRU PTCHG0
PTCHG2 SUB =10; MUL =CPRATE; DIV =30
       ADD =CPRATE; STA CPURATE; BRU PTCHG0


BLANK  ZRO
       CAB; LDA =' '; CIO OUTFIL; CBA; BRR BLANK

ZERO   ZRO
       CAB; LDA ='0'; CIO OUTFIL; CBA; BRR ZERO

SPUT   ZRO; STA SPPTR
SPUT1  GCI ←SPPTR; BRU SPUT2
       WCI SPTR; BRU SPUT1
SPUT2  LDA ='/'; WCI SPTR; BRR SPUT

SGET   ZRO; STA SGPTR
SGET1  GCI SPTR; ZRO *; WCI ←SGPTR; SKE ='/'; BRU SGET1; BRR SGET

OUTSTR ZRO
       STA OUTSPT; CBA; STA OUTSFG; SKG =-1; LDA =1000; STA NOCHRS
       BRU OUTST2
OUTST1 GCI ←OUTSPT; BRU OUTST3; SKE ='/'; BRU *+2; BRU OUTST3
       CIO OUTFIL
OUTST2 SKR NOCHRS; BRU OUTST1
OUTST3 SKN OUTSFG; BRU *+2; BRR OUTSTR
OUTST4 LDA =' '; CIO OUTFIL; SKR NOCHRS; BRU OUTST4; BRR OUTSTR

ERRORM ZRO; LDB =-1; LDX =1; BRS 34
       LDA =ATLINE; BRS 34
       LDA LINENO; LDB =10; LDX =-1;
       BRS 36; MSG (); BRS 10

PUNTR  ZRO; MSG (FATAL ERROR AT LINE ); LDA LINENO; LDB =10; LDX =-1
       BRS 36; MSG (); BRS 10


* ERROR MESSAGES

NOPROC ASC 'PROCESS NUMBER NOT FOUND AFTER LINE NUMBER/'
INVACC ASC 'INVALID ACCOUNTING CHAR/'
NOEOF  ASC 'NO END OF FILE CHAR/'
NOTLOG ASC 'TRIED TO LOGIN, BUT PREVIOUS PROC NOT LOGGED OUT/'
NOLOGN ASC 'USED PRINTER, BUT USER NOT LOGGED IN/'
ATTLGO ASC 'ATTEMPTED TO LOGOUT, BUT NO ENTRY FOUND/'
NOPRML ASC 'LINE NUMBER PARAMETER (L) NOT FOUND/'
NOPRMU ASC 'USER NUMBER PARAMETER (U) NOT FOUND/'
NOPRMP ASC 'PAPER USAGE PARAMETER (P) NOT FOUND/'
NOPRMF ASC 'PAGE FAULT PARAMETER (PF) NOT FOUND/'
NOPRMT ASC 'ELAPSED CPU TIME PARAMETER (T) NOT FOUND/'
ATLINE ASC ' AT LINE /'

* STRING POINTERS

ACCNT  BSS 2
DAY    BSS 2
MONTH  BSS 2
NAME   BSS 2
ONDAY  BSS 2
ONMONTH BSS 2
PASS   BSS 2
TEMPST BSS 2
SVTEMP BSS 2


* STRING STORAGE

ASTR   BSS 96
DSTR   BSS 2
MSTR   BSS 2
NSTR   BSS 96
ODSTR  BSS 2
OMSTR  BSS 2
PSTR   BSS 96
TSTR   BSS 96


* INITIALIZED STRING POINTERS

ASINIT DATA 3*ASTR-1,3*ASTR-1
DSINIT DATA 3*DSTR-1,3*DSTR-1
MSINIT DATA 3*MSTR-1,3*MSTR-1
NSINIT DATA 3*NSTR-1,3*NSTR-1
ODSINIT DATA 3*ODSTR-1,3*ODSTR-1
OMSINIT DATA 3*OMSTR-1,3*OMSTR-1
PSINIT DATA 3*PSTR-1,3*PSTR-1
TSINIT DATA 3*TSTR-1,3*TSTR-1

* TEMPORARY STORAGE

BLKCNT BSS 1
CENTS  BSS 1
CHARGE BSS 1
CPHR   BSS 1
CPMIN  BSS 1
CPSEC  BSS 1
CPURATE BSS 1
CPTIME BSS 1
PAPER  BSS 1
DATE   BSS 1
DIGIT  BSS 1
DOLLAR BSS 1
GNPTR  BSS 1
HOUR   BSS 1
IFNO   BSS 1
LINCNT BSS 1
LINE   BSS 1
LINENO BSS 1
MIN    BSS 1
NOCHRS BSS 1
USEPPR BSS 1
ONDATE BSS 1
ONHOUR BSS 1
ONMIN  BSS 1
ONSEC  BSS 1
ONTIME BSS 1
ONYEAR BSS 1
OPTR   BSS 1
OUTFIL BSS 1
OUTSFG BSS 1
OUTSPT BSS 1
PFAULT BSS 1
SEC    BSS 1
SGPTR  BSS 1
SPPTR  BSS 1
SPTR   BSS 2
SYSFIL BSS 1
USRFIL BSS 1
PROCNO BSS 1
UNO    BSS 1
VALUE  BSS 1
YEAR   BSS 1


* STATUS TABLES AND STRING STORAGE FOR ENTERED USERS

*         FOR EACH PROCESS NUMBER, 2 STORAGE LOCATIONS ARE USED IN THE
* STATUS TABLE, WHICH IS INDEXED BY (PROCNO * 2). THE FIRST LOCATION
* IS THE STATUS OF THE PROCESS.   (-1 IF UNUSED  AND THE
* USER NUMBER IF LOGGED IN).  THE SECOND LOCATION IS A POINTER TO THE DATA
* STORAGE AREA FOR THE PARAMETERS SUCH AS LOGIN TIME, CPU TIME, ETC.
* THERE ARE 40 LOCATIONS AVAILABLE FOR THIS.

TSTATE EQU *

       RPT (I=1,NOTERM)
XX     EQU I-1
YY     EQU XX*41+TSTATE+2*NOTERM
       DATA 0,YY
       ENDR
       FRGT XX,YY

       BSS 40*NOTERM

       END

***********************  QSPL PACKAGES  ***************************


    QSPL CONSISTS OF 6 PACKAGES.

       1) QSPL-COMP
       2) QSPL-CONV
       3) QSPL-CTL
       4) QSPL-DRIV
       5) QSPL-MISC
       6) QSPL-STOR

    AT THE PRESENT TIME, IT IS NOT KNOWN HOW TO ASSEMBLE IT TOGETHER.

********************  QSPL-COMP  *****


*  (LOWER CASE)
       NOLIST EXT

* QSPL COMPILER, ASSEMBLE WITH NARP
QC     IDENT



* ENTRY POINTS FROM EXEC
       BRU ENTRY0
       BRU ENTRY1



* MAIN SEQUENCING LOGIC


$SEQ   M INLCNT,INLTCT; CLA; SBRM PP; BRU SEQ17
       M PPBIP,INPUT; M =CODEBF,ETS; GND; STX CODE
       M =RECSTK,RSTK; M TEMPB,TEMPTR; M =1,LCTR; STA COMFLG
       STA XSFOR; STA PTADRF
SEQ5   LDA* INPUT; SKE IDECLARE; BRU SEQ1
       RBF XDEC,14; LDX DECT6; BRU SEQ2A
SEQ1   SKE IFUNCTION; BRU SEQ36
SEQ37  RBF XFD,14; M XFDT12,RRL; M XFDT13,SRRL
       M XFDT6,RFFLG; LDX XFDT11; CLA; BRU SEQ2
SEQ36  SKE IRECURSIVE; BRU SEQ7; BRU SEQ37
SEQ7   SKE ILIST; BRU SEQ8; NEXT; CBF ISOURCE,SEQ9
       M =-1,LSTATF; BRU SEQ10
SEQ9   CBF IBINARY,SEQ11; M SBINFL,BINFIL; BRU SEQ10
SEQ11  CBF ICODE,25; M SLSTFL,LSTFIL; BRU SEQ10
SEQ8   SKE INOLIST; BRU SEQ12; NEXT; CBF ISOURCE,SEQ13
       M =0,LSTATF; BRU SEQ10
SEQ13  CBF IBINARY,SEQ14; M =2,BINFIL; BRU SEQ10
SEQ14  CBF ICODE,SEQ31; M =2,LSTFIL
SEQ10  NEXT; CBF ISEMI,25; BRU SEQ
SEQ31  CBF IFREE,SEQ35; MIN LSTUIV; BRU SEQ10
SEQ35  CBF IEXTERNAL,25; MIN LSTEXT; BRU SEQ10
SEQ12  SKE IEND; BRU SEQ15; BRU ENDB2
SEQ15  SKE IIDENT; BRU SEQ20; NEXT
       LDA* INPUT; SKG ESYT; SKG BSYT; CERR 14
       XMA IDENT; SKE =-1; CERR 27; APINS CODE,IDENT,=11; NEXT; BRU SEQ2B
SEQ20  SKE IFOR; BRU SEQ32; M =-1,XSFOR; STA PTADRF
       NEXT; RBF XFORC,1
SEQ33  CBF IDO,1; NEXT
       LDX OP2; M FORSTK,/5; STX FORSTK; LDX FOROUT; CLA; BRU SEQ2
SEQ32  SKE IWHILE; BRU SEQ21; M =-1,XSFOR; STA PTADRF
       RBF XWHILC,1; BRU SEQ33
SEQ21  SKE IENDFOR; BRU SEQ22; GND; STX OP2; LDA FORSTK; SKG =0; CERR 41
       CAX; LDB 5,2; STB FORSTK; SBRM CLSFOR
SEQ24  NEXT; LDX OP2; CLA; BRU SEQ2
SEQ22  SKE IIF; BRU SEQ23; M =-1,PTADRF
       GTADR; CAB; GSTS =3
       STB 2,2; XMA IFSTK; STA 0,2
SEQ26  RBF EXPR,1; CBF IDO,1; LDX OP2; SBRM FFXFER; LDX OP2
       LDA ADDR,2; LDX IFSTK; STA 1,2; BRU SEQ24
SEQ23  SKE IELSEIF; BRU SEQ25; M =-1,PTADRF; LDX IFSTK
       CXA; SKG =0; CERR 43; APISA CODE,ZBRU,/2
       LDX IFSTK; APINS CODE,/1,=2; BRU SEQ26
SEQ25  SKE IELSE; BRU SEQ27; LDX IFSTK
       CXA; SKG =0; CERR 43; APISA CODE,ZBRU,/2
       LDX IFSTK; CLA; XMA 1,2; APINS CODE,:,=2; NEXT; CBF IDO,1
SEQ28  NEXT; GND; CLA; BRU SEQ2
SEQ27  SKE IENDIF; BRU SEQ38; LDX IFSTK; CXA; SKG =0; CERR 43
       LDA 1,2; ETR =37777B; SKG =0; BRU SEQ29
       APINS CODE,:,=2
SEQ29  LDX IFSTK; APINS CODE,/2,=2; LDX IFSTK
       M /0,IFSTK; BRU SEQ28
SEQ38  SKE IINCLUDE; BRU SEQEND; NEXT; CBF ISC,53; NEXT
       LDA INPUT; MUL =3; LSH 23; ADD =2; STA CPT1
       ADD* INPUT; STA CPT2; MUL =12525253B; STA INPUT
       NEXT; CBF ISEMI,24; SKN LSTATF; BRU SEQ39; C WCR; SBRM PSTAT
SEQ39  LDP CPT1; SBRM INPUSH; BRU SEQ
SEQEND BSS 0
* NOT ANY RECOGNIZABLE STATEMENT, MUST BE EXPRESSION
SEQ3   LDB =INTVF; SKE IDOL; BRU SEQ30; NEXT; LDB =INTVF+ENTF
SEQ30  STB CPT1; NEXT; CBF ICOLON,SEQ4
* LABEL
       PREV; LDA* INPUT; SKG ESYT; SKG BSYT; CERR 17
       CAX; LDA SFLAG,2; SKA =7777B4; CERR 18
       MRG CPT1; STA SFLAG,2; M INLTCT,LBLLCT; CXA; STA LSTLBL
       APINS CODE,:,=4; NEXT; NEXT; M =0,FTFLG; MIN NLIW
       GND; LDA* CODE; STX CODE; C OLS; BRU SEQ5
* NO LABEL
SEQ4   LDB CPT1; SKB =ENTF; PREV; PREV; PREV
       RBF EXPR,1; FVALNO OP2; LDX OP2
       SKN CPTR,2; BRU *+2; CERR 14
       LDX CPTR,2; LDX 1,2; LDA 2,2; LDX OP2; ETR =577B5
       SKE ZBRU; BRU *+3
SEQ19  LDA =-1; BRU SEQ2; SKE ZBRR; BRU SEQ2; BRU SEQ19
* GOT COMPILED CODE LIST. GENERATE CODE
SEQ2   STA FTFLG; CLA; XMA FTBADR; SKG =0; BRU SEQ2A
       STX PT1; APINS CODE,:,=2; LDX PT1
SEQ2A  APPCOD CODE
SEQ2B  CBF ISEMI,24
SEQ16  SKN LSTATF; BRU SEQ6; C WCR; SBRM PSTAT
$SEQRET EQU *
SEQ6   LDA* CODE; SKE =-1; C OLS
       BRU SEQ
* COMMENT
SEQ17  M =MINONE,CODE; M =-1,COMFLG; BRU SEQ16

MINONE DATA -1



* DECLARATION RECOGNIZER
XDEC   SAVE
       M =1,DECT1; STA DECT2; STA DECT9; STA DECT10; STA DECT14
       STA DECT16
       GND; STX DECT6; CBF IDECLARE,XDEC1
XDEC19 NEXT; M =-1,DECT15
XDEC31 CBF IPAGED,XDEC34; M =-1,DECT10; NEXT
XDEC34 CBF IFIELD,XDEC30; LDA =3; BRU XDEC3
XDEC30 CBT IMACRO,XMD1; CBF IPARAM,XDEC49; M =0,DECT12
* PARAMETER. EXPECT NAME←INTEGER
XDEC58 NEXT; LDA* INPUT; SKG ESYT; SKG BSYT; BRU XDEC57
       LDB =INTCF; STB DECT12
XDEC32 STA DECT5; CAX; LDA SFLAG,2; SKA =7777B4
       BRU XDEC53; LDA SCHAIN,2; ETR =37777B; SKE =37777B; BRU XDEC14
XDEC54 NEXT; CBF ILARR,32; SBRM GINT; LDX DECT5; STA SVAL,2
       LDA SFLAG,2; MRG DECT12; STA SFLAG,2
       LDX OP2; LDX ADDR,2; LDA SNAME,2; SKE =0; BRU XDEC56
XDEC55 CXA; MRG =SYMPTR; LDX DECT5; STA SCHAIN,2
       CBF ICOMMA,XDEC18; BRU XDEC58
XDEC53 SKA =INTCF; SKA =7777B4-INTCF-ENTF; BRU XDEC14
       LDA SNAME,2; SKE =0; BRU XDEC54; BRU XDEC14
XDEC56 LDA SVAL,2; MCON; BRU XDEC55
XDEC57 SKE IDOL; BRU XDEC59; M =INTCF+ENTF,DECT12; NEXT
       LDA* INPUT; SKG ESYT; SKG BSYT; BRU XDEC12; BRU XDEC32
XDEC59 CLA; SKE DECT12; BRU XDEC31; BRU XDEC12
XDEC49 CBF IFIXED,XDEC13; M =-1,DECT14; NEXT
XDEC13 CBF IINTEGER,XDEC2; LDA =1; BRU XDEC3A
XDEC2  CBF ISTRING,XDEC2A; LDA =2
XDEC3A CLB; STB DECT16; BRU XDEC3
XDEC2A CBF IREAL,XDEC4; M =-1,DECT16; LDA =1
XDEC3  STA DECT1; M =0,DECT9; NEXT
XDEC4  CBF IENTRY,XDEC5; LDA =2; BRU XDEC6
XDEC5  CBF IEXTERNAL,XDEC7; LDA =3; BRU XDEC6
XDEC7  CBF ILOCAL,XDEC8; LDA =1
XDEC6  STA DECT2; NEXT
XDEC8  CBF IARRAY,XDEC26; LDA =-2; SKN DECT14; LDA =-1; STA DECT9; NEXT
XDEC26 M DECT2,DECT3; M DECT1,DECT4
       CBF ISTAR,XDEC9; LDA =3; BRU XDEC10
XDEC9  CBF IDOL,XDEC11; LDA =2
XDEC10 STA DECT3; NEXT
* NOW MUST HAVE UNDECLARED NAME
XDEC11 LDA* INPUT; SKG ESYT; SKG BSYT; BRU XDEC12; STA DECT5
       CAX; LDA SFLAG,2; SKA =7777B4; BRU XDEC14
* DO
       NEXT; CBT IEQ,XDEC33
       LDA DECT4; SKE =3; BRU *+2; BRU XDEC52
       SKN DECT9; BRU XDEC51
XDEC52 CBT ILPAR,XDEC24; CBT ILBRAK,XDEC24
XDEC51 LDA DECT9; SKG =-2; CERR 34; CBF ILARR,XDEC15
* HANDLE INITIALIZATION FOR SYMBOL NOT ARRAY
       LDA DECT4; SKE =2; BRU XDEC41
* STRING.  EXPECT STRING CONSTANT
       SBRM CSC; CERR 35; APINS DECT6,DECT5,=4; APCODE DECT6,DECSD
       MIN DECT15; BRU XDEC15
* NOT STRING.  EXCLUDE ARRAY
XDEC41 SKN DECT9; BRU *+2; CERR 36
* ORDINARY INTEGER VARIABLE. EXPECT SINGLE SYMBOL OR INTEGER
       SBRM CII; LDX DECT5; STA SVAL,2; CBA; MRG =SYMIV
       ADM SCHAIN,2; BRU XDEC15
XDEC24 LDA =4; XMA DECT4; SKE =3; BRU *+2; BRU XDEC17
       SKE =2; BRU *+2; MIN DECT4; LDA DECT9; SKE =-2; BRU XDEC28
* FIXED ARRAY
       MIN NFAIW; LDX DECT5
       M =2B7,/SVAL; SBRM GINT; STA DECT12; CBT IRPAR,XDEC44
       CBF IRBRAK,XDEC16
XDEC44 NEXT; GND; STX DECT11; LDA DECT12; ADD =1; APINS DECT11,:,=5
       CBF ILARR,XDC45A; APINS DECT11,DECT5,=4
       LDA DECT4; SKE =5; BRU XDEC47
* STRING.  ACCEPT SC,SC,..,SC
XDEC46 SBRM CSC; CERR 35; SKR DECT12; BRU *+2; CERR 38
       GTADR; STA DECT13; APINS DECT6,:,=2; APCODE DECT6,DECSD
       APINS DECT11,DECT13,=0; CBT ICOMMA,XDEC46
XDEC45 APFT DECT6
XDC45B APCODE DECT6,DECT11
       APINS DECT6,DECT12,=7; BRU XDEC15
* INTEGER.  ACCEPT II,II,...,II
XDEC47 APFT DECT6; SBRM CII; SKR DECT12; BRU *+2; CERR 38
       LDX =5; SKB =-1; CLX; CXB; APPINS DECT11; CBT ICOMMA,XDEC47
       BRU XDEC45
* UNINITIALIZED FIXED ARRAY
XDC45A SKN STEMPF; APFT DECT6
       LDA DECT5; MRG =4B7; APINS DECT11,:,=4
       LDA =4B7; ADM DECT12; BRU XDC45B

* SUBROUTINES FOR COMPILETIME INITIALIZATION OF VARIABLES
* COLLECT INTEGER INITIALIZATION: CONSTANT OR SINGLE SYMBOL.
* RETURN VALUE IN A, 0 OR SYMPIV IN B DEPENDING
CII    ZRO CIIT1
       RBF EXPR,37; LDX OP2; TIA OP2; BRU CII1
* INTEGER
       CLB; SBRR CII
CII1   LDA ADDR,2; SKA =2004B4; CERR 37; LDB =SYMPIV; SBRR CII

* COLLECT STRING CONSTANT FOR INITIALIZATION.  COMPILE TEXT, PUT 
* DESCRIPTOR ON DECSD AND SKIP.  IF ISC IS NOT NEXT THING, NOSKIP
CSC    ZRO CSCT1
       NEXT; CBF ISC,CSC1; NEXT; M ETS,CSCT4; GND; STX CSCT2
       APFT CSCT2; M =-1,PTADRF; GTADR; STX CSCT3; MIN PTADRF
       APINS CSCT2,:,=2; APINS CSCT2,INPUT,=8
       LDA* CSCT2; C OLS; M CSCT4,ETS; GND; STX DECSD
       LDA =7774B4; MRG CSCT3; STA CSCT3
       APINS DECSD,:,=10; APINS DECSD,CSCT3,=10; LDA* INPUT
       CLB; LSH 14; ADM CSCT3; LRSH 14
       ADD =2; MUL =12525253B; ADM INPUT
       APINS DECSD,CSCT3,=10; APINS DECSD,CSCT3,=10; NEXT; MIN CSCT1
CSC1   SBRR CSC

XDEC28 CERR 14
XDEC25 NEXT; CLA; STA FTFLG; XMA FTBADR; SKG =0; BRU XDC25A
       APINS DECT6,:,=2
XDC25A APCODE DECT6,OP2
* DEALT WITH ARRAY DECLARATION IF THERE WAS ONE. SET UP BITS
XDEC15 LDX DECT4; LDA DECTB1-1,2; LDX DECT3; MRG DECTB2-1,2
       LDX DECT5; MRG SFLAG,2; SKN DECT9; BRU *+2; MRG =ARRAYF
       SKN DECT10; BRU *+2; MRG =PAGEDF; LDB SCHAIN,2
       SKA =EXTF; BRU *+2; BRU *+3; SKB =SYMIV; CERR 7; STA SFLAG,2
       SKA =STRDF; SKN DECT14; BRU XDC23A; SKA =ARRAYF; BRU XDC23A
       SKN DECT15; BRU XDC23A
* ALLOCATE SPACE FOR FIXED STRING.  IT IT DESCRIPTOR ONLY, OR STORAGE 
* AS WELL
       CBF ILPAR,XDEC50; APFT DECT6
       GTADR; STA CSCT3; APINS DECT6,:,=2
       SBRM GINT; SKG =1777B; BRU *+2; CERR 44
       STA CSCT1; CBF IRPAR,14; NEXT; LDA CSCT1; ADD =2
       MUL =12525253B; APINS DECT6,:,=7; APINS DECT6,DECT5,=4
       LDA CSCT3; MRG =7774B4; STA CSCT3; APINS DECT6,:,=10
       APINS DECT6,CSCT3,=10; APINS DECT6,CSCT3,=10; CLB; LDA CSCT1
       LSH 14; ADD CSCT3; APINS DECT6,:,=10; BRU XDC23A
XDEC50 SKN STEMPF; APFT DECT6
       LDA DECT5; MRG =4B7; APINS DECT6,:,=4
       APINS DECT6,=4B7+4,=7
* DEALT WITH SYMBOL WHICH REQUIRES A STORAGE CELL.
* DEFINE IT UNDER TEMP. L.C. UNLESS IT IS INITIALIZED
XDC23A SKN STEMPF; BRU XDEC23; LDX DECT5; LDA SCHAIN,2
       SKA =SYMIV; BRU *+2; BRU XDEC23
       LDA DECT5; MRG =4B7; APINS DECT6,:,=2
* GO ON TO NEXT ITEM
XDEC23 CBF ICOMMA,XDEC18; BRU XDEC19
* MISSING RIGHT PAREN
XDEC16 CERR 10
* ATTEMPT TO REDECLARE SYMBOL
XDEC14 CERR 11
* EXPECTED NAME AND DIDN'T FIND IT
XDEC12 CERR 12
* FIELD DEFINITION
XDEC17 M =1,DECT3; SBRM GINT; STA DECT7; CBF ICOLON,XDEC21
       SBRM GINT; SKG =23; SKG =-1; CERR 40
       STA DECT8; CBF ICOMMA,XDEC20
       SBRM GINT; SUB DECT8; ADD =1; SKG =24; SKG =0; CERR 40
* THIS IS LENGTH
       LDX DECT5; STA SVAL,2; LDA DECT8; CLB; LSH 15; XMA DECT7
       ETR =37777B; MRG DECT7; STA SCHAIN,2
XDEC22 CBF IRPAR,XDEC20; LDX DECT5; LDA =STRUCF
       SKN DECT10; BRU *+2; MRG =PAGEDF; SKN DECT16; BRU *+2; MRG =FLTVF
       ADM SFLAG,2; NEXT; BRU XDEC23
* FULL-WORD FIELD
XDEC21 LDX DECT5; M =40000030B,/SVAL; M DECT7,/SCHAIN; BRU XDEC22
* ERRONEOUS SYNTAX IN FIELD DEFINITION
XDEC20 CERR 13
* NOT COMMA
XDEC18 TRET XDEC
XDEC1  FRET XDEC
* EQUIVALENCE
XDEC33 SKN DECT14; BRU *+2; CERR 42
       NEXT; LDA* INPUT; SKG ESYT; SKG BSYT; BRU XDEC12; NEXT; CAX
       LDA SFLAG,2; SKA =STRDF+INTVF; BRU *+2; BRU XDEC12
XDEC39 LDA SCHAIN,2; SKA =SYMPTR; BRU XDEC37; SKA =SYMRIV; BRU XDEC38
XDEC40 CXA; ETR =37777B; LDX DECT5; MRG =2B7; STA SCHAIN,2; BRU XDEC15
* CHAINED
XDEC37 CAX; BRU XDEC39
* MIGHT BE FIXED ARRAY OR FIXED STRING
XDEC38 LDA SFLAG,2; SKA =ARRAYF+STRDF; BRU *+2; BRU XDEC40
* STILL MIGHT BE
       CBF ILBRAK,XDEC40
* IT IS. PICK UP SUBSCRIPT
       STX DECT8; SBRM GINT; LDX DECT8; ADD SVAL,2
       ETR =37777B; LDX DECT5; MRG =SYMVAL; STA SCHAIN,2
       CBF IRBRAK,14; NEXT; BRU XDEC51
DECTB1 DATA INTVF,STRDF,STRUCF,INTVF+ARRAYF,STRDF+ARRAYF
DECTB2 DATA 0,ENTF,EXTF


* GET INTEGER
GINT   ZRO GINT1
       RBF EXPR,37; LDX OP2; TIA OP2; CERR 37; SBRR GINT



* MACRO DEFINITION.   NAME(ARGS)←DEFINITION
XMD1   NEXT; LDA* INPUT; SKG ESYT; SKG BSYT; BRU XDEC12
       CAX; LDA SFLAG,2; SKA =7777B4; CERR 20
       LDA SCHAIN,2; SKE =37777B; CERR 20; STX DECT5
       M =-1,DECT1; NEXT; CBF ILPAR,XMD2A
       MIN DECT1; NEXT; CBT IRPAR,XMD2; M INPUT,DECT3
* COLLECT ARGUMENT NAMES
XMD3   LDA* INPUT; SKG ESYT; SKG BSYT; CERR 30; MIN DECT1
       NEXT; CBF ICOMMA,XMD4; NEXT; BRU XMD3
XMD4   CBF IRPAR,30
XMD2   NEXT
XMD2A  CBF ILARR,30; LDB DECT1; LSH 39; ADD =6B7+1B5
       MRG ESTS; LDX DECT5; STA SCHAIN,2
       LDA =RWF; ADM SFLAG,2
* COLLECT DEFINITION
XMD5   NEXT
XMD11  GSTS =1; M ←INPUT,/0; SKG ESYT; SKG BSYT; BRU XMD6
* SYMBOL, MIGHT BE ARGUMENT
       LDB DECT1; STB DECT4; CXB; LDX DECT3; BRU XMD7A
XMD7   EAX 2,2; SKE -2,2; BRU XMD7A
* IS.  STORE ARGUMENT NUMBER
       COPY XA,BX; SUB DECT3; MUL =6B7; STA 0,2; BRU XMD5
XMD7A  SKR DECT4; BRU XMD7; BRU XMD5
* NOT SYMBOL, TRY FOR SC OR SEMICOLON
XMD6   SKE ISEMI; BRU XMD9; TRET XDEC
XMD9   SKE ISC; BRU XMD5; NEXT
       LDA* INPUT; ADD =2; MUL =12525253B; STA DECT2
XMD10  GSTS =1; M ←INPUT,/0; NEXT
       SKR DECT2; BRU XMD10; BRU XMD11



* FUNCTION DECLARATIONS HAVE THE FORM
*      [RECURSIVE] FUNCTION [$]F(ARGLIST)[,SAVE VARLIST][,LINK ADDR]
* WHERE THE ARGLIST IS A SEQUENCE OF NAMES SEPARATED BYY COMMAS.
* A NAME CAN BE PROCEDED BY ANY OF INTEGER, STRING, PAGED OR ARRAY.  THESE
* WORDS TAKE EFFECT UNTIL SUPEDSEDED. STRING, INTEGER AND PAGED CANCEL EACH
* OTHER, AND ALL CANCELS ARRAY.  AN INITIAL INTEGER IS ASSUMED.
* A 2B7 IS MERGED INTO THE VALUE OF EACH ARRAY ARGUMENT.
* THE DECLARATION OF EACH ARGUMENT MUST MATCH PREVIOUS DECLARATIONS,
* IF ANY.
* THE CODE GENERATED IS
*      STA ARG1
*      STB ARG2 (MAYBE CBA IF MRG =2B7 IS NEEDED)
*      STX ARG3 (MAYBE CXA    "   )
*      LDX 0: STX XF
*      LDA -1,2: STA ARG4
*      ...
*      LDA -N,2: STA ARG(3+N)

XFD    SAVE
       M =0,XFDT6; CBF IRECURSIVE,XFD0
       M =-1,XFDT6; NEXT; M =2B7+2,XFDT9
XFD0   CBF IFUNCTION,XFD1; NEXT
* EXPECT FUNCTION NAME, POSSIBLY PRECEDED BY $
       CBF IDOL,XFD2; NEXT; LDA =ENTF; BRU XFD3
XFD2   CLA
XFD3   STA XFDT1; GND; STX XFDT4; GND; STX XFDT7
       GND; STX XFDT0; GND; STX XFDT11
       LDA* INPUT; SKG ESYT; SKG BSYT
* BAD SYNTAX
XFD4   CERR 19
       STA XFDT2; CAX; LDA SFLAG,2
       SKA =7777B4-ENTF-INTVF-PAGEDF-FLTVF; CERR 20; MRG =INTVF
       MRG XFDT1; STA SFLAG,2; NEXT; SKN XFDT6; BRU XFD24
* INITIALIZE CODELIST FOR RETURN IF RECURSIVE
       M =-1,PTADRF; GTADR; STA XFDT13
       APINS XFDT11,:,=2; APINS XFDT11,ZMINTR,=1
       GTADR; STA XFDT12; APINS XFDT11,:,=2
       APINS XFDT11,ZLDXTR,=1; MIN PTADRF
* OBTAIN NAME OF LINK
XFD24  LDX XFDT2; LDA SNAME,2; LRSH 6; MRG ='X   '; STA FRETL
       LCY 12; ETR =7700B; STA FRETL1; LDA SFLAG,2; LRSH 6
       ETR =77B; ADM FRETL1; CBF ILPAR,XFD6
       NEXT; CBF IRPAR,XFD20; NEXT; BRU XFD6
XFD20  PREV
* COLLECT ARGUMENTS
       M =INTVF,XFDT1; M =0,XFDT8
       SBRM GRWFD; BRU XFD7; SBRM CMXFD
XFD7   LDA ZSTA; MRG XFDT3; APINS XFDT4,:,=0; CBF ICOMMA,XFD10
       SBRM GRWFD; BRU XFD8; APINS XFDT4,ZCBA,=1; SBRM CMXFD; LDA ZSTA
       BRU XFD9
XFD8   LDA ZSTB
XFD9   MRG XFDT3; APINS XFDT4,:,=0; CBF ICOMMA,XFD10
       SBRM GRWFD; BRU XFD11; APINS XFDT4,ZCXA,=1; SBRM CMXFD
       LDA ZSTA; BRU XFD12
XFD11  LDA ZSTX
XFD12  MRG XFDT3; APINS XFDT4,:,=0; CBF ICOMMA,XFD10
* MORE THAN 3 ARGUMENTS
       M =201B5,XFDT5; SKN XFDT6; BRU XFD13
       APINS XFDT4,ZLDXRL,=1
* LOOP TO DEAL WITH EXTRA ARGUMENTS
XFD13  SKR XFDT5; LDA XFDT5; MRG ZLDA; APINS XFDT7,:,=1
       SBRM GRWFD; BRU XFD14; MCI =2B7; MRG ZMRG
       APINS XFDT7,:,=0
XFD14  LDA ZSTA; MRG XFDT3; APINS XFDT7,:,=0; CBT ICOMMA,XFD13
* EXHAUSTED EXTRA ARGUMENTS. EXIT
XFD15  CBF IRPAR,XFD4; NEXT; BRU XFD6
* RAN OUT OF ARGUMENTS BEFORE THE FOURTH
XFD10  CBF IRPAR,XFD4; NEXT
* NO ARGUMENTS, HENCE NO RIGHT PAREN
XFD6   SKN XFDT6; BRU XFD6A; M XFDT9,XFDT10
* COLLECT LIST OF LOCAL VARIABLES IF ANY
       CBF ICOMMA,XFD22; NEXT; CBF ISAVE,14
       M =INTVF,XFDT1; M =0,XFDT8
XFD23  SBRM GRWFD; NOP; CBF ICOMMA,XFD22; BRU XFD23
* COLLECT LINK NAME AND COMPILE SAVING OF LINK
XFD6A  CBF ICOMMA,XFD17; NEXT; CBF ILINK,14; NEXT; LDA* INPUT
       SKG ESYT; SKG BSYT; BRU XFD21; CAX
       NEXT; CBT ISEMI,XFD19; PREV; BRU XFD21
XFD19  LDA SFLAG,2; SKA =7777B4-INTVF-ENTF; CERR 11
       MRG =INTVF; STA SFLAG,2; STX FRETL; BRU XFD18
XFD21  PREV; RBF EXPR,14; LDX OP2; SKN ADDR,2; BRU *+2; CERR 14
       APCODE XFDT4,OP2; APINS XFDT4,ZLDA,=1; LDA ZSTA; LDX OP2
       MRG ADDR,2; APINS XFDT4,:,=0; LDX XFDT7; SKN CPTR,2
       BRU *+2; BRU XFD16; APINS XFDT4,ZXXA,=1; BRU XFD16
XFD17  LDP FRETL; LKS; CERR 22; BRU XFD19
XFD18  APINS XFDT4,ZLDX,=1; LDA ZSTX; MRG FRETL
       APINS XFDT4,:,=0
* ALL DONE
XFD16  MIN MAXTMP; M MAXTMP,TEMPB
       APINS XFDT11,XFDT2,=4; APCODE XFDT11,XFDT0
       APCODE XFDT11,XFDT4; APCODE XFDT11,XFDT7
       MIN NFAIW; TRET XFD
XFD1   FRET XFD
* FINISH SAVE AND RESTORE CODE
XFD22  LDA XFDT9; SUB =2B7+2; MRG ZRCALL; APIF XFDT0,:,=1
       APIF XFDT0,ZLDA,=1; LDA XFDT10; SKG =2B7+2; BRU XFD16A
       APIF XFDT0,ZSTAR1,=1; APINS XFDT0,ZLDAR1,=1
       LDA XFDT10; SKG =2B7+4; BRU XFD16A; APINS XFDT0,ZLDXR3,=1
XFD16A APINS XFDT11,ZRRET,=1; BRU XFD16

* GET RESERVED WORD IN FUNCTION DECLARATION
GRWFD  ZRO GRWFT1
GRWF2  NEXT; LDA* INPUT; SKE IINTEGER; BRU GRWF1; LDA =INTVF
GRWF3  STA XFDT1; STA XFDT8; BRU GRWF2
GRWF1  SKE ISTRING; BRU GRWF4; LDA =STRDF; BRU GRWF3
GRWF4  SKE IARRAY; BRU GRWF5; LDA XFDT1; MRG =ARRAYF; BRU GRWF3
GRWF5  SKE IPAGED; BRU GRWF10; LDA =INTVF+PAGEDF; BRU GRWF3
GRWF10 SKE IREAL; BRU GRWF6; LDA =FLTVF; BRU GRWF3
* MUST HAVE NAME
GRWF6  SKG ESYT; SKG BSYT; BRU XFD4
       SKN XFDT6; BRU *+2; SBRM CSRFD
       LDX* INPUT; LDA SFLAG,2; SKA =7777B4; BRU GRWF7
       MRG XFDT1; STA SFLAG,2; BRU GRWF8
GRWF7  SKA =RWF+STRUCF+INTCF+FLTCF; CERR 21
       LDB =INTVF+ARRAYF+STRDF+PAGEDF+FLTVF; SKM XFDT1; BRU GRWF9
GRWF8  STX XFDT3; NEXT; SKA =ARRAYF; MIN* GRWFD; SBRR GRWFD
GRWF9  LDB XFDT8; SKB =-1; CERR 21; BRU GRWF8


* COMPILE MERGE INDEX FOR FD
CMXFD  ZRO CMXFT1
       MCI =2B7; MRG ZMRG; APINS XFDT4,:,=0
       SBRR CMXFD


* COMPILE SAVE FOR RECURSIVE FD
CSRFD  ZRO CMXFT1
       STA CSRFT1; MRG ZLDA; APINS XFDT0,:,=0
       LDA XFDT9; MRG ZSTA; APINS XFDT0,:,=0
       LDA XFDT9; MRG ZLDB; APINS XFDT11,:,=0
       LDA CSRFT1; MRG ZSTB; APINS XFDT11,:,=0
       MIN XFDT9; SBRR CSRFD




* EXPRESSION
* SEVERAL EXPRESSIONS MAY BE GLUED TOGETHER WITH &. THEY ARE EXECUTED
* IN ORDER.  THE VALUE IS THE VALUE OF THE LAST ONE.
EXPR   SAVE OP1
       SKR LCTR; NOP; RBF XWHR,1
EXPR2  CBF IAMP,EXPR1; M OP2,OP1; RBF XWHR,1; FVAL OP1
       APCODE OP1,OP2; LDX OP2; LDA ADDR,2
       LDX OP1; STA ADDR,2; STX OP2; BRU EXPR2
EXPR1  MIN LCTR; TRET EXPR



* WHERE.  O1 WHERE O2 CAUSES O2 TO BE EVALUATED FIRST.
* THE VALUE IS THROWN AWAY. WHERES MAY NOT BE ITERATED ON THE
* SAME LEVEL
XWHR   SAVE OP1
       RBF XFORX,1; CBF IWHERE,XWHR1; M OP2,OP1; RBF XFORX,1
       FVAL OP2; APCODE OP2,OP1; LDX OP1; LDA ADDR,2; LDX OP2; STA ADDR,2
XWHR1  TRET XWHR


XFORX  SAVE OP1
       RBF XCOND,1
XFORX1 CBF IFOR,XFORX2; NEXT; M OP2,OP1; RBF XFORC,1
XFORX4 APP FOROUT,OP1; LDA FOROUT; XMA OP2; SBRM CLSFOR
       BRU XFORX1
XFORX2 CBF IWHILE,XFORX3; M OP2,OP1; RBF XWHILC,1; BRU XFORX4
XFORX3 TRET XFORX


* SYNTAX OF FOR CLAUSE
* FOR CLAUSE = 'FOR' I ( '=' / '←' ) ( [EXPR ','] EXPR
*      ['WHILE' EXPR] / EXPR ['BY' EXPR] ['TO' EXPR] )
*      / 'WHILE' EXPR
* FORX = XCOND (* FOR CLAUSE *)
* FORSTAT = FOR CLAUSE 'DO'  / 'ENDFOR'

* WHAT TO COMPILE:  FOR WHILE
*      EXPR1                   MOIT IF EXPR1 IS OMITTED
*      BRU L1
*L2    EXPR2
*L1    STA I
*      EXPR3                   OMIT IF EXPR3 MOITTED
*       BRU L3 IF 0
*      ...
*      BRU L2
*L3    BSS 0

* FOR TO THERE ARE MANY CASES:  INCREMENT=1, EXPR3=ADDRESS
*      EXPR1
*      STA I
*      BRU L1
*L2    ...
*      MIN I
*      LDA I
*L1    SKR EXPR3
*      BRU L2

* INCREMENT=-1, EXPR3=0
*      EXPR1                   COMPUTE IF CONSTANT. ALSO
*      ADD =1                  CHECK FOR SUB =1 AT END OF EXPR1
*      STA I
*      BRU L1
*L2    ...
*L1    SKR I
*      BRU L2

* FOR NEGATIVE CONSTANT INCREMENT
*      EXPR1
*      BRU L1
*L2    EXPR2
*      ADD I
*L1    STA I
*  THEN TWO CASES, DEPENDING ON WHETHER EXPR3 IS ADDR (LEFT) OR NOT
*      ADD =1                  EXPR3
*      SKG EXPR3               SKG I
*      BRU L3                  BRU *+2
*                              BRU L3
*      ........
*      BRU L1
*L3    BSS 0

* FOR ALL OTHER CASES
*      EXPR1
*      BRU L1
*L2    EXPR2
*      ADD I
*L1    STA I
* THEN TWO CASES, DEPENDING ON WHETHER EXPR3 IS ADDR (LEFT) OR NOT
*      SKG EXPR3               EXPR3
*      BRU *+2                 ADD1=1
*      BRU L3                  SKG I
*                              BRU L3
*      ......
*      BRU L1
*L3    BSS 0


XFORC  SAVE OP1,FORCOD,FORLL,FORELL,FORVAR,FORT1,FORINC,FORICF
       LDA =-2; ADM LCTR
       GND; STX FORCOD; LDA* INPUT; SKG ESYT; SKG BSYT; CERR 1
       CAX; LDA SFLAG,2; SKA =INTCF+STRUCF; CERR 1; STX FORVAR
       GTADR; STA FORLL
       NEXT; CBT IEQ,FORC25; CBF ILARR,1
FORC25 RBF XCOND,1; CBT IBY,FORC1; CBT ITO,FORC1
       M =-1,FORT1; FLOAD OP2; CBF ICOMMA,FORC3; APP FORCOD,OP2
       GTADR; STA FORT1; MRG ZBRU; APINS FORCOD,:,=0
       RBF XCOND,1; FLOAD OP2
FORC3  APINS FORCOD,FORLL,=2; APP FORCOD,OP2
       SKN FORT1; BRU *+2; BRU FORC4; APINS FORCOD,FORT1,=2
FORC4  APISA FORCOD,FORVAR,ZSTA; CBF IWHILE,14
FORENT RBF XCOND,1; LDX OP2; SBRM FFXFER
       LDX OP2; LDA ADDR,2; ETR =37777B; STA FORELL
       APP FORCOD,OP2; M =0,CPT1
* COMPLETED COMPILING OF CODE.  SET UP RESULT
FORC5  SKN XSFOR; BRU FORC23
       GSTS =6; BRU FORC24
FORC23 GTS =6
FORC24 STA OP2; M FORLL,/0; M FORELL,/1; M CPT1,/2; M FORVAR,/3
       M CPT2,/4; M FORCOD,FOROUT; MIN LCTR; MIN LCTR; TRET XFORC
FORC1  M OP2,FORCOD; GTADR; STA FORELL; CBT IBY,FORC2

       M =1,FORINC; BRU FORC6
FORC2  RBF XCOND,1; LDX OP2; TIA OP2; BRU FORC7; STA FORINC
FORC6  LDA =-1; BRU FORC8
FORC7  M OP2,FORINC; CLA
FORC8  STA FORICF; CBF ITO,FORC9
       RBF XCOND,1; M =0,CPT1; MCI =1; STX CPT4
* DECIDE WHICH CASE WE HAVE TO COMPILE
       SKN FORICF; BRU FORC10
* CONSTANT INCREMENT. IS IT +-1
       LDA FORINC; SKE =1; BRU FORC11
* +1.  IS TERMINATOR ADDRESS
       FLOAD FORCOD; APISA FORCOD,FORVAR,ZSTA; APISA FORCOD,FORELL,ZBRU
       APINS FORCOD,FORLL,=2; LDX OP2; LDA ADDR,2; SKA =6004B4
       BRU FORC12
* YES
       STA CPT2; M =1,CPT1; BRU FORC5
* +1 INCREMENT, TERMINATOR MESSY
FORC12 APISA FORCOD,ZMIN,FORVAR; GTADR; XMA FORELL
       APINS FORCOD,:,=2; FLOAD OP2; APP FORCOD,OP2
       SBRM CSO; APISA FORCOD,ZSKG,FORVAR
       APISA FORCOD,ZBRU,FORELL; BRU FORC5
* NOT +1 INCREMENT
FORC11 SKE =-1; BRU FORC10
* -1 INCREMENT.  IS TERMINATOR 0
       LDX OP2; TZO OP2; BRU FORC10
* YES
       M =-1,CPT1; LDX FORCOD; SKN CPTR,2; BRU FORC17
       TIA FORCOD; BRU FORC17; ADD =1; MCON; MRG ZLDA
       APINS FORCOD,:,=0; BRU FORC16
FORC17 FLOAD FORCOD; SBRM CSO
FORC16 APISA FORCOD,ZSTA,FORVAR; APISA FORCOD,ZBRU,FORELL
       APINS FORCOD,FORLL,=2; BRU FORC5
* INCREMENT IS NOT +-1
FORC10 FLOAD FORCOD; APISA FORCOD,ZBRU,FORELL; APINS FORCOD,FORLL,=2
       SKN FORICF; BRU FORC13; MCI FORINC; MRG ZLDA
       APINS FORCOD,:,=0; BRU FORC14
FORC13 FLOAD FORINC; APP FORCOD,FORINC
FORC14 APISA FORCOD,ZADD,FORVAR
       GTADR; XMA FORELL; APINS FORCOD,:,=2
       APISA FORCOD,ZSTA,FORVAR
* NOW SPLIT INTO FOUR CASES: INCREMENT + OR -, TERMINATOR ADDRESS OR NOT
       LDX OP2; LDA ADDR,2; STA CPT3; SKN FORICF; BRU FORC18
       SKN FORINC; BRU FORC18
* INCREMENT -
       SKA =6004B4; BRU FORC19
* TERM IS CLEAN
       APISA FORCOD,ZADD,CPT4; APISA FORCOD,ZSKG,CPT3
FORC20 APISA FORCOD,ZBRU,FORELL; BRU FORC5
* TERM IS DIRTY
FORC19 FLOAD OP2; APP FORCOD,OP2; APISA FORCOD,ZSKG,FORVAR
FORC22 LDA ZBRU; MRG =2; APINS FORCOD,:,=6; BRU FORC20
* INCREMENT IS +
FORC18 SKA =6004B4; BRU FORC21; APISA FORCOD,ZSKG,CPT3
       BRU FORC22
FORC21 FLOAD OP2; APP FORCOD,OP2; APISA FORCOD,ZADD,CPT4
       APISA FORCOD,ZSKG,FORVAR; BRU FORC20
* NO TO CLAUSE
FORC9  CERR 14


* CHECK FOR SUB =1 AT END OF FORCOD, REMOVE IF PRESENT,
* OTHERWISE APPEND ADD =1.  ASSUME PTR TO =1 IN CPT4.
* CLOBBERS CPT3
CSO    ZRO CPT3; LDX FORCOD; LDX CPTR,2; LDX 1,2
       LDA ZSUB; MRG CPT4; SKE 2,2; BRU CSO1
       M =0,/2; M =7,/3; SBRR CSO
CSO1   APISA FORCOD,ZADD,CPT4; SBRR CSO



* 'WHILE' VARIANT OF FOR CLAUSE
XWHILC SAVE OP1,FORCOD,FORLL,FORELL,FORVAR,FORT1,FORINC,FORICF
       LDA =-2; ADM LCTR; GTADR; STA FORLL
       GND; STX FORCOD; APINS FORCOD,FORLL,=2; BRU FORENT



* CLOSE FOR LOOP.  ADDRESS OF FOR CONTROL BLOCK IN A.  COMPILE
* CODE TO OP2
CLSFOR ZRO CPT1
       CAX; STX CPT2; LDA 2,2; SKE =0; BRU CLSF1
* NORMAL CLOSE
       APISA OP2,/0,ZBRU; LDX CPT2; APINS OP2,/1,=2
CLSF2  LDX OP2; M =-1,/ADDR; M =CLOBA+CLOBX,/CFLAG; SBRR CLSFOR
CLSF1  SKE =1; BRU CLSF3
       APISA OP2,/3,ZMIN; LDX CPT2; APISA OP2,/3,ZLDA
       LDX CPT2; APINS OP2,/1,=2; LDX CPT2; APISA OP2,ZSKG,/4
CLSF4  LDX CPT2; APISA OP2,ZBRU,/0; BRU CLSF2
CLSF3  APINS OP2,/1,=2; LDX CPT2; APISA OP2,ZSKR,/3; BRU CLSF4







* RECOGNIZER FOR CONDITIONALS
XCOND  SAVE OP1,TTADR
       RBF XOR,1; M OP2,OP1; M =-1,TTADR; CBF IIF,XCOND1
       RBF XOR,1
* SEE IF EXPRESSION IS AN UNADORNED BRANCH
       LDX OP1; SKN ADDR,2; BRU XCND11; LDX CPTR,2; SKN 0,2; BRU XCND11
* ONLY ONE INSTRUCTION
       LDA 2,2; ETR =777B5; SKE ZBRU; BRU XCND11
* WHICH IS A BRANCH.  GET ADDRESS
       LDA 2,2; ETR =@577B5; STA CPT1
* FORCE TRUE TRANSFER FROM PREDICATE AND PLUG IN ADDRESS OBTAINED
       LDX OP2; SBRM FTXFER; LDX OP2; STX OP1; LDX ADDR,2; LDA CPT1
       MRG =2B7; STA SCHAIN,2; LDX OP1; M =-1,/ADDR; M =CLOBX+CLOBA,/CFLAG
       CBT IELSE,XCOND9; SKN LCTR; BRU XCOND5
       APINS OP1,ZCLA,=1; BRU XCOND5
* MAKE FALSE TRANSFER OUT OF SECOND OPERAND
XCND11 LDX OP2; TIA OP2; BRU XCOND2
* CONDITION EVALUATES TO A CONSTANT.  CHECK FOR ELSE, THEN ALL DONE
       STA TTADR; CBF IELSE,XCOND3; RBF XCOND,1; LDX OP2
XCOND4 LDA TTADR; SKE =0; LDX OP1; STX OP2; TRET XCOND
XCOND3 CLA; MCC OP2; BRU XCOND4
XCOND2 SBRM FFXFER; LDX OP2; LDA ADDR,2; ETR =37777B; STA FTADR
* GOT PREDICATE PROPERLY COMPILED.
       SKN LCTR; BRU *+2; FLOAD OP1; CBF IELSE,XCND12
* SUPPRESS JUMP OVER ELSE IF WE HAVE A BRANCH
       LDX OP1; LDX CPTR,2; LDX 1,2; LDA 2,2; ETR =577B5
       SKE ZBRU; BRU *+2; BRU XCOND8; SKE ZBRR; BRU *+2; BRU XCOND8
       SKN TTADR; BRU XCOND6; GTADR; STA TTADR
XCOND6 LDA TTADR; MRG ZBRU; APINS OP1,:,=0
XCOND8 APCODE OP2,OP1; M OP2,OP1; APINS OP1,FTADR,=2
XCOND9 RBF XCOND,1; SKN LCTR; BRU *+2; FLOAD OP2
       APCODE OP1,OP2; BRU XCOND5
* NO ELSE. ASSUME 0
XCND12 SKN LCTR; BRU XCND13; SKN TTADR; BRU XCND14; GTADR; STA TTADR
XCND14 LDA TTADR; MRG ZBRU; APINS OP1,:,=0; APINS OP1,ZCLA,=1
XCND13 APCODE OP2,OP1; M OP2,OP1; APINS OP1,FTADR,=2
* GOT ENTIRE EXPRESSION
XCOND5 SKN TTADR; BRU *+2; BRU XCOND7; APINS OP1,TTADR,=2
XCOND7 LDX OP1; LDA =-1; STA ADDR,2; LDA CFLAG,2
       ETR =77777777B-TXFER-FXFER-STRNG-CONST; MRG =CLOBA; STA CFLAG,2
XCOND1 M OP1,OP2; TRET XCOND



* RECOGNIZER FOR OR
XOR    SAVE OP1
       RBF XAND,1; M OP2,OP1
XOR2   CBF IOR,XOR1; RBF XAND,1
* COMPILE CODE FOR OR. HERE WE WANT TXFER
ORCOD  LDX OP1; TIA OP2; BRU ORC3; MRG RESULT; MCC OP1; BRU XOR2
ORC3   LDA CFLAG,2; SKA =FXFER+TXFER; BRU ORC1
       LDX OP2; LDA CFLAG,2; SKA =FXFER+TXFER; BRU ORC1
* TWO VALUES.  PROCEED AS FOR ADD
ORC2   LDX OP2; SPP OP1; NOP; STX OP1
       LDA =-1; XMA ADDR,2; MRG ZMRG; APINS OP1,:,=0; BRU XOR2
* ONE XFER OPERAND
ORC1   LDX OP1; SBRM FTXFER; LDX OP2; SBRM FTXFER
       APCODE OP1,OP2
       LDX OP1; LDA ADDR,2; EOR =6B7; LDX OP2; LDX ADDR,2; STA SCHAIN,2
       BRU XOR2
XOR1   M OP1,OP2; TRET XOR


* RECOGNIZER FOR AND AND EOR
XAND   SAVE OP1
       RBF XNOT,2; M OP2,OP1
XAND2  CBF IAND,XAND1; RBF XNOT,1
* COMPILE CODE FOR AND.  THERE ARE THREE CASES FOR THE LOGICAL
* OPERATORS AND AND OR
* A) BOTH OPERANDS XFER.  THE RESULT IS THE SAME AND NO VALUE
*    IS GENERATED
* B) BOTH OPERANDS VALUE.  THE RESULT IS VALUE, DONE WITH THE
*    APPROPRIATE MACHINE INSTRUCTION
* C) ONE OF EACH. THE VALUE OPERAND IS CONVERTED TO XFER
* HERE WE WANT FXFER
ANDCOD LDX OP1; LDA CFLAG,2; SKA =FXFER+TXFER; BRU ANDC1
       LDX OP2; LDA CFLAG,2; SKA =FXFER+TXFER; BRU ANDC1
* TWO VALUES. PROCEED AS FOR ADD
ANDC2  LDX OP2; TIA OP1; BRU ANDC3; ETR RESULT
ANDC4  MCC OP1; BRU XAND2
ANDC3  SPP OP1; NOP; STX OP1
       APIXA OP1,ZETR; BRU XAND2
* ONE XFER OPERANDS.  FORCE BOTH TO FALSE XFER
ANDC1  LDX OP1; SBRM FFXFER; LDX OP2; SBRM FFXFER
* NOW MERGE THE TWO AND WE HAVE A FXFER RESULT
       APCODE OP1,OP2
* ALSO EQUIVALENCE THE OP2 XFER ADDRESS WITH THE ONE FOR OP1
       LDX OP1; LDA ADDR,2; EOR =6B7; LDX OP2; LDX ADDR,2; STA SCHAIN,2
       BRU XAND2
XAND1  CBF IEOR,XAND3; RBF XNOT,1
* COMPILE CODE FOR EOR
       LDX OP2; TIA OP1; BRU EORC1; EOR RESULT; BRU ANDC4
EORC1  SPP OP1; NOP; STX OP1; APIXA OP1,ZEOR; BRU XAND2
XAND3  M OP1,OP2; TRET XAND



* RECOGNIZER FOR NOT
XNOT   SAVE
       NEXT; CBF INOT,XNOT1; RBF XREL,1
* COMPILE CODE FOR NOT
       LDX OP2; TIA OP2; BRU XNOT3; EOR =-1; MCC OP2; TRET XNOT
XNOT3  LDA CFLAG,2; SKA =FXFER+TXFER; BRU XNOT2
       FLOAD OP2; M =-1,/ADDR; M =CLOBA,/CFLAG
       MCI =-1; MRG ZEOR; APINS OP2,:,=0; TRET XNOT
XNOT2  EOR =FXFER+TXFER; STA CFLAG,2; TRET XNOT
XNOT1  PREV; RBF XREL,1; TRET XNOT






* RECOGNIZER FOR RELATIONS
XREL   SAVE OP1,RELOP
       RBF XMOD,1; M OP2,OP1
       CBF IEQ,XREL1; LDA =1; BRU XREL2
XREL1  CBF INE,XREL3; LDA =2; BRU XREL2
XREL3  CBF IGT,XREL4; LDA =3; BRU XREL2
XREL4  CBF IGE,XREL5; LDA =4; BRU XREL9
XREL5  CBF ILT,XREL6; LDA =5; BRU XREL9
XREL6  CBF ILE,XREL7; LDA =6; BRU XREL2
XREL9  STA RELOP; RBF XMOD,1; LDA OP1; XMA OP2; STA OP1; BRU XREL11
XREL2  STA RELOP; RBF XMOD,1
XREL11 LDX OP2; TIA OP1; BRU RELC1
       SKE RESULT; BRU RELC2; LDB =2; BRU RELC3
RELC2  LDB =3; SKG RESULT; LDB =1
RELC3  CBA; XMA RELOP; SUB =1; MUL =3; LSH 23; ADD RELOP; CAX
       LDA RELVAL; RSH 0,2; ETR =1; MCC OP2; TRET XREL
RELVAL DATA 707124B
* TRY FOR OPTIMIZATION
RELC1  LDA RELOP; SKG =2; BRU RELC5
* LESS OR GREATER OPERATION A<0 OR 0>A COULD BE DONE WITH SKN AND
* FALSE TRANSFER, A>=O AND 0<=A WITH SKN AND TRUE TRANSFER.  WITH
* LUCK WE MIGHT FIND AN SKR
       SUB =2; RSH 1; STA CPT1; LDX OP2
       TZO OP1; BRU RELC4
* ONE OPERAND IS 0.  IS IT THE RIGHT ONE
       COPY AX,BA; SKA =1; BRU RELC4
* YES.  CHECK FOR NON-ZERO OPERAND TO BE AN ADDRESS
       SKN ADDR,2; BRU *+2; BRU RELC4
* IT IS.  DOES ITS CODE END WITH SKR, NOP
       STX OP1; SKN CPTR,2; BRU *+2; BRU RELC6
       LDX CPTR,2; LDX 1,2; LDA 2,2; SKE ZNOP; BRU RELC6
* NOP IS THERE.  THIS IS ENOUGH, SINCE NO OTHER CODE PRODUCING AN
* ADDRESS CAN END WITH NOP.  WE REMOVE THE NOP, REPLACING IT WITH 
* WITH BSS 0
       M =0,/2; M =7,/3
* NOW DECIDE TRANSFER.  TRUE FOR >= OR <= (EVEN), FALSE FOR > OR < (ODD)
* THIS IS THE SAME RULE AS IN THE UNOPTIMIZED CASE
       BRU RELC7A
* NO NOP.  CONTENT OURSELVES WITH SKN
RELC6  LDX OP1; LDA ADDR,2; MRG ZSKN; APINS OP1,:,=0; BRU RELC7A
* EQUALITY COMPARISON
RELC5  LDX OP2; TZO OP1; BRU RELC4
* ONE OPERAND IS 0. TRY FOR SKA
       CAX; FEB RELC4
*YES
       STB CPT3; MCON; MRG ZSKA
       LDX CPT3; STA 2,2; M =0,/3; BRU RELC9
*NO
RELC4  LDX OP2; SPP OP1
* COMPILING RELATIONS.  EACH RELATION HAS A NATURAL TRANSFER DIRECTION
* DETERMINED BY THE AVAILABLE SET OF SKIP INSTRUCTIONS.  THE
* INEQUALITIES ALSO HAVE A PREFERRED OPERAND TO PUT IN A.  THUS
* A=B  F DON'T CARE            SKE 1
* A#B  T DON'T CARE            SKE 2
* A>B  F A                     SKG 3
* A>=B T B                     SKG 4
* A<B  F B                     SKG 5
* A<=B T A                     SKG 6
* THE ORDER PREFERENCES ARE TAKEN CARE OF ABOVE
       BRU XREL8
* PREFERENCE NOT SATISFIED
       STX OP1; LDA RELOP; SKG =2; BRU XREL10
* CARE
       SBRM SWOP; BRU XREL10
XREL8  STX OP1
* ORDER IS NOW CORRECT
XREL10 LDA RELOP; LDB ZSKG; SKG =2; LDB ZSKE; CBA
       APIA OP1
* SET UP TRUE OR FALSE TRANSFER
RELC9  LDA =CLOBA; BRU RELC7
RELC7A CLA
RELC7  LDB RELOP; MRG =TXFER; SKB =1; EOR =FXFER+TXFER
       LDX OP1; MRG CFLAG,2; ETR =NCS
       STA CFLAG,2
       GTADR; MRG =4B7; LDX OP1; STA ADDR,2
       ETR =37777B; MRG ZBRU; APINS OP1,:,=0
XREL7  M OP1,OP2; TRET XREL



* RECOGNIZER FOR MOD
XMOD   SAVE OP1
       RBF XADD,1; M OP2,OP1
XMOD2  CBF IMOD,XMOD1; RBF XADD,1
       LDA =-1; BRU DIVC2
XMOD1  M OP1,OP2; TRET XMOD




* RECOGNIZER FOR + AND -
XADD   SAVE OP1
       RBF XMUL,1; M OP2,OP1
XADD2  CBF IPLUS,XADD1; RBF XMUL,1
* COMPILE CODE FOR PLUS.  ASSUME OPERAND ADDRESSES IN OP1,OP2
ADDCOD LDX OP2; TIA OP1; BRU ADDC3; ADD RESULT
ADDC4  MCC OP1; BRU XADD2
ADDC3  SPP OP1; NOP; STX OP1
ADDC2  APIXA OP1,ZADD; BRU XADD2
XADD1  CBF IMINUS,XADD3; RBF XMUL,1
* COMPILE CODE FOR MINUS
SUBCOD LDX OP2; TIA OP1; BRU SUBC2; SUB RESULT; BRU ADDC4
SUBC2  SPP OP1; BRU SUBC1
* SECOND OPERAND LEFT IN A. COMPILE CNA AND ADD
       STX OP1; APINS OP1,ZCNA,=1; LDX OP1; BRU ADDC2
* NORMAL. COMPILE SUB
SUBC1  STX OP1; APIXA OP1,ZSUB; BRU XADD2
XADD3  M OP1,OP2; TRET XADD



* RECOGNIZER FOR * AND /
XMUL   SAVE OP1
       RBF XSIGN,1; M OP2,OP1
XMUL2  CBF ISTAR,XMUL1; RBF XSIGN,1
* COMPILE CODE FOR TIMES
MULCOD LDX OP2; TIA OP1; BRU MULC1; MUL RESULT; LSH 23
MULC2  MCC OP1; BRU XMUL2
MULC1  SPP OP1; NOP; STX OP1
       APIXA OP1,ZMUL
* NOW COMPILE LSH 23
       APINS OP1,ZLSH23,=1; BRU XMUL2
XMUL1  CBF ISLASH,XMUL4; RBF XSIGN,1
* COMPILE CODE FOR DIVIDE
DIVCOD CLA
DIVC2  STA CPT2; LDX OP2; TIA OP1; BRU DIVC3; RSH 23; DIV RESULT
       SKN CPT2; XAB; XAB; BRU MULC2
DIVC3  SPP OP1; BRU DIVC1
* SECOND OPERAND LEFT IN A. COMPILE STA TEMP, LDA FIRST OPERAND
       STX OP1; SBRM SWOP; BRU *+2
* NOW READY FOR DIVIDE
DIVC1  STX OP1
* CHECK FOR LSH 23 JUST PRECEDING
       SKN CPTR,2; BRU *+2; BRU DIVC4; LDX CPTR,2; LDX 1,2
       LDA 2,2; SKE ZLSH23; BRU DIVC4
       LDA 3,2; SKE =1; BRU DIVC4
* GOT ONE.  REPLACE WITH NULL (BSS 0)
       M =0,/2; M =7,/3; BRU DIVC5
DIVC4  APINS OP1,ZRSH23,=1
DIVC5  LDX OP1; APIXA OP1,ZDIV
       SKN CPT2; BRU XMUL2
* MOD. COMPILE CBA
       APINS OP1,ZCBA,=1; BRU XMOD2
* LOOK FOR SHIFTS
XMUL4  CBF ILSH,XMUL5; RBF XSIGN,1; LDA ZLSH
XMUL10 CLB
XMUL6  STA CPT3; STB CPT2; LDX OP2; TIA OP1; BRU SHFTC5
       COPY AX,BA; SKG =48; BRU *+2; LDA =48; ADM CPT3
       COPY XA,XB; SKN CPT2; CLB; EXU CPT3; BRU MULC2
SHFTC5 SPP OP1; BRU SHFTC1; STX OP1; SBRM SWOP
SHFTC1 STX OP1; LDA CPT3; SKE ZLSH; BRU SHFTC6
       APINS OP1,ZCLB,=1; BRU SHFTC2
SHFTC6 SKE ZLRSH; BRU *+2; BRU SHFTC2; APINS OP1,ZCAB,=1
SHFTC2 LDA ADDR,2; SKA =2004B4; BRU SHFTC3; CAX; LDA SFLAG,2
       SKA  =INTCF; BRU *+2; BRU SHFTC3; LDA SVAL,2; BRU SHFTC4
SHFTC3 APIA OP1,ZLDX; LDA CFLAG,2; MRG =CLOBX; STA CFLAG,2; LDA =2B7
SHFTC4 MRG CPT3; APINS OP1,:,=1; M =-1,/ADDR; BRU XMUL2
XMUL5  CBF IRSH,XMUL7; RBF XSIGN,1; LDA ZLRSH; BRU XMUL10
XMUL7  CBF ILCY,XMUL8; RBF XSIGN,1; LDA ZLCY
XMUL11 LDB =-1; BRU XMUL6
XMUL8  CBF IRCY,XMUL3; RBF XSIGN,1; LDA ZRCY; BRU XMUL11
XMUL3  M OP1,OP2; TRET XMUL




* RECOGNIZER FOR UNARY + AND - AND GOTO (AND DO)
XSIGN  SAVE OP1,RETYPE
       NEXT; CBF IPLUS,XSIGN1
XSIGN9 RBF XTAIL,1; TRET XSIGN
XSIGN1 CBF IMINUS,XSIGN2; RBF XTAIL,1
       LDX OP2; SKN ADDR,2; BRU XSIGN3
* COMPUTES
       APINS OP2,ZCNA,=1; TRET XSIGN
* ADDRESS
XSIGN3 LDA CFLAG,2; SKA =CONST; BRU XSIGN4
* NOT CONSTANT. LOAD AND COMPLEMENT
       LDA =-1; XMA ADDR,2; MRG ZLDA; APINS OP2,:,=0
       APINS OP2,ZCNA,=1; LDX OP2
       LDA CFLAG,2; MRG =CLOBA; STA CFLAG,2; TRET XSIGN
* UNARY MINUS ON CONSTANT
XSIGN4 LDX ADDR,2; LDA SVAL,2; CNA; MCON
       LDX OP2; STA ADDR,2; TRET XSIGN
XSIGN2 CBF IGOTO,XSIGN6; RBF XTAIL,1
       FVAL OP2; SKN ADDR,2; BRU XSIGN5; APINS OP2,ZXXA,=1
XSIGN8 APINS OP2,ZBRUI,=1; TRET XSIGN
XSIGN5 LDA ZBRU; MRG ADDR,2; SKA =4B4; BRU XSIGN7
       MRG =4B4; APINS OP2,:,=0; M =-1,/ADDR; TRET XSIGN
XSIGN7 APIXA OP2,ZLDX; BRU XSIGN8
XSIGN6 CBT IDO,XSIGN9; CBF IRETURN,XSGN16; CLA
* RETURN OPERATION
XSGN17 STA RETYPE; NEXT
       M =XOR,FAREC; M =4B7,ARGCW; RBF CFARGS,1
       CBF IFROM,XSGN11
       M ARGSET,OP1; RBF XTAIL,1; LDX OP2; SPP OP1
       BRU XSGN12; STX OP1; SBRM SWOP
XSGN12 STX OP1; LDA ADDR,2; STX OP2; BRU XSGN13
XSGN11 M ARGSET,OP2; SKN RFFLG; BRU XSGN20; LDA SRRL
       SKN RETYPE; LDA RRL; MRG ZBRU; BRU XSGN19
XSGN20 LDA FRETL; SKE =-1; BRU XSGN13; CERR 26
XSGN13 SKN RETYPE; BRU XSGN18; STA CPT1; MRG ZMIN; APINS OP2,:,=0
       LDA CPT1
XSGN18 MRG ZBRR
XSGN19 APINS OP2,:,=0; LDA =CLOBA
       MRG CFLAG,2; ETR =NCS; STA CFLAG,2; TRET XSIGN
XSGN16 CBF ISRETURN,XSGN10; LDA =-1; BRU XSGN17
XSGN10 PREV; BRU XSIGN9


* RECOGNIZER FOR FUNCTION CALLS.  EXPECT INPUT POINTING TO A (.
XFC    SAVE
       M OP2,FN; NEXT; M =0,ARGCW; CALL CFAN; BRU XFC2B
* FUNCTION WITH ARGUMENTS
       FADDR FN; LDA ADDR,2; MRG ZCALL; MRG =4B4; APINS ARGLST,:,=0
       APCODE FN,ARGSET; APCODE FN,ARGLST; M FN,OP2
XFC2C  M =0,ARGCW; RBF GFCTL,1
       LDA =CLOBA+CLOBX; LDX FN; MRG /CFLAG; ETR =@CONST
       LDX OP2; STA /CFLAG; M =-1,/ADDR
XFC1   TRET XFC
* NO ARGUMENTS
XFC2B  FVAL FN; STX OP2; SKN ADDR,2; BRU XFC3
       APINS OP2,ZXXA,=1
XFC4   LDA ZCALL; MRG =2B7; APINS OP2,:,=1; BRU XFC2C
XFC3   LDA ZCALL; MRG ADDR,2; SKA =4B4; BRU XFC5; MRG =4B4; APINS OP2,:,=0
       BRU XFC2C
XFC5   APIA FN,ZLDX; BRU XFC4


* COLLECT FUNCTION ARGUMENTS (NOW POINTING AFTER '('). IF THERE ARE NONE,
* RETURN WITHOUT SKIP AFTER ONE NEXT.  OTHERWISE RETURN WITH SKIP,
* ARGUMENT SETUP CODE IN ARGSET AND ARGUMENT LIST (IF ANY) IS ARGLST,
* INPUT POINTING JUST AFTER ARGUMENTS
CFAN   M 0,FA0; CBF IRPAR,CFAN1
* ARGUMENTLESS
CFAN2  BRR FA0
CFAN1  CBT ICOLON,CFAN2; M =EXPR,FAREC; RBF CFARGS,1
       MIN FA0; BRR FA0


* COLLECT FUNCTION ARGS USING RECOGNIZER IN FAREC (EXPR OR XOR).  CHECKS
* ARGS AGAINST ARGCW.  NO MORE THAN 3 ARGS ALLOWED IF ARGCW#0
CFARGS SAVE FA0,FA1,FA2,FA3,FA4,FA5,FA6,FA7,FA8,FN,OP1,CARGCW
       M FAREC,FA6; LDA ARGCW; CAB; LCY 12; STA CARGCW
       M =-1,FA1; STA FA2; STA FA3
       GND; STX FA4; GND; STX FA5; PREV
       EAX FA1; CALL GETARG; EAX FA2; CALL GETARG; EAX FA3; CALL GETARG
       CBT ICOMMA,XFC11; NEXT; BRU XFC6
* MORE THAN THREE ARGUMENTS. COMPILE CODE AND ADDRESSES FOR THE REST
XFC11  LDA CARGCW; SKE =0; CERR 50
XFC9   RBF ←FA6,1; FADDR OP2
       MRG ZNOP; APIF FA5,:,=0; APCODE FA4,OP2
XFC8   CBT ICOMMA,XFC9
* FINISHED WITH FUNCTION ARGUMENTS.  FIGURE OUT HOW TO COMPILE
* THE FIRST THREE
XFC6   M =-1,CPT1; SKN FA1; BRU *+2; BRU XFC13; LDX FA1; LDA CFLAG,2
       SKA =CLOBX+CLOBA+NEEDX; BRU *+2; BRU XFC13
* FIRST ARG IS COMPUTATION
       LDA =1; STA CPT1
XFC13  SKN FA2; BRU *+2; BRU XFC15; LDX FA2; LDA CFLAG,2
       SKA =CLOBX+CLOBA+NEEDX; BRU *+2; BRU XFC15
       LDA =2; XMA CPT1; EAX FA2; SKE =-1; BRU XFC14
XFC15  SKN FA3; BRU *+2; BRU XFC16; LDX FA3; LDA CFLAG,2
       SKA =CLOBX+CLOBA+NEEDX; BRU *+2; BRU XFC16
       LDA =3; XMA CPT1; EAX FA3; SKE =-1; BRU XFC14
* NO MORE THAN ONE ARG REQUIRES COMPUTATION (I.E. CLOBBERS A OR X)
XFC16  SKN CPT1; BRU *+2; BRU XFC30; LDX CPT1; LDA* FARGT-1,2; STA CPT2
* DOES IT RETURN AN ADDRESS OR NOT
       CAX; SKN ADDR,2; BRU *+2; BRU XFC18
* YES
       LDA ADDR,2; LDX CPT1; MRG FLOADT-1,2; APINS CPT2,:,=0
       BRU XFC17
XFC18  LDX CPT1; LDA FCOPYT-1,2; SKG =0; BRU XFC17; APINS CPT2,:,=1
XFC17  APCODE FA4,CPT2
* DEALT WITH THAT ONE.  NOW DO THE OTHERS
XFC30  LDA =1; SKE CPT1; BRU *+2; BRU XFC19
       SKN FA1; BRU *+2; BRU XFC19; APCODE FA4,FA1; LDX FA1; LDA ADDR,2
       MRG ZLDA; APINS FA4,:,=0
XFC19  LDA =2; SKE CPT1; BRU *+2; BRU XFC20; SKN FA2; BRU *+2; BRU XFC20
       APCODE FA4,FA2
       LDX FA2; LDA ADDR,2; MRG ZLDB
       APINS FA4,:,=0
XFC20  LDA =3; SKE CPT1; BRU *+2; BRU XFC21; SKN FA3; BRU *+2; BRU XFC21
       APCODE FA4,FA3
       LDX FA3; LDA ADDR,2; MRG ZLDX; APINS FA4,:,=0
* COMPILED ALL OPERANDS
XFC21  BRU XFC22
* MORE THAN ONE BAD ARGUMENT. X CONTAINS ADDRESS OF THE SECOND ONE, CPT1 ITS
* NUMBER, A THE NUMBER OF THE FIRST
XFC14  STA CPT3; CXA; ETR =37777B; STA CPT2; FADDR* CPT2
XFC25  APCODE FA4,←CPT2; LDX* CPT2; M =-1,/CPTR
XFC24  LDA CPT1; SKE =2; BRU XFC26
* ONE TO GO
       SKN FA3; BRU *+2; BRU XFC26; LDX FA3; LDA CFLAG,2
       SKA =CLOBX+CLOBA+NEEDX; BRU *+2; BRU XFC26
       LDA CPT3; MIN CPT1; EAX FA3; BRU XFC14
* GENERATED STORES IN TEMP FOR EXTRA BAD ARGS
XFC26  M CPT3,CPT1; BRU XFC16
* COMPLETED CODE GENERATION FOR ARGUMENTS.  ALL CODE ON FA4. ARGUMENT LIST
* MAY BE ON FA5.
XFC22  M FA4,ARGSET; M FA5,ARGLST; TRET CFARGS

FARGT  DATA FA1,FA2,FA3
FCOPYT ZRO 0; CAB; CAX
FLOADT LDA 0; LDB 0; LDX 0



* GET ONE OF THE FIRST 3 ARGUMNETS OF A FUNCTION
* LEAVE CODE FOR IT IN WORD ADDRESSED BY X IF THERE IS ANY
GETARG M 0,FA7; STX FA8
       NEXT; LDA* INPUT; SKE ICOMMA; BRU GTARG1; LDA =1; BRU GTARG2
GTARG1 SKE ICOLON; BRU GTARG3; CLA; BRU GTARG2
GTARG3 SKE IRPAR; BRU *+2; BRU GTARG9
       SKE ISEMI; BRU *+2; BRU GTARG9
       SKE IFROM; BRU *+2; BRU GTARG9
       SKE IIF; BRU *+2; BRU GTARG9
       LDA =-1; BRU GTARG2
GTARG9 CLA
* GOT 1,0 OR -1 IN A IF NEXT CHAR IS COMMA, ARGLIST TERMINATOR, OR SOMETHING ELSE
GTARG2 STA GTRGT1
       LDA CARGCW; CAB; LCY 4; XMA CARGCW
       CALL EXAS; BRU GTARG4; BRU GTARG5; BRU GTARG6
* DEFAULT ARG GIVEN
       SKN GTRGT1; BRU *+2; BRU GTARG7
* USE IT, SINCE NONE IS SUPPLIED
       STA OP2; GND; M OP2,/ADDR; CXA
       LDX FA8; STA 0,2
GTARG8 LDA* INPUT; SKE ICOMMA; PREV; BRR FA7
* DON'T CARE
GTARG6 SKN GTRGT1; BRU GTARG8
* ARG PRESENT AND WANTED
GTARG7 PREV; RBF ←FA6,1; FVALNO OP2; LDX FA8; M OP2,/0
       BRU GTARG8
* ARG REQUIRED
GTARG4 SKN GTRGT1; CERR 16; BRU GTARG7
* ARG FORBIDDEN
GTARG5 SKN GTRGT1; BRU GTARG8; CERR 50



* EXAMINE ARGUMENT SPECIFIER IN LAST 4 BITS OF A.  RETURN NOSKIP IF IT
* SAYS ARGUMENT REQUIRED, ONESKIP IF FORBIDDEN, TWOSKIP IF DONT CARE,
* THREESKIP WITH ADDRESS IN A IF IT GIVES A DEFAULT ARG.
EXAS   STA EXAST1; LDB 0; STB EXAST2
       ETR =17B; CAX; SKG =8; BRU EXAS3
EXAS2  MIN EXAST2
EXAS1  MIN EXAST2
EXAS0  BRR EXAST2
EXAS3  EXU EXASTB,2; SKG =10; MCON; CAX
       MIN EXAST2; BRU EXAS2

EXASTB BRU EXAS2; CLA; LDA =1; LDA =-1; LDA =10
       LDA NARRAY; LDA NFTLER; BRU EXAS0; BRU EXAS1



* CALL WITH CODE FOR FUNCTION CALL IN OP2 AND INPUT POINTING AFTER ARGS.
* COLLECT FUNCTION CALL TAIL (:LABEL:SAVE LIST) IF PRESENT AND
* APPEND CODE TO DEAL WITH IT TO OP2.  CALLS EXPR.  CHECKS ARGCW
* FOR LABEL REQUIREMENTS
GFCTL  SAVE OP1,FA0
       M OP2,OP1
       CBF ICOLON,GFCTL1; NEXT; CBT ICOLON,GFCTL2
       LDA ARGCW; ETR =17B; SKE =8; BRU *+2; CERR 51
       PREV; CALL GADDR; CERR 19
GFCTL7 MRG ZBRUJ; APINS OP1,:,=0
       CBF ICOLON,GFCTL3
* READY FOR SAVES
GFCTL6 CBT IRPAR,GFCTL3
       CALL GADDR; BRU GFCTL4; MRG ZSTA; APINS OP1,:,=0; CALL CESAVS
GFCTL4 CALL GADDR; BRU GFCTL5; MRG ZSTB; APINS OP1,:,=0; CALL CESAVS
GFCTL5 CALL GADDR; BRU GFCTL3; MRG ZSTX; APINS OP1,:,=0
* NOW EXPECT )
GFCTL3 CBF IRPAR,15; NEXT; M OP1,OP2; TRET GFCTL
* INITIAL : BUT NO LABEL.  IS LABEL EXPECTED
GFCTL2 LDA ARGCW; CALL EXAS; CERR 52; BRU GFCTL6; BRU GFCTL6
       BRU GFCTL7
* NO : AT ALL
GFCTL1 CBF IRPAR,19; BRU GFCTL2


* GET ADDRESS FOR GFCTL.  IF NEXT CHAR IS , RETURN NOSKIP.
* IF IT IS ), GOTO GFCTL3
* OTHERWISE COLLECT EXPR AND RETURN ADDR IN A IF IT IS SIMPLE, ELSE ERROR
GADDR  M 0,FA0; NEXT; CBF ICOMMA,GADDR1; BRR 0
GADDR1 CBT IRPAR,GFCTL3; PREV; RBF EXPR,19
       LDX OP2; SKN CPTR,2; CERR 19
       LDA ADDR,2; SKA =60040000B; CERR 19; MIN FA0; BRR FA0


* CHECK FOR END OF SAVES: RPAR MEANS GOTO GFCTL3, COMMA IS OK. OTHERWISE
* ERROR
CESAVS CBT IRPAR,GFCTL3; CBF ICOMMA,19; BRR 0



* RECOGNIZER FOR TAIL AND ASSIGNMENT
XTAIL  SAVE OP1,SFLG,SSTAIL
       RBF XREF,1; M =-1,SFLG; CLA; STA LSFLG
XTAIL2 CBF IDOT,XBDOL1
* MUST HAVE FIELD NAME NEXT
       NEXT; LDX* INPUT; CXA; SKG ESYT; SKG BSYT; BRU XPR6
       LDA SFLAG,2; SKA =STRUCF; BRU XPR8
* EXPECTED FIELD NAME
XPR6   CERR 2
XPR8   ABC; SKB =PAGEDF; MRG =PAGADR; SKB =FLTVF; MRG =REALV; STA VFLAGS
       NEXT; CBF ILARR,XPR32; MIN SFLG; M =-1,LSFLG
XPR32  PREV
*  COMPILE CODE TO GET ADDRESS INTO X
       M =2B7,XPRT3; FVAL OP2; SKN ADDR,2; BRU XPR35
* COMPUTES
       FLOAD OP2; APINS OP2,ZXXA,=1
       LDA CFLAG,2; MRG =CLOBA+CLOBX; STA CFLAG,2; SKA =PAGADR
       BRU *+2; BRU XPR29; MCI =0; STX CPT1
       LDA ZCEIS; SKN LSFLG; LDA ZCEI; MRG CPT1
       APINS OP2,:,=0; BRU XPR29
* ADDRESS. IS IT PAGED
XPR35  LDA CFLAG,2; SKA =PAGADR; BRU XPR36
* NO. IS IT FIXED ARRAY, 24-BIT FIELD
       LDA ADDR,2; SKN CPTR,2; BRU XPR43A
       CAX; LDA SFLAG,2; SKA =ARRAYF+STRDF; BRU XPR42
XPR43  CXA
XPR43A MRG ZLDX; BRU XPR28
XPR42  LDB SCHAIN,2; SKB =SYMRIV; BRU *+2; BRU XPR43
       CXA; LDX* INPUT; LDB SCHAIN,2; LDX SVAL,2; XXA
       SKE =4B7+24; BRU XPR43; CBA; ADD SVAL,2; ETR =37777B
       STA CPT1; GSTS =3; LDX OP2; STA ADDR,2; CAX
       M CPT1,/SNAME; M =RVALF,/SFLAG; M =0,/SCHAIN
       NEXT; BRU XTAIL2
* YES
XPR41  LDX ADDR,2; LDA SVAL,2; STA XPRT3; GND; STX OP2; BRU XPR29
* PAGED
XPR36  LDA ZCEAS; SKN LSFLG; LDA ZCEA; MRG ADDR,2
XPR28  APINS OP2,:,=0
XPR29  SKN LSFLG; BRU XPR34
* STORE. SAVE CODE SO FAR
       M OP2,SSTAIL; GND; STX OP2
* DECODE FIELD DESCRIPTION
XPR34  LDX* INPUT; SKN SVAL,2; BRU *+2; BRU XPR27
       LDA SCHAIN,2; CAB; ETR =37777B
       ADM XPRT3; CLA; LSH 9
XPR37  STA XPRT4
       LDA SVAL,2; ADD XPRT4; SUB =1; SKG =23; BRU XPR9
       SUB =24; STA XPRT5; CLA; BRU XPR10
XPR9   STA XPRT5; LDA =-1
XPR10  STA XPRT6
       SKN LSFLG; BRU XPR12
* STORE
       SKN XPRT6; BRU XPR13
* FIELD IS WITHIN SINGLE WORD. CHECK FOR FULL WORD FIRST
       LDA XPRT4; SKE =0; BRU XPR14
* FIELD STARTS AT START OF WORD
       LDA XPRT5; SKE =23; BRU XPR15

* AND ENDS AT END OF WORD. JUST PASS XPRT3 AS ADDRESS
XPR39  LDX OP2; LDA =NEEDX+CLOBX; MRG CFLAG,2; STA CFLAG,2
       M XPRT3,/ADDR; BRU XPR17
* STARTS AT START BUT DOES NOT END AT END
XPR15  CNA; ADD =23; MRG ZLSH; STA XPRT5
       APINS OP2,ZCLB,=1; APINS OP2,XPRT5,=1
       LDA =-1; CLB; EXU XPRT5; STA CPT2
XPR20  LDA XPRT3; MRG ZXMA; APINS OP2,:,=0
       LDA CPT2; EOR =-1; MCON; MRG ZETR
       APINS OP2,:,=0
       LDA XPRT3; MRG ZADM; APINS OP2,:,=0
XPR24  LDA =CLOBA+CLOBX; LDX OP2; STA CFLAG,2; M =-1,/ADDR; BRU XPR17
* DOES NOT START AT START
XPR14  LDA =23; SUB XPRT5; SKG =0; BRU XPR18
       MRG ZLSH; STA XPRT5; APINS OP2,:,=1
       LDA =-1; CLB; EXU XPRT5; BRU XPR19
XPR18  LDA =-1
XPR19  LDX XPRT4; LSH 0,2; LRSH 0,2; STA CPT2; MCON
       MRG ZETR; APINS OP2,:,=0; BRU XPR20
* STORE INTO DOUBLE WORD FIELD
XPR13  SBRM ETRDL; LDA ZXMA; SBRM SETDL; LDA CPT2
       EOR =-1; SKE =0; BRU XPR22
       APINS OP2,ZCLA,=1; BRU XPR23
XPR22  MCON; MRG ZETR; APINS OP2,:,=0
XPR23  LDA XPRT3; MRG ZMRG; APINS OP2,:,=0
       LDA XPRT5; ADD =1; MRG ZRCY; APINS OP2,:,=1
       LDA XPRT3; MRG ZSTA; APINS OP2,:,=0
       LDA XPRT3; ADD =1; MRG ZSTB; APINS OP2,:,=0
       BRU XPR24
* LOAD OPERATION
XPR12  SKN XPRT6; BRU XPR25
* FIELD IS WITHIN SINGLE WORD
       LDA XPRT5; SKE =23; BRU XPR38; LDA XPRT4; SKG =0; BRU XPR39
XPR38  LDA XPRT3; MRG ZLDA; APINS OP2,:,=0
       LDA =23; SUB XPRT5; SKG =0; BRU XPR16; MRG ZLRSH; APINS OP2,:,=1
XPR16  LDA XPRT4; SKG =0; BRU XPR26; CNA; ADD XPRT5; ADD =1
       AXC; LDB =-1; LSH 0,2; MCON; MRG ZETR
       APINS OP2,:,=0
XPR26  BRU XPR24
* LOAD FROM DOUBLE WORD FIELD
XPR25  LDA ZLDA; SBRM SETDL; SBRM ETRDL; BRU XPR26
* TAIL IS SINGLE OR DOUBLE WORD FIELD. WHICH?
XPR27  LDA SVAL,2; ETR =37777B; SKE =24; BRU XPR30
* SINGLE. SIMPLY RETURN ADDRESS
       LDA SCHAIN,2
XPR31  ETR =37777B; ADD XPRT3
XPR31A LDX SSTAIL; SKN LSFLG
       LDX OP2; STA ADDR,2
       LDA =NEEDX+CLOBX; MRG CFLAG,2; STA CFLAG,2; STX OP2; BRU XPR17
* DOUBLE. NOT PRESENTLY IMPLEMENTED
XPR30  CERR 4
* DEALT WITH ONE DOT. CHARGE ON
XPR17  NEXT; LDX OP2; LDA CFLAG,2; ETR =@CONST
       MRG VFLAGS; STA CFLAG,2; BRU XTAIL2

* SUBROUTINES FOR FIELDS CROSSING WORDS
ETRDL  ZRO CPT3
       LDA XPRT5; ADD =25; SUB XPRT4; AXC; LDB =-1
       LSH 0,2; STA CPT2; SKE =-1; BRU *+2; SBRR ETRDL
       MCON; MRG ZETR; APINS OP2,:,=0; SBRR ETRDL


SETDL  ZRO CPT3
       MRG XPRT3; APINS OP2,:,=0
       LDA XPRT3; ADD =1; MRG ZLDB; APINS OP2,:,=0
       LDA XPRT5; ADD =1; MRG ZLCY; APINS OP2,:,=1; SBRR SETDL
* NO DOT. TRY FOR BINARY $, THEN SUBSCRIPTING, THEN ASSIGNMENT

XBDOL1 CBF IDOL,XTAIL1
* BINARY $.  COLLECT FIELD NAME
       SBRM GFIELD; PREV; LDX* INPUT
       CLB; LDA SFLAG,2; SKA =PAGEDF; LDB =PAGADR
       SKA =FLTVF; CERR 52; COPY BA,XB
       LDX OP2; MRG CFLAG,2; STA CFLAG,2; CBX
       SKN SVAL,2; BRU XBDOL7
       NEXT; BRU XTAIL1
XBDOL7 NEXT
* ANALYZE FIRST OPERAND INTO: CONSTANT, ADDRESS OR EXPRESSION
       LDX OP2; TIA OP2; BRU XBDOL2
* CONSTANT
       ETR CPT1; CAB; LDA CPT2; ETR =77B; COPY AX,BA
       RSH 0,2; MCC OP2; BRU XBDOL5
XBDOL2 SKN ADDR,2; BRU XBDOL3
* EXPRESSION
       FLOAD OP2; LDA CPT1; SKA =4B7; BRU XBDOL4; MCON
       MRG ZETR; APINS OP2,:,=0
XBDOL4 LDA CPT2; ETR =77B; SKG =0; BRU XBDOL5
       MRG ZLRSH; APINS OP2,:,=1; BRU XBDOL5
* NOT STORE-TYPE
XBDOL5 CBF ILARR,XTAIL2; CERR 1
* ADDRESS
XBDOL3 CBF ILARR,XBDOL6; MIN SFLG; M =-1,LSFLG; M OP2,SSTAIL
       GND; STX OP2; LDX SSTAIL
XBDOL6 PREV; LDA ADDR,2; STA XPRT3; LDX* INPUT; LDA SCHAIN,2
       LRSH 15; BRU XPR37

* CHECK FOR SUBSCRIPTS, FUNCTION CALLS, ASSIGNMENT
XTAIL1 CBF ILBRAK,XTL1A; RBF XSUBS,1; BRU XTAIL2
XTL1A  CBF ILPAR,XTL1B; RBF XFC,1; BRU XTAIL2
XTL1B  CBF ILARR,XTAIL3
* LEFT ARROW. CHECK FOR STRING CONSTANT
       LDX OP2; STX OP1; LDA CFLAG,2; SKA =CONST; CERR 45
       NEXT; CBF ISC,XTAIL4
* CHECK FOR VARIABLE←STRING CONSTANT
       LDX OP1; SKN ADDR,2; BRU *+2; BRU XTAIL4
* YES
       STX OP2; SBRM CSA; BRU XTAIL3
* NOT VARIABLE←STRING CONSTANT
XTAIL4 PREV; SKR LCTR; NOP; RBF XOR,1; MIN LCTR
       LDX OP1; SKN ADDR,2; BRU XTAIL5
* LEFT HALF IS NOT ADDRESS. MUST BE FIELD STORE OR ERROR
       SKN SFLG; BRU XTAIL6; CERR 1
XTAIL5 LDA CFLAG,2; SKA =CLOBA; BRU XTAIL7
* LEFT HALF DOES NOT CLOBBER A. DO THE OBVIOUS THING
* OPTIMIZER FOR REPLACEMENTS. LOOK FOR
*      X←X+1  OR LDA X: ADD =1   AND COMPILE MIN X
*      X←X-1  OR LDA X: SUB =1   AND COMPILE SKR X: NOP
*      X←E+X  OR -----: ADD X   AND COMPILE -----: ADM X
*      X←X+N  OR LDA X: ADD N   AND COMPILE LDA N: ADM X
       LDA ADDR,2; SKA =2004B4; BRU XTL13; STA CPT1; MRG ZLDA; STA CPT2
       LDX OP2; SKN ADDR,2; BRU XTL13; LDX CPTR,2; LDA 2,2; SKE CPT2
       BRU XTL14
* EXPRESSION STARTS WITH LDA X
       SKN 0,2; BRU *+2; BRU XTL13
       LDX 0,2; SKN 0,2; BRU XTL13
* ONLY 2 INSTRUCTIONS
       LDA 2,2; LDB =577B5; SKA =2004B4; BRU XTL13; SKM ZADD; BRU XTL15
* THEN ADD
       CAX; LDA SFLAG,2; SKA =INTCF; BRU XTL16
* NOT ADD =1. COMPILE ADM
XTL17  CXA; ETR =@577B5
XTL21  MRG ZLDA; STA CPT3; GND; STX OP2
       LDA CPT3; APINS OP2,:,=0; LDA CPT1; STA ADDR,2; MRG ZADM
XTL18  APINS OP2,:,=0
XTL20  M =CLOBA,/CFLAG; BRU XTAIL3
XTL16  LDA SVAL,2; SKE =1; BRU XTL17
* ADD =1. COMPILE MIN
       GND; STX OP2; LDA CPT1; STA ADDR,2; MRG ZMIN
       APINS OP2,:,=0; BRU XTAIL3
XTL15  SKM ZSUB; BRU XTL13
* THEN SUBTRACT
       CAX; LDA SFLAG,2; SKA =INTCF; BRU *+2; BRU XTL13
* CONSTANT
       LDA SVAL,2; SKE =1; BRU XTL19
* SUB =1. COMPILE SKR: NOP
       GND; STX OP2; LDA CPT1; STA ADDR,2; MRG ZSKR; APINS OP2,:,=0
       APINS OP2,ZNOP,=1; BRU XTAIL2
* SUB =CONST. CONVERT CONST AND COMPILE ADM
XTL19  CNA; MCON; BRU XTL21
* DOES NOT START WITH LDA X. DOES IT END WITH ADD X
XTL14  LDX 1,2; LDA 2,2; LDB =577B5; SKM ZADD; BRU XTL13
       ETR =@577B5; SKE CPT1; BRU XTL13
* YES. REPLACE IT WITH ADM X
       MRG ZADM; STA 2,2; LDX OP2; M CPT1,/ADDR; BRU XTAIL3
* ALL OPTIMIZATION FAILS
XTL13  FLOAD OP2
       APCODE OP2,OP1
XTAIL8 LDX OP1; LDA ADDR,2; MRG ZSTA; APINS OP2,:,=0
       LDA CFLAG,2; MRG =CLOBA; STA CFLAG,2; M =-1,/ADDR
       BRU XTAIL3
* OP1 DOES CLOBBER A. DOES OP2 CLOBBER X.  IF NOT, CAN COMPILE OP1 FIRST
XTAIL7 LDX OP2; LDA CFLAG,2; SKA =CLOBX; BRU XTAIL9
* DOESN'T. GO AHEAD
       FLOAD OP2
       APCODE OP1,OP2; M OP1,OP2; BRU XTAIL8
* BAD SITUATION. COMPUTE AND SAVE OP2
XTAIL9 FADDR OP2; APCODE OP2,OP1; APIA OP2,ZLDA; BRU XTAIL8
* FIELD STORE
XTAIL6 SKN LCTR; BRU XTL6A; FADDR OP2; LDX OP2; M /ADDR,CPT1
XTL6A  LDX SSTAIL; LDA CFLAG,2; SKA =CLOBA; BRU XTL10; SKN ADDR,2
       BRU *+2; BRU XTL10
* SETUP FOR STORE DOES NOT CLOBBER A. CONSTRUCT OP2 SSTAIL OP1
       FLOAD OP2; APCODE OP2,SSTAIL; BRU XTL12
* SETUP FOR STORE CLOBBERS A. IS RIGHT HALF COMPLETELY CLEAN
XTL10  LDX OP2; LDA ADDR,2; SKA =6004B4; BRU XTL11
* YES. CONSTRUCT OP2 SSTAIL  OP1
       APCODE OP2,SSTAIL; STX OP2; FLOAD OP2; BRU XTL12
* RIGHT HALF NOT CLEAN. MUST COMPILE OP2: STA TEMP: SSTAIL: LDA TEMP: OP1
XTL11  FADDR OP2; APCODE OP2,SSTAIL; APIA OP2,ZLDA
XTL12  APCODE OP2,OP1; LDX OP2; LDA CFLAG,2
       MRG =CLOBX+CLOBA; STA CFLAG,2; LDA CPT1; SKN LCTR; LDA =-1; STA ADDR,2
* NO LEFT ARROW EITHER
XTAIL3 TRET XTAIL



* COMPILE STRING ASSIGNMENT FOR CONSTANT TO OP2. RETURN OP2 IN X
CSA    ZRO CSAT1
       LDA ADDR,2; MRG ZESC; APINS OP2,:,=0; NEXT
       LDA* INPUT; APINS OP2,:,=5; APINS OP2,INPUT,=8
       LDA* INPUT; ADD =5; MUL =12525253B; ADM INPUT
       LDX OP2; LDA CFLAG,2
       MRG =CLOBA+CLOBX; STA CFLAG,2; SBRR CSA



* RECOGNIZER FOR INDIRECTION AND REFERENCE
XREF   SAVE
       NEXT; CBF IDOL,XREF1; RBF XREF,1
       FVAL OP2; SKN ADDR,2; BRU XREF2
       APINS OP2,ZXXA,=1
XREF4  LDX OP2; LDA =NEEDX+CLOBX; MRG CFLAG,2; STA CFLAG,2
       LDA =2B7; BRU XREF11
XREF2  LDA ADDR,2; SKA =4B4; BRU XREF3
       LDA CFLAG,2; ETR =@[CONST+STRNG]
       STA CFLAG,2; LDA ADDR,2; MRG =4B4
XREF11 STA ADDR,2; LDA CFLAG,2; SKA =PAGADR; BRU *+2; TRET XREF
* INDIRECTING THROUGH PAGED EXPRESSION.  IS IT STORE
       MRG =CLOBX; STA CFLAG,2; CBF ILARR,XREF12; LDA ZCEAS; BRU XREF13
XREF12 LDA ZCEA
XREF13 MRG ADDR,2; ETR =@4B4; APINS OP2,:,=0
       LDX OP2; M =2B7,/ADDR; TRET XREF
XREF3  MRG ZLDX; APINS OP2,:,=0; BRU XREF4
* NO $
XREF1  CBF IAT,XREF5; RBF XPRIM,1; RBF XSUBS,1
       FVAL OP2; SKN ADDR,2; BRU XREF6; CERR 5
XREF6  LDX OP2; LDA ADDR,2; SKE =2B7; BRU *+2
* ADDRESS IS 0,2. HENCE REFERENCE IS IN X ALREADY
       BRU XREF8
* ADDRESS MUST BE GOTTEN TO X
       SKA =2004B4; BRU XREF9
* CAN USE LITERAL
       MSTCON; LDX OP2; STA ADDR,2; TRET XREF
XREF9  MRG ZEAX; APINS OP2,:,=0
* NOW SEND ADDRESS FROM X TO A
XREF8  APINS OP2,ZXXA,=1
* AND CLEAR NON-ADDRESS BITS UNLESS TAIL IS COMING, IN WHICH
* CASE IT IS NOT NECESSARY SINCE ADDRESS WILL BE SENT RIGHT
* BACK TO X
       CBT IDOT,XREF7; MCI =37777B; MRG ZETR
       APINS OP2,:,=0
* NOW SET ADDR PROPERLY AND EXIT
XREF7  M =-1,/ADDR
       LDA =CLOBX+CLOBA; MRG CFLAG,2; STA CFLAG,2; TRET XREF
* NO AT EITHER
XREF5  PREV; RBF XPRIM,1; RBF XSUBS,1; TRET XREF



* RECOGNIZER FOR SUBSCRIPTING. EXPECT INPUT POINTING TO FIRST
* ELEMENT OF INTEREST, NOT TO THE ONE BEFORE AS ALL HIGHER LEVEL
* THINGS DO
XSUBS  SAVE OP1
XSUBS5 CBF ILBRAK,XSUBS1
       M OP2,OP1; RBF EXPR,1; CBF IRBRAK,6; NEXT; FVALNO OP1
       LDA ADDR,2; SKA =6004B4; BRU XSUBS2
* SIMPLE NAME. IS IT ARRAY NAME
       CAX; LDA SFLAG,2; SKA =ARRAYF+STRDF; BRU XSBS11
* NO.  IS IT PAGED (IF SO, TREAT LIKE ARRAY)
XSBS15 LDA SFLAG,2; SKA =PAGEDF+ARRAYF; BRU XSBS10; BRU XSUBS2
* ARRAY.  IS IT FIXED?
XSBS11 LDA SCHAIN,2; SKA =SYMRIV; BRU *+2; BRU XSBS15
       M /SVAL,CPT1
* YES. CONSTANT SUBSCRIPT?
       LDX OP2; TIA OP2; BRU XSUBS7
* YES.  COMPUTE ADDRESS
       ADM CPT1; GSTS =3
       LDX OP1; STX OP2; STA ADDR,2
       CLB; STB CFLAG,2; AXC; STA SCHAIN,2
       LDA CPT1; ETR =37777B; STA SNAME,2
       M =RVALF,/SFLAG; BRU XSUBS5
* COMPILE LDX SUBSCRIPT, ADDR* NAME
XSBS10 FVAL OP2; SKN ADDR,2; BRU XSUBS3
       APINS OP2,ZXXA,=1; BRU XSUBS4
XSUBS3 LDA ADDR,2; MRG ZLDX; APINS OP2,:,=0
XSUBS4 LDX OP1; LDX ADDR,2; LDA SFLAG,2; SKA =PAGEDF; BRU XSUBS8
       CXA; MRG =4B4; LDX OP2; BRU XSUBS6
* PAGED ARRAY
XSUBS8 LDB ZCEI; CBF ILARR,XSUBS9; LDB ZCEIS
XSUBS9 COPY XA,BA; APINS OP2,:,=0; LDA =2B7; LDX OP2
XSUBS6 STA ADDR,2; LDA =NEEDX+CLOBX; MRG CFLAG,2; ETR =@CONST; STA CFLAG,2
       BRU XSUBS5
* OBJECT BEING SUBSCRIPTED IS NOT ARRAY NAME.
* CHECK FOR CONSTANT SUBSCRIPT FIRST
XSUBS2 LDX OP2; TIA OP2; BRU XSBS12; STA CPT1
* GOT ONE.  COMPILE LDX OP1: ADDR OP2,2
       LDX OP1; STX OP2; SKN ADDR,2; BRU XSBS13
       APINS OP2,ZXXA,=1; BRU XSBS14
XSBS13 LDA ADDR,2; MRG ZLDX; APINS OP2,:,=0
XSBS14 LDA CPT1; ETR =37777B; MRG =2B7; LDX OP2; BRU XSUBS6
* NON CONSTANT.  COMPILE LDA OP1: ADD OP2: XXA: ADDR 0,2
XSUBS7 LDA CPT1; SKA =2B7; BRU XSBS10
XSBS12 LDX OP2; SPP OP1; NOP; STX OP1
       APIXA OP1,ZADD; APINS OP1,ZXXA,=1; LDA =2B7; LDX OP1; STX OP2
       BRU XSUBS6
XSUBS1 TRET XSUBS



* RECOGNIZER FOR PRIMARY.
XPRIM  SAVE
       NEXT
       CBT ILPAR,XPRI6; CBT ISC,XPRI15
       LDX* INPUT; CXA; SKG =MAXSF; SKG =277B; BRU *+2
       BRU XPRI7; SKG ESYT; SKG BSYT; BRU XPRI1
       LDA SFLAG,2; SKA =INTCF; BRU XPRI2
       SKA =STRUCF; BRU XPRI4
       SKA =STRDF; BRU XPRI8
       SKA =PAGEDF; BRU XPRI14
* ORDINARY NAME WITH NO SPECIAL PROPERTIES. GENERATE
* DESCRIPTOR FOR IT
       GND
XPRI5  LDA* INPUT
XPRI10 STA ADDR,2; STX OP2; NEXT; TRET XPRIM
* PAGED NAME
XPRI14 GND; M =PAGADR,/CFLAG; BRU XPRI5
* INTEGER CONSTANT
XPRI2  GND; LDA =CONST; STA CFLAG,2; BRU XPRI5
* FIELD NAME. IS IT FOLLOWED BY PARENTHESES
XPRI4  STX OP1; NEXT; CBF ILPAR,XPRI11
* YES. EXPECT EXPRESSION
       RBF EXPR,1; LDX OP1; SBRM GPF
* DO WE HAVE CONSTANT
       LDX OP2; TIA OP2; BRU XPRI12
* YES.  COMPUTE RESULT
       EXU CPT2; ETR CPT1; MCC OP2
XPRI13 CBF IRPAR,9; NEXT; TRET XPRIM
* NOT CONSTANT
XPRI12 FLOAD OP2; APINS OP2,CPT2,=1; MCI CPT1; MRG ZETR
       APINS OP2,:,=0; M =-1,/ADDR; LDA CFLAG,2; MRG =CLOBA
       STA CFLAG,2; BRU XPRI13
XPRI11 PREV
       LDA SCHAIN,2; ETR =37777B; MCON; STX CPT1
       GND; LDA =CONST; STA CFLAG,2; LDA CPT1; BRU XPRI10
* STRING. HANDLE LIKE ORDINARY INTEGER VARIABLE
XPRI8  GND; BRU XPRI5
* NOT LPAR OR SYMBOL
XPRI1  CERR 8
* LEFT PARENTHESIS
XPRI6  RBF EXPR,1; CBF IRPAR,9; NEXT; TRET XPRIM
* SPECIAL FUNCTION
XPRI7  RBF XSF,1; NEXT; TRET XPRIM
* STRING CONSTANT.  COMPILE ESC IN-LINE
XPRI15 GND; STX OP2
       LDA =6; MRG ZBRU; APINS OP2,:,=6
       GTADR; STA CPT1; APINS OP2,:,=2; APINS OP2,=1,=6
       APINS OP2,=4,=7; LDX OP2; M CPT1,/ADDR; SBRM CSA
       TRET XPRIM

* GET PARAMETERS OF FIELD AND CHECK THAT IT FALLS IN ONE WORD.
* LEAVE MASK IN CPT1, LSH INSTRUCTION IN CPT2. CALL WITH
* PTR TO S.T. ENTRY FOR FIELD IN X
$GPF   ZRO GPFT1
       STX CPT2; LDA SCHAIN,2; LRSH 15; STA CPT1; ADD SVAL,2
       ETR =37777B; SKG =24; BRU *+2; CERR 39
* COMPUTE LEFT SHIFT AND MASK
       LDB =-1; LDX SVAL,2; CLA; RCY 0,2; LDX CPT1; LRSH 0,2; XMA CPT1
       LDX CPT2; ADD SVAL,2; CNA; ADD =24
       MRG ZLSH; STA CPT2; SBRR GPF



* RESERVED WORD TABLE

* MACRO TO CREATE TABLE FOR INTIALIZATION OF RESERVED WORDS

RW     MACRO D;Q1 NARG; RPT (Q2=1,2,Q1)
       RW1 'D(Q2)      ',D(Q2+1); ENDR; ENDM
RW1    MACRO D; DATA 'D(1$2,5)'
       DATA '  D(1$6,7)'+RWF
       IF RWI;$I.&D(1$2,6) EQU *; ENDF; DATA D(2); ENDM


$RWT   BSS 0
RWI    EQU 1
       RW AND,100B,OR,101B,NOT,102B,EOR,103B,MOD,104B
       RW LSH,130B,RSH,131B,LCY,132B,RCY,133B,MACRO,134B
       RW WHERE,105B,IF,106B,ELSE,107B,GOTO,115B,DO,116B
       RW FOR,117B,WHILE,120B,TO,121B,BY,123B,ENDFOR,124B
       RW ENDIF,125B,ELSEIF,126B,SRETUR,127B,INCLUDE,135B
       RW DECLARE,110B,INTEGER,111B,STRING,112B,FIELD,113B,ARRAY,114B
       RW ENTRY,233B,EXTERNAL,234B,LOCAL,235B
       RW FUNCTION,236B,RETURN,237B,FROM,240B,END,241B
       RW LIST,242B,NOLIST,243B,SOURCE,244B,BINARY,245B,CODE,246B
       RW IDENT,247B,FIXED,250B,PARAMETER,251B,LINK,252B,PAGED,253B
       RW REAL,254B,RECURSIVE,255B
       RW SAVE,300B,FREE,301B
RWI    EQU 0
       RW GCI,302B,WCI,303B,GCD,304B,WCD,305B
       RW GC,306B,APPEND,307B,SETS,310B,LENGTH,311B,SETUP,312B
       RW INFILE,313B,OUTFILE,314B,CLOSE,315B,CLOSALL,316B,INNAME,317B
       RW OUTNAME,320B,SCOPY,321B,BCOPY,322B,CIN,323B,COUT,324B
       RW SOUT,325B,IOUT,326B,IIN,327B,CRLF,330B
       RW SETR,331B,SETW,332B,WIN,333B,WOUT,334B
       RW SETARRAY,335B,PMAKE,336B,INITIALIZE,337B
       RW HALT,340B,EXIT,341B,FMASK,342B,FSHIFT,343B
       RW CNS,344B,CSN,345B,BRS,346B,SBRM,347B,LOCK,350B,UNLOCK,351B
       RW PFLUSH,352B,MAKE,353B,BPUT,354B,BGET,355B,POP,356B
$MAXSF EQU 356B


$ERWT  DATA -1



$ISC   DATA 277B


$IGE   DATA 231B
$ILE   DATA 232B


* MACRO TO CREATE SPECIAL CHARACTER TABLE.  ARGUMENTS ARE CHARACTER,
* INTERNAL NAME, INTERNAL VALUE.  MUST BE ORDERED BY CHARACTER CODE VALUE

SC     MACRO D;Q1 NARG; RPT (Q2=1,3,Q1);Q3 NCHR D(Q2)
       IF Q3>1;Q3 EQU D(Q2); ELSE;Q3 EQU '   D(Q2)'; ENDF; IF Q3>SCV
       IF Q3>SCV+1; RPT (Q4=SCV+1,Q3-1); DATA -1; ENDR
       ENDF;$D(Q2+1) DATA D(Q2+2);SCV EQU Q3
       ELSE
       REM (CALL OF SC WITH ARGS D(Q2),D(Q2+1) CONFLICTS WITH SCV VALUE OF ($SCV))
       ENDF; ENDR; ENDM


SCV    EQU -1

$SCTAB SC 00B,IBLANK,200B,02B,IDQT,201B,03B,INE,202B,$,IDOL,203B
       SC 06B,IAMP,204B,07B,ISQT,205B,10B,ILPAR,206B,11B,IRPAR,207B
       SC *,ISTAR,210B,+,IPLUS,211B,14B,ICOMMA,212B,-,IMINUS,213B
       SC .,IDOT,214B,/,ISLASH,215B,:,ICOLON,216B,33B,ISEMI,217B
       SC <,ILT,220B,=,IEQ,221B,>,IGT,222B,40B,IAT,223B
       SC [,ILBRAK,224B,],IRBRAK,225B,76B,IUPARR,226B,77B,ILARR,227B
       SC 100B,INULL,230B





* MACRO TO DEFINE Z-WORDS FOR OPCODES IN ARPAS
ZD1    MACRO D;Q1 NARG; RPT (Q2=1,Q1);$Z.&D(Q2) D(Q2) 0; ENDR; ENDM



       ZD1 LDA,STA,LDB,LDX,STX,EAX,ADD,SUB,MUL,DIV
       ZD1 CBA,XAB,XXA,CNA,CLA,CLAB,CLB,CXA,CAB,ABC
       ZD1 ETR,MRG,EOR,BRU,LSH,RSH,LRSH,LCY,RCY
       ZD1 SKG,SKE,ADM,BRS,CIO,STB,XMA,WIO,BIO
       ZD1 BRR,NOP,MIN,SKR,SKN,SKA,SBRM

       ZD1 CALL,ESC,CEA,CEI,CEAS,CEIS,RCALL,RRET

ZBRUI  BRU 0,2
ZBRUJ  BRU* 0
ZLSH23 LSH 23
ZRSH23 RSH 23
$ZINIT CALL* INIT
$ZBRS10 BRS 10
ZSTAR1 STA ARG1
ZLDAR1 LDA ARG1
ZLDXR3 LDX ARG3
ZLDXRL LDX RECLNK
ZMINTR MIN* TOPRST
ZLDXTR LDX TOPRST





* RECOGNIZERS NEEDED BY QMISC
       EXTDEF EXPR,CFARGS,GFCTL,EXAS


       END

********************  QSPL-CONV  *****


START  DEFINE('GSTAT()')
       DEFINE('WSTAT(OUTSTAT)')
       DEFINE('NEXTLINE()')
       DEFINE('CHECKGOTO(CHG)')
       CTIME=CLOCK(0)
       STAT=@STCOUNT
       NULLS=' &M&J'
       CRLF='&M&J'
       PARS='()'
       SIMPLESPECIALS='!#$%&&*:=-@←[\+?/>.<,]↑'
       SPECIALS=SIMPLESPECIALS PARS
       QUOTES='"' "'"
       SYMBREAKS=SPECIALS NULLS QUOTES
       SYMCHARS=@ALPHABET @DIGITS
       NOTPARS=SIMPLESPECIALS NULLS SYMCHARS
       CLOSE(-1)
       INPUTFILE=INFILE
       INFILNO=OPENIN(INPUTFILE)
       ASSIGN('SOURCE',INFILNO)
       OUTFILNO=OPENOUT(OUTFILE)
       ASSIGN('RESULT',OUTFILNO)
       CHAR('RESULT')
       LINE=
       LINENO=0
       CHARSET1=@ALPHABET @DIGITS SPECIALS NULLS
       IPAT=POS(0) BREAK(';' QUOTES) . LF1 ANY(';' QUOTES) . LF2
       IPATSQT=POS(0) BREAK("'") . LF1 "'" . LF2
       IPATDQT=POS(0) BREAK('"') . LF1 '"' . LF2
       NNULBRK=BREAK(SYMCHARS SPECIALS QUOTES ';')
       CPAT1=POS(0) NNULBRK '*'
       CPAT2=POS(0) SPAN(NULLS) RPOS(0)
       ARGLIST=BREAK(PARS QUOTES) FENCE ( ')' ! (('(' *ARGLIST ')' ) !
       ('"' BREAK('"') '"') !
       ("'" BREAK("'") "'")) FENCE *ARGLIST )
       SYMBOL=SPAN(SYMCHARS)
       SFPAT1=(ARB BREAK('GWAIO')) . LF1
       ((ANY('GWAIO') SPAN(SYMCHARS)) . NF1 NNULBRK '(') . LF2
       ARGLIST . LF3 REM . LF4
LOOP   CSTAT=
       STAT=GSTAT() :F(EOF)
PARTLOOP STAT SFPAT1 :F(STATOK)
       '(GCI(WCI(GCD(WCD(INFILE(OUTFIL(INNAME(OUTNAME(' '(' NF1 '(' :F(PARTSTATOK)
       LF2 SYMBOL . LABEL :($LABEL)
GCI
INFILE
INNAME
OUTNAME
GCD    LF3 POS(0) BAL . AF1 ',' BAL . AF2 ')' :F(PARTSTATOK)
GCI1   AF2=CHECKGOTO(AF2)
       LF3=AF1 ':' AF2 ')' :(PARTSTATOK)
WCI
WCD    LF3 POS(0) (BAL ',' BAL) . AF1 ',' BAL . AF2 ')' :F(PARTSTATOK)S(GCI1)
OUTFIL LF3 POS(0) BAL . AF1 ',' BAL . AF2 ((',' BAL) ! NULL) . AF3
       ')' :F(PARTSTATOK)
       AF2=CHECKGOTO(AF2)
       LF3=AF1 AF3 ':' AF2 ')' :(PARTSTATOK)
PARTSTATOK CSTAT=CSTAT LF1 LF2 LF3
       STAT=LF4 :(PARTLOOP)
STATOK WSTAT(CSTAT STAT) :(LOOP)
CHECKGOTO CHG NNULBRK 'GOTO' SPAN(NULLS) BAL . CHECKGOTO RPOS(0)
       :S(RETURN)
       OUTPUT=CRLF 'FAILURE NOT GOTO. LINE ' LINENO
       OUTPUT=STAT 
       CHECKGOTO=CHG :(RETURN)
EOF    STAT (POS(0) ! ':') NNULBRK 'END' NNULBRK ';' :S(CLEANUP)
       OUTPUT=CRLF 'UNEXPECTED EOF.  LAST STATEMENT PROCESSED IS'
       OUTPUT=STAT
CLEANUP CLOSE(INFILNO)
       CLOSE(OUTFILNO)
       OUTPUT= LINENO ' LINES   ' ((CLOCK(0) - CTIME) / 60) ' SEC   '
       (@STCOUNT - STATS) ' STATS'
       OUTPUT='DONE' :(END)
GSTAT  GSTAT=
COMMENTLOOP LINE CPAT1 :S(COMMENTLINE)
       LINE CPAT2 :F(GSTATLOOP)
* LINE IS FULL OF NULLS
       NEXTLINE() :F(FRETURN)S(COMMENTLOOP)
COMMENTLINE NEXTLINE() :F(FRETURN)
       WSTAT(GSTAT) :(GSTAT)
GSTATLOOP LINE IPAT= :F(GSTAT1)
       GSTAT=GSTAT IDENT(LF2,';') LF1 ';' :S(RETURN)
*QUOTE
       GSTAT=GSTAT LF1 LF2
       IDENT(LF2,'"') :S(GETDQT)
* SINGLE QUOTE
GETSQT LINE IPATSQT = :S(GOTQT)
       NEXTLINE() :S(SETSQT)F(FRETURN)
GOTQT  GSTAT=GSTAT LF1 LF2 :(GSTATLOOP)
GETDQT LINE IPATDQT = :S(GOTQT)
       NEXTLINE() :S(GETDQT)F(FRETURN)
GSTAT1 NEXTLINE() :S(GSTATLOOP)F(FRETURN)
NEXTLINE GSTAT=GSTAT LINE
       LINENO=LINENO + 1
       LINE=SOURCE CRLF :S(RETURN)F(FRETURN)
WSTAT  RESULT=OUTSTAT
       OUTPUTC=IDENT(MONF,'T') OUTSTAT :(RETURN)

*******************  QSPL-CTL  *****


START  ALLFILES='QRUN,QSTOR,QCOMP,QMISC,QDRIV,'
       CRLF='&M&J'
       LOGIN() :F(NOLOGIN)
       DEFINE('NARP(SRCLIST)')
       DEFINE('T(BINFIL,ORG,BOUND)')
       DIGIT=ANY('0123456789')
       DIGITS=SPAN('0123456789')
       ENDNARP=POS(0) '&J' DIGITS . TIME ' SEC    '
  DIGITS . ERRORS ' ERR    ' DIGITS . WRDS ' ('
CLOOP  OUTPUTC='?'
       A=INPUTC
       '.FINISHED.READ.WRITE.ASSEMBLE.LOAD.' '.' A ARB . B '.' :S(GOODCOM)
BADCOM OUTPUT = ' EH?' :(CLOOP)
GOODCOM OUTPUTC = B :($(A B))
NOLOGIN OUTPUT='UNABLE TO LOG IN' :(END)
FINISHED IDENT(INPUTC,'.') LOGOUT() :S(END)F(BADCOM)
READ   IDENT('.',INPUTC) :F(BADCOM)
       OUTPUT=
       FILES=ALLFILES
       COMM = "'KDF'."
RLOOP  FILES ARB . NAME ',' = :F(RL1)
       COMM = COMM "R" NAME ".'/" NAME "/'." :(RLOOP)
RL1    COMM=COMM "F."
       SEND(COMM)
       A=RECV(10000)
       A '?' :F(CLOOP)
RWERR  OUTPUT = "ERROR.  TEXT FOLLOWS"
       OUTPUT = A :(CLOOP)
WRITE  '\.STOREALL,\:STORELIST,' '\' INPUTC ARB . A ',' :F(BADCOM)S($A)
STORELIST OUTPUTC=   '   '
       FILES=INPUT ',' :(WL2)
STOREALL FILES=ALLFILES
WL2    COMM="'KDF'."
WLOOP  FILES ARB . NAME ',' = :F(WL1)
       COMM=COMM "W" NAME ".'/" NAME "/'." :(WLOOP)
WL1    COMM=COMM "F."
       SEND(COMM)
       A=RECV(10000)
       A '?' :F(CLOOP)S(RWERR)
ASSEMBLE IDENT(INPUTC,'.') :F(BADCOM)
       OUTPUT=
       SEND("'CHANGE DRUM ASG TO '500.")
       RECV(1000) '500 OUT OF' :S(DRUMOK)
       OUTPUT = 'NOT ENOUGH DRUM' :(CLOOP)
DRUMOK NARP('QRUN')
       NARP('QSTOR,QCOMP,QMISC,QDRIV') :(CLOOP)
NARP   SRCLIST=SRCLIST ','
       ALLOUTPUT=
       SRCLIST ARB . SRCFIL ',' =  :F(BADARGTONARP)
       SEND("'NARP'.") :(NARP1)
NARPLOOP ALLOUTPUT=ALLOUTPUT NARPOUT
       SRCLIST ARB . SRCFIL ',' =  :F(RETURN)
       SEND("'CONTINUE'.")
NARP1  OUTPUT = 
       OUTPUT = 'ASSEMBLING ' SRCFIL ':'
       NARPOUT=RECV(10000)
       SEND("'/" SRCFIL "/'.'/B-" SRCFIL "/'.")
NARP3  TEMP=RECVLINE() :F(NARP2)
       NARPOUT=NARPOUT TEMP CRLF
       TEMP ENDNARP :F(NARP3)
       OUTPUT = '&J' TIME ' SEC  ' WRDS ' WORDS'
       EQ(ERRORS,0) :F(NARP4)
       OUTPUT= SRCFIL ' ASSEMBLED' :(NARPLOOP)
NARP4  OUTPUT='ERRORS:'
NARP5  OUTPUT=NARPOUT :(NARPLOOP)
NARP2  OUTPUT='NO ASSEMBLY'
       NARPOUT=NARPOUT RECV(10000) :(NARP5)
LOAD   OUTPUTC=' '
       '.COMPILER.RUNTIME.' '.' (INPUTC ARB . B) . A '.' :F(BADCOM)
       OUTPUTC=B
       IDENT(INPUTC,'.') :F(BADCOM)S($A)
COMPILER OUTPUT=
        SEND("'RESET'.'DDT'.")
       DDTOUT=RECV(1000)
       T('QRUN',34000,40000)
       T('QSTOR',240,4000)
       T('QCOMP',4000,24000)
       T('QMISC',,24000)
       SEND(';F<F:%R34000;ABRS 4;U.')
       DDTOUT=DDTOUT RECV(1000)
       SEND('%R')
       TEMP=RECV(1000)
       DDTOUT=DDTOUT TEMP
       TEMP (DIGIT DIGIT) . A (DIGIT DIGIT) . B (DIGIT DIGIT DIGIT DIGIT) . C
         ARB DIGITS . D  :F(CONFUSION)
       SEND(A '00' C ',' D '+' B '0000;R')
       DDTOUT=DDTOUT RECV(1000)
       T('QDRIV',4000,10000)
       SEND('%R;U')
       OUTPUT=RECV(1000)
       SEND("%F'DUMP ON''/DUMP/'.")
LOADX  DDTOUT=DDTOUT RECV(1000) :(CLOOP)
T      SEND(ORG ';T' "'/B-" BINFIL "/';")
       TEMP = RECV(10000)
       DDTOUT=DDTOUT TEMP
       TEMP DIGITS . A CRLF :S(GOODLOAD)
       OUTPUT='BAD LOAD:' CRLF TEMP :(RETURN)
GOODLOAD GT(BOUND,A) :S(BOUNDOK)
       OUTPUT='EXCEEDED BOUND:' CRLF TEMP :(RETURN)
BOUNDOK OUTPUT=BINFIL ' LOADED' :(RETURN)
RUNTIME OUTPUT=
       SEND("'RESET'.'DDT'.")
       DDTOUT=RECV(1000)
       T('QRUN',34000,40000)
       SEND("IRUN;G34000%Y'/B-QRUN/'."
   "ENDTS;FENDTS;K224;0;F<..:%F"
   ";B<X:0,X;R30000\BRU RUN0; .&M")
       DDTOUT=DDTOUT RECV(10000)
       SEND('%R;U')
       OUTPUT=RECV(1000)
       SEND("%F'SAVE CORE'30000 37777 '/QRUN',30000.'DUMP ON''/DQRUN'.")
               :(LOADX)

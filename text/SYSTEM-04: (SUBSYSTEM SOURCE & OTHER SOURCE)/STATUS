COMMON    SYSCALLS;

* MCALL DECLARATIONS

MACRO     ARBMC ← UNKNOWN MONITOR;
MACRO     INTMC ← INTEGER MONITOR;
MACRO     STMC ← STRING MONITOR;
MACRO     LNMC ← LONG MONITOR;
MACRO     LNLNMC ← LONGLONG MONITOR;

* CALLS TO MANIPULATE MIBS AND SIBS
INTMC     CREATE'MIB ← 190;
ARBMC     READ'MIBOB'INDEX ← 0;
ARBMC     READ'MIBOB'NAME ← 1;
ARBMC     SET'MIBOB'NAME ← 2;
ARBMC     SET'MIBOB'ACCESS ← 3;
ARBMC     SET'LOCK'LIST ← 4;
ARBMC     DELETE'MIBOB ← 5;
INTMC     CREATE'MIBOB ← 6;
ARBMC     SET'MIB'ACCESS ← 10;
INTMC     READ'MIB'ACCESS ← 11;
ARBMC     SET'MIBOB'VALUE ← 12;
INTMC     COPY'MIBOB ← 14;* UNIMPLEMENTED
ARBMC     SET'NO'CHARGE ← 15;*** ???
INTMC     READ'MIB'SPACE ← 16;
ARBMC     SET'FILE'LOCK ← 18;*?* UNIMPLEMENTED
ARBMC     SET'DURABILITY ← 28;*** ???

* OFT CALLS
INTMC     MOPEN'FILE ← 19;
ARBMC     MREAD'OFT ← 20;
ARBMC     SET'OFT'AL ← 21;
INTMC     MSET'OFT'CL ← 22;
ARBMC     SET'FILE'LENGTH ← 23;* IMPROVE THIS FOR UTS
INTMC     CR'FILE'PAGE ← 24;
INTMC     DEL'FILE'PAGE ← 25;
INTMC     NEXT'FILE'PAGE ← 26;
ARBMC     MOVE'PAGE'PMT ← 27;

* PMT CALLS
INTMC     ACQUIRE'PMT ← 50;
ARBMC     NEW'PMT'PAGE ← 51;
ARBMC     CLEAR'PMT ← 53;
ARBMC     DELETE'PMT ← 54;
ARBMC     SET'PMT'AL ← 55;
ARBMC     SET'PMT'CL ← 56;
ARBMC     SET'PMT'RO ← 57;
ARBMC     READ'PMT ← 58;

* WORKING SET CALLS
ARBMC     PUT'PAGE'DWS ← 65;
ARBMC     PUT'PAGE'CWS ← 66;
INTMC     DEL'PAGE'DWS ← 67;
INTMC     DEL'PAGE'CWS ← 68;
INTMC     READ'LWS ← 70;
ARBMC     SET'LWS ← 71;

* SPT CALLS
INTMC     MCREATE'SP ← 90;
ARBMC     MDESTROY'SP ← 91;
ARBMC     MREAD'SPT ← 95;
ARBMC     READ'SPCS ← 96;
INTMC     MRD'SPT'FIELD ← 97;
ARBMC     MST'SPT'FIELD ← 98;
ARBMC     READ'MAP ← 99;
ARBMC     SET'MAP ← 100;
INTMC     READ'MAP'BYTE ← 101;
ARBMC     SET'MAP'BYTE ← 102;
INTMC     READ'SPS'PARAM ← 106;

* SPCS CALLS
ARBMC     SP'CALL ← 111;
ARBMC     SP'JUMP ← 112;
ARBMC     SP'TRAP ← 113;
ARBMC     TRAP'RETURN ← 114;
ARBMC     SP'BRANCH ← 115;
ARBMC     SP'RETURN ← 116;
ARBMC     JUMP'RETURN ← 117;
ARBMC     MARK'CALL ← 118;
ARBMC     DELETE'CALL ← 119;
ARBMC     MODIFY'CALL ← 120;

* PROCESS CALLS
INTMC     COPY'PMT'PROC ← 130;
INTMC     ACTIVATE'PROC ← 132;
ARBMC     TRANSFER'TERM ← 133;
ARBMC     MAKE'DORMANT ← 134;
ARBMC     INIT'PROC'PAGE ← 135;
ARBMC     INIT'PROC'MAP ← 136;
ARBMC     INIT'SPT ← 137;
INTMC     READ'PROC'PARAM ← 211;

* IWS CALLS
ARBMC     SET'PROC'INT ← 163;
ARBMC     QUIT'BLOCK ← 164;
INTMC     GET'INT'NO ← 165;
ARBMC     READ'ICT ← 166;
ARBMC     ALLOW'INTS ← 168;
ARBMC     REFUSE'INTS ← 169;
ARBMC     BLOCK ← 170;
ARBMC     SET'ICT ← 172;
ARBMC     SET'ICT'CL ← 173;
INTMC     ACQUIRE'ICT ← 174;

* CHIO CALLS
ARBMC     SET'LINE'FIELD ← 180;
ARBMC     READ'LINE'TABLE ← 181;
ARBMC     READ'STRING'BRK ← 182;
ARBMC     WRITE'STRING ← 183;

* MISCELLANEOUS
LNMC      READ'CLOCK ← 210;

* UCALL DECLARATIONS

MACRO     ARBUC ← UNKNOWN UTILITY;
MACRO     INTUC ← INTEGER UTILITY;
MACRO     CHRUC ← CHARACTER UTILITY;
MACRO     STUC ← STRING UTILITY;
MACRO     LNUC ← LONG UTILITY;

* MISCELLANEOUS UCALLS
ARBUC     BREAK'POINT ← 0;*             UCALL FOR DEBUGGING PROGRAMS
STUC      ERRORMSG ← 1;*                RETURN SYSTEM ERROR MESSAGE
STUC      GET'PARAM ← 2;*               STRIP PARAMETER FROM STRING
STUC      GET'COM'LINE ← 3;*            GET CURRENT COMMAND LINE FROM UTS
INTUC     ABRV'LKP ← 4;*                LOOK UP ABBREVIATED NAME IN STARY
INTUC     CON'ABRV'LKP ← 5;*            CONTINUE SAME IN NEW STARY

* FILE SYSTEM CALLS
ARBUC     NAME'SEARCH ← 10;*            CONVERT FILE ST TO UTS NAME
ARBUC     SPECIAL'SEARCH ← 11;*         VARIATION OF ABOVE
INTUC     CONV'NAME ← 12;*              CONVERT FROM UTS TO MON FILE NAME
ARBUC     SPREAD'NAME ← 13;*            SPLIT FILE NAME STRING INTO COMP.
ARBUC     READ'MIBOB'VALUE ← 14;*       READ 'VALUE' OF MIB OBJECT
ARBUC     DELETE'FILE ← 15;*            DELETE FILE AND CONTENTS
INTUC     OPEN'FILE ← 16;*              OPEN FILE W/WO LOCKING
ARBUC     CLOSE'FILE ← 17;*             CLOSE AND UNLOCK FILE
ARBUC     READ'OFT ← 18;*               READ OFT
INTUC     READ'OFT'FIELD ← 19;*         READ OFT FIELD
ARBUC     SET'OFT'CL ← 20;*             SET OFT CONTROL LOCK
ARBUC     CONV'KEY ← 21;*               CONVERT DEFAULT ACCESS KEY

* EXTENDED SPS CALLS
INTUC     CREATE'SSP ← 30;*             CREATE SUBSIDIARY SUB-PROCESS
INTUC     CREATE'PSP ← 31;*             CREATE PARALLEL SUB-PROCESS
ARBUC     ATTACH ← 32;*                 ATTACH PI FILE TO SUB-PROCESS
ARBUC     DESTROY'SP ← 33;*             DESTROY SUB-PROCESSES
ARBUC     READ'SPT ← 34;*               READ SPT
INTUC     READ'SPT'FIELD ← 35;*         READ SPT FIELD
ARBUC     SET'SPT'FIELD ← 36;*          SET SPT FIELD
STUC      READ'SPNAME ← 37;*            READ SUB-PROC NAME
ARBUC     SET'SPNAME ← 38;*             SET SUB-PROC NAME
INTUC     SPNAME'SEARCH ←39;*           LOOK UP SP NAME

* CIOS MANIPULATION
INTUC     CREATE'CIOS ← 40;*            CREATE CONTROL I/O STREAM
INTUC     READ'CIOS'FIELD ← 41;*        READ CIOS FIELD
ARBUC     SET'CIOS'FIELD ← 42;*         SET (SOME) CIOS FIELDS
ARBUC     SET'CIOS'INPUT ← 43;*         SET UP FOR INPUT
ARBUC     SET'CIOS'OUTPUT ← 44;*        SET UP FOR OUTPUT

* CIOS INPUT/OUTPUT
ARBUC     PRINT'STRING ← 45;*           WRITE STRING ON CIOS
ARBUC     PRINT'CHAR ← 46;*             WRITE (= BUFFER) CHAR ON CIOS
ARBUC     START'OUTPUT ← 47;*           DUMP OUTPUT BUFFER
STUC      READ'LINE ← 48;*              READ NEXT INPUT LINE
*STUC      EDIT'LINE ← 49;*              EDIT CURRENT LINE
CHRUC     READ'CHAR ← 50;*              READ NEXT CHARACTER
ARBUC     BLOCK'OB'EMPTY ← 51;*         WAIT UNTIL OUT BUFFER IS EMPTY

* USER, ACCOUNT, AND GROUP PROFILES
STUC      READ'UP'ITEM ← 60;*           READ ITEM FROM USER PROFILE
STUC      READ'UP'NAMES ← 61;*          READ NAMES OF UP ITEMS
ARBUC     SET'UP'ITEM ← 62;*            SET (CREATE) VALUE OF UP ITEM
ARBUC     SET'UP'ACCESS ← 63;*          SET ACCESS TO UP ITEM
LNUC      FIND'MIB ← 64;*               CONVERT USER NAME/NUMBER TO MIB ADDR
ARBUC     CREATE'UP'ENTRY ← 65;*        CREATE USER/UP ENTRY
ARBUC     DELETE'UP'ENTRY ← 66;*        DELETE USER/UP ENTRY

* PROCESSES, AND PROCESS PROFILE
ARBUC     CREATE'PROCESS ← 70;*         CREATE/INITIALIZE PROCESS
STUC      READ'PP'ITEM ← 71;*           READ ITEM FROM PROCESS PROFILE
STUC      READ'PP'NAMES ← 72;*          READ NAMES OF PP ITEMS

ARBUC     SET'PP'ITEM ← 73;*            SET (CREATE) VALUE OF PP ITEM
COMMON    DECDECS;
*
* SHORT DECLARATION MACROS FOR SPL
*

MACRO     INT ← DECLARE INTEGER;
MACRO     OCT ← DECLARE OCTAL;
MACRO     PTR ← DECLARE POINTER;
MACRO     CHR ← DECLARE CHARACTER;
MACRO     ST  ← DECLARE STRING;
MACRO     LN  ← DECLARE LONG;
MACRO     LNLN ← DECLARE LONGLONG;
MACRO     LB  ← DECLARE LABEL;

MACRO     OCTFL ← DECLARE OCTAL FIELD;
MACRO     INTFL ← DECLARE INTEGER SIGNED FIELD;
MACRO     PTRFL ← DECLARE POINTER FIELD;
MACRO     CHRFL ← DECLARE CHARACTER FIELD;
MACRO     STFL  ← DECLARE STRING FIELD;
MACRO     LNFL  ← DECLARE LONG FIELD;
MACRO     ARYFL ← DECLARE ARRAY FIELD;
MACRO     FNFL  ← DECLARE FUNCTION FIELD;

MACRO     INTARY ← DECLARE INTEGER ARRAY;
MACRO     OCTARY ← DECLARE OCTAL ARRAY;
MACRO     PTRARY ← DECLARE POINTER ARRAY;
MACRO     CHRARY ← DECLARE CHARACTER ARRAY;
MACRO     STARY  ← DECLARE STRING ARRAY;
MACRO     LNARY  ← DECLARE LONG ARRAY;
MACRO     LBARY  ← DECLARE LABEL ARRAY;
MACRO     FLARY ← DECLARE FIELD ARRAY;
MACRO     FNARY ← DECLARE FUNCTION ARRAY;

MACRO     INTARY1 ← DECLARE INTEGER ARRAYONE;
MACRO     PTRARY1 ← DECLARE POINTER ARRAYONE;

MACRO     INTFN ← DECLARE INTEGER FUNCTION;

MACRO     ARBENT ← UNKNOWN ENTRY;
MACRO     INTENT ← INTEGER ENTRY;
MACRO     OCTENT ← POINTER ENTRY;
MACRO     PTRENT ← POINTER ENTRY;
MACRO     CHRENT ← CHARACTER ENTRY;
MACRO     STENT ← STRING ENTRY;
MACRO     LNENT ← LONG ENTRY;
MACRO     LBENT ← LABEL ENTRY;
MACRO     ARYENT ← ARRAY ENTRY;

MACRO     ARBEXT ← DECLARE UNKNOWN EXTERNAL;
MACRO     INTEXT ← DECLARE INTEGER EXTERNAL;
MACRO     OCTEXT ← DECLARE OCTAL EXTERNAL;
MACRO     PTREXT ← DECLARE POINTER EXTERNAL;
MACRO     CHREXT ← DECLARE CHARACTER EXTERNAL;
MACRO     STEXT ← DECLARE STRING EXTERNAL;
MACRO     LNEXT ← DECLARE LONG EXTERNAL;
MACRO     LBEXT ← DECLARE LABEL EXTERNAL;
MACRO     ARYEXT ← DECLARE ARRAY EXTERNAL;

MACRO     C'(X)←;* KLUDGE FOR INTERNAL COMMENTS

MACRO     LTABLE(F) ← F$FLDWDSP+1;
INTFL     FLDWDSP(0: 13,23);

* LENGTHS OF NAMES
INT       LMN ← 4, LTY ← 1, LFN ← LMN+LTY;
INT       NBY ← 4, LNCH ← 24/NBY, NMNCH ← LMN*NBY,
          NTYCH ← LTY*NBY, NFNCH ← LFN*NBY, NCMCH ← 90;

COMMON    SYS'COMMON; INCLUDE SYSCALLS;

*
* MCALLS, UCALLS, & GLOBAL CELLS
*

DECLARE INTEGER  QUIT'FLAG;* GLOBAL QUIT FLAG
DECLARE INTEGER   QUIT'FCN'FLAG;* GLOBAL QUIT FUNCTION FLAG
DECLARE INTEGER   ERMSNO;* SYSTEM ERROR NUMBER
DECLARE CHARACTER   ERCODE;* SYSTEM ERROR CODE

COMMON    MACHINE'DECS; INCLUDE DECDECS;
*
* DECLARATIONS FOR MACHINE-DEPENDENT PROGRAMMING
*

* LOW-G DEFINITIONS
PTR       STACK'PTR = G'[2], STACK'LIM = G'[3],
             RTRAP'PARAM = G'[5], RTRAP'LOC = G'[4];

* FIELDS IN BLL DESCRIPTOR
PTRFL     BRDPC(0: 6,23), BRDLR(1: 6,23);

* STATE DEFINTIONS
INT       PSTLOC ← 0, ASTLOC ← 1, BSTLOC ← 2, CSTLOC ← 3, DSTLOC ← 4,
          XSTLOC ← 5, LSTLOC ← 6, GSTLOC ← 7, ESTLOC ← 8, SSTLOC ← 9,
          LSTATE ← 10;

* FIELDS FOR TRAP DEFINITIONS
PTRFL     ADDR(0: 6,23); OCTFL SP'TNO(-2), SP'TPAR(-1),
          BLL'CLASS(0: 3,5), UTSE'CLASS(0: 0,1),
          UTSE'SPTNO(0: 1,5), UTSE'RTNO(0: 2,5);

COMMON    COMDECS; INCLUDE DECDECS, SYS'COMMON;
*
* COMMON DECLARATIONS FOR CODING
*

* GENERALLY USEFUL MACROS

MACRO     NAMSET(S,L,A,B) ← SETUP(S,L,A,B) & S$WP ← S$EP;
MACRO     EMPTY(S) ← LNGDES(S$RP, S$WP) <= 0;*** WP=RP OR WP=BP?
MACRO     REPEAT ← WHILE 1 DO;
MACRO     ENDRPT ← ENDFOR;
MACRO     FDISP(F) ← RUNTIME'FAILURE() IF F$FLDSTB # 0 OR
             F$FLDSIZE # 24 ELSE F$FLDWDSP;
OCTFL     FLDSTB(0: 8,12), FLDSIZE(0: 3,7);

* ERROR MACROS
MACRO     NC'PUNT ← RUNTIME'FAILURE();* FOR NORMAL CALLS (EXPRESSIONS)
MACRO     LF'PUNT ← VALUE NC'PUNT;* FOR LIBRARY FUNCTIONS
MACRO     SF'PUNT ← LF'PUNT: ERCODE, ERMSNO;* FOR SYSTEM CALLS

* QUIT ACTION MACROS
MACRO     QUIT'PUNT(L) ← VALUE GOTO L IF ERCODE = 'QIT' ELSE
             RUNTIME'FAILURE(): ERCODE, ERMSNO;
MACRO     QUIT'PUNTX(L, X) ← VALUE GOTO L IF ERCODE = 'QIT' ELSE
             RUNTIME'FAILURE(): X, ERCODE, ERMSNO;

* PARAMETRIC CHARACTER DEFINITIONS
CHR       SCHERALD ← '>' C'(/* SUB-COMMAND HERALD */),
          BELCH ← 303B C'(/* BELL */), NULCH ← 300B C'(/* NULL */),
          NLCH ← 307B C'(/* NEW LINE */),
          LFCH ← 310B C'(/* LINE FEED */),
          MBCH ← 200B C'(/* ZERO MULTIPLE BLANKS */),
          SQTCH ← '&'' C'(/* SINGLE QUOTE */),
          DQTCH ← '"' C'(/* DOUBLE QUOTE */),
          SEPCH ← '-' C'(/* SEPARATOR */);

* STRING POINTER FIELDS
OCTFL     BP(0) C'(/* BEGINNING */), RP(1) C'(/* READER */),
          WP(2) C'(/* WRITER */), EP(3) C'(/* END */);
* CHARACTER FIELDS
CHRFL     CH0(0: 0,7), CH1(0: 8,15), CH2(0: 16,23);
* BEAD LENGTH FIELD
PTRFL     LENGF(-1: 6, 23);

* FIELDS IN UTILITY FILE NAME
LNFL      UFNUN(0) C'(/* USER NUMBER/DISK ADDRESS */);
OCTFL     UFNEN(2) C'(/* OBJECT ENTRY-NUMBER */),
          UFNFN(3) C'(/* FILE NAME */), UFNMN(3) C'(/* MAIN NAME */),
          UFNTY(3+LMN) C'(/* TYPE WORD */);

* FIELDS FOR UNO/DKA
OCTFL     UNDKUN(0),
          UNDKDK(1);

INT       LUFN ← LTABLE(UFNTY);* LENGTH OF UTILITY FILE:NAME

INT       CB'PMT ← 1;* PMT ADDRESS OF CONTEXT BLOCK

* DECLARATIONS OF COMMON FUNCTIONS

* SPL RUNTIME FUNCTIONS
*ARBEXT    SCOPY, APPEND, CNS, RUNTIME'FAILURE;
LBEXT     LABEL'KLUDGE; ARYEXT LBARY'KLUDGE;*, AR'DESC;
PTREXT    SBASE; INTEXT ARRAYUB, ARRAYLB;* STEXT ST'DESC;
LNEXT     LONG'ADD, LONG'SUB; INTEXT LONG'LE, LONG'LT;

* STORAGE ALLOCATOR
PTREXT    STKMAKE;*, MAKE, SETZONE;
*ARBEXT    STORINIT, SELZONE, EXTZONE, FREE, FREEZONE;

COMMON    UQNDECS; INCLUDE DECDECS;

* UNIQUE NAME FIELDS
OCTFL     UQNTY(0: 0,1), UQNPMB(0: 0,0), UQNLFB(0: 1,1),
          UQNOWN(0: 2,17), UQNHFN(0: 18,23);
OCTFL     UQNLFN(1: 0,12), UQNLPN(1: 13,23),
          UQNSFN(1: 0,15), UQNSPN(1: 16,23);

COMMON    BFSDECS; INCLUDE UQNDECS;

* OBJECT TYPE-CODES
INT       SIBSFCD ← 0, SIBLFCD ← 1, SIBPRCD ← 2, SIBAKCD ← 3,
          SIBRSCD ← 4, SIBOWCD ← 5, SIBFRCD ← 6,
          SIBSCCD ← 14, SIBLKCD ← 15;

* ACCESS KEY FIELDS
OCTFL     ACK0(0), ACK1(1:0,7), ACKUN(1:8,23);
INT       NORM'FIL'AC ← 0357B;* P(NO) F(RW) O(OW) - NORMAL ACCESS

COMMON    OFTDECS; INCLUDE BFSDECS;

* FIELDS IN OFT
OCTFL     OFTUB(0: 0,0), OFTRB(0: 1,1), OFTWB(0: 2,2), OFTXB(0: 3,3),
          OFTOB(0: 4,4), OFTMIX(0: 6,12),
          OFTAL(0: 15,23);* BETTER CHECK THIS WITH REVISION

OCTFL     OFTCL(1: 15,23),
          OFTOT(2: 0,3), OFTPIB(2: 8,15), OFTPMIB(2: 16,23);
LNFL      OFTUN(3);

INT       NOFT ← 16, LOFT ← LTABLE(OFTUN)+1;


COMMON    SIBDECS; INCLUDE BFSDECS;
*
* DECLARATIONS FOR SIB
*

* FIELDS IN SIB NAME (SIBN)
OCTFL     SIBNOT(0: 1,4),
          SIBNLN(0: 10,23),
          SIBNAA(1: 1,4), SIBNEN(1: 10,23),
          SIBNMN(2), SIBNFN(2);
OCTFL     SIBNTY(SIBNMN$FLDWDSP+LMN),
          SIBNLL(SIBNTY$FLDWDSP+1: 4,11),
          SIBNAC(SIBNLL$FLDWDSP: 12,23);
OCTFL          SIBNPA(SIBNAC$FLDWDSP: 12,15),
               SIBNFA(SIBNAC$FLDWDSP: 16,19),
               SIBNOA(SIBNAC$FLDWDSP: 20,23);

INT       LSIBN ← LTABLE(SIBNOA);* LENGTH OF SIBN TABLE

* FIELDS IN SIB VALUE (SIBV)
OCTFL     SIBVOT(0: 1,4),
          SIBVLN(0: 10,23),
          SIBVAA(1: 1,4), SIBVEN(1: 10,23);
LNFL      SIBFLUN(2);
OCTFL     SIBFLLEN(4),
          SIBFLWD(5),
          SIBFLRD(6);

LNFL      SIBLKUN(2);
OCTFL     SIBLKEN(4),
          SIBLKMN(5),
          SIBLKTY(5+LMN);

INT       LSIBFL ← LTABLE(SIBFLRD), LSIBLK ← LTABLE(SIBLKTY),
          LSIBV ← (LSIBFL IF LSIBFL > LSIBLK ELSE LSIBLK);
INT       MLSIB ← (LSIBV IF LSIBV > LSIBN ELSE LSIBN);

COMMON    PMTDECS; INCLUDE UQNDECS;

* FIELDS FOR PMT ENTRY
LNFL      PMTUN(0);
OCTFL     PMTFL(2: 0,0), PMTDKA(2: 2,23),
          PMTRO(3: 0,0), PMTAL(3: 3,11), PMTCL(3: 15,23);

INT       NPMT ← 128;* NUMBER OF PMT ENTRIES
INT       LPMT ← 5;* SIZE OF PMT ENTRY

* FIELDS IN APT
OCTFL    APTUH(0:0,7),
         APTPGL(0:8,11),
         APTDWS(0:12,12),
         APTCWS(0:13,13),
         APTKEEP(0:14,14),
         APTLOCK(0:15,15),
         APTPMTX(0:16,23);


COMMON    SPTDECS; INCLUDE DECDECS;

* FIELDS IN SPCS
OCTFL     SPCSNIS(0: 0,0), SPCSNIC(0: 1,1),
          SPCSCSP(0: 2,5), SPCSPR(0: 6,23),
          SPCS940M(1: 0,0), SPCSR0SP(1: 2,5), SPCSLR(1: 6,23),
          SPCSR1SP(2: 2,5), SPCSGR(2: 6,23);
LNFL      SPCSIT(3);
INT       LSPCS ← LTABLE(SPCSIT) + 1;

INT       NSPT ← 8;

COMMON    ATTACHDECS; INCLUDE DECDECS;
*
* DEFINITION OF ATTACH (PI) FILE HEADER
*
OCTFL     ATFMT(0), ATNP(1), ATMAP(3), ATMNM(38),
             ATCUF(43), ATEP(44), ATEG(45);
OCTFL     BYTEC(0: 12,13), BYTEP(0: 16,23);

INT       FMTCODE ← 0;* VALUE OF CURRENT FORMAT

COMMON    ICTDECS; INCLUDE DECDECS;

* FIELDS IN ICT
OCTFL     ICTSRC(0: 0,2) C'(/* SOURCE */),
          ICTACT(0: 3,5) C'(/* ACTION */),
          ICTSPEC(0: 6,10) C'(/* SUB-PROCESS/TRAP */),
          ICTBLK(0: 11,11) C'(/* BLOCKING */),
          ICTCL(0: 15,23) C'(/* CONTROL LOCK */);
LNFL      ICTTM(1);* REAL/COMPUTE TIME VALUE

INT       NICT ← 24, LICT ← LTABLE(ICTTM) + 1;

* VALUES FOR SOURCE-ACTION-BLOCK PARAMETER OF SET'ICT
MACRO     ICT'SAB(S, A, B) ← S @ ICTSRC V' A @ ICTACT V' B @ ICTBLK;
INT       ICTNULCD ← ICT'SAB(0, 0, 0) C'(/* NULL */),
          ICTBLKCD ← ICT'SAB(1, 0, 1) C'(/* BLOCKING */),
          ICTTRPCD ← ICT'SAB(1, 2, 1) C'(/* TRAP */),
          ICTRTICD ← ICT'SAB(2, 1, 1) C'(/* REAL-TIME INTERRUPR */);

PROGRAM LABEL'KLUDGE; INCLUDE DECDECS;
*
* CONVERT SOURCE RELATIVE LABEL TO ABSOLUTE
*
LB     L; LBARY A;

LBENT  LABEL'KLUDGE(L); RETURN L;

ARYENT LBARY'KLUDGE(A); RETURN A;

PROGRAM   LONG'COMPARE; INCLUDE DECDECS;
*
* COMPARE LONG VALUES
*
PTR       P, Q; INT N;
OCTFL W0(0);

INTENT    LONG'COMPARE(INTEGER @P, INTEGER @Q, N);

          RETURN 1 IF P[N].W0 # Q[N].W0 FOR N ← N - 1 BY -1 TO 0;
          RETURN 0;

PROGRAM   SCOPY; INCLUDE COMDECS;
PTR       P; ST S, D; STFL A(0);

ARBENT    SCOPY(STRING @P, S), FRETURN;
          D ← P.A; P.RP ← D$WP ← D$RP ← D$BP; GOTO L;

ARBENT    APPEND(STRING @P, S), FRETURN;
          D ← P.A;

****      CHECK STRING CHARACTER SIZES FOR COMPATABILITY
L:
REPEAT;   WCI(GCI(S// VALUE P.WP ← D$WP & RETURN), D// FRETURN); ENDRPT;

PROGRAM   ST'DESC; INCLUDE COMDECS;
INT       N, S, O; PTR P; ST X;
STENT     ST'DESC(N, P, S, O);

          P ← MAKE(S *(N + 24 / S - 1)/ 24) IF P = 0;

IF S = 8 DO;
          .LDA 44B6;
ELSEIF S = 6 DO;
          .LDA 40B6;
ELSEIF S = 12 DO;
          .LDA 50B6;
ELSEIF S = 24 DO;
          .LDA 54B6;
ELSE DO;
          RUNTIME'FAILURE();
ENDIF;

          .IOR P; .XMA O; .LSHA 18; .IOR O; .LDX -1; .ASP; .CXA;
          .STA X$BP; .STA X$RP; .STA X$WP; .LDX N; .ASP; .STX X$EP;
          RETURN X;

PROGRAM   AR'DESC; INCLUDE COMDECS;
INT       N, S, O; PTR P;
ARYENT    AR'DESC(N, P, S, O);

          N ← N - 1 IF O = 0;
          RUNTIME'FAILURE() IF S > 63 OR S < 1 OR S > 3 AND N > 17777B OR
                      N > 377777B OR N < O OR O # 0 AND O # 1;

          P ← MAKE((N + 1 IF O = 0 ELSE N)* S) IF P = 0;

          .LDA S; .SUB 1; .ICP 3; .BGT R'[3]; .IOR 100B; .LSHA 6; .LSHA 11;
          .IOR N; .CPZ O; .BEQ R'[2]; .IOR 1B7; .IOR 6B7; .CAB;
          .LDA P; .IOR 4B6; .XAB; RETURN;

PROGRAM   CNS; INCLUDE COMDECS;
INT       N, F, R, T, I, D; PTR P; ST S, B(25); STFL A(0);

ARBENT    CNS(N, STRING @P, F, R), FRETURN;

          S ← P.A;
          FRETURN IF R < 2 OR R > 36;
          T ← (-N IF F >= 0 AND N < 0 ELSE N);
          B$RP ← B$WP ← B$EP; I ← 0;
LP:       .LDA T; .LSHD -23; .DIV R; .STA T; .STB D;
          WCD(D +('0' IF D < 10 ELSE 'A'-10), B);
          I ← I + 1; GOTO LP IF T # 0;
          WCD('-', B) & I ← I + 1 IF F >= 0 AND N < 0;
          F ← F A' 77B;
IF F = 0 DO;
          F ← I;
ELSEIF F <= I DO;
          B$RP ← INCDES(B$EP, -I);
ELSE DO;
          WCI(' ', S// FRETURN) FOR I ← I + 1 TO F;
ENDIF;
          WCI(D, S// FRETURN)
                FOR D ← GCI(B// VALUE P.WP ← S$WP & RETURN) WHILE 1;

PROGRAM   CSN; INCLUDE COMDECS;
PTR       P; INT R, F, D, N, FLB, FLP, PW; ST S; STFL A(0);

INTENT    CSN(STRING @P, R), FRETURN;

          FLB←FLP←0;

AGN:      S ← P.A; FRETURN IF R < 2 OR R > 36;

IF D ← GCI(S// FRETURN) = '-' OR D = '+' DO;
          F ← (1 IF D = '-' ELSE 0); D ← GCI(S// FRETURN);
ELSE DO;
          F ← 0;
ENDIF;

          D ← D - '0' IF D >= '0' AND D <= '9' ELSE
             D ← D - ('A'-10) IF D >= 'A' AND D <= 'Z' ELSE FRETURN;
          FRETURN IF D >= R; N ← D;

FOR D ← GCI(S// Y) REPEAT;
          D ← D - '0' IF D >= '0' AND D <= '9' ELSE
             D ← D - ('A'-10) IF D >= 'A' AND D <= 'Z' ELSE GOTO X;
          GOTO X IF D >= R; N ← N * R + D;
ENDRPT;

X:        IF R<=10 AND (D←D+'A'-10='B' OR D='D') DO;
           IF FLB DO;
            S$RP←INCDES(S$RP,1) IF FLP;
           ELSE DO;
            FLB←-1;
            PW←GCI(S//Z); PW←PW-'0' & FLP←-1 IF PW>='0' AND PW<='9'
                ELSE S$RP←INCDES(S$RP,-1);
Z:          R←8 & GOTO AGN IF D='B' AND R#8;
            R←10 & GOTO AGN IF D='D' AND R#10;
           ENDIF;
          ELSE DO;
           S$RP ← INCDES(S$RP, -1);
          ENDIF;
Y:       N←N*R FOR D←1 TO PW IF FLP;
          P.RP ← S$RP; RETURN (-N IF F ELSE N);

PROGRAM   SBASE; INCLUDE COMDECS;
*
* FIND BASE ADDRESS OF WORD-ORIGINED STRING DESCRIPTOR
*
ST        S;

PTRENT    SBASE(S);
          .LDA S$BP; .LDX 1; .ASP; .CXA;
          .CMZ 3B6; .BNE L; .ETR 777777B; RETURN;
L:        RUNTIME'FAILURE();

PROGRAM   ALENGTH; INCLUDE COMDECS;
*
* COMPUTE ARRAY BOUNDS
*
PTR       A; OCTFL ABW(0);
INTENT    ARRAYUB(A);
          .LDA A.ABW; .CMZ 2B6; .BNE R'[2]; .ETR 17777B;
          .ETR 377777B; RETURN;

INTENT    ARRAYLB(A);
          .LDA A.ABW; .ETR 1B7; .ASHA -21; RETURN;

PROGRAM   LONG'ARITH; INCLUDE COMDECS;
*
* LONG ARITHMETIC/RELATIONALS
*
LN        X, Y; OCTFL W0(0), W1(1);

LNENT     LONG'ADD(X, Y);* ADD
          .LDA X$W1, ADD Y$W1, CAB;
          .LDA X$W0, ADC Y$W0; RETURN;

LNENT     LONG'SUB(X, Y);* SUBTRACT
          .LDA X$W1, SUB Y$W1, CAB;
          .LDA X$W0, SUC Y$W0; RETURN;

INTENT    LONG'LE(X, Y);* LESS THAN OR EQUALS
          RETURN (1 IF LONG'SUB(X, Y)$W0 <= 0 ELSE 0);

INTENT    LONG'LT(X, Y);* LESS THAN
          RETURN (1 IF LONG'SUB(X, Y)$W0 < 0 ELSE 0);

COMMON ALLOC'DECS;

*
* SPL STORAGE ALLOCATOR
*

* THE BASIC STRUCTURE OF A STORAGE BLOCK IS AS IN THE OLD ALLOCATOR,
* I.E. THE WORD BEFORE THE 0'TH WORD OF A BLOCK CONTAINS THE LENGTH
* OF THE BLOCK (NUMBER OF INFORMATION WORDS +1), A FLAG IN BIT 0
* TO SAY THAT THE BLOCK IS FREE, AND A FLAG IN BIT 1 TO SAY THAT
* THE NEXT LOWER BLOCK IS FREE.
       DECLARE FIELD HIDDEN(-1), HSIZE(-1: 6,23), HFREE(-1: 0,0),
   HFTAG(-1: 1,1), HZTAG(-1: 2,2);
* FREE STORAGE COMES IN ZONES.  A ZONE CONSISTS OF A ZONE HEADER
* AND A CHAIN OF EXTENSIONS.  THE ZONE HEADER CONTAINS: THE BLOCK
* SIZE FOR THE ZONE (0 MEANS ALL SIZES ARE ALLOWABLE), THE OVERFLOW
* ROUTINE, THE EXTENSION LIST, AND THE FREE LIST ROVER.
       DECLARE FIELD FEXT(0), FLIST(2), FUEXT(3), FUNCTION FIELD FOVX(1);
       DECLARE PARAMETER FZHS←4;
* THE FEXT WORD IN EACH EXTENSION POINTS TO THE NEXT ONE.  THIS CHAIN,
* IS TERMINATED BY A -1.  THE FIRST TWO WORDS
* OF A FREE BLOCK ARE USED TO HOLD THE ADDRESS OF THE NEXT FREE
* BLOCK AND THE PREVIOUS FREE BLOCK.  THIS LIST IS CIRCULAR.
       DECLARE FIELD NBLK(0),PBLK(1);
* FOR FIXED-SIZE ZONES, THE ENTIRE FREE LIST AND THE HIDDEN WORDS
* ARE SET UP AT THE TIME AN EXTENSION IS CREATED.  FOR VARIABLE-SIZED
* ZONES, AN EXTENSION IS SET UP AS A SINGLE FREE BLOCK WHICH IS
* SUBDIVIDED AS THE NEED ARISES.  A FIRST-FIT STRATEGY WITH A "ROVER"
* IS USED FOR THE LATTER.  BLOCKS BELOW A MINIMUM SIZE WILL NOT BE CREATED.
       DECLARE PARAMETER MINSIZ←3;

DECLARE INFINITY'ZONE, CURRENT'ZONE;* ZONE VARIABLES FOR ALLOCATOR

PROGRAM   STKMAKE; INCLUDE ALLOC'DECS;
          FIXED;
*
* ALLOCATE LOCAL (STACKED) STORAGE
*
DECLARE   SP=G'[2], SL=G'[3], BLK, SIZE;

FUNCTION  STKMAKE(SIZE);

          RUNTIME'FAILURE() IF SP + SIZE >= SL;
          SP ← (BLK ← SP + 1) + SIZE;
          BLK.HIDDEN ← SIZE + 1;
          BSET(BLK, 0, SIZE);
          RETURN BLK;

PROGRAM MAKE; INCLUDE ALLOC'DECS;
*
* ASSIGN BLOCK OF SIZE (A) IN ZONE (B)
*
       DECLARE BLK,ROVER,RSIZE,EBLK,ROVEC;

FUNCTION MAKE(SIZE,ZONE);

       ZONE ← CURRENT'ZONE IF ZONE = 0;
       SIZE ← SIZE + 1;
       GOTO MAKEOV IF ZONE.FLIST<0;
* VARIABLE-SIZED ZONE
       ROVEC←ROVER←ZONE.FLIST;
MAKE1: RSIZE←ROVER.HSIZE;
       IF RSIZE<SIZE+MINSIZ AND RSIZE#SIZE DO;
               GOTO MAKE1 IF (ROVER←ROVER.NBLK)#ROVEC
   ELSE GOTO MAKEOV;
       ENDIF;
       EBLK←(BLK←ROVER)+ROVER.HSIZE;
       EBLK.HFTAG←0;
       IF ROVER.HSIZE=SIZE DO;
* EXACT FIT
               BLK.HFREE←0;
               ZONE.FLIST ← RFB(ROVER, ZONE);
       ELSE DO;
* SPLIT THE BLOCK
               BLK←EBLK-SIZE;
               BLK.HIDDEN ← 1 @ HFTAG + SIZE;
               BLK[-2]←-(ROVER.HSIZE←ROVER.HSIZE-SIZE);
       ENDIF;
* COMMON EXIT
       BSET(BLK, 0, SIZE - 1);
       RETURN BLK;

* OVERFLOW
MAKEOV: BLK ← (ZONE.FOVX)(SIZE-1,ZONE); RETURN BLK;

PROGRAM RFB; INCLUDE ALLOC'DECS;
FUNCTION RFB(RBLK, ZONE);
* SUBROUTINE TO REMOVE A BLOCK FROM THE FREELIST
       IF RBLK.NBLK=RBLK DO;
               RETURN ZONE.FLIST←-1;
       ELSE DO;
               RBLK.NBLK.PBLK←RBLK.PBLK;
               RETURN RBLK.PBLK.NBLK←RBLK.NBLK;
       ENDIF;

PROGRAM FREE; INCLUDE ALLOC'DECS;
*
* RELEASE BLOCK (A) TO ZONE (B)
*
       DECLARE EXPTR,EFB,PFB;

FUNCTION FREE(BLK,ZONE);
       EFB←BLK+BLK.HSIZE;
       ZONE ← CURRENT'ZONE IF ZONE = 0;
       BLK.HFREE←1;
* VARIABLE-SIZED ZONE
* CHECK FOR MERGE WITH NEXT HIGHER BLOCK
       IF EFB.HFREE DO;
               BLK.HIDDEN←BLK.HIDDEN+EFB.HSIZE;
               RFB(EFB, ZONE);
               EFB ← BLK + BLK.HSIZE;
       ENDIF;
* CHECK FOR MERGE WITH NEXT LOWER BLOCK
       IF BLK.HFTAG DO;
               PFB←BLK+(BLK[-2] IF BLK[-2]<0 ELSE -3);
               PFB.HIDDEN←PFB.HIDDEN+BLK.HSIZE;
               RFB(BLK ← PFB, ZONE);
       ENDIF;
* CLEAN UP
       EFB.HFTAG←1;
       EFB[-2]←-BLK.HSIZE;
       FPB(BLK, ZONE);
       RETURN;

PROGRAM FPB; INCLUDE ALLOC'DECS;
* SUBROUTINE TO PUT A BLOCK ON THE FREELIST
       DECLARE ZFP,ZNBP;

FUNCTION FPB(BLK, ZONE);
       ZFP←ZONE.FLIST;
       IF ZFP<0 DO;
               ZONE.FLIST←BLK.NBLK←BLK.PBLK←BLK;
       ELSE DO;
               ZNBP←ZFP.NBLK;
               ZFP.NBLK←ZNBP.PBLK←BLK;
               BLK.NBLK←ZNBP;
               BLK.PBLK←ZFP;
       ENDIF;
       RETURN;

PROGRAM SELZONE; INCLUDE ALLOC'DECS;

FUNCTION SELZONE(ZONE);
      CURRENT'ZONE ← ZONE; RETURN;

PROGRAM STORINIT; INCLUDE ALLOC'DECS;
*
* SET UP ZONES
*

FUNCTION STORINIT(ZONE, SIZE), FRETURN;
      (ZONE ← ZONE + 1).HIDDEN ← SIZE;
      SETZONE(ZONE// FRETURN);
      CURRENT'ZONE ← INFINITY'ZONE ← ZONE; RETURN;

PROGRAM SETZONE; INCLUDE ALLOC'DECS;
*
* INITIALIZE ZONE
*
       DECLARE FAREA, FUNCTION DUMBFUCN ← OFLOTRAP;

FUNCTION SETZONE(ZONE), FRETURN;
       FRETURN IF ZONE.HSIZE<FZHS+MINSIZ+4;
       ZONE.HZTAG ← 1;
       ZONE.FOVX ← DUMBFUCN;
       ZONE.FLIST ← -1;
       ZONE.FUEXT ← 0;
       FAREA ← ZONE + (FZHS+1);
       FAREA.HIDDEN←ZONE.HSIZE-(FZHS+1);
       EXTZONE(FAREA, ZONE// VALUE RUNTIME'FAILURE());
       ZONE.FEXT ← -1; RETURN ZONE;

PROGRAM EXTZONE; INCLUDE ALLOC'DECS;
*
* ADD EXTENSION (B) TO ZONE (A)
*
       DECLARE EEXT,EXB;

FUNCTION EXTZONE(EXT, ZONE), FRETURN;
       FRETURN IF EXT.HSIZE<MINSIZ+2;
       EEXT←EXT+EXT.HSIZE;
       EXT.FEXT←ZONE.FEXT;
       ZONE.FEXT←EXT;
       EXB←EXT+2;
       EXB.HIDDEN ← (1@HFREE-3) + EXT.HSIZE;
       (EEXT - 1).HIDDEN ← 1 @ HFTAG;
       FPB(EXB, ZONE);
       RETURN;

PROGRAM FREEZONE; INCLUDE ALLOC'DECS;
*
* DELETE ZONE (A)
*
       DECLARE ZEPTR;

FUNCTION FREEZONE(ZF,ZF1);
       SELZONE(INFINITY'ZONE) IF ZF = CURRENT'ZONE;
FZONE1:ZEPTR←ZF.FEXT; FREE(ZF,ZF1);
       GOTO FZONE1 IF (ZF←ZEPTR)>=0;
       RETURN;


COMMON    USERDECS; INCLUDE COMDECS;
*
* DECLARATIONS FOR USER PROGRAMS
*
ST        OL(NCMCH);* OUTPUT BUFFER FOR USER CONSOLE OUTPUT
LB        TRAP'LABEL;* GO HERE AFTER TRAP
PTR       INITIAL'SP ← 3200B, NORMAL'SL ← 3777B;
       PTR STORAGE'AREA←400B;

* OUTPUT MACROS
MACRO     IOUT() ← SETS(OL, 0,0);
MACRO     PTCH(C) ← WCI(C, OL);
MACRO     PTST(S) ← APPEND(OL, S// LF'PUNT);
MACRO     PTNO(N, F, R) ← CNS(N, OL, F, R// LF'PUNT);
MACRO     PTDN(N) ← PTNO(N, 4B7, 10);
MACRO     PTON(N) ← PTNO(N, 4B7, 8);
MACRO     PTNL() ← WCI(NLCH, OL);
MACRO     PTIS(S) ← SCOPY(OL, S// LF'PUNT);


COMMON    TRAP'DECS; INCLUDE MACHINE'DECS;
       INCLUDE MACHINE'DECS;

* TRAP VARIABLES
INT       TRAP'FLAG;* FLAG INDICATING WHETHER A TRAP IS BEING PROCESSED
PTR       INSTR'LOC;* PTR TO INSTR FOLLOWING ONE CAUSING ABE TRAP
INT       SAVEL;* SAVE L-REG WHILE DOING EAC IN ABE'TRAP
INT       GSAVER; INTARY GSTATE[LSTATE], SP'GSTATE[LSTATE];* GLOBAL TRAP STATES
INT       SP'LEV;* SUBPROCESS LEVEL ON ENTRY

PROGRAM   USER'ENTRIES; INCLUDE USERDECS, TRAP'DECS;
*
* ENTRY POINTS
*
          FIXED;

MACRO     SAVE'STATE(X) ← .STX X[XSTLOC], EAX X[0], STORS, MIN TRAP'FLAG;

* COME HERE AFTER TRAP MESSAGE
T'L:      JUMP'RETURN(
           READ'SPS'PARAM('CSL'//SF'PUNT)-SP'LEV-1//T'R:ERCODE,ERMSNO);
T'R:      SP'RETURN(//SF'PUNT);

* INITIAL AND 'CONTINUE' SUBPROCESS ENTRIES
ARBENT    XXXXXX(), SP'ENTRY ← 2;
ARBENT    XXXXXY(), SP'ENTRY ← 3;

          .LDA INITIAL'SP, XLA;
          TRAP'LABEL ← T'L; TRAP'FLAG ← QUIT'FCN'FLAG ← QUIT'FLAG ← 0;
          STACK'PTR ← INITIAL'SP; STACK'LIM ← NORMAL'SL;
       STORINIT(STORAGE'AREA,INITIAL'SP-STORAGE'AREA-1//LF'PUNT);
          SP'LEV←READ'SPS'PARAM('CSL'//SF'PUNT);
          SET'SPT'FIELD(-1,'TM',READ'SPT'FIELD(-1,'TCM'//SF'PUNT)
                                                        //SF'PUNT);
          RUN'USER(); RUNTIME'FAILURE();

* SP'TRAPS COME HERE
ARBENT    XXXSPT(), SP'ENTRY ← 0; SAVE'STATE(SP'GSTATE); STRAP();


* RING TRAPS
ARBENT    XXXABE(), TRAP'ENTRY ← 1; SAVE'STATE(GSTATE); ABE'TRAP();
ARBENT    XXXFLO(), TRAP'ENTRY ← 2; SAVE'STATE(GSTATE); RTRAP(2);
ARBENT    XXXFLU(), TRAP'ENTRY ← 3; SAVE'STATE(GSTATE); RTRAP(3);
ARBENT    XXXRO(),  TRAP'ENTRY ← 4; SAVE'STATE(GSTATE); RTRAP(4);
ARBENT    XXXIAT(), TRAP'ENTRY ← 5; SAVE'STATE(GSTATE); RTRAP(5);
ARBENT    XXXUFN(), TRAP'ENTRY ← 6; SAVE'STATE(GSTATE); RTRAP(6);
ARBENT    XXXFXO(), TRAP'ENTRY ← 7; SAVE'STATE(GSTATE); RTRAP(7);
ARBENT    XXXDIZ(), TRAP'ENTRY ← 8; SAVE'STATE(GSTATE); RTRAP(8);

* STACK OVERFLOW - WATCH OUT
ARBENT    XXXSOV(), TRAP'ENTRY ← 9; STKTRAP();

PROGRAM   PUNT; INCLUDE USERDECS, TRAP'DECS;
          INCLUDE SPTDECS;
*
* MAIN TRAP/PUNT PROCESSING ROUTINE
*
INT       N, P, Q, SR;
INT       LSPCS←5;
LB        R = L'[0];
INTARY    SPCA[LSPCS], STATE[LSTATE];
PTR       SA;* POINTER TO STATE[0]
MACRO     IS'TSB'INSTR(X) ← ((X) A' 07740000B=04600000B);
OCTFL     UTNO(0: 0, 5),SPCSLR(1:6,23);
LB        FIELD LBW0(0);

MACRO     SAVE'STATE(X) ← BCOPY(SA ← @STATE[0], @X[0], LSTATE) &
               (TRAP'PUNT() IF TRAP'FLAG#1);
MACRO     SPT'PUNT ← SPTPUNT: ERCODE, ERMSNO;

*
* ENTRY FOR RING TRAPS
*
ARBENT    RTRAP(N);
          SAVE'STATE(GSTATE);
RTPUNT:   RPUNTMSG(N, RTRAP'LOC); GOTO PUNTCOM;

*
* SPECIAL ENTRY FOR 'ABE' TRAP -
* CHECK IF REFERENCE IS FOLLOWED BY TSB OPCODE
*
ARBENT    ABE'TRAP();
          SAVE'STATE(GSTATE);
          INSTR'LOC ← RTRAP'LOC+1;
          IF IS'TSB'INSTR($INSTR'LOC) DO;
             .LDX SA[XSTLOC], LDA SA[LSTLOC], XLA, STA SAVEL, EAC $INSTR'LOC;
             .LDA SAVEL, XLA, STX Q;
             R$BRDPC ← Q;
             SA[PSTLOC] ← @ABE'EXIT;
             R$BRDLR ← SA[LSTLOC];
             SA[LSTLOC] ← @R;
          TRAP'FLAG ← 0;
             .LDX SA, LOADS;
ABE'EXIT:    RETURN;
          ENDIF;
          N ← 1; GOTO RTPUNT;

*
* ENTRY FOR SP TRAPS
*
ARBENT    STRAP();
          SAVE'STATE(SP'GSTATE); ALLOW'INTS(); N ← @R.SP'TNO; Q ← @R.SP'TPAR;
          READ'SPCS(0, SPCA// SPT'PUNT); R$BRDLR ← SPCA[0]$SPCSLR;
          P←SPCA[0]$SPCSPR;
          GOTO SPTPUNT IF N#23;

* QUIT
QUIT:     QUIT'FLAG ← 1;
          QUIT'FCN() IF QUIT'FCN'FLAG;
          SA[LSTLOC] ← @R;
          SA[PSTLOC] ← @QUITX; .LDX SA, LOADS;
***       ARM TRAP
QUITX:    SP'RETURN(// SPT'PUNT);


* FREE STORAGE OVERFLOW
ARBENT    OFLOTRAP(ERCODE, ERMSNO);
          R ←R$BRDLR.LBW0; N ← 24; GOTO RTF;

* UNEXPECTED RUNTIME FAILURE
ARBENT    RUNTIME'FAILURE(); N ← 25;
RTF:      P ← R$BRDPC; Q ← 0;

SPTPUNT:  SPUNTMSG(N, P, Q);
PUNTCOM:  TRAP'FLAG ← 0;
          GOTO TRAP'LABEL;

* TRAP DURING STATE-SAVING
ARBENT    TRAP'PUNT();
          SPUNTMSG(26, R$BRDPC, 0); GOTO PUNTCOM;


PROGRAM   STKOV'TRAP; INCLUDE USERDECS;
*
* STACK OVERFLOW TRAP PROCESSING
*
          FIXED;

ARBENT    STKTRAP();
STKWAIT:  GOTO TRAP'LABEL;


PROGRAM   UTRAP'MSG; INCLUDE USERDECS, MACHINE'DECS;
*
* PRINT USER TRAP MESSAGE
*?*  THIS ROUTINE SHOULD FRETURN, RATHER THAN PUNTING (COULD CAUSE
*?*       PUNT LOOP AND STACK OVERFLOW)
*
          ST MSG(60), CM; INT N, P, Q, T;
CHRARY    RN[10] ← (6'RT0?', 6'ABE', 6'FLO', 6'FLU', 6'ROIA',
             6'IAT', 6'UFN', 6'FXO', 6'DIZ', 6'SOV');
CHRARY    SN[27] ← (6'MACC', 6'PRO', 6'PNIM', 6'PNIC', 6'PI',
             6'TI', 6'BLL', 6'ILIM', 6'PNOD', 6'DWSO', 6'CWSO',
             6'NEP', 6'DMRD', 6'NILE', 6'SPCO', 6'PMTO', 6'DKSE',
             6'?17?', 6'?18?', 6'?19?', 6'?20?', 6'?21?', 6'UTSE',
             6'QUIT', 6'FSOV', 6'PUNT', 6'TRAP');

ARBENT    RPUNTMSG(N, P); N ← -(N + 1);
ARBENT    SPUNTMSG(N, P, Q);


          SETS(MSG, 0, 0); WCI(NLCH, MSG);
          APPEND(MSG, "USER TRAP '"// LF'PUNT);

COM:
IF N = 22 DO;* 'UTSE' ERROR
          APPEND(MSG, "UTSE - "// LF'PUNT);
          N ← (Q$UTSE'SPTNO IF T ← Q$UTSE'CLASS > 1 ELSE
             6 IF T = 1 ELSE -(Q$UTSE'RTNO+1));
ENDIF;

IF N = 6 DO;* BLL ERROR
          PUNT'WWD(MSG, 6'BLL-'); WCI(Q$BLL'CLASS V' '0', MSG);
ELSE DO;
          PUNT'WWD(MSG, SN[N] IF N >= 0 ELSE RN[-(N+1)]);
ENDIF;
          APPEND(MSG, "' AT P: "// LF'PUNT);
          CNS(P, MSG, 4B7, 8// LF'PUNT); WCI('B', MSG);

          WCI(NLCH, MSG);
QT'P:     PRINT'STRING(-1, MSG, 0// QUIT'PUNTX(QT'P, MSG));
          RETURN;

PROGRAM   PUNT'WWD; INCLUDE COMDECS;
*
* APPEND 4 CHARACTER NAME TO STRING
*
PTR       P; CHR M, C; ST S; STFL A(0); CHRFL CH60(0: 0, 5);

ARBENT    PUNT'WWD(STRING @P, M); S ← P.A;

          (WCI(C, S) IF C # ' ') & M ← M LSH 6
             FOR C ← M$CH60 WHILE M # 6'    ';
          P.WP ← S$WP; RETURN;

PROGRAM   VARIOUS; INCLUDE USERDECS;

*
* CLEAR CIOS NPUT/OUTPUT &
* TYPE NEWLINE
*

ARBENT    CLEAR'CIOS();
LP:       QUIT'FLAG←0;
          SET'CIOS'FIELD(-1,'OCC',0//SF'PUNT);
          SET'CIOS'FIELD(-1,'ICC',0//SF'PUNT);
          IOUT();
          PRINT'CHAR(-1,NLCH,QUIT'FLAG//QUIT'PUNT(LP));
          RETURN;

*
* REMOVE QUIT CALL FROM SPCS AND UNWIND STACK
* BY NON-LOCAL GOTO
*

ARBENT    ZAP(LABEL ZLAB);
          DELETE'CALL(//SF'PUNT);
          GOTO ZLAB;
       COMMON SCOMTAB; INCLUDE DECDECS;* COMMAND NAME STRINGS

* MAIN TABLE
        STARY STBMA[5]←(6"FINISHED",6"MEMORY",6"OPEN-FILES",
        6"SUB-PROCESSES",6"HELP");

* MEMORY
        STARY STBMY[4]←(6"*",6"SUB-PROCESS",6"FILE",
        6"PRIVATE");

* SUB-PROCESS
        STARY STBSP[3]←(6"MAP",6"STATE",6"*");
       STARY HELP'STRING[10]←("&/<COMMAND>::=&/",
        "   MEMORY&/",
        "   MEMORY PRIVATE [ <SUB-PROCESS> ]&/",
        "   MEMORY SUB-PROCESS [ <SUB-PROCESS> ]&/",
        "   MEMORY FILE [ <FILE> [ <SUB-PROCESS> ] ]&/",
        "   OPEN-FILES [ <FILE> ]&/",
        "   SUB-PROCESSES [ <SUB-PROCESS> [ MAP / STATE ] ]&/",
        "   FINISHED&/",
        "&/<FILE>::= <FILE:NAME> / <OFT:INDEX> / *&/",
        "<SUB-PROCESS>::= <SUB-PROCESS:NAME> / <SPT:INDEX> / *&/");

       PROGRAM STATUS;
       INCLUDE USERDECS,SIBDECS,OFTDECS,PMTDECS,SPTDECS,SCOMTAB;
*
* STATUS COMMAND
*

        INT ENTNO,ERCODE,ERMSNO,COMFLG,SPMASK,T,KEY;
       INTARY WA[8],N[2];
       INT FPFLAG,PPFLAG;
       LNFL UFN(0);
       INTARY FILE'ARY[LUFN],VAL'ARY[LSIBV],PMT'ARY;PTR VAL'PTR,PMT'PTR;
       ST COMLINE(NCMCH),NAME'ST;
       LN UNIQFN;
       STARY SFN'ARY;LNARY UFN'ARY;


* MAIN TABLE
        LBARY ETBMA[5]←(FINISH'C,MEMORY'C,OP'FIL'C,S'PROC'C,HELP'C);

* MEMORY
        LBARY ETBMY[4]←(MEM'ALL,MEM'SP,MEM'FIL,MEM'PRI);



        ENTRY RUN'USER();
* START OF COMMAND PROCESSING
        QUIT'FLAG←0;SETS(COMLINE,0,0);
       GET'COM'LINE(COMLINE:COMLINE//SF'PUNT);
       NAME'ST←GET'PARAM(COMLINE);* SKIP COMMAND NAME 'STATUS'
       NAME'ST←GET'PARAM(COMLINE);
       GOTO COM'LP IF EMPTY(NAME'ST);COMFLG←0;

NEXT'COM:GOTO LABEL'KLUDGE(ETBMA[ABRV'LKP(NAME'ST,STBMA
        //PARERR:   ERCODE,ERMSNO)]);

COM'LP: COMFLG←-1;SETS(COMLINE,0,0);
       READ'LINE(-1,COMLINE,">",QUIT'FLAG:COMLINE
        //          QUIT'PUNTX(QT'XIT,COMLINE));
       GOTO COM'LP IF EMPTY(COMLINE);
       NAME'ST←GET'PARAM(COMLINE); GOTO NEXT'COM;

ERXIT:  IOUT();OL←ERRORMSG(ERMSNO,OL//SF'PUNT); GOTO LN'OUT;
PARERR:PARAM'ERR(NAME'ST);
       GOTO EXIT;

LN'OUT: WCI(NLCH,OL);PRINT'STRING(-1,OL,0//QUIT'PUNTX(QT'XIT,OL));
EXIT:  IF QUIT'FLAG DO;
QT'XIT:    SET'CIOS'FIELD(-1,'ICC',0//SF'PUNT);
           SET'CIOS'FIELD(-1,'OCC',0//SF'PUNT);
           QUIT'FLAG←0;
           IOUT(); PTNL();
           PTST("USER TRAP 'QUIT'"); PTNL();
           PRINT'STRING(-1,OL,0//QUIT'PUNTX(EXIT,OL));
       ENDIF;
       GOTO COM'LP IF COMFLG;
FINISH'C:SP'RETURN(//SF'PUNT);* FINISHED

*
* LIST PMT
*

MEMORY'C:NAME'ST←GET'PARAM(COMLINE);
       GOTO MEM'ALL IF EMPTY(NAME'ST);
       GOTO LABEL'KLUDGE(ETBMY[ABRV'LKP(NAME'ST,STBMY
        //PARERR:   ERCODE,ERMSNO)]);
MEM'ALL:SPMASK←DMASK();
       FPFLAG←PPFLAG←1;
       GOTO DOIT;

MEM'SP: SPMASK←DMASK()IF EMPTY(COMLINE)
        ELSE GETSPN(COMLINE:COMLINE,SPMASK//EXIT);
       FPFLAG←PPFLAG←1;
       GOTO DOIT;

MEM'FIL:NAME'ST←GET'PARAM(COMLINE);*GET FILE NAME
       SPMASK←DMASK() IF EMPTY(COMLINE)
        ELSE GETSPN(COMLINE:COMLINE,SPMASK//EXIT);
       T←GCI(NAME'ST//ALL);NAME'ST$RP←INCDES(NAME'ST$RP,-1);
       IF T='*' DO ;
ALL:       FPFLAG←-1;
       ELSEIF T<='9' AND T>='0' DO ;
           MREAD'OFT(CSN(NAME'ST,10//PARERR),WA//ERXIT:ERCODE,ERMSNO);
           GOTO PARERR IF WA[0]$OFTOT>9;
           FPFLAG←@WA[3];*POINTER TO UNIQUE NAME
       ELSE DO ;
           KEY←CONV'KEY(-1//SF'PUNT);
           NAME'SEARCH(NAME'ST,WA,0,'',KEY//SF'PUNT);
           READ'MIBOB'NAME(WA,0,N,KEY//SF'PUNT);
           IF N[0]$SIBNOT#SIBSFCD AND N[0]$SIBNOT#SIBLFCD DO ;
               IOUT();PTST(NAME'ST);PTST(" NOT A FILE NAME");
               GOTO LN'OUT;
           ENDIF ;
           READ'MIBOB'VALUE(WA,2,N,0,KEY//SF'PUNT);
           FPFLAG←@N[0];*POINTER TO UNIQUE NAME
       ENDIF ;
       PPFLAG←0;
       GOTO DOIT;

MEM'PRI:SPMASK←DMASK() IF EMPTY(COMLINE)
        ELSE GETSPN(COMLINE:COMLINE,SPMASK//EXIT);
       FPFLAG←0;
       PPFLAG←1;

DOIT:   PMT(SPMASK,PPFLAG,FPFLAG//EXIT);
       GOTO EXIT;

*
* LIST SPT
*
S'PROC'C:SPMASK←DMASK() IF EMPTY(COMLINE) ELSE
        GETSPN(COMLINE:COMLINE,SPMASK//EXIT);
       NAME'ST←GET'PARAM(COMLINE);
       ENTNO←(2 IF EMPTY(NAME'ST) ELSE
        ABRV'LKP(NAME'ST,STBSP//PARERR:ERCODE,ERMSNO));
       LISTSPT(SPMASK,ENTNO+1//EXIT); GOTO EXIT;

*
* LIST OFT
*
OP'FIL'C:IOUT();
       PTCH(SQTCH);PTST(NAME'ST);PTCH(SQTCH);
       PTST(" NOT IMPLIMENTED YET"); GOTO LN'OUT;
*
* HELP
*
HELP'C: PRINT'STRING(-1,HELP'STRING[T],0
        //QUIT'PUNTX(QT'XIT,COMLINE))FOR T←0 TO 9;
       GOTO EXIT;

       PROGRAM PARAM'ERR;
       INCLUDE USERDECS;

        INT ERCODE,ERMSNO;

        ENTRY PARAM'ERR( STRING STT);
       IOUT();PTCH(SQTCH);PTST(STT);PTCH(SQTCH);
       PTST(" IS UNRECOGNIZABLE");PTNL();
       PRINT'STRING(-1,OL,0//QUIT'PUNTX(EXIT,OL));
EXIT:  RETURN ;

       PROGRAM PMT;
       INCLUDE USERDECS,PMTDECS;

        INT ERCODE,ERMSNO;

        PTR PMTPTR,TAIL,J,JJ,JJJ;
       INTARY PMTENTRY[LPMT+1];*PMT AND APT STORAGE
       INT I,FPFLAG,PPFLAG,PPPFLAG,COUNT,SPMASK;
       INTFL PMTXLINK(3:0,23),NEXT(0);
       LNFL UFN(1);
       LN PLONG;
       ST NAME'ST(21:6);
       OCTFL W0(0),W1(1),W2(2);


        ENTRY PMT(SPMASK,PPFLAG,FPFLAG),FRETURN;
       IOUT();
       IF PPFLAG DO;
              PTST("(R<PMT>%:<SP-LIST>) WHERE R=READ-ONLY,");
              PTST(" %=DWS, *=NO ACC, +=NO CTRL"); PTNL();
               PRINT'STRING(-1,OL,0//QUIT'PUNTX(QT'XIT,OL));
           IOUT();
           PTST("PRIVATE ");
       ENDIF ;
       TAIL←COUNT←PPPFLAG←0;
       PMTPTR←@PMTENTRY[0];
       FOR I←1 TO NPMT DO ;
           GOTO QT'XIT IF QUIT'FLAG;
           READ'PMT(I,PMTENTRY//SF'PUNT);
           IF (PMTPTR.PMTCL A' SPMASK) AND PMTENTRY[0]#0
            AND PMTENTRY[1]#0 DO ;
               IF FPFLAG AND PMTPTR.UQNTY<2 AND PMTPTR.UQNOWN#0 DO ;
                   PLONG←PMTPTR.PMTUN;
                   PLONG$UQNLPN←0 IF PLONG$UQNLFB
                    ELSE PLONG$UQNSPN←0;*REMOVE PAGE NOS.
                   IF FPFLAG>1 DO ;*ONLY ONE FILE WANTED
                   GOTO AGAIN IF PLONG$W0#FPFLAG.W0
                    OR PLONG$W1#FPFLAG.W1;
                   ENDIF ;
                   J←TAIL;
                   WHILE J#0 DO;
                       GOTO XIT IF J.W1=PLONG$W0 AND J.W2=PLONG$W1;
                       J←J.NEXT;
                   ENDFOR;
                   J←MAKE(4,0);J.NEXT←TAIL;J.PMTXLINK←0;
                   TAIL←J;J.UFN←PLONG;
                   COUNT←COUNT+1;
XIT:               JJ←MAKE(2,0);JJ[0]←(J.PMTXLINK);
                   JJ[1]←I;J.PMTXLINK←JJ;
               ELSEIF PPFLAG DO ;*PRINT NON-FILE PAGE
               LIST(PMTPTR,SPMASK,0,I//EXIT);
                   PPPFLAG←1;*PRIVATE PAGES FOUND FLAG
               ENDIF ;
           ENDIF ;
AGAIN:
        ENDFOR ;
       IF PPFLAG AND PPPFLAG=0 DO ;*NO PRIVATE PAGES FOUND
       PTST("- NONE");
       ENDIF ;
       IF LENGTH(OL)>0 DO ;
           PTNL();PRINT'STRING(-1,OL,0//QUIT'PUNTX(QT'XIT,OL));IOUT();
       ENDIF ;
       J←TAIL;
       WHILE J#0 DO ;*PRINT FILE PAGES FOUND
          FRETURN IF QUIT'FLAG;
           IF LENGTH(OL)>0 DO;
               PTNL();PRINT'STRING(-1,OL,0//QUIT'PUNTX(QT'XIT,OL));IOUT();
           ENDIF;
           SETS(NAME'ST,0,0);
           IOUT();PTST(FNAME(@J[1],NAME'ST//EXIT));PTCH(' ');
           JJ←J.PMTXLINK;
           WHILE JJ#0 DO ;
               READ'PMT(JJ.W1,PMTENTRY//SF'PUNT);
               LIST(PMTPTR,SPMASK,0,JJ.W1//EXIT);
               JJJ←JJ.NEXT;FREE(JJ);JJ←JJJ;
           ENDFOR ;
           JJJ←J.NEXT;
           FREE(J);J←JJJ;
       ENDFOR ;
       IF LENGTH(OL)>0 DO ;
           PTNL();PRINT'STRING(-1,OL,0//QUIT'PUNTX(QT'XIT,OL));
           IOUT();
       ENDIF ;
EXIT:  RETURN ;
QT'XIT:QUIT'FLAG←1;
       FRETURN;

       PROGRAM LISTSPT; INCLUDE USERDECS,SPTDECS;
*
* LIST THE SPT ACCORDING TO THE SP MASK, AND PRINT CODE
*
        INT SPMASK,CODE,SPNO,SPNO',KEY;
       INT PF,IX,J,PN,ERCODE,ERMSNO,X;
       ST NAME(NFNCH),ML(50),MAP(64:12);
       OCTFL MAPRO(0:12,12);

* NAME ARRAYS FOR TRAPS AND STATUS BITS
        INTARY TNAME[24]←(6'MACC',6'PRO',6'PNIM',6'PNIC',
        6'PI',6'TI',6'BLL',6'ILIM',
        6'PNOD',6'DWSO',6'CWSO',6'NEP',
        6'DMRD',6'NILE',6'SPCO',6'PMTO',
        6'DKSE',6'UD17',6'UD18',6'UD19',
        6'UD20',6'UD21',6'UTSE',6'QUIT');
       INTARY SNAME[24]←(6'PRP',6'SYS',6'UD02',6'940M',
        6'PNIC',6'PNIM',6'WFI',6'CWSO',
        6'DWSO',6'PNOD',6'MSP',6'SD',
        6'UD12',6'UD13',6'UD14',6'UD15',
        6'UD16',6'UD17',6'UD18',6'UD19',
        6'UD20',6'UD21',6'UD22',6'UD23');


        ENTRY LISTSPT(SPMASK,CODE),FRETURN;
       FOR SPNO←0 TO NSPT DO ;
           FRETURN IF QUIT'FLAG;
           IF (1 LSH SPNO) A' SPMASK#0
            AND READ'SPT'FIELD(SPNO,0//SF'PUNT)#0 DO;
               IOUT();
               PTNO(SPNO,2,10);PTCH(':');
               SETS(NAME,0,0);
               PTCH(' ');READ'SPNAME(SPNO,NAME:NAME//SF'PUNT);
               PTST("<NO-NAME>")IF EMPTY(NAME) ELSE PTST(NAME);
               PTNL();PRINT'STRING(-1,OL,0//QUIT'PUNTX(QT'XIT,OL));
               IOUT();PTST("  RCL=");
               PTNO(READ'SPT'FIELD(SPNO,'RCL'//SF'PUNT),0,10);
               PTST(" FTH=");
               PTNO(READ'SPT'FIELD(SPNO,'FTH'//SF'PUNT),0,10);
                PTST(" USP=");PTNO(READ'SPT'FIELD(SPNO,'USP'//SF'PUNT),0,10);
               KEY←READ'SPT'FIELD(SPNO,'KEY'//SF'PUNT);
               PTST(" CALLABLE SP(*=KEY SET):"); X←0;
               FOR SPNO'←1 TO NSPT DO ;
                   IF READ'SPT'FIELD(SPNO',1//SF'PUNT)
                    A' (1 LSH SPNO)#0 DO ;
                       PTCH(',')IF X#0;X←1;
                       PTNO(SPNO',0,10);
                       PTCH('*') IF (1 LSH SPNO') A' KEY#0;
                   ENDIF ;
               ENDFOR ;
               PTNL();PRINT'STRING(-1,OL,0//QUIT'PUNTX(QT'XIT,OL));
               IF CODE A' 2#0 DO ;* PRINT 'STATE'
               IOUT();PTST("  ENTRY=");
                   PTNO(READ'SPT'FIELD(SPNO,'EP'//SF'PUNT),0,8);
                   PTST(" G-REG=");
                   PTNO(READ'SPT'FIELD(SPNO,'EG'//SF'PUNT),0,8);
                   PTST(" CAK=");
                   PTNO(READ'SPT'FIELD(SPNO,'CAK'//SF'PUNT),0,10);
                   PTST(" UAK=");
                   PTNO(READ'SPT'FIELD(SPNO,'UAK'//SF'PUNT),0,10);

                   PTNL(); PRINT'STRING(-1,OL,0//QUIT'PUNTX(QT'XIT,OL));
                   IOUT();PTST("  CONTROLLED TRAPS(*=NOT ARMED, +=NO CTRL):");
                   LISTBITS(READ'SPT'FIELD(SPNO,'TCM'//SF'PUNT),
                    READ'SPT'FIELD(SPNO,'TM'//SF'PUNT),TNAME);
                   GOTO EXIT IF QUIT'FLAG;
                   IOUT();PTST("  CONTROLLED STATUS(*=NOT SET, +=NO CTRL):");
                   LISTBITS(READ'SPT'FIELD(SPNO,'SCB'//SF'PUNT),
                    READ'SPT'FIELD(SPNO,'SB'//SF'PUNT),SNAME);
               ENDIF ;
               IF CODE A' 1#0 DO ;* PRINT MAP
               SETS(MAP,0,0);
                   READ'MAP(SPNO,MAP:MAP//SF'PUNT);IX←0;
LP:                    PF←0;
                       IOUT();PTST("  ");
                   PTCH('0')IF IX=0;
                   CNS(IX,OL,0,8//LF'PUNT);
                       PTCH('B');
                       FOR J←1 TO 8 DO ;
                           PN←GCI(MAP//XIT);
                           PTCH(' ') IF J#5 ELSE PTCH('/');
                           IF PN=0 DO ;
                               PTST("  - ");
                           ELSE DO ;
                               PTCH('R' IF PN$MAPRO#0 ELSE ' ');
                               PTNO(PN A' 377B,3,10);PF←1;
                           ENDIF ;
                       ENDFOR ;* J
XIT:                   IX←IX+8;PTNL();
                       PRINT'STRING(-1,OL,0//QUIT'PUNTX(QT'XIT,OL))
                        IF PF#0; GOTO LP IF NOT EMPTY(MAP);
               ENDIF ;
           ENDIF ;
       ENDFOR ;
EXIT:  RETURN ;
QT'XIT:QUIT'FLAG←1; RETURN;

       PROGRAM LISTBITS; INCLUDE USERDECS;
*
* LIST 'STATUS' BIT WORD SYMBOLICALLY
*
        INT CF,AF,I,B,N,ERCODE,ERMSNO;
       INTARY NAME;
       CHRFL CH60(0:0,5),CH61(0:6,11),CH62(0:12,17),CH63(0:18,23);

*      *=CONTROL, BUT NOT ARMED
*      +=ARMED, BUT NOT CONTROLLED

        ENTRY LISTBITS(CF,AF,NAME);

        RETURN IF CF V' AF=0;
       FOR I←0 TO 23 DO ;
           B←4B7 RSH I;* COMPUTE BIT
           IF (CF V' AF) A' B # 0 DO;
               PTCH(' ');N←NAME[I];
               PTCH(N$CH60) IF N$CH60#' ';
               PTCH(N$CH61) IF N$CH61#' ';
               PTCH(N$CH62) IF N$CH62#' ';
               PTCH(N$CH63) IF N$CH63#' ';
               PTCH('*') IF AF A' B=0;
               PTCH('+') IF CF A' B=0;
               IF LENGTH(OL)>62 DO ;
                   PTNL();PRINT'STRING(-1,OL,0//QUIT'PUNTX(QT'XIT,OL));
                   IOUT();PTST("       ");
               ENDIF ;
           ENDIF ;
       ENDFOR ;
       IF LENGTH(OL)>10 DO ;
           PTNL();PRINT'STRING(-1,OL,0//QUIT'PUNTX(QT'XIT,OL));
       ENDIF ;
EXIT:  RETURN ;
QT'XIT:QUIT'FLAG←1; RETURN;

       PROGRAM GETSPN;
       INCLUDE USERDECS,PMTDECS;

        INT C,N,SPMASK;
       ST SPSTRING,NAME'ST;

        ENTRY GETSPN(SPSTRING), FRETURN ;
       NAME'ST←GET'PARAM(SPSTRING);
       C←GCI(NAME'ST//ALL);NAME'ST$RP←INCDES(NAME'ST$RP,-1);
       IF C='*' DO ;
ALL:       SPMASK←DMASK();
       ELSEIF C<'9' AND C>='0' DO;
           SPMASK←1 LSH (C-'0');
       ELSE DO ;
           N←SPNAME'SEARCH(NAME'ST//PARERR:ERCODE,ERMSNO);
           SPMASK←1 LSH N;
       ENDIF ;
       RETURN (SPSTRING,SPMASK);
PARERR:PARAM'ERR(NAME'ST);
       FRETURN ;

       PROGRAM DMASK;
       INCLUDE USERDECS,SPTDECS;

        INT X,I; INTARY SAR[10]; INTFL CSNOF(0:2,5);
       ENTRY DMASK();
       X←1;
       FOR I←1 TO NSPT DO;
           X←X V'(1 LSH (READ'SPT'FIELD(I,'USP'//SF'PUNT)))
            IF READ'SPT'FIELD(I,0//SF'PUNT)#0;
       ENDFOR;
       READ'SPCS(-1,SAR//SF'PUNT);
       X←X V' (1 LSH SAR[0]$CSNOF);
       RETURN (777B E' X);

       PROGRAM LIST;

        INCLUDE USERDECS,PMTDECS,SPTDECS;

       INT PMTX,X;
        ST PS(50);
       INT SPMASK,T,I,ERCODE,ERMSNO;
       PTR PMTPTR;

        ENTRY LIST(PMTPTR,SPMASK,FP,PMTX),FRETURN;
       SETS(PS,0,0);WCI(' ',PS//EXIT);
       WCI('R',PS//EXIT) IF PMTPTR.PMTRO;
       CNS(PMTX,PS,0,10//LF'PUNT);
       WCI('%',PS//EXIT)IF PMTPTR[4]$APTDWS;
       WCI(':',PS//EXIT);
       IF FP DO ;*IF FILE PAGE...
       T←(PMTPTR.UQNLPN IF PMTPTR.UQNLFB ELSE PMTPTR.UQNSPN);
           CNS(T,PS,0,10//LF'PUNT);
       ENDIF ;
       X←0;
       FOR I←0 TO NSPT DO ;
           FRETURN IF QUIT'FLAG;
           T←1 LSH I;
           IF T A'  (PMTPTR.PMTAL V' PMTPTR.PMTCL) DO ;
               WCI(',',PS//EXIT)IF X#0;X←1;
               CNS(I,PS,0,10//LF'PUNT);
               IF T A' N' PMTPTR.PMTAL DO ;
                   WCI('*',PS//EXIT);*CONTROL BUT NO ACCESS
               ELSEIF T A' N' PMTPTR.PMTCL DO ;
                   WCI('+',PS//EXIT);*ACCESS BUT NO CONTROL
               ENDIF ;
           ENDIF ;
       ENDFOR ;
       IF LENGTH(OL)+LENGTH(PS)>68 DO ;
           PTNL();PRINT'STRING(-1,OL,0//QUIT'PUNTX(QT'XIT,OL));
           IOUT();PTST("    ");
       ENDIF ;
          APPEND(OL,PS//EXIT);
EXIT:  RETURN ;
QT'XIT:QUIT'FLAG←1; RETURN;

       PROGRAM FNAME;
       INCLUDE USERDECS,SIBDECS,UQNDECS;

        INTFL TYP(0:1,4);
       CHRFL CH60(0:0,5),CH61(0:6,11),CH62(0:12,17),CH63(0:18,23);
       INT I,X,UNO,KEY,ERCODE,ERMSNO;
       INTARY WA[8],N[8];
       OCTFL W0(0),W1(1);
       ST NAME,NAME'ST;
       PTR UQN;
       LN LUQN;

        STRING ENTRY FNAME(UQN,NAME'ST), FRETURN ;
       UNO←UQN.UQNOWN;SETS(NAME'ST,0,0);
       KEY←CONV'KEY(-1//SF'PUNT);
       LUQN$W0←UNO;
       FOR I←0,I+1 WHILE 1 DO ;
           FRETURN IF QUIT'FLAG;
           READ'MIBOB'INDEX(LUQN,6,WA,I,KEY//XIT:ERCODE,ERMSNO);
           IF WA[0]$TYP<2 DO ;*IF FILE...
           BCOPY(@WA[2],@WA[1],6);
               WA[0]←UNO; WA[1]←$(UQN+1);
               READ'MIBOB'VALUE(WA,4,N,0,KEY//SF'PUNT);
               IF UQN.W0=N[2] AND UQN.W1=N[3] DO ;
                   SETUP(NAME,16,@WA[3],6);
                   SETS(NAME,0,15);
                   X←' ';X←GCD(NAME) WHILE X=' ';
                   WCI(X,NAME//EXIT);
                   APPEND(NAME'ST,NAME//EXIT);
                   IF WA[7]#0 DO ;
                       WCI(':',NAME'ST//EXIT);
                       WCI(WA[7]$CH60,NAME'ST//EXIT);
                       WCI(WA[7]$CH61,NAME'ST//EXIT);
                       WCI(WA[7]$CH62,NAME'ST//EXIT);
                       WCI(WA[7]$CH63,NAME'ST//EXIT);
                   ENDIF ;
EXIT:              RETURN NAME'ST;
               ENDIF ;
           ENDIF ;
MORE:  ENDFOR ;
NOMORE:GOTO UQNUM;

XIT:    GOTO NOMORE IF ERCODE='MOB' ELSE GOTO MORE;
UXIT:  IOUT();OL←ERRORMSG(ERMSNO,OL//SF'PUNT);PTNL();
       PRINT'STRING(-1,OL,0//QUIT'PUNTX(QT'XIT,OL));

FEXIT:  FRETURN ;
QT'XIT:QUIT'FLAG←1; FRETURN;

UQNUM:  APPEND(NAME'ST,"UQN:"//EXIT);
       CNS(((UQN.W0 RSH I)A' 7B),NAME'ST,0,8//LF'PUNT)IF(UQN.W0 RSH I)#0 FOR I←21 BY -3 TO 0;
       CNS(((UQN.W1 RSH I)A' 7B),NAME'ST,0,8//LF'PUNT)FOR I←21 BY -3 TO 0;
       WCI('B',NAME'ST//EXIT);
       GOTO EXIT;
    PRINT'STRING(-1,OL,0//QUIT'PUNTX(UXIT,OL));
    GOTO UXIT;
       COMMON ENTRY'DEFS;

*      THIS COMMON BLOCK CONTAINS THE VARIABLES NECESSARY FOR THE
* PROGRAM BLOCK ENTRIES, SUCH THINGS AS THE SIZE OF THE STACK, THE
* STACK BOUNDS, STACK POINTER, AND STACK LIMIT.

       DECLARE PARAMETER
          STACK'SIZE ← 4000B;

       DECLARE ARRAY
          STACK[STACK'SIZE];

       DECLARE ARRAY
          STATE[10];         /* THE SAVED STATE KEPT BY THE MONITOR   */

       DECLARE PARAMETER
          STACK'POINTER = G'[2],
          STACK'LIMIT = G'[3],
          INITIAL'SP ← @STACK[0],
          INITIAL'SL ← @STACK[STACK'SIZE - 1];

       DECLARE PARAMETER     /* INDEXES INTO STATE                    */
          P'INDEX ← 0,       /* PROGRAM COUNTER                       */
          L'INDEX ← 7,       /* LOCAL REGISTER                        */
          G'INDEX ← 8;       /* GLOBAL REGISTER                       */

       DECLARE FIELD         /* FOR A SPCS ENTRY                      */
          PC (0:6,23),       /* THE SAVED P-COUNTER                   */
          LR (1:6,23),       /* THE SAVED L-REGISTER                  */
          GR (2:6,23);       /* THE SAVED G-REGISTER                  */

       MACRO SAVE'STATE (CURRENT'STATE) ← .STX CURRENT'STATE[6],
          .EAX CURRENT'STATE[0], .STORS;



       END;

       PROGRAM ENTRIES;

* THIS PROGRAM BLOCK CONTAINS THE ENTRY POINTS TO THE WHOLE PROGRAM

       INCLUDE ENTRY'DEFS;

       DECLARE INTEGER
          SP'INT'NO = L'[0],
          SP'TRAP'NO = L'[0],
          SP'TRAP'PARAM = L'[1];



* SUB-PROCESS TRAP ENTRY POINT
       FUNCTION SP'TRAP'ENTRY(), SP'ENTRY ← 0;
       SAVE'STATE(STATE);
       SP'TRAP'HANDLER(SP'TRAP'NO, SP'TRAP'PARAM);



* INTERRUPT ENTRY POINT
       FUNCTION INTERRUPT'ENTRY(), SP'ENTRY ← 1;
       FATAL'ERROR();



* INITIAL ENTRY POINT
       FUNCTION INITIAL'ENTRY(), SP'ENTRY ← 2;
       STACK'POINTER ← INITIAL'SP;
       STACK'LIMIT ← INITIAL'SL;
       INITIAL'DRIVER();



* CONTINUE ENTRY POINT
       FUNCTION CONTINUE'ENTRY(), SP'ENTRY ← 3;
       STACK'POINTER ← INITIAL'SP;
       STACK'LIMIT ← INITIAL'SL;
       /*CONTINUE'*/INITIAL'DRIVER();



       END;

       COMMON MONITOR'CALLS;


******************************
*
* CALLS TO MANIPULATE MULTI-INDEX BLOCKS (MIBS) AND SUB-INDEX BLOCKS (SIBS)
*
******************************

       INTEGER MONITOR CREATE'MIB ← 190;         
       UNKNOWN MONITOR READ'MIBOB'INDEX ← 0;     * READ CONTENTS OF ENTRY
       UNKNOWN MONITOR READ'MIBOB'NAME ← 1;      * READ ENTRY
       UNKNOWN MONITOR SET'MIBOB'NAME ← 2;       * SET NAME OF ENTRY
       UNKNOWN MONITOR SET'MIBOB'ACCESS ← 3;     * SET PUBLIC, FRIEND AND OWENER ACCESS OF OBJECT
       UNKNOWN MONITOR SET'LOCK'LIST ← 4;        * SET LOCK AND ACCESS FOR LOCK
       UNKNOWN MONITOR DELETE'MIBOB ← 5;         * DELETE ENTRY
       INTEGER MONITOR CREATE'MIBOB ← 6;         * CREATE NEW ENTRY
       UNKNOWN MONITOR MERGE'MCW ← 9;            * READ OR MERGE THE MIB CAPABILITY WORK (MCW) INTO SPT
       UNKNOWN MONITOR SET'MIB'ACCESS ← 10;      * COPY MIB CAPABILITIES WORD FROM ONE MIB TO ANOTHER
       INTEGER MONITOR READ'MIB'ACCESS ← 11;     * READ MIB ACCESS
       UNKNOWN MONITOR SET'MIBOB'VALUE ← 12;     * SET VALUE OF OBJECT
       INTEGER MONITOR COPY'MIBOB ← 14;          * COPY ACCESS KEY FROM ONE MIB TO ANOTHER (NOT IMPLEMENTED)
       UNKNOWN MONITOR SET'NO'CHARGE ← 15;       * SET NO DRUM CHARGE FLAG FOR FILE
       INTEGER MONITOR READ'MIB'SPACE ← 16;      * READ AVAILABLE SPACE IN MIB
       UNKNOWN MONITOR SET'FILE'LOCK ← 18;       * SET WRITTEN AND REFERENCE DATE ON FILE (NOT IMPLEMENTED)
       UNKNOWN MONITOR SET'DURABILITY ← 28;      * SET THE DURABILITY FIELD OF THE MIB (BUT, NO ONE LOOKS AT IT)





******************************
*
* OPEN FILE TABLE (OFT) CALLS
*
******************************

       INTEGER MONITOR MON'OPEN'FILE ← 19;       * OPEN OBJECT
       UNKNOWN MONITOR MON'READ'OFT ← 20;        * READ OFT ENTRY
       UNKNOWN MONITOR MON'SET'OFT'AC ← 21;      * SET OFT ACCESS LOCK
       UNKNOWN MONITOR MON'SET'OFT'CL ← 22;      * SET OFT CONTROL LOCK
       UNKNOWN MONITOR SET'FILE'LENGTH ← 23;     * SET WORD LENGTH FOR OFT ENTRY
       INTEGER MONITOR CREATE'FILE'PAGE ← 24;    * CREATE A PRIVATE MEMORY PAGE
       INTEGER MONITOR DEL'FILE'PAGE ← 25;       * DELETE A PAGE OF AN OBJECT
       INTEGER MONITOR NEXT'FILE'PAGE ← 26;      * GET NEXT PAGE OF FILE
       UNKNOWN MONITOR MOVE'PAGE'PMT ← 27;       * PUT REAL NAME OF A PAGE OF A FILE INTO A PMT ENTRY

******************************
*
* PROCESS MEMORY TABLE (PMT) CALLS
*
******************************

       INTEGER MONITOR ACQUIRE'PMT ← 50;         * ACQUIRE AND INITIALIZE A PMT ENTRY
       UNKNOWN MONITOR NEW'PMT'PAGE ← 51;        * CREATE A PRIVATE MEMORY PAGE AND PUT ITS REAL NAME INTO PMT
       UNKNOWN MONITOR COPY'RN'PMT ← 52;         * PUT SPECIFIED REAL NAME INTO A PMT ENTRY
       UNKNOWN MONITOR CLEAR'PMT ← 53;           * RELEASE PAGE FROM PMT ENTRY
       UNKNOWN MONITOR DELETE'PMT ← 54;          * RELEASE PMT ENTRY (RELEASE PAGE FROM PMT ENTRY AND FREE ENTRY)
       UNKNOWN MONITOR SET'PMT'ACC'LOCK ← 55;    * SET THE ACCESS LOCK OF A PMT ENTRY
       UNKNOWN MONITOR SET'PMT'CON'LOCK ← 56;    * SET THE CONTROL LOCK OF AN PMT ENTRY
       UNKNOWN MONITOR SET'PMT'RO ← 57;          * SET THE READ ONLY BIT IN A PMT ENTRY
       UNKNOWN MONITOR READ'PMT ← 58;            * READ A PMT ENTRY



******************************
*
* WORKING SET CALLS
*
******************************

       UNKNOWN MONITOR PUT'PAGE'DWS ← 65;        * PUT PAGE IN THE DRUM WORKING SET
       UNKNOWN MONITOR PUT'PAGE'CWS ← 66;        * PUT A PAGE IN THE CORE WORKING SET
       INTEGER MONITOR DEL'PAGE'DWS ← 67;        * DELETE A PAGE FROM THE DWS
       INTEGER MONITOR DEL'PAGE'CWS ← 68;        * DELETE A PAGE FROM THE CWS
       INTEGER MONITOR READ'LEN'WS ← 70;         * READ THE LENGTH OF A SPECIFIED THE WORKING SET
       UNKNOWN MONITOR SET'LEN'WS ← 71;          * SET THE OVERFLOW LENGTH OF A SPECIFIED WS



******************************
*
* SUB-PROCESS TABLE (SPT) CALLS
*
******************************

       INTEGER MONITOR MON'CREATE'SP ← 90;       * ACQUIRE AND INITIALIZE AN SPT ENTRY
       UNKNOWN MONITOR MON'DESTROY'SP ← 91;      * DELETE THE CONTENTS OF AN SPT ENTRY
       UNKNOWN MONITOR MON'READ'SPT ← 95;        * READ AN SPT ENTRY
       UNKNOWN MONITOR MON'READ'SPCS ← 96;       * READ AN SPCS ENTRY
       INTEGER MONITOR MON'READ'SPT'FLD ← 97;    * READ A SELECTED FIELD OF AN SPT ENTRY
       UNKNOWN MONITOR MON'SET'SPT'FLD ← 98;     * SET THE VALUE OF A SPECIFIED FIELD OF AN SPT ENTRY
       UNKNOWN MONITOR READ'SPT'MAP ← 99;        * READ THE MAP OF AN SPT ENTRY
       UNKNOWN MONITOR SET'SPT'MAP ← 100;        * SET THE MAP OF AN SPT ENTRY
       INTEGER MONITOR READ'MAP'BYTE ← 101;      * READ A BYTE IN THE MAP OF AN SPT ENTRY
       UNKNOWN MONITOR SET'MAP'BYTE ← 102;       * SET A BYTE IN THE MAP OF AN SPT ENTRY
       UNKNOWN MONITOR READ'ACCESS'KEY ← 103;    * READ AN ACCESS KEY FROM AN SPT ENTRY
       UNKNOWN MONITOR COPY'ACCESS'KEY ← 104;    * COPY AN ACCESS KEY FROM ONE SPT ENTRY TO ANOTHER
       UNKNOWN MONITOR COPY'TAK ← 105;           * COPY THE TEMPORARAY ACCESS KEY
       INTEGER MONITOR READ'SPS'PARAM ← 106;

******************************
*
* SUB-PROCESS CALL STACK (SPCS) CALLS
*
******************************

       UNKNOWN MONITOR SP'CALL ← 111;            * CALL A SUB-PROCESS
       UNKNOWN MONITOR SP'JUMP ← 112;            * JUMP TO A SUB-PROCESS
       UNKNOWN MONITOR SP'TRAP ← 113;            * GENERATE A SOFTWARE TRAP
       UNKNOWN MONITOR TRAP'RETURN ← 114;        * POP UP THE SUB-PROCESS CALL STACK AND GENERATE A SOFTWARE TRAP
       UNKNOWN MONITOR SP'BRANCH ← 115;          * BRANCH INTO A SUB-PROCESS
       UNKNOWN MONITOR SP'RETURN ← 116;          * RETURN TO A CALLING SUB-PROCESS
       UNKNOWN MONITOR JUMP'RETURN ← 117;        * RETURN TO A SPECIFIED LEVEL IN THE SUB-PROCESS CALL STACK
       UNKNOWN MONITOR MARK'CALL ← 118;          * RECORD A FUNCTION CALL ON THE SPCS
       UNKNOWN MONITOR DELETE'CALL ← 119;        * DELETE A FUNCTION CALL FROM THE SPCS
       UNKNOWN MONITOR MODIFY'CALL ← 120;        * CHANGE A FUNCTION CALL ON THE SPCS



******************************
*
* PROCESS CALLS
*
******************************

       INTEGER MONITOR COPY'PMT'PROC ← 130;      * COPY A PMT ENTRY FROM ONE PROCESS TO ANOTHER
       INTEGER MONITOR ACTIVATE'PROC ← 132;      * ACTIVATE A PROCESS
       UNKNOWN MONITOR TRANSFER'TERM ← 133;      * TRANSFER A TERMINAL
       UNKNOWN MONITOR MAKE'DORMANT ← 134;       * MAKE A PROCESS DORMANT
       UNKNOWN MONITOR INIT'PROC'PAGE ← 135;     * INITIALIZE UTILITY AREA OF THE CONTEXT BLOCK OR PRIVATE MEMORY PAGE
*                                                *   IN A NEW PROCESS
       UNKNOWN MONITOR INIT'PROC'MAP ← 136;      
       UNKNOWN MONITOR INIT'SPT ← 137;
       INTEGER MONITOR READ'PROC'PARAM ← 211;

******************************
*
* OPERATIONS ON INTERRUPT CHANNEL TABLE (ICT)
*
******************************

       UNKNOWN MONITOR SET'PROC'INT ← 163;       * SET PIW BITS
       INTEGER MONITOR QUIT'BLOCK ← 164;
       INTEGER MONITOR GET'INT'NUM ← 165;        * CONVERT INTERRUPT CHARACTER CONSTANT TO INTERRUPT NUMBER
       INTEGER MONITOR READ'ICT ← 166;           * READ INTERRUPT CELL
       INTEGER MONITOR READ'PIW ← 167;           * READ PROGRAM INTERRUPT WORD (PIW)
       UNKNOWN MONITOR ALLOW'INTS ← 168;         * RESET NON-INTERRUPTABILITY
       UNKNOWN MONITOR REFUSE'INTS ← 169;        * MAKE NON-INTERRUPTABLE
       UNKNOWN MONITOR BLOCK ← 170;              * BLOCK THE PROCESS
       UNKNOWN MONITOR CLEAR'PIW ← 171;          * CLEAR PIW BITS
       UNKNOWN MONITOR SET'ICT ← 172;            * SET INTERRUPT CELL
       UNKNOWN MONITOR SET'ICT'CON'LOCK ← 173;   * SET CONTROL LOCK IN INTERRUPT CELL
       INTEGER MONITOR ACQUIRE'ICT ← 174;        * ACQUIRE INTERRUPT CELL



******************************
*
* CHIO CALLS
*
******************************

       UNKNOWN MONITOR SET'LINE'FIELD ← 180;     * SET THE VALUE OF A PARAMETER FOR THE CHIO LINE
       UNKNOWN MONITOR READ'LINE'TABLE ← 181;    * READ CHIO LINE TABLE
       STRING MONITOR READ'STRING ← 182;         * INPUT STRING FROM CHIO LINE
       STRING MONITOR WRITE'STRING ← 183;        * OUTPUT A STRING ONTO A CHIO LINE



******************************
*
* MISCELLANEOUS
*
******************************

       UNKNOWN MONITOR DO'POT'PIN ← 129;         * HARDWARE KLUDGE

       LONG MONITOR READ'CLOCK ← 210;            * READ REAL-TIME CLOCK
       MONITOR READ'WRITE'CM ← 255;              * READS AND WRITES INTO CENTRAL MEMORY

* DON'T KNOW MUCH ABOUT THESE
       MONITOR SEIZE'SEM ← 29;                   * (NOT IMPLEMENTED)
       MONITOR RELEASE'SEM ← 30;                 * (NOT IMPLEMENTED)
       MONITOR DIAGNOSTIC'DIO ← 59;              * DIRECT INPUT/OUTPUT?
       MONITOR KLUDGE'IO ← 128;                  * VARIATION OF DIAGNOSTIC'DIO?
       MONITOR MOVE'DISK'RES ← 149;              * MOVE DISK RESOURCES (WHO CARES?)



       END;

       COMMON UTILITY'CALLS;

******************************
*
* MISCELLANEOUS UCALLS
*
******************************

       UNKNOWN UTILITY BREAK'POINT ← 0;          * UCALL FOR DEBUGGING PROGRAMS
       STRING UTILITY ERRORMSG ← 1;              * RETURN SYSTEM ERROR MESSAGE
       STRING UTILITY GET'PARAM ← 2;             * STRIP PARAMETER FROM STRING
       STRING UTILITY GET'COM'LINE ← 3;          * GET CURRENT COMMAND LINE FROM UTS
       INTEGER UTILITY ABRV'LKP ← 4;             * LOOK UP ABBREVIATED NAME IN STRING ARRAY
       INTEGER UTILITY CON'ABRV'LKP ← 5;         * CONTINUE SAME IN NEW STRING ARRAY
       STRING UTILITY GET'CMP'COMLINE ← 6;       * GET SAVED COMMAND LINE AND USER NUMBER OF ATTACHED FILE
       UNKNOWN UTILITY SET'COM'LINE ← 7;         * SET THE SAVED COMMAND LINE

******************************
*
* FILE SYSTEM CALLS
*
******************************

       UNKNOWN UTILITY NAME'SEARCH ← 10;         * CONVERT FILE ST TO UTS NAME
       UNKNOWN UTILITY SPECIAL'SEARCH ← 11;      * VARIATION OF ABOVE
       INTEGER UTILITY CONV'NAME ← 12;           * CONVERT FROM UTS TO MON FILE NAME
       LONG UTILITY SPREAD'NAME ← 13;            * SPLIT FILE NAME STRING INTO COMP.
       UNKNOWN UTILITY READ'MIBOB'VALUE ← 14;    * READ 'VALUE' OF MIB OBJECT
       UNKNOWN UTILITY DELETE'FILE ← 15;         * DELETE FILE AND CONTENTS
       INTEGER UTILITY OPEN'FILE ← 16;           * OPEN FILE W/WO LOCKING
       UNKNOWN UTILITY CLOSE'FILE ← 17;          * CLOSE AND UNLOCK FILE
       UNKNOWN UTILITY READ'OFT ← 18;            * READ OFT
       INTEGER UTILITY READ'OFT'FIELD ← 19;      * READ OFT FIELD
       UNKNOWN UTILITY SET'OFT'CL ← 20;          * SET OFT CONTROL LOCK
       INTEGER UTILITY CONV'KEY ← 21;            * CONVERT DEFAULT ACCESS KEY


******************************
*
* EXTENDED SUB-PROCESS SYSTEM (SPS) CALLS
*
******************************

       INTEGER UTILITY CREATE'SSP ← 30;          * CREATE SUBSIDIARY SUB-PROCESS
       INTEGER UTILITY CREATE'PSP ← 31;          * CREATE PARALLEL SUB-PROCESS
       UNKNOWN UTILITY ATTACH ← 32;              * ATTACH PIF FILE TO SUB-PROCESS
       UNKNOWN UTILITY DESTROY'SP ← 33;          * DESTROY SUB-PROCESSES
       UNKNOWN UTILITY READ'SPT ← 34;            * READ SPT
       INTEGER UTILITY READ'SPT'FIELD ← 35;      * READ SPT FIELD
       UNKNOWN UTILITY SET'SPT'FIELD ← 36;       * SET SPT FIELD
       STRING UTILITY READ'SPNAME ← 37;          * READ SUB-PROC NAME
       UNKNOWN UTILITY SET'SPNAME ← 38;          * SET SUB-PROC NAME
       INTEGER UTILITY SPNAME'SEARCH ←39;        * LOOK UP SP NAME

******************************
*
* CONTROL INPUT/OUTPUT STREAMS (CIOS) MANIPULATION
*
******************************

       INTEGER UTILITY CREATE'CIOS ← 40;         * CREATE CONTROL I/O STREAM
       INTEGER UTILITY READ'CIOS'FIELD ← 41;     * READ CIOS FIELD
       UNKNOWN UTILITY SET'CIOS'FIELD ← 42;      * SET (SOME) CIOS FIELDS
       UNKNOWN UTILITY SET'CIOS'INPUT ← 43;      * SET UP FOR INPUT
       UNKNOWN UTILITY SET'CIOS'OUTPUT ← 44;     * SET UP FOR OUTPUT



******************************
*
* CIOS INPUT/OUTPUT
*
******************************

       UNKNOWN UTILITY PRINT'STRING ← 45;        * WRITE STRING ON CIOS
       UNKNOWN UTILITY PRINT'CHAR ← 46;          * WRITE (= BUFFER) CHAR ON CIOS
       UNKNOWN UTILITY START'OUTPUT ← 47;        * DUMP OUTPUT BUFFER
       STRING UTILITY READ'LINE ← 48;            * READ NEXT INPUT LINE
       STRING UTILITY EDIT'LINE ← 49;            * EDIT CURRENT LINE
       CHARACTER UTILITY READ'CHAR ← 50;         * READ NEXT CHARACTER
       UNKNOWN UTILITY BLOCK'OB'EMPTY ← 51;      * WAIT UNTIL OUT BUFFER IS EMPTY



******************************
*
* USER, ACCOUNT, AND GROUP PROFILES
*
******************************

       STRING UTILITY READ'UP'ITEM ← 60;         * READ ITEM FROM USER PROFILE
       STRING UTILITY READ'UP'NAMES ← 61;        * READ NAMES OF UP ITEMS
       UNKNOWN UTILITY SET'UP'ITEM ← 62;         * SET (CREATE) VALUE OF UP ITEM
       UNKNOWN UTILITY SET'UP'ACCESS ← 63;       * SET ACCESS TO UP ITEM
       LONG UTILITY FIND'MIB ← 64;               * CONVERT USER NAME/NUMBER TO MIB ADDR
       INTEGER UTILITY CREATE'UP'ENTRY ← 65;     * CREATE USER/UP ENTRY
       UNKNOWN UTILITY DELETE'UP'ENTRY ← 66;     * DELETE USER/UP ENTRY

******************************
*
* PROCESSES, AND PROCESS PROFILE
*
******************************

       UNKNOWN UTILITY CREATE'PROCESS ← 70;      * CREATE/INITIALIZE PROCESS
       STRING UTILITY READ'PP'ITEM ← 71;         * READ ITEM FROM PROCESS PROFILE
       STRING UTILITY READ'PP'NAMES ← 72;        * READ NAMES OF PP ITEMS
       UNKNOWN UTILITY SET'PP'ITEM ← 73;         * SET (CREATE) VALUE OF PP ITEM
       UNKNOWN UTILITY DESTROY'PROCESS ← 74;     * DESTROY THIS PROCESS



******************************
*
* TIME CALCULATIONS
*
******************************

       INTEGER UTILITY SYS'TIME'NUM ← 80;        * NUMERICAL SYSTEM TIMES
       INTEGER UTILITY ANY'TIME'NUM ← 81;        * CHARACTER SPECIFIC TIMES
       STRING UTILITY ANY'TIME'CHAR ← 82;        * CHARACTER SPECIFIC TIMES 


       END;

       COMMON ERROR'DEFS;

*      THIS COMMON BLOCK DECLARES ALL THE VARIABLES USED TO PRINT OUT
* ERROR MESSAGES AND THE MACROS USED IN THE FAILURE RETURN FIELD OF
* FUNCTION CALLS.

* BE CAREFUL, MACROS!
       MACRO WARNING ← RUNTIME'FAILURE();
       MACRO CATASTROPHE ← FATAL'ERROR();
       MACRO DISTRESS ← SYSTEM'ERROR(): ERROR'CODE, ERROR'NUMBER;

       DECLARE INTEGER
          ERROR'CODE,        /* CHARACTER CODE OF ERROR               */
          ERROR'FILE'NUM,    /* THE FILE NUMBER USED BY THE FORMAT-   */
                             /*   TING OUTPUT FUNCTIONS               */
          ERROR'NUMBER,      /* NUMERICAL CODE OF ERROR               */
          ERROR'RADIX;       /* THE RADIX OF NUMBERS OUTPUT BY THE    */
                             /*   FORMATTING OUTPUT FUNCTIONS         */

       DECLARE STRING
          ERROR'STRING (200);/* THE STRING USED BY THE FORMATTING     */
                             /*   OUTPUT FUNCTIONS                    */



       END;

       COMMON ARRAY'DEFS;

*      THIS COMMON BLOCK DEFINES ALL THE FIELDS USED TO MANIPULATE
* ARRAYS WITH.

       INCLUDE ERROR'DEFS;

       DECLARE FIELD         /* FOR THE ARRAY DESCRIPTOR ITSELF       */
          INDEXING'ORGIN (0:2,2),
          ARRAY'TRAP'BIT (0:3,3),
          LEB (0:4,4),
          ITEM'SIZE'LEB0 (0:5,6),
          ITEM'SIZE'LEB1 (0:5,10),
          UPPER'BOUND'LEB0 (0:7,23),
          UPPER'BOUND'LEB1 (0:11,23),
          ARRAY'DESC'ADDR (1);

       DECLARE FIELD         /* FOR GENERAL INDIRECT ADDRESS WORDS    */
          IAW'TYPE (0:0,1),
          IAW'TAG (0:2,4),
          IAW'TRAP (0:5,5),
          IAW'ADDRESS (0:6,23);

       DECLARE PARAMETER     /* FOR IAW'TYPE                          */
          NORMAL'IAW ← 0,
          FIELD'IAW ← 1,
          STRING'IAW ← 2,
          ARRAY'IAW ← 3;

       DECLARE PARAMETER     /* FOR IAW'TAG                           */
          DIRECT ← 0,
          INDIRECT ← 1,
          INDEXED ← 2,
          BASE'INDEXED ← 3,
          POINTER'DISP ← 4,
          IND'PTR'DISP ← 5,
          BASE'INDEX'DISP ← 6,
          RELATIVE ← 7;


       END;

       PROGRAM CONS'ARRAY'DESC;

*      THIS FUNCTION CREATES AN ARRAY DESCRIPTOR GIVEN THE BASE ADDRESS,
* THE NUMBER OF ELEMENTS, ELEMENT SIZE, AND LOWER BOUND.  THIS FUNCTION
* FAILS IF ONE THE THE ARGUMENTS ARE INVALID.

       INCLUDE ARRAY'DEFS;

       DECLARE ARRAY
          ARRAY'DESC;

       DECLARE FIELD
          MULTIPLIER,        /* WHAT IT IS DEPENDS ON LEB             */
          UPPER'LIMIT;       /* WHAT IT IS DEPENDS ON LEB             */

       DECLARE INTEGER
          BASE'ADDRESS,      /* FIRST ADDRESS THAT STORAGE BEGINS IN  */
          ELEMENT'SIZE,      /* NUMBER OF WORDS PER ENTRY             */
          KLUDGE,
          LARGE'ELEMENT,
          LOWER'BOUND,       /* AN ARRAY OR AN ARRAYONE               */
          NO'OF'ELEMENTS,    /* NUMBER OF ELEMENTS                    */
          UPPER'BOUND;       /* HIGHEST VALID SUBSCRIPT               */



       ARRAY FUNCTION CONS'ARRAY'DESC(BASE'ADDRESS, NO'OF'ELEMENTS,
          ELEMENT'SIZE, LOWER'BOUND), FRETURN;

* CHECK THE PARAMETERS PASSED TO SEE IF THEY ARE VALID
       WARNING IF (BASE'ADDRESS < 0 OR BASE'ADDRESS > (-1)$IAW'ADDRESS);
       WARNING IF NO'OF'ELEMENTS < 0;
       WARNING IF (ELEMENT'SIZE < 1 OR ELEMENT'SIZE >
          (-1)$ITEM'SIZE'LEB1 + 1);
       WARNING IF (LOWER'BOUND # 0 AND LOWER'BOUND # 1);

* SET UP THE FIELDS FOR SMALL OR LARGE ELEMENT CASES
       IF ELEMENT'SIZE <= 4 DO;
          LARGE'ELEMENT ← 0;
          MULTIPLIER ← ITEM'SIZE'LEB0;
          UPPER'LIMIT ← UPPER'BOUND'LEB0;
       ELSE DO;
          LARGE'ELEMENT ← 1;
          MULTIPLIER ← ITEM'SIZE'LEB1;
          UPPER'LIMIT ← UPPER'BOUND'LEB1;
       ENDIF;

* COMPUTE AND CHECK UPPER'BOUND
       UPPER'BOUND ← LOWER'BOUND + NO'OF'ELEMENTS - 1;
*      A CONSTANT OR PARAMETER TAILED WITH A VARIABLE FIELD CAUSES SPL
* TO GENERATE INCORRECT CODE, SO HERE'S THE KLUDGE.
       KLUDGE ← -1;
       CATASTROPHE IF UPPER'BOUND > KLUDGE$UPPER'LIMIT;

* CONSTRUCT AND RETURN THE DESCRIPTOR
       ARRAY'DESC$IAW'TYPE ← ARRAY'IAW;
       ARRAY'DESC$INDEXING'ORGIN ← LOWER'BOUND;
       ARRAY'DESC$ARRAY'TRAP'BIT ← 0;
       ARRAY'DESC$LEB ← LARGE'ELEMENT;
       ARRAY'DESC$MULTIPLIER ← ELEMENT'SIZE - 1;
       ARRAY'DESC$UPPER'LIMIT ← UPPER'BOUND;
       ARRAY'DESC$ARRAY'DESC'ADDR ← NORMAL'IAW@IAW'TYPE V'
          INDEXED@IAW'TAG V' 0@IAW'TRAP V' BASE'ADDRESS@IAW'ADDRESS;

       RETURN ARRAY'DESC;


       END;

       COMMON STRING'DEFS;

*      THIS COMMON BLOCK DEFINES ALL THE FIELDS USED TO MANIPULATE
* STRINGS WITH.

       INCLUDE ERROR'DEFS;

       DECLARE FIELD
          BP (0),            /* BEGIN POINTER                         */
          RP (1),            /* READ POINTER                          */
          WP (2),            /* WRITE POINTER                         */
          EP (3);            /* END POINTER                           */

       DECLARE FIELD
          CHAR'SIZE (0:2,3), /* THE SIZE OF CHARACTERS IN THE STRING  */
                             /*   (0 = 6 BITS, 1 = 8 BITS,            */
                             /*   2 = 12 BITS, AND 3 = 24 BITS)       */
          CHAR'POSITION      /* THE CHARACTER POSITION IN THE WORD    */
            (0:4,5);

       DECLARE FIELD         /* FOR 6 BIT CHARACTERS                  */
          CHAR6'0 (0:0,5),
          CHAR6'1 (0:6,11),
          CHAR6'2 (0:12,17),
          CHAR6'3 (0:18,23);

       DECLARE FIELD         /* FOR 8 BIT CHARACTERS                  */
          CHAR8'0 (0:0,7),
          CHAR8'1 (0:8,15),
          CHAR8'2 (0:16,23);

       DECLARE FIELD         /* FOR 12 BIT CHARACTERS                 */
          CHAR12'0 (0:0,11),
          CHAR12'1 (0:12,23);

       DECLARE STRING FIELD  /* A KLUDGE SO THAT WHEN THE POINTER TO  */
          STRING'DESC (0);   /*   ONTO STRING DESCRIPTOR IS ASSIGNED  */
                             /*   TO ANOTHER, SPL WILL DO THE RIGHT   */
                             /*   THING.                              */



       END;

       PROGRAM APPEND;

*      THIS PROGRAM BLOCK TAKES AS ITS ARGUMENTS TWO STRINGS WHICH IT
* ATTEMPTS TO CONCATENATE TOGETHER.  THERE ARE TWO ENTRY POINTS TO THE
* PROGRAM, SCOPY, AND APPEND.  SCOPY IS JUST A SPECIAL CASE OF APPEND
* IN WHICH ONE STRING WILL BE COPIED TO THE BEGINNING OF THE OTHER
* STRING.
*      I TRIED TO BE CONSISTENT AND DECLARE ALL VARIABLES EXPLICITLY,
* IN "DECLARE" STATEMENTS, BUT THERE SEEM TO BE PROBLEMS WITH DECLARING
* A STRING WHICH WILL BE AN ARGUMENT TO A FUNCTION AND LATER IN THE
* FUNCTION DEFINITION, INFORMING SPL THAT THAT STRING WILL BE CALLED
* BY WHAT I CONSIDER TO BE CALL BY NAME.

       INCLUDE STRING'DEFS;

       DECLARE STRING
          ADDENDUM,          /* THE STRING FROM WHICH CHARACTERS ARE  */
                             /*   COPIED INTO THE FIRST ARGUMENT      */
*         OBJECT,            /* THE STRING TO WHICH CHARACTERS WILL   */
                             /*   BE COPIED                           */
          WORKING'NAME;      /* TO KEEP SPL HAPPY                     */

       DECLARE INTEGER
          COUNT,             /* JUST A COUNTER FOR A FOR LOOP         */
          LENGTH'ADDENDUM;   /* LENGTH OF THE STRING ADDENDUM         */



* SCOPY - COPY THE SECOND STRING INTO THE FIRST
       UNKNOWN FUNCTION SCOPY(STRING @OBJECT, ADDENDUM), FRETURN;
       OBJECT.WP ← OBJECT.RP ← OBJECT.BP;



* APPEND - APPEND THE SECOND STRING TO THE FIRST
       UNKNOWN FUNCTION APPEND(STRING @OBJECT, ADDENDUM), FRETURN;
       WORKING'NAME ← OBJECT.STRING'DESC;
       CATASTROPHE IF ADDENDUM$CHAR'SIZE # WORKING'NAME$CHAR'SIZE;
       LENGTH'ADDENDUM ← LENGTH(ADDENDUM);
       WARNING IF
          LENGTH'ADDENDUM > LNGDES(WORKING'NAME$WP, WORKING'NAME$EP);

       FOR COUNT ← 1 TO LENGTH'ADDENDUM DO;
          WCI(GCI(ADDENDUM), WORKING'NAME);
       ENDFOR;

       OBJECT.WP ← WORKING'NAME$WP;
       RETURN;


       END;

       PROGRAM APPEND'WO'CHECK;

*      THIS PROGRAM BLOCK CONTAINS FUNCTIONS VERY SIMILAR TO APPEND AND
* SCOPY.  THE DIFFERENCES BETWEEN SCOPY'WO'CHECK AND SCOPY AND APPEND'-
* WO'CHECK AND APPEND IS THAT THE CHARACTER SIZES OF THE TWO STRINGS
* AREN'T CHECKED.  SO THESE FUNCTIONS WOULD BE USED TO COPY CHARACTERS
* FROM A 6 BIT BYTE STRING TO AN 8 BIT BYTE STRING.

       INCLUDE STRING'DEFS;

       DECLARE STRING
          ADDENDUM,          /* THE STRING FROM WHICH CHARACTERS ARE  */
                             /*   COPIED INTO THE FIRST ARGUMENT      */
*         OBJECT,            /* THE STRING TO WHICH CHARACTERS WILL   */
                             /*   BE COPIED                           */
          WORKING'NAME;      /* TO KEEP SPL HAPPY                     */

       DECLARE INTEGER
          COUNT,             /* JUST A COUNTER FOR A FOR LOOP         */
          LENGTH'ADDENDUM;   /* LENGTH OF THE STRING ADDENDUM         */



* SCOPY - COPY THE SECOND STRING INTO THE FIRST
       UNKNOWN FUNCTION SCOPY'WO'CHECK(STRING @OBJECT, ADDENDUM),
          FRETURN;
       OBJECT.WP ← OBJECT.RP ← OBJECT.BP;



* APPEND - APPEND THE SECOND STRING TO THE FIRST
       UNKNOWN FUNCTION APPEND'WO'CHECK(STRING @OBJECT, ADDENDUM),
          FRETURN;
       WORKING'NAME ← OBJECT.STRING'DESC;
       LENGTH'ADDENDUM ← LENGTH(ADDENDUM);
       WARNING IF
          LENGTH'ADDENDUM > LNGDES(WORKING'NAME$WP, WORKING'NAME$EP);

       FOR COUNT ← 1 TO LENGTH'ADDENDUM DO;
          WCI(GCI(ADDENDUM), WORKING'NAME);
       ENDFOR;

       OBJECT.WP ← WORKING'NAME$WP;
       RETURN;


       END;

       PROGRAM SUBSTR;

*      THIS FUNCTION IS JUST ANOTHER SPECIAL CASE OF THE FUNCTION APPEND.
* IT WOULD BE POSSIBLE TO PUT THIS FUNCTION WITH THE FUNCTIONS APPEND
* AND SCOPY, BUT IT WOULD BE MESSY AND NOT WORTH THE EFFORT.
*      THIS FUNCTION APPENDS TO THE FIRST STRING THE SUBSTRING OF THE
* SECOND STRING STARTING AT THE CHARACTER POSITION SPECIFIED BY START'
* CHARACTER AND CONTINUING FOR NUMBER'OF'CHARS.  IF NUMBER'OF'CHARS IS
* NEGATIVE, THE REMAINDER OF THE FIRST STRING IS APPENDED TO THE FIRST.

       INCLUDE STRING'DEFS;

       DECLARE INTEGER
          COUNTER,
          NUMBER'OF'CHARS,   /* THE NUMBER OF CHARACTERS OF THE STRING*/
                             /*   SECOND TO BE APPENDED ONTO THE      */
                             /*   STRING FIRST                        */
          START'POSITION;    /* THE INITIAL CHARACTER OF THE STRING   */
                             /*   SECOND TO BE COPIED INTO THE STRING */
                             /*   FIRST (STARTS FROM 0)              */

       DECLARE STRING
*         OBJECT,            /* THE STRING TO WHICH CHARACTERS WILL   */
                             /*   BE COPIED                           */
          REFERENCE,         /* THE STRING FROM WHICH CHARACTERS ARE  */
                             /*   COPIED INTO THE FIRST ARGUMENT      */
          WORKING'NAME;      /* TO KEEP SPL HAPPY                     */


       UNKNOWN FUNCTION SUBSTR(STRING @OBJECT, REFERENCE,
          START'POSITION, NUMBER'OF'CHARS), FRETURN;

       WORKING'NAME ← OBJECT.STRING'DESC;
       FRETURN IF REFERENCE$CHAR'SIZE # WORKING'NAME$CHAR'SIZE;
       FRETURN IF START'POSITION < 0;
       REFERENCE$RP ← INCDES(REFERENCE$RP, START'POSITION);
       IF NUMBER'OF'CHARS < 0 DO;
          FRETURN IF         /* THE STRING WON'T FIT INTO OBJECT      */
             LENGTH(REFERENCE) > LNGDES(WORKING'NAME$WP, WORKING'NAME$EP);
          WCI(GCI(REFERENCE//DONE), WORKING'NAME) WHILE 1;
       ENDIF;
       FRETURN IF            /* REFERENCE DOESN'T HAVE THAT MANY CHARS*/
          NUMBER'OF'CHARS > LNGDES(REFERENCE$RP, REFERENCE$EP);
       REFERENCE$WP ← INCDES(REFERENCE$RP, NUMBER'OF'CHARS);
       FRETURN IF            /* THE STRING WON'T FIT INTO OBJECT      */
          NUMBER'OF'CHARS > LNGDES(WORKING'NAME$WP, WORKING'NAME$EP);
       WCI(GCI(REFERENCE), WORKING'NAME) FOR COUNTER ← 1 TO NUMBER'OF'CHARS;
DONE:  OBJECT.WP ← WORKING'NAME$WP;

       RETURN;


       END;

       PROGRAM SUBSTR'WO'CHECK;

*      THIS FUNCTION IS JUST ANOTHER SPECIAL CASE OF THE FUNCTION APPEND.
* IT WOULD BE POSSIBLE TO PUT THIS FUNCTION WITH THE FUNCTIONS APPEND
* AND SCOPY, BUT IT WOULD BE MESSY AND NOT WORTH THE EFFORT.
*      THIS FUNCTION APPENDS TO THE FIRST STRING THE SUBSTRING OF THE
* SECOND STRING STARTING AT THE CHARACTER POSITION SPECIFIED BY START'
* CHARACTER AND CONTINUING FOR NUMBER'OF'CHARS.  IF NUMBER'OF'CHARS IS
* NEGATIVE, THE REMAINDER OF THE SECOND STRING IS APPENDED TO THE FIRST.

       INCLUDE STRING'DEFS;

       DECLARE INTEGER
          COUNTER,
          NUMBER'OF'CHARS,   /* THE NUMBER OF CHARACTERS OF THE STRING*/
                             /*   SECOND TO BE APPENDED ONTO THE      */
                             /*   STRING FIRST                        */
          START'POSITION;    /* THE INITIAL CHARACTER OF THE STRING   */
                             /*   SECOND TO BE COPIED INTO THE STRING */
                             /*   FIRST (STARTS FROM 0)               */

       DECLARE STRING
*         OBJECT,            /* THE STRING TO WHICH CHARACTERS WILL   */
                             /*   BE COPIED                           */
          REFERENCE,         /* THE STRING FROM WHICH CHARACTERS ARE  */
                             /*   COPIED INTO THE FIRST ARGUMENT      */
          WORKING'NAME;      /* TO KEEP SPL HAPPY                     */


       UNKNOWN FUNCTION SUBSTR'WO'CHECK(STRING @OBJECT, REFERENCE,
          START'POSITION, NUMBER'OF'CHARS), FRETURN;

       WORKING'NAME ← OBJECT.STRING'DESC;
       FRETURN IF START'POSITION < 0;
       REFERENCE$RP ← INCDES(REFERENCE$RP, START'POSITION);
       IF NUMBER'OF'CHARS < 0 DO;
          FRETURN IF         /* THE STRING WON'T FIT INTO OBJECT      */
             LENGTH(REFERENCE) > LNGDES(WORKING'NAME$WP, WORKING'NAME$EP);
          WCI(GCI(REFERENCE//DONE), WORKING'NAME) WHILE 1;
       ENDIF;
       FRETURN IF            /* REFERENCE DOESN'T HAVE THAT MANY CHARS*/
          NUMBER'OF'CHARS > LNGDES(REFERENCE$RP, REFERENCE$EP);
       REFERENCE$WP ← INCDES(REFERENCE$RP, NUMBER'OF'CHARS);
       FRETURN IF            /* THE STRING WON'T FIT INTO OBJECT      */
          NUMBER'OF'CHARS > LNGDES(WORKING'NAME$WP, WORKING'NAME$EP);
       WCI(GCI(REFERENCE), WORKING'NAME) FOR COUNTER ← 1 TO NUMBER'OF'CHARS;
DONE:  OBJECT.WP ← WORKING'NAME$WP;

       RETURN;


       END;

       PROGRAM INDEX;

*      THIS FUNCTION DETERMINES THE POSITION OF THE STRING SPECIFIED BY
* THE SECOND ARGUMENT, IN THE STRING SPECIFIED BY THE FIRST ARGUMENT.
* THIS FUNCTION FAILS IF THE SECOND ARGUMENT DOESN'T APPEAR IN THE
* FIRST ARGUMENT OR THE TWO STRINGS HAVE DIFFERENT CHARACTER SIZES.
* VALUES RETURNED START FROM 0.

       INCLUDE STRING'DEFS;

       DECLARE INTEGER
          CHAR1,
          CHAR2,
          PREVIOUS'MATCH,    /* FLAG SIGNALING THAT THE PREVIOUS CHAR-*/
                             /*   ACTERS MATCHED                      */
          SAVE'IN'RP,        /* THE INITIAL CONDITION OF LOOKING'IN'S */
                             /*   READ POINTER BEFORE WE START        */
          SAVE'FOR'RP,       /* THE INITIAL CONDITION OF LOOKING'FOR'S*/
                             /*   READ POINTER BEFORE WE START        */
          START'OF'STRING;   /* THE POSITION IN THE FIRST STRING WHERE*/
                             /*   THE SECOND BEGINS                   */
       DECLARE STRING
          LOOKING'FOR,       /* THE PATTERN WE ARE LOOKING FOR        */
          LOOKING'IN;        /* THE OBJECT WE ARE SEARCHING FOR THE   */
                             /*   PATTERN IN                          */



       FUNCTION INDEX(LOOKING'IN, LOOKING'FOR), FRETURN;

       FRETURN IF LOOKING'FOR$CHAR'SIZE # LOOKING'IN$CHAR'SIZE;
       FRETURN IF LENGTH(LOOKING'FOR) > LENGTH(LOOKING'IN);
       SAVE'IN'RP ← LOOKING'IN$RP;
       SAVE'FOR'RP ← LOOKING'FOR$RP;
       PREVIOUS'MATCH ← 0;
       GOTO INDX1;

INDX0: WCD(CHAR1, LOOKING'IN) IF PREVIOUS'MATCH;
       LOOKING'FOR$RP ← SAVE'FOR'RP;
       PREVIOUS'MATCH ← 0;
INDX1: CHAR2 ← GCI(LOOKING'FOR//RETURN START'OF'STRING IF PREVIOUS'MATCH
          ELSE FRETURN);
INDX2: CHAR1 ← GCI(LOOKING'IN//FRETURN);
       IF CHAR1 = CHAR2 DO;
          GOTO INDX1 IF PREVIOUS'MATCH;
          PREVIOUS'MATCH ← -1;
          START'OF'STRING ← LNGDES(SAVE'IN'RP, LOOKING'IN$RP) - 1;
          GOTO INDX1;
       ELSE DO;
          GOTO INDX0 IF PREVIOUS'MATCH ELSE GOTO INDX2;
       ENDIF;

       END;

       PROGRAM INDEX'WO'CHECK;

*      THIS FUNCTION DETERMINES THE POSITION OF THE STRING SPECIFIED
* BY THE SECOND ARGUMENT IN THE STRING SPECIFIED BY THE FIRST ARGUMENT.
* THIS FUNCTION FAILS IF THE STRINGS DON'T HAVE THE SAME SIZE CHARACTERS
* OR THE SECOND ARGUMENT DOESN'T APPEAR IN THE FIRST.  THE VALUE RETURNED
* BY THIS FUNCTION IS THAT OF THE BEGINNING OF THE SECOND ARGUMENT
* RELATIVE TO THE READ POINTER OF THE FIRST ARGUMENT AT THE TIME OF THE
* CALL.
*      THE WAY THE FUNCTION WORKS IS AS FOLLOWS: THE FUNCTION WILL TRY
* TO LOOK FOR THE SECOND ARGUMENT(LOOKING'FOR) IN THE FIRST(LOOKING'IN)
* AS LONG AS LOOKING'IN IS AT LEAST AS LONG AS LOOKING'FOR.  MEETING
* THAT REQUIREMENT, CHARACTERS ARE READ FROM LOOKING'FOR AND LOOKING'IN:
* 1) IF THEY ARE UNEQUAL AND THE PREVIOUS CHARACTERS DIDN'T MATCH,
* THE READ POINTER OF LOOKING'IN IS DECREMENTED TO ALLOW THE FIRST
* CHARACTER OF IT TO BE READ AGAIN AND COMPARED TO THE NEXT CHARACTER
* OF LOOKING'FOR; 2) IF THEY ARE UNEQUAL, BUT THE PREVIOUS CHARACTERS
* MATCHED, THE READ POINTER OF LOOKING'IN IS DECREMENTED BY AN AMOUNT
* EQUAL TO THE NUMBER OF CONSECUTIVE PREVIOUS CHARACTERS OF LOOKING'FOR
* FOUND EQUAL TO THOSE IN LOOKING'IN; 3) IF THEY ARE EQUAL BUT THE
* PREVIOUS CHARACTERS DIDN'T MATCH, THE POSITION OF THE CHARACTER READ
* FROM LOOKING'IN RELATIVE TO THE ORIGINAL READ POINTER IS CALCULATED
* (IN CASE THIS IS THE BEGINNING OF A STRING EQUAL TO LOOKING'FOR);
* 4) IF THEY ARE EQUAL AND THE PREVIOUS CHARACTERS ALSO MATCHED, THE
* NEXT CHARACTERS OF THE STRINGS ARE CHECKED.

       INCLUDE STRING'DEFS;

       DECLARE INTEGER
          CHAR'FROM'FOR,
          CHAR'FROM'IN,
          PREVIOUS'MATCH,    /* A FLAG SIGNALING THAT THE PREVIOUS    */
                             /*   CHARACTERS MATCHED                  */
          LEN'PART'MATCH,    /* LENGTH OF THE SUB-STRING OF THE STRING*/
                             /*   WE ARE LOOKING FOR WHICH MATCHED    */
          SAVE'IN'RP,        /* THE INITIAL VALUE OF THE READ POINTER */
                             /*   OF LOOKING'IN                       */
          SAVE'FOR'RP,       /* THE INITIAL VALUE OF THE READ POINTER */
                             /*   OF LOOKING'FOR                      */
          START'STRING;      /* THE POSITION IN THE FIRST STRING WHERE*/
                             /*   THE SECOND BEGINS                   */

       DECLARE STRING
          LOOKING'FOR,       /* THE PATERN WE ARE LOOKING FOR         */
          LOOKING'IN;        /* THE OBJECT WE ARE SEARCHING FOR THE   */
                             /*   PATTERN IN                          */

       FUNCTION INDEX'WO'CHECK(LOOKING'IN, LOOKING'FOR), FRETURN;

       SAVE'IN'RP ← LOOKING'IN$RP;
       SAVE'FOR'RP ← LOOKING'FOR$RP;
       PREVIOUS'MATCH ← 0;
       WHILE LENGTH(LOOKING'FOR) <= LENGTH(LOOKING'IN) DO;
          CHAR'FROM'FOR ← GCI(LOOKING'FOR//
             RETURN START'STRING IF PREVIOUS'MATCH ELSE FRETURN);
          CHAR'FROM'IN ← GCI(LOOKING'IN//FRETURN);
          IF CHAR'FROM'FOR = CHAR'FROM'IN DO;
             IF NOT PREVIOUS'MATCH DO;
                PREVIOUS'MATCH ← -1;
                START'STRING ← LNGDES(SAVE'IN'RP, LOOKING'IN$RP) - 1;
             ENDIF;
          ELSEIF PREVIOUS'MATCH DO; * CHARS ARE UNEQUAL
             PREVIOUS'MATCH ← 0;
             LEN'PART'MATCH ← LNGDES(SAVE'FOR'RP, LOOKING'FOR$RP) - 1;
             LOOKING'IN$RP ← INCDES(LOOKING'IN$RP, -LEN'PART'MATCH);
             LOOKING'FOR$RP ← SAVE'FOR'RP;
          ELSE DO; * CHARS ARE UNEQUAL AND NOT PREVIOUS'MATCH
             LOOKING'FOR$RP ← INCDES(LOOKING'FOR$RP, -1);
          ENDIF;
       ENDFOR;
       FRETURN;



       END;

       PROGRAM SETUP'KLUDGE;

*      THIS FUNCTION DOES WHAT SETUP OUGHT TO DO -- TAKE A VARIABLE
* CHARACTER SIZE.  UNFORTUNATELY, THE ONLY WAY IT CAN DO IT IS BY DOING
* A SETUP FOR EACH POSSIBLE CHARACTER SIZE.

       INCLUDE STRING'DEFS;

       DECLARE INTEGER
          BEGIN'ADDRESS,
          CHARACTER'SIZE,
          LENGTH;

       DECLARE STRING
*         STR'DESC'POINTER,
          WORKING'NAME;



       UNKNOWN FUNCTION SETUP'KLUDGE(STRING @STR'DESC'POINTER, LENGTH,
          BEGIN'ADDRESS, CHARACTER'SIZE), FRETURN;

       WORKING'NAME ← STR'DESC'POINTER.STRING'DESC;
       IF CHARACTER'SIZE = 6 DO;
          SETUP(WORKING'NAME, LENGTH, BEGIN'ADDRESS, 6);
       ELSEIF CHARACTER'SIZE = 8 DO;
          SETUP(WORKING'NAME, LENGTH, BEGIN'ADDRESS, 8);
       ELSEIF CHARACTER'SIZE = 12 DO;
          SETUP(WORKING'NAME, LENGTH, BEGIN'ADDRESS, 12);
       ELSEIF CHARACTER'SIZE = 24 DO;
          SETUP(WORKING'NAME, LENGTH, BEGIN'ADDRESS, 24);
       ELSE DO;
          RUNTIME'FAILURE();
          FRETURN;
       ENDIF;
       STR'DESC'POINTER.STRING'DESC ← WORKING'NAME;

       RETURN;



       END;

       PROGRAM CNS;

*      THIS FUNCTION APPENDS A SINGLE PRECISION INTEGER TO A STRING
* AFTER CONVERTING THE INTEGER FROM INTERNAL REPRESENTATION TO CHAR-
* ATER REPRESENTATION.  THIS FUNCTION FAILS IF THE BASE THE NUMBER WILL
* BE CONVERTED TO IS OUTSIDE THE ALLOWABLE RANGE OF 2 TO 36, INCLUSIVE,
* OR IF THE STRING PASSED TO IT CAN'T HOLD ALL THE CHARACTERS OF THE 
* BER.

       INCLUDE STRING'DEFS;

       DECLARE INTEGER
          BASE,              /* THE BASE THE NUMBER WILL BE CONVERTED */
                             /*   TO                                  */
          CHAR,              /* THE CHARACTER TO WRITE INTO THE STRING*/
          COUNT,             /* JUST A COUNTER FOR FOR LOOPS          */
          LENGTH'TEMP,       /* LENGTH OF THE STRING TEMP             */
          NUMBER,            /* THE NUMBER TO CONVERT                 */
          NUMBER'OF'CHARS,   /* BITS (18-23) OF SIGN'NUM'CHARS        */
          SIGN'FLAG,         /* SET IF NEGATIVE NUMBERS ARE TO BE     */
                             /*   CONVERTED SIGNED                    */
          SIGN'NUM'CHARS;    /* DETERMINES IF THE NUMBER WILL BE      */
                             /*   SIGNED AND HOW MANY CHARACTERS TO   */
                             /*   GENERATE.  IF IT IS 0, IT WILL BE   */
                             /*   CONVERTED SIGNED AND WITHOUT PAD-   */
                             /*   DING OR TRUNCATION                  */

       DECLARE STRING
          TEMP (24),         /* A TEMPORARY STRING EACH DIGIT IS      */
          WORKING'NAME;      /* TO KEEP SPL HAPPY                     */
                             /*   WRITTEN INTO                        */



       UNKNOWN FUNCTION CNS(NUMBER, STRING @STRING'CREATED,
          SIGN'NUM'CHARS, BASE), FRETURN;

       WARNING IF BASE < 2 OR BASE > 36;
       WORKING'NAME ← STRING'CREATED.STRING'DESC;
       SIGN'FLAG ← (-1 IF SIGN'NUM'CHARS >= 0 AND NUMBER < 0 ELSE 0);
       NUMBER ← -NUMBER IF SIGN'FLAG;

* BE CLEVER AND WRITE THE STRING BACKWARDS
       TEMP$RP ← TEMP$WP ← TEMP$EP;

       IF NUMBER # 0 DO;
          WHILE NUMBER # 0 DO;
             .LDA NUMBER, LSHD -23, DIV BASE, STA NUMBER, STB CHAR;
             WCD(CHAR + ('0' IF CHAR < 10 ELSE 'A' - 10), TEMP);
          ENDFOR;
       ELSE DO;
          WCD('0', TEMP);
       ENDIF;

       WCD('-', TEMP) IF SIGN'FLAG;

* ALL WE NEED NOW IS HOW MANY CHARACTERS TO GENERATE
       NUMBER'OF'CHARS ← SIGN'NUM'CHARS A' 77B;
       LENGTH'TEMP ← LENGTH(TEMP);

* TRUNCATE CHARACTERS IF NECESSARY
       IF NUMBER'OF'CHARS # 0 AND NUMBER'OF'CHARS < LENGTH'TEMP DO;
          TEMP$RP ← INCDES(TEMP$EP, -NUMBER'OF'CHARS);

* OR PAD
       ELSEIF NUMBER'OF'CHARS # 0 AND NUMBER'OF'CHARS > LENGTH'TEMP DO;
          FOR COUNT ← LENGTH'TEMP + 1 TO NUMBER'OF'CHARS DO;
             WCI(' ', WORKING'NAME//WARNING);
          ENDFOR;
       ENDIF;

       FOR COUNT ← 1 TO LENGTH(TEMP) DO;
          CHAR ← GCI(TEMP);
          WCI(CHAR, WORKING'NAME//WARNING);
       ENDFOR;

FINISH:STRING'CREATED.WP ← WORKING'NAME$WP;
       RETURN;


       END;

       COMMON SEQ'FILE'DEFS;

*      THIS COMMON BLOCK CONTAINS THE DECLARATIONS OF IDENTIFIERS
* USED IN FILE HANDLING OPERATIONS.

       DECLARE ARRAYONE
          OPEN'FILE'TABLE[16];
                             /* ARRAY DETERMINING WHICH FILES ARE OPEN*/

       DECLARE FIELD
          PAGE'NUM'ADDR      /* THE PAGE NUMBER OF THE ADDRESS        */
             (0:6,12),
          PAGES'IN'FILE      /* NUMBER OF PAGES IN THE FILE           */
             (0:2,12),
          WORDS'IN'PAGE      /* WORD NUMBER IN THE LAST PAGE          */
             (0:13,23);

       DECLARE PARAMETER
          A'PAGE ← 2048;     /* WORDS TO A PAGE                       */

       DECLARE PARAMETER     /* FOR IOFLAG VALUES                     */
          READ'FILE ← 0,
          WRITE'FILE ← 1,
          APPEND'FILE ← 2;

       DECLARE PARAMETER     /* FOR OBJECT TYPES                      */
          SMALL'FILE ← 0,
          LARGE'FILE ← 1;

       DECLARE PARAMETER     /* FOR FILE TYPES                        */
          SUBCOMMAND'FILE ← 6'9SUB',
          SAVE'FILE ← 6'9SAV',
          BINARY'FILE ← 6'9BIN',
          SYMBOLIC'FILE ← 6'9SYM',
          DUMP'FILE ← 6'9DMP',
          UNKNOWN'FILE ← 6'    ';

       DECLARE PARAMETER     /* FOR THE MAXIMUM LENGTH OF FILENAMES   */
          LENGTH'PFS'NAMES ← 13,
          LENGTH'TSS'NAMES ← 16;



       END;

       COMMON WINDOW'DEFS;
       
* THIS COMMON BLOCK DECLARES THE STRUCTURE OF A WINDOW DESCRIPTOR

       DECLARE PARAMETER
          NUM'SEQ'FILES ← 2;

       DECLARE ARRAY
          SEQ'FILE'TABLE[NUM'SEQ'FILES:21];

       DECLARE SIGNED FIELD
          PAGE'IN'WINDOW (0:0,11); /* PAGE NUMBER OF THE FILE         */
       
       DECLARE FIELD
          PMT'INDEX (0:12,19),     /* PMT INDEX OF THE FILE           */
          WINDOW'IN'USE (0:20,20),
                                  /* BIT SIGNALING THE WINDOW IS IN  */
                                   /*   USE                           */
          LARGE'OR'SMALL (0:21,21),/* LARGE OR SMALL FILE             */
          OPERATION (0:22,23),     /* BITS REPRESENTING WHAT WILL BE  */
                                   /*   DONE TO THE FILE              */
          FILE'NUM (1:1,5),        /* NUMBER OF THE FILE              */
          WINDOW'ADDRESS (1:6,23), /* ADDRESS OF THE WINDOW IN USE    */
          CHARACTER'SIZE (2:0,5),  /* NUMBER OF BITS PER CHARACTER    */
          CHARS'PER'WORD (2:6,8),  /* NUMBER OF CHARACTERS PER WORD   */
          CHARS'PER'PAGE (2:9,23), /* NUMBER OF CHARACTERS PER PAGE   */
          NAME'STORAGE (3);        /* STORAGE FOR THE M1 FORMATTED    */
                                   /*   NAME                          */

       DECLARE STRING FIELD
          READ'DESC (11);          /* STRING DESCRIPTOR FOR A FILE    */
                                   /*   WHICH WILL BE READ            */

       DECLARE FIELD
          CHARS'LEFT (15);         /* NUMBER OF CHARACTERS YET TO BE  */
                                   /*   READ FROM THE FILE (AFTER THE */
                                   /*   CURRENT PAGE HAS BEEN READ)   */

       DECLARE STRING FIELD
          WRITE'DESC (16);         /* STRING DESCRIPTOR OF A FILE     */
                                   /*   WHICH WILL BE READ            */

       DECLARE FIELD
          LENGTH'IN'CHARS (20);    /* NUMBER OF CHARACTERS ALREADY    */
                                   /*   WRITTEN INTO THE FILE (AFTER  */
                                   /*   THE LAST PAGE HAD BEEN        */
                                   /*   WRITTEN)                      */
       
       DECLARE ARRAY
          SEQ'FILE'WINDOWS[NUM'SEQ'FILES] ← (100000B, 104000B);


       END;

       COMMON SPECIAL'CHARS;

*      THIS COMMON BLOCK DECLARES ALL THE SPECIAL CHARACTERS USED IN
* THIS PROGRAM OTHER THAN THOSE NEED BY THE DTP FUNCTIONS.

       DECLARE PARAMETER     /* FOR 940 CHARACTER CONSTANTS           */
          BLANK ← 0,
          MB ← 135B,         /*   940 MULTIPLE BLANK CHARACTER        */
          EOF ← 137B,        /*   940 END OF FILE CHARACTER           */
          NULL ← 140B,
          LF ← 152B,
          CR ← 155B;

       DECLARE PARAMETER     /* FOR M1 CHARACTER CONSTANTS            */
          ESCAPE'CHAR ← 37B, /*   FOR I/O THROUGH THE CHIO            */
          M1'MB ← 200B,
          M1'NULL ← 300B,
          M1'NL ← 307B,
          M1'LF ← 310B,
          M1'CR ← 355B;

       DECLARE PARAMETER     /* ASCII CHARACTER CONSTANTS             */
          ASCII'NULL ← 0,
          ASCII'LF ← 12B,
          ASCII'CR ← 15B,
          ASCII'BLANK ← 40B;


       END;

       COMMON ASCII'940'TABLES;

* TRANSLATES BETWEEN ASCII AND 940

       INCLUDE SPECIAL'CHARS;

       DECLARE ARRAY TRANS'TBL'940'AS[200B] ← (ASCII'NULL);
       MACRO CNVRT'940'ASCII (CHAR) ←
          DECLARE ARRAY TRANS'TBL'940'AS[CHAR] ← ;

       CNVRT'940'ASCII (  0B) ( 40B,  41B,  42B,  43B,  44B,  45B,  46B,  47B);
       CNVRT'940'ASCII ( 10B) ( 50B,  51B,  52B,  53B,  54B,  55B,  56B,  57B);
       CNVRT'940'ASCII ( 20B) ( 60B,  61B,  62B,  63B,  64B,  65B,  66B,  67B);
       CNVRT'940'ASCII ( 30B) ( 70B,  71B,  72B,  73B,  74B,  75B,  76B,  77B);
       CNVRT'940'ASCII ( 40B) (100B, 101B, 102B, 103B, 104B, 105B, 106B, 107B);
       CNVRT'940'ASCII ( 50B) (110B, 111B, 112B, 113B, 114B, 115B, 116B, 117B);
       CNVRT'940'ASCII ( 60B) (120B, 121B, 122B, 123B, 124B, 125B, 126B, 127B);
       CNVRT'940'ASCII ( 70B) (130B, 131B, 132B, 133B, 134B, 135B, 136B, 137B);
       CNVRT'940'ASCII (100B) (140B, 141B, 142B, 143B, 144B, 145B, 146B, 147B);
       CNVRT'940'ASCII (110B) (150B, 151B, 152B, 153B, 154B, 155B, 156B, 157B);
       CNVRT'940'ASCII (120B) (160B, 161B, 162B, 163B, 164B, 165B, 166B, 167B);
       CNVRT'940'ASCII (130B) (170B, 171B, 172B, 173B, 174B, 174B, 176B, 177B);
       CNVRT'940'ASCII (140B) (  0B,   1B,   2B,   3B,   4B,   5B,   6B,   7B);
       CNVRT'940'ASCII (150B) ( 10B,  11B,  12B,  13B,  14B,  15B,  16B,  17B);
       CNVRT'940'ASCII (160B) ( 20B,  21B,  22B,  23B,  24B,  25B,  26B,  27B);
       CNVRT'940'ASCII (170B) ( 30B,  31B,  32B,  33B,  34B,  35B,  36B,  37B);


       DECLARE ARRAY TRANS'TBL'AS'940[200B] ← (NULL);
       MACRO CNVRT'ASCII'940 (CHAR) ←
          DECLARE ARRAY TRANS'TBL'AS'940[CHAR] ← ;

       CNVRT'ASCII'940 (  0B) (140B, 141B, 142B, 143B, 144B, 145B, 146B, 147B);
       CNVRT'ASCII'940 ( 10B) (150B, 151B, 152B, 153B, 154B, 155B, 156B, 157B);
       CNVRT'ASCII'940 ( 20B) (160B, 161B, 162B, 163B, 164B, 165B, 166B, 167B);
       CNVRT'ASCII'940 ( 30B) (170B, 171B, 172B, 173B, 174B, 175B, 176B, 177B);
       CNVRT'ASCII'940 ( 40B) (  0B,   1B,   2B,   3B,   4B,   5B,   6B,   7B);
       CNVRT'ASCII'940 ( 50B) ( 10B,  11B,  12B,  13B,  14B,  15B,  16B,  17B);
       CNVRT'ASCII'940 ( 60B) ( 20B,  21B,  22B,  23B,  24B,  25B,  26B,  27B);
       CNVRT'ASCII'940 ( 70B) ( 30B,  31B,  32B,  33B,  34B,  35B,  36B,  37B);
       CNVRT'ASCII'940 (100B) ( 40B,  41B,  42B,  43B,  44B,  45B,  46B,  46B);
       CNVRT'ASCII'940 (110B) ( 50B,  51B,  52B,  53B,  54B,  55B,  56B,  57B);
       CNVRT'ASCII'940 (120B) ( 60B,  61B,  62B,  63B,  64B,  65B,  66B,  67B);
       CNVRT'ASCII'940 (130B) ( 70B,  71B,  72B,  73B,  74B,  75B,  76B,  77B);
       CNVRT'ASCII'940 (140B) (100B, 101B, 102B, 103B, 104B, 105B, 106B, 107B);
       CNVRT'ASCII'940 (150B) (110B, 111B, 112B, 113B, 114B, 115B, 116B, 117B);
       CNVRT'ASCII'940 (160B) (120B, 121B, 122B, 123B, 123B, 125B, 126B, 127B);
       CNVRT'ASCII'940 (170B) (130B, 131B, 132B, 133B, 134B, 135B, 136B, 137B);



       END;

       COMMON MESSAGES;

*      THIS COMMON BLOCK JUST DECLARES ALL THE ERROR MESSAGES THAT MAY
* BE PRINTED OUT BY THIS PROGRAM.

       MACRO PRINT'ERROR ←
          VALUE OUTPUT'STRING(ERROR'MESSAGES[ERROR'NUMBER]) & RETURN:
          ERROR'NUMBER;

       DECLARE STRING ARRAY
          ERROR'MESSAGES[50] ← ("");

       MACRO PROGRAM'ERROR (X) ← DECLARE STRING ARRAY ERROR'MESSAGES[X];

       PROGRAM'ERROR(0) ← "INVALID ARGUMENTS FOR CON'ARRAY'DESC&/";
       PROGRAM'ERROR(1) ← "COULDN'T WRITE CHARACTER INTO THE STRING&/";
       PROGRAM'ERROR(2) ← "COULDN'T READ CHARACTER FROM THE STRING&/";
       PROGRAM'ERROR(3) ← "CAN'T APPEND THE STRING&/";
       PROGRAM'ERROR(4) ← "INVALID ARGUMENTS FOR CNS&/";
       PROGRAM'ERROR(5) ← "INVALID ARGUMENTS FOR CSN&/";
       PROGRAM'ERROR(6) ← "EXPECTED PARAMETER WITH COMMAND&/";

* ERROR MESSAGES GENERATED BY RUN
       PROGRAM'ERROR(10) ← "COMMAND NOT FOUND&/";
       PROGRAM'ERROR(11) ← "COMMAND IS AMBIGUOUS&/";
       PROGRAM'ERROR(12) ← "COMMAND SPECIFICATION ERROR&/";

* ERROR MESSAGES GENERATED BY GET'FILENAME
       PROGRAM'ERROR(15) ← "FILE NOT FOUND&/";
       PROGRAM'ERROR(16) ← "FILE NAME IS AMBIGUOUS&/";
       PROGRAM'ERROR(17) ← "OBJECT NAMED IS NOT A FILE&/";
       PROGRAM'ERROR(18) ← "FILE NAME SPECIFICATION ERROR&/";

* ERROR MESSAGES GENERATED BY ACQUIRE'ENTRY
       PROGRAM'ERROR(20) ← "SORRY, QUEUE FULL&/";

* ERROR MESSAGES GENERATED BY DEL'LIST'ENTRY AND QUEUE
       PROGRAM'ERROR(25) ← "NO SUCH COMMAND ON THE QUEUE&/";

* SYSTEM ERRORS
       PROGRAM'ERROR(30) ← "SYSTEM ERROR&/";




       END;

       COMMON GLOBAL'VARIABLES;

*      THIS BLOCK CONTAINS GENERAL CONSTANTS AND VARIABLES USED
* THROUGHOUT THE PROGRAM

       INCLUDE MONITOR'CALLS, UTILITY'CALLS, STRING'DEFS, WINDOW'DEFS,
          SPECIAL'CHARS, MESSAGES, SEQ'FILE'DEFS;

       DECLARE PARAMETER
          MOST'POSSIBLE ← -1,
          HP'TTY'LINE ← 19,
          HP'READ'LINE ← 2*HP'TTY'LINE,
          HP'WRITE'LINE ← HP'READ'LINE + 1,
          PDP'TTY'LINE ← 17,
          PDP'READ'LINE ← 2*PDP'TTY'LINE,
          PDP'WRITE'LINE ← PDP'READ'LINE + 1;

       DECLARE PARAMETER NUM'LEGAL'CMDS ← 8;

       DECLARE STRING ARRAY LEGAL'COMMANDS[NUM'LEGAL'CMDS] ←
          ("CLEANUP-ELF", "LOAD-ELF", "SEND-ELF",
           "CLEANUP-HP", "LOAD-HP", "SEND-HP", "ASSEMBLE-HP",
           "FINISH");

       DECLARE UNKNOWN EXTERNAL
          CLEANUP'LINE, LOAD'FROM'FILE, SEND'FILE, ASSEMBLE'FILE;

       DECLARE FUNCTION ARRAY ACTION'FNCS[NUM'LEGAL'CMDS] ←
          (CLEANUP'LINE, LOAD'FROM'FILE, SEND'FILE,
           CLEANUP'LINE, LOAD'FROM'FILE, SEND'FILE, ASSEMBLE'FILE,
           EXIT);

       DECLARE ARRAY LINES'INVOLVED[NUM'LEGAL'CMDS] ←
          (PDP'WRITE'LINE, PDP'WRITE'LINE, PDP'WRITE'LINE,
           HP'WRITE'LINE, HP'WRITE'LINE, HP'WRITE'LINE, HP'WRITE'LINE,
           -1);

       DECLARE ARRAY FILE'REQUIRED[NUM'LEGAL'CMDS] ←
          (0, 1, 1, 0, 1, 1, 1, 0);

       DECLARE ARRAY TYPE'ASSUMED[NUM'LEGAL'CMDS] ←
          (-1, BINARY'FILE, SYMBOLIC'FILE,
           -1, BINARY'FILE, SYMBOLIC'FILE, SYMBOLIC'FILE,
           -1);

       DECLARE PARAMETER     /* FOR SETTING FLAGS                     */
          FALSE ← 0,
          TRUE ← 1;

       DECLARE INTEGER
          COMMAND'INDEX,     /* INTO ARRAY OF LEGAL COMMANDS          */
          CHIO'WATCH,        /* CHIO INTERRUPT NUMBER                 */
          DATA'LINE,         /* THE OUTPUT HALF OF THE LOGICAL DEVICE */
                             /*   INPUT OR OUTPUT IS TO BE PERFORMED  */
                             /*   ON                                  */
          FINISH'INDEX,
          INIT'STACK'LEVEL,  /* STACK LEVEL UPON ENTRY                */
          THIS'PROCESS,      /* PROCESS NUMBER                        */
          THIS'SUB'PROCESS;  /* CURRENT SUB-PROCESS INDEX INTO THE SPT*/

       DECLARE INTEGER       /* FOR ASSEMBLE'FILE                     */
          BLOCK'SIZE,
          DATA'COUNT,
          LABEL'INDEX,
          NULL'COUNT;

       DECLARE STRING        /* FOR ASSEMBLE'FILE                     */
          INPUT'DATA'BLK(4*80);



       END;

       PROGRAM INITIAL'DRIVER;

*      THIS FUNCTION INITIALIZES WHATEVER IT HAS TO BEFORE EXECUTING ANY
* OF THE POSSIBLE COMMANDS.  IF THE PROCESS WAS ENTERED BY CALLING ONE
* OF THE LINKS TO THIS PROGRAM, ONLY THE SPECIFIED ACTION IS TAKEN AND
* CONTROL THEN RETURNS TO THE COMMAND PROCESSOR.  IF, HOWEVER, THIS
* PROGRAM WAS CALLED ITSELF, THE PROGRAM WILL EXECUTE ALL THE LEGAL
* COMMANDS SPECIFIED BY THE USER.  CONTROL RETURNS TO THE COMMAND PRO-
* CESSOR ONLY AFTER A "FINISH" COMMAND IS TYPED.

       INCLUDE GLOBAL'VARIABLES;

       DECLARE INTEGER
          OPEN'FILE'NUM,
          PREVIOUS'VALUE,    /* OF THE CHIO TABLE ENTRY               */
          SEQ'FILE'NUM,
          TM'BITS'SET;

       DECLARE STRING
          COMMAND'LINE(100), /* LINE TYPED BY THE USER TO THE EXEC    */
          COMMAND(30),       /* THE COMMAND THE USER WANTS EXECUTED   */
          FILE'NAME(30);



       FUNCTION FUNCTION INITIAL'DRIVER();

* INITIALIZE FILE WINDOWS
       SEQ'FILE'TABLE[SEQ'FILE'NUM]$WINDOW'IN'USE ← FALSE
          FOR SEQ'FILE'NUM ← 0 TO NUM'SEQ'FILES - 1;
       OPEN'FILE'TABLE[OPEN'FILE'NUM] ← -1
          FOR OPEN'FILE'NUM ← 1 TO 16;

* DETERMINE THE PROCESS PARAMETERS
       THIS'PROCESS ← READ'PROC'PARAM('PRT'//DISTRESS);
       THIS'SUB'PROCESS ← READ'SPS'PARAM('CSP'//DISTRESS);
       INIT'STACK'LEVEL ← READ'SPS'PARAM('CSL'//DISTRESS);
       TM'BITS'SET ← READ'SPT'FIELD(THIS'SUB'PROCESS, 'TM'//DISTRESS);
       SET'SPT'FIELD(THIS'SUB'PROCESS, 'TM', (TM'BITS'SET V' 1)//DISTRESS);
       CHIO'WATCH ← GET'INT'NUM('CHI'//DISTRESS);
       FINISH'INDEX ← ABRV'LKP("FINISH", LEGAL'COMMANDS//DISTRESS);

*      CHECK TO SEE IF THE COMMAND TO BE EXECUTED IS SPECIFIED IN THE
* UTILITY'S COMMAND LINE.
       COMMAND'LINE ← GET'COM'LINE(COMMAND'LINE//DISTRESS);
       COMMAND ← GET'PARAM(COMMAND'LINE);
       COMMAND'INDEX ← ABRV'LKP(COMMAND, LEGAL'COMMANDS//
             HP'11'DRIVER(): ERROR'CODE, ERROR'NUMBER);
       EXIT() IF COMMAND'INDEX = FINISH'INDEX;
       FILE'NAME ← GET'FILENAME(FILE'NAME, COMMAND'LINE) IF
          FILE'REQUIRED[COMMAND'INDEX];
       DATA'LINE ← LINES'INVOLVED[COMMAND'INDEX];
       PREVIOUS'VALUE ← ACQUIRE'LINE(DATA'LINE/2);
       (ACTION'FNCS[COMMAND'INDEX])(FILE'NAME);
       RETURN'LINE(DATA'LINE/2, PREVIOUS'VALUE);
       EXIT();



       END;

       PROGRAM HP'11'DRIVER;

*      THIS FUNCTION IS THE MAIN DRIVER WHEN THIS PROGRAM IS CALLED.  IF
* THE USER TYPES A CONTROL-K FROM HERE ON, THE TRAP HANDLER (SP'TRAP'-
* HANDLER) WILL CALL THIS FUNCTION THROUGH ANOTHER ENTRY POINT SO THAT
* HOPEFULLY ACTIONS WILL BE WELL CONTROLLED.

       INCLUDE GLOBAL'VARIABLES;

       DECLARE INTEGER
          PREVIOUS'VALUE;    /* OF THE CHIO TABLE ENTRY               */

       DECLARE STRING
          COMMAND'LINE(100), /* LINE TYPED BY USER (MAY CONTAIN BOTH  */
                             /*   COMMAND AND FILE NAME)              */
          COMMAND(30),       /* STRING HOLDING THE COMMAND THE USER   */
                             /*   WANTS EXECUTED                      */
          FILE'NAME(30);



       UNKNOWN FUNCTION HP'11'DRIVER();

       WHILE 1 DO;
          WHILE 1 DO;
             OUTPUT'STRING("←");
             COMMAND'LINE ← INPUT'STRING(COMMAND'LINE);
             COMMAND ← GET'PARAM(COMMAND'LINE);
             COMMAND'INDEX ← ABRV'LKP(COMMAND, LEGAL'COMMANDS//
                BAD'COMMAND: ERROR'CODE, ERROR'NUMBER);
             EXIT() IF COMMAND'INDEX = FINISH'INDEX;
             FILE'NAME ← GET'FILENAME(FILE'NAME, COMMAND'LINE) IF
                FILE'REQUIRED[COMMAND'INDEX];
             DATA'LINE ← LINES'INVOLVED[COMMAND'INDEX];
             PREVIOUS'VALUE ← ACQUIRE'LINE(DATA'LINE/2);
             (ACTION'FNCS[COMMAND'INDEX])(FILE'NAME);
             RETURN'LINE(DATA'LINE/2, PREVIOUS'VALUE);
          ENDFOR;

BAD'COMMAND:
          IF ERROR'CODE = 'NNF' DO;
             OUTPUT'STRING(ERROR'MESSAGES[10]);
          ELSEIF ERROR'CODE = 'NAM' DO;
             OUTPUT'STRING(ERROR'MESSAGES[11]);
          ELSE DO;
             OUTPUT'STRING(ERROR'MESSAGES[30]);
          ENDIF;
       ENDFOR;



       END;

       PROGRAM GET'FILENAME;

*      THIS FUNCTION GETS THE NAME OF THE FILE FOR THE COMMAND YOU
* SPECIFIED.

       INCLUDE GLOBAL'VARIABLES;

       DECLARE INTEGER
          FILE'NUMBER;       /* TO TEST IF THE FILE EXISTS            */

       DECLARE STRING
          COMMAND'LINE,      /* HOLDS WHAT THE USER TYPES IF THE FILE-*/
                             /*   NAME WASN'T ORGINALLY SPECIFIED     */
          FILE'NAME,
          TEMP;              /* HOLDS THE NEXT PARAMETER OF EXEC'CMD'-*/
                             /*   LINE (HOPEFULLY A FILE NAME)        */



       STRING FUNCTION GET'FILENAME(FILE'NAME, COMMAND'LINE);

       TEMP ← GET'PARAM(COMMAND'LINE);
       WHILE 1 DO;
          WHILE LENGTH(TEMP) = 0 DO;
             OUTPUT'STRING("M1 FILENAME: ");
             SETS(COMMAND'LINE);
             COMMAND'LINE ← INPUT'STRING(COMMAND'LINE);
             TEMP ← GET'PARAM(COMMAND'LINE);
          ENDFOR;

* MAKE SURE THE FILE EXISTS
          FILE'NUMBER ← OPEN'SEQ'FILE(TEMP, READ'FILE,
             TYPE'ASSUMED[COMMAND'INDEX], 8//BAD'NAME: ERROR'CODE,
             ERROR'NUMBER);
          CLOSE'SEQ'FILE(FILE'NUMBER//WARNING);
          SCOPY(FILE'NAME, TEMP//WARNING);
          RETURN FILE'NAME;

BAD'NAME: IF ERROR'CODE = 'NNF' DO;
             OUTPUT'STRING(ERROR'MESSAGES[15]);
          ELSEIF ERROR'CODE = 'NAM' DO;
             OUTPUT'STRING(ERROR'MESSAGES[16]);
          ELSEIF ERROR'CODE = 'NFL' DO;
             OUTPUT'STRING(ERROR'MESSAGES[17]);
          ELSE DO;
             OUTPUT'STRING(ERROR'MESSAGES[18]);
          ENDIF;
          SETS(TEMP);
          SETS(COMMAND'LINE);
       ENDFOR;

       END;

       PROGRAM ACQUIRE'LINE;

*      THIS BLOCK CONTAINS TWO FUNCTIONS WHICH MANIPULATE THE MAIN CHIO
* LINE TABLES: ACQUIRE'LINE AND RETURN'LINE.  ACQUIRE'LINE TAKES OVER
* CONTROL OF A SPECIFIED LINE, RETURNING THE CURRENT VALUE OF THE THIRD
* LINE TABLE SO THAT IT MAY BE RESET TO ITS PREVIOUS VALUE BY RETURN'LINE.

       INCLUDE GLOBAL'VARIABLES;

       DECLARE PARAMETER
          ENTRY'LENGTH ← 4,
          MAIN'TABLE'BASE    /* BASE ADDRESS OF THE MAIN TABLE        */
             ← 6104B,
          REL'COMPENSATION   /* THE NUMBER NECESSARY TO TURN AN ABSO- */
             ← 664B3;        /*   LUTE ADDRESS INTO A RELATIVE ONE    */

       DECLARE PARAMETER
          READ ← 0, WRITE ← 1;

       DECLARE INTEGER
          ADDRESS, DATA;



       FUNCTION ACQUIRE'LINE(LINE'NUMBER);

       ADDRESS ← LINE'NUMBER*ENTRY'LENGTH + MAIN'TABLE'BASE + 3 +
          REL'COMPENSATION;
       DATA ← READ'WRITE'CM(ADDRESS, DATA, READ//DISTRESS);
       READ'WRITE'CM(ADDRESS, DATA A' 7777B4 V' THIS'PROCESS, WRITE//DISTRESS);
       RETURN DATA;



       UNKNOWN FUNCTION RETURN'LINE(LINE'NUMBER, DATA);

       ADDRESS ← LINE'NUMBER*ENTRY'LENGTH + MAIN'TABLE'BASE + 3 +
          REL'COMPENSATION;
       READ'WRITE'CM(ADDRESS, DATA, WRITE//DISTRESS);
       RETURN;


       END;

       PROGRAM LOAD'FROM'FILE;

*      THIS FUNCTION WILL PUNCH THE FILE SPECIFIED IN THE LIST ENTRY
* PASSED AS A PARAMETER TO THIS FUNCTION ON THE SYSTEM PAPER TAPE PUNCH.

       INCLUDE GLOBAL'VARIABLES;

       DECLARE INTEGER
          CHAR,
          MAX ← 21,
          FINISHED'FILE,     /* FLAG SIGNALING THAT THE FILE HAS BEEN */
                             /*   COMPLETELY READ                     */
          INPUT'FILE;        /* FILE TO GET THE DATA TO BE OUTPUT     */

       DECLARE STRING
          FILE'NAME,
          OUTPUT (200);      /* BUFFER WHICH HOLDS THE CHARACTERS COM-*/
                             /*   PRISING A LINE OF THE FILE WHILE    */
                             /*   INIDIVIDUAL CHARACTERS ARE OUTPUT   */



       UNKNOWN FUNCTION CLEANUP'LINE(FILE'NAME);

       CLEAN'DATA'BUF(DATA'LINE);
       RETURN;



       UNKNOWN FUNCTION LOAD'FROM'FILE(FILE'NAME);

       CLEAN'DATA'BUF(DATA'LINE);
       INPUT'FILE ← OPEN'SEQ'FILE(FILE'NAME, READ'FILE, BINARY'FILE,
          8//LOAD'FAILED);
       FINISHED'FILE ← FALSE;
* OUTPUT THE FILE
       WHILE NOT FINISHED'FILE DO;
          OUTPUT ← INPUT'SEQ'FILE'(INPUT'FILE, OUTPUT, MAX//LOAD'FAILED);
          OUTPUT'DATA(OUTPUT, DATA'LINE, FALSE); * DON'T TRANSLATE
          IF LENGTH(OUTPUT) # MAX DO;
             CLOSE'SEQ'FILE(INPUT'FILE//LOAD'FAILED);
             RETURN;
          ENDIF;
       ENDFOR;

LOAD'FAILED:
       OUTPUT'STRING(ERROR'MESSAGES[30]);
       RETURN;



       END;

       PROGRAM SEND'FILE;

*      THIS FUNCTION WILL PUNCH THE FILE SPECIFIED IN THE LIST ENTRY
* PASSED AS A PARAMETER TO THIS FUNCTION ON THE SYSTEM PAPER TAPE PUNCH.

       INCLUDE GLOBAL'VARIABLES;

       DECLARE INTEGER
          CHAR,
          COUNT,
          FINISHED'FILE,     /* FLAG SIGNALING THAT THE FILE HAS BEEN */
                             /*   COMPLETELY READ                     */
          OUTPUT'FILE;       /* FILE IN WHICH DATA TO BE OUTPUT CAN   */
                             /*   BE FOUND                            */

       DECLARE STRING
          FILE'NAME,
          OUTPUT (200);      /* BUFFER WHICH HOLDS THE CHARACTERS COM-*/
                             /*   PRISING A LINE OF THE FILE WHILE    */
                             /*   INIDIVIDUAL CHARACTERS ARE OUTPUT   */



       UNKNOWN FUNCTION SEND'FILE(FILE'NAME);

       CLEAN'DATA'BUF(DATA'LINE);
       OUTPUT'FILE ← OPEN'SEQ'FILE(FILE'NAME, READ'FILE, SYMBOLIC'FILE,
          8//PUNCH'FAILED);
       FINISHED'FILE ← FALSE;
* OUTPUT THE FILE
       WHILE NOT FINISHED'FILE DO;
          OUTPUT ← INPUT'SEQ'FILE(OUTPUT'FILE, OUTPUT//PUNCH'FAILED);
          FINISHED'FILE ← (1 IF LENGTH(OUTPUT) = 0 ELSE 0);
          IF FINISHED'FILE DO;
             CLOSE'SEQ'FILE(OUTPUT'FILE//PUNCH'FAILED);
             RETURN;
          ENDIF;
          OUTPUT'DATA(OUTPUT, DATA'LINE, TRUE); * TRANSLATE
       ENDFOR;

PUNCH'FAILED:
       OUTPUT'STRING(ERROR'MESSAGES[30]);
       RETURN;



       END;

       PROGRAM ASSEMBLE'FILE;

*      THIS FUNCTION CONTROLS THE FILES THE 500 MUST HANDLE FOR THE
* HP TO ASSEMBLE A FILE.  IN PASS 1, ONLY THE SOURCE FILE IS SENT.  IN
* PASS 2, THE SOURCE FILE IS SENT AGAIN, BUT ALSO THE BINARY OUTPUT,
* NORMALLY PUNCHED ON PAPER TAPE IS DIVERTED TO THE 500 AND MUST BE
* STORED ON A FILE SO THAT THE HP CAN LATER BE RELOADED.

       INCLUDE GLOBAL'VARIABLES, ASCII'940'TABLES;

       DECLARE INTEGER
          CHAR,
          CHARS'LEFT,        /* FLAG SIGNALING WHTHTER THERE IS MORE  */
                             /*   DATA TO BE OUTPUT                   */
          COLON,             /* CHARACTER POSITION OF THE FIRST COLON */
          COUNT,
          INPUT'FILE,        /* FILE TO BE ASSEMBLED (SOURCE)         */
          OUTPUT'FILE,       /* BINARY FILE OUTPUTTED BY THE HP       */
          WE'ARE'DONE;       /* SIGNALS THAT ALL THE BINARY OUTPUT HAS*/
                             /*   BEEN READ IN FROM THE HP            */

       DECLARE STRING
          DATA(400),         /* CHARACTERS READY FOR OUTPUT TO THE    */
                             /*   CHIO                                */
          FILE'NAME,
          FULL'NAME(42),     /* DERIVED FROM FILE'NAME                */
          OUTPUT(200),       /* SOURCE WHICH MUST BE OUTPUT           */
          QUOTED'NAME(36);   /* SO THAT THE FILE CAN BE OPENED FOR    */
                             /*   OUTPUT                              */



       UNKNOWN FUNCTION ASSEMBLE'FILE(FILE'NAME);

* FOR PASS 1
       SEND'FILE(FILE'NAME);

* FOR PASS 2, THINGS ARE MORE DIFFICULT.  THE WAY THINGS ARE SUPPOSED TO
* WORK IS LIKE THIS: A LINE OF SOURCE FILE IS RETRIEVED FROM THE FILE.
* AS MUCH OF THE LINE AS POSSIBLE IS OUTPUT TO THE HP.  IF THE FIRST LINE
* IS COMPLETELY OUTPUT, THE SECOND IS AND SO ON UNTIL THE CHIO WON'T LET
* ME OUTPUT ANYMORE.  AT THAT TIME, THE INPUT BUFFER IS EMPTIED OF
* EVERYTHING IT HAD, AND WRITTEN OUT TO THE THE OUTPUT FILE.  IF THERE WAS
* NOTHING IN THE INPUT LINE BUFFER, FRETURN, OUTPUT OF INPUT'DATA, OUT
* OF GET'CHARACTER, OUTPUT OF READ'BLOCK AND BLOCK IN THIS FUNCTION.  A
* WAKEUP CAUSES ME TO REPEAT THE PROCESS.  THE WAY I GET OUT OF THE LOOP
* IS TO RECOGNIZE THE LAST BLOCK TRANSMITTED BY THE HP AND SET A FLAG.

* SET THE WAKEUP CHARACTER COUNT AND CLEAR THE BUFFER.
       SET'LINE'FIELD(HP'READ'LINE, 'WKC', 0//DISTRESS);
       INPUT'DATA(//GO'ON) WHILE 1; * CLEAN OUT INPUT BUFFER ONLY

GO'ON: GET'CMPLT'NAME(FULL'NAME, FILE'NAME, 6'9SYM'//WARNING);

* CREATE THE QUOTED FILE NAME SO THAT THE UTILITY WON'T COMPLAIN THAT THE
* FILE ISN'T THERE.
* LOOK FOR THE USER NUMBER FIRST
       COLON ← INDEX(FULL'NAME, ":"//WARNING);
       SUBSTR(QUOTED'NAME, FULL'NAME, 0, COLON+1//WARNING);
       SETR(FULL'NAME, COLON+1);

* INSERT THE QUOTES AROUND THE MAIN NAME
       WCI('"', QUOTED'NAME//WARNING);
       COLON ← INDEX(FULL'NAME, ":"//WARNING);
       SUBSTR(QUOTED'NAME, FULL'NAME, 0, COLON//WARNING);
       WCI('"', QUOTED'NAME//WARNING);
       SETR(FULL'NAME);

* OPEN UP THE FILES
       INPUT'FILE ← OPEN'SEQ'FILE(QUOTED'NAME, WRITE'FILE, BINARY'FILE,
          8//READ'FAILED);
       OUTPUT'FILE ← OPEN'SEQ'FILE(FILE'NAME, READ'FILE, SYMBOLIC'FILE,
          8//READ'FAILED);

       LABEL'INDEX ← 0;
       WHILE 1 DO;
* GET A LINE FROM THE FILE AND PREPARE IT FOR OUTPUT
          OUTPUT ← INPUT'SEQ'FILE(OUTPUT'FILE, OUTPUT//READ'FAILED);
          GOTO ALMOST'DONE IF LENGTH(OUTPUT) = 0;
          FOR COUNT ← 1 TO LENGTH(OUTPUT) DO;
             CHAR ← GCI(OUTPUT);
             CHAR ← TRANS'TBL'940'AS[CHAR];
             IF CHAR < 40B DO;
                WCI(ESCAPE'CHAR, DATA);
                CHAR ← CHAR V' 40B;
             ENDIF;
             WCI(CHAR, DATA);
          ENDFOR;

* OUTPUT THE LINE
          CHARS'LEFT ← TRUE;
          WHILE CHARS'LEFT DO;
             WRITE'STRING(DATA'LINE, MOST'POSSIBLE, DATA:
                DATA, CHARS'LEFT//DISTRESS);
             IF CHARS'LEFT DO;
                READ'BLOCK(INPUT'FILE: WE'ARE'DONE//WAIT'FOR'WAKEUP);
                GOTO CLOSE IF WE'ARE'DONE ELSE GOTO ANY'LEFT;
WAIT'FOR'WAKEUP:BLOCK(4B7 RSH CHIO'WATCH//DISTRESS);
             ENDIF;
ANY'LEFT: ENDFOR;
          SETS(DATA);
          SETS(OUTPUT);
       ENDFOR;

* WAIT FOR ALL THE BINARY CODE
ALMOST'DONE:
       WHILE NOT WE'ARE'DONE DO;
          BLOCK(4B7 RSH CHIO'WATCH//DISTRESS);
          READ'BLOCK(INPUT'FILE: WE'ARE'DONE//ALMOST'DONE);
       ENDFOR;

CLOSE: CLOSE'SEQ'FILE(INPUT'FILE//EXIT());
       CLOSE'SEQ'FILE(OUTPUT'FILE//EXIT());
       CLEAN'DATA'BUF();
       RETURN;

READ'FAILED:
       OUTPUT'STRING(ERROR'MESSAGES[30]);
       RETURN;


       END;

       PROGRAM GET'CMPLT'NAME;

*      THIS FUNCTION DETERMINES THE COMPLETE NAME OF AN OBJECT GIVEN A
* PARTIAL NAME.  IT TAKES AS ITS ARGUMENTS THE STRING TO WHICH THE FULL
* NAME WILL BE APPENDED TO, THE STRING WHICH CONTAINS THE PARTIAL NAME
* AND AN INTEGER WHICH IN SIX BIT CHARACTER MODE IS THE FILE TYPE.  THE
* FUNCTION FAILS IF THE NAME'SEARCH IT PERFORMS FAILS, THE USUAL CAUSE
* OF THIS IS THAT THE FILE DOE NOT EXIST OR THE NAME SPECIFIED IS AMBIGUOUS
* OR THE STRING IS NOT LONG ENOUGH TO HOLD THE FULL NAME, BUT IT COULD
* ALSO BE A SYNTAX ERROR, BAD USER NUMBER, ETC.

       INCLUDE STRING'DEFS, UTILITY'CALLS;

       DECLARE ARRAY
          FORMATTED'NAME[8]; /* WILL CONTAIN THE M1 FORMATTED NAME    */

       DECLARE INTEGER
          ACCESS ← 0,        /* FILE ACCESS, REALLY DOES NOT MATTER   */
          FILE'TYPE,         /* TYPE IN SIX BIT CHARACTERS            */
          FULL'NAME'PTR,     /* POINTER TO THE THE STRING DESCRIPTOR  */
          LENGTH'MAIN,       /* NUMBER OF CHARACTERS IN THE MAIN NAME */
          LENGTH'TYPE;       /* NUMBER OF CHARACTERS IN THE FILE TYPE */

       DECLARE STRING
          FULL'NAME,         /* STRING TO APPEND THE FULL NAME TO     */
          PARTIAL'NAME,      /* NEEDED TO GET STARTED                 */
          SUPERFLUOUS'NAME;  /* THE M1 FORMATTED NAME AS A STRING     */
                             /*   (MAY CONTAIN EXTRA BLANKS)          */



       FUNCTION GET'CMPLT'NAME(STRING @FULL'NAME'PTR, PARTIAL'NAME,
          FILE'TYPE), FRETURN;

       FULL'NAME ← FULL'NAME'PTR.STRING'DESC;
* TRY TO FIND THE OBJECT
       NAME'SEARCH(PARTIAL'NAME, FORMATTED'NAME, ACCESS, FILE'TYPE, -1//
          FRETURN: ERROR'CODE, ERROR'NUMBER);
       SETUP(SUPERFLUOUS'NAME, 20, @FORMATTED'NAME[3], 6);
       SETW(SUPERFLUOUS'NAME, 20);
* NOW COMPACT SUPERFLUOUS'NAME INTO FULL'NAME
       WCI('#', FULL'NAME//FRETURN);
       CNS(FORMATTED'NAME[0], FULL'NAME, 0, 10//FRETURN);
       WCI(':', FULL'NAME//FRETURN);
       LENGTH'MAIN ← INDEX'WO'CHECK(SUPERFLUOUS'NAME, " "//16);
       SUBSTR'WO'CHECK(FULL'NAME, SUPERFLUOUS'NAME, 0, LENGTH'MAIN//FRETURN);
       WCI(':', FULL'NAME//FRETURN);
       SETR(SUPERFLUOUS'NAME, 16);
       LENGTH'TYPE ← INDEX'WO'CHECK(SUPERFLUOUS'NAME, " "//4);
       SUBSTR'WO'CHECK(FULL'NAME, SUPERFLUOUS'NAME, 0, LENGTH'TYPE//FRETURN);
       FULL'NAME'PTR.STRING'DESC ← FULL'NAME;
       RETURN;

       END;

       PROGRAM READ'BLOCK;

*      THIS FUNCTION READS IN THE NEXT BLOCK OF BINARY OUTPUT FROM THE
* HP.  IT ONLY RETURNS AFTER IT HAS FNISHED READING ALL THE DATA FOR
* THAT BLOCK.  IT FRETURNS IF THE DATA LINE IS EMPTY.  THE SETTING OF
* LABEL'INDEX, EXPLICITLY, OR BY CRETURNING, DETERMINES WHERE TO BEGIN
* THE NEXT TIME THE FUNCTION IS CALLED.  THE DATA IS READ IN CHARACTER BY
* CHARACTER AND WRITTEN INTO THE OUTPUT FILE.

       INCLUDE GLOBAL'VARIABLES;

       DECLARE INTEGER
          CHAR,
          OUTPUT'FILE;

       DECLARE LABEL ARRAY WHERE'WE'LEFTOFF[3] ←
          (INIT'NULLS, GETTING'BLOCK, BETWEEN'BLOCKS);

       MACRO CRETURN(X) ← LABEL'INDEX ← X & FRETURN;



       FUNCTION READ'BLOCK(OUTPUT'FILE), FRETURN;

       GOTO WHERE'WE'LEFTOFF[LABEL'INDEX];
INIT'NULLS:
       CHAR ← ASCII'NULL;
       WHILE CHAR = ASCII'NULL DO;
          CHAR ← GET'CHARACTER(1, DATA'LINE - 1//CRETURN(0));
          OUT'CHAR'FILE(OUTPUT'FILE, CHAR//CATASTROPHE);
       ENDFOR;

*      CONVERT WORD COUNT READ FROM THE HP TO A BYTE COUNT, TAKING
* INTO ACCOUNT THE EXTRA BYTES FROM THE GARBAGE BYTE FOLLOWING THE WORD
* COUNT (1), THE BYTES OF THE FIRST WORD (2), THE BYTES OF THE LAST
* WORD (2).
       BLOCK'SIZE ← CHAR*2 + 1 + 2 + 2;

       DATA'COUNT ← 0;
       WHILE DATA'COUNT < BLOCK'SIZE DO;
GETTING'BLOCK:
          GET'CHARACTER(1, OUTPUT'FILE//CRETURN(1));
          OUT'CHAR'FILE(OUTPUT'FILE, CHAR//CATASTROPHE);
          DATA'COUNT ← DATA'COUNT + 1;
       ENDFOR;

*      SKIP OVER INTER-BLOCK NULLS.  END OF FILE IS SIGNALED BY MORE THAN
* 11 CONSECUTIVE NULLS.
       NULL'COUNT ← 0;
       CHAR ← ASCII'NULL;
       WHILE CHAR = ASCII'NULL AND NULL'COUNT < 12 DO;
BETWEEN'BLOCKS:
          CHAR ← GET'CHARACTER(1, OUTPUT'FILE//CRETURN(2));
          OUT'CHAR'FILE(OUTPUT'FILE, CHAR//CATASTROPHE);
          NULL'COUNT ← NULL'COUNT + 1;
       ENDFOR;
       RETURN TRUE IF CHAR = ASCII'NULL; * END OF FILE
       BLOCK'SIZE ← CHAR*2 + 1 + 2 + 2;

       DATA'COUNT ← 0;
       LABEL'INDEX ← 1;
       RETURN FALSE; * ANOTHER BLOCK FOLLOWING


       END;

       PROGRAM GET'CHARACTER;

*      THIS FUNCTION RETURNS ONE LEGITIMATE CHARACTER FROM THE INPUT
* BUFFER OF THE DATA LINE.  IN OTHER WORDS, IT TAKES CARE OF ESCAPE
* CHARACTERS (37B).

       INCLUDE GLOBAL'VARIABLES;

       DECLARE INTEGER
          CHAR,
          CHARS'DESIRED,     /* VALUE TO SET THE WAKEUP COUNT TO      */
          CHARS'LEFT,
          LINE'NUMBER;       /* LINE TO READ THE DATA FROM            */

       DECLARE STRING
          TEMP;



       CHARACTER FUNCTION GET'CHARACTER(CHARS'DESIRED, LINE'NUMBER), FRETURN;

       WHILE 1 DO;
          CHAR ← GCI(INPUT'DATA'BLK//CHECK'BUFFER);
          IF CHAR < ESCAPE'CHAR DO;
             FATAL'ERROR(); * CHIO CONTROL CHARACTER?
          ELSEIF CHAR = ESCAPE'CHAR DO;
             CHAR ← GCI(INPUT'DATA'BLK) A' 37B;
          ENDIF;
          RETURN CHAR;

*      WE HAVE RUN OUT OF THE CHARACTERS READ FROM THE DATA LINE THE
* LAST TIME.
CHECK'BUFFER:
          SET'LINE'FIELD(LINE'NUMBER, 'WKC', CHARS'DESIRED - 1//
             DISTRESS);
          INPUT'DATA(LINE'NUMBER//FRETURN);
       ENDFOR;



       END;

       PROGRAM INPUT'DATA;

*      THIS FUNCTION READS ALL THE CHARACTERS IT CAN FROM THE DATA LINE
* AND PUTS THEM INTO THE STRING INPUT'DATA'BLK.  THE FUNCTION FRETURNS
* IF THE LINE BUFFERS ARE EMPTY.  ONE SHOULD BE AWARE OF POSSIBLE PROBLEMS
* HERE IF THERE ARE TOO MANY CHARACTERS TO READ.  INPUT'DATA'BLK WILL
* FILL UP AND THE MONITOR CALL READ'STRING WILL FAIL WITH ERROR CODE
* 'ARG'.  HOPEFULLY, THIS SHOULD NEVER HAPPEN BECAUSE THE BUFFER IS
* CLEANED UP BEFOREHAND BY CALLING THE FUNCTION CLEAN'DATA'BUF AND
* THE CPU IS NOT BUSY ENOUGH (PRETTY GOOD ASSUMPTION) AND FAST ENOUGH
* (PRETTY TERRIBLE ASSUMPTION) THAT THE SITUATION WILL "NEVER" OCCUR.

       INCLUDE GLOBAL'VARIABLES;

       DECLARE INTEGER
          FIRST'TIME,        /* FLAG SIGNALLING THE FIRST TIME IN THE */
                             /*   LOOP                                */
          LINE'NUMBER,
          STATUS'INDICATOR;  /* THE NUMBER OF CHARACTERS RETURNED AND */
                             /*   WHY                                 */

       DECLARE FIELD
          CHARS'FOUND(0:2,23);

       DECLARE PARAMETER
          DESTRUCTIVELY ← 0;



       UNKNOWN FUNCTION INPUT'DATA(LINE'NUMBER), FRETURN;

       FIRST'TIME ← TRUE;
       SETS(INPUT'DATA'BLK);

       WHILE 1 DO;
          READ'STRING(LINE'NUMBER, MOST'POSSIBLE, DESTRUCTIVELY, INPUT'DATA'BLK:
             INPUT'DATA'BLK, STATUS'INDICATOR//DISTRESS);
          IF STATUS'INDICATOR$CHARS'FOUND = 0 DO;
             FRETURN IF FIRST'TIME ELSE RETURN;
          ENDIF;
          FIRST'TIME ← FALSE;
       ENDFOR;


       END;

       PROGRAM OUTPUT'DATA;

*      THIS FUNCTION OUTPUTS A STRING ONTO THE DATA LINE.  IT TAKES CARE
* OF OCCURENCES WHEN THE MONITOR DOESN'T WANT ANY MORE CHARACTERS BY
* BLOCKING, AND THEN TRYING AGAIN.

       INCLUDE GLOBAL'VARIABLES, ASCII'940'TABLES;

       DECLARE INTEGER
          CHAR,
          CHARS'LEFT,        /* THE NUMBER OF CHARACTERS THE MONITOR  */
                             /*   HAS YET TO OUTPUT                   */
          LINE'NUMBER,
          TRANSLATE;         /* SPECIFIES WHETHER TRANSLATION SHOULD  */
                             /*   BE PERFORMED                        */

       DECLARE STRING
          DATA(200),         /* THE ACTUAL DATA PASSED TO THE CHIO    */
          RAW'DATA,          /* DATA TO BE OUTPUT BEFORE CONVERSION   */
          TO'BE'OUTPUT;



       UNKNOWN FUNCTION OUTPUT'DATA(RAW'DATA, LINE'NUMBER, TRANSLATE);

       WHILE 1 DO;
          CHAR ← GCI(RAW'DATA//OUTPUT);
          CHAR ← TRANS'TBL'940'AS[CHAR] IF TRANSLATE;
          IF CHAR < 40B DO;
             WCI(ESCAPE'CHAR, DATA);
             CHAR ← CHAR V' 40B;
          ENDIF;
          WCI(CHAR, DATA);
       ENDFOR;
OUTPUT:CHARS'LEFT ← TRUE;
       WHILE CHARS'LEFT DO;
          WRITE'STRING(LINE'NUMBER, MOST'POSSIBLE, DATA: DATA, CHARS'LEFT//
             DISTRESS);
          BLOCK(4B7 RSH CHIO'WATCH//DISTRESS) IF CHARS'LEFT;
       ENDFOR;
       RETURN;



       END;

       PROGRAM CLEAN'DATA'BUF;

*      THIS PROGRAM BLOCK CONTAINS THE FUNCTIONS WHICH CLEAN OUT THE
* INPUT AND OUTPUT BUFFERS OF THE SPECIFIED LINE SIMPLY BY READING CHAR-
* ACTERS FROM THE LINES UNTIL THERE ARE NONE LEFT.

       INCLUDE GLOBAL'VARIABLES;

       DECLARE FIELD
          CHARS'FOUND(0:2,23);

       DECLARE INTEGER
          LINE'NUMBER,
          STATE'OF'LINE;     /* TELLS WHY THE MONITOR CALL TERMINATED */

       DECLARE PARAMETER
         DESTRUCTIVELY ← 0;

       DECLARE STRING
          PART'OF'BUFFER(21);/* NOT NECESSARILY A "LINE"              */



       UNKNOWN FUNCTION CLEAN'DATA'BUF(LINE'NUMBER);

       STATE'OF'LINE$CHARS'FOUND ← 1;
       WHILE STATE'OF'LINE$CHARS'FOUND DO;
          SETS(PART'OF'BUFFER);
          READ'STRING(LINE'NUMBER - 1, MOST'POSSIBLE, DESTRUCTIVELY,
             PART'OF'BUFFER: PART'OF'BUFFER, STATE'OF'LINE//DISTRESS);
       ENDFOR;
       STATE'OF'LINE$CHARS'FOUND ← 1;
       WHILE STATE'OF'LINE$CHARS'FOUND DO;
          SETS(PART'OF'BUFFER);
          READ'STRING(LINE'NUMBER, MOST'POSSIBLE, DESTRUCTIVELY,
             PART'OF'BUFFER: PART'OF'BUFFER, STATE'OF'LINE//DISTRESS);
       ENDFOR;
       RETURN;


       END;

       PROGRAM OPEN'SEQ'FILE;

*      THIS FUNCTION OPENS A FILE SPECIFIED BY THE ARGUMENT FILE'NAME
* FOR INPUT OR OUTPUT DEPENDING ON THE SECOND ARGUMENT, IOFLAG.  THE
* THIRD ARGUMENT, CHAR'LENGTH DETERMINES WHAT THE SIZE OF THE CHAR-
* ACTERS READ FROM OR WRITTEN INTO THE FILE ARE.  THIS FUNCTION WILL
* FAIL FOR MANY REASONS, SUCH AS IF ANY OF THE SYSTEM CALLS IT USES
* FRETURNS.  HOWEVER, THE USER CAN CAUSE THE FUNCTION TO FAIL BY PAS-
* SING A BAD FILE NAME, OR BY SPECIFYING AN OBJECT WHICH REALLY ISN'T A
* FILE.  THIS FUNCTION ALSO FAILS IF THE USER TRIES TO OPEN A FILE WHEN
* HE ALREADY HAS THE MAXIMUM ALLOWABLE NUMBER OF FILES OPEN.

       INCLUDE GLOBAL'VARIABLES;

       DECLARE ARRAY
          FORMATTED'NAME,    /* M1 FORMATTED NAME                     */
          LENGTH'WORD[3];    /* VALUE OF THE M1 FORMATTED NAME        */


       DECLARE INTEGER
          ACCESS'SPEC,       /* ACCESS SPECIFICATION TO THE FILE      */
          CHAR'LENGTH,       /* LENGTH OF A CHARACTER IN BITS         */
          FILE'LENGTH,       /* LENGTH OF FILE IN CHARACTERS          */
          FILE'NUMBER,       /* TSS FILE NUMBER                       */
          FILE'TYPE,         /* TYPE OF FILE: SYMBOLIC, BINARY, ETC.  */
          IOFLAG,            /* OPERATION TO BE PERFORMED ON THE FILE */
                             /*   (0 - RETRIEVE, 1 - STORE)           */
          GARBAGE,           /* UNNECESSARY RETURNED VALUES           */
          LAST'PAGE,         /* LAST PAGE OF THE FILE                 */
          LAST'WORD,         /* LAST WORD OF THE LAST PAGE OF THE FILE*/
          OBJECT'TYPE,       /* TYPE OF FILE                          */
                             /*  (0 - SMALL FILE, 1 - LARGE FILE)     */
          PAGE'NUMBER,       /* PAGE NUMBER OF THE FILE               */
          SEQ'FILE'NUM;      /* NUMBER OF SEQUENTIAL FILES OPEN       */

       DECLARE POINTER
          FILE;              /* A POINTER TO THE FILE WINDOW          */

       DECLARE STRING
          NULL'STRING,       /* JUST A NULL STRING                    */
          FILE'NAME;         /* FILE THE USER WANTS TO OPEN           */
          



       FUNCTION OPEN'SEQ'FILE(FILE'NAME, IOFLAG, FILE'TYPE, CHAR'LENGTH),
          FRETURN;

* CAN THE USER OPEN A FILE?
       FOR SEQ'FILE'NUM ← 0 TO NUM'SEQ'FILES - 1 DO;
          GOTO SET IF NOT SEQ'FILE'TABLE[SEQ'FILE'NUM]$WINDOW'IN'USE;
       ENDFOR;
       WARNING;

* SET UP A POINTER TO THE FILE'S WINDOW DESCRIPTOR
SET:   FILE ← @SEQ'FILE'TABLE[SEQ'FILE'NUM];

* SET UP AN ARRAY DESCRIPTOR
       FORMATTED'NAME ← CONS'ARRAY'DESC(@(FILE.NAME'STORAGE), 8, 1, 0 //
          FRETURN (-1, -1));

* GET THE M1 FORMATTED NAME FROM THE FILE NAME TYPED IN BY THE USER
       NAME'SEARCH(FILE'NAME, FORMATTED'NAME, IOFLAG, FILE'TYPE, -1//
             FRETURN (ERROR'CODE, ERROR'NUMBER): ERROR'CODE, ERROR'NUMBER);

* MAY HAVE TO BE CHANGED FOR THE APPEND
       ACCESS'SPEC ← ('WU' IF IOFLAG ELSE 'RU');

* IS THE FILE NEW (FORMATTED'NAME[2] = -1)?
       IF FORMATTED'NAME[2] = -1 DO;
          FILE'NUMBER ← OPEN'FILE(-1, FORMATTED'NAME, ACCESS'SPEC, -1//
             DISTRESS);
          FILE'LENGTH ← 0;
          OBJECT'TYPE ← SMALL'FILE;

       ELSE DO;
*       THE FILE ALREADY EXISTS.  DO THIS TO BE SAFE, THE OLD NAME MAY
* NOT HAVE BEEN A MONITOR FORMATTED NAME.
          CONV'NAME(FORMATTED'NAME, FORMATTED'NAME, -1:
             GARBAGE, OBJECT'TYPE, GARBAGE//DISTRESS);
          IF (OBJECT'TYPE = SMALL'FILE) OR (OBJECT'TYPE = LARGE'FILE) DO;
             READ'MIBOB'VALUE(FORMATTED'NAME, 1, LENGTH'WORD, 2, -1//
                DISTRESS);
             FILE'NUMBER ← OPEN'FILE(-1, FORMATTED'NAME, ACCESS'SPEC, -1//
                DISTRESS);
             LAST'PAGE ← LENGTH'WORD[2]$PAGES'IN'FILE - 1;
             LAST'WORD ← LENGTH'WORD[2]$WORDS'IN'PAGE + 1;
             FILE'LENGTH ← (0 IF NEXT'FILE'PAGE(FILE'NUMBER, -1//
                SYSTEM'ERROR() & GOTO ABORT: ERROR'CODE, ERROR'NUMBER) = -1
                ELSE (24/CHAR'LENGTH)*((2048*LAST'PAGE) + LAST'WORD));

             IF FILE'LENGTH AND IOFLAG = WRITE'FILE DO;
                DEL'SEQ'FILE(FILE'NUMBER//ABORT);
                FILE'LENGTH ← 0;
             ENDIF;
          ELSE DO;
             FRETURN ('NFL', -1); * NOT A FILE

          ENDIF;

       ENDIF;

* FILL UP THE WINDOW
       FILE.PAGE'IN'WINDOW ← -1;
       FILE.PMT'INDEX ← ACQUIRE'PMT(-1//SYSTEM'ERROR() &
          GOTO ABORT: ERROR'CODE, ERROR'NUMBER);
       FILE.WINDOW'IN'USE ← 1;
       FILE.LARGE'OR'SMALL ← (0 IF OBJECT'TYPE = SMALL'FILE ELSE 1);
       FILE.OPERATION ← IOFLAG;
       FILE.FILE'NUM ← FILE'NUMBER;
       FILE.WINDOW'ADDRESS ← SEQ'FILE'WINDOWS[SEQ'FILE'NUM];
       FILE.CHARACTER'SIZE ← CHAR'LENGTH;
       FILE.CHARS'PER'WORD ← 24/CHAR'LENGTH;
       FILE.CHARS'PER'PAGE ← 4000B*24/CHAR'LENGTH;
       FILE.CHARS'LEFT ← FILE'LENGTH;
       FILE.LENGTH'IN'CHARS ← FILE'LENGTH;

       SET'MAP'BYTE(THIS'SUB'PROCESS, FILE.WINDOW'ADDRESS$PAGE'NUM'ADDR,
          FILE.PMT'INDEX//SYSTEM'ERROR() & GOTO ABORT:
          ERROR'CODE, ERROR'NUMBER);

*      THIS IS RIDICULOUS.  THE STATEMENT SHOULD BE 
*         SETUP(NULL'STRING, 0, FILE.WINDOW'ADDRESS, CHAR'LENGTH);
* EXCEPT THAT SPL WON'T TAKE A VARIABLE CHARACTER LENGTH.
* (THERE ARE SIMILAR STATEMENTS IN MAP'IN'NEXT'PAGE AND CREATE'PAGE)
       SETUP'KLUDGE(NULL'STRING, 0, FILE.WINDOW'ADDRESS,
          FILE.CHARACTER'SIZE//ABORT);
       FILE.READ'DESC ← NULL'STRING;
       FILE.WRITE'DESC ← (PREPARE'APPEND(FILE, LAST'PAGE//ABORT) IF
          IOFLAG = APPEND'FILE ELSE NULL'STRING);
       OPEN'FILE'TABLE[FILE'NUMBER] ← SEQ'FILE'NUM;
       RETURN FILE'NUMBER;

* SOMETHING WENT WRONG, SO RESET THINGS
ABORT: FILE.WINDOW'IN'USE ← 0;
       CLOSE'SEQ'FILE(FILE'NUMBER//FRETURN (-1, -1));
       FRETURN (-1, -1);



       END;

       PROGRAM DEL'SEQ'FILE;

*      THIS FUNCTION DELETES ALL THE PAGES OF AN EXISTING FILE WHICH HAS
* BEEN OPENED FOR OUTPUT.  THE FUNCTION FAILS ONLY IF ONE OF THE MONITOR
* CALLS IT USES FAILS.  THE NAME OF THIS FUNCTION ISN'T EXACTLY AC-
* CURATE, BECAUSE IT ACTUALLY ONLY DELETES THE EXISTING PAGES OF THE
* FILE BUT DEL'FILE'PAGES IS EASILY CONFUSED WITH DEL'FILE'PAGE.

       INCLUDE GLOBAL'VARIABLES;

       DECLARE INTEGER
          FILE'NUMBER,       /* TSS FILE NUMBER                       */
          PAGE'NUMBER;       /* PAGE (MEMORY PAGE) NUMBER OF THE FILE */



       FUNCTION DEL'SEQ'FILE(FILE'NUMBER), FRETURN;

       PAGE'NUMBER ← 0;
       WHILE PAGE'NUMBER # -1 DO;
          DEL'FILE'PAGE(FILE'NUMBER, PAGE'NUMBER//
             DISTRESS);
          PAGE'NUMBER ← NEXT'FILE'PAGE(FILE'NUMBER, PAGE'NUMBER//
             DISTRESS);
       ENDFOR;
       SET'FILE'LENGTH(FILE'NUMBER, 0//DISTRESS);

       RETURN;


       END;

       PROGRAM INPUT'SEQ'FILE;

*      THIS FUNCTION READS A LINE FROM A SPECIFIED FILE AND RETURNS IT
* TO THE CALLING FUNCTION.  A "LINE" IS A STRING OF CHARACTERS ENDING
* WITH A CARRIAGE RETURN LINEFEED, A CARRIAGE RETURN, OR A LINEFEED.
* THE LINE THE FUNCTION RETURNS HAS HAD ANY MULTIPLE BLANK CHARACTERS
* REMOVED AND THE APPROPRIATE NUMBER OF BLANKS INSERTED.
*      WHEN THIS FUNCTION IS CALLED THE FIRST TIME AFTER OPENING THE
* FILE, THE GCI AT READ FAILS BECAUSE FILE.READ'DESC WAS SET UP TO A
* LENGTH OF ZERO.

       INCLUDE GLOBAL'VARIABLES;

       DECLARE INTEGER
          CHAR,              /* A CHARACTER READ FROM THE FILE        */
          COUNT,             /* JUST A COUNTER FOR A FOR LOOP         */
          FINISHED,          /* A FLAG SIGNALING THAT THE FILE HAS    */
                             /*   BEEN COMPLETELY READ                */
          FILE'NUMBER;       /* THE NUMBER OF THE FILE                */

       DECLARE POINTER
          FILE;              /* A POINTER TO THE FILE WINDOW          */

       DECLARE STRING
          INPUT'DUMMY,       /* A STRING CONTAINING A PAGE OF THE FILE*/
                             /*   UNLESS IT IS THE LAST PAGE WHEN IT  */
                             /*   CONTAINS THE REMAINDER OF THE FILE  */
          OUTPUT'LINE;       /* THE STRING RETURNED WITH A LINE READ  */
                             /*   FROM THE FILE                       */



       STRING FUNCTION INPUT'SEQ'FILE(FILE'NUMBER, OUTPUT'LINE), FRETURN;

       SETS(OUTPUT'LINE, 0, 0);
* SET UP THE POINTER TO THE FILE
       FILE ← @SEQ'FILE'TABLE[OPEN'FILE'TABLE[FILE'NUMBER]];

* MAKE A DUMMY ASSIGNMENT OF THE STRING DESCRIPTOR TO KEEP SPL HAPPY
*   (REMEMBER TO REASSIGN FILE.READ'DESC BEFORE RETURNING)
       INPUT'DUMMY ← FILE.READ'DESC;

       FINISHED ← FALSE;
       WHILE 1 DO;
READ:     GOTO PAU IF FINISHED;
          CHAR ← GCI(INPUT'DUMMY//
             MAP'IN'NEXT'PAGE(FILE:INPUT'DUMMY, FINISHED//FRETURN) &
             GOTO READ) A' 177B;

* IS IT A MULTIPLE BLANK CHAR
          IF CHAR = MB DO;
BLANKS:      GOTO PAU IF FINISHED;
             CHAR ← GCI(INPUT'DUMMY//
                MAP'IN'NEXT'PAGE(FILE:INPUT'DUMMY, FINISHED//FRETURN) &
                GOTO BLANKS) A' 77B;
             WCI(BLANK, OUTPUT'LINE//WARNING) FOR
                COUNT ← 1 TO CHAR - 1;
             CHAR ← BLANK;

* TEST FOR END OF LINE CHARACTER/CHARACTERS
          ELSEIF CHAR = CR DO;
C'RET:       GOTO PAU IF FINISHED;
             CHAR ← GCI(INPUT'DUMMY//
                MAP'IN'NEXT'PAGE(FILE: INPUT'DUMMY, FINISHED//FRETURN) &
                GOTO C'RET) A' 177B;

             IF CHAR = LF DO;
                WCI(CR, OUTPUT'LINE//WARNING);
             ELSE DO;
                CHAR ← CHAR V' 200B;
                WCD(CHAR, INPUT'DUMMY);
             ENDIF;
          ENDIF;
          WCI(CHAR, OUTPUT'LINE//WARNING);
          IF CHAR = LF OR CHAR = CR DO;
PAU:         FILE.READ'DESC ← INPUT'DUMMY;
             RETURN OUTPUT'LINE;
          ENDIF;
       ENDFOR;

CARR:  WCI(CR, OUTPUT'LINE//FRETURN);
       FILE.READ'DESC ← INPUT'DUMMY;
       RETURN OUTPUT'LINE;




       END;

       PROGRAM INPUT'SEQ'FILE';

*      THIS FUNCTION RETURNS A SPECIFIED NUMBER OF CHARACTERS FROM THE
* FILE.  ASSUME THE FILE IS IN BINARY, SO DON'T INTERPRET ANYTHING.

       INCLUDE GLOBAL'VARIABLES;

       DECLARE INTEGER
          CHAR,              /* A CHARACTER READ FROM THE FILE        */
          COUNT,             /* JUST A COUNTER FOR A FOR LOOP         */
          FINISHED,          /* A FLAG SIGNALING THAT THE FILE HAS    */
                             /*   BEEN COMPLETELY READ                */
          FILE'NUMBER,       /* THE NUMBER OF THE FILE                */
          NUMBER'CHARS;      /* NUMBER OF CHARS TO RETURN             */

       DECLARE POINTER
          FILE;              /* A POINTER TO THE FILE WINDOW          */

       DECLARE STRING
          INPUT'DUMMY,       /* A STRING CONTAINING A PAGE OF THE FILE*/
                             /*   UNLESS IT IS THE LAST PAGE WHEN IT  */
                             /*   CONTAINS THE REMAINDER OF THE FILE  */
          OUTPUT'LINE;       /* THE STRING RETURNED WITH A LINE READ  */
                             /*   FROM THE FILE                       */



       STRING FUNCTION INPUT'SEQ'FILE'(FILE'NUMBER, OUTPUT'LINE,
          NUMBER'CHARS), FRETURN;

       SETS(OUTPUT'LINE, 0, 0);
* SET UP THE POINTER TO THE FILE
       FILE ← @SEQ'FILE'TABLE[OPEN'FILE'TABLE[FILE'NUMBER]];

* MAKE A DUMMY ASSIGNMENT OF THE STRING DESCRIPTOR TO KEEP SPL HAPPY
*   (REMEMBER TO REASSIGN FILE.READ'DESC BEFORE RETURNING)
       INPUT'DUMMY ← FILE.READ'DESC;

       FINISHED ← FALSE;
       FOR COUNT ← 1 TO NUMBER'CHARS DO;
READ:     GOTO PAU IF FINISHED;
          CHAR ← GCI(INPUT'DUMMY//
             MAP'IN'NEXT'PAGE(FILE:INPUT'DUMMY, FINISHED//FRETURN) &
             GOTO READ);
          WCI(CHAR, OUTPUT'LINE//FRETURN);
       ENDFOR;
PAU:   FILE.READ'DESC ← INPUT'DUMMY;
       RETURN OUTPUT'LINE;




       END;

       PROGRAM MAP'IN'NEXT'PAGE;

*      THIS FUNCTION SETS THINGS UP SO THAT ANOTHER PAGE MAY BE READ BY
* ACQUIRING A PMT INDEX FOR THE NEXT PAGE AND MAPPING IT IN.  IF IT IS
* SUCCESSFUL IN DOING THAT, THE FUNCTION RETURNS THE STRING DESCRIPTOR
* FOR THE STRING WHICH OVERLAYS THE PAGE OF THE FILE AND A FLAG SIGNAL-
* WHETHER THE FILE HAS BEEN FULLY READ.  THIS FUNCTION FAILS ONLY ON
* INTERNAL ERRORS.

       INCLUDE GLOBAL'VARIABLES;

       DECLARE INTEGER
          CHAR;              /* A CHARACTER READ FROM THE FILE        */

       DECLARE POINTER
          FILE;              /* POINTER TO THE FILE WINDOW            */

       DECLARE STRING
          INPUT'DUMMY;       /* STRING THAT CHARACTERS ARE READ FROM  */




       STRING FUNCTION MAP'IN'NEXT'PAGE(FILE), FRETURN;

* IS THE FILE WINDOW AVAILABLE?  IS THE FILE OPEN FOR INPUT?
       WARNING IF NOT FILE.WINDOW'IN'USE OR FILE.OPERATION
          OR FILE.CHARS'LEFT < 0;

       IF FILE.CHARS'LEFT = 0 DO;
          SETUP'KLUDGE(INPUT'DUMMY, 0, FILE.WINDOW'ADDRESS,
             FILE.CHARACTER'SIZE//FRETURN);
          RETURN (INPUT'DUMMY, TRUE);
       ENDIF;
       FILE.PAGE'IN'WINDOW ← FILE.PAGE'IN'WINDOW + 1;
       CLEAR'PMT(FILE.PMT'INDEX//DISTRESS);
       MOVE'PAGE'PMT(FILE.FILE'NUM, FILE.PAGE'IN'WINDOW, FILE.PMT'INDEX//
          DISTRESS);

* IF THERE'S MORE THAN A PAGE LEFT
       IF FILE.CHARS'LEFT > FILE.CHARS'PER'PAGE DO;
          SETUP'KLUDGE(INPUT'DUMMY, FILE.CHARS'PER'PAGE,
             FILE.WINDOW'ADDRESS, FILE.CHARACTER'SIZE//FRETURN);
          INPUT'DUMMY$WP ← INPUT'DUMMY$EP;
          FILE.CHARS'LEFT ← FILE.CHARS'LEFT - FILE.CHARS'PER'PAGE;

* IF IT'S THE LAST PAGE
       ELSE DO;
          INPUT'DUMMY ← DET'END'OF'FILE(FILE//FRETURN);
       ENDIF;
       RETURN (INPUT'DUMMY, FALSE);


       END;

       PROGRAM DET'END'OF'FILE;

*      THIS FUNCTION DETERMINES WHERE THE LAST ACTUAL CHARACTER OF THE
* FILE IS.  THE MONITOR KNOWS THE LENGTH OF THE FILE IN WORDS.  THE
* REASON THINGS ARE SO INEXACT IS BECAUSE ON ONE KNEW HOW MANY EOF'S OLD
* SPL WROTE INTO FILES.  THIS FUNCTION WILL SET THE WRITE POINTER OF
* THE STRING TO THE RIGHT PLACE IF THE FIRST EOF IS ANYWHERE IN THE LAST
* WORD OR EVEN IF THERE IS NO EOF WRITTEN.  THE FUNCTION RETURNS A
* STRING DESCRIPTOR SETUP TO READ HOWEVER MANY CHARACTERS ARE LEFT IN
* THE FILE.

       INCLUDE GLOBAL'VARIABLES;

       DECLARE INTEGER
          CHAR,              /* A CHARACTER READ FROM THE STRING      */
          COUNT;             /* JUST A COUNTER FOR A FOR LOOP        */

       DECLARE PARAMETER
          CHARS'TO'CHECK ← 3;/* THE SPAN OF CHARACTERS CHECKED WHILE  */
                             /*   LOOKING FOR THE EOF CHARACTER       */

       DECLARE POINTER
          FILE;              /* A POINTER TO THE WINDOW IN USE        */

       DECLARE STRING
          LAST'FILE'PAGE;    /* THE STRING WHICH OVERLAYS THE WORDS   */
                             /*   OF THE FILE                         */



       STRING FUNCTION DET'END'OF'FILE(FILE), FRETURN;

       SETUP'KLUDGE(LAST'FILE'PAGE, FILE.CHARS'LEFT,
          FILE.WINDOW'ADDRESS, FILE.CHARACTER'SIZE//FRETURN);
       LAST'FILE'PAGE$WP ← LAST'FILE'PAGE$EP;
       LAST'FILE'PAGE$RP ← INCDES(LAST'FILE'PAGE$EP, -CHARS'TO'CHECK);

       FOR COUNT ← 1 TO CHARS'TO'CHECK DO;
          GOTO END'OF'FILE IF (CHAR ← GCI(LAST'FILE'PAGE) A' 177B = EOF);
       ENDFOR;
END'OF'FILE:
       LAST'FILE'PAGE$WP ← INCDES(LAST'FILE'PAGE$RP, -1) IF CHAR = EOF;
       SETR(LAST'FILE'PAGE, 0);
       FILE.CHARS'LEFT ← 0;

       RETURN LAST'FILE'PAGE;


       END;

       PROGRAM OUTPUT'SEQ'FILE;

*      THIS FUNCTION APPENDS THE STRING SPECIFIED BY ITS SECOND ARGUMENT
* TO THE FILE SPECIFIED BY THE SECOND ARGUMENT.  THE FIRST TIME THIS 
* FUNCTION IS CALLED AFTER OPENING THE FILE, ONE OF THE WCI'S WILL FAIL
* BECAUSE FILE.WRITE'DESC WAS SETUP WITH A LENGTH OF ZERO.  CREATE'NEW'-
* PAGE IS THEN CALLED TO CREATE ANOTHER FILE PAGE.  IT IS EXPECTED THAT
* INPUT'LINE WILL BE A STRING IN THE 940 CHARACTER SET, SO THAT THE
* STRING CAN SIMPLY BE WRITTEN INTO THE FILE.  THIS FUNCTION FAILS ONLY
* IF CREATE'NEW'PAGE FAILS.

       INCLUDE GLOBAL'VARIABLES;

       DECLARE INTEGER
          CHAR,              /* A CHARACTER TO BE WRITTEN INTO A FILE */
          FILE'NUMBER;       /* THE NUMBER OF THE FILE                */

       DECLARE POINTER
          FILE;              /* A POINTER TO THE FILE WINDOW          */

       DECLARE STRING
          INPUT'LINE,        /* THE STRING FROM WHICH CHARACTERS ARE  */
                             /*   WRITTEN INTO THE FILE               */
          OUTPUT'DUMMY;      /* A WORKING STRING                      */



       FUNCTION OUTPUT'SEQ'FILE(FILE'NUMBER, INPUT'LINE), FRETURN;

       FILE ← @SEQ'FILE'TABLE[OPEN'FILE'TABLE[FILE'NUMBER]];
       OUTPUT'DUMMY ← FILE.WRITE'DESC;
       WHILE 1 DO;
          CHAR ← GCI(INPUT'LINE//
             FILE.WRITE'DESC ← OUTPUT'DUMMY & RETURN);
WRITE'CHAR:
          WCI(CHAR, OUTPUT'DUMMY//OUTPUT'DUMMY ←
                CREATE'NEW'PAGE(FILE//FRETURN) & GOTO WRITE'CHAR);
       ENDFOR;



       END;

       PROGRAM CREATE'NEW'PAGE;

*      THIS FUNCTION CREATES A NEW FILE PAGE SO THAT MORE CHARACTERS CAN
* BE WRITTEN OUT TO THE FILE.  IT RESETS THE STRING OUTPUT'DUMMY SO MORE
* CHARACTERS CAN BE WRITTEN INTO IT AND OVERLAYS THE STRING ON THE PAGE
* IT HAS JUST CREATED.  THE LENGTH OF THE FILE KEPT IN THE WINDOW IS
* INCREMENTED BY A PAGE WORTH OF CHARACTERS.  IF THE PAGE ISN'T FILLED,
* CLOSE'SEQ'FILE SETS THE EXACT LENGTH WHEN IT TRIES TO CLOSE THE FILE.
* THIS FUNCTION FAILS IF ANY OF THE MONITOR CALLS IT USES FAILS.

       INCLUDE GLOBAL'VARIABLES;

       DECLARE POINTER
          FILE;              /* A POINTER TO THE FILE WINDOW          */

       DECLARE STRING
          OUTPUT'DUMMY;      /* THE STRING THAT THE CHARACTERS WILL   */
                             /*   BE WRITTEN INTO                     */



       STRING FUNCTION CREATE'NEW'PAGE(FILE), FRETURN;

* IS THE FILE REALLY OPEN?  IS IT OPEN FOR OUTPUT?
       WARNING IF NOT FILE.WINDOW'IN'USE OR NOT FILE.OPERATION;

* DO THINGS TO MAP IN A NEW PAGE INTO THE WINDOW
       FILE.PAGE'IN'WINDOW ← FILE.PAGE'IN'WINDOW + 1;
       CREATE'FILE'PAGE(FILE.FILE'NUM, FILE.PAGE'IN'WINDOW//
          DISTRESS);
       CLEAR'PMT(FILE.PMT'INDEX//DISTRESS);
       MOVE'PAGE'PMT(FILE.FILE'NUM, FILE.PAGE'IN'WINDOW, FILE.PMT'INDEX//
          DISTRESS);
       SETUP'KLUDGE(OUTPUT'DUMMY, FILE.CHARS'PER'PAGE,
          FILE.WINDOW'ADDRESS, FILE.CHARACTER'SIZE//FRETURN);

       FILE.LENGTH'IN'CHARS ← FILE.PAGE'IN'WINDOW*FILE.CHARS'PER'PAGE;
       RETURN OUTPUT'DUMMY;



       END;

       PROGRAM PREPARE'APPEND;

*      THIS FUNCTION IS A SPECIAL CASE OF MAP'IN'NEXT'PAGE WHERE THE
* PAGE WHICH WILL BE MAPPED INTO THE WINDOW IS THE LAST PAGE OF THE FILE.

       INCLUDE GLOBAL'VARIABLES;

       DECLARE INTEGER
          LAST'PAGE;         /* THE LAST PAGE OF THE FILE             */

       DECLARE POINTER
          FILE;              /* A POINTER TO THE FILE WINDOW          */

       DECLARE STRING
          APPEND'DESC;       /* THE STRING DESCRIPTOR SET UP SO THAT  */
                             /*   THE FILE CAN HAVE MORE CHARACTERS   */
                             /*   APPENDED TO IT                      */




       STRING FUNCTION PREPARE'APPEND(FILE, LAST'PAGE), FRETURN;

* IS THE FILE REALLY OPEN?  IS IT OPEN FOR OUTPUT?
       WARNING IF NOT FILE.WINDOW'IN'USE OR
          FILE.OPERATION # APPEND'FILE;

* DO THINGS TO MAP IN A NEW PAGE INTO THE WINDOW
       FILE.PAGE'IN'WINDOW ← LAST'PAGE;
       CLEAR'PMT(FILE.PMT'INDEX//DISTRESS);
       MOVE'PAGE'PMT(FILE.FILE'NUM, FILE.PAGE'IN'WINDOW, FILE.PMT'INDEX//
          DISTRESS);
*      CHANGE THE CHARACTER COUNT SO DET'END'OF'FILE DOESN'T CREATE A
* STRING OVER A PAGE LONG.
       FILE.CHARS'LEFT ← FILE.CHARS'LEFT - FILE.CHARS'PER'PAGE*LAST'PAGE;
       APPEND'DESC ← DET'END'OF'FILE(FILE//FRETURN);
*      MOVE THE END POINTER OF THE STRING SO THAT THE STRING IS A WHOLE
* PAGE LONG.
       APPEND'DESC$EP ← INCDES(APPEND'DESC$BP, FILE.CHARS'PER'PAGE);
       FILE.LENGTH'IN'CHARS ← FILE.CHARS'PER'PAGE*(FILE.PAGE'IN'WINDOW);

       RETURN APPEND'DESC;



       END;

       PROGRAM CLOSE'SEQ'FILE;

*      THIS FUNCTION CLOSES THE FILE SPECIFIED BY ITS ONLY ARGUMENT.
* IT IS CALLED TO CLOSE BOTH FILES WHICH WERE OPENED FOR INPUT AND OUT-
* PUT.  HOWEVER, FOR FILES WHICH HAVE BEEN OPENED FOR OUTPUT, IT MUST
* DETERMINE THE EXACT LENGTH OF THE FILE AND LET THE MONITOR KNOW ABOUT
* IT.  THE FUNCTION FAILS ONLY FOR INTERNAL REASONS: THE FILE IS ALREADY
* CLOSED, OR ONE OF THE MONITOR CALLS IT USES FAILS.

       INCLUDE GLOBAL'VARIABLES;

       DECLARE INTEGER
          FILE'NUMBER,
          LENGTH'IN'WORDS;   /* LENGTH OF THE FILE IN WORDS           */

       DECLARE POINTER
          FILE;              /* A POINTER TO THE FILE WINDOW          */



       UNKNOWN FUNCTION CLOSE'SEQ'FILE(FILE'NUMBER), FRETURN;

       FILE ← @SEQ'FILE'TABLE[OPEN'FILE'TABLE[FILE'NUMBER]];
* CHECK TO SEE IF WHAT IT IS GOING TO BE CLOSED ALREADY IS
       WARNING IF NOT FILE.WINDOW'IN'USE;
       IF FILE.OPERATION DO;
          OUT'CHAR'FILE(FILE'NUMBER, EOF//FRETURN);
          LENGTH'IN'WORDS ←
             (LENGTH(FILE.WRITE'DESC)*(FILE.CHARACTER'SIZE) + 23)/24;
          SET'FILE'LENGTH(FILE'NUMBER, LENGTH'IN'WORDS -1//
             DISTRESS);
       ENDIF;

* FREE THE WINDOW
       CLOSE'FILE(FILE'NUMBER//DISTRESS);
       FILE.WINDOW'IN'USE ← 0;
       OPEN'FILE'TABLE[FILE'NUMBER] ← -1;
       DELETE'PMT(FILE.PMT'INDEX//DISTRESS);

       RETURN;



       END;

       PROGRAM OUTPUT'TO'FILE;

*      THIS PROGRAM BLOCK CONTAINS FUNCTIONS USED TO OUTPUT CHARACTERS,
* WORDS, AND NUMBERS TO FILES.

       DECLARE INTEGER
          BASE,              /* THE BASE OF THE NUMBER TO OUTPUT      */
          CHAR,              /* THE CHARACTER TO OUTPUT               */
          FILE'NUMBER,       /* THE NUMBER OF THE FILE                */
          NUMBER,            /* THE NUMBER TO OUTPUT                  */
          SIGN'NUM'CHARS,    /* DETERMINES THE NUMBER OF DIGITS TO    */
                             /*   CONVERT THE NUMBER TO AND WHETHER   */
                             /*   IT  WILL BE SIGNED                  */
          WORD;              /* THE WORD TO OUTPUT                    */

       DECLARE STRING
          CHAR'REPRES        /* THE CHARACTER REPRESENTATION OF THE   */
             (100),          /*   NUMBER TO BE OUTPUT AFTER CONVERSION*/
          OUTPUT;            /* THE STRING TO OUTPUT                  */



       UNKNOWN FUNCTION OUT'CHAR'FILE(FILE'NUMBER, CHAR), FRETURN;

       IF FILE'NUMBER = -1 DO;
          OUT'CHAR'TTY(CHAR//FRETURN);
          RETURN;
       ENDIF;
       SETUP(OUTPUT, 3, @CHAR);
       SETS(OUTPUT, 2, 3);
       OUTPUT'SEQ'FILE(FILE'NUMBER, OUTPUT//FRETURN);
       RETURN;



       UNKNOWN FUNCTION OUT'WORD'FILE(FILE'NUMBER, WORD), FRETURN;

       IF FILE'NUMBER = -1 DO;
          OUT'WORD'TTY(WORD//FRETURN);
          RETURN;
       ENDIF;
       SETUP(OUTPUT, 3, @WORD);
       OUTPUT'SEQ'FILE(FILE'NUMBER, OUTPUT//FRETURN);
       RETURN;

       UNKNOWN FUNCTION OUT'NUMBER'FILE(FILE'NUMBER, NUMBER,
          SIGN'NUM'CHARS, BASE), FRETURN;

       IF FILE'NUMBER = -1 DO;
          OUT'NUMBER'TTY(NUMBER, SIGN'NUM'CHARS, BASE//FRETURN);
          RETURN;
       ENDIF;
       CNS(NUMBER, CHAR'REPRES, SIGN'NUM'CHARS, BASE//FRETURN);
       OUTPUT'SEQ'FILE(FILE'NUMBER, CHAR'REPRES//FRETURN);
       RETURN;



       UNKNOWN FUNCTION OUT'CHAR'TTY(CHAR), FRETURN;
       SETUP(OUTPUT, 3, @CHAR);
       SETS(OUTPUT, 2, 3);
       OUTPUT'STRING(OUTPUT);
       RETURN;



       UNKNOWN FUNCTION OUT'WORD'TTY(WORD), FRETURN;
       SETUP(OUTPUT, 3, @WORD);
       OUTPUT'STRING(OUTPUT);
       RETURN;



       UNKNOWN FUNCTION OUT'NUMBER'TTY(NUMBER, SIGN'NUM'CHARS, BASE),
          FRETURN;
       CNS(NUMBER, CHAR'REPRES, SIGN'NUM'CHARS, BASE//FRETURN);
       OUTPUT'STRING(CHAR'REPRES);
       RETURN;


       END;

       PROGRAM TERMINAL'IO;

*      THIS PROGRAM BLOCK CONTAINS THE TERMINAL INPUT AND OUTPUT
* FUNCTIONS.  THESE FUNCTIONS DON'T HAVE FRETURNS, BUT CALL THE FUNCTION
* SYSTEM'ERROR WHICH WILL RETURN IMMEDIATELY IF THE FLAG DEBUGGING ISN'T
* SET, WHICH MAY TOTALLY SCREW THINGS UP.  HOWEVER, ALL CALLS TO THESE
* FUNCTION ARE MADE ONLY IF DEBUGGER HAS BEEN SET.

       INCLUDE GLOBAL'VARIABLES;

       DECLARE CHARACTER
          CHAR;              /* THE CHARACTER TO INPUT OR OUTPUT      */

       DECLARE STRING
          INPUT,             /* THE STRING READ IN FROM THE TERMINAL  */
          OUTPUT;            /* THE STRING TO OUTPUT TO THE TERMINAL  */




* IF THE FUNCTION FAILS, THE CHARACTER RETURNED WILL BE A BLANK
       CHARACTER FUNCTION INPUT'CHARACTER();
       CHAR ← READ'CHAR(-1, 0//
          SYSTEM'ERROR() & 0: ERROR'CODE, ERROR'NUMBER);
       RETURN CHAR;


       UNKNOWN FUNCTION OUTPUT'CHARACTER(CHAR);
       PRINT'CHAR(-1, CHAR, 0//
          SYSTEM'ERROR(): CHAR, ERROR'CODE, ERROR'NUMBER);
       START'OUTPUT(-1, 0//SYSTEM'ERROR(): ERROR'CODE, ERROR'NUMBER);
       RETURN;



*      IF THE FUNCTIONS FAILS, THE STRING RETURNED WILL BE WHATEVER
* WAS IN INPUT AT THAT POINT
       STRING FUNCTION INPUT'STRING(INPUT);
       INPUT ← READ'LINE(-1, INPUT, "", 0//
          SYSTEM'ERROR() & INPUT: INPUT, ERROR'CODE, ERROR'NUMBER);
       RETURN INPUT;


       UNKNOWN FUNCTION OUTPUT'STRING(OUTPUT);
       PRINT'STRING(-1, OUTPUT, 0//
          SYSTEM'ERROR(): OUTPUT, ERROR'CODE, ERROR'NUMBER);
       RETURN;


       END;

       PROGRAM FAILURES;

*      THIS PROGRAM BLOCK CONTAINS THE FUNCTIONS CALLED WHEN SOMETHING
* GOES WRONG

       INCLUDE GLOBAL'VARIABLES;

       DECLARE INTEGER
          ERROR'ADDR = L'[0];/* ADDRESS OF CALLING STATEMENT          */
                             /*   (WHERE FAILURE OCCURRED)            */

       DECLARE STRING
          EXPLANATION;       /* JUST A STRING USED TO WRITE INTO      */



*      RUNTIME FAILURE IS CALLED WHEN THE PROGRAM ARRIVES SOMEWHERE IT
* ISN'T SUPPOSED TO, USUALLY CAUSED BY SEVERAL UNFORTUNATE CIRCUMSTANCES
* (SUCH AS TRYING TO CLOSE A FILE THAT'S ALREADY CLOSED OR TRYING TO
* TO WRITE MORE CHARACTERS INTO A STRING THAN WILL FIT)
       UNKNOWN FUNCTION RUNTIME'FAILURE();
       FOR'OUTPUT'TTY ("&/RUNTIME FAILURE AT P = #B");
       OUTPUT'NUMBER (ERROR'ADDR);
       OUTPUT'STRING("&/");
       EXIT();


* SYSTEM'ERROR IS CALLED WHEN A MONITOR OR UTILITY CALL HAS FAILED
       UNKNOWN FUNCTION SYSTEM'ERROR();
       OUTPUT'STRING("&/SYSTEM CALL FAILED: CODE = ");
       SETUP (EXPLANATION, 3, @ERROR'CODE);
       SETS (EXPLANATION, 0, 3);
       OUTPUT'STRING(EXPLANATION);
       FOR'OUTPUT'TTY (", NUMBER = *");
       OUTPUT'NUMBER (ERROR'NUMBER);
       FOR'OUTPUT'TTY (" AT P = #B");
       OUTPUT'NUMBER (ERROR'ADDR);
       OUTPUT'STRING("&/");
       EXIT();


*      FATAL'ERROR IS CALLED WHEN AN ERROR OCCURS THAT WILL ALWAYS OCCUR
* EVEN IF RERUN (SUCH AS COMPARING THE LENGTH OF TWO STRINGS WITH DIF-
* FERENT CHARACTER SIZES)
       UNKNOWN FUNCTION FATAL'ERROR();
       FOR'OUTPUT'TTY ("&/FATAL ERROR AT P = #B");
       OUTPUT'NUMBER (ERROR'ADDR);
       OUTPUT'STRING("&/");
       EXIT();

       END;

       PROGRAM FORMATTED'OUTPUT;

*      THIS PROGRAM BLOCK CONTAINS THE FUNCTIONS WHICH FORMAT OUTPUT
* THE FUNCTIONS FOR'OUTPUT'FILE AND OUTPUT'NUMBER WORK AS COUROUTINES
* FOR'OUTPUT'TTY IS JUST A SPECIAL CASE OF FOR'OUTPUT'FILE.
*      FORMATTED'OUTPUT CONVERTS THE NUMBER TO A STRING AND OUTPUTS
* THEM TO A FILE, OR THE TELETYPE.

       INCLUDE GLOBAL'VARIABLES;

       DECLARE INTEGER
          BASE,              /* THE BASE THE NUMBER IS IN             */
          CHAR,              /* A CHARACTER READ FROM A STRING        */
          FILE'NUMBER,       /* THE NUMBER OF THE FILE                */
          NUMBER,            /* THE NUMBER WHICH MUST BE OUTPUT       */
          SIGN'UNSIGN;       /* NUMBER DETERMINING WHETHER THE NUMBER */
                             /*   WILL BE SIGNED OR UNSIGNED          */

       DECLARE STRING
          OUTPUT;            /* THE STRING TO BE OUTPUT               */



       UNKNOWN FUNCTION FOR'OUTPUT'FILE(OUTPUT, FILE'NUMBER);

       ERROR'FILE'NUM ← FILE'NUMBER;
FOF0:  SCOPY(ERROR'STRING, OUTPUT//EXIT());

       WHILE 1 DO;
          CHAR ← GCI(ERROR'STRING//RETURN);
          IF CHAR = '&'' DO;
             OUT'CHAR'FILE(ERROR'FILE'NUM, GCI(ERROR'STRING//EXIT())//
                EXIT());
          ELSEIF CHAR = '/' DO;
             OUTPUT'SEQ'FILE(ERROR'FILE'NUM, M1'NL//EXIT());
          ELSEIF CHAR = '#' DO;
             ERROR'RADIX ← 8;
             RETURN;         /* COROUTINE RETURN                      */
          ELSEIF CHAR = '*' DO;
             ERROR'RADIX ← 10;
             RETURN;         /* COROUTINE RETURN                      */

* CHAR IS NOT UNDEFINED BECAUSE THE ONLY WAY TO GET HERE IS BY ENTERING
*   THROUGH OUTPUT'NUMBER
FOF1:     OUT'NUMBER'FILE(ERROR'FILE'NUM, NUMBER,
             4B7 IF NUMBER < -4B4 ELSE 0, ERROR'RADIX//EXIT());

          ELSEIF CHAR < 100B DO;
             OUT'CHAR'FILE(ERROR'FILE'NUM, CHAR//EXIT());
          ENDIF;
       ENDFOR;

       UNKNOWN FUNCTION FOR'OUTPUT'TTY(OUTPUT);
       ERROR'FILE'NUM ← -1;
       GOTO FOF0;


       UNKNOWN FUNCTION OUTPUT'NUMBER(NUMBER);
       GOTO FOF1;



       END;

       PROGRAM SP'TRAP'HANDLER;

*      THIS PROGRAM WILL EVENTUALLY HANDLE MORE SP'TRAPS, BUT NOW IT
* JUST HANDLES QUITS(CONTROL-K), AND TYPES OUT ERROR MESSAGES FOR THE REST

       INCLUDE GLOBAL'VARIABLES, ENTRY'DEFS;

       DECLARE ARRAY
          CALLER'STATE[5];   /* A SPCS ENTRY                          */


       DECLARE INTEGER
          QUIT ← 23,         /* TRAP GENERATED BY TYPING A CONTROL-K  */
          CUR'STACK'LEVEL,   /* CURRENT STACK LEVEL                   */
          SP'TRAP'NO,        /* THE NUMBER OF THE SUB-PROCESS TRAP    */
                             /*   GENERATED, THE TRAP NUMBER CORRES-  */
                             /*   PONDS TO THE BIT POSITION IN THE    */
                             /*   TM OF THE SPT WHICH IDENTIFYS IT    */
          SP'TRAP'PARAM,     /* THE PARAMETER PASSED WHEN THE SP'TRAP */
                             /*   IS GENERATED, IT IS USUALLY THE AD- */
                             /*   DRESS OF THE GUILTY STATEMENT       */
          TM'BITS'SET;




       FUNCTION SP'TRAP'HANDLER(SP'TRAP'NO, SP'TRAP'PARAM);

* REARM QUIT TRAPS
       TM'BITS'SET ← READ'SPT'FIELD(THIS'SUB'PROCESS, 'TM'//
          SYSTEM'ERROR(): ERROR'CODE, ERROR'NUMBER);
       SET'SPT'FIELD(THIS'SUB'PROCESS, 'TM', (TM'BITS'SET V' 1B)//
          SYSTEM'ERROR(): ERROR'CODE, ERROR'NUMBER);

       STATE[L'INDEX] ← CALLER'STATE[0]$LR;
       STATE[G'INDEX] ← CALLER'STATE[0]$GR;

* TAKE CARE OF QUITS
*      IF SP'TRAP'NO = QUIT DO;
*         STATE[0] ← @EXIT'QUIT;
*         .EAX STATE[0], .LOADS;
*EXIT'QUIT:SP'RETURN(//SYSTEM'ERROR(): ERROR'CODE, ERROR'NUMBER);
*      ELSE DO;
*      MAY HAVE TO DO FANCIER THINGS, SUCH AS READING THE SPCS ENTRY
* OF THE CALLER INTO CALLER'STATE
          FOR'OUTPUT'TTY("&/SUB-PROCESS TRAP NUMBER #B, AT #B");
          OUTPUT'NUMBER(SP'TRAP'NO);
          OUTPUT'NUMBER(SP'TRAP'PARAM);
          CUR'STACK'LEVEL ← READ'SPS'PARAM('CSL'//
             SYSTEM'ERROR(): ERROR'CODE, ERROR'NUMBER);
          JUMP'RETURN(CUR'STACK'LEVEL - INIT'STACK'LEVEL//
             SYSTEM'ERROR(): ERROR'CODE, ERROR'NUMBER);
*      ENDIF;


       END;

       PROGRAM EXIT;

* THIS PROGRAM PERFORMS THE RETURN TO THE EXECUTIVE

       INCLUDE GLOBAL'VARIABLES;

       DECLARE STRING
          LINE;



       UNKNOWN FUNCTION EXIT'KLUDGE(LINE);


       UNKNOWN FUNCTION EXIT();
       SP'RETURN(// VALUE HALT(): ERROR'CODE, ERROR'NUMBER);

       UNKNOWN FUNCTION HALT();
       .HLT 0;





       END;
INSTRUCTIONS FOR THE USE OF FORM-LETTER FACILITY:

       TWO FILES ARE NEEDED FOR THIS PROGRAM, BOTH PREPARED IN ADVANCE
BY RUNOFF.  THE FIRST IS A FILE OF ADDRESSEES, CALLED THE NAMES FILE.
THE SECOND IS THE TEXT OF A FORM LETTER INTO WHICH EACH ADDRESSEE WILL
BE PLACED, IN TURN.

       THE NAMES FILE IS MADE BY PREPARING THE ADDRESSEES FOR RUNOFF
PROCESSING IN THE FOLLOWING WAY:

.NOFILL
.PAGING MODE OFF
.LAYOUT 1,80,6,66,79,0
.LINE LAYOUT 1,72
/DOPE, /MS. /IMA /J.
123 /E. /MAIN /ST.
/ANYWHERE, /U./S./A. 12345

/SUCKFINGER, /MR. /CLYDE /F.
507 /ALA /MOANA /BLVD. #702
/HONOLULU, /HAWAII 96813

/HORSESHIT, /CAPT. /HERBERT /Q.
23RD /ARMORED /DIVISION
/COMPANY "/C"
C↑/O ↑CFPO
/SAN /FRANCISCO, /CALIF. 94600

/GOTOHELL, /MISS /WHYDON' /CHU
#3 /MAIDEN /LANE
/HONG /KONG

QUIT

       THE FOLLOWING PROGRAM WILL CONVERT A FILE LIKE THE ABOVE
WITHOUT ANY RUNOFF CONTROLS INTO ONE EXACTLY LIKE RUNOFF NEEDS
TO MAKE THE NAMES FILE.  THE ORIGINAL FILE NEED BE JUST TYPED ON
THE TERMINAL WITH NO REGARD PAID TO CAPITALIZATION.  THE PROGRAM
PROBABLY CANNOT BE PERFECT ALL THE TIME; BUT ANY
ERRORS MADE BY IT WILL BE DETECTED BY THE PROOFREADING OF THE NAMES
FILE.

PREPAR IDENT

OUTPUT MACRO D,G,2; LDA =G(1); LDB =-1; LDX OFNO; BRS 34; BRU G(2)
G(1)   ASC 'D(1).&$.&/'
G(2)   EQU *; ENDM

SKNE   MACRO D; SKE D(1); BRU *+2; ENDM

MSG    MACRO D,F,2; LDA =F(1); LDB =-1; LDX =1; BRS 34; BRU F(2)
F(1)   ASC '$.&D(1).&/'
F(2)   EQU *; ENDM

START  MSG (INPUT FILE: ); CLEAR; BRS 15; BRU START; STA IFNO
S1     MSG (OUTPUT FILE: ); CLEAR; LDA =3B6; BRS 16; BRU S1; STA OFNO
       TCO =155B; TCO =152B
       OUTPUT (.NOFILL)
       OUTPUT (.PAGING MODE OFF)
       OUTPUT (.LAYOUT 1,80,6,66,79,0)
       OUTPUT (.LINE LAYOUT 1,72)
LOOP   CLA; STA CCOUNT
LOOP1  CIO IFNO; SKNE =' '; BRU BLANK
       SKNE =135B; BRU BLANKS
       SKNE =155B; BRU CRLF
       SKNE =137B; BRU DONE
       STA TCHAR; LDA CCOUNT; SKG =0; BRU *+2; BRU NORMAL
       LDA TCHAR; SKG ='Z'; SKG ='A'-1; BRU BLANK
       LDA ='/'; CIO OFNO
NORMAL LDA TCHAR; CIO OFNO; MIN CCOUNT; BRU LOOP1

BLANK  CIO OFNO; BRU LOOP

BLANKS CIO OFNO; CIO IFNO; CIO OFNO; BRU LOOP

CRLF   CIO OFNO; CIO IFNO; CIO OFNO; BRU LOOP

DONE   CIO OFNO; BRS 17; BRS 10

IFNO   BSS 1
OFNO   BSS 1
CCOUNT BSS 1
TCHAR  BSS 1

       END

       THE TEXT FILE IS ALSO MADE BY RUNOFF ACCORDING TO THE
FOLLOWING PRESCRIPTION:

.PAGING MODE OFF
.RM 0,7
.SP 8
.IN 37
/OCTOBER 25, 1976
.SP 5
←
.SP 2
/DEAR ↑↑:
       /THIS IS JUST A NOTE WELCOMING YOU TO THE /ISLANDS, IN KEEPING
WITH THE SPIRIT OF /ALOHA.
       /MY FIRM, /MIKE /MC/CORMACK /REALTORS, IS THE LARGEST REAL
...
...
/I WOULD BE MOST PLEASED IF /I COULD HELP TO MAKE YOUR MOVE TO THE /ISLANDS
A MORE PLEASANT EXPERIENCE.
.SP
.IN 23
/ALOHA AND MAHALO,
.SP 4
.IN 23
/BONNIE /A. /LICHTENBERGER

.IN 23
/REALTOR /ASSOCIATE
.SP 3
BAL↑/BCC

/ENCLOSURE

       BOTH FILES ARE RUN OFF AND PROOFREAD.  THE NAMES FILE SHOULD
CONSIST OF CONSECUTIVE ADDRESSEES EACH SEPARATED BY ONE BLANK LINE
OR A LINE BEGINNING WITH '*' (THE REST OF LINE CAN BE COMMENTS).
THE TEXT FILE SHOULD LOOK JUST LIKE THE FINAL COPY, WITH THE EXCEPTION
THAT THE "←" CAUSES INSERTION AT THAT POINT OF THE NEXT ADDRESSEE, AND
THE "↑" CAUSES THE TITLE AND NAME TO BE INSERTED.

       NOTE THAT EACH ADDRESSEE IS PLACED IN THE NAMES FILE BY
LAST NAME FIRST (FOR EASY SORTING PERHAPS LATER) FOLLOWED BY A TITLE:
MR., MRS., ETC.  COMPOUND NAMES, E.G., "ST. DENIS" CAN BE HANDLED BY
PLACING THEM IN PARENTHESES, E.G., "(ST. DENIS)".  COMPOUND TITLES,
E.G., "MR. & MRS." ARE HANDLED THE SAME WAY.

       WHEN BOTH BASIC CONSTITUENT FILES ARE READY.  THE MERGING
PROGRAM WHICH FOLLOWS IS ASSEMBLED, LOADED, AND STARTED.  IT AKS
FOR EACH OF THE FILES BY NAME, AND ALSO FOR THE NAME OF AN OUTPUT FILE.
THE OUTPUT FILE IS THEN PRINTED BY KDF ON THE HYTYPER.

       FOR PRINTING ON THE HYTYPER, USE THE "PAUSE AFTER EACH PAGE" MODE.


       IDENT LETTER;

* PROGRAM TO PLACE ENTRIES FROM A FILE OF ADDRESSEES INTO A TEXT FILE
*      CONTAINING A FORM LETTER.

* DECLARATIONS
       DECLARE PARAMETER CR←'&M',EOFCHR←137B,FF←'&L',LF←'&J',SYM9←3B6;
       DECLARE PARAMETER BLKCNT←135B;
       DECLARE INTEGER CCOUNT,CHR,LAROFLG,NFNO,OFNO,TFNO,UPAROFLG;
       DECLARE INTEGER TRMCHR;
       DECLARE STRING JUNIOR(10),NAME(35),NFNAME(20),OFNAME(20);
       DECLARE STRING TEMPSTR(0),TFNAME(20),TITLE(20);



* START OF PROGRAM.  OPEN FILE OF ADDRESSEES ...
START: SOUT("&M&JNAMES FILE: ");
       SETS(NFNAME,0,0);
       INNAME(NFNAME:START);
       NFNO←INFILE(NFNAME:START);

* OPEN TEXT FILE CONTAINING FORM LETTER ...
S1:    SOUT("&M&JFORM LETTER FILE: ");
       SETS(TFNAME,0,0);
       INNAME(TFNAME:S1);
       TFNO←INFILE(TFNAME:S1);

* OPEN OUTPUT FILE & RETURN CARRIAGE ON TERMINAL ...
S2:    SOUT("&M&JOUTPUT FILE: ");
       SETS(OFNAME,0,0);
       OUTNAME(OFNAME:S2);
       OFNO←OUTFILE(OFNAME,SYM9:S2);
       CRLF(1);

* PUT HEADING ONTO OUTPUT FILE ...
       SOUT("**RUNOFF&M&J&L",OFNO);

* SKIP TO & INCLUDING FF IN NAMES FILE ...
       SKIP(FF,NFNO);



* MAIN LOOP STARTS HERE.  LOOP TERMINATES WHEN THE NAMES FILE IS
*      EXHAUSTED.  THE GNC FUNCTION TAKES ITS FAILURE RETURN.
       WHILE 1 DO;

* POSITION TEXT FILE TO BEGINNING & SKIP TO 1ST FF ...
          BRS(144,0,00010001B,TFNO);
          SKIP(FF,TFNO);

* INITIALIZE SOME THINGS ...
          LAROFLG←UPAROFLG←CCOUNT←0;

* COPY THE TEXT FILE TO THE OUTPUT FILE, PAUSING TO TAKE CARE OF A
*      FEW THINGS ...
          WHILE (CHR←CIN(TFNO))#EOFCHR DO;
             IF LAROFLG=0 AND CHR='←' DO;

* INSERT ADDRESSEE IN PLACE OF 1ST '←' ...
                LAROFLG←-1;

* FIRST, INITIALIZE STRING POINTERS ...
                SETS(NAME,0,0); SETS(TITLE,0,0); SETS(JUNIOR,0,0);

* NOW SKIP TO 1ST NON-BLANK CHARACTER & SET UP COPYING LOOP ...
                TRMCHR←',' IF (CHR←SKIP(-1,NFNO))#'(' ELSE TRMCHR←')';

* COPY TO END OF NAME ONTO NAME STRING ...
                WCI(CHR,NAME:FTLERR) IF TRMCHR=',';
                WCI(CHR,NAME:FTLERR) WHILE (CHR←GNC(:DONE))#TRMCHR;
                SKIP(',',NFNO) IF TRMCHR=')';

* SKIP TO 1ST NON-BLANK CHARACTER AGAIN ...
                TRMCHR←' ' IF (CHR←SKIP(-1,NFNO))#'(' ELSE TRMCHR←')';

* COPY TITLE ONTO TITLE STRING ...
                WCI(CHR,TITLE:FTLERR) IF TRMCHR=' ';
                WCI(CHR,TITLE:FTLERR) WHILE ((CHR←GNC(:FTLERR))#TRMCHR
                                      AND (CHR#',' OR TRMCHR#' ')
                                      AND CHR#CR);
                CHR←GNC(:FTLERR) IF TRMCHR=')';

* COPY THE TITLE STRING TO THE OUTPUT FILE ...
                BCOPY(TEMPSTR,TITLE,4);
                COUT(GCI(TEMPSTR:L1),OFNO) WHILE 1;

* OUTPUT A BLANK ...
L1:             COUT(' ',OFNO);

* CHECK TO SEE IF THERE IS MORE LINE ...
                IF CHR#CR DO;

* CHECK TO SEE IF THE REST OF NAME IS MISSING ...
                   IF CHR#',' DO;

* COPY 1ST NON-BLANK CHARACTER FOLLOWING ONTO OUTPUT FILE ...
                      COUT(SKIP(-1,NFNO),OFNO);

* COPY FROM NAMES FILE TO OUTPUT FILE UP TO CR OR ',' ...
                      COUT(CHR,OFNO) WHILE ((CHR←GNC(:FTLERR))#CR 
                                            AND CHR#',');

                      IF CHR=',' DO;

* SKIP TO 1ST ALPHABETIC CHARACTER & COPY ONTO JUNIOR STRING ...
                         WCI(SKIP(-1,NFNO),JUNIOR:FTLERR);

* COPY FROM NAMES FILE TO JUNIOR STRING UP TO CR ...
                         WCI(CHR,JUNIOR:FTLERR) WHILE
                                             (CHR←GNC(:FTLERR))#CR;
                      ENDIF;

                   ELSE DO;

* REST OF NAME IS MISSING BUT JUNIOR IS PRESENT.  HANDLE ...
                      WCI(SKIP(-1,NFNO),JUNIOR:FTLERR);
                      WCI(CHR,JUNIOR:FTLERR) WHILE
                                          (CHR←GNC(:FTLERR))#CR;

                   ENDIF;
                ENDIF;

* GET NEXT CHARACTER FROM FILE.  IT HAD BETTER BE LF ...
                GOTO FTLERR IF GNC(:DONE)#LF;

* OUTPUT A BLANK & COPY NAME STRING TO OUTPUT FILE ...
                COUT(' ',OFNO);
                BCOPY(TEMPSTR,NAME,4);
                COUT(GCI(TEMPSTR:L2),OFNO) WHILE 1;

* MUST NOW OUTPUT JUNIOR STRING TO FILE IF NOT EMPTY ...
L2:             IF LENGTH(JUNIOR)#0 DO;
                   COUT(',',OFNO);
                   COUT(GCI(JUNIOR:L3),OFNO) WHILE 1;
                ENDIF;

* NOW OUTPUT CRLF TO FILE ...
L3:             CRLF(1,OFNO);

* COPY FROM NAMES ONTO OUTPUT FILE TO EMPTY LINE OR ONE BEGINNING W/ '*'
                WHILE ((CHR←GNC(:FTLERR))#CR AND CHR#LF AND CHR#'*') DO;

* MUST INSERT AS MANY BLANKS AS IN CCOUNT IF NOT ZERO ...
                   IF CCOUNT#0 DO;
                      COUT(BLKCNT,OFNO); COUT(CCOUNT,OFNO);
                   ENDIF;

* COPY LINE TO CR ...
                   COUT(CHR,OFNO);
                   COUT(CHR,OFNO) WHILE (CHR←GNC(:FTLERR))#CR;
                   COUT(CR,OFNO);

* COPY NEXT CHARACTER & PUNT IF NOT LF ...
                   GOTO FTLERR IF (CHR←GNC(:FTLERR))#LF;
                   COUT(LF,OFNO);
                ENDFOR;

* IF ABOVE LOOP TERMINATED ON '*', SKIP TO CR ...
                CHR←SKIP(CR,NFNO) IF CHR='*';

* IF LOOP DID NOT TERMINATE ON LF, READ CHARACTER AND CHECK FOR LF ...
                IF CHR#LF DO;
                   GOTO FTLERR IF (CHR←GNC(:FTLERR))#LF;
                ENDIF;

             ELSEIF UPAROFLG=0 AND CHR='↑' DO;

* INSERT GREETING IN PLACE OF 1ST '↑' ...
                UPAROFLG←-1;

* COPY TITLE STRING ONTO OUTPUT FILE & THEN A SINGLE BLANK ...
                COUT(GCI(TITLE:L4),OFNO) WHILE 1;
L4:             COUT(' ',OFNO);

* NOW COPY NAME STRING TO OUTPUT FILE ...
                COUT(GCI(NAME:L5),OFNO) WHILE 1;

L5:          ELSEIF CHR=CR DO;

* COPY CR & CLEAR CCOUNT ... BEGINNING NEW LINE.
                COUT(CR,OFNO);
                CCOUNT←0;

             ELSEIF CHR=LF DO;

* COPY LF ONLY ...
                COUT(LF,OFNO);

             ELSE DO;

* ELSE COPY CHR AND INCREMENT CCOUNT ...
                COUT(CHR,OFNO);
                CCOUNT←CCOUNT+1;
             ENDIF;
          ENDFOR;

* OUTPUT NEW FF ON OUTPUT FILE ...
          COUT(FF,OFNO);
       ENDFOR;

* CLOSE FILES AND QUIT ...
DONE:  COUT(EOFCHR,OFNO); CLOSALL();
       SOUT("DONE."); EXIT();


* ROUTINE TO SKIP TO DESIGNATED CHARACTER FROM DESIGNATED FILE.
*      A -1 IN THE CHARACTER MEANS ANY NON-BLANK CHARACTER ...

       DECLARE TCHAR;

       FUNCTION SKIP(SCHAR,SFILE);
       IF SCHAR>-1 DO;
          RETURN TCHAR IF (TCHAR←CIN(SFILE))=SCHAR WHILE 1;
       ELSE DO;
          RETURN TCHAR IF (TCHAR←CIN(SFILE))#' ' WHILE 1;
       ENDIF;


* FUNCTION TO GET NEXT CHARACTER FROM NAMES FILE.  THIS FUNCTION
*      CHECKS FOR EOFCHR, FAIL RETURNING IN THIS CASE .
*      IT ALSO SKIPS OVER ANY FF CHARACTERS ENCOUNTERED ...

       DECLARE GCHR;

       FUNCTION GNC();
       WHILE 1 DO;
          IF ((GCHR←CIN(NFNO))#FF AND GCHR#EOFCHR) DO;
             SRETURN GCHR;
          ELSEIF GCHR=EOFCHR DO;
             RETURN GCHR;
          ENDIF;
       ENDFOR;
   


       END;
        COMMON M30PAR; INCLUDE INTERCOM;

         DECLARE ARRAY COMTAB0[24]←(136,129,
         130,139,132,133,142,135,184,177,178,187,
         180,189,190,183,72,65,66,75,68,77,78,71);
        DECLARE ARRAY COMTAB1[8]←(120,113,114,
         123,116,125,126,119);
*   COMTAB1 HAS THE RESPONSE CODES FROM THE HP.  NOTE THAT THE TWO
*   HIGH BITS HAVE BEEN COMPLEMENTED IN HARDWARE - AN OLD KLUDGE FOR
*   THE 360/30 OF FORGOTTEN MEMORY.
*   170B  COMMUNICATIONS ERROR
*   161B  DEVICE ERROR
*   162B     NOT USED BY THE HP.  WHO KNOWS WHAT IT WAS?
*   173B  DEVICE NOT READY.
*   164B  WRITE OK, UNIT EXCEPTION
*   175B  PRINT FINISHED
*   176B  READ OK
*   167B  WRITE OK
*   KDF SEEMS TO HANDLE THOSE CODES OK, THE MYSTERY IS IN THE
*   NUMBERS FOR COMMUNICATIONS ERRORS ETC.
*   I BELEIVE THOSE ARE WHAT THE HP CALLES ITS RESPONSE FLAGS, WHICH ARE:
*   1  RRFLAG  (DON'T KNOW WHAT THAT MEANS YET, LOOK AT THE HP CODE)
*   2  NOT ENOUGH (DATA I PRESUME, BUT FOR THE DIRTY OLD MEN...)
*   4  BAD COMPARE
*  10  UNIT ERROR FLAG
*  20  INCORRECT LENGTH
*  40  UNIT EXCEPTION

*   WHEN GET'RESPONSE (GRSPO) RETURNS THESE IT WOULD BE A GREAT BOON
*   TO HAVE AN ARRAY OF STRINGS AND SOME CODE TO OUTPUT THEM IN A USEFUL
*   AND THEREFORE NONCRYPTIC WAY.  KITAI SHITE ORIMASU YO.  DOOMO SUMAN.
         DECLARE ARRAY R1LEN[8]←(1,2,2,2,0,0,3,0);
        DECLARE ARRAY R2LEN[8]←(0,0,0,0,0,0,1,0);
        DECLARE ARRAY P1LEN[20]←(1,1,1,1,1,3,3,3,3,3,
         0,0,0,0,0,0,0,0,1,1);
        DECLARE ARRAY P2LEN[20]←(3,3,3,1,1,0,0,0,0,0,
         0,0,0,0,0,0,0,0,3,1);
        DECLARE ARRAY P3LEN[20]←(0,0,0,1,0,0,0,0,0,0,
         0,0,0,0,0,0,0,0,1,0);

*   THE FOLLOWING COMMAND NAMES GIVE INDEXED ENTRY TO THE COMTAB0
*   ABOVE.  THIS GIVES AN EXTRA ARBITRARY LEVEL OF MAPPING BETWEEN THE TSS
*   AND THE HP RESIDENT.  BY THE PROTOCALL, ALL COMMANDS HAVE THE EOR OF
*   THEIR HIGH TWO BITS TRUE - THUS ALL COMMANDS ARE IN THE RANGE 
*   100B - 277B.  THE HP ONLY HAS CODE FOR THE FOLLOWING:
*   210B  READ
*   202B  WRITE
*   213B  CNTRL
*   204B  SET'MOD
*   205B  HYTYPE IN ASCII
*   216B  HYTYPE IN PLOT MODE
*   207B  IOMEC LINE PRINTER
*   264B  SKIP
*   102B  HEADER'SEARCH
         DECLARE READ←0, READB←1, WRITE←2,
         CNTRL←3, SET'MOD←4, /*  READ'BCARD←5 */ HYTP'ASCII←5,
         /* READ'ECARD←6 */ HYTP'PLOT←6, PRINTL←7, MOUNT'C←8,
         SENSE←9, RETRY←10, NO'RETRY←11, SKIP←12,
         REPEAT←13, RESTART←14, TAPE'RESTART←15,
         DATA'OK←16, DATA'BAD←17, HEADER'SEARCH←18,
         SET'SPEED←19,CHIO'NULL←23,PFIN←29;

         DECLARE CSL←300,DB←300B,M30R←38,M30W←39,FCPAR←10;

         DECLARE LONG MIN5←(1,62341600B),MIN3'5←(1,27571700B),
         MIN1←(0,26706600B),ALARM'CLOCK,
         SEC10←(0,3641100B),LZ,LNCON ← (1,0);
        DECLARE ARRAY FLGAR[1];

         DECLARE CHIOBIT, BBITS, FLAG,TIMER'NO,M30Q'FN,
         DPMTX,M30PMTX,Z,ERMSNO;
        DECLARE CHARACTER E,ERCODE;

         DECLARE FIELD BBT(0:0,0),ASLP(0:1,1),LTOP(0:2,2),PIP(0:3,3),
         PRQ(0:4,4),TRQ(0:6,6),
         CRQ(0:5,5),T7R(0:7,7),
         T9R(0:8,8),OIP(0:9,9),
         TBTS(0:7,8),DISP'FLD(0:3,6),IDLE'F(0:10,10);

         DECLARE FIELD BIT0(0:0,0),CIU(0:11,11),PIU(0:12,12),
         T7IU(0:13,13),T9IU(0:14,14),CRP(0:15,15),PRP(0:16,16),
         T7RP(0:17,17),T9RP(0:18,18);
        DECLARE FIELD ARRAY [4] REQB←(CRQ,PRQ,T7R,T9R),
         DEVF←(CIU,PIU,T7IU,T9IU),
         REQ'PEND←(CRP,PRP,T7RP,T9RP);

         DECLARE ARRAY M30Q'NAME[8]←(0,1,2,3,4,5,6,7);

         DECLARE ARRAY [4] ENN,TOPB;
        DECLARE ARRAY [10:8] DB1,DB2,DB3,DB4;
        DECLARE ARRAY ARRAY DBUF[4]←(DB1,DB2,DB3,DB4);

         DECLARE FIELD FII(0:0,0),FOP(0:1,5),FN(0:6,23),
         FER(1:0,0),FERC(1:1,5),FERDATA(1:6,23),
         FSA(2),FWC(3),FDT1(4),FDT2(5),FDT3(6),FDT4(7);

         MACRO EN←(DBUF[DEVNO])[ENO];
        MACRO II←EN$FII;
        MACRO OP←EN$FOP;
        MACRO N←EN$FN;
        MACRO ER←EN$FER;
        MACRO ERC←EN$FERC
         MACRO ERDATA←EN$FERDATA
         MACRO SA←EN$FSA;
        MACRO WC←EN$FWC;
        MACRO DT1←EN$FDT1;
        MACRO DT2←EN$FDT2;
        MACRO DT3←EN$FDT3;
        MACRO DT4←EN$FDT4;

         DECLARE FIELD BP(0),RP(1),WP(2),EP(3);
        MACRO EMPTY(S) ← LNGDES(S$RP, S$WP) <=0;
        MACRO ERR(A,B)← FRETURN (A,B);
        MACRO LF'PUNT←RUNTIME'FAILURE();
        MACRO SF'PUNT←LF'PUNT:ERCODE,ERMSNO;
        MACRO SET(FLB)←FLAG$(FLB)←-1;
        MACRO CLEAR(FLB)←FLAG$(FLB)←0;
        MACRO IFF(FLB)← IF (FLAG$(FLB));

* MCALLS
         MACRO UMC←UNKNOWN MONITOR;
        MACRO IMC←INTEGER MONITOR;
        MACRO LMC←LONG MONITOR;

         UMC RSTB←182; UMC WST ← 183; *READ'STRING'BRK,WRITE'STRING
        LMC RRTC←210;
        IMC CVINT←165; IMC ACQICT←174; UMC RDICT←166; UMC SETICT←172;
        UMC BLOCK←170; UMC RESNI←168; UMC SETPIW←123;
        IMC READ'SPT'FIELD←97; UMC SET'SPT'FIELD←98; UMC SP'RETURN←116;
        UMC SET'MAP'BYTE←102;
        IMC ACQPMT←50; UMC CLRPMT←53;
        IMC OPEN←19; UMC GET'FILE'PAGE←27;
        IMC DO'POT'PIN←129;



         END;

        PROGRAM TAPE'OPS;
        INCLUDE GLOBAL,M30PAR;
        MACRO PP(X)←COM'ERR(X// RETURN);
        DECLARE XTIME, LONG LTIME;
        DECLARE RC,RP1,RP2,CENT,BYTEC,NULL;
        DECLARE FIELD FF(0:18,18), TIMEF(1:0,17), FF1(0:19,19);



         FUNCTION READ'RECORD(BYTEC,ARRAY BUF), FRETURN;
        SEND'COM(READ,UNIT,BYTEC,0);
CAL0:   RDT(BUF:RC,RP1,RP2,CENT//PUNT():C,D);
        FRETURN 1 IF RP2$FF=1;* TAPE MARK
        GOTO CAL0 IF RC=27 ELSE GOTO ERR0 IF RC=25 ELSE PP(RC) IF RC#30;
        RETURN CENT;



         ENTRY WRITE'RECORD(BYTEC,ARRAY BUF), FRETURN;
        SEND'COM(WRITE,UNIT,BYTEC,0);
        WDT(BUF,BYTEC:NULL,NULL); GOTO CAL1;



         ENTRY REWIND(), FRETURN;
        SEND'COM(CNTRL,UNIT,1,0); GOTO CAL1;



         ENTRY UNLOAD(), FRETURN;
        SEND'COM(CNTRL,UNIT,1,1); GOTO CAL1;



         ENTRY SET'MODE(MODE), FRETURN;
        RETURN IF NOT PRINT'FLAG AND UNIT#0;
        SEND'COM(SET'MOD,0,MODE,0); GOTO CAL1;



         ENTRY SKIP'FILE(), FRETURN;
        SEND'COM(CNTRL,UNIT,1,7); GOTO CAL1;



         ENTRY BACKWARD'SPACE(), FRETURN;
        SEND'COM(CNTRL,UNIT,1,5); GOTO CAL1;



         ENTRY WRITE'TAPE'MARK(), FRETURN;
        SEND'COM(CNTRL,UNIT,1,3); GOTO CAL1;



         ENTRY BACK'REC(), FRETURN;
        SEND'COM(CNTRL,UNIT,1,4); GOTO CAL1;



         ENTRY ERASE'G(), FRETURN;
        SEND'COM(CNTRL,UNIT,1,2); GOTO CAL1;



         ENTRY FORWARD'REC(), FRETURN;
        SEND'COM(CNTRL,UNIT,1,6); GOTO CAL1;

         ENTRY PRINT'LINES(ARRAY BUF,INTEGER BYTEC, HYTYP'FLG), FRETURN;
        POK();
        SEND'COM(HYTP'ASCII IF HYTYP'FLG ELSE PRINTL,BYTEC,0,0);
        WDT(BUF,BYTEC:NULL,NULL);
        GOTO CAL1;
        ENTRY PLOT'RECORD(ARRAY BUF, INTEGER BYTEC), FRETURN;
        POK();
        SEND'COM(HYTP'PLOT,BYTEC,0,0);
        WDT(BUF,BYTEC:NULL,NULL);


CAL1:    GRSPO(:RC,RP1,RP2,CENT//PUNT():C,D);
        GOTO CAL1 IF RC=27 ELSE FRETURN 1 IF RC=28 ELSE
         GOTO ERR1 IF RC=25 ELSE PP(RC) IF RC#31;
        RETURN;
*   NOTE PP IS SHORT FOR COM'ERR(ETC.)

ERR0:    SEND'COM(SKIP,0,0,0);
        GRSPO(:RC,RP1,RP2,CENT//PUNT():C,D);
        PP(RC) IF RC#30; FRETURN 2;

ERR1:    SEND'COM(SKIP,0,0,0);
        GRSPO(:RC,RP1,RP2,CENT//PUNT():C,D);
        PP(RC) IF RC#31; FRETURN 2;



         ENTRY COM'ERR(X), FRETURN;
        CLEANUP();
        CRLF(1); SOUT("COMMUNICATIONS ERROR: ");
        IOUT(X,10); FRETURN;
*   INSTEAD OF THAT IDIOT IOUT, THE ERROR CODE OUT TO BE PARSED INTO 
*   PLAIN ENGLISH.



         END;

        COMMON TIME'DECS;

         DECLARE DATE'INDEX, DUMP'INDEX, HELP'INDEX, KDF'HDR'INDEX;
        DECLARE TIME'OK,TIMER,FLOP,BUGS,BUGGER,DRUMMER,WAITER;
        DECLARE QUEUE'FLAG,QU'FB,QU'FILE,QUEUE←11;
        DECLARE LONG DELAY←(3,0),XX←(0,2B7),BUG'TIME←(0,2B6);
        DECLARE INT'WORD;
        DECLARE LONG DRUM'TIME←(0,1B7),PREEM'TIME←(3,0),TIME;
        DECLARE LONG WAIT'TIME←(1,0);
        LONG MONITOR RRTC ← 210;
        MONITOR SETICT ← 172;
        DECLARE PREEM,PRE'EMPT,QU'X;
        DECLARE ARRAY SPC[3];
        DECLARE FIELD SPNO(0:2,5);
        DECLARE ARRAY QU'FILE'NAME[8]←(-1,0,0,6'KDF-',6'QUEU',
         6'E   ',0,6'QUEU');



         END;

        COMMON CHIO'CELL'DEC;
        UTILITY PRINT'CHAR ← 46;
        UTILITY READ'CHAR ← 50;
        UTILITY DUMP'BUFFER ← 47;



         END;

        PROGRAM LONG'ARIT;
* LONG ARITHMETIC PACKAGE
         DECLARE P,Q,I;
        DECLARE LONG X,Y;
        DECLARE FIELD W0(0),W1(1);



         LONG FUNCTION FAD(X,Y);
        .LDA X$W1; .ADD Y$W1; .CAB;
        .LDA X$W0; .ADC Y$W0; RETURN;



         LONG FUNCTION FSB(X,Y);
        .LDA X$W1; .SUB Y$W1; .CAB;
        .LDA X$W0; .SUC Y$W0; RETURN;



         FUNCTION FGT(X,Y);
        RETURN (1 IF FSB(Y,X)$W0<0 ELSE 0);


        FUNCTION FLT(X,Y);
        RETURN (1 IF FSB(X,Y)$W0<0 ELSE 0);

        FUNCTION FEQ(X,Y);
        X←FSB(X,Y);
        RETURN (1 IF (X$W0=0 AND X$W1=0) ELSE 0);

        FUNCTION LONG'COMPARE(X, Y);
        IF X$W0 = Y$W0 AND X$W1 = Y$W1 DO;
           RETURN -1;
        ELSE DO;
           RETURN 0;
        ENDIF;
 

        END;

        PROGRAM MISCM30; INCLUDE M30PAR;

         DECLARE INTEGER C,P1,P2,P3;



         ENTRY SEND'COM(C,P1,P2,P3);
        S'C(COMTAB0[C],P1,-P1LEN[C]+4,P2,-P2LEN[C]+4,P3,-P3LEN[C]+4:Z,Z
         //SF'PUNT);

         RETURN;



         END;

        PROGRAM POK;
        INCLUDE M30PAR;
        DECLARE C;



         FUNCTION POK();
LP:     (SET(PIP) & RETURN) IFF (PIP)=0;
LP1:    GRSPO(:Z,E,E,E//PUNT():E,Z);
        GOTO LP IF Z=PFIN ELSE GOTO LP1 IF Z=27 ELSE
         SEND'COM(SKIP,0,0,0) & GOTO LP1 IF Z=25 ELSE
         CLEAR(PIP) & COM'ERR(Z//LP);



         END;

        PROGRAM CLEANER;
        INCLUDE M30PAR;
        DECLARE STRING EES(10);
        DECLARE FIELD NCRD(0:2,23);
        DECLARE I,T;



         FUNCTION CLEANER(); GOTO LP1;



         ENTRY CLEANUP();
*       READ POSSIBLE GARBAGE QUEUED FOR XMISSION TO HP.
LP0:     SETS(EES,0,0);
        RSTB(M30W,9,0,EES:EES,I//LP0:T,T);
        GOTO LP0 IF I$NCRD#0;
*       NOW SEND OVER A RESTART INTERRUPT
         DO'POT'PIN(4B7+10B,4B,1//PUNT():T,T);
*       NOW SENT 277B "CLEAN UP" - NOTE NOT IN REGULAR COMMAND TABLES.
         S'C(277B,0,4,0,4,0,4:T,T//PUNT():T,T);
*       AND READ AND DISCARD ANY FINAL TRASH FROM HP
LP1:     SETS(EES,0,0);
        RSTB(M30R,9,0,EES:EES,I//LP1:T,T);
        GOTO LP1 IF I$NCRD#0;
        RETURN;




         END;

        PROGRAM M30BAS;
        INCLUDE M30PAR; INCLUDE INTERCOM;

         DECLARE FIELD HCBTS(0:18,19),LCBTS(0:21,23),BCHR(0:0,0),
         CHION(0:2,23);

         DECLARE CMD,RPR1,RPR2,RLEN,T,TT,I;
        DECLARE STRING PSTR(5),COMSTR(CSL+1),DATSTR,P1S,P2S,P3S,RP1S,RP2S;

         DECLARE P1,P2,P3,LEN,NCHRS,TCHR;
        DECLARE FIELD L3(0:21,23);
        DECLARE ARRAY BUF;



         FUNCTION S'C(CMD,P1,P1L,P2,P2L,P3,P3L), FRETURN;
        SETUP(P1S,4,@P1,6);
        SETUP(P2S,4,@P2,6);
        SETUP(P3S,4,@P3,6);
        SETS(P1S,P1L,4); SETS(P2S,P2L,4);
        SETS(P3S,P3L,4); SETS(COMSTR,0,0);
        WCI(CMD,COMSTR//LF'PUNT);
SC1:    WCI(GCI(P1S//SC2) V' DB,COMSTR//LF'PUNT) & GOTO SC1;
SC2:    WCI(GCI(P2S//SC3) V' DB,COMSTR//LF'PUNT) & GOTO SC2;
SC3:    WCI(GCI(P3S//SC4) V' DB,COMSTR//LF'PUNT) & GOTO SC3;
SC4:    WST(M30W,7,COMSTR:COMSTR,NCHRS//SC6:E,Z);
        GOTO SC4 IF NCHRS # 0;
        RETURN (0,0);
SC6:    ERR('SC0',1);



         FUNCTION RDT(BUF), FRETURN;
        SETUP(DATSTR,8192,@BUF[0],6);
        T←301B; CLEAR(BBT);
RDT1:   SETS(COMSTR,0,0);
        RSTB(M30R,CSL,0,COMSTR:COMSTR,NCHRS//PUNT():E,Z);
RDT4:   GOTO RDT7 IF NCHRS$CHION = CSL;
        (T←GCD(COMSTR) & GOTO RDT7) IF NCHRS$BCHR;
RDT3:   ALARM'CLOCK←FAD(RRTC('RTC'),LNCON);
        CHIOBIT←2B5 V' (4B7 RSH INTCEL);
        SETICT (INTCEL,2B7 V' 1B4,0,ALARM'CLOCK//SF'PUNT);
        SET(BBT);
RDT013: BLOCK(CHIOBIT//SF'PUNT);
        LZ←RRTC('RTC');
*         ERR('RD2',4) IF FGT(LZ,ALARM'CLOCK); TEMP FIX DURING DEBUG
         CLEAR(ASLP);
        TCHR ← NCHRS$CHION;
        RSTB(M30R,-(NCHRS$CHION)+CSL,0,COMSTR:COMSTR,NCHRS//PUNT():E,Z);
        NCHRS$CHION ← NCHRS$CHION + TCHR;
        GOTO RDT013 IF NCHRS$CHION = 0;
        GOTO RDT4;
RDT7:   WCI(GCI(COMSTR//RDT2),DATSTR//PUNT()) & GOTO RDT7;
RDT6:   PUNT();
RDT2:   GOTO RDT1 IF T>=300B;
        RLEN←(LENGTH(DATSTR)*3)/4;
RDT12:  SETS(PSTR,0,0);
        CMD←((T $ HCBTS LSH 3) V' T $ LCBTS)-24;
        ERR('RD3',5) IF COMTAB1[CMD]#T;
        GOTO RDT8 IF (T←R1LEN[CMD]+R2LEN[CMD])=0;
        RPR1←RPR2←0;
RDT10:  RSTB(M30R,T,0,PSTR:PSTR,NCHRS//PUNT():E,Z);
        GOTO RDT10 IF LENGTH(PSTR)#T;
        CLEAR(ASLP);
        SETUP(RP1S,4,@RPR1,6);
        SETUP(RP2S,4,@RPR2,6);
        SETS(RP1S,4,4);
        SETS(RP2S,4,4); SETS(PSTR,0,T);
        WCD(GCD(PSTR//PUNT()),RP2S//LF'PUNT) FOR I←1 TO R2LEN[CMD];
        WCD(GCD(PSTR//PUNT()),RP1S//LF'PUNT) FOR I←1 TO R1LEN[CMD];
RDT8:   CMD ← CMD + 24;
        CLEAR(PIP) IF CMD=PFIN;
        RETURN (CMD, RPR1,RPR2,RLEN);



         ENTRY GRSPO(), FRETURN;
RDT14:  CLEAR(BBT);
RDT13:  SETS(COMSTR,0,0);
        RSTB(M30R,CSL,0,COMSTR:COMSTR,NCHRS//PUNT():E,Z);
        T←GCD(COMSTR//RDT11);
        GOTO RDT12 IF NCHRS$BCHR ELSE ERR('RD2',4);
RDT11:  ALARM'CLOCK←FAD(RRTC('RTC'),LNCON);
        CHIOBIT←2B5 V' (4B7 RSH INTCEL);
        SETICT(INTCEL,2B7 V' 1B4,0,ALARM'CLOCK//SF'PUNT);
        BLOCK(CHIOBIT//SF'PUNT);
        LZ←RRTC('RTC');
*         ERR('RD1',3) IF FGT(LZ,ALARM'CLOCK); TEMP REMOVAL FOR DEBUG REASONS
         CLEAR(ASLP);
        GOTO RDT13;
RDT0:   ERR('RD1',3);
RDT9:   ERR('RD3',5);

         FUNCTION WDT(ARRAY BUF,LEN);
        LEN←((LEN+2)/3)*4;
        LEN←LEN+4 IF LEN$L3#0;
        SETUP(DATSTR,LEN,@BUF[0],6);
        SETW(DATSTR,LEN);
WDT1:   SETS(COMSTR,0,0);
WDT2:   WCI(GCI(DATSTR//WDT3) V' DB,COMSTR//WDT4) & GOTO WDT2;
WDT4:   WST(M30W,CSL+1,COMSTR:COMSTR,NCHRS//PUNT():E,Z);
        GOTO WDT4 IF NCHRS#0;
        DATSTR$RP←INCDES(DATSTR$RP,-1);
        GOTO WDT1;
WDT3:   WST(M30W,CSL+1,COMSTR:COMSTR,NCHRS//PUNT():E,Z);
        GOTO WDT3 IF NCHRS#0;
        RETURN (0,0);
WDT0:   ERR('WD0',6);



         END;

        COMMON CRUN;

         INCLUDE GLOBAL, PRINT'DEFS;
        DECLARE STRING INP(70);
        DECLARE DENSITY, FINI'FLAG, SL= G' [2], STACK;
        DECLARE LONG LNGE;
        DECLARE NCMD1←48;
        DECLARE ARRAY A1[20],A2[20];
        DECLARE I,J,K,X1,X2,X3;
        DECLARE STRING PAR,KDF;


         DECLARE STRING ARRAY TABLE1[NCMD1]←
         ("HELP", "FINISH", "LOAD", "PRINT", "DUMP",
         "&S&Y&SWRITE-TAPE-MARK", "KDF-HDR", "REWIND",
         "BACKSPACE-FILE", "FORWARD-SPACE-FILE",
         "&S&Y&SKDF-TRAILER", "LIST", "&S&Y&SCOMPLETE-DUMP",
         "COMPLETE-LOAD", "UNIT", "&S&Y&SCREATE-INIT-TAPE",
         "&S&Y&SWRITE-LABEL", "READ-LABEL", "&S&Y&SINIT-FILES",
         "&S&Y&SEND-INIT-FILE", "&S&Y&SEND-INIT-TAPE",
         "&S&Y&SCREATE-KDF-TAPE", "&S&Y&SCREATE-IPL-TAPE",
         "&S&Y&SWRITE-IPL", "READ-IPL", "DIRECTORY-IPL",
         "DATE", "&S&Y&SWRITE-INIT-CORELOAD",
         "&S&Y&SWRITE-BWL-CORELOAD", "CHANGE-PRINT", "UNLOAD",
         "RETRIEVE", "DRUM-SPACE", "PREEMPT", "UNPREEMPT",
         "CLEANUP", "940-LIST", "940-LOAD", "SET-DENSITY",
         "DENSITY", "ARB-LOAD", "TYMESHARE-LOAD", "USER-LOAD",
         "HYTYPE", "PLOT", "NEW-TYMESHARE-LOAD", "NEW-TYMESHARE-LIST",
         "BLOCK-FORMAT-DUMP");

         DECLARE FUNCTION ARRAY CMD1[NCMD1]←
         (HELP, FINI, LOAD'CALL, PRINT'CALL, DUMP'CALL, W'T'M,
         KDF'HDR'CALL, REWIND'CALL, BACK'CALL, FORWARD'CALL,
         KDF'TRAIL'CALL, LIST'CALL, DUMP'ALL'CALL, LOAD'ALL'CALL,
         UNIT'CALL, CINIT, WLAB, RLAB, WMIF, EIF, EIT,
         CREATE'KDF'CALL, CREATE'IPL'CALL, WRITE'IPL'CALL,
         READ'IPL'CALL, DIR'IPL'CALL, DATE, WICL, WBCL,
         CHANGE'PRINT, UNLOAD'C, RET'CALL, DRUM'CALL, PREEMPT,
         UNPREEMPT, CLEANUP, LIST'9, LOAD'9, SET'DENS, DENS,
         ARB'LOAD'C, TYME'LOAD'C, USER'LOAD'C, HYTYPE'CALL,
         PLOT'CALL, NEW'TYME'LOAD'C, NEW'TYME'LIST'C,
         BLOCK'F'DUMP'C);



         END;

        PROGRAM RUN;
        INCLUDE CRUN,TIME'DECS;
        MACRO GP←GET'PARAM(INP:PAR);
        DECLARE CHR,XCHR,LCMD,X4;



         FUNCTION XRUN(); SL←STACK;
RUB:    GOTO RUB WHILE TCI()#'&K'; GOTO INLINE;



         ENTRY QRUN(); SL←STACK; FINI'FLAG←0; GOTO INLINE;



         ENTRY RUN(); FINI'FLAG←0; STACK←SL; DUMP'OK←0;
        INITX(); DENSITY←1;
INLINE: IF QUEUE'FLAG AND NOT PRE'EMPT DO;
            CRLF(1);
            SOUT("WAIT--");
            QU'X←-1;
            PROCESS'QUEUE(//CAL3);
            CRLF(1);
            SOUT("PROCEED.");
CAL3:       QU'X←0;
        ENDIF;
        CRLF(1); TCO('$'); GET'LINE('$',INP:INP);
        PRINT'FLAG←0;
CAL2:   GOTO INLINE IF LENGTH(INP)=0; TRIM(INP:INP);
        LCMD←ABRV'LKP(INP,TABLE1//CAL1:C,D);
        (CMD1[LCMD])();
        DUMP'OK←(-1 IF LCMD=HELP'INDEX OR LCMD=DATE'INDEX OR
         LCMD=DUMP'INDEX OR LCMD=KDF'HDR'INDEX ELSE 0);
        SP'RETURN(//PUNT():C,D) IF FINI'FLAG;
        GOTO CAL2 IF GCI(INP//INLINE)='$' ELSE GOTO INLINE;
CAL1:   IF C='NNF' DO; SOUT("COMMAND NOT FOUND");
        ELSEIF C='NAM' DO; SOUT("COMMAND IS AMBIGUOUS");
        ENDIF; GOTO INLINE;



         ENTRY FINI(); FINI'FLAG←-1; RETURN;



         ENTRY HELP();
        (SOUT(TABLE1[I]) & CRLF(1)) FOR I←0 TO NCMD1-1;
        RETURN;

         ENTRY UNLOAD'C(); UNLOAD(//E4:C); RETURN;



         ENTRY REWIND'CALL();
        REWIND(//E4:C); RETURN;



         ENTRY PREEMPT(); PRE'EMPT←-1;
        TIME←FAD(PREEM'TIME,RRTC(0));
        SETICT(PREEM,21B6,SPC[0]$SPNO,TIME//PUNT():C,D);
        RETURN;



         ENTRY UNPREEMPT();
        QUEUE'FLAG←-1;
        PRE'EMPT←0;
        RETURN;



         ENTRY LOAD'9(); X3←-1; GOTO LH;
        ENTRY LOAD'CALL(); X3←0;
LH:     SOUT("940 USER NUMBER: "); X1←IIN(10); CRLF(1);
L0:     SOUT("940 KDF NAME: "); SETUP(KDF,5,@LNGE,6); LNGE←LONG'ZERO;
L1:     GOTO L3 IF (CHR←TCI())='.' OR CHR=',';
        IF CHR='&A' DO; GCD(KDF//L1); WCI(0,KDF); GCD(KDF);
L2:         TCO('↑'); GOTO L1;
        ENDIF; WCI(CHR,KDF//L2); GOTO L1;
L3:     CRLF(1); SOUT("FULL FILE NAME: "); GNAME(A1); CRLF(1);
        LOAD'940(X1,LNGE,A1//L4:C) IF X3 ELSE LOAD(X1,LNGE,A1//L4:C);
        (CRLF(1) & GOTO L0) IF CHR=','; RETURN;
L4:     IF C=1 DO; SOUT("TAPE ERROR -- ABORT");
        ELSEIF C=2 DO; SOUT("USER NOT ON TAPE");
        ELSEIF C=3 DO; SOUT("NO SUCH FILE");
        ELSE DO; SOUT("ERROR: "); IOUT(C,10);
        ENDIF; RETURN;



         ENTRY RET'CALL();
        SOUT("940 KDF NAME: "); SETUP(KDF,5,@LNGE,6);
        LNGE←LONG'ZERO;
RET1:   GOTO RET3 IF (CHR←TCI())='.';
        IF CHR='&A' DO; GCD(KDF//RET1); WCI(0,KDF); GCD(KDF);
RET2:       TCO('↑'); GOTO RET1;
        ENDIF; WCI(CHR,KDF//RET2); GOTO RET1;
RET3:   CRLF(1); SOUT("FULL FILE NAME: "); GNAME(A1); CRLF(1);
        RETRIEVE(LNGE,A1//L4:C);
        RETURN;

         ENTRY ARB'LOAD'C();
        SOUT("STARTING RECORD: "); X1←IIN(10); CRLF(1);
        SOUT("NUMBER OF RECORDS: "); X2←IIN(10); CRLF(1);
        SOUT("FULL FILE NAME: "); GNAME(A1); CRLF(1);
        ARB'LOAD(X1,X2,A1//L4:C);
        RETURN;



         ENTRY USER'LOAD'C();
        SOUT("FILE NUMBER: "); X1←IIN(10); CRLF(1);
        SOUT("FULL FILE NAME: "); GNAME(A1); CRLF(1);
        USER'LOAD(X1,A1//L4:C);
        RETURN;


         ENTRY NEW'TYME'LOAD'C(); X3←1; GOTO TY0;

         ENTRY TYME'LOAD'C(); X3←0;
TY0:    SOUT("FILE NUMBER: "); X1←IIN(10); CRLF(1);
TYA:    SOUT("FULL FILE NAME: "); GNAME(A1); CRLF(1);
TY:     SOUT("SMALL OR LARGE FILE? "); X2←TCI();
        IF X2='S' DO; SOUT("MALL"); CRLF(1); X2←0;
        ELSEIF X2='L' DO; SOUT("ARGE"); CRLF(1); X2←1;
        ELSE DO; SOUT(" ? "); CRLF(1); GOTO TY;
        ENDIF;
        IF X3 DO;
            NEW'TYME'LOAD(X1,X2,A1:X4//L4:C);
        ELSE DO;
            TYME'LOAD(X1,X2,A1//L4:C); X4←0;
        ENDIF;
        IF X4 DO;
            X1←-1; GOTO TYA;
        ENDIF;
        RETURN;



         ENTRY NEW'TYME'LIST'C();
        SOUT("FIRST FILE: "); X1←IIN(10); CRLF(1);
        SOUT("LAST FILE: "); X2←IIN(10); CRLF(1);
        NEW'TYME'LIST(X1,X2//L4:C);
        RETURN;



         ENTRY CHANGE'PRINT();
        GET'NAME(A1,"OLD FILE: ");
        GET'NAME(A2,"NEW FILE: ");
CP0:    CRLF(1); SOUT("SINGLE OR DOUBLE? "); CHR←TCI();
        IF CHR='S' DO; SOUT("INGLE"); X1←SINGLE'SPACING;
        ELSEIF CHR='D' DO; SOUT("OUBLE"); X1←DOUBLE'SPACING;
        ELSE DO; SOUT(" ?"); GOTO CP0;
        ENDIF; CRLF(1);
        PRINT'CHANGES(A1,A2,X1//P4:C);
        RETURN;

         ENTRY PRINT'CALL();
PR0A:   GET'NAME(A1, "FILE NAME: ");
PR0:    SOUT("SINGLE OR DOUBLE? "); CHR←TCI();
        IF CHR='S' DO; SOUT("INGLE"); X1←SINGLE'SPACING;
        ELSEIF CHR='D' DO; SOUT("OUBLE"); X1←DOUBLE'SPACING;
        ELSEIF CHR='A' DO; SOUT("BSOLUTE"); X1←ABSOLUTE'SPACING;
        ELSE DO; SOUT(" ? "); GOTO PR0;
        ENDIF;
        X2←0;

         IF X1#ABSOLUTE'SPACING DO;
PR1:        CRLF(1);
            SOUT("LINE NUMBERS? ");
            CHR←TCI();
            IF CHR='Y' DO;
                SOUT("ES");
                CRLF(1);
                X2←-1;
            ELSEIF CHR='N' DO;
                SOUT("O");
            ELSE DO;
                SOUT(" ?");
                CRLF(1);
                GOTO PR1;
            ENDIF;
            CRLF(1);
        ENDIF;

         PRINT(A1,X1,X2,0,0,0,1//P4:C); RETURN;
P4:     IF C=1 DO; SOUT("BAD FILE NAME");
        ELSEIF C=2 DO; SOUT("PRINTER ERROR");
        ELSEIF C=3 DO; SOUT("FILE EMPTY");
        ELSE DO; SOUT("ERROR: "); IOUT(C,10);
        ENDIF; RETURN;



         ENTRY HYTYPE'CALL();
         X1 ← PRELIM'QUES();
         CLEANUP();
         PRINT(A1, 0, 0, 1, X1, 0, 0//P4: C);
        RETURN;


         ENTRY PLOT'CALL();
        X1 ← PRELIM'QUES();
        PLOT(A1, X1//P4: C);
        RETURN;

        ENTRY PRELIM'QUES();
        GET'NAME(A1, "FILE NAME: ");
Q1:     SOUT("PAUSE AFTER EACH PAGE?  "); I←TCI();
        IF I='Y' DO;
            SOUT("ES"); CRLF(1); X1←1;
        ELSEIF I='N' DO;
            SOUT("O"); CRLF(1); X1←0;
        ELSE DO;
            SOUT("  ?"); CRLF(1); GOTO Q1;
        ENDIF;
        RETURN X1;


         ENTRY LIST'9(); X3←-1; GOTO LIH;



         ENTRY LIST'CALL(); X3←0;
LIH:    SOUT("FIRST USER: "); X1←IIN(10); CRLF(1);
        SOUT("LAST USER: "); X2←IIN(10); CRLF(1);
        LIST'940(X1,X2//L4:C) IF X3 ELSE LIST(X1,X2,A1//L4:C); RETURN;

         ENTRY DUMP'ALL'CALL();
        DUMP'ALL(//D4:C); RETURN;



         ENTRY LOAD'ALL'CALL();
        LOAD'ALL(//L4:C); RETURN;



         ENTRY UNIT'CALL();
        SOUT("TAPE UNIT: ");
U1:     X1←IIN(10);
        IF X1=0 OR X1=1 DO; UNIT←X1;
            SET'MODE(2+DENSITY*8//PUNT():C) IF X1=0;
        ELSE DO; SOUT(" ? "); GOTO U1;
        ENDIF; RETURN;



         ENTRY DRUM'CALL();
        IOUT(X1←DRUM'SPACE(),10); SOUT(" PAGES = ");
        IOUT(X1*2048,10); SOUT(" WORDS OF DRUM SPACE LEFT");
        RETURN;



         ENTRY SET'DENS(); SOUT("DENSITY: ");
BR:     X1←IIN(10); X2←DENSITY;
        DENSITY←(0 IF X1=200 ELSE 1 IF X1=556 ELSE
         2 IF X1=800 ELSE -1);
        IF DENSITY=-1 DO; DENSITY←X2;
            SOUT(" ? "); GOTO BR;
        ENDIF;
        RETURN;



         ENTRY DENS();
        IOUT(200 IF DENSITY=0 ELSE 556 IF DENSITY=1 ELSE
         800 IF DENSITY=2,10);
        SOUT(" BPI"); RETURN;

         ENTRY DUMP'CALL();
D0:     GET'NAME(A1,"FILE NAME: ");
        SOUT("940 KDF NAME: "); SETUP(KDF,5,@LNGE,6); LNGE←LONG'ZERO;
D1:     GOTO D3 IF (CHR←TCI())='.' OR CHR=',';
        IF CHR='&A' DO; GCD(KDF//D1); WCI(0,KDF); GCD(KDF);
D2:         TCO('↑'); GOTO D1;
        ENDIF; WCI(CHR,KDF//D2); GOTO D1;
D3:     XCHR←CHR; SOUT(" TYPE: "); I←TCI(); J←TCI(); CHR←TCI();
        IF CHR#'.' OR (I#'R' AND I#'S') OR J-'0'<0 OR J-'7'>0 DO;
            SOUT(" ? (E.G. S3)"); CRLF(1); GOTO D3;
        ELSE DO; J←J-'0'; I←(10B IF I='R' ELSE 0);
            X2←I V' J;
        ENDIF; CRLF(1);
        DUMP(X1,A1,LNGE,X2//D4:C);
        (CRLF(1) & GOTO D0) IF XCHR=','; RETURN;
D4:     IF C=1 DO; SOUT("END OF TAPE");
        ELSEIF C=2 DO; SOUT("TAPE ERROR");
        ELSEIF C=3 DO; SOUT("BAD M1 FILE NAME");
        ELSEIF C=4 DO; SOUT("NO DATA IN FILE");
        ELSE DO; SOUT("ERROR: "); IOUT(C,10);
        ENDIF; RETURN;
E4:     IF C=1 DO; SOUT("LOAD POINT");
        ELSEIF C=2 DO; SOUT("TAPE ERROR");
        ELSE DO; SOUT("ERROR: "); IOUT(C,10);
        ENDIF; RETURN;
IP4:    IF C=1 DO; SOUT("BAD M1 FILE NAME");
        ELSEIF C=2 AND J=1 DO; SOUT("FILE ALREADY ON TAPE");
        ELSEIF C=2 AND J=2 DO; SOUT("NO SUCH FILE");
        ELSEIF C=3 DO; SOUT("TAPE ERROR");
        ELSE DO; SOUT("ERROR: "); IOUT(C,10);
        ENDIF; RETURN;



         ENTRY KDF'HDR'CALL();
        SOUT("940 USER NUMBER: "); X1←IIN(10); CRLF(1);
        KDF'HDR(X1//D4:C); RETURN;



         ENTRY CREATE'KDF'CALL();
        CREATE'KDF(//D4:C); RETURN;



         ENTRY CREATE'IPL'CALL();
        CREATE'IPL(//IP4:C);
        RETURN;

         ENTRY WRITE'IPL'CALL();
        J←1; GET'NAME(A1,"FILE NAME: ");
        SOUT("IPL FILE NAME: "); X1←0; SETUP(KDF,4,@X1,6);
IPL0:   I←TCI();
        IF I='&A' DO; GCD(KDF//IPL0); WCI(0,KDF); GCD(KDF);
IPL1:       TCO('↑'); GOTO IPL0;
        ELSEIF I='.' OR I=' ' OR I='&M' DO; GOTO IPL2;
        ELSE DO; WCI(I,KDF//IPL1); GOTO IPL0;
        ENDIF;
IPL2:   CRLF(1); SOUT("TRANSFER ADDRESS: "); X2←IIN(8); CRLF(1);
        SOUT("LOAD ADDRESS: "); X3←IIN(8); CRLF(1);
        SOUT("WORD COUNT [OCTAL]: "); K←IIN(8); CRLF(1);
        K←FILE'LENGTH(A1// VALUE C←1 & GOTO IP4)+1 IF K<0;
        WRITE'IPL(A1,X1,X2,X3,K//IP4:C);
        RETURN;


        END;

        PROGRAM RUN'MORE;
        INCLUDE CRUN,TIME'DECS;
        MACRO GP←GET'PARAM(INP:PAR);
        DECLARE CHR,XCHR,LCMD,X4;


         ENTRY READ'IPL'CALL();
        J←2; SOUT("IPL FILE NAME: "); X1←0; SETUP(KDF,4,@X1,6);
IPL3:   I←TCI();
        IF I='&A' DO; GCD(KDF//IPL3); WCI(0,KDF); GCD(KDF);
IPL4:       TCO('↑'); GOTO IPL3;
        ELSEIF I='.' OR I=' ' OR I='&M' DO; GOTO IPL5;
        ELSE DO; WCI(I,KDF//IPL4); GOTO IPL3;
        ENDIF;
IPL5:   CRLF(1); SOUT("FULL FILE NAME: "); GNAME(A1); CRLF(1);
        READ'IPL(X1,A1//IP4:C);
        RETURN;

IP4:     IF C=1 DO; SOUT("BAD M1 FILE NAME");
        ELSEIF C=2 AND J=1 DO; SOUT("FILE ALREADY ON TAPE");
        ELSEIF C=2 AND J=2 DO; SOUT("NO SUCH FILE");
        ELSEIF C=3 DO; SOUT("TAPE ERROR");
        ELSE DO; SOUT("ERROR: "); IOUT(C,10);
        ENDIF; RETURN;



         ENTRY DIR'IPL'CALL();
        DIR'IPL(//IP4:C);
        RETURN;



         ENTRY W'T'M();
        WRITE'TAPE'MARK(//D4:C); RETURN;

         ENTRY BACK'CALL(); GP; GP; X3←IIN'S(PAR,10); X3←1 IF X3<1;
        BACKWARD'SPACE(//E4:C) FOR I←1 TO X3;
        RETURN;
D4:     IF C=1 DO; SOUT("END OF TAPE");
        ELSEIF C=2 DO; SOUT("TAPE ERROR");
        ELSEIF C=3 DO; SOUT("BAD M1 FILE NAME");
        ELSEIF C=4 DO; SOUT("NO DATA IN FILE");
        ELSE DO; SOUT("ERROR: "); IOUT(C,10);
        ENDIF; RETURN;
E4:     IF C=1 DO; SOUT("LOAD POINT");
        ELSEIF C=2 DO; SOUT("TAPE ERROR");
        ELSE DO; SOUT("ERROR: "); IOUT(C,10);
        ENDIF;
        RETURN;



         ENTRY FORWARD'CALL(); GP; GP; X3←IIN'S(PAR,10); X3←1 IF X3<1;
        SKIP'FILE(//D4:C) FOR I←1 TO X3;
        RETURN;



         ENTRY KDF'TRAIL'CALL();
        KDF'TRAILER(//D4:C); RETURN;



         ENTRY BLOCK'F'DUMP'C();
        GET'NAME(A1,"FILE NAME: ");
BD0:    SOUT("BLOCK LENGTH (BYTES): "); X1←IIN(10); CRLF(1);
        IF X1>6144 DO;
            SOUT("CANNOT BE > 6144 BYTES"); CRLF(1);
            GOTO BD0;
        ENDIF;
BD1:    SOUT("TAPE MARK AT EOF?  "); X2←TCI();
        IF X2='Y' DO;
            SOUT("ES"); CRLF(1); X3←1;
        ELSEIF X2='N' DO;
            SOUT("O"); CRLF(1); X3←0;
        ELSE DO;
            SOUT("  ?"); CRLF(1); GOTO BD1;
        ENDIF;
        BLOCK'F'DUMP(A1,X1,X3//D4:C);
        RETURN;


         END;

        PROGRAM INITX;
        INCLUDE INTERCOM, DATE'DECS, TIME'DECS, CRUN;
        DECLARE ARRAY NAME[8];
        DECLARE XX1,XX2;



     FUNCTION INITX();

        QUIT'FLAG←UNIT←0;
        BCOPY(@NAME[0],@QU'FILE'NAME[0],8);
        SOUT("VERSION 8/15/78 12H");

        DATE'INDEX←ABRV'LKP("DATE",TABLE1//PUNT():C,D);
        DUMP'INDEX←ABRV'LKP("DUMP",TABLE1//PUNT():C,D);
        HELP'INDEX←ABRV'LKP("HELP",TABLE1//PUNT():C,D);
        KDF'HDR'INDEX←ABRV'LKP("KDF-HDR",TABLE1//PUNT():C,D);
        READ'SPT'FIELD(SPTX,'SCB':XX1//PUNT():C,D);
        READ'SPT'FIELD(SPTX,'SB':XX2//PUNT():C,D);
        SET'SPT'FIELD(SPTX,'SB',(XX2 V' 1B6) A' XX1//PUNT():C,D);
        READ'SPT'FIELD(SPTX,'TCM':XX1//PUNT():C,D);
        SET'SPT'FIELD(SPTX,'TM',4B5+1//PUNT():C,D);
        SET'CIOS'FIELD(-1,'EST',1//PUNT():C,D);
        SET'CIOS'FIELD(-1,'BWS','ALL'//PUNT():C,D);
        SET'LINE'TABLE(M30'LINE,'BWS',2B4+2//PUNT():C,D);
        OA←READ'SPT'FIELD(SPTX,'UAK'//PUNT():C,D);
        THIS'SUB'PROCESS←READ'SPS'PARAM('CSP'//RUNTIME'FAILURE());
        ACQICT(QUEUE//PUNT():C,D);
        INTCEL←ACQICT(-1//PUNT():C,D);
        WAKEUP'TIMER←ACQICT(-1//PUNT():C,D);
*      TIMER←ACQICT(-1//PUNT():C,D);
         BUGGER←ACQICT(-1//PUNT():C,D); BUGS←0;
*      DRUMMER←ACQICT(-1//PUNT():C,D);
         PREEM←ACQICT(-1//PUNT():C,D);
*      TIME←FAD(DELAY,RRTC(0));
         READ'SPCS(-1,SPC//PUNT():C,D);
*      SETICT(TIMER,21B6,SPC[0]$SPNO,TIME//PUNT():C,D);
*       TIME←FAD(DRUM'TIME,RRTC(0));
*       SETICT(DRUMMER,21B6,SPC[0]$SPNO,TIME//PUNT():C,D);
         SETICT(QUEUE,11B6,SPC[0]$SPNO,LONG'ZERO//PUNT():C,D);
        TIME'OK←FLOP←QUEUE'FLAG←PRE'EMPT←QU'X←0;
        INIT'ALLOC();
        INITQM();
        OPENF(-1,NAME,0,OA:QU'FILE//CAL1:C,D); GOTO CAL2;

CAL1:    CRNE(NAME,0,OA//PUNT():C,D);
        SETAC(NAME,357B,OA//PUNT():C,D);
        OPENF(-1,NAME,0,OA:QU'FILE//PUNT():C,D);
        CRPG(QU'FILE,0//PUNT():C,D);
        QU'FB←GET'PAGE(QU'FILE,0//PUNT());
        $QU'FB←0; $(QU'FB+1)←$(QU'FB+2)←3;
        RETURN;
CAL2:   QU'FB←GET'PAGE(QU'FILE,0//PUNT());
        RETURN;



         END;

        COMMON FIDDLE'LOGIC;
*SAVE STATE AND LOAD REGISTERS
         INCLUDE GLOBAL;

         MACRO SAVE'STATE(MA) ← .STX MA[6], .EAX MA[0], .STORS;
        MACRO LOAD'REGISTERS(MA) ←
         .EAX R' [4], .STX MA[0], .EAX MA[0], .LOADS;
        DECLARE OCTAL ARRAY TRSTATE[10];
        DECLARE OCTAL ARRAY SPCS[5];
        DECLARE ARRAY STACK[5000B];
        DECLARE INITIAL'SP←@STACK[0], INITIAL'SL←@STACK[4777B];
        DECLARE WAIT'OK;



         END;

        PROGRAM SP'ENTRIES;
*SP'ENTRIES, TRAP AND INTERRUPT LOGIC
         INCLUDE FIDDLE'LOGIC;
        DECLARE SP= G' [2], SL= G' [3];
        DECLARE RET= L' [0], LL= L' [1];



         ENTRY TRAP(), SP'ENTRY ← 0;
        SAVE'STATE(TRSTATE);
        TRAP'FCN(RET,LL);



         ENTRY INTERRUPT(), SP'ENTRY ← 1;
        SAVE'STATE(TRSTATE);
        INTERRUPT'FCN(RET);



         ENTRY SP'ENTRY'2(), SP'ENTRY ← 2; GOTO ENTER;



         ENTRY SP'ENTRY'3(), SP'ENTRY ← 3; QRUN();
ENTER:  SP←INITIAL'SP; SL←INITIAL'SL;
        RUN();



         END;

        PROGRAM TRAP'FCN;
        INCLUDE FIDDLE'LOGIC,TIME'DECS;
        DECLARE XX1;
        DECLARE MEC, MEM, PC, SPCSE;
        DECLARE FIELD CSPC(0:6,23), CSLR(1:6,23), CSGR(2:6,23);

         FUNCTION TRAP'FCN(TRAPNO, TRAPPAR);
        READ'SPT'FIELD(SPTX,'TCM':XX1//PUNT():C,D);
        SET'SPT'FIELD(SPTX,'TM',4B5+1//PUNT():C,D);
        IF QUIT'FLAG DO;
            LOAD'REGISTERS(TRSTATE); SP'RETURN(//PUNT():C,D);
        ENDIF;
        QUIT'FLAG←-1;
        IF TRAPNO=23 DO;
            IF QU'X AND NOT PRE'EMPT DO; PRE'EMPT←-1;
                TIME←FAD(PREEM'TIME,RRTC(0));
                SETICT(PREEM,21B6,SPC[0]$SPNO,TIME//PUNT():C,D);
                GOTO TRPX;
            ENDIF; QU'X←0;
            IF BUGS=0 DO; BUGS←1;
                TIME←FAD(BUG'TIME,RRTC(0));
                SETICT(BUGGER,21B6,SPC[0]$SPNO,TIME//PUNT():C,D);
            ELSE DO; BUGS←BUGS+1;
                IF BUGS>=3 DO; CRLF(1); BUGS←1;
                    SOUT("TRYING TO KILL ME?");
            ENDIF; ENDIF;
            MODIFY'CALL(0,XX1←@TRP82,0,0,0//PUNT():C,D);
            SP'RETURN(//PUNT():C,D);
        ENDIF;
        IF TRAPNO=6 DO;
            IF TRAPPAR A' 7B6=3B6 OR TRAPPAR A' 7B6=6B6 DO;
                CRLF(1); SOUT("BLL-"); IOUT((TRAPPAR A' 7B6) RSH 18,10);
                SOUT(" AT "); READ'SPCS(0,SPCS//TRP80:MEC,MEM);
                IOUT(SPCS[0]$CSPC,8); TCO('B'); CRLF(1);
                KDF'CORE();
TRPX:           QUIT'FLAG←0; LOAD'REGISTERS(TRSTATE);
                SP'RETURN(//PUNT():C,D);
        ENDIF; ENDIF;
        CRLF(2);
        SOUT("TRAP NUMBER "); IOUT(TRAPNO,8); TCO('B'); SOUT(" AT ");
        READ'SPCS(0,SPCS//TRP80: MEC, MEM);
        SPCSE ← @SPCS[0];
        PC ← SPCSE.CSPC;
        IOUT(PC, 8); TCO('B'); SOUT(" - PARAMETER = ");
        IOUT(TRAPPAR,8); TCO('B'); CRLF(1);
        LOAD'REGISTERS(TRSTATE);
        MODIFY'CALL(0,XX1←@TRP79,0,0,0//PUNT():C,D);
        SP'RETURN(//PUNT():C,D);
TRP79:  QUIT'FLAG←0; BREAK();
TRP80:  PUNT();
TRP81:  PUNT();
TRP82:  QUIT'FLAG←0; XRUN();



         END;

        PROGRAM INTERRUPT'FCN;
        INCLUDE FIDDLE'LOGIC,TIME'DECS;
        DECLARE STRING ST(30);
        DECLARE MEC, MEM;



         FUNCTION INTERRUPT'FCN(INTNO);
        SETS(ST,0,0);
        IF INTNO=TIMER DO;
            IF TIME'OK DO;
                FLOP←FLOP+1;
                IF FLOP>=6 DO; FLOP←0; CRLF(2);
                    SOUT("I AM GETTING LONELY"); CRLF(2); TCO('$'); GOTO IT0;
                ENDIF;
                CRLF(2); APPEND'DATE(ST); SOUT(ST); CRLF(2); TCO('$');
            ENDIF;
IT0:        TIME←FAD(DELAY IF TIME'OK ELSE XX,RRTC(0));
            SETICT(TIMER,21B6,SPC[0]$SPNO,TIME//PUNT():C,D);
            LOAD'REGISTERS(TRSTATE);
            SP'RETURN(//PUNT():C,D);
        ELSEIF INTNO=BUGGER DO; BUGS←0; GOTO IT1;
        ELSEIF INTNO=DRUMMER DO;
            TIME←FAD(DRUM'TIME,RRTC(0));
            SETICT(DRUMMER,21B6,SPC[0]$SPNO,TIME//PUNT():C,D);
            IF $(QU'FB+1)#(C←$(QU'FB+2)) DO;
                QUEUE'FLAG←-1; GOTO ITX IF TIME'OK AND NOT QU'X;
            ENDIF;
            GOTO IT1;
        ELSEIF INTNO=QUEUE DO;
            QUEUE'FLAG←-1;
            IF TIME'OK AND NOT PRE'EMPT DO; TIME'OK←0;
ITX:            MODIFY'CALL(0,MEC←@INT81,0,0,0//PUNT():C,D);
                SP'RETURN(//PUNT():C,D);
            ENDIF; GOTO IT1;
        ELSEIF INTNO=PREEM DO; PRE'EMPT←0;
            GOTO ITX IF TIME'OK ELSE GOTO IT1;
        ENDIF;
        CRLF(2);
        SOUT("INTERRUPT NUMBER "); IOUT(INTNO,8); TCO('B'); CRLF(1);
IT1:    LOAD'REGISTERS(TRSTATE);
        SP'RETURN(//PUNT():C,D);
INT80:  PUNT();
INT81:  QRUN();



         END;

        PROGRAM KDF'CORE;
        INCLUDE FIDDLE'LOGIC;
        DECLARE ARRAY DUMP'FILE[8];
        DECLARE FB,FILE,PAGE;
        DECLARE STRING S;



         FUNCTION KDF'CORE(); BSET(@DUMP'FILE[0],0,8);
        SETUP(S,16,@DUMP'FILE[3],6);
        APPEND(S,"KDF-CORE-DUMP"); DUMP'FILE[0]←-1;
        DUMP'FILE[7]←6'CORE';
        CRNE(DUMP'FILE,0,OA// VALUE GOTO CAL0 IF D=28 ELSE PUNT():C,D);
        SETAC(DUMP'FILE,357B,OA//PUNT():C,D);
CAL0:   OPENF(-1,DUMP'FILE,0,OA:FILE//PUNT():C,D); PAGE←-1;
CAL1:   GNXTPG(FILE,PAGE:PAGE//PUNT():C,D);
        IF PAGE#-1 DO; DELPG(FILE,PAGE//PUNT():C,D); GOTO CAL1;
        ENDIF;
        CRPG(FILE,0//PUNT():C,D); CRPG(FILE,1//PUNT():C,D);
        FB←GET'PAGE(FILE,0//PUNT());
        BCOPY(FB,0,2048); REL'PAGE(FB//PUNT());
        FB←GET'PAGE(FILE,1//PUNT());
        BCOPY(FB,2048,2048); REL'PAGE(FB//PUNT());
        FOR PAGE←2 TO 15 DO;
            CRPG(FILE,PAGE//PUNT():C,D);
            FB←GET'PAGE(FILE,PAGE//PUNT());
            IF PAGE>=7 DO;
                BCOPY(FB,PAGE*2048,2048);
            ELSE DO; BSET(FB,0,2048);
            ENDIF;
            REL'PAGE(FB//PUNT());
        ENDFOR;
        SOFTCL(FILE,0//PUNT():C,D);
        SOUT("STATE:"); CRLF(1);
        (IOUT(TRSTATE[FB],8) & CRLF(1)) FOR FB←0 TO 9;
        RETURN;



         END;

        PROGRAM DRUM'SPACE;
        MONITOR LOOK ← 255;
        DECLARE DRBT←1601B, Z←664B3;
        DECLARE SPACE,X,I,C,D;



         FUNCTION DRUM'SPACE(); SPACE←0;
        FOR I←Z+DRBT TO Z+DRBT+277B DO; X←LOOK(I,0,0//PUNT():C,D);
            .LDA X, .ZOB, .COB, .STX X; SPACE←SPACE+X;
        ENDFOR;
        RETURN SPACE;



         END;

        PROGRAM LOCK;
        INCLUDE TIME'DECS;
        DECLARE FIELD RP(1),WP(2),LK(0);



         FUNCTION LOCK(BUF), FRETURN;
CAL0:   GOTO CAL1 IF BUF.LK#0; BUF.LK←-1;
        INT'WORD←0; GOTO CAL2;
CAL1:   BUF.LK←-1 IF (INT'WORD←BUF.LK)>0;
        GOTO CAL2 IF INT'WORD>0; FRETURN;
CAL2:   BUF.RP←BUF.RP+BUF; BUF.WP←BUF.WP+BUF;
        RETURN;



         ENTRY UNLOCK(BUF);
        BUF.RP←BUF.RP-BUF; BUF.WP←BUF.WP-BUF;
        BUF.LK←INT'WORD;
        RETURN;



         END;

        PROGRAM ACCT'LOCK'UNLOCK;
       INCLUDE DEFS;

*  PROGRAM TO LOCK AND UNLOCK THE ACCOUNT FILE.  THIS CODE FUNCTIONS
*      MORE OR LESS THE WAY THE MONITOR OBJECT LOCKS FUNCTION, EXCEPT
*      THAT THE LOCK IS STORED IN ACTIVE-USERS AND A 3-MINUTE TIMER
*      IS SET INSTEAD OF THE MONITOR'S 30-SECOND TIMER.

       DECLARE LONG PARAMETER WAIT'TIME←(1,1222784), /* 3 MINUTES */
                              LWAIT←(0,5*1000*100),  /* 5 SECONDS */
                              SWAIT←(0,1*1000*100),  /* 1 SECOND  */
                              LONG'ZERO←(0,0);
       DECLARE PARAMETER ACCTING←1, ACCT'LOCK'BASE←2045;
       DECLARE INTEGER LKEY;
       DECLARE LONG LOCK'TIME, NOW, THEN, DUMMY;
       DECLARE FIELD LHALF(1:12,23);
       DECLARE POINTER PTR1;

       FUNCTION ACCT'LOCK(PTR2);
       PTR1←PTR2+ACCT'LOCK'BASE;
       WHILE 1 DO;
LOCK1:    MON'LOCK(ACCTING:LKEY//LOCK1X:DUMMY);
          THEN←FAD((NOW←READ'CLOCK('RTC')),WAIT'TIME);
          IF (FEQ((LOCK'TIME←$PTR1),LONG'ZERO) OR
               FLT(LOCK'TIME,NOW)) DO;
             THEN$LHALF←LKEY;
             $PTR1←THEN;
             MON'UNLOCK(ACCTING//LOCK2:DUMMY);
LOCK2:
             RETURN;
          ELSE DO;
             MON'UNLOCK(ACCTING//LOCK3:DUMMY);
LOCK3:
             SLEEP(LWAIT);
          ENDIF;
       ENDFOR;

LOCK1X: SLEEP(SWAIT) & GOTO LOCK1;

       FUNCTION ACCT'UNLOCK(PTR2);
       PTR1←PTR2+ACCT'LOCK'BASE;
UNLOCK1: MON'LOCK(ACCTING:LKEY//UNLOCK1X:DUMMY);
       $PTR1←LONG'ZERO IF PTR1.LHALF=LKEY;
       MON'UNLOCK(ACCTING//UNLOCK2:DUMMY);
UNLOCK2:
       RETURN;

UNLOCK1X: SLEEP(SWAIT) & GOTO UNLOCK1;

       END;

        PROGRAM SLEEP;
        INCLUDE DEFS, INTERCOM;

*   THIS FUNCTION WILL BLOCK FOR T CLOCK TIMES.

       INCLUDE DEFS, INTERCOM;


        DECLARE INTEGER
           STATUS'BITS,
           REAL'TIME'INT ← 2,
           JUST'WAKEUP ← 0;

        DECLARE LONG
           X,Y,
           TIME'TO'WAKEUP,
           DELAY'TIME;

        DECLARE FIELD
           HIGH'WORD(0),
           LOW'WORD(1),
           SOURCE(0:0,2),
           ACTION(0:3,5),
           BLK(0:11,11);

        MACRO SETUP'SAB(S,A,B) ← S@SOURCE V' A@ACTION V' B@BLK;



        FUNCTION SLEEP(DELAY'TIME);

        TIME'TO'WAKEUP ← FAD(LONG(READ'CLOCK('RTC')),DELAY'TIME);
        SET'ICT(WAKEUP'TIMER,SETUP'SAB(REAL'TIME'INT,JUST'WAKEUP,1),
           THIS'SUB'PROCESS,TIME'TO'WAKEUP//RUNTIME'FAILURE());
        BLOCK(4B7 RSH WAKEUP'TIMER//RUNTIME'FAILURE());

        RETURN;



        END;

        PROGRAM PROCESS'QUEUE;
        INCLUDE GLOBAL,TIME'DECS;
        DECLARE FIELD RP(1),WP(2),FN(1);
        DECLARE FIELD OPT(0:0,2), LINE'FLAG (0:7,7),
         USE(0:6,6), OPC(0:3,5), TTY'LINE(0:8,15), PROCESS'NUMB(0:16,23);
        DECLARE ARRAY AR1[8],AR2[8];
        DECLARE PRTNO←1, CPRTNO←2, MESNO←3;
        DECLARE CHR, FLAG, I, LINE'NOS, NEXT'OP, OPER, OPTION, TNO, PRCNO;
        DECLARE FIRST'TIME;
        DECLARE STRING STR;



         FUNCTION PROCESS'QUEUE(), FRETURN;
        FIRST'TIME ← -1; FLAG ← 0;
CAL0:   LOCK(QU'FB// RETURN); QU'FB.RP.USE←1;
        IF QU'FB.RP=QU'FB.WP DO;
            INT'WORD←0; QUEUE'FLAG←0;
            UNLOCK(QU'FB);
            RETURN IF NOT FIRST'TIME ELSE FRETURN;
        ENDIF;

         FIRST'TIME ← 0;
        (UNLOCK(QU'FB) & XRUN()) IF PRE'EMPT;
        BCOPY(@AR1[0],@(QU'FB.RP.FN),8);
        BCOPY(@AR2[0],@((QU'FB.RP+9).FN),8) IF QU'FB.RP.OPC=CPRTNO;
        OPER←QU'FB.RP.OPC;
        OPTION←QU'FB.RP.OPT;
        LINE'NOS←QU'FB.RP.LINE'FLAG;
        TNO ← QU'FB.RP.TTY'LINE;
        PRCNO ← QU'FB.RP.PROCESS'NUMB;
        UNLOCK(QU'FB);
        IF OPER=PRTNO DO;
            PRINT(AR1,OPTION,LINE'NOS,0,0,TNO,PRCNO//CALE:C);
        ELSEIF OPER=CPRTNO DO;
            PRINT'CHANGES(AR1,AR2,OPTION//CALE:C);
        ELSEIF OPER=MESNO DO;
            (CRLF(1) & SOUT("***") & CRLF(1)) IF NOT FLAG; FLAG←-1;
            SETUP(STR,OPTION,@AR1[0]); SETW(STR,OPTION); SOUT(STR);
        ENDIF;
CALE:   LOCK(QU'FB//CALW);
        IF QU'FB.RP.OPC#CPRTNO DO; QU'FB.RP←QU'FB.RP+9;
        ELSE DO; QU'FB.RP←QU'FB.RP+18;
        ENDIF;
        IF QU'FB.RP>=QU'FB+3+200*9 DO;
            QU'FB.RP←3+QU'FB;
        ENDIF; NEXT'OP←QU'FB.RP.OPC; UNLOCK(QU'FB);
        IF FLAG AND NEXT'OP#MESNO DO; SOUT("***"); CRLF(1); ENDIF;
        GOTO CAL0;
CALW:   I←I FOR I←1 TO 1000; GOTO CALE;



         END;

        PROGRAM RUNTIME'FAILURE;
        INCLUDE DEFS;
        DECLARE FAIL'LOC= L' [0];



         FUNCTION RUNTIME'FAILURE();
        SOUT("RUNTIME FAILURE AT LOCATION ");
        IOUT(FAIL'LOC,8); TCO('B'); CRLF(1);
        BREAK();



         END;

PROGRAM GET'NAME;

       /* THIS PROGRAM SEARCHES THE DESIGNATED FILE DIRECTORY FOR AN  */
       /* EXISTANT FILE, THEN FORMATTS IT INTO A MONITOR FORMATTED    */
       /* NAME ARRAY USED FOR OPENING FILES, ETC. UNLIKE THE FUNCTION */
       /* GNAME, THIS FUNCTION USES AN UTILITY CALL AND THUS IT IS    */
       /* NOT NECESSARY TO SUPPLY THE ENTIRE FILE NAME & TYPE.        */

       INCLUDE GLOBAL, CRUN;

       DECLARE ARRAY NAME;      /* M1 FORMATTED ARRAY                 */

       DECLARE INTEGER DUMMY;   /* TO KEEP OPEN & CLOSE'FILE HAPPY    */

       DECLARE STRING HEADER;

FUNCTION GET'NAME(NAME, HEADER);


START: SOUT(HEADER);
       GET'LINE(' ',INP:INP);
       GOTO START IF LENGTH(INP) = 0;
       NAME'SEARCH(INP,NAME,0,6'*   ',-1//BAD'FILE:C,D);
       OPEN'FILE(-1, NAME, 'RO', -1:DUMMY//BAD'FILE:C,D);
       CLOSE'FILE(DUMMY//PUNT():C,D);

RETURN;

BAD'FILE:  SOUT("BAD FILE NAME");
           CRLF(1);
           GOTO START;


END;

        PROGRAM XNAME;
*INPUT/OUTPUT OF FILE NAMES
         MACRO IN'CHAR←(GCI(STR// VALUE 0) IF FLG<0 ELSE TCI());
        DECLARE STRING OX,USER(5);
        DECLARE KK,LIM,CH,FLAG,SLIM,FLG;
        DECLARE ON←-1,OFF←0;



         FUNCTION GNAME(ARRAY ARR); FLG←0; GOTO X0;



         ENTRY GNAME'S(ARRAY ARR,STRING STR); FLG←-1;
X0:     SETUP(OX,16,@ARR[3],6);
        ARR[0]←-1; ARR[1]←ARR[2]←0;
        ARR[7]←0; FLAG←OFF; SLIM←16;
        ARR[KK]←0 FOR KK←3 TO 6; LIM←0;
G:      CH←IN'CHAR; SETS(USER,0,0);
        RETURN IF CH=' ' OR CH='&M' ELSE (ARR[0]←-1 & GOTO CAL0A) IF CH#'#';
ULOOP:  GOTO S IF (CH←IN'CHAR)=':'; WCI(CH,USER// VALUE TCO(':') & GOTO S);
        GOTO ULOOP;
S:      ARR[0]←(-1 IF LENGTH(USER)=0 ELSE IIN'S(USER,10));
        RETURN IF (CH←IN'CHAR)=' ' OR CH='&M'; GOTO CAL0A;
CAL0:   CH←IN'CHAR; RETURN IF CH=' ' OR CH='&M';
CAL0A:  GOTO CAL2 IF CH=':' AND FLAG=OFF; LIM←LIM+1;
        IF CH='&A' DO; LIM←LIM-1;
            GCD(OX//CAL0); LIM←LIM-1; WCI(0,OX); GCD(OX);
            TCO('↑'); GOTO CAL0;
        ENDIF;
        (TCO('↑') & LIM←LIM-1 & GOTO CAL0) IF LIM>SLIM;
        WCI(CH,OX// RETURN); GOTO CAL0;
CAL2:   FLAG←ON; SETUP(OX,4,@ARR[7],6); LIM←0; SLIM←4; GOTO CAL0;



         ENTRY ONAME(ARRAY ARR,INTEGER INDX);
        SETUP(OX,16,@ARR[INDX],6);
        SETW(OX,16);
CAL1:   CH←GCI(OX// RETURN); RETURN IF CH=' ';
        TCO(CH); GOTO CAL1;



         END;

        PROGRAM GET'LINE;
        INCLUDE DEFS,TIME'DECS;
        DECLARE CHR,C,D;



         STRING FUNCTION GET'LINE(HERALD,STRING INP);
        SET'CIOS'FIELD(-1,'EST',0//PUNT():C,D);
CAL0:   SETS(INP,0,0); TIME'OK←-1;
LOOP:   CHR←TCI(); TIME'OK←0;
        GOTO EXIT IF CHR='&M';
        GOTO CAL1 IF CHR='&A'; GOTO CAL2 IF CHR='&Q';
        TCO(CHR); WCI(CHR,INP//CALF); GOTO LOOP;
CAL1:   GCD(INP//LOOP); TCO('↑'); GOTO LOOP;
CAL2:   TCO('←'); CRLF(1); TCO(HERALD) IF HERALD; GOTO CAL0;
CALF:   CRLF(1); SOUT("LINE TOO LONG"); GOTO CAL2;
EXIT:   CRLF(1); SET'CIOS'FIELD(-1,'EST',1//PUNT():C,D);
        RETURN INP;



         STRING ENTRY TRIM(STRING A);
CAL3:   (GCI(A// RETURN A) & GOTO CAL3) IF GC(A)=' ';
        RETURN A;



         END;

        PROGRAM CIO;
        INCLUDE DEFS,CHIO'CELL'DEC;
        MONITOR BLOCK ← 170;
        DECLARE FIELD NCHF(0:0,1);
        DECLARE C,D;
        DECLARE STRING STR(2);
        DECLARE MEC, MEM, NCH;



         ENTRY TCO(CHAR);
        SETS(STR, 0, 0);
        IF CHAR<=77B DO; CHAR←CHAR+240B;
        ELSE DO; CHAR←CHAR-140B;
        ENDIF;
        WCI(37B,STR//CIO80) & WCI(CHAR+40B,STR//CIO80) IF
         CHAR<40B ELSE WCI(CHAR,STR//CIO80);
CIO10:  WRITE'STRING(-1,-1,STR:STR,NCH//CIO80:MEC,MEM);
        GOTO CIO10 IF NCH>0;
        RETURN;



         ENTRY TCI();
        SETS(STR, 0, 0);
CIO20:  READ'STRING(-2,1,0,STR:STR,NCH//CIO80:MEC,MEM);
        BLOCK(4B7 RSH 7//PUNT():C,D) IF NCH$NCHF=1;
        CHAR ← GCI(STR//CIO20);
        IF CHAR=37B DO;
            CHAR ← GCI(STR//CIO80) A' 37B;
        ELSEIF CHAR<40B DO;
            GOTO CIO80;
        ENDIF;
        CHAR←CHAR A' 177B;
        CHAR←(CHAR-40B IF CHAR>=40B ELSE CHAR+340B);
        RETURN CHAR;
CIO80:  PUNT();



         END;

        PROGRAM STRING'UTILITIES;

* THIS PROGRAM BLOCK CONTAINS THE FUNCTIONS WHICH OPERATE ON STRINGS

         DECLARE FIELD
         BP (0), RP (1), WP (2), EP (3);

         DECLARE STRING FIELD
         KLUDGE (0);        /* SO THAT WHEN THE POINTER TO A STRING  */
                            /*   DESCRIPTOR IS ASSIGNED TO ANOTHER   */
                            /*   STRING, SPL WILL DO THE RIGHT THING */

         DECLARE INTEGER
         CHAR1,
         CHAR2,
         COUNT,
         LENGTH'SECOND,     /* THE LENGTH OF STRING SECOND           */
         NUM'OF'CHARS,      /* THE NUMBER OF CHARACTERS OF THE SECOND*/
/*   STRING TO BE PLACED INTO THE FIRST  */
         PREVIOUS'MATCH,    /* FLAG SIGNALING THAT THE PREVIOUS CHAR-*/
/*   ACTERS MATCHED                      */
         SAVE'RP,
         START,             /* THE POSITION OF THE INITIAL           */
/*   CHARACTER TO BE READ                */
         START'STRING;      /* THE POSITION IN THE FIRST STRING WHERE*/
/*   THE SECOND BEGINS                   */

         DECLARE STRING
         FIRST,
         SECOND,
         THIRD;



* SUBSTR RETURNS A STRING STARTING AT CHARACTER POSITION START AND
*   CONTINUING FOR NUM'OF'CHARS

         STRING FUNCTION SUBSTR (FIRST, SECOND, START, NUM'OF'CHARS),
         FRETURN;

        SETS (SECOND, START, START + NUM'OF'CHARS);
        FRETURN IF LENGTH (SECOND) > LNGDES (FIRST$WP, FIRST$EP);
        LENGTH'SECOND ← LENGTH (SECOND);

         FOR CHAR1 ← 1 TO LENGTH'SECOND DO;
            WCI (GCI (SECOND // RUNTIME'FAILURE ()), FIRST //
             RUNTIME'FAILURE ());
        ENDFOR;

         RETURN FIRST;

* INDEX FINDS THE POSITION OF STRING SECOND IN STRING FIRST. IF SECOND
*   DOESN'T APPEAR, THE FUNCTION FRETURNS.

         FUNCTION INDEX (FIRST, SECOND), FRETURN;

        FRETURN IF LENGTH (SECOND) > LENGTH (FIRST);

         SAVE'RP ← SECOND$RP;

INDX0:   INCDES (FIRST$RP, -1) IF SECOND$RP # SAVE'RP;
        SETR (SECOND, SAVE'RP);
        PREVIOUS'MATCH ← 0;

INDX1:   CHAR2 ← GCI (SECOND // RETURN START'STRING IF PREVIOUS'MATCH
        ELSE FRETURN);

INDX2:   CHAR1 ← GCI (FIRST // FRETURN);

         IF CHAR1 = CHAR2 DO;
            GOTO INDX1 IF PREVIOUS'MATCH;
            PREVIOUS'MATCH ← -1;
            START'STRING ← FIRST$RP -1;
            GOTO INDX2;

         ELSE DO;
            GOTO INDX1 IF PREVIOUS'MATCH ELSE GOTO INDX2;

         ENDIF;



* COMPARE'STRING COMPARES TWO STRINGS AND RETURNS -1 IF THEY ARE
*   EQUAL, AND 0 IF THEY ARE UNEQUAL

         FUNCTION COMPARE'STRING (FIRST, SECOND);

        IF LENGTH (FIRST) # LENGTH (SECOND) DO;
            RETURN 0;

         ELSE DO;
            LENGTH'SECOND ← LENGTH (SECOND);
            FOR COUNT ← 1 TO LENGTH'SECOND DO;
                CHAR1 ← GCI (FIRST);
                CHAR2 ← GCI (SECOND);
                RETURN 0 IF CHAR1 # CHAR2;
            ENDFOR;
            RETURN -1;
        ENDIF;


         END;

        PROGRAM APPEND;
        DECLARE STRING STR;
        DECLARE STRING FIELD STFLD(0);



         FUNCTION APPEND(STRING @P,STRING SOURCE);
        STR←P.STFLD;
X0:     WCI(GCI(SOURCE//X1),STR//X1); GOTO X0;
X1:     P.STFLD←STR; RETURN;



         END;

        PROGRAM PUNT;
        INCLUDE DEFS;
        DECLARE PUNT'LOC= L' [0];



         FUNCTION PUNT();
        CRLF(1); SOUT("PUNT AT LOCATION "); IOUT(PUNT'LOC,8);
        TCO('B');
        BREAK();



         END;

        COMMON APP'DECS;
        DECLARE STRING ARRAYONE STRING'DAY[7]←
         ("SUNDAY", "MONDAY", "TUESDAY", "WEDNESDAY",
         "THURSDAY", "FRIDAY", "SATURDAY");
        DECLARE STRING ARRAYONE STRING'MONTH[12]←
         ("JANUARY","FEBRUARY","MARCH","APRIL","MAY","JUNE","JULY",
         "AUGUST","SEPTEMBER","OCTOBER","NOVEMBER","DECEMBER");



         END;

        PROGRAM APPEND'DATE;
        INCLUDE GLOBAL, DATE'DECS,APP'DECS;
        DECLARE STRING TS;
        DECLARE STRING FIELD STF(0);



         FUNCTION APPEND'DATE(STRING @ST);
        TS←ST.STF;
        SYS'TIME'NUM(:YEAR, MONTH, WDAY, MDAY, HOUR, MIN, SEC);
        APPEND(TS,STRING'DAY[WDAY]);
        APPEND(TS,"  ");
        APPEND(TS,STRING'MONTH[MONTH]);
        WCI(0,TS);
        IOUT'S(MDAY,10,TS);
        APPEND(TS,", ");
        IOUT'S(YEAR,10,TS);
        APPEND(TS,"  ");
        IOUT'S(HOUR,10,TS);
        WCI(':',TS);
        WCI('0',TS) IF MIN < 10;
        IOUT'S(MIN,10,TS);
        WCI(':',TS);
        WCI('0',TS) IF SEC < 10;
        IOUT'S(SEC,10,TS);
        ST.STF←TS;
        RETURN;



         END;

        PROGRAM IIN;
        DECLARE SUM,CHR,SIGN,FLAG;
        MACRO IN'CHAR←(GCI(STR//FINI) IF FLAG<0 ELSE TCI());



         FUNCTION IIN(RADIX); FLAG←0; GOTO X0;



         ENTRY IIN'S(STRING STR,INTEGER RADIX); FLAG←-1;
X0:     SUM←0;
        CHR←IN'CHAR; (SIGN←-1 & GOTO LOOP) IF CHR='-' ELSE
        (SIGN←1 & GOTO LOOP1);
LOOP:   CHR←IN'CHAR;
LOOP1:  GOTO FINI IF CHR<20B OR CHR>=20B+RADIX;
        SUM←SUM*RADIX+CHR-20B; GOTO LOOP;
FINI:   RETURN SUM*SIGN;



         END;

        PROGRAM IOUT;
        DECLARE STRING ST(15);
        DECLARE A1,A2,I,FLAG;
        DECLARE STRING FIELD STFLD(0);
        DECLARE STRING ISTR;



         FUNCTION IOUT(A,RADIX); FLAG←0; GOTO XX;



         ENTRY IOUT'S(A,RADIX,STRING @STR); FLAG←-1;
        ISTR←STR.STFLD;
XX:     SETS(ST,0,0); I←0;
        IF A<0 AND RADIX=8 DO;
            IF FLAG DO;
                WCI(((A RSH ((8-I)*3)) A' 7)+20B,ISTR) FOR I←1 TO 8;
                GOTO X3;
            ELSE DO;
                TCO(((A RSH ((8-I)*3)) A' 7)+20B) FOR I←1 TO 8;
            ENDIF;
            RETURN;
        ELSEIF A<0 DO; A←-A; I←-1;
        ENDIF;
X0:     A1←A/RADIX; A2←A-RADIX*A1; A←A1;
        WCI(A2+20B,ST//X1A);
        IF A=0 DO; WCI('-',ST//X1A) IF I<0; GOTO X1A;
        ELSE DO; GOTO X0;
        ENDIF;
X1:     TCO(GCD(ST// RETURN)); GOTO X1;
X1A:    GOTO X1 IF FLAG=0;
X2:     WCI(GCD(ST//X3),ISTR); GOTO X2;
X3:     STR.STFLD←ISTR; RETURN;



         END;

        PROGRAM CRLF;
        DECLARE K;



         FUNCTION CRLF(I);
        (TCO('&M') & TCO('&J')) FOR K←1 TO I;
        RETURN;



         END;

        PROGRAM SOUT;
        DECLARE CHR;



         FUNCTION SOUT(STRING ST);
X1:     CHR←GCI(ST// RETURN);
        IF CHR>77B DO;
            TCO(CHR) IF CHR='&M' OR CHR='&J'; GOTO X1;
            TCO('&&');
        ENDIF; TCO(CHR A' 77B);
        GOTO X1;



         END;

        COMMON DECDECS;
*
* SHORT DECLARATION MACROS FOR SPL
*

         MACRO INT ← DECLARE INTEGER;
        MACRO OCT ← DECLARE OCTAL;
        MACRO PTR ← DECLARE POINTER;
        MACRO CHR ← DECLARE CHARACTER;
        MACRO   ST ← DECLARE STRING;
        MACRO   LN ← DECLARE LONG;
        MACRO LNLN ← DECLARE LONGLONG;
        MACRO   LB ← DECLARE LABEL;

         MACRO UINFL ← DECLARE INTEGER FIELD;* /OCTFL/UINFL/
        MACRO SINFL ← DECLARE INTEGER SIGNED FIELD;* /INTFL/SINFL/
        MACRO PTRFL ← DECLARE POINTER FIELD;
        MACRO CHRFL ← DECLARE CHARACTER FIELD;
        MACRO   STFL ← DECLARE STRING FIELD;
        MACRO   LNFL ← DECLARE LONG FIELD;
        MACRO   FNFL ← DECLARE FUNCTION FIELD;

         MACRO INTARY ← DECLARE INTEGER ARRAY;
        MACRO PTRARY ← DECLARE POINTER ARRAY;
        MACRO CHRARY ← DECLARE CHARACTER ARRAY;
        MACRO   STARY ← DECLARE STRING ARRAY;
        MACRO   LNARY ← DECLARE LONG ARRAY;
        MACRO   LBARY ← DECLARE LABEL ARRAY;
        MACRO FLARY ← DECLARE FIELD ARRAY;
        MACRO FNARY ← DECLARE FUNCTION ARRAY;

         MACRO INTARY1 ← DECLARE INTEGER ARRAYONE;
        MACRO PTRARY1 ← DECLARE POINTER ARRAYONE;

         MACRO INTFN ← DECLARE INTEGER FUNCTION;

         MACRO ARBENT ← UNKNOWN ENTRY;
        MACRO INTENT ← INTEGER ENTRY;
        MACRO PTRENT ← POINTER ENTRY;
        MACRO CHRENT ← CHARACTER ENTRY;
        MACRO STENT ← STRING ENTRY;
        MACRO LNENT ← LONG ENTRY;
        MACRO LBENT ← LABEL ENTRY;
        MACRO ARYENT ← ARRAY ENTRY;

         MACRO ARBEXT ← DECLARE UNKNOWN EXTERNAL;
        MACRO INTEXT ← DECLARE INTEGER EXTERNAL;
        MACRO PTREXT ← DECLARE POINTER EXTERNAL;
        MACRO CHREXT ← DECLARE CHARACTER EXTERNAL;
        MACRO STEXT ← DECLARE STRING EXTERNAL;
        MACRO LNEXT ← DECLARE LONG EXTERNAL;
        MACRO LBEXT ← DECLARE LABEL EXTERNAL;
        MACRO ARYEXT ← DECLARE ARRAY EXTERNAL;

         MACRO C'(X)←;* KLUDGE FOR INTERNAL COMMENTS

         MACRO LTABLE(F) ← F$FLDWDSP+1;
        SINFL FLDWDSP(0: 13,23);

* LENGTHS OF NAMES
         INT LMN ← 4, LTY ← 1, LFN ← LMN+LTY;
        INT NBY ← 4, LNCH ← 24/NBY, NMNCH ← LMN*NBY,
         NTYCH ← LTY*NBY, NFNCH ← LFN*NBY, NCMCH ← 90;



         END;

        COMMON COMDECS; INCLUDE DECDECS;
*
* COMMON DECLARATIONS FOR CODING
*

* GENERALLY USEFUL MACROS
         MACRO NAMSET(S,L,A,B) ← SETUP(S,L,A,B) & S$WP ← S$EP;
        MACRO EMPTY(S) ← LNGDES(S$RP, S$WP) <= 0;*** WP=RP OR WP=BP?
        MACRO REPEAT ← WHILE 1 DO;
        MACRO ENDRPT ← ENDFOR;
        MACRO FDISP(F) ← RUNTIME'FAILURE() IF F$FLDSTB # 0 AND
         F$FLDSIZE # 24 ELSE F$FLDWDSP;
        UINFL FLDSTB(0: 8,12), FLDSIZE(0: 3,7);

* ERROR MACROS
         MACRO NC'PUNT ← RUNTIME'FAILURE();* FOR NORMAL CALLS (EXPRESSIONS)
        MACRO LF'PUNT ← VALUE NC'PUNT;* FOR LIBRARY FUNCTIONS
        MACRO SF'PUNT ← LF'PUNT: ERCODE, ERMSNO;* FOR SYSTEM CALLS

* QUIT ACTION MACROS
         MACRO QUIT'PUNT(L) ← VALUE GOTO L IF ERCODE = 'QIT' ELSE
         RUNTIME'FAILURE(): ERCODE, ERMSNO;
        MACRO QUIT'PUNTX(L, X) ← VALUE GOTO L IF ERCODE = 'QIT' ELSE
         RUNTIME'FAILURE(): X, ERCODE, ERMSNO;

* PARAMETRIC CHARACTER DEFINITIONS
         CHR SCHERALD ← '>' C'(/* SUB-COMMAND HERALD */),
         BELCH ← 303B C'(/* BELL */), NULCH ← 300B C'(/* NULL */),
         NLCH ← 307B C'(/* NEW LINE */),
         LFCH ← 310B C'(/* LINE FEED */),
         MBCH ← 200B C'(/* ZERO MULTIPLE BLANKS */),
         SQTCH ← '&'' C'(/* SINGLE QUOTE */),
         DQTCH ← '"' C'(/* DOUBLE QUOTE */),
         SEPCH ← '-' C'(/* SEPARATOR */);

* STRING POINTER FIELDS
         UINFL BP(0) C'(/* BEGINNING */), RP(1) C'(/* READER */),
         WP(2) C'(/* WRITER */), EP(3) C'(/* END */);

* CHARACTER FIELDS
         UINFL CH0(0: 0,7), CH1(0: 8,15), CH2(0: 16,23);

* BEAD LENGTH FIELD
         UINFL LENGF(-1: 6, 23);

* FIELDS IN UTILITY FILE NAME
         LNFL UFNUN(0) C'(/* USER NUMBER/DISK ADDRESS */);
        UINFL UFNEN(2) C'(/* OBJECT ENTRY-NUMBER */),
         UFNFN(3) C'(/* FILE NAME */), UFNMN(3) C'(/* MAIN NAME */),
         UFNTY(3+LMN) C'(/* TYPE WORD */);

* FIELDS FOR UNO/DKA
         UINFL UNDKUN(0),
         UNDKDK(1);

         INT LUFN ← LTABLE(UFNTY);* LENGTH OF UTILITY FILE:NAME
        INT CB'PMT ← 1;* PMT ADDRESS OF CONTEXT BLOCK

* DECLARATIONS OF COMMON FUNCTIONS

* SPL RUNTIME FUNCTIONS
*ARBEXT    SCOPY, APPEND, CNS, RUNTIME'FAILURE;

* STORAGE ALLOCATOR
*ARBEXT    STORINIT, SELZONE, EXTZONE, FREE, FREEZONE;
        END;

       PROGRAM GET'ACCT'PNTR;

* THIS PROGRAM GETS THE POINTER TO THE FILE BUFFER OF #1:ACTIVE-USERS:BIN.
* THIS IS NECESSARY FOR THE ACCOUNT'LOCK PROGRAM.

       INCLUDE COMDECS, M30PAR, GLOBAL;

       DECLARE INTEGER I,PMTI,OFTI,LNO,KEY,PGNO;
       DECLARE INTEGER ARRAY FN[LUFN];
       DECLARE INTEGER FIELD PAG'FL(0:6,12);
       DECLARE POINTER PNTR;
       DECLARE STRING NAME ← 6"#1:X298-ACTUSR";

       FUNCTION GET'ACCT'PNTR();

       KEY ← READ'PROC'PARAM('IKY'//SF'PUNT);
       NAME'SEARCH(NAME,FN,1,'',KEY//SF'PUNT);
       OPENF(-1,FN,0,KEY:OFTI//SF'PUNT);
       ACQPMT(-1:PMTI//SF'PUNT);
       FOR I←1, I+1 WHILE READ'MAP'BYTE(-1,I//SF'PUNT)#0 DO;
       ENDFOR;
       SET'MAP'BYTE(-1,I,PMTI//SF'PUNT);
       FPGPMT(OFTI,0,PMTI//SF'PUNT);
       PNTR ← I@PAG'FL;
       RETURN (OFTI,PMTI,PNTR);

       END;

        PROGRAM CNS; INCLUDE COMDECS;
        INT N, F, R, T, I, D; PTR P; ST S, B(25); STFL A(0);

         ARBENT CNS(N, STRING @P, F, R), FRETURN;

         S ← P.A;
        FRETURN IF R < 2 OR R > 36;
        T ← (-N IF F >= 0 AND N < 0 ELSE N);
        B$RP ← B$WP ← B$EP; I ← 0;
LP:     .LDA T; .LSHD -23; .DIV R; .STA T; .STB D;
        WCD(D +('0' IF D < 10 ELSE 'A'-10), B);
        I ← I + 1; GOTO LP IF T # 0;
        WCD('-', B) & I ← I + 1 IF F >= 0 AND N < 0;
        F ← F A' 77B;
        IF F = 0 DO;
            F ← I;
        ELSEIF F <= I DO;
            B$RP ← INCDES(B$EP, -I);
        ELSE DO;
            WCI(' ', S// FRETURN) FOR I ← I + 1 TO F;
        ENDIF;
        WCI(D, S// FRETURN)
         FOR D ← GCI(B// VALUE P.WP ← S$WP & RETURN) WHILE 1;



         END;

        COMMON HMFOG;

         INCLUDE GLOBAL;
        DECLARE STRING INP(70);
        MACRO RCL(RL,RLP)←RL←GET'LINE(0,RL);
        MACRO GPR(A,B,C)←GPPR(A,B:A,B//C);
        MACRO COUT(A)←TCO(A);
        MACRO FL()←PP(77);
        MACRO DFS←DECLARE STRING;
        MACRO DC←DECLARE;
        MACRO FRET← FRETURN;
        MACRO ATTB(ATBARR)←
         BLKBUF[I]←(((BCD[ATBARR[(3*I)]] LSH 8) +BCD[ATBARR[(3*I)+1]]) LSH 8)+
         BCD[ATBARR[(3*I)+2]] FOR I←0 TO 26;

         DECLARE ARRAY BCDASC[64],BLKBUF[1100];
        DECLARE CURREC,CURFIL,E,TAPMOD;
        DECLARE ARRAY BCD[64]←(
         20B,52B,57B,13B,53B,34B,60B,74B,
         32B,35B,54B,37B,33B,40B,73B,21B,
         12B,01B,02B,03B,04B,05B,06B,07B,
         10B,11B,15B,56B,76B,77B,16B,72B,
         14B,61B,62B,63B,64B,65B,66B,67B,
         70B,71B,41B,42B,43B,44B,45B,46B,
         47B,50B,51B,22B,23B,24B,25B,26B,
         27B,30B,31B,75B,36B,55B,17B,17B);
        INTEGER MONITOR OPENF←19;



         END;

        COMMON HMMG;
        INCLUDE HMFOG;

         DECLARE NBB,I,A,STADR,F,FI,C,D,J,G,GER;
        DECLARE FIELD BP(0),RP(1),WP(2),EP(3);
        DECLARE STRING GNMS,BACST,GT,GT1,GPALN,GPAPS,TRBF,NULL(3);
        DECLARE STRING SLIN(100),LINE,PAR;

         DECLARE ARRAY FLAB[81];
        DECLARE STRING AS(30), FNSTR(50),NMSTR(18);


         DECLARE FIELD PF(0:6,6), UPF(0:7,12), SPF(0:8,12),
         SIX(0:18,23),
         LEL(0:13,23),LB(0:23,23),TF(0:0,11),BOF(0:12,23);
        DECLARE FIELD FFO(0:18,23);

         MACRO FAIL()←FL();
        MACRO RCLL←(LINE←INP & XXPP());
*
*  DECLARATIONS
*
*


*  ENTRY POINT INTO PROGRAM LABEL IS .ENTER



         END;

        PROGRAM INITQM;
        INCLUDE HMMG;

         FUNCTION INITQM();
        CURFIL←CURREC←0;
        BCDASC[BCD[I]]←I FOR I←0 TO 77B;
        SETS(NULL,0,0);
        RETURN;



         END;

        PROGRAM BACKUP;
        INCLUDE HMMG;



         STRING FUNCTION BACKUP(STRING BACST), FRETURN;
        CRLF(1);   SOUT(BACST);   RCL(SLIN,FRET); GPR(SLIN,PAR,FRET);
        LINE←SLIN;
        RETURN PAR;



         END;

        PROGRAM GNM;
        INCLUDE HMMG;
        DECLARE XX1;

         ENTRY XXPP(); GPAR(LINE,PAR); RETURN;

         FUNCTION GNM(STRING GNMS), FRETURN;
        GPR(LINE, PAR , GSA1);
GSA0:   RETURN XX1 ← CSNF(PAR//GSA1);
GSA1:   FRETURN IF LENGTH(GNMS)=0; BACKUP(GNMS//GSA1);   GOTO GSA0;



         END;

        PROGRAM CSNF;
        INCLUDE HMMG;

         DECLARE DCM,OCT,MINF,CHARACTER CHR;
        DECLARE STRING CSS;
        INTEGER FUNCTION CSNF(CSS), FRETURN;
        DCM←OCT←MINF←0;
CSN0:   GOTO CSN1 IF (CHR←GCI(CSS//CSN7))='+';
        MINF←-1 IF CHR='-' ELSE GOTO CSN2;
CSN1:   CHR←GCI(CSS//CSN7);
CSN2:   GOTO CSN3 IF (CHR>='0') AND (CHR<='9') ELSE
        GOTO CSN4 IF CHR='B' ELSE
         GOTO CSN5 IF CHR='D' ELSE
         FRET;
CSN3:   OCT←OCT *8+(CHR-'0');
        DCM←DCM *10+(CHR-'0');
        GOTO CSN1;
CSN4:   DCM←OCT; OCT←8; GOTO CSN6;
CSN5:   OCT←10;
CSN6:   CHR←GCI(CSS//CSN7);
        FRET IF CHR<'0' OR CHR>'9';
        DCM←DCM *OCT FOR CHR←CHR-1-'0' BY -1 TO 0;
CSN7:   DCM←-DCM IF MINF<0;
        RETURN DCM;



         END;

        PROGRAM GPEFESS;

*CREATE-SYSINIT-TAPE
         INCLUDE HMMG;

         DECLARE STRING VOLST←"VOL1INIT00",EOVST←"EOV",EOFST←"EOF";
        DECLARE STRING FLST←
         "HDR1INITIALIZESYSTEMTINIT000001                                                  ";
        DECLARE STRING XS;
        DECLARE POINTER PPTR,BPTR;
        DECLARE FPA,CPA,NP;

         MACRO GFL← VALUE CRLF(1) & IOUT(GER,10) & PUNT();



         FUNCTION POS(NBB);
        IF NBB=0 DO;
            RWND(//GFL:GER); FSR(80//GFL:GER); CURFIL←0; RETURN;
        ENDIF;
        RETURN IF NBB=CURFIL;
        IF NBB<CURFIL DO;
            RWND(//GFL:GER);
            FSF(//GFL:GER) FOR I←1 TO NBB;
        ELSE DO;
            A←NBB-CURFIL;
            FSF(//GFL:GER) FOR I←1 TO A;
        ENDIF;
        CURFIL←NBB; RETURN;



         FUNCTION CINIT();
        RWND(//GFL:GER); SWBCD(//GFL:GER); XS←VOLST;
        SETS(XS,0,10);
        FLAB[I]←GCD(XS) FOR I←9 BY -1 TO 0;
        ATTB(FLAB);
        TOUT(10,80//GFL:GER);
        RETURN;

*WRITE-LABEL

         FUNCTION WLAB();
        RCLL; XS←FLST;
        SETS(XS,0,80);
        FLAB[I]←GCD(XS) FOR I←79 BY -1 TO 0;

         GPR(LINE,NMSTR,WL1);
WL3:    FLAB[I]←GCI(NMSTR//DNMM) FOR I←4 TO 20;
DNMM:   FLAB[J]←' ' FOR J←I TO 20;
        FLAB[I]←'0' FOR I←40 BY -1 TO 31;
        GPR(LINE,AS,WL2);
WL5:    FLAB[I]←GCD(AS//DNGN) FOR I←38 BY -1 TO 35;
DNGN:   GPR(LINE,AS,WL4);
WL6:    FLAB[I]←GCD(AS//DNVN) FOR I←40 BY -1 TO 39;
        POS(GNM(NULL//DNVN)*3);
DNVN:   SETS(AS,0,0);
        CNS((CURFIL+3)/3,AS,0,10//PUNT());
        FLAB[I]←GCD(AS//DNFSN) FOR I←34 BY -1 TO 31;
DNFSN:  ATTB(FLAB);

         SWBCD(//GFL:GER); TOUT(80,80//GFL:GER); WEOF(//GFL:GER);
WLDN:   SET'MODE(12B//PUNT():GER); RETURN;
WL1:    NMSTR←BACKUP("NAME"//WL1 ); GOTO WL3;
WL2:    AS←BACKUP("GENERATION"//WL2); GOTO WL5;
WL4:    AS←BACKUP("VERSION"//WL4); GOTO WL6;


*READ-LABEL

         FUNCTION RLAB();
        RCLL;
        POS(GNM(NULL//RL1)*3);

RL1:     SWBCD(//GFL:GER); FSR(80//GFL:GER); FSF(//GFL:GER); COUT('"');
        SETUP(TRBF,80,@BLKBUF[0]);
        SETS(TRBF,4,21);
RL2:    TCO(BCDASC[GCI(TRBF//RL3) A' 77B]) & GOTO RL2;
RL3:    SETS(TRBF,35,39);
        SOUT("&"&M&J GENR.VER ");

RL4:     TCO(BCDASC[GCI(TRBF//RL5) A' 77B]) & GOTO RL4;
RL5:    SETS(TRBF,39,41);
        COUT('.');
RL6:    TCO(BCDASC[GCI(TRBF//RL7) A' 77B]) & GOTO RL6;
RL7:    SET'MODE(12B//PUNT():GER); RETURN;

*WRITE-INIT-CORELOAD

         FUNCTION WICL();
        RETURN;



         FUNCTION WBCL();
        RCLL; GIF();
        POS(GNM(NULL//WB1)*3+1);
        A←GNM(NULL//WB1);
        FSRR(//GFL:GER) & FSRR(//GFL:GER) FOR I←1 TO A;
WB1:    BLKBUF[0]←1; BLKBUF[I]←0 FOR I←3 TO 7;
        BPTR←@BLKBUF[9];
WB2:    FPA←GNM("FILE PAGE ADDRESS: "//PUNT());
        GOTO WB5 IF FPA<0;
        CPA←GNM("CORE PAGE ADDRESS: "//PUNT());
        GOTO WB5 IF CPA<0;
        NP←GNM("NUMBER OF PAGES: "//PUNT());
        GOTO WB5 IF NP<0;

         FOR I←0 TO NP DO;
            GOTO WB3 IF CPA>76B;
            A←52525252B;
            PPTR←GET'PAGE(FI,FPA//WB4);
            BCOPY(BPTR,PPTR,1024);
            A←A E' BLKBUF[J] FOR J←9 TO 1032;
            BLKBUF[1]←FPA; BLKBUF[2]←1; BLKBUF[8]←CPA;
            TOUT(1033,1034//GFL:GER);
            BCOPY(BPTR,PPTR+1024,1024);
            A←A E' BLKBUF[J] FOR J←9 TO 1032;
            BLKBUF[2]←2; BLKBUF[1033]←A;
            TOUT(1034,1034//GFL:GER);
            FPA←FPA+1; CPA←CPA+1;
            REL'PAGE(PPTR//PUNT());
        ENDFOR;
        GOTO WB2;

WB3:     SOUT("&M&JPAGE OUT OF BOUNDS: ");
        IOUT(CPA,8); GOTO WB6;

WB4:     SOUT("&M&JFILE PAGE NOT THERE: ");
        IOUT(FPA,8);

WB6:     SOUT("B&M&JCONTINUE FROM ERROR:&M&J");
        RCL(SLIN,PUNT());
        LINE←SLIN;
        GOTO WB1;

WB5:     SOUT("&M&JDONE");
        SOFTCL(FI,0//PUNT():A,A);
        RETURN;

*WRITE-INIT-FILES

         FUNCTION WMIF();
        RCLL;
        POS((GNM(NULL//WM1)*3)+1);
WM1:    M1DUMP(0);
        RETURN;



*END-INIT-FILE

         FUNCTION EIF();
        RCLL;

         D←GNM(NULL//EIF1); C←CURFIL;
        RWND(//GFL:GER); POS(C);
        (FSR(1034) & FSR(1034)) FOR I←1 TO D;
EIF1:   WEOF(//GFL:GER); XS←EOFST;
        SETS(XS,0,3);
        FLAB[I]←GCI(XS) FOR I←0 TO 2;
        SETS(AS,0,0);
        AS←CNS(CURREC,AS,0,10//GFL);
        FLAB[I]←GCD(AS//DNPGCT) FOR I←59 BY -1 TO 54;
DNPGCT: FLAB[I]←'0' FOR J←I BY -1 TO 54;
        FLAB[I]←FLAB[I] A' 77B FOR I←0 TO 77B;
        ATTB(FLAB);
        SWBCD(//GFL:GER);
        TOUT(80,80//GFL:GER); G←0;
        WEOF(//GFL:GER);
        RETURN;



*END-INIT-TAPE

         FUNCTION EIT();
        RCLL;
        D←CURFIL -1;
        D←GNM(NULL//EIT1)*3+2;
EIT1:   RWND(//GFL:GER); POS(D); SWBCD(//GFL:GER); FSR(80//GFL:GER);
        WEOF(//GFL:GER); WEOF(//GFL:GER); RWND(//GFL:GER); RETURN;



         END;

        PROGRAM GPR;
        INCLUDE HMMG;

         FUNCTION GPPR(STRING GT,GT1), FRETURN;
        GPAR(GT,GT1); FRET IF LENGTH(GT1)=0;
        RETURN (GT,GT1);



         END;

        PROGRAM GPAR;
* GET NEXT PARAMETER
         INCLUDE HMMG;

         DECLARE GPACH,GPALN,GPAPS;
        DECLARE STRING FIELD SFL(0);
        DECLARE STRING GPALNP;



         FUNCTION GPAR(STRING @GPALN,STRING @GPAPS);

         GPALNP←GPALN.SFL;

* SCAN OVER INITIAL BLANKS
GPA1:    GPACH ← GCI(GPALNP// GPA7); GOTO GPA1 IF GPACH = ' ';
        GPAPS.BP ← INCDES(GPALNP$RP, -1);
        (GPAPS.EP ← GPAPS.BP & GOTO GPA4)
         IF GPACH = ',';* NULL PARAMETER

* SCAN OVER PARAMETER
GPA2:    GPACH ← GCI(GPALNP// GPA8);
        GOTO GPA2 IF GPACH # ' ' AND GPACH # ',';
        GPAPS.EP ← INCDES(GPALNP$RP, -1);
        GOTO GPA4 IF GPACH = ',';

* ELIMINATE BLANKS
GPA3:    GPACH ← GCI(GPALNP// GPA6);
        GOTO GPA3 IF GPACH = ' ' ELSE GOTO GPA5 IF GPACH # ',';

* ELIMINATE TRAILING BLANKS
GPA4:    GOTO GPA4 IF GCI(GPALNP// GPA6) = ' ';

* END OF COMPLETE PARAMETER
GPA5:    GPALNP$RP ← INCDES(GPALNP$RP, -1);
GPA6:   GPAPS.RP ← GPAPS.BP; GPAPS.WP ← GPAPS.EP;
        GPALN.RP←GPALNP$RP; RETURN;

* END OF  STRING
GPA7:    GPAPS.BP ← GPALNP$RP;
GPA8:   GPAPS.EP ← GPALNP$RP; GOTO GPA6;



         END;

        PROGRAM FUFFWHS;
        INCLUDE HMFOG;
        DECLARE X,L,BB,BLEN;
        DECLARE STRING BSTR;



         FUNCTION FSF(), FRETURN;
        SKIP'FILE(// FRETURN 1:E);
        CURREC←0;
        CURFIL←CURFIL+1; RETURN;



         FUNCTION FSR(L), FRETURN;
        L←L*3 IF TAPMOD>=0;
        READ'RECORD(L,BLKBUF// FRETURN 2:E);
        CURREC←CURREC+1;
        RETURN;



         FUNCTION FSRR(), FRETURN;
        FORWARD'REC(// FRETURN 11:E);
        CURREC←CURREC+1; RETURN;



         FUNCTION BSR(), FRETURN;
        BACK'REC(// FRETURN 2:E);
        CURREC←CURREC-1; RETURN;



         FUNCTION BSF(), FRETURN;
        BACKWARD'SPACE(// FRETURN 4:E);
        CURFIL←CURFIL-1; CURREC←0;



         FUNCTION SWBCD(), FRETURN;
        SET'MODE(14B// FRETURN 5:E);
        TAPMOD←-1;
        RETURN;



         FUNCTION RWND(), FRETURN;
        REWIND(// FRETURN 7:E);
        CURFIL←CURREC←0;
        RETURN;



         FUNCTION WEOF(), FRETURN;
        ERASE'G(// FRETURN 8:E);
        WRITE'TAPE'MARK(// FRETURN 9:E);
        CURREC←0; CURFIL←CURFIL+1;
        RETURN;



         FUNCTION TOUT(BB,BLEN), FRETURN;
        BB←BB*3 & BLEN←BLEN*3 IF TAPMOD>=0;
        SETUP(BSTR,BLEN,@BLKBUF[0],8);
        SETW(BSTR,BB);
TOT2:   WCI(0,BSTR//TOT1) & GOTO TOT2;
TOT1:   WRITE'RECORD(BLEN,BLKBUF// FRETURN 10:E);
        CURREC←CURREC+1;
        RETURN;



         END;

        PROGRAM GIF;
        INCLUDE HMMG;
        DECLARE ARRAY FINAME[8];
        DFS INM←"INPUT FILE:  ";



         FUNCTION GIF();
        GPR(LINE,PAR,GIF1);
GIF0:   GNAME'S(FINAME,PAR);
        FI←OPENF(-1,FINAME,0,OA//GIF1:C,D);
        RETURN FI;
GIF1:   BACKUP(INM//GIF1);
        GOTO GIF0;



         END;
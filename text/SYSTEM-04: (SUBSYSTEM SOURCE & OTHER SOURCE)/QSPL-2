********************  QSPL-DRIV  *****


*  (LOWER CASE)
       NOLIST EXT


* DRIVER, INITIALIZATION AND CLEANUP FOR QSPL, ASSEMBLE WITH NARP
QD     IDENT

* ENTRY POINTS FROM EXEC
       BRU ENTRY0
       BRU ENTRY1


**************
* END OF PGM *
**************

* SYMBOL TABLE WRITING ROUTINES

* SORT MAIN SYMBOL TABLE
* (A),(B),(X) DESTROYED
RYT    LDA ASYMHT; STA RYTP
* COMPACT ALL ENTRIES TO BEGINNING OF HASH TABLE
* ELIMINATE ZERO POINTERS AND RESERVED WORDS
RYT1   CAX; LDB 0,2; SKB =-1; BRU RYT2
RYT3   ADD =1; SKE AESMHT; BRU RYT1; BRU CYT1
RYT2   CBA; ETR =37777B; XXA
       LDB SFLAG,2; SKB =RWF; BRU RYT3
       SKB =7777B4; BRU RYT4; STX* RYTP
       MIN RYTP; BRU RYT3
RYT4   STX* RYTP; MIN RYTP; BRU RYT3
* CLASSIFICATION SORT PROGRAM
CYT1   LDA ASYMHT; SUB RYTP; STA NSYMTX
       LDA RYTP; MRG =2B7; STA ESYMTX; LDA =5; STA CYTI
       LDA ESYMPI; SUB NSYMTX; STA ESYMPX
* START NEW PASS: COUNT CLASSES AND COMPUTE ORIGINS
CYT3   LDX =-100B; CLA; STA CYTTE,2; BRX *-1
       LDX CYTI; LDA CYTLT,2; STA CYTL
       LDA CYTST,2; STA CYTS; LDX NSYMTX
CYT4   STX CYTP; LDX* ESYMTX
       EXU CYTL; EXU CYTS; ETR =77B; CAX
       MIN CYTT,2; LDX CYTP; BRX CYT4
       LDX =-100B; LDA ESYMPX; SUB =2B7+1; ADD NSYMTX
CYT5   XMA CYTTE,2; ADD CYTTE,2; BRX CYT5
* REARRANGE TABLE
       LDX NSYMTX
CYT6   STX CYTP; LDX* ESYMTX
       EXU CYTL; EXU CYTS; ETR =77B; XXA
       MIN CYTT,2; STA* CYTT,2; LDX CYTP; BRX CYT6
       LDA ESYMPX; XMA ESYMTX; STA ESYMPX
       SKR CYTI; BRU CYT3; R1
ESYMPI ZRO SYMPT,2
* LOAD AND SHIFT INSTRUCTIONS
CYTLT  LDB 0,2; LDB 0,2; LDA 0,2; LDA 0,2; LDA 1,2; LDA 1,2
CYTST  LCY 6; LCY 12; RCY 6; NOP; RCY 6; NOP

* SCAN SYMBOL HASH TABLE (A,B) USING SUBROUTINE (X)
* ZERO ENTRIES ARE IGNORED
* (A),(B),(X) DESTROYED
SCT    STA SCP; STB SCE; STX SCS
SCT1   SKE SCE; BRU *+2; R1
       LDX* SCP; CLA; SKE* SCP; C* SCS
       MIN SCP; LDA SCP; BRU SCT1

* SCAN MAIN SYMBOL TABLE USING SUBROUTINE (X)
* (A),(B),(X) DESTROYED
SST    LDA ASYMHT; LDB RYTP; BRU SCT

* SCAN LITERAL TABLE USING (X)
* (A),(B),(X) DESTROYED
SLT    LDA ACONHT; LDB AECNHT; BRU SCT

* SCAN MAIN SYMBOL TABLE FOR WRITING USING (X), TYPE (A)
* (A),(B),(X) DESTROYED
SWT    STX SCS; LDB =4; C OCW
       LDX SCS; C SST; LDA =-1; CR1 OCW

* WRITE LITERAL TABLE
WLT    MIN NLIT; LDA SCHAIN,2; SKE =37777B; BRU WLT1
       MIN NULIT; R1
WLT1   STX WLP; C ODF; LDX WLP
       LDA SFLAG,2; SKA =REFF; BRU WLT2
       SKA =FLTCF; BRU WLT3; LDA SCHAIN,2
       CLB; SKA =4B6; LDB =2; LDA SVAL,2; CR1 OCW
WLT2   LDA SVAL,2; CR1 OSI
WLT3   LDA SVAL,2; CLB; C OCW
       LDX WLP; LDA SNAME,2; CLB; CR1 OCW

* LIST UNDEFINED SYMBOLS
AUL    LDA SFLAG,2; SKA =REFF; BRU *+2; R1
       LDX SVAL,2; LDA SCHAIN,2; SKE =37777B; R1; BRU AUE
AUS    LDA SCHAIN,2; SKE =37777B; BRU AUE
       LDA SFLAG,2; SKA =7777B4; R1
       CLA; STA* SCP; R1
AUE    LDA SFLAG,2; SKA =7777B4; R1; STX CBT
       SKN LSTEXT; BRU AU3; MRG =INTVF; STA SFLAG,2
       SKN USF; BRU AU1; MIN USF
       LDA =AUM; LDB =-1; LDX LSTFIL; BRS 34
AU1    SKR USF; BRU AU2; LDA =7; STA USF
       C WCR; TCL CHSTAR
AU2    TCL =0; LDX CBT; CR1 WSY
AUM    ASC '$*** UNDECLARED SYMBOLS:$/'
AU3    MRG =EXTF; STA SFLAG,2; R1

* ALLOCATE INITIALIZED VARIABLES
AIS    LDA SCHAIN,2; SKA =1B7; BRU *+2; R1
       SKA =4B7; BRU *+2; C ODF; LDX* SCP; LDA SCHAIN,2
       SKA =2B6; BRU AIS3
       CLB; SKA =4B6; LDB =2; LDA SVAL,2; C OCW
AISL   EQU *
AIS4   LDX* SCP; C WLB; LDA SCHAIN,2; SKA =6B6; BRU AIS1
       LDA ='DATA'; CLB; C WSW; TCL =0
       LDA SVAL,2; C WVL; BRU AIS2
AIS1   LDA ='ZRO '; CLB; C WSW; TCL =0
       LDA SCHAIN,2; SKA =2B6; BRU AIS5
       C CGL; C WSW; LDA SVAL,2; LRSH 9; ETR =7B4
       SKG =0; BRU AIS2; MRG =',0  '; CLB; C WSW
AIS2   CR1 WCR
AIS3   LDA SVAL,2; C OSI; BRU AIS4
AIS5   LDX SVAL,2; C WSY; BRU AIS2

* ALLOCATE NON-INITIALIZED VARIABLES
ATS    LDA SFLAG,2; SKA =EXTF; R1
       SKA =INTVF+STRDF; SKN LSTUIV; BRU ATS1
       LDA SCHAIN,2; SKA =7B7; R1; C WLB
       LDA ='ZRO '; CLB; C WSW; C WCR
       C ODF; CLAB; C OCW; R1
ATS1   EOR =INTCF+INTVF; SKA =ENTF; SKA =INTCF; R1; STA SFLAG,2
       LDA SVAL,2; MCON; LDA SCHAIN,2; CXB; LDX* SCP
       SKE =37777B; BRU ATS2; MRG =SYMIV; STA SCHAIN,2; R1
ATS2   CBA; MRG =SYMPTR; STA SCHAIN,2; R1

* ALLOCATE TEMPORARY STORAGE
AWS    CXA; SKE =-1; BRU *+2; R1
       LDA SCHAIN,2; SKE =SYMTMP+37777B; BRU *+2; R1
       LDA SCP; SUB ATMPBF; STA TMPMAX
       LDA SNAME,2; ADD TMPORG; LDB =2; C OCW
       LDA =204B5; LDX* SCP; C ODS; SKR CBL; R1

* WRITE TEMPORARY STORAGE
WTS    LDA TMPMAX; SKG =-1; R1
       ADD =1; LDB =4; C OCW
       LDX =WTS1; C WLB; LDA ='BSS '-40B6; C WOC
       TCL =0; LDA TMPMAX; ADD =1; C WNL; CR1 WCR
WTS1   DATA 'T:  ',INTVF,37777B,0

* OUTPUT USAGE TABLE
WSU    LDA SFLAG,2; SKA =EXTF; BRU WU1; R1
WU1    LDA SCHAIN,2; ETR =37777B; CLB; SKE =37777B; BRU WS2
       LDA SFLAG,2; RCY 12; LDA SNAME,2; LDX =-1; CR1 OCW

* OUTPUT ENTRY TABLE
WSE    LDA SFLAG,2; SKA =ENTF; BRU WE1; R1
WE1    LDA SCHAIN,2; SKA =SYMPTR; BRU WE3
WE2    C WLB; LDA ='EXT '; CLB; C WSW; C WCR; BRU WS1
WE3    LDX SCHAIN,2; LDA SFLAG,2; SKA =INTCF; BRU WE4
WE5    LDX* SCP; BRU WE2
WE4    LDA SCHAIN,2; LDX* SCP; STA SCHAIN,2; C AISL; BRU WE5

* OUTPUT LOCAL TABLE
WSL    LDA SFLAG,2; SKA =STRDF+INTVF+STRUCF
       SKA =ENTF+EXTF; R1; CLB; SKA =STRDF+INTVF
WS1    LDB =4B7
WS2    LDA SFLAG,2; RCY 12; LDA SCHAIN,2; LDX SNAME,2
       ETR =37777B; XXA; C OCW; LDX* SCP
       LDA SCHAIN,2; SKA =4B6; BRU *+2; R1
       C CGL; ADD ='.   '-':   '; LDX SVAL,2
       XAB; MRG =4000B; COPY BX,AB,XA
       ETR =37777B; XXA; CR1 OCW

* TERMINATE COMPILATION OF CURRENT PROGRAM
* (A),(B),(X) DESTROYED
$TCP   C WCR; C RYT
       LDA =-1; STA USF; LDA ELSTFL; XMA LSTFIL; STA USL
       LDX =AUS; C SST; LDX =AUL; C SLT
       C WCRI; LDA USL; STA LSTFIL
       LDX =ATS; C SST; LDX =AIS; C SST; M CBL,TMPORG
       LDA ATMPBF; LDB AETPBF; LDX =AWS; C SCT; C WTS
       LDA =201B5; MRG CBL; LDB =4; C OCW
       CLA; STA NLIT; STA NULIT; LDX =WLT; C SLT
       LDA =6B7; LDX =WSU; C SWT
       LDA =4B7; LDX =WSE; C SWT
       LDA =7B7; LDX =WSL; C SWT
       LDA =2B7; LDB =4; C OCW; C WCB; LDX CBP; C WBB
       LDA ='END '; C WOC; C WCR
       BRS 88; SUB ITIME; LRSH 23; DIV =60
       LDB =10; LDX =1; BRS 36; MSG TCPM1
       LDA NERRS; SKG =0; BRU TCP1
       LDB =10; LDX =1; BRS 36; MSG TCPM2
TCP1   LDA =3*TCPM0-1; LDB =137777B; STP FNP0; CLA
TCP2   CIO =1; GCI FNP0; HLT *; SKG ="9"; SKG ="0"-1; BRU TCP2
       CAX; EXU TCPT-"0",2
TCP3   LDB =10
TCP4   LDX =1; BRS 36; BRU TCP2+1
TCPT   BRU TCPT0; BRU TCPT1; LDA NLIT; LDA NULIT
       LDA NLIW; LDA NFAIW; LDA TMPMAX; R1
TCPT0  LDA CBL; LDB =8; BRU TCP4
TCPT1  LDA ESTS; SUB BSTS; BRU TCP3
TCPM1  ASC ' SECS  /'
TCPM2  ASC ' ERRS /'
TCPM0  ASC '0 CELLS   (A:1,L:2(3),I:4,5,T:6)7'

**********
* DRIVER *
**********

* SUBROUTINES FOR COMMAND PROCESSORS

* COLLECT INPUT FILE NAME OF TYPE (A)
CIFN   ZRO XRELM; STA FTT; LDB FNPP; LDA =2B7; CLX
       BRS 15; SBRR CIFN; COPY XA,BX; LRSH 18; ETR =47B
       SKE FTT; BRU CIFN1; CXA
CFN1   SKE ='.'; BRU *+2; BRU CFN2
       SKE =','; BRU *+2; BRU CFN2
       SKE =';'; SBRR CIFN; LDA =','
CFN2   LDX FNPP
       LDB 1,2; STB 2,2; EAX 2,2; STX FNPP
       MIN* CIFN; SBRR CIFN
CIFN1  MSG CIFERR; LDA FTT; LDX* CIFN; BRU 0,2
CIFERR ASC '$(WRONG TYPE) /'

* COLLECT OUTPUT FILE NAME OF TYPE (A)
COFN   ZRO XRELM; STA FTT; MRG =20B; LDB =1B6; LCY 18
       LDB FNPP; CLX; BRS 16; SBRR COFN; CBA; BRU CFN1

* TRY AGAIN FOR FILE NAME
CTRY1  ZRO XRELP; LDA =-2; ADM FNPP; SKR XRELM; NOP
CTRY   NOP XRELP; MSG CTRMSG; LDA FTT; LDX XRELM; BRU 0,2
CTRMSG ASC ' ? /'

* TYPE CARRIAGE RETURN
CCCR   ZRO XRELM; MSG CCMCR; SBRR CCCR
CCMCR  ASC '$/'

* COMMAND PROCESSOR

FNPPR  ZRO FNPT,4
FNPP0  ZRO FNP0
FNPP1  ZRO FNP1
FNPP2  ZRO FNP2

* COMPILE FILE <FILE>, BINARY TO <FILE>, LIST ON <FILE>.
CMDEM  ASC ' ?/'
CMDERR MSG CMDEM; LDX =-1; BRS 14; BRS 11
CCOMP  LDA =2; STA LSTFIL; STA BINFIL
       M FNPPR,FNPP; MSG CCMSRC
       LDA =3; SBRM CIFN; SBRM CTRY; SKE =14B; BRU CC1
       MSG CCMBIN; LDA =2; SBRM COFN; SBRM CTRY; SKE =14B; BRU CC2
       MSG CCMLST; LDA =3; SBRM COFN; SBRM CTRY; SKE =16B; SBRM CTRY1
       LDA =1301B4; LDB FNPP2; LDX =-1; BRS 16; BRU CMDERR; STA LSTFIL
CC2    LDA =1201B4; LDB FNPP1; LDX =-1; BRS 16; BRU CMDERR; STA BINFIL
CC1    LDA BINFIL; STA SBINFL; LDA LSTFIL; STA SLSTFL
       SKE =2; BRU *+2; LDA =1; STA ELSTFL
       LDA =-1; STA LSTUIV; STA LSTEXT; SBRM CCCR; BRU INIT
CCMSRC ASC '$SOURCE FILE: /'
CCMBIN ASC '$BINARY FILE: /'
CCMLST ASC '$LISTING FILE: /'

* COMMAND ROUTINE AND INITIALIZATION

$BSTS  DATA CBSTS              ORIGIN OF TEMP. STORAGE ABOVE FIXED TBLS
$CONTRL BRS 43; CBX; LRSH 18; LCY 18; BRS 44; CXB
       RCY 12; ETR =77B; STA DBYTE; CBA; ETR =77B; STA CBYTE
       LDA =FNSS; MUL =3B7; LSH 2; SUB =1; STA FNPT
       SBRM CCCR; LDP CONMSG; LDX =1; BRS 35
$CONTIN M =RUBOUT,201B; M =-1,RBTFLG
       LDA =2B6; BRS 78; BRU CCOMP

CONMSS ASC ' 2/24/69'
CONMSG DATA 3*CONMSS-1,3*CONMSS+7

* RUBOUT PROCESSOR
$RBTPRO SKN RBTFLG; BRU RBTXIT; STP RBTM
       LDA LSTFIL; SKE =2; BRU RBTXIT; MIN RBTFLG
       M =1,LSTFIL; STA SLSTFL; LDP RBTM; BRU RBTRET
RBTXIT LDX =-1; BRS 29; BRS 10

* PERMANENTLY DECLARED SYMBOLS

SYMBOL MACRO S
X      NCHR S(1)
       IF X>4
       TEXT 'S(1)'
       ELSE
       TEXT 'S(1)'
       DATA 0
       ENDF
       DATA S(1)
       ENDM
QEXST  SYMBOL SARRAY
       SYMBOL FTLERR
       SYMBOL FTYPE
       SYMBOL ERROR
       SYMBOL EARRAY
       SYMBOL BSTORG
       SYMBOL ESTORG
       SYMBOL NPL
       SYMBOL NPB
       SYMBOL NPG
       SYMBOL NPC
       SYMBOL NUP
       SYMBOL PADDR
       SYMBOL PCAT
       SYMBOL PM
       SYMBOL RECSTK
       SYMBOL RECUNS
       SYMBOL TOPRST
QEEXST EQU *

******************
* COMPILER STUFF *
******************


* INITIALIZATION OF COMPILER

* CLEAR SYMBOL TABLE AND CONSTANT HASH TABLE.  INITIALIZE SYMBOL
* STORAGE AREA
INIT   LDA =LSYMHT; CNA; AXC; STA ESYMHT,2; BRX *-1
       LDA =LCONHT; CNA; AXC; STA ECONHT,2; BRX *-1
       M BSTS,BSYT; M =37777B,ESYT; STA ESTS
* INSTALL RESERVED WORDS IN SYMBOL TABLE
       M =RWT,INT1; M =-1,INITF; MIN ESTS
IN2    LDA* INT1; SKE =-1; BRU *+2; BRU IN1; MIN INT1
       CAB; LDA* INT1; ETR =7777B; XAB
       LKS; HLT 0; MIN INT1; MIN INT1; BRU IN2
* RAN THROUGH RESERVED WORD TABLE. CHECK
IN1    LDA INT1; SKE =ERWT; HLT 0; M =0,INITF
* INITIALIZE EXTERNAL SYMBOLS
       M =QEXST,INT1
IN7    LDX INT1; LDA 1,2; LRSH 36; LDA 0,2; LKS; HLT 0
       LDA =EXTF; ADM SFLAG,2; LDA =3; ADM INT1
       LDA INT1; SKE =QEEXST; BRU IN7
       LDP INSRY; LKS; STX NARRAY
       LDA =ARRAYF; ADM SFLAG,2
       LDP INFTLE; LKS; STX NFTLER
       CLA; STA TADRC; STA NERRS; STA NLIW; STA NFAIW
* INITIALIZE TEMP STORAGE
       LDA =LTMPBF; CNA; CAX; LDA =-1; STA ETMPBF,2; BRX *-1; STA ETMPBF
       STA FRETL; STA IDENT; STA INCLEV
       M ATMPBF,TEMPTR; STA MAXTMP; STA TEMPB
IN9    M =MPL,MPP; C RCO
       M =0,FORSTK; STA IFSTK
       M ILSTATF,LSTATF; M PPFPX,PPFP2; M BSTS,PPBIP
       LDA =PPFS; MUL =3B7; LSH 2; SUB =1; STA PPFP0
       LDA =PPEFS; MUL =3B7; LSH 2; SUB =1; STA PPFP1
       M =CODEBF,ETS; GND; STX CODE; LDA ZINIT; APINS CODE,:,=1
       M =0,FTFLG; STA RFFLG
       LDP FNP0; SBRM RBLSET; BRU CMDERR; SBRM RBLK; MSG INM4
       BRU ISEQRT
ILSTATF DATA -1
INSRY  TEXT 'SARR  AY'
INFTLE TEXT 'FTLE  RR'
INM4   ASC '$/'



* FATAL ERROR POP
$DFERR STX CERRT1; CLA; SBRM PERRS; LDX CERRT1
       LDA FERRTB,2; LDX ELSTFL; LDB =-1; BRS 34
       MSG FERRM0; BRS 10
FERRTB DATA FERRM0,FERRM1,FERRM2,FERRM3,FERRM4,FERRM5
FERRM0 ASC '$ABORT$$/'
FERRM1 ASC '$SYMBOL TABLE OVERFLOW/'
FERRM2 ASC '$LITERAL TABLE OVERFLOW/'
FERRM3 ASC '$TEMPORARY LOCATION BUFFER OVERFLOW/'
FERRM4 ASC '$TOO MANY TEMPORARY LCTRS/'
FERRM5 ASC '$MAIN TABLE OVERFLOW/'



* PRINT STATEMENT IN ERROR, BREAKING IT (WITH LINE FEED) AT CHARACTER
* CORRESPONDING TO INPUT
PERRS  ZRO PERST1; STA PERST2
       LDA SLSTFL; SKE =2; BRU *+2; LDA =1
       STA ILSTFL; XMA LSTFIL; STA TLSTFL; SKN PERST2; BRU PERRS3
       MSG PERSM1,ILSTFL; LDA =-1; SBRM PP; NOP
PERRS3 MSG PERSM2,ILSTFL; SKN LSTLBL; BRU PERRS1
       LDA INLTCT; C PERLCS; LDA CBL; C PERLCB; BRU PERRS2
PERRS1 TCL =':'; LDX LSTLBL; C WSY; TCL =':'
       LDA INLTCT; SUB LBLLCT; C PERLCS
       LDX LSTLBL; C CGL; ADD ='.   '-':   '; C WSW
       LDA CBL; SUB SVAL,2; C PERLCB
PERRS2 MSG PERSM3,ILSTFL; M TLSTFL,LSTFIL; SBRR PERRS

PERLCS LDB =10; C PERLCN; TCL CHLPAR; R1
PERLCB LDB =8; C PERLCN; TCL CHRPAR; R1
PERLCN SKG =0; R1; TCL CHPLUS; LDX LSTFIL; BRS 36; R1

PERSM1 ASC '$* /'
PERSM2 ASC '$** /'
PERSM3 ASC '$/'


* ERROR POP
$DCERR STX CERRT1; M 0,CERRT2; MIN NERRS
       LDA =-1; SBRM PERRS; MSG CERM0,ELSTFL
       LDX CERRT1; LDA CERRT,2; LDX ELSTFL; LDB =-1; BRS 34
       MSG CERRM,ELSTFL; BRU RSEQ
CERRM  ASC '$/'
CERM0  ASC '*** /'



* COMPILER ERROR MESSAGE TABLE

$CERRT ZRO
       DATA CERM1,CERM2,CERM3,CERM4,CERM5,CERM6,CERM7,CERM8
       DATA CERM9,CERM10,CERM11,CERM12,CERM13,CERM14,CERM15
       DATA CERM16,CERM17,CERM18,CERM19,CERM20,CERM21,CERM22
       DATA CERM23,CERM24,CERM25,CERM26,CERM27,CERM28,CERM29
       DATA CERM30,CERM31,CERM32,CERM33,CERM34,CERM35,CERM36
       DATA CERM37,CERM38,CERM39,CERM40,CERM41,CERM42,CERM43
       DATA CERM44,CERM45,CERM46,CERM47,CERM48,CERM49,CERM50
       DATA CERM51,CERM52,CERM53

CERM1  ASC 'MALFORMED EXPRESSION/'
CERM2  ASC 'EXPECTED FIELD NAME/'
CERM3  ASC 'BAD CHARACTER OR LEXICAL ANALYSIS ERROR/'
CERM4  ASC 'DOUBLE-WORD FIELDS ARE NOT IMPLEMENTED/'
CERM5  ASC 'THE OPERAND OF A REFERENCE MUST BE AN ADDRESS/'
CERM6  ASC 'MISSING ]/'
CERM7  ASC 'EXTERNAL SYMBOL CANNOT BE INITIALIZED/'
CERM8  ASC 'OPERAND MISSING/'
CERM9  ASC 'MISSING ) IN EXPRESSION /'
CERM10 ASC 'MISSING ) IN DECLARATION/'
CERM11 ASC 'ATTEMPT TO REDECLARE NAME/'
CERM12 ASC 'MISSING NAME IN DECLARATION/'
CERM13 ASC 'A FIELD DEFINITION HAS THE FORM F(1:3,16)/'
CERM14 ASC '?/'
CERM15 ASC 'MISSING ) IN FUNCTION CALL/'
CERM16 ASC 'WRONG SYNTAX FOR SPECIAL FUNCTION/'
CERM17 ASC 'COLON MUST FOLLOW SYMBOL/'
CERM18 ASC 'ATTEMPT TO USE DECLARED SYMBOL AS LABEL/'
CERM19 ASC 'WRONG SYNTAX FOR FUNCTION/'
CERM20 ASC 'ATTEMPT TO USE DECLARED SYMBOL AS FUNCTION NAME/'
CERM21 ASC 'ATTEMPT TO CHANGE FORMER DECLARATION OF ARGUMENT/'
CERM22 ASC 'SYSTEM-GENERATED FUNCTION LINK ALREADY DECLARED/'
CERM23 ASC 'SHOULD HAVE STRING NAME/'
CERM24 ASC 'JUNK ON END/'
CERM25 ASC '[LIST OR NOLIST] [CODE,SOURCE OR BINARY]/'
CERM26 ASC 'I HAVE NO RETURN LINK/'
CERM27 ASC 'ONLY ONE IDENT PER PROGRAM/'
CERM28 ASC 'A CHARACTER CONSTANT SHOULD NOT EXCEED 3 CHARACTERS/'
CERM29 ASC 'LEGAL AFTER & ARE: 3 OCTAL DIGITS, A LETTER, OR ANOTHER &/'
CERM30 ASC 'WRONG SYNTAX FOR MACRO DEFINITION/'
CERM31 ASC 'THE ONLY LEGAL FORM IS <STRING NAME>←"<STRING>"/'
CERM32 ASC 'SHOULD BE   PARAMETER <NAME>←<INTEGER>,.../'
CERM33 ASC 'A FIXED ARRAY CANNOT BE PAGED/'
CERM34 ASC 'MUST STATE DIMENSION OF FIXED ARRAY/'
CERM35 ASC 'STRING MUST BE INITIALIZED WITH STRING CONSTANT/'
CERM36 ASC 'NO INITIALIZATION FOR NOT-FIXED ARRAY/'
CERM37 ASC 'EXPECTED INTEGER/'
CERM38 ASC 'TOO MANY EXPRESSIONS FOR ARRAY SIZE/'
CERM39 ASC 'FIELD MUST BE CONTAINED IN ONE WORD/'
CERM40 ASC 'BAD PARAMETERS FOR FIELD/'
CERM41 ASC 'ENDFOR UNMATCHED BY FOR/'
CERM42 ASC 'CANNOT EQUIVALENCE A FIXED OBJECT/'
CERM43 ASC 'ENDIF OR ELSEIF UNMATCHED BY IF/'
CERM44 ASC 'CANNOT ALLOCATE >1023 CHARACTERS TO FIXED STRING/'
CERM45 ASC 'MUST HAVE ADDRESS, NOT CONSTANT/'
CERM46 ASC 'NO MORE THAN THREE ARGUMENTS ALLOWED/'
CERM47 ASC 'MACRO CALL ERROR/'
CERM48 ASC 'NO MORE THAN 16 ARGUMENTS ALLOWED/'
CERM49 ASC 'MALFORMED NUMBER/'
CERM50 ASC 'TOO MANY ARGUMENTS FOR BUILT-IN FUNCTION/'
CERM51 ASC 'BUILT-IN FUNCTION SHOULD NOT HAVE GOTO/'
CERM52 ASC 'BUILT-IN FUNCTION MUST HAVE GOTO/'
CERM53 ASC 'EXPECTED STRING CONSTANT/'

       END

********************  QSPL-MISC  *****


*  (LOWER CASE)
       NOLIST EXT

* MISCELLANEOUS STUFF FOR QSPL COMPILER, ASSEMBLE WITH NARP
QM     IDENT


* TABLE BOUNDARIES

$ASYMHT DATA SYMHT
$AESMHT DATA ESYMHT
$ACONHT DATA CONHT
$AECNHT DATA ECONHT
$ATMPBF DATA TEMPBF
$AETPBF DATA ETMPBF




* SWITCH MAP

$GDRIV ZRO XGMAP; STP GMAPA; LDA DBYTE; BRU GMAP1
$GCOMP ZRO XGMAP; STP GMAPA; LDA CBYTE
GMAP1  STA GMAPT; BRS 43; RCY 12; ETR =@77B
       MRG GMAPT; LCY 12; BRS 44; LDP GMAPA; BRR XGMAP

* ENTRY TO COMPILER
$ISEQRT SBRM GCOMP; BRU SEQRET
$RSEQ  SBRM GCOMP; BRU SEQ

* ENTRIES FROM EXEC
$ENTRY0 BRU CONTRL
$ENTRY1 SBRM GDRIV; BRU CONTIN

* RUBOUT PROCESSOR
$RUBOUT ZRO RBTL; STP RBTA; STX RBTX
       BRS 43; SBRM GDRIV; BRU RBTPRO
$RBTRET BRS 44; LDP RBTA; LDX RBTX; BRU* RBTL




* NORMAL GET-INPUT-CHARACTER
       POPDEF NGIC
NGIC1  MIN CIP; LDB* WIP; EXU* CIP; ETR =377B; SKG =136B; BRR 0
       SKE =155B; BRU *+3; MIN INLCNT; BRR 0
       SKE CHEOF; BRR 0; SBRM ENDBLK; BRU NGIC1; BRR 0

* GET-INPUT-CHARACTER FOR LISTING OR ERROR
       POPDEF IGIC
IGIC1  MIN ICIP; LDB* IWIP; EXU* ICIP; ETR =377B
       SKE CHEOF; BRU IGIC2
       M =ISHTAB,ICIP; M =INBUF,IWIP; BRU IGIC1
IGIC2  SKE =152B; BRU *+2; BRR 0; SKE =155B; BRU IGIC3
       SKN IGICC; BRU *+2; BRR 0; MSG PERM1,ILSTFL; LDA =155B
IGIC3  STA IGICC; LDA PPEIP; SKE INPUT; BRU IGIC4
       LDA =152B; CIO ILSTFL; M =-1,INPUT
IGIC4  LDA IGICC; SKE =155B; CIO ILSTFL; BRR 0

NSHTAB HLT *; LCY 8; LCY 16; CBA; BRU *+1
       MIN WIP; M =NSHTAB+1,CIP; BRU NGIC1+1
ISHTAB HLT *; LCY 8; LCY 16; CBA; BRU *+1
       MIN IWIP; M =ISHTAB+1,ICIP; BRU IGIC1+1



* COMPILER ERROR ROUTINE
       POPDEF CERR
ECERR  EAX* 0; SBRM GDRIV; BRU DCERR



* FATAL ERROR. GENERATE MESSAGE, PRINT STATEMENT, ABORT
       POPDEF FERR
EFERR  EAX* 0; SBRM GDRIV; BRU DFERR


* PRINT STATEMENT
$PSTAT ZRO PERST1
       LDA LSTFIL; SKE =2; BRU *+2; SBRR PSTAT; STA ILSTFL
       MSG PERM2,ILSTFL; M =-1,INPUT; SBRM PP; NOP
       SKN COMFLG; BRU *+2; SBRR PSTAT
       MSG PERM3,ILSTFL; SBRR PSTAT

PERM1  ASC '$* /'
PERM2  ASC '* /'
PERM3  ASC '$/'




* LOOK UP SYMBOL IN AB. RETURN ADDRESS OF INITIALIZED SYMBOL TABLE ENTRY 
* IN X WITH SKIP IF NEW, OF OLD CELL IF OLD. HT ADDRESS IN A ALSO
       POPDEF LKS
* FIRST HASH SYMBOL
ELKS   STA LKST2; STB LKST3
       EOR =11111111B; STA LKST1; CBA; EOR =11111111B; MUL LKST1
       LRSH 12; CBX; LSH NSPSHT; CLA; LSH PSYMHT
* GOT HASH TABLE ADDRESS TO START AT IN A. SAVE 10 EXTRA BIT
* OF HASH CODE
       SUB =LSYMHT; COPY XA,AX,B; LSH 14; MRG =4B4; STA LKST1; STB LKST4
       LDB =77740000B
LKS4   LDA ESYMHT,2; SKM LKST1; BRU LKS1
* EXTRA HASH CODE BITS MATCH
       STX LKST5; ETR =37777B; CAX; LDA SNAME,2; SKE LKST2; BRU LKS2
       LDA SFLAG,2; ETR =7777B; SKE LKST3; BRU LKS2
* AND SYMBOL MATCHES. DONE
       LDA LKST5; BRR 0
* SYMBOL DOES NOT MATCH
LKS2   LDX LKST5; BRU LKS3
* THIS HT ENTRY IS NOT GOOD, UNLESS IT IS NULL
LKS1   SKE =0; BRU LKS3
* IT IS NULL. MAKE NEW ENTRY HERE
       MIN 0; SKN INITF; BRU LKS6
       LDA INT1; SUB =1; CAB; MRG LKST1; STA ESYMHT,2
       COPY BX,XA; BRR 0
LKS6   CXB; LDA =-4; ADM PPOVC
       GSTS =4; MRG LKST1; XXB; STA ESYMHT,2
       COPY XA,BX; LDB LKST2; STB SNAME,2; LDB LKST3; STB SFLAG,2
       LDB =37777B; STB SCHAIN,2; CLB; STB SVAL,2; BRR 0
* HT ENTRY NO GOOD
LKS3   BRX LKS4
* RAN OFF END OF HASH TABLE
       LDA =LSYMHT; CNA; CAX; SKN LKST4; SKR LKST4; BRU *+2; BRU LKS4
* RAN OFF END SECOND TIME. SYMBOL TABLE FULL
LKS5   FERR 1




* MAKE CONSTANT. CALL WITH INTEGER CONSTANT IN A. LOOK IT UP IN CONSTANT
* HASH TABLE AND RETURN VALUE OF SYMBOL TABLE ENTRY, CREATING A
* NEW ONE IF NECESSARY. SKIP ON NEW ENTRY. ADDRESS RETURNED IN X
       POPDEF MCI
EMCI   LDA* 0
       POPDEF MCON
EMCON  LDX =INTCF
MCON6  CLB
MCON7  STB MCONT6; STX MCONT5; STA MCONT1
       EOR =10101010B; EOR MCONT6; STA MCONT2; MUL MCONT2
       LRSH 12; CBX; LSH NSPCHT; CLA; LSH PCONHT
       SUB =LCONHT; COPY XA,AX,B; LSH 14; MRG =4B4; STA MCONT2; STB MCONT3
       LDB =77740000B
MCON4  LDA ECONHT,2; SKM MCONT2; BRU MCON1
* EXTRA HASH CODE BITS MATCH
       STX MCONT4; ETR =37777B; CAX; LDA SVAL,2; SKE MCONT1; BRU MCON2
       LDA SNAME,2; SKE MCONT6; BRU MCON2
* AND CONSTANT MATCHES. DONE IF IT IS PROPER TYPE
       LDA SFLAG,2; ETR =INTCF+FLTCF+REFF; SKE MCONT5; BRU MCON2
       CXA; BRR 0
MCON2  LDX MCONT4; BRU MCON3
* THIS HT ENTRY IS NO GOOD UNLESS IT IS NULL
MCON1  SKE =0; BRU MCON3
* IS. MAKE NEW ENTRY HERE
       CXB; LDA =-4; ADM PPOVC
       GSTS =4; XXB; MRG MCONT2; STA ECONHT,2; XXB
       M MCONT5,/SFLAG; M MCONT6,/SNAME
       M =37777B,/SCHAIN; M MCONT1,/SVAL; CXA; BRR 0
* HT ENTRY DEFINITELY NO GOOD
MCON3  BRX MCON4; LDA =LCONHT; CNA; CAX; SKN MCONT3
       SKR MCONT3; BRU *+2; BRU MCON4
* RAN OFF END OF HT TWICE. IT IS FULL
MCON5  FERR 2



* MCON FOR CONSTANT WHICH IS POINTER TO S.T. (REFF ON)
       POPDEF MSTCON
EMSTCN LDX =INTCF+REFF; BRU MCON6
* MCON FOR FLOATING POINT CONSTANT
       POPDEF MFCON
EMFCON LDX =FLTCF; BRU MCON7






* SET UP TO READ FROM FILE WITH NAME (AB)
* NOSKIP IF NONEXISTENT OR NOT SYMBOLIC
$RBLSET ZRO RBST1; STP RBST4; LDA =1B7; LDX =-1; LDB =RBST4
       BRS 15; SBRR RBLSET; STA INFIL
       CXA; ETR =7B6; SKE =3B6; BRU RBLS1
       M =0,INWCNT; STA IWIP; M =-1,LSTLBL; M =1,INLCNT
       LDA RBST5; SUB RBST4; ADD =5; MUL =12525253B
       ADD PPBIP; ADD =11; SKG ESTS; BRU *+2; FERR 5
       SUB =5; CAX; XMA PPBIP; MUL =3; LSH 23
       SUB =1; STA RBST2; STA RBST3
       LDA RBST5; SUB RBST4; STA -7,2; MIN* RBLSET
RBLS2  GCI RBST4; SBRR RBLSET; WCI RBST2; BRU RBLS2
RBLS1  LDA INFIL; BRS 20; SBRR RBLSET


* PUSH STATE OF INPUT
$INPUSH ZRO INPT1; STP INPT2; LDX PPBIP
       M WIP,/-6; M CIP,/-5; M INWCNT,/-4
       M INLCNT,/-3; M LSTLBL,/-2; M LBLLCT,/-1
       LDP INPT2; SBRM RBLSET; BRU INP1
       MIN INCLEV; SBRM RBLK; SBRR INPUSH
INP1   MSG INPM1; LDP INPT2; LDX =1; BRS 35
       MSG INPM2; BRU INPOP1
INPM1  ASC '$COULD NOT OPEN FILE /'
INPM2  ASC '$/'


* POP STATE OF INPUT
INPOP  ZRO INPT1; SKR INCLEV; NOP; LDX PPBIP; LDA -7,2
       ADD =23; MUL =12525253B; CNA; ADD PPBIP; STA PPBIP
       SUB =6; STA INPT2; CAX; LDA -1,2; STA INPT3
       ADD =5; MUL =12525253B; CNA; ADD INPT2; STA PPBIP
       MUL =3; LSH 23; SUB =1; STA INPT2; ADM INPT3
       LDP INPT2; SBRM RBLSET; BRU INPOP4
INPOP1 LDX PPBIP; M =0,IWIP; M /-4,INWCNT
       M /-3,INLCNT; M /-2,LSTLBL; M /-1,LBLLCT
       LDA INWCNT; SUB =1; RSH 23; DIV =LINBUF
       SKG =0; BRU INPOP2; MUL =LINBUF; LSH 23; SUB =LINBUF
       LDB =10001B; LDX INFIL; BRS 144; STA INWCNT; SBRM RBLK
INPOP3 SBRM RBLK; LDX PPBIP; M /-6,WIP; M /-5,CIP; SBRR INPOP
INPOP2 CLA; LDB =10001B; LDX INFIL; BRS 144; STA INWCNT; BRU INPOP3
INPOP4 MSG INPM3; BRS 10
INPM3  ASC '$COULD NOT REOPEN OLD INPUT AFTER INCLUDE$ABORT$$$/'


* READ BLOCK FROM INPUT FILE AND INITIALIZE WIP AND CIP APPRO-
*PRIATELY. SAVE OLD BLOCK FROM IWIP TO END, UP TO 50 WORDS
$RBLK  ZRO RBLT1
       LDA IWIP; SKG =0; BRU RBL6; CNA; ADD =LINBUF; ADD =INBUF; ADD =2
       SKG =48; BRU *+2; LDA =48; CAX
       ADD IWIP; MRG =2B7; STA RBLT2; CXA; CNA; XXA; ADD =SINBUF
       MRG =2B7; STA RBLT3; LDA* RBLT2; STA* RBLT3; BRX *-2
       M =SINBUF,IWIP; M =137B*2B5+137B*4B2+137B,←RBLT3
RBL6   LDA =LINBUF; LDX =INBUF; BIO INFIL; BRU *+2; BRU RBL1
* ABNORMAL TERMINATION
       STA RBLT2; LDA INFIL; SKA =4B5; BRU RBL2
* END OF FILE
       LDA =137B*200000B+137B*400B+137B; STA* RBLT2; MIN RBLT2
       STA* RBLT2; LDA =-1; BRU RBL4
* I-O ERROR. NOTE AND ABORT
RBL2   MSG RBLM1
RBL5   LDA RBLT2; SUB =INBUF; ADD =1; ADD INWCNT
       LDB =10; LDX =1; BRS 36; MSG RBLM3; BRS 10
* NORMAL TERMINATION OF BIO
RBL1   LDA =137B*200000B+137B*400B+137B; STA EINBUF
       LDA =LINBUF; ADM INWCNT; CLA
RBL4   STA ENDIFL; M =INBUF,WIP; M =NSHTAB,CIP
       M =2,ECRCNT
       SBRR RBLK

RBLM1  ASC '$I-O ERROR AT INPUT WORD /'
RBLM3  ASC '$ABORT$$$/'



* GIC ENCOUNTERS END OF INPUT. CALL RBLK. NOSKIP RETURN IF RBLK CALLED,
* SKIP IF THIS ROUTINE SUPPLIES CODE
$ENDBLK ZRO ENDBT1
       SKN ENDIFL; BRU ENDB1
* END OF FILE. DONE. RETURN EXTRA CRS FIRST
       SKR ECRCNT; BRU ENDB3
       SKN INCLEV; BRU ENDB7; MSG ENDBM1; BRU ENDB2
ENDB7  LDA INFIL; BRS 20; SBRM INPOP
       C WCR; MSG ENDBM4,LSTFIL; BRU SEQ
$ENDB2 SKN FTFLG; BRU *+2; BRU ENDB4
       GND; STX CODE; LDA ZBRS; MRG =10; APINS CODE,:,=1
       LDA* CODE; C OLS
ENDB4  LDA IFSTK; SKG =0; BRU ENDB5; MSG ENDBM2
ENDB5  LDA FORSTK; SKG =0; BRU ENDB6; MSG ENDBM3
ENDB6  SBRM GDRIV; C TCP; LDA =137B; CIO LSTFIL
       LDA =27657537B; WIO BINFIL; WIO BINFIL; BRS 10
ENDB1  SBRM RBLK; SBRR ENDBLK
ENDB3  LDB =152B; CLA; SKE ECRCNT; LDB =155B; MIN* ENDBLK; SBRR ENDBLK

ENDBM1 ASC '$* END OF FILE$$/'
ENDBM2 ASC '$* UNFINISHED IFS$/'
ENDBM3 ASC '$* UNFINISHED FORS$/'
ENDBM4 ASC '$**END INCLUDE$$/'





* PREPROCESSOR. SCANS THE INPUT FROM THE POINT SPECIFIED BY WORD AND CHARACTER
* POINTERS WIP AND CIP TO THE NEXT SEMICOLON.  PRODUCES
* AN ENCODED VERSION OF THE SOURCE STATEMENT IN EIBUF,
* SKIP UNLESS COMMENT LINE (* TO NEXT CR), IN WHICH CASE RETURN
* UNCHANGED
$PP    ZRO PPT1; SKE =0; BRU PP49; M VNGIC,VGIC
       LDA CIP; ADD =ISHTAB-NSHTAB; STA ICIP
       M WIP,IWIP; BRU PP0
PP49   M VIGIC,VGIC; M =-1,IGICC
PP0    M =-1,PPMAC; M PPBIP,PPEIP
       CNA; ADD ESTS; SUB =5; STA PPOVC
PP43   GIC; SKE CHSTAR; BRU PP42
* COMMENT LINE. SKIP CHARACTERS UP TO NEXT CR
PP40   GIC; SKE =155B; BRU PP40; SBRR PP
PP42   SKG =0; BRU PP43; SKG =77B; BRU PP19
       SKE CHMBLK; BRU PP47; GIC; BRU PP43
PP47   SKE =155B; BRU PP43; LDA VGIC; SKE VNGIC; BRU PP43
       MIN INLTCT; BRU PP43
* GET NEXT OBJECT
PP6    LDA PPNC
PP19   SKG =72B; SKG =40B; BRU PP1
* LETTER. COLLECT SYMBOL
       MUL =4B5; STB SYMBUF; STA SYMBF1; M =PPITAB-1,PPT2
PP3    MIN PPT2
PP3A   GIC; SKG =72B; SKG =40B; BRU PP2
PP4    CAB; EXU* PPT2; ADM SYMBUF; BRU PP3
PP2    SKG =31B; SKG =17B; BRU PP3B; BRU PP4
PPITAB LSH 12; LSH 6; NOP; BRU PP4A; BRU PP4B; BRU PP3A
PP4A   LSH 6
PP4B   ADM SYMBF1; BRU PP3
* FOUND NON-ALPHAMERIC CHARACTER
PP3B   STA PPNC
* LOOK UP SYMBOL
       LDA SYMBUF; LDB SYMBF1; LKS; NOP
* IS IT RESERVED WORD
       LDA SFLAG,2; SKA =RWF; BRU PP5; CXA
* GOT OBJECT IN A. STORE AND LOOP
PP7    STA* PPEIP
PP21   MIN PPEIP; SKR PPOVC; BRU PP6; FERR 5
* RESERVED WORD
PP5    LDA SCHAIN,2; SKA =4B7; BRU PP50; BRU PP7
* MACRO.  NOTE LOCATION IF FIRST IN STATEMENT
PP50   CXA; SKN PPMAC; BRU PP7; LDX PPEIP; STX PPMAC; BRU PP7
* INITIAL CHARACTER NOT LETTER
PP1    SKG =31B; SKG =17B; BRU PP8
* INITIAL CHARACTER IS DIGIT. COLLECT NUMBER IN DECIMAL AND OCTAL
       SUB =20B; STA PPT2; STA PPT3; STA PPFS; M =PPFS,PPT4
PP10   GIC; SKG =31B; SKG =17B; BRU PP9
       SUB =20B; CAX; XMA PPT2; MUL =10; LSH 23; ADM PPT2
       COPY XA,B; XMA PPT3; LSH 3; ADM PPT3
       LDA PPT4; SKE =PPEFS; MIN PPT4; STX* PPT4; BRU PP10
* FOUND NON-NUMERIC CHARACTER. END OF NUMBER IF IT IS NOT B OR D
PP9    SKE CHB; BRU PP11
* B. NUMBER IS OCTAL.  LOOK FOR SCALE (ONE DIGIT)
       GIC; SKG =31B; SKG =17B; BRU PP12
* FOUND IT
       SUB =20B; MUL =3; LSH 23; COPY AX,B; LDA PPT3; LSH 0,2; BRU PP13
* NO OCTAL SCALE
PP12   STA PPNC; MCI PPT3; BRU PP7
PP11   SKE CHD; BRU PP15
* D. NUMBER IS DECIMAL. LOOK FOR SCALE
       GIC; SKG =31B; SKG =17B; BRU PP14
       SKG =20B; BRU PP35; SUB =20B; CNA; CAX
       LDA PPT2; MUL =10; LSH 23; BRX *-2
PP13   STA PPT2
PP35   GIC
PP14   STA PPNC; MCI PPT2; BRU PP7
PP15   SKE CHDOT; BRU *+2; BRU PF1; SKE CHE; BRU PP14

* FLOATING POINT NUMBER.  START BY WRITING INTEGER ONTO STRING
PF1    STA PPNC; LDX =PPFS; M PPFP0,PPFP; STA PPFPI
PF2    LDA 0,2; MRG =20B; WCH PPFP
       CXA; EAX 1,2; SKE PPT4; BRU PF2
       LDA PPNC; WCH PPFP; SKE CHDOT; BRU PF4
* COLLECT DIGITS BEYOND DECIMAL POINT
PF3    GIC
PF3A   WCH PPFP; SKG =17B; BRU PF4; SKG =31B; BRU PF3
PF4    SKE CHE; BRU PF5; GIC; WCH PPFP
* COLLECT EXPONENT OF 10
       SKE CHPLUS; BRU *+2; BRU PF6; SKE CHMNS; BRU PF7
PF6    GIC; WCH PPFP
PF7    SKG =17B; BRU PF5; SKG =31B; BRU PF6
PF5    STA PPNC; SKR PPFP
* ATTEMPT TO CONVERT NUMBER
       CLEAR; SIC PPFPI; CERR 49; MFCON; BRU PP7
* STRING OVERFLOW
$PPFPX BRU *+1; CERR 49

* INITIAL CHARACTER IS NOT LETTER OR DIGIT. LOOK IT UP IN SC TABLE
PP8    SKG =77B; BRU PP17
* CONTROL CHARACTER, IGNORE
PP44   SKE CHMBLK; BRU PP20; GIC
PP20   GIC; BRU PP19
* IGNORE BLANK
PP17   SKG =0; BRU PP20
* SPECIAL CHARACTER >0,<100B
       CAX; LDA SCTAB,2; SKE =-1; BRU *+2; BRU PP18
* CHECK FOR SPECIAL ACTION
       STA* PPEIP; SKE ISEMI; BRU *+2; BRU PP41
       SKE ISQT; BRU PP22
* CODE TO PROCESS CHARACTER CONSTANT
       M =7,SCFLG; M =0,PPT2; STA GNCT3; M =3,PPT4
PP36   SBRM GNC; BRU PP35; RSH 8; LDA PPT2; LSH 8; STA PPT2; SKR PPT4
       BRU PP36; CERR 28
PP22   SKE IDQT; BRU PP23
* CODE TO PROCESS STRING CONSTANT
       M =2,SCFLG; M ISC,←PPEIP; MIN PPEIP; M PPEIP,PPT5
       M =0,PPT4; STA GNCT3; SKR PPOVC; BRU PP39
PP48   CERR 46
PP39   M =0,PPT2; SBRM GNC; BRU PP37; LSH 16; ADM PPT2
       MIN PPT4; SBRM GNC; BRU PP38; LSH 8; ADM PPT2; MIN PPT4
       SBRM GNC; BRU PP38; ADM PPT2; MIN PPT4
       LDA PPT2; MIN PPEIP; STA* PPEIP
       SKR PPOVC; BRU PP39; BRU PP48
PP38   LDA PPT2; MIN PPEIP; STA* PPEIP; SKR PPOVC; BRU *+2; BRU PP48
PP37   M PPT4,←PPT5; GIC; STA PPNC; BRU PP21
PP23   GIC; STA PPNC; LDA* PPEIP
       SKE IGT; BRU PP24; LDA PPNC; SKE CHEQL; BRU PP21
       LDA IGE
PP25   STA* PPEIP; GIC; STA PPNC; BRU PP21
PP24   SKE ILT; BRU PP28; LDA PPNC
       SKE CHEQL; BRU PP21; LDA ILE; BRU PP25
PP28   SKE IDOT; BRU PP21; LDA PPNC
       SKG =31B; SKG =17B; BRU PP21; M PPFP0,PPFP; STA PPFPI
       LDA CHDOT; WCH PPFP; LDA PPNC; BRU PF3A
PP41   MIN PPEIP; SKN PPMAC; BRU PX1 (MACROS); MIN* PP; SBRR PP
* ERROR DETECTED BY PREPROCESSOR
PP18   M PPEIP,INPUT
PP18A  GIC; SKE CHSEMI; BRU PP18A; CERR 3



* ROUTINE TO COLLECT CHARACTER IN STRING OR CHARACTER CONSTANT
GNC    ZRO GNCT1
       CLA; SKR GNCT3; BRU *+2
       GIC; SKE =6; BRU GNC1
* AMPERSAND
       GIC; SKG =27B; SKG =17B; BRU GNC2
* OCTAL DIGIT. EXPECT TWO MORE
       CLB; LSH 6; STA GNCT2; GIC; SKG =27B; SKG =17B; CERR 29
       CLB; LSH 3; ADM GNCT2; GIC; SKG =27B; SKG =17B; CERR 29
       ADD GNCT2
* CONVERT ASCII CODES TO OCTAL DIGITS
       SUB ='   0'*111B
GNC3   ETR =377B; MIN* GNC; CLB; SBRR GNC
GNC2   SKG =72B; SKG =40B; BRU GNC4
       MRG =100B; BRU GNC3
GNC4   BRU GNC3
GNC1   SKE =135B; BRU GNC6
* MULTIPLE BLANKS
       GIC; STA GNCT3; BRU GNC+1
GNC6   SKE SCFLG; BRU GNC3; SBRR GNC




* MACRO PROCESSOR.  SCAN FOR NEXT MACRO NAME
PX1    LDX PPMAC
PX2    LDA 0,2; SKG ESYT; SKG BSYT; BRU PX3
       COPY XB,AX; LDA SFLAG,2; SKA =RWF; BRU PX4
PX5    CBX
PX6    EAX 1,2; BRU PX2
PX3    SKE ISEMI; BRU PX7
PX26   MIN* PP; SBRR PP
PX7    SKE ISC; BRU PX6; STX PPT2; LDA 1,2
       ADD =8; MUL =12525253B; ADD PPT2; CAX; BRU PX2
PX4    LDA SCHAIN,2; SKA =2B7; SKN SCHAIN,2; BRU PX5
* GOT ONE, COLLECT ARGUMENTS
       CBX; STX PPMAC; LDB =-1; STB PPLEV
       RCY 15; ETR =177B; STA PPARGS
       M PPEIP,PPABP; STA PPAP
       LDA PPARGS; SKG =0; BRU PX24
       SKG PPOVC; BRU *+2; FERR 5
       EAX 1,2; LDA 0,2; SKE ILPAR; BRU PX0
       SKR PPARGS; LDA PPARGS; SKE =0; BRU PX8
       EAX 1,2; LDA 0,2; SKE IRPAR; CERR 47; BRU PX24
PX8    STX* PPAP; EAX 1,2; MIN PPAP
       SKR PPARGS; BRU PX9; CERR 47
PX9    LDA 0,2; SKE ILPAR; BRU PX10; MIN PPLEV
PX11   EAX 1,2; BRU PX9
PX10   SKE ISC; BRU PX12
* STRING CONSTANT
       LDA 1,2; ADD =8; MUL =12525253B; STA PPT2
       CXA; ADD PPT2; CAX; BRU PX9
* NOT ( OR SC.  CHECK SEMICOLON, THEN COMMA AND )
PX12   SKE ISEMI; BRU PX14
PX0    CERR 47
PX14   SKE IRPAR; BRU PX16; SKN PPLEV; BRU PX17
       LDA PPARGS; SKE =0; BRU PX0; BRU PX24
PX17   SKR PPLEV; NOP; BRU PX11
PX16   SKN PPLEV; BRU PX11; SKE ICOMMA; BRU PX11; BRU PX8
* FINISHED WITH ARGUMENTS.  COPY DEFINITION INTO EIBUF
PX24   STX* PPAP; MIN PPAP
PX15   M PPEIP,←PPAP; MIN PPAP; M PPAP,PPEIP
       CNA; ADD ESTS; SUB =5; STA PPOVC
       LDX* PPMAC; LDA SCHAIN,2; ETR =37777B; STA PPT2
PX18   SKR PPT2; LDA* PPT2; STA* PPEIP; SKG =-1; BRU PX19
       SKE ISEMI; BRU PX20
       LDA PPAP; SUB PPABP; SUB =2; SBRM CPYARG; BRU PX13
PX19   EOR =-1; SBRM CPYARG
PX21   BRU PX18
PX20   MIN PPEIP; SKE ISC; BRU PX23
* STRING CONSTANT
       LDX PPT2; LDA -1,2; ADD =5; MUL =12525253B; STA PPT3
PX22   SKR PPT2; M ←PPT2,←PPEIP; MIN PPEIP
       SKR PPOVC; BRU *+2; FERR 5
       SKR PPT3; BRU PX22; BRU PX18
PX23   SKR PPOVC; BRU PX21; FERR 5
* COPY EXPANDED LINE BACK
PX13   LDA PPEIP; MRG =2B7; STA PPT3
       LDA PPAP; SUB PPEIP; COPY AX,N
       ADD PPMAC; STA PPEIP; MRG =2B7; STA PPT2
PX25   LDA* PPT3; STA* PPT2; BRX PX25
       LDA ESTS; SUB PPEIP; SUB =5; STA PPOVC; BRU PX1

* COPY ARGUMENT (A) INTO EIBUF
CPYARG ZRO PPT3; ADD PPABP; CAX
       LDA 0,2; ADD =1; STA PPT4
       SUB 1,2; COPY AX,AB; ADD PPOVC
       STA PPOVC; SKG =-1; FERR 5
       SKB =-1; BRU *+2; SBRR CPYARG
CPYA1  M ←PPT4,←PPEIP; MIN PPT4; MIN PPEIP
       BRX CPYA1; SBRR CPYARG





* BASIC COMPILER SERVICE ROUTINES


       POPDEF CALL
       BRU* 0



* GET TEMPORARY STORAGE IN MAIN TABLE WHEN CODEBF FULL.
* CALL WITH (ETS)+BLOCK LENGTH IN A, RETURN ADDRESS IN A,
* PRESERVE BX, ALWAYS SKIP (FOR GTS MACRO)
$GTS   ZRO GTST1; SUB ETS; ADD PPEIP; MIN GTST1
       SKG ESTS; BRU *+2; FERR 5; XMA PPEIP; BRR GTST1



* CONTROL OF TEMPORARY STORAGE LOCATIONS
* WE MAINTAIN A TABLE OF THE SYMBOL TABLE ADDRESSES OF THE
* TEMPORARIES ASSIGNED SO FAR. TEMPTR POINTS TO THE CURRENTLY
* ACTIVE CELL IN THIS TABLE, WHICH IS INITIALIZED TO -1
* WHEN A REQUEST FOR A TEMPORARY CAUSES TEMPTR TO POINT TO -1, A NEW
* SYMBOL TABLE CELL IS ASSIGNED.  WHENEVER A NEW TEMPORARY IS SUPPLIED, IT
* IS PROPERLY INITIALIZED.  THIS POP RETURNS ST ADDRESS IN A, SAVES X
* MAXTMP HOLDS THE ADDRESS OF THE LARGEST TEMPORARY ASSIGNED
* SO FAR
       POPDEF GTEMP
EGTEMP MIN TEMPTR; SKN* TEMPTR; BRU GTEMP1
* NEED TO ASSIGN NEW LOCATION
       STX GTMPT1; LDA TEMPTR; SKE AETPBF; BRU GTEMP2
* OVERFLOWED BUFFER
       FERR 3
GTEMP2 GSTS =4; STX* TEMPTR; MIN MAXTMP
       LDA MAXTMP; SUB ATMPBF; STA SNAME,2
       M =SYMTMP+37777B,/SCHAIN; CLA; STA SVAL,2; STA SFLAG,2
       CXA; ETR =37777B; LDX GTMPT1; BRR 0
* LOCATION AVAILABLE
GTEMP1 LDA* TEMPTR; BRR 0


* GET TRANSFER LOCATION. THESE ARE FLAGGED APPROPRIATELY AND IDENTIFIED 
* BY NUMBERS (WHICH START AT 1) IN SFLAG. RETURN ADDRESS IN A AND X
       POPDEF GTADR
EGTADR SKN PTADRF; BRU GTADR1; GSTS =4; BRU GTADR2
GTADR1 GTS =4
GTADR2 MIN TADRC; M TADRC,/SFLAG; M =SYMTRA+37777B,/SCHAIN
       M =0,/SVAL; STA SNAME,2; CXA; BRR 0






* POP TO APPEND CONTENTS OF AB TO CODE IN DESCRIPTOR POINTED TO BY ADDRESS
* RETURN DESCRIPTOR ADDRESS IN X
       POPDEF APPINS
EAPPINS STA APPT1; GTS =4; M APPT1,/2; STB 3,2
       COPY XA,XB; LDX* 0; SKN CPTR,2; BRU APPI1
* NO CODE IN DESCRIPTOR NOW
APPI2  STA CPTR,2; COPY AX,XB; MRG =4B7; STA 0,2; STA 1,2; CBX; BRR 0
* HAVE CODE ALREADY. INSERT NEW CELL
APPI1  LDX CPTR,2; MRG =4B7; XMA 1,2; CBX; ETR =37777B
       STA 1,2; COPY AX,BA; XMA 0,2; CBX; STA 0,2
       LDX* 0; BRR 0


* POP TO APPEND CONTENTS OF AB AT FRONT OF CODE IN DESCRIPTOR
* POINTED TO BY ADDRESS.  RETURN DESCRIPTOR ADDRESS IN X
       POPDEF APPIF
EAPPIF STA APPT1; GTS =4; M APPT1,/2; STB 3,2
       COPY XA,XB; LDX* 0; SKN CPTR,2; BRU APPF1
* NO CODE IN DESCRIPTOR NOW
       BRU APPI2
* HAVE CODE ALREADY. PREFIX NEW CELL
APPF1  XMA CPTR,2; CAX; LDA 1,2
       COPY AX,BA; MRG =4B7; XMA 0,2
       CBX; ETR =37777B; STA 0,2; COPY AX,BA; XMA 1,2
       CBX; STA 1,2; LDX* 0; BRR 0



* GET NEW DESCRIPTOR. LEAVE ADDRESS IN X
       POPDEF GND
EGND   GTS =4; CLA; STA CFLAG,2; LDA =-1
       STA CPTR,2; STA SPTR,2; STA ADDR,2; BRR 0



* FORCE VALUE FROM EXPRESSION ADDRESSED BY POP. LEAVE DESCRIPTOR
* ADDRESS IN X
       POPDEF FVAL
EFVAL  LDX* 0; LDA CFLAG,2; SKA =FXFER+TXFER; BRU FVAL3
       BRR 0
* IT IS A TRANSFER EXPRESSION
FVAL3  M 0,FVLT10
       STX FVALT2; LDA ADDR,2; ETR =37777B; STA FVALT9
       MCI =1; STX FVLT11
       LDX FVALT2; LDA CFLAG,2
       SKA =FXFER; BRU FVAL1
* TRUE TRANSFER
       LDX ZCLA; LDA ZLDA; MRG FVLT11; ABC; BRU FVAL2
* FALSE TRANSFER
FVAL1  LDA ZLDA; MRG FVLT11; CAX; LDB ZCLA; LDA =1
FVAL2  STX FVALT5; STB FVALT7; STA FVALT8; EOR =1; STA FVALT6
       APINS FVALT2,FVALT5,FVALT6
       GTADR; STA FVALT3; MRG ZBRU; APINS FVALT2,:,=0
       APINS FVALT2,FVALT9,=2
       APINS FVALT2,FVALT7,FVALT8
       APINS FVALT2,FVALT3,=2
FVAL4  LDX FVALT2; M =-1,/ADDR; LDA CFLAG,2
       ETR =77777777B-TXFER-FXFER-STRNG; MRG =CLOBA; STA CFLAG,2
       BRR FVLT10



* FORCE VALUE UNLESS STRING
       POPDEF FVALNO
EFVALNO BRU EFVAL





* FORCE LOAD. GUARANTEE RESULT IN A FROM CODE ADDRESSED BY POP
* LEAVE ADDRESS OF DESCRIPTOR IN X
       POPDEF FLOAD
EFLOAD LDX* 0; STX FLDT2; LDA 0; STA FLDT1; SKN ADDR,2; BRU FLOAD1
       FVAL FLDT2; BRR FLDT1
FLOAD1 APIXA FLDT2,ZLDA; BRR FLDT1



* FORCE SIMPLE ADDRESS. RETURN DESCRIPTOR ADDRESS IN X, ADDR IN A
       POPDEF FADDR
EFADDR M 0,FADRT1; FVALNO* FADRT1
       SKN ADDR,2; BRU FADR1; STX FADRT2
FADR2  GTEMP; STA ADDR,2; MRG ZSTA; APINS FADRT2,:,=0; LDA CFLAG,2
       MRG =CLOBA; STA CFLAG,2; LDA ADDR,2; BRR FADRT1
FADR1  LDA ADDR,2; SKA =2004B4; BRU *+2; BRR FADRT1; STX FADRT2
       MRG ZLDA; APINS FADRT2,:,=0; BRU FADR2


* POP TO APPEND CODE ADDRESSED BY X TO CODE ADDRESSED BY POP
* RETURN ADDRESS OF DESCRIPTOR IN X
       POPDEF APPCOD
EAPPCOD SKN CPTR,2; BRU APPC2; LDA CFLAG,2; LDX* 0
APPC3  MRG CFLAG,2; ETR =NCS; STA CFLAG,2; BRR 0
* SECOND ARGUMENT HAS CODE. IF NOT, NOTHING TO DO
APPC2  CXB; LDX* 0; SKN CPTR,2; BRU APPC1
* FIRST DOES NOT
       XXB
       LDA CPTR,2; LDX CFLAG,2; COPY XA,BX,AB; STB CPTR,2; BRU APPC3
* BOTH HAVE CODE
APPC1  LDA CFLAG,2; XXB; MRG CFLAG,2; ETR =NCS; LDX CPTR,2
       XXB; STA CFLAG,2; LDX CPTR,2
       LDA 1,2; ETR =37777B; XXB; XMA 1,2; COPY BX,AB
       XMA 1,2; CAX; LDA 0,2; XXB; XMA 0,2; ETR =37777B
       XXB; STA 0,2; LDX* 0; BRR 0


* FORCE TRUE TRANSFER. CALL WITH DESCRIPTOR IN X.
$FTXFER ZRO FXFRT1
       LDA CFLAG,2; SKA =TXFER; SBRR FTXFER
       LDB =-1
FXFR2  STB FXFRT4; SKA =TXFER+FXFER; BRU FXFR1
* CONSTANT
       STX FXFRT2; SKA =CONST; BRU *+2; BRU FXFR7
* YES
       LDA =TXFER; SKN FXFRT4; LDA =FXFER; STA FXFRT3
       LDX ADDR,2; LDA SVAL,2; SKE =0; BRU FXFR8
       SKN FXFRT4; BRU FXFR10; BRU FXFR9
* TRANSFER
FXFR10 LDA FXFRT3; LDX FXFRT2; BRU FXFR11
* NO TRANSFER
FXFR9  GTADR; ETR =37777B; MRG =4B7; LDX FXFRT2; STA ADDR,2
       M FXFRT3,/CFLAG; APINS FXFRT2,=0,=7; SBRR FFXFER
FXFR8  SKN FXFRT4; BRU FXFR9; BRU FXFR10
* VALUE NOW.  CONVERT.  IS IT CODE ENDING WITH ETR
FXFR7  SKN ADDR,2; BRU FXFR3; FEB FXFR12
* CAN USE SKA =CONST
       STB FXFRT3; MCON; MRG ZSKA
       LDX FXFRT3; STA 2,2; M =0,/3; BRU FXFR4
* NO.  STILL MIGHT HAVE ETR ON END
FXFR12 LDX CPTR,2; LDX 1,2; LDA 2,2
       LDB =577B5; SKM ZETR; BRU FXFR3
* YES. CONVERT ETR TO SKA
       ETR =20077777B; MRG ZSKA; STA 2,2; BRU FXFR4
* NO LUCK
FXFR3  FLOAD FXFRT2; MCI =0; MRG ZSKE; APINS FXFRT2,:,=0
* GENERATE THE RIGHT NUMBER OF BRANCHES
FXFR4  SKN FXFRT4; BRU FXFR5
* TRUE TRANSFER.  THIS IS THE NATURAL WAY
       LDA =TXFER
FXFR6  LDX FXFRT2; MRG CFLAG,2
FXFR11 LDX FXFRT2; MRG =CLOBA; STA CFLAG,2
       GTADR; STA FXFRT3; MRG ZBRU; APINS FXFRT2,:,=0
       LDA FXFRT3; MRG =4B7; STA ADDR,2; SBRR FTXFER
* FALSE TRANSFER. NEED EXTRA BRU *+2
FXFR5  LDA =2; MRG ZBRU; APINS FXFRT2,:,=6; LDA =FXFER; BRU FXFR6
FXFR1  STX FXFRT2; GTADR; ETR =37777B; STA FXFRT3
       MRG ZBRU; APINS FXFRT2,:,=0
       LDA FXFRT3; MRG =4B7; XMA ADDR,2; ETR =37777B
       APINS FXFRT2,:,=2; LDA CFLAG,2; EOR =FXFER+TXFER
       STA CFLAG,2; SBRR FTXFER
* FORCE FALSE TRANSFER
$FFXFER ZRO FXFRT1
       LDA CFLAG,2; SKA =FXFER; SBRR FFXFER; CLB;  BRU FXFR2




* THIS ROUTINE TESTS TO SEE IF BOTH ITS OPERANDS ARE INTEGER
* CONSTANTS. IF NOT, NOSKIP RETURN. IF SO, SKIP RETURN. ADDRESSES
* ONE ARGUMENT, LEAVES ITS VALUE IN A ON SUCCESS. POINTS TO OTHER
* ARGUMENT FROM X, LEAVES ITS VALUE IN B AND RESULT ON SUCCESS.
* PRESERVES X
       POPDEF TIA
ETIA   LDA CFLAG,2; SKA =CONST; BRU *+2; BRR 0; STX T; LDX ADDR,2
       LDB SVAL,2; LDX* 0; LDA CFLAG,2; SKA =CONST; BRU *+2; BRU TIA1
       LDX ADDR,2; LDA SVAL,2; STB RESULT
TIA2   MIN 0
TIA1   LDX T; BRR 0




* THIS ROUTINE MAKES A CODE BLOCK FOR THE CONSTANT IN A AND
* LEAVES ITS ADDRESS IN THE EFFECTIVE ADDRESS
       POPDEF MCC
EMCC   LDB 0; STB MCCT1; MCON; STX MCCT2; GND
       M =CONST,/CFLAG; M MCCT2,/ADDR
       STX* MCCT1; BRR MCCT1



* THIS ROUTINE IS CALLED LIKE TIA. IT RETURNS NOSKIP IF NEITHER OPERAND
* IS A CONSTANT 0. IF ONE IS, IT SKIPS AND RETURNS THE ADDRESS OF
* THE OTHER ONE IN A AND 0 OR 1 IN B DEPENDING ON WHETHER THE NON-ZERO
* OPERAND IS THE FIRST OR THE SECOND.
       POPDEF TZO
ETZO   STX T; LDA CFLAG,2; SKA =CONST; BRU TZO1
TZO2   LDX* 0; LDA CFLAG,2; SKA =CONST; BRU *+2; BRU TIA1
       LDX ADDR,2; LDA SVAL,2; SKE =0; BRU TIA1
       LDA T; CLB; BRU TIA2
TZO1   LDX ADDR,2; LDA SVAL,2; SKE =0; BRU TZO2
       LDA* 0; LDB =1; BRU TIA2




* APPEND FLOW-THROUGH BRANCH IF REQUIRED
* THIS SETS FTBADR AND APPENDS A BRU TO THERE ON THE
* DESCRIPTOR ADDRESSED BY THE POP
       POPDEF APFT
EAPFT  LDA =-1; XMA FTFLG; SKE =-1; BRU *+2; BRR 0
       M 0,APFTT1; M =-1,PTADRF; GTADR; MIN PTADRF
       STA FTBADR; MRG ZBRU; LDB APFTT1; STB 0
       CLB; BRU EAPPINS



* TEST FOR FIELD EXTRACT OR BRANCH.  CALL WITH DESCRIPTOR IN X.
* IF THE CODE ENDS WITH SOME COMBINATION OF ETR =CONST AND LRSH,
* REPLACE THEM WITH BSS 0 AND RETURN WITH SHIFT COUNT IN X,
* PROPERLY ALIGNED MASK IN A, CODE BLOCK POINTER IN B
* OTHERWISE BRANCH TO EFFECTIVE ADDRESS
       POPDEF FEB
EFEB   SKN CPTR,2; BRU *+2; BRU* 0; STX FEBT1
       LDX CPTR,2; LDX 1,2; LDA 2,2
       LDB =@77B; SKM ZLRSH; BRU FEB1
* HAVE LRSH
       ETR =77B; STA FEBT2; STX FEBT3
* TRY FOR ETR
       LDX 1,2; LDA 2,2; LDB =@37777B; SKM ZETR; BRU FEB2
* YES
       COPY AX,XB; LDA SFLAG,2; SKA =INTCF; BRU *+2; BRU FEB2
       LDA SVAL,2; COPY BX,B; STB 2,2; LDB =7; STB 3,2
FEB3   LDX FEBT2; LRSH 0,2; CLB; LSH 0,2
* HAVE MASK IN A, SHIFT IN FEBT2
FEB4   STA FEBT1; LDX FEBT3; M =0,/2; M =7,/3
       LDA FEBT1; CXB; LDX FEBT2; BRR 0
* HAVE LRSH BUT NOT ETR.  USE -1 AS MASK
FEB2   LDA =-1; BRU FEB3
* NO LRSH ON END.  TRY FOR ETR
FEB1   LDB =@37777B; SKM ZETR; BRU FEB0
* YES
       COPY AX,XB; LDA SFLAG,2; SKA =INTCF; BRU FEB5
FEB0   LDX FEBT1; BRU* 0
FEB5   LDA SVAL,2; STA FEBT2; CBX; STX FEBT3
       LDX 1,2; LDA 2,2; LDB =@77B; SKM ZLRSH; BRU FEB6
* HAVE LRSH TOO
       ETR =77B; CLB; STB 2,2; LDB =7; STB 3,2
       COPY AX,B; XMA FEBT2; LSH 0,2; BRU FEB4
* ONLY ETR
FEB6   CLA; XMA FEBT2; BRU FEB4


* RECOGNIZE POP
       POPDEF REC
EREC   LDX =4B4; EAX* 0; CXA; SUB 0,2; STA RECT1
       LDA 0,2; COPY AX,N; ADD RSTK; STA RECT2; BRU REC2
REC1   LDB* RECT1; STB* RECT2
REC2   BRX REC1; ETR =37777B; STA RSTK
       LDA 0; STA* RSTK; LDX RECT1; BRU 0,2

* TRUE RETURN POP
       POPDEF RECTR
ERECTR LDA* RSTK; ADD =1; BRU RECR1
* FALSE RETURN POP
       POPDEF RECFR
ERECFR LDA* RSTK
RECR1  XMA 0; CAX; LDA* 0,2; ADD =2B7; ADD RSTK
       XMA RSTK; MRG =2B7; STA RECT1
       LDA 0,2; SUB* 0,2; MRG =4B4; STA RECT2
       LDX* 0,2; BRU RECR3
RECR2  LDA* RECT1; STA* RECT2
RECR3  BRX RECR2; BRR 0



* PREPROCESSOR FOR STANDARD OPERATOR COMPILATION
* 1. FORCE BOTH OPERANDS TO GENERATE VALUES
* 2. IS SECOND OPERAND ADDRESS NOT CLOBBERING A
*  2A. YES. GENERATE CODE TO LOAD FIRST OPERAND. APPEND ANY
*      CODE FOR SECOND OPERAND. RETURN SECOND OPERAND ADDRESS
*  2B. NOT ADDRESS. IS FIRST OPERAND ADDRESS NOT CLOBBERING A
*   2B1. YES. GENERATE CODE TO LOAD SECOND OPERAND.  APPEND ANY CODE FOR 
*        FIRST OPERAND. RETURN FIRST OPERAND ADDRESS WITH SKIP
*   2B2. NOT ADDRESS. TAKE CODE FOR SECOND OPERAND AND STORE TEMP.  TREAT
*        TEMP AS ADDRESS AND GO TO 2A
*   2B3. ADDRESS BUT CLOBBERS A. GENERATE LDA ADDRESS AND GO TO 2B2
*  2C. ADDRESS BUT CLOBBERS A. GENERATE LDA ADDRESS AND GO TO 2B

* AFTER THIS ROUTINE HAS DONE ITS WORK, THE CODE GENERATOR FOR THE PARTICULAR
* OPERATOR DOES ITS JOB.  THIS ROUTINE SKIPS IF IT LEAVES THE SECOND OPERAND
* IN A.  IT ADDRESSES THE DESCRIPTOR FOR THE FIRST
* OPERAND, TAKES THE ADDRESS OF THE ONE FOR THE SECOND OPERAND IN X.
* ADDRESS OF DESCRIPTOR WITH CODE AND ADDRESS RETURNED IN X

       POPDEF SPP
ESPP   BSS 0
* BEGIN BY FORCING BOTH OPERANDS TO GENERATE VALUES IF THEY DON'T
       M 0,SPPT1; STX PT2; LDX* 0; STX PT1; FVAL PT1; FVAL PT2
* EXAMINE SECOND OPERAND
       LDX PT2; LDA CFLAG,2; SKA =CLOBA; BRU SPP1
       SKN ADDR,2; BRU *+2; BRU SPP1
* SECOND OPERAND IS AN ADDRESS WHICH DOES NOT CLOBBER A.
* EXAMINE FIRST OPERAND
SPP8   LDX PT1; LDA CFLAG,2; SKA =CLOBA; BRU SPP2
       SKN ADDR,2; BRU *+2; BRU SPP2
* FIRST OPERAND IS ALSO GOOD. GENERATE CODE TO LOAD FIRST
* OPERAND, AND APPEND ANY CODE FOR SECOND OPERAND.  RETURN
* ADDRESS OF SECOND OPERAND AS OBJECT ADDRESS
SPP4   APIA PT1,ZLDA
* APPEND CODE FOR SECOND OPERAND
SPP3   APCODE PT1,PT2; LDX PT2; LDB ADDR,2; LDX PT1
       STB ADDR,2
* RETURN WITH ADDRESS OF NEW DESCRIPTOR IN X
       BRU SPP7
* SECOND OPERAND IS A CLEAN ADDRESS BUT FIRST IS NOT.  IS FIRST AN
* ADDRESS AT ALL
SPP2   SKN ADDR,2; BRU SPP4
* YES. WE DON'T CARE ABOUT ITS CLOBBERING A
       BRU SPP3
* SECOND OPERAND IS NOT CLEAN. EXAMINE FIRST OPERAND
SPP1   LDX PT1; LDA CFLAG,2; SKA =CLOBA; BRU SPP5
       SKN ADDR,2; BRU *+2; BRU SPP5
* FIRST OPERAND IS CLEAN. GENERATE CODE TO LOAD SECOND
* OPERAND AND APPEND CODE FOR FIRST. RETURN FIRST OPERAND ADDRESS
* AS OBJECT ADDRESS WITH SKIP
       MIN SPPT1; LDA PT1; XMA PT2; STA PT1; BRU SPP8
* FIRST OPERAND NOT CLEAN CLEAN ADDRESS EITHER
SPP5   FLOAD PT2
* HAVE TWO BAD OPERANDS
SPP6   GTEMP; LDX PT2; STA ADDR,2; APIA PT2,ZSTA
       FLOAD PT1; APCODE PT2,PT1
       M PT2,PT1; CAX
SPP7   LDA CFLAG,2; MRG =CLOBA; STA CFLAG,2; BRR SPPT1



* SUBROUTINE TO STORE A IN TEMP, LOAD FROM OP1
$SWOP  ZRO SWOPT1
       LDX OP1; SKN CPTR,2; BRU SWOP1
SWOP2  GTEMP; LDX OP1; XMA ADDR,2; STA SWOPT2; LDA ADDR,2; MRG ZSTA
       APINS OP1,:,=0; LDA SWOPT2
SWOP3  MRG ZLDA; APINS OP1,:,=0; LDX OP1; SBRR SWOP
SWOP1  LDX CPTR,2; LDX 1,2; LDA 2,2
       EOR ZSTA; SKA =7774B4; BRU SWOP2
       LDB =-1; SKB 3,2; BRU SWOP2
       LDX OP1; XMA ADDR,2; BRU SWOP3


* SPECIAL FUNCTIONS
XSF   SAVE OP1,SFT1
XSF    EXT
       LDA* INPUT; SKG =MAXSF; SKG =277B; CERR 16; SUB =300B
       STA CPT1; ADM CPT1; NEXT; CBF ILPAR,16; LDX CPT1
       LDB SFTAB+1,2; STB ARGCW; STB OP1
       LDA SFTAB,2; SKA =777B5; BRU *+2; BRU XSF3; STA SFT1
       SKN SFTAB+1,2; BRU *+2; BRU XSF4
* NOT POP
       M =EXPR,FAREC; NEXT; RBF CFARGS,1; LDA SFT1; APINS ARGSET,:,=1
XSF7   APCODE ARGSET,ARGLST; M ARGSET,OP2; M OP1,ARGCW
       RBF GFCTL,1; PREV; BRU XSF2
* SPECIAL FUNCTION WHICH HAS ITS OWN CODE
XSF3   CAX; BRU 0,2
* SPECIAL FUNCTION POP
XPOP   RBF EXPR,37; LDX OP2; TIA OP2; CERR 37; ETR =577B
       LSH 24-9; STA SFT1; M =0,OP1; CBT ICOMMA,XSF4; PREV
* OTHER SPECIAL FUNCTIONS WITH BUILT-IN POP VALUES.  COLLECT
* EFFECTIVE ADDRESS
XSF4   RBF EXPR,8; FVALNO OP2; SKN CPTR,2; FADDR OP2
       LDA SFT1; ADM ADDR,2; STX SFT1
       M =EXPR,FAREC; CBF ICOMMA,XSF8; NEXT
XSF8   M OP1,ARGCW; RBF CFARGS,1; LDX SFT1; LDA ADDR,2
       APINS ARGSET,:,=0; APCODE SFT1,ARGSET; M SFT1,ARGSET
       BRU XSF7



XSF2   LDX OP2; M =-1,/ADDR; M =CLOBX+CLOBA,/CFLAG
XSF1   CBF IRPAR,15; TRET XSF

* FIELD MASK AND SHIFT FUNCTIONS
XFMASK SBRM GFIELD; LDA CPT1; MCC OP2; BRU XSF1

XFSHFT SBRM GFIELD; LDA CPT2; ETR =77B; MCC OP2; BRU XSF1

* GET FIELD FOR FMASK AND FSHIFT.  ALSO USED BY BDOL
$GFIELD ZRO GFLDT1
       NEXT; LDA* INPUT; SKG ESYT; SKG BSYT; CERR 2; CAX; STX CPT3
       LDA SFLAG,2; SKA =STRUCF; BRU *+2; CERR 2
       NEXT; SBRM GPF; SBRR GFIELD


* RECOGNIZE COUT
XCOUT  LDA ZCIO
XCOUT2 STA SFT1; RBF EXPR,1; FLOAD OP2; M OP2,OP1; CBF ICOMMA,XCOUT1; RBF EXPR,1
       FADDR OP2; APCODE OP2,OP1; LDX OP2; LDA ADDR,2; BRU XCOUT3
XCOUT1 MCI =1
XCOUT3 MRG SFT1; APINS OP2,:,=0; BRU XSF2

* RECOGNIZE WOUT
XWOUT  LDA ZWIO; BRU XCOUT2


* KLUDGE: PUT :: IN PLACE OF SAVE( IN INPUT AND CALL GFCTL
XSAVE  PREV; LDX INPUT; M ICOLON,/0; STA /1
       GND; STX OP2; RBF GFCTL,16; PREV; BRU XSF2


* MACRO TO GENERATE SPECIAL FUNCTION TABLE
* THE FIRST WORD IS WRITTEN LITERALLY
* THE MACRO CONSTRUCTS THE SECOND WORD
*   IF THE FIRST ARG IS P IT IS DISCARDED AND THE SF IS A POP
*   LATER ARGS ARE ONE OF THE SYMBOLS BELOW, SPECIFYING THE REQUIREMENTS
*     FOR THE FOLLOWING REGISTERS, IN THAT ORDER*
*      Q (POPS ONLY)
*      A,B,X
*      GOTO
DONCAR EQU 0
DF0    EQU 1   0 IS DEFAULT ARG
DF1    EQU 2   1
DFM1   EQU 3   -1
DF10   EQU 4   10D
DFSARY EQU 5   SARRAY
DFFTLE EQU 6   FTLERR
GIVEN  EQU 7   ARGUMENT MUST BE SUPPLIED BY CALL
G      EQU 7
ABSENT EQU 8   ARGUMENT MUST NOT BE SUPPLIED.  THIS IS THE DEFAULT CASE
A      EQU 8

SF     MACRO D
Q3     EQU 0
Q1     EQU ABSENT*2B5
       IF 'D(1$1,4)'='P';Q1 EQU 4B7+D(2)*2B5;Q3 EQU 2; ENDF
Q2     NARG
Q4     EQU 1B4
       RPT 4
       IF Q3=Q2
Q1     EQU Q1+ABSENT*Q4
       ELSE
Q3     EQU Q3+1
Q1     EQU Q1+D(Q3)*Q4
       ENDF
Q4     EQU Q4/20B
       ENDR
       DATA Q1
       ENDM


* ASSUME THAT SPECIAL FUNCTIONS IMPLEMENTED WITH POPS START WITH GIVEN ARGUMENT

SFTAB  ZRO XSAVE; SF DONCAR,DONCAR,DONCAR
       CALL* FREE; SF G,DFSARY
       RCS 0; SF P,G,A,A,A,DFFTLE   GCI
       WCS 0; SF P,G,G,A,A,DFFTLE   WCI
       RCB 0; SF P,G,A,A,A,DFFTLE   GCD
       WCB 0; SF P,G,G,A,A,DFFTLE   WCD
       RCN 0; SF P,G                GC
       CALL* APPEND; SF G,G,A,DFFTLE
       RSD 0; SF P,G,G,G            SETS
       LNG 0; SF P,G                LENGTH
       CALL* SETUP; SF G,G,DF0
       CALL* INFILE; SF G,A,A,G
       CALL* OUTFILE; SF G,DF0,A,G
       BRS 20; SF G            CLOSE
       BRS 17; SF A            CLOSALL
       CALL* INNAME; SF G,A,A,G
       CALL* OUTNAM; SF G,A,A,G
       CALL* SCOPY; SF G,G,A,DFFTLE
       CALL* BCOPY; SF G,G,DFM1
       CIO 0; SF P,G           CIN
       ZRO XCOUT; SF G         COUT
       CALL* SOUT; SF G,DF1
       FIO 0; SF P,G,DF1,DF10,DFM1  IOUT
       CALL* IIN; SF G,DF10
       CALL* CRLF; SF DF1,DF1
       RSR 0; SF P,G,G              SETR
       RSW 0; SF P,G,G              SETW
       WIO 0; SF P,G           WIN
       ZRO XWOUT; SF G         WOUT
       CALL* SETARRAY; SF G,G
       CALL* PMAKE; SF G,DF0
       CALL* INIT; SF A
       HLT 0,2; SF A       HALT
       BRS 10; SF A         EXIT
       ZRO XFMASK; SF G
       ZRO XFSHFT; SF G
       NSC 0; SF P,G,G,DF10,DFM1    CNS
       CALL* CSN; SF G,DF10
       BRS* 0; SF P,G,DONCAR,DONCAR,DONCAR,DONCAR
       SBRM* 0; SF P,G,DONCAR,DONCAR,DONCAR,DONCAR
       CALL* LOCK; SF G
       CALL* UNLOCK; SF G
       CALL* PFLUSH; SF A
       CALL* MAKE; SF G,DFSARY
       CALL* BPUT; SF G
       CALL* BGET; SF G
       ZRO XPOP; SF DONCAR,DONCAR,DONCAR,DONCAR

* OUTPUT ROUTINES FOR QSPL
QO     IDENT

* MACROS
OPC    MACRO N
XX     NARG; RPT (YY=2,XX)
ZZ     NCHR 'N(YY)'
       IF N(1); N(YY$2,ZZ-2) 0; ENDF
       IF ZZ=3; DATA N(YY); ELSE
       OPC1 'N(YY)   '; ENDF; ENDR
       ENDM
OPC1   MACRO N
       IF 'N(1$3)'<'2';VV EQU 'N(1$4,7)';WW EQU N(1$2,3)B
       ELSE;VV EQU 'N(1$3,6)';WW EQU N(1$2); ENDF
VV     EQU VV&37373737B
       DATA VV+[WW*2B7&4B7]+[WW*4B5&4B5]+[WW*1B3&4B3]+[WW*4&40B]
       ENDM

* INTERNAL SUBROUTINE CALL POP
       POPDEF C
EC     XMA 0; STA* MPP; XMA 0; MIN MPP; BRU* 0

$R1    SKR MPP; BRR* MPP
$R2    SKR MPP; MIN* MPP; BRR* MPP

*********************
* OUTPUT AND LISTER *
*********************

* COMPILER ERROR
CERR   STP CERRA; STX CERRX; MSG CERR1; LDX MPP; LDA -1,2
       ETR =37777B; LDB =8; LDX =1; BRS 36
       MSG CERR2; LDP CERRA; LDX CERRX; R1
CERR1  ASC '$COMPILER ERROR AT /'
CERR2  ASC 'B$/'

* CODE OUTPUT ROUTINES

* INITIALIZE CODE PACKAGE
* (A),(X) DESTROYED
$RCO   CLA; STA CBM; STA LSC; STA TSLC; STA OTSLC
       LDX =-NLCTRS; STA ETSLV,2; STA ETSLA,2; BRX *-2
       LDA =-1; STA OLX; STA OLA; BRS 88; STA ITIME
       LDA =FGTBUF; STA FGTPTR; LDX =-LBPBUF
RCO1   STX CBP; CLA; STA CBF; LDX =-9; STX CBC; R1

* OUTPUT CODE BUFFER
* (A),(X) DESTROYED
$WCB   LDX CBP; LDA CBC; SKG =-9; BRU WCB1
       ADD =9; STA CERRX; LDA =CBF; STA CERRA
WCB2   LDA* CERRA; STA EBPBUF,2; BRX *+2; C WBB
       MIN CERRA; SKR CERRX; BRU WCB2; BRU RCO1
WCB1   SKN CBM; BRU RCO1; MIN CBM; LDA =-1
       STA EBPBUF,2; BRX RCO1; C WBB; BRU RCO1

* OUTPUT BPBUF
* (A)←(EBPBUF-1), (X)←-LBPBUF
$WBB   CXA; SKG =-LBPBUF; BRU WBB1
       ADD =LBPBUF; LDX =BPBUF; BIO BINFIL; NOP
WBB1   LDX =-1; LDA EBPBUF,2; LDX =-LBPBUF; STX CBP; R1

* OUTPUT CODE WORD:
* (CBM)>-1: SYMBOL (A)(B)(X)
* (CBM)<0: WORD (A) WITH 3-BIT CODE (B)
* (A),(B),(X) DESTROYED
$OCW   SKN CBM; BRU OCW1; STX CBT
       LDX CBP; STA EBPBUF,2; BRX *+2; C WBB
       SKE =-1; BRU OCW2; STX CBP; MIN CBM; R1
OCW2   STB EBPBUF,2; BRX *+2; C WBB; LDA CBT
       STA EBPBUF,2; BRX *+2; C WBB; STX CBP; R1
OCW1   STB CBT1; LDX CBC; BRX OCW3
       STA CBT; C WCB; LDA CBT; LDB CBT1; BRX OCW3
OCW3   STX CBC; STA CBE,2; CLA; RCY 9,2; RCY 9,2; RCY 9,2
       ADM CBF; LDA CBT1; SKE =4; BRU OCW4
       LDB CBE,2; LSH 3; SKG =42B; BRU OCW5
       C WCB; LDA =-1; STA CBM; R1
OCW4   MIN CBL; R1
OCW5   SKA =2; R1
       LDA CBE,2; ADD CBL; ETR =37777B; STA CBL; R1

* OUTPUT INSTRUCTION WITH ADDRESS IN SYMBOL TABLE
* (A)0-9 TAKEN LITERALLY, (A)10-23 POINT TO SYMBOL TABLE ENTRY
* FORMAT: FLAGS IN 2ND WORD, CHAIN IN 3RD WORD
* IF BIT 0 IS ON, THE SYMBOL IS DEFINED AND RELOCATABLE
* IF BIT 1 IS ON, THE CHAIN WORD POINTS TO ANOTHER
* SYMBOL TO BE USED INSTEAD
* IF BITS 0 AND 1 ARE OFF, THE SYMBOL IS UNDEFINED, AND BITS 10-23
* OF THE CHAIN ARE USED TO CONSTRUCT THE POINTER CHAIN, WHERE A VIRGIN
* ENTRY IS ASSUMED TO CONTAIN A 37777B
* IF BIT 2 IS ON, THEN THE 4TH WORD IS A VALUE TO BE STORED
* INTO THE CELL, WHICH IS RELOCATABLE IF BIT 3 IS ON, OR A POINTER
* TO ANOTHER SYMBOL TABLE ENTRY IF BIT 4 IS ON
* (A),(B),(X) DESTROYED
$OSI   CAX; ETR =77740000B; STA CBT
OSI3   LDA SFLAG,2; SKA =RVALF; BRU OSI4
       LDA SCHAIN,2; CAB; ETR =37777B; SKB =6B7; BRU OSI1
       SKE =37777B; BRU *+2; LDA CBL; ADM CBT
       LDA SCHAIN,2; ETR =77740000B; MRG CBL; STA SCHAIN,2
       LDA CBT; LDB =2; BRU OCW
OSI1   SKB =2B7; BRU OSI2; MRG CBT; LDB =2; BRU OCW
OSI2   CAX; BRU OSI3
OSI4   LDA SNAME,2; MRG CBT; LDB =2; BRU OCW

* OUTPUT SYMBOL DEFINITION FOR SYMBOL (X) AS (LOC)
* AND DEFINE SYMBOL IN TABLE
* (A),(B),(X) DESTROYED
$ODF   LDA =203B5
$ODS   STA CBT; LDA CBL; MRG =4B7; XMA SCHAIN,2
       CAB; ETR =37740000B; ADM SCHAIN,2; SKA =2B7; C CERR
       CBA; ETR =37777B; SKE =37777B; BRU *+2; R1
       MRG CBT; LDB =4; BRU OCW

* OUTPUT IDENT RECORD FOR SYMBOL (X), VALUE (A)
* (B),(X) DESTROYED
OID    STA OIDA; STX OIDX; LDA =5B7; LDB =4; C OCW
       LDX OIDX; LDB SFLAG,2; LSH 12; LDA SNAME,2
       LDX OIDA; C OCW; LDA =-1; C OCW
       LDA OIDA; R1

* OUTPUT CODE LIST (A)
* FORMAT OF CODE LIST: (Q)=FORWARD POINTER, (Q+1)=BACKWARD POINTER,
*                         (Q+2)=WORD, (Q+3)=TYPE
* LIST IS CIRCULAR IN BOTH DIRECTIONS,
* WRAPAROUND POINTERS HAVE BIT 0 SET
* THE FOLLOWING OPTIMIZATION IS PERFORMED:
*   XXA, XXA DELETED
*   LDX Q, ... , LDX Q WITH NO TRANSFER OF CONTROL OR MODIFICATION OF
*     (X) OR (Q) INTERVENING DELETES 2ND LDX
*   SAME OPTIMIZATION FOR CEA AND CEAS
*   OPC* =N REPLACED BY OPC N
* (A),(B),(X) DESTROYED
$OLS   STA OLP; C WCR
OLS0   LDX OLP; LDA 2,2; STA CBT; LDX 3,2; BRU* OLS1,2
OLS1   DATA OLS2,OLS3,OLS4,OLS5,OLS6,OLS13,OLS20,OLS22
       DATA OLS23,OLS26,OLS27,OLS28
* LABEL CELL INITIALIZATION
OLS6   CAX; LDA SCHAIN,2; MRG =14B6; STA SCHAIN,2
       LDA CBL; ADM SVAL,2; BRU OLS5
* TRANSFER POINT
OLS4   CAX; C ODF
* IGNORE, BREAK IN CONTROL
OLS5   M =-1,OLA
OLS5A  M =-1,OLX
OLS11  LDX OLP; LDA LSTFIL; SKE =2; C WII
OLS7   LDX OLP; LDA 0,2; STA OLP; SKN OLP; BRU OLS0
       LDA LSTFIL; SKE =2; C WFG; R1
* ABSOLUTE INSTRUCTION
OLS3   LDX OLP; SKN 0,2; SKE ZXXA; BRU OLS8
       LDX 0,2; SKE 2,2; BRU OLS13; BRU OLS7+1
OLS13  LDX OLP; LDA 2,2; BRU OLS8
OLS9   LDX OLP; LDB =1; STB 3,2
OLS8   CLB; C OCW
OLS19  LDA CBT; C FOC; BRU OLS5
       LDB =-1; SKA =4B3; STB OLX; SKA =4B5; STB OLA
       SKA =4B1; BRU *+2; BRU OLS11; LDX OLP; LDA 2,2
       LDB =20077777B; SKM OLA; BRU OLS19B; LDX =-1; STX OLA
OLS19B SKM OLX; BRU OLS11; BRU OLS5A
* INCREMENT LOCATION COUNTER
OLS22  ETR =37777B; SKG =0; BRU OLS7
       LDB =4; C OCW; BRU OLS11
* ASCII STRING
OLS23  STA OLQ; LDA* OLQ; SUB =1; MUL =12525253B; STA OLC
OLS24  MIN OLQ; LDA* OLQ; CLB; C OCW
       SKR OLC; BRU OLS24; BRU OLS11
* SYMBOLIC INSTRUCTION
OLS2   CAX; SKA =4B4; SKA =2B7; BRU OLS30
       LDB SFLAG,2; SKB =INTCF; BRU OLS31
OLS30  SKE OLX; BRU *+2; BRU OLS7
       LDB =577B5; SKM ZLDX; BRU OLS17
OLS25  SKA =2004B4; BRU OLS9B; STX OLX; BRU OLS17A
OLS17  SKM ZCEAS; BRU *+2; BRU OLS25
       SKM ZCEA; BRU OLS38; EOR ZCEA; EOR ZCEAS
       SKE OLX; BRU OLS25; BRU OLS7
OLS38  SKM ZSTA; BRU OLS39; SKA =2004B4; BRU OLS41
       EOR ZSTA; EOR ZLDA; STA OLA
OLS41  LDB =20077777B; SKM OLX; BRU OLS17B; BRU OLS9B
OLS40  CAB; SKB =2004B4; LDB =-1; STB OLA; BRU OLS17B
OLS39  SKM ZLDA; BRU OLS17B; SKE OLA; BRU OLS40; BRU OLS7
OLS9B  LDB =-1; STB OLX
OLS17B SKA =2B7; BRU OLS9
OLS17A LDX CBT
OLS18  LDA SCHAIN,2; SKA =2B7; BRU *+2; BRU OLS21
       ETR =77777B; XMA CBT; ETR =777B5; MRG CBT; STA CBT
       LDX OLP; STA 2,2; CAX; BRU OLS18
OLS21  LDA CBT; C OSI; BRU OLS19
OLS31  ETR =577B5; XMA CBT; SKB =REFF; BRU OLS32
       LDX OLP; LDB =1; STB 3,2; CAX
OLS32  LDA SVAL,2; ETR =20077777B; MRG CBT
       LDX OLP; STA 2,2; BRU OLS0
* INSTRUCTION RELATIVE TO CURRENT LOCATION
OLS20  ETR =77740000B; XMA CBT; ADD CBL; ETR =37777B
       MRG CBT; STA CBT; LDB =2; C OCW; BRU OLS19
* EQUIVALENCED SYMBOL
OLS26  LDX OLP; LDA 0,2; STA OLP; XXA; LDB 2,2
       XXA; STB 1,2; BRU OLS11+1
* CHARACTER POINTER
OLS27  CAX; LDA SCHAIN,2; SKA =SYMVAL; BRU *+2
       C CERR; ETR =37777B
       MUL =3B7; LSH 2; XMA CBT; RSH 14; ADD CBT
       LDB =3; C OCW; BRU OLS11
* IDENT
OLS28  LDX OLP; SKN 2,2; BRU OLS33; LDA 2,2; LDX =-NLCTRS+1
OLS34  SKN ETSLA,2; CXB; SKE ETSLA,2; BRU OLS35
OLS37  COPY XA,B; ADD =NLCTRS; LSH 16; STA TSLC; BRU OLS11
OLS33  LDX 2,2; CLA; C OID; BRU OLS11
OLS35  BRX OLS34; COPY AB,BA,BX; SKE =0; BRU *+2; FERR 4
       STA ETSLA,2; XXA; ADD =4B7+NLCTRS; C OID
       SUB =4B7+NLCTRS; CAX; BRU OLS37

* ROUTINES FOR LISTING

* TCO FOR LISTING FILE
       POPDEF TCL
ETCL   STA TCLT; LDA* 0; CIO LSTFIL
       MIN LSC; LDA TCLT; BRR 0

* WRITE CR ON LISTING IF NECESSARY
* (A) DESTROYED
$WCR   LDA LSC; SKG =0; R1
       SKE =7; BRU WCRI; TCL CHB
       TCL CHS; TCL CHS; TCL =0; TCL CH0
$WCRI  TCL =155B; TCL =152B; CLA; STA LSC; R1

* WRITE (A) BLANKS ON LISTING
* (A),(B) DESTROYED
$WBL   SKG =1; BRU WBL1; ADM LSC; SKR LSC
       TCL CHMBLK; CIO LSTFIL; R1
WBL1   SKE =0; TCL =0; R1

* WRITE OCTAL NUMBER (A) ON LISTING
* (A),(B) DESTROYED
$WNL   STX LSS; CAX
WNL1   MIN LSC; LRSH 3; SKE =0; BRU WNL1
       CXA; LDB =8; LDX LSTFIL; BRS 36; LDX LSS
       SKA =@7; TCL CHB; R1

* WRITE SIGNED OCTAL NUMBER (A) ON LISTING
* (A),(B) DESTROYED
WSA    LCY 10; RSH 10
WSV    SKG =-1; SKG =777B5-1; BRU WSV1
$WVL   SKG =-1; SKG =777B5-1; BRU WNL
       TCL CHMNS; CNA; BRU WNL
WSV1   SKE =0; BRU *+2; R1; TCL CHPLUS; BRU WNL

* WRITE SYMBOL (X,X+1) ON LISTING
* (A),(B) DESTROYED
WSY5   LDA SVAL,2
WSY4   CAX
$WSY   LDA SCHAIN,2; SKA =2B7; BRU WSY4
$WSI   LDA SFLAG,2; SKA =INTCF; BRU WSY1; SKA =RVALF; BRU WSY6
       LDB SCHAIN,2; SKB =SYMTMP; BRU WSY2; SKB =SYMTRA; BRU WSY3
       CLB; RSH 12; LDA SNAME,2; CR1 WSW
WSY1   TCL CHEQL; SKA =REFF; BRU WSY5
       LDA SVAL,2; CR1 WVL
WSY2   LDA ='T:+ '; CLB; C WSW
       LDA SNAME,2; CR1 WNL
$WSYTRA EQU *
WSY3   LDA SFLAG,2; C WNL; TCL CHX; R1
WSY6   LDP HSZERO; C WSW; LDA SNAME,2; CR1 WSA

* CONSTRUCT GENERATED LABEL FOR (X)
$CGL   LDB SFLAG,2; LSH 12; STB LSS; LDA SNAME,2
       LRSH 6; MRG =':   '; SKB =7700B; BRU *+2; R1
       XAB; EOR LSS; ETR =77B6; EOR LSS; XAB; R1

* WRITE SYMBOL (A)(B) ON LISTING
* (A),(B) DESTROYED
$WSW   RCY 18
WSW1   STA LSS; ETR =77B; SKG =0; R1
       CIO LSTFIL; MIN LSC; EOR LSS; LCY 6; BRU WSW1

* WRITE LABEL (X)
* (A),(B) DESTROYED
$WLB   C WCR; C WSI; LDA =7; SUB LSC; CR1 WBL

* WRITE PREAMBLE FOR INSTRUCTION
* (A),(B) DESTROYED
WPI    LDA =7; SKE LSC; BRU *+2; R1
       SKG LSC; BRU WPI1; CR1 WBL
WPI2   TCL CHSEMI; TCL =0; R1
WPI1   LDA LSC; SKG =59; BRU WPI2; C WCR; BRU WPI

* WRITE OP CODE (A)
* (A),(B) DESTROYED
$WOC   STA LSO; SKA =4B7; BRU WOC1
WOC2   C WPI; LDA LSO; ETR =37373737B; MRG =404040B2
       SKA =37B; MRG =40B; CLB; CR1 WSW
WOC1   LDA LSC; SKE =7; C WCR; BRU WOC2

* WRITE 'FRGT'S
* (A),(B),(X) DESTROYED
WFG    LDA FGTPTR; SKG =FGTBUF; R1
       C WCR; LDA HFRGT; C WOC; TCL =0
WFG1   LDA =-2; ADM FGTPTR; LDX FGTPTR; C WSYTRA
       LDA FGTPTR; SKG =FGTBUF; R1; TCL CHCMA; BRU WFG1

* WRITE INSTRUCTION ON LISTING
* (A)=INSTRUCTION, (B)=TYPE
* (A),(B),(X) DESTROYED
WII    LDA 2,2; LDB 3,2
WIL    STA CBT; STB WILT; XAB; ETR =77B; COPY AX,BA; BRU* WIL1,2
WIL1   DATA WIL2,WIL3,WIL4,WIL5,WIL6,WIL9,WIL7,WIL18
       DATA WIL20,WIL31,WIL32,WIL33
* LABEL INITIALIZATION
WIL6   C WCR; LDX CBT; C CGL; C WSW
       LDA =7; SUB LSC; CR1 WBL
* IGNORE, BUT CONTROL BREAKS
WIL5   CR1 WCR
* TRANSFER POINT
WIL4   LDX CBT; C WLB; LDA =EFGTBF; SKG FGTPTR; C WFG
       LDX CBT; LDP SNAME,2; STP* FGTPTR
       LDA =2; ADM FGTPTR; R1
* ABSOLUTE INSTRUCTION
WIL3   BRU WIL2
WIL9A  R1
* RELATIVE INSTRUCTION
WIL7   BRU WIL2
* DATA WORD
WIL9   LDA HDATA
WIL19  C WOC; TCL =0; LDA CBT; CR1 WVL
* BSS
WIL18  ETR =37777B; STA CBT; LDA HBSS; BRU WIL19
* EQUIVALENCED SYMBOL
WIL31  CAX; C WLB; LDA HEQU; CLB; C WSW; TCL =0
       LDA WILT; RSH 6; CAX; LDX 1,2; C WSI
       LDA SCHAIN,2; CNA; LDX CBT; ADD SCHAIN,2
       C WSA; BRU WIL5
* CHARACTER POINTER
WIL32  LDA HDATA; C WOC; TCL =0
       LDA HOPR; CLB; C WSW; LDX CBT; C WSY
       LDA CBT; RSH 14; CR1 WSV
* ASCII STRING
WIL20  LDA HDATA; STA WAF; LDA* CBT; STA WAP1
       LDA CBT; MUL =3; LSH 23; ADD =2; STA WAP; ADM WAP1
WIL21  LDA WAP; STA WAPT; MIN CBT
WIL23  GCI WAP; BRU WIL24; SKE CHSQ; SKA =300B; BRU WIL25
       LDA WAP; SUB WAPT; SKE =3; BRU WIL23
WIL24  LDA WAP; SKG WAPT; BRU WIL27
       LDA HASC; SKE WAF; BRU WIL26
WIL28  GCI WAPT; BRU WIL21; CIO LSTFIL; MIN LSC; BRU WIL28
WIL26  STA WAF; C WOC; TCL =0
       LDA CHSQ; BRU WIL28+2
WIL27  LDA WAF; SKE HDATA; TCL CHSQ; BRU WIL5
WIL25  LDA HDATA; SKE WAF; BRU WIL25A
WIL29  C WOC; TCL =0; LDA* CBT; C WNL
WIL30  LDA WAP; SUB WAPT; SKE =3; GCI WAP; BRU WIL21; BRU WIL30
WIL25A STA WAF; TCL CHSQ; LDA HDATA; BRU WIL29
* IDENT
WIL33  SKG =0; R1; CAX; C WLB
       C WPI; LDP HIDENT; C WSW; CR1 WCR
* SYMBOLIC INSTRUCTION
WIL2   C FOC; BRU WIL35; STB CBT; C WOC
       LDA CBT; SKE =-1; BRU *+2; BRU WIL9A
WIL2X  SKA =40000B; TCL CHSTAR; TCL =0
       LDA WILT; SKE =0; BRU WIL8
       LDA CBT; SKA =2B7; BRU WIL2H; CAX; C WSY
WIL2G  LDA CBT; SKA =6B7; BRU WIL2D; BRU WIL9A
WIL2H  LDA CBT; ETR =37777B; C WNL; BRU WIL2G
WIL2D  LDA CBT; RCY 9; ETR =6B4; MRG =',0  '
       CLB; C WSW; BRU WIL9A
WIL8   SKE =6; BRU WIL2H; TCL CHSTAR
       LDA CBT; C WSA; BRU WIL2G
WIL35  C WPI; LDA CBT; LRSH 15; ETR =577B; C WNL
       LDA CBT; ETR =20077777B; STA CBT; BRU WIL2X

* FIND SYMBOLIC OP CODE (A)
* RETURNS OPCODE IN (A), RESIDUUM OR -1 IN (B)
* NO-SKIP RETURN IF NOT AN OPCODE
* (X) DESTROYED
FOC    STA CBT; LDB =577B5; SKM WIL10A; BRU FOC1
* RCH INSTRUCTION
       LDX WIL10
FOC2   SKE WIL10,2; BRX FOC3; LDA WIL11,2; LDB =-1
FOC4   R2
FOC3   BRX FOC2
FOC5   R1
* NOT RCH, TEST FOR POP OR SYSPOP
FOC1   SKA =5B7; BRU FOC6; RCY 15; ETR =77B; CAX; LDB WIL12,2
FOC7   SKB =77B6; BRU FOC8; CBX; BRU* *+1,2
       DATA FOC5,FOC10
FOC6   RCY 15; ETR =477B; SKA =400B; BRU FOC13
       SKG WIL13A; BRU *+2; R1
       CAX; LDB WIL13,2; BRU FOC7
FOC8   LDA CBT; ETR =20077777B; XAB; BRU FOC4
* SHIFT INSTRUCTION
FOC10  LDB CBT; LDA FOCC1; SKB =1B5; ADD FOCC2
       SKB =4000B; BRU FOC11; SKB =20000B; ADD FOCC3
FOC12  XAB; ETR FOCC4; XAB; BRU FOC4
FOC11  LDB FOCC5; RCY 6; EOR =404000B; LDB CBT; BRU FOC12
* SYSPOP
FOC13  LDA CBT; LDB =577B5; LDX WIL16
FOC14  SKM WIL16,2; BRX FOC15; LDB WIL17,2; BRU FOC7
FOC15  BRX FOC14; R1
FOCC1  DATA 'RSH '-40004000B
FOCC2  DATA 'L   '-'R   '
FOCC3  DATA ' CY '-' SH '
FOCC4  DATA 20053777B
FOCC5  DATA '   L'-40B

* INSTRUCTION TABLES FOR FOC
$CHSQ  DATA 7B
$CHSTAR DATA '   *'
$CHPLUS DATA '   +'
$CHMNS DATA '   -'
$CHDOT DATA '   .'
$CHCMA DATA '   ,'
$CHLPAR DATA '   ('
$CHRPAR DATA '   )'
$CH0   DATA '   0'
$CHSEMI DATA '   ;'
$CHEQL DATA '   ='
$CHQM  DATA '   ?'
$CHB   DATA '   B'
$CHD   DATA '   D'
$CHE   DATA '   E'
$CHR   DATA '   R'
$CHS   DATA '   S'
$CHX   DATA '   X'
$CHMBLK DATA 135B
$CHEOF DATA 137B
HIDENT TEXT 'IDENT'
HDATA  TEXT 'DATA'
HEQU   TEXT 'EQU'
HBSS   TEXT 'BSS'
HASC   TEXT 'ASC'
HFRGT  TEXT 'FRGT'
HOPR   TEXT '3*'
HSZERO TEXT ':ZERO:'
WIL10A EQU *
       OPC 1,1CLA,0CLB,4CLX,5XXA,4XXB,1XAB
       OPC 1,4CAX,1CXA,4CBX,0CXB,0CAB,1CBA
       OPC 1,1ABC,1BAC,1CLAB,1CNA
WIL10  DATA WIL10A-*
WIL11  EQU WIL10+1
WIL12  EQU *
       OPC 0,0ZRO,0BRU,0,0,0,0,0,0
       OPC 0,0,0,0,0,1ETR,0,1MRG,1EOR
       OPC 0,0NOP,0,0,5EXU,0,0,0,0
       OPC 0,0,0,0,0,0,0STA,10STB,10STX
       OPC 0,0,5BRX,0,5BRM,0,0,0,0
       OPC 0,0SKE,0BRR,0SKB,0SKN,1SUB,1ADD,1SUC,1ADC
       OPC 0,10SKR,10MIN,11XMA,10ADM,1MUL,1DIV,1,1
       OPC 0,0SKM,0LDX,0SKA,0SKG,0SKD,0LDB,2LDA,6EAX
WIL13  EQU *
       OPC 0,5CALL,5NSC,5MSG,5FIO,5RERR,7RCN
       OPC 0,7RCS,5WCS,7RCB,7WCB,5RSD,7LNG
       OPC 0,5RSR,5RSW,7ESC,0CEA,4CEI,0CEAS,4CEIS
       OPC 0,5RCALL,5RRET
WIL13A DATA *-WIL13-1
WIL16A EQU *
       OPC 1,1CIO,5BRS,1WIO,5BIO,5SBRM
WIL16  DATA WIL16A-*
WIL17  EQU WIL16+1
       FRGT VV,WW,XX,YY,Z

       END

********************  QSPL-STOR  *****


*  (LOWER CASE)

* PARAMETERS AND STORAGE FOR QSPL COMPILER, ASSEMBLE WITH NARP

* INFORMATION ATTACHED TO A PIECE OF AN EXPRESSION DURING COMPILATION:
*      1) POINTER TO CODE WHICH EVALUATES IT, OR -1
*      2) POINTER TO SOURCE WHICH PRODUCED IT, OR -1 IF
*         CONFUSION HAS SET IN.  THIS WORD IS NOT USED AT THE MOMENT
*      3) FLAGS INDICATING WHETHER CODE CLOBBERS A OR X
*      4) AN ADDRESS WHICH SHOULD BE USED IN ANY INSTRUCTION AFFECTING
*         THIS CODE, OR -1
*      5) FLAGS INDICATING WHETHER THIS ADDRESS REQUIRES X PRESERVED IN
*         ORDER TO BE USEFUL
*      6) FLAG INDICATING WHETHER CODE GENERATES A VALUE, A FALSE
*         TRANSFER, OR A TRUE TRANSFER

* ALL THIS REQUIRES A BLOCK OF FOUR WORDS:
CPTR   EQU 0   POINTER TO HEAD OF CODE CHAIN, OR -1
SPTR   EQU 1   POINTER TO SOURCE, OR -1
ADDR   EQU 2   ADDRESS, OR -1
CFLAG  EQU 3   FLAG WORD
* THE FOLLOWING BITS ARE USED IN THE CFLAG WORD:
* NAME    VALUE  BIT  MEANING
CLOBA  EQU 2B7    1   CLOBBERS A
CLOBX  EQU 1B7    2   CLOBBERS X
NEEDX  EQU 4B6    3   ADDRESS REQUIRES X
FXFER  EQU 2B6    4   FALSE TRANSFER
TXFER  EQU 1B6    5   TRUE TRANSFER
CONST  EQU 4B5    6   CONSTANT
STRNG  EQU 2B5    7   STRING
PAGADR EQU 1B5    8   PAGED ADDRESS
REALV  EQU 4B4    9   REAL VALUE

NCS    EQU 77777777B-CONST-STRNG  (NOT CONSTANT OR STRING)

* THIS BLOCK IS CALLED A DESCRIPTOR

* COMPILED CODE IS KEPT ON A FOUR WORD CHAIN.  THE FIRST TWO WORDS ARE
* FORWARD AND BACK POINTERS. THE END-AROUND POINTERS HAVE THE SIGN BIT
* SET.  THE THIRD WORD IS AN INSTRUCTION, AND THE FOURTH CONTAINS MIS-
* CELLANEOUS INFORMATION:
*      0 - ADDRESS OF INSTRUCTION POINTS TO S.T. ENTRY
*          IF INDEX BIT (1) OF INSTRUCTION IS ON, IT IS ABSOLUTE 
*          EVEN IF THIS WORD IS 0
*      1 - INSTRUCTION HAS ABSOLUTE ADDRESS, BUT OPCODE MUST BE OK.
*      2 - ADDRESS OF INSTRUCTION POINTS TO S.T. ENTRY WHICH SHOULD
*          BE DEFINED TO HAVE THE CURRENT VALUE OF THE LOC CTR.
*          NOTHING SHOULD BE COMPILED.  IF THE SIGN BIT OF THE
*          INSTRUCTION IS SET, USE THE TEMPORARY LOCATION
*          COUNTER, OTHERWISE THE PERMANENT LOCATION COUNTER.
*      3 - INSTRUCTION IS MEANINGLESS.  THIS INDICATES A BREAK IN THE
*          FLOW OF CONTROL OVER WHICH POSTOPTIMIZATION SHOULD NOT BE
*          ATTEMPTED
*      4 - ADDRESS OF INSTRUCTION POINTS TO ST ENTRY WHICH SHOULD BE
*          GIVEN THE CURRENT LOC CTR AS ITS INITIAL VALUE. I.E.
*          TURN ON BITS 2,3 OF SCHAIN.  IF THE SIGN BIT IS SET,
*          USE THE TEMPORARY L.C., OTHERWISE THE PROGRAM L.C.
*      5 - INSTRUCTION WORD IS ABSOLUTE (BITS WITH DATA)
*      6 - ADDRESS OF INSTRUCTION IS RELATIVE TO CURRENT VALUE
*          OF LOCATION COUNTER.
*      7 - INSTRUCTION CONTAINS A NUMBER BY WHICH THE PROGRAM COUNTER
*          SHOULD BE INCREMENTED IF THE SIGN BIT IS CLEAR, BY
*          WHICH THE TEMPOARAY LOCATION COUNTER SHOULD BE
*          INCREMENTED IF THE SIGN BIT IS SET.
*      8 - INSTRUCTION CONTAINS THE ADDRESS OF A BLOCK OF WORDS,
*          THE FIRST OF WHICH IS A CHARACTER COUNT AND THE REMAINDER
*          OF WHICH CONTAIN THE SPECIFIED NUMBER OF CHARACTERS
*          PACKED 3/WORD
*      9 - POINTER TO SYMBOL TABLE ENTRY FOR EQUIVALENCED (NEW)
*          SYMBOL IS IN THE INSTRUCTION WORD.  THE NEXT ENTRY ON
*          THE OUTPUT LIST, WHOSE TYPE IS IGNORED, CONTAINS A
*          POINTER TO THE SYMBOL EQUIVALENCED TO, WHICH IS
*          ASSUMED TO BE A FIXED ARRAY.
*      10- INSTRUCTION IS S.T. POINTER WITH RELOCATABLE INITIAL VALUE
*              WHICH SHOULD BE MULTIPLIED BY 3, AND SIGNED OFFSET IN
*              TOP 10 BITS.
*      11- INSTRUCTION IS POINTER TO S.T. ENTRY TO BE OUTPUT AS IDENT
*          IF THE SIGN BIT IS CLEAR, OR TO S.T. ENTRY TO BE USED
*          AS TEMPORARY LOCATION COUNTER IF THE SIGN BIT IS SET.




* A SYMBOL TABLE ENTRY CONSISTS OF
SNAME  EQU 0
SFLAG  EQU 1
* SNAME        2 WORDS FOR THE NAME, PACKED FOUR CHARACTERS/WORD IN THE
*              FIRST WORD AND SECOND HALF OF THE SECOND WORD
SCHAIN EQU 2
* SCHAIN       1 WORD (USUALLY) CONTAINING A FIXUP CHAIN ADDRESS USED BY THE
*              BINARY OUTPUT GENERATOR.  IT IS INITIALIZED TO 37777B.
*              BIT             MEANING
SYMVAL EQU 4B7
*   SYMVAL     0   SYMBOL HAS A VALUE (ASSUMED RELOCATABLE),
*                   WHICH IS IN THE LAST 14 BITS
*                  OTHERWISE THESE BITS ARE THE HEAD OF A FIXUP CHAIN
SYMPTR EQU 2B7
*   SYMPTR     1   LAST 14 BITS ARE A POINTER TO ANOTHER SYMBOL
*                  TABLE ENTRY THE SCHAIN WORD OF WHICH SHOULD BE USED
*                  INSTEAD OF THIS ONE. IF THE INDIRECT BIT IS ON,
*                  HOWEVER, IT IS CARRIED ALONG.
SYMIV  EQU 1B7
*   SYMIV      2   SVAL CONTAINS AN INITIAL VALUE WHICH SHOULD BE PUT
*                  INTO THE CELL RESERVED FOR THE SYMBOL
SYMRIV EQU 4B6
*   SYMRIV     3   SVAL IS RELOCATABLE
SYMPIV EQU 2B6
*   SYMPIV     4   SVAL IS A SYMBOL TABLE POINTER
SYMTRA EQU 1B6
*   SYMTRA     5   SYMBOL IS A GENERATED TRANSFER LOCATION (# IN SFLAG)
SYMTMP EQU 4B5
*   SYMTMP     6   SYMBOL IS A GENERATED TEMPORARY (# IN SNAME)
SVAL   EQU 3
* SVAL         1 WORD CONTAINING AN INITIAL VALUE FOR THE SYMBOL




* THE TOP 12 BITS OF THE SECOND NAME WORD, WHICH IS ALSO CALLED THE
* SFLAG WORD, CONTAIN FLAG BITS:
* NAME    VALUE  BIT  MEANING
ENTF   EQU 4B7    0   SYMBOL IS ENTRY (DEFINED WITH $)
EXTF   EQU 2B7    1   SYMBOL IS NOT DEFINED IN THIS PROGRAM
REFF   EQU 2B7    1   CONSTANT (INTCF MUST BE ON) IS POINTER TO
*                     SYMBOL TABLE ENTRY WHOSE ADDRESS IS TRUE
*                     VALUE OF CONSTANT
STRUCF EQU 1B7    2   SYMBOL IS A STRUCTURE NAME, SCHAIN AND SVAL
*                     ARE INTERPRETED DIFFERENTLY
ARRAYF EQU 4B6    3   SYMBOL IS AN ARRAY NAME, NOTHING SPECIAL
STRDF  EQU 2B6    4   SYMBOL IS A STRING NAME
INTCF  EQU 1B6    5   SYMBOL IS AN INTEGER CONSTANT (LITERAL)
RVALF  EQU 4B5    6   SYMBOL IS A 24-BIT RELOCATABLE VALUE TO BE
*                    FOUND IN THE SNAME WORD
RWF    EQU 2B5    7   SYMBOL IS A RESERVED WORD, INTERNAL NAME IN SCHAIN
INTVF  EQU 1B5    8   SYMBOL IS AN INTEGER VARIABLE
FLTCF  EQU 4B4    9   SYMBOL IS A FLOATING POINT CONSTANT
FLTVF  EQU 2B4   10   SYMBOL IS A FLOATING POINT VARIABLE
PAGEDF EQU 1B4   11   SYMBOL IS PAGED




* A STRUCTURE NAME DOES NOT CONTAIN THE USUAL INFORMATION IN SCHAIN
* AND SVAL.  INSTEAD, THESE WORDS ARE USED TO HOLD A DESCRIPTION
* OF THE FIELD DEFINED BY THE STRUCTURE.  THE ADDRESS FIELD OF SCHAIN
* CONTAINS THE WORD DISPLACEMENT.  THE OPCODE FIELD OF
* SCHAIN CONTAINS THE BIT DISPLACEMENT.  SVAL CONTAINS THE FIELD LENGTH.
* ITS SIGN IS SET IF THE FIELD IS A FULL WORD OR PAIR OF WORDS.


* CODE GENERATION FOR STRUCTURES (OR FIELDS)
* FOR A LOAD, THE WORST CASE IS
*      LDA WD,2
*      LDB WD+1,2
*      LSH -
*      ETR =-  (OMIT FOR 24 BIT FIELD)
* A FIELD CONTAINED IN A SINGLE WORD REQUIRES
*      LDA WD,2
*      LRSH -  (OMIT IF FIELD ENDS ON END OF WORD
*      ETR =-  (OMIT IF FIELD BEGINS ON START OF WORD)
* FOR A STORE, THE WORST CASE IS
*      ETR =-  (OMIT FOR 24 BIT FIELD)
*      XMA WD,2
*      LDB WD+1,2
*      LCY -
*      ETR =-  (CLA FOR 24 BIT FIELD)
*      MRG WD,2
*      RCY -
*      STA WD,2
*      STB WD+1,2
* A FIELD CONTAINED IN A SINGLE WORD REQUIRES
*      LSH -   (OMIT IF FIELD ENDS AT END OF WORD
*      ETR =-
*(REPLACE THESE INSTRUCTIONS WITH CLB, LSH - IF FIELD STARTS AT START
* OF WORD)
*      XMA WD,2
*      ETR =-
*      ADM WD,2



* OPERATOR HIERARCHY
*      ←       REPLACEMENT
*      IF ELSE CONDITIONAL
*      OR      LOGICAL INCLUSIVE OR
*      AND EOR LOGICAL AND AND EXCLUSIVE OR
*      NOT     LOGICAL NOT (EOR =-1)
*      RELATIONS  = # < <= > >=
*      MOD     A MOD B = REMAINDER OF A/B
*      + -
*      * /
*      ↑       NOT IMPLEMENTED AT THE MOMENT
*      UNARY + -, GOTO (BRU), DO (NOISE WORD)
*      ()      FUNCTION CALL
*      .       TAIL. MUST BE FOLLOWED BY STRUCTURE NAME
*      $ @     (UNARY) INDIRECTION AND REFERENCE
*      []      SUBSCRIPT
*      SPECIAL FUNCTIONS


* A SPECIAL FUNCTION IS DEFINED BY TWO WORDS
*  1) CONTAINS A LITERAL WORD TO BE ASSEMBLED (POSSIBLY WITH AN
*     ADDRESS SUPPLIED).  IF ITS OPCODE IS 0, IT IS AN ADDRESS TO
*     TRANSFER TO FOR SPECIAL HANDLING OF THE FUNCTION.
*  2) BIT
*       0    SET FOR POP, CLEAR FOR TAKING (1) LITERALLY
*      4-7   SPEC FOR FIRST ARG
*      8-11           2ND
*     12-15           3RD
*     16-19           4TH
*     20-23           GOTO
* AN ARGUMENT SPEC HAS ONE OF THE VALUES:
* 0 NO ARG REQUIRED
* 1 USE 0
* 2 USE 1
* 3 USE -1
* 4 USE 10
* 5 USE SARRAY
* 6 USE FTLERR
* 7 ARG MUST BE PRESENT
* 8 ARG MUST BE ABSENT

* MACROS

POPDEF MACRO D;D(1) POPD V.&D(1)*1B5; ENDM


POPVAL MACRO D;Q1 NARG; RPT (Q2=1,2,Q1);V.&D(Q2) EQU D(Q2+1)+100B
D(Q2)  OPD 1B7+D(Q2+1)*1B5; ENDR; ENDM


       POPVAL CALL,0,MCON,1,LKS,2,APPINS,3,GND,4,FLOAD,5,APPCOD,6
       POPVAL GTEMP,7,GTADR,10B,FVAL,11B,SPP,12B,CERR,13B
       POPVAL FERR,14B,FADDR,15B,NGIC,16B,IGIC,17B,FVALNO,20B
       POPVAL TIA,21B,MCC,22B,MSTCON,23B,TZO,24B,APFT,25B
       POPVAL REC,26B,RECTR,27B,RECFR,30B,TCL,31B,C,32B,MCI,33B
       POPVAL MFCON,34B,GIC,35B,FEB,36B,APPIF,37B

       FRGT Q1,Q2


* RUNTIME POPS

       POPVAL CALL,0,NSC,1,FIO,3,RCN,5,RCS,6,WCS,7
       POPVAL RCB,10B,WCB,11B,RSD,12B,LNG,13B,RSR,14B,RSW,15B
       POPVAL ESC,16B,CEA,17B,CEI,20B,CEAS,21B,CEIS,22B
       POPVAL RCALL,23B,RRET,24B


M      MACRO X
       LDA X(1); STA X(2)
       ENDM
MSG    MACRO X
Q1     NARG; IF Q1>1; LDX X(2); ELSE; LDX =1; ENDF
       LDA =X(1); LDB =-1; BRS 34
       ENDM
EXTDEF MACRO D
Q1     NARG; RPT (Q2=1,Q1);D(Q2) EXT; ENDR
       ENDM

* MACRO TO ACQUIRE SYMBOL TABLE SPACE

GSTS   MACRO N
       LDA ESTS; SUB N(1); SKG PPEIP; FERR 5
       STA ESTS; CAX
       ENDM

* MACRO TO ACQUIRE CODEBF SPACE

GTS    MACRO N
       LDA ETS; ADD N(1); SKG =ECODBF; BRU *+2
       SBRM GTS; XMA ETS; CAX
       ENDM



* MACRO TO GENERATE LOCAL VARIABLE SAVES FOR A RECOGNIZER
SAVE   MACRO D
Q      NARG
       DATA -2B7-Q-1
       RPT (Q1=1,Q); DATA D(Q1); ENDR
       ENDM


* TRUE RETURN
TRET   MACRO D; RECTR D(1); ENDM
* FALSE RETURN
FRET   MACRO D; RECFR D(1); ENDM




NEXT   MACRO D; MIN INPUT; ENDM
PREV   MACRO D; SKR INPUT; ENDM
CBF    MACRO D; LDA D(1); SKE* INPUT; RBRU D(2); ENDM
CBT    MACRO D; LDA D(1); SKE* INPUT; BRU *+2; RBRU D(2); ENDM
RBF    MACRO D; REC D(1); RBRU D(2); ENDM
RBT    MACRO D; REC D(1); BRU *+2; RBRU D(2); ENDM

RBRU   MACRO D;Q1 EQU '   D(1$1)'; IF Q1>'   0'-1; IF Q1<'   9'+1
       CERR D(1); ELSE; BRU D(1); ENDF; ELSE; BRU D(1); ENDF; ENDM


TEBRS  MACRO D; SBRM TEBCH; BRU D(1); ENDM



* MACRO TO CALL APPINS POP
APINS  MACRO D; LDB D(3); IF 'D(2$1)'#':'; LDA D(2)
       ENDF; APPINS D(1); ENDM


* MACRO TO CALL APPIF POP
APIF   MACRO D; LDB D(3); IF 'D(2$1)'#':'; LDA D(2)
       ENDF; APPIF D(1); ENDM



* MACRO TO CALL APPINS POP FOR COMPILING AN INSTRUCTION WITH THE ADDRESS
* IN A DESCRIPTOR
APIA   MACRO D; CLB; LDX D(1);Q1 NARG; IF Q1>1; LDA D(2);
       ENDF; MRG ADDR,2; APPINS D(1); ENDM

APIXA  MACRO D; LDA =-1; XMA ADDR,2; MRG D(2); CLB; APPINS D(1); ENDM


APISA  MACRO D; LDA D(2); MRG D(3); CLB; APPINS D(1); ENDM



* MACRO TO CALL APPCOD
APCODE MACRO D; LDX D(2); APPCOD D(1); ENDM

APP    MACRO D; LDX D(2); APPCOD D(1); ENDM


* RETURN FROM SUBROUTINE CALLED WITH 'C'

R1     MACRO; BRU R1; ENDM

R2     MACRO; BRU R2; ENDM

CR1    MACRO X; BRU X(1); ENDM

* PARAMETERS

LINBUF EQU 256 LENGTH OF FILE INPUT BUFFER
LBPBUF EQU 256 LENGTH OF BINARY OUTPUT BUFFER
PSYMHT EQU 10  LOG2(SIZE OF SYMBOL HASH TABLE)
PCONHT EQU 9   LOG2(SIZE OF CONSTANT HASH TABLE)
LTMPBF EQU 120 LENGTH OF TEMP. STORAGE LOC. POINTERS BUFFER
LFGTBF EQU 6   LENGTH OF 'FRGT' BUFFER
NLCTRS EQU 16  NUMBER OF LOCATION COUNTERS
*
NSPSHT EQU 24-10-PSYMHT
LSYMHT EQU 2↑PSYMHT
NSPCHT EQU 24-10-PCONHT
LCONHT EQU 2↑PCONHT


       FREEZE

QS     IDENT

* GLOBAL STORAGE
$DBYTE BSS 1   P-R BYTE FOR DRIVER (PAGE 1)
$CBYTE BSS 1   P-R BYTE FOR PAGE 1 OF COMPILER
$INFIL BSS 1   TEXT INPUT FILE
$BINFIL BSS 1  BINARY OUTPUT FILE
$SBINFL BSS 1  PERMANENT BINARY OUTPUT FILE
$LSTFIL BSS 1  LISTING FILE
$SLSTFL BSS 1  PERMANENT LISTING FILE
$ELSTFL BSS 1  ERROR LISTING FILE
$ILSTFL BSS 1  SOURCE STATEMENT LISTING FILE FOR ERROR
$LSTUIV BSS 1  LIST UNINITIALIZED VARIABLES IF <0
$LSTEXT BSS 1  MAKE UNDECLARED SYMBOLS EXTERNAL IF >=0
$TLSTFL BSS 1  SAVE LSTFIL WHILE PRINTING ERROR
$LSTLBL BSS 1  SYMTAB POINTER FOR LAST LABEL OR -1
$INLCNT BSS 1  INPUT LINE COUNTER
$INLTCT BSS 1  SAVE INLCNT AT START OF PREPROCESSING
$LBLLCT BSS 1  INLCNT WHEN LSTLBL ENCOUNTERED
$NERRS BSS 1   NUMBER OF ERRORS
$TSLC  BSS 1   LC NUMBER FOR TS, LEFTSHIFTED 16
$OTSLC BSS 1   CURRENT ALC, LEFTSHIFTED 16
$TSLV  BSS NLCTRS  TEMPORARY STORAGE LCS (0=PROGRAM)
$ETSLV BSS 0
$TSLA  BSS NLCTRS  TEMPORARY STORAGE LC NAMES (0 NOT USED)
$ETSLA BSS 0

* LOCAL STORAGE FOR CODE OUTPUT
$CERRA BSS 2   SAVE (AB) FOR CERR
$CERRX BSS 1   SAVE (X) FOR CERR
$ITIME BSS 1   STARTING TIME OF COMPILATION
$CBT   BSS 2   TEMPORARY FOR OCW
$CBT1  EQU CBT+1
$CBM   BSS 1   SYMBOL MODE FLAG
$CBC   BSS 1   WORD COUNTER IN CBF
$CBF   BSS 9   CODE OUTPUT BUFFER
$CBE   EQU CBF+9
$CBL   EQU TSLV  CURRENT LOCATION
$CBP   BSS 1   BPBUF POINTER (NEGATIVE)
$FGTBUF BSS LFGTBF*2  'FRGT' BUFFER
$EFGTBF BSS 0
$FGTPTR BSS 1  POINTER TO NEXT ENTRY IN FGTBUF
$LSC   BSS 1   CHARACTER COUNT ON OUTPUT LINE
$LSS   BSS 1   TEMPORARY FOR SYMBOL BEING LISTED
$LSO   BSS 1   OPCODE BEING WRITTEN ON LISTING
$OLP   BSS 1   POINTER IN CODE LIST FOR OLS
$OLX   BSS 1   CURRENT (X) IN BINARY PROGRAM
$OLA   BSS 1   CURRENT (A) IN BINARY PROGRAM
$OLC   BSS 1   WORD COUNT FOR DATA STRING
$OLQ   BSS 1   POINTER TO DATA STRING
$OIDA  BSS 1   VALUE FOR IDENT
$OIDX  BSS 1   SYMBOL POINTER FOR IDENT
$TCLT  BSS 1   SAVE (A) FOR TCL
$WAF   BSS 1   ASC/DATA FLAG
$WAPT  BSS 3   OLD VALUE OF WAP
$WAP   EQU WAPT+1  STRING POINTER TO DATA STRING
$WAP1  EQU WAP+1
$WILT  BSS 1   INSTRUCTION TYPE FOR WIL
$WILP  BSS 1   CODE LIST POINTER FOR WIL
$TMPMAX BSS 1  MAXIMUM TEMPORARY NUMBER
$TMPORG BSS 1  TEMPORARY STORAGE ORIGIN
$SCP   BSS 1   SYMBOL TABLE SCAN POINTER FOR SCT
$SCE   BSS 1   END OF SYMBOL TABLE
$SCS   BSS 1   SUBROUTINE FOR SCT
$WLP   BSS 1   POINTER TO LITERAL OR SYMBOL BEING WRITTEN
$USL   BSS 1   SAVE LSTFIL FOR UNDEFINED SYMBOL LISTING
$USF   BSS 1   UNDEFINED SYMBOL FLAG
$RYTP  BSS 1   END OF SORTED SYMBOL TABLE
$ESYMPX BSS 1  END OF SYMPT,2
$ESYMTX BSS 1  END OF SYMHT,2
$NSYMTX BSS 1  -LENGTH OF SYMHT
$CYTI  BSS 1   PASS NUMBER
$CYTP  BSS 1   TEMPORARY FOR SYMHT INDEX
$CYTL  BSS 1   LOAD INSTRUCTION
$CYTS  BSS 1   SHIFT INSTRUCTION
$CYTU  BSS 1   LINEAR SCAN POINTER
$MPP   BSS 1   MINI-PUSHDOWN POINTER
$MPL   BSS 20  MINI-PUSHDOWN LIST
* LOCAL STORAGE FOR DRIVER
$NLIT  BSS 1   NUMBER OF LITERALS
$NULIT BSS 1   NUMBER OF UNUSED LITERALS
$NLIW  BSS 1   NUMBER OF LABEL INDIRECT WORDS
$NFAIW BSS 1   NUMBER OF FUNCTION/ARRAY INDIRECT WORDS
$FTT   BSS 1   FILE TYPE FOR CIFN,COFN
$FNPP  BSS 1   POINTER TO CURRENT END OF FNPT TABLE
$FNPT  BSS 16  STRING POINTERS TO FILE NAMES
$FNP0  EQU FNPT
$FNP1  EQU FNPT+2
$FNP2  EQU FNPT+4
$FNSS  BSS 50  STRING STORAGE FOR FILE NAMES
$TFNPP BSS 1   TEMPORARY FOR FNPT POINTER
$GMAPA BSS 2   SAVE (AB) FOR GDRIV,GCOMP
$GMAPT BSS 1   P-R BYTE FOR GDRIV,GCOMP
$RBTL  BSS 1   SAVE (P),
$RBTM  BSS 2   MAP,
$RBTA  BSS 2   (AB),
$RBTB  EQU RBTA+1
$RBTX  BSS 1   (X) FOR RUBOUT
$RBTFLG BSS 1  -1 IF NO CHAR TYPED SINCE RUBOUT

* SUBROUTINE LINKS FOR DRIVER
$XRELM BSS 1   LINK FOR CIFN,COFN,RESET,CCCR
$XRELP BSS 1   LINK FOR RELMAP,CTRY
$XGMAP BSS 1   LINK FOR GDRIV,GCOMP

* STORAGE FOR COMPILER PROPER

BSR    LMACRO N
N(0)   EQU CBSTS
CBSTS  EQU CBSTS+N(1)
       ENDM
DEF    MACRO L
Q2     NARG
       RPT (Q1=1,Q2)
$L(Q1) BSS 1
       ENDR
       ENDM
* ORIGIN OF UPPER CORE VARIABLE STORAGE
$CBSTS EQU 24000B

* STORAGE FOR PP

* BLOCK INPUT BUFFER
$INBUF BSR LINBUF
$EINBUF BSR 2
$SINBUF BSR 50

       DEF WIP,CIP,ENDIFL,INWCNT,INCLEV
       DEF IWIP,ICIP,IGICC
       DEF PPFPI,PPFP,PPFP1,PPFP2,PPFP0
       DEF PPBIP,PPEIP,PPCNT,PPNC,PPOVC
       DEF PPT1,PPT2,PPT3,PPT4,PPT5,SCFLG
       DEF PPMAC,PPLEV,PPEF,PPARGS,PPAP,PPABP
       DEF GNCT1,GNCT2,GNCT3
$PPFS  BSS 10
$PPEFS BSS 0

       DEF SYMBUF,SYMBF1

* SYMBOL HASH TABLE
$SYMHT BSR LSYMHT
$ESYMHT BSR 0

* CONSTANT HASH TABLE
$CONHT BSR LCONHT
$ECONHT BSR 0

* BINARY OUTPUT BUFFER
$BPBUF BSR LBPBUF
$EBPBUF BSR 0





* BUFFER FOR TEMPORARY STORAGE LOCATION POINTERS

$TEMPBF BSS LTMPBF
$ETMPBF BSS 1
       DEF TEMPTR,MAXTP

* TRANSFER ADDRESS COUNTER
       DEF TADRC


* STORAGE FOR RECOGNIZER STACK
$RECSTK BSS 500
$ERECST BSS 1

* BUFFER FOR CODE LIST
$CODEBF BSS 800
$ECODBF BSS 1

* TABLES FOR SYMBOL TABLE SORT
$CYTT  EQU RECSTK
$CYTTE EQU CYTT+100B
$SYMPT EQU CYTTE
*** LENGTH OF RECSTK+CODEBF MUST BE >= LSYMHT+100B ***


* STORAGE
       DEF BSYT,ESYT,NARRAY,NFTLER
       DEF LSTATF,IDENT,COMFLG,INITF,STEMPF
       DEF RSTK,WSTK,CODE,FRETL,FRETL1,LCTR,ECRCNT
       DEF RRL,SRRL,RFFLG
       DEF FTFLG,FTBADR
       DEF ESTS,ETS,INPUT,MAXTMP,TEMPB,PTADRF
       DEF OP1,OP2,PT1,PT2,PT3,PT4
       DEF CPT1,CPT2,CPT3,CPT4
       DEF DECT1,DECT2,DECT3,DECT4,DECT5,DECT6
       DEF DECT7,DECT8,DECT9,DECT10,DECT11,DECT12
       DEF DECT13,DECT14,DECT15,DECT16
       DEF DECXF
       DEF FLDT1,FLDT2
       DEF FVALT1,FVALT2,FVALT3,FVALT4,FVALT5,FVALT6,FVALT7,FVALT8
       DEF FVALT9,FVLT10,FVLT11
       DEF FXFRT1,FXFRT2,FXFRT3,FXFRT4
       DEF FEBT1,FEBT2,FEBT3
       DEF INT1,INT2,LKST1,LKST2,LKST3,LKST4,LKST5
       DEF MCONT1,MCONT2,MCONT3,MCONT4,MCONT5,MCONT6
       DEF RBLT1,RBLT2,RBLT3,RECT1,RECT2
       DEF RBST1,RBST2,RBST3,RBST4,RBST5,INPT1,INPT2,INPT3
       DEF SPPT1,GINT1,GINT2,PERST1,PERST2
       DEF TTADR,FTADR,CERRT1,CERRT2,FERRT1,ENDBT1
       DEF RETYPE
       DEF FA0,FA1,FA2,FA3,FA4,FA5,FA6,FA7,FA8,FN
       DEF FAREC,CARGCW,ARGCNT,ARGSET,ARGLST,ARGCW
       DEF EXAST1,EXAST2,GTRGT1,GTRGT2
       DEF GTMPT1,LSFLG,RELOP,SFLG,SSTAIL
       DEF SFT1,SFT2,SFT3,SWOPT1,SWOPT2
       DEF XPRT3,XPRT4,XPRT5,XPRT6,VFLAGS
       DEF FADRT1,FADRT2,CSAT1,CSAT2,APPT1,GTST1
       DEF XFDT1,XFDT2,XFDT3,XFDT4,XFDT5,XFDT6,XFDT7,XFDT8
       DEF XFDT0,XFDT9,XFDT10,XFDT11,XFDT12,XFDT13
       DEF GRWFT1,CMXFT1,GPFT1,GFLDT1,CIIT1,APFTT1,CSRFT1
       DEF MCCT1,MCCT2,CSCT1,CSCT2,CSCT3,CSCT4
       DEF DECSD,T,RESULT
       DEF FORCOD,FORLL,FORELL,FORVAR,FORT1,FORINC,FORICF,XSFOR,FOROUT
       DEF FORSTK,IFSTK

       END
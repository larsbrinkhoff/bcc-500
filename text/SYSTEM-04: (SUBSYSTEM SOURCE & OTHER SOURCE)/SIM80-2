        PROGRAM GET'REG;
*
*  THIS PROGRAM WILL FETCH THE REGISTER (NUMBERED 0 - 7) AND RETURN
*  ITS CONTENTS.
*

         INCLUDE SIMU'VARS, FIELD'DESC;

         DECLARE INTEGER
         I1,
         REG;

         DECLARE LABEL ARRAY CASE[8] ←
         (CASE0, CASE1, CASE2, CASE3, CASE4, CASE5, CASE6, CASE7);

         FUNCTION GET'REG(REG), FRETURN;

/*     HELP() IF REG < 0 OR REG > 7; */

         GOTO CASE[REG];

         CASE0:
        RETURN REG'AREA.REG'B;
        CASE1:
        RETURN REG'AREA.REG'C;
        CASE2:
        RETURN REG'AREA.REG'D;
        CASE3:
        RETURN REG'AREA.REG'E;
        CASE4:
        RETURN REG'AREA.REG'H;
        CASE5:
        RETURN REG'AREA.REG'L;
        CASE6:
        I1 ← GET'M(REG'AREA.REG'H'L// FRETURN);
        RETURN I1;
        CASE7:
        RETURN REG'AREA.REG'A;

         END;  /*  END GET'REG.  */
        PROGRAM INTERP;
*
*  THIS IS THE FUNCTION WILL ACTUALLY DOES ALL OF THE INTERPRETATION
*  AND DECODING OF 8080 MACHINE INSTRUCTIONS.  IT DECIDES VIA A DO-
*  CASE LOOP WHAT FUNCTIONS AND WHAT OPERATIONS ARE TO BE CARRIED
*  OUT.
*

         INCLUDE SIMU'VARS, FIELD'DESC, SPECIAL'CHARS, MONITOR'CALLS;

         UNKNOWN UTILITY START'OUTPUT ← 47;        * DUMP OUTPUT BUFFER
        UNKNOWN UTILITY PRINT'CHAR ← 46;          * WRITE CHAR ON CIOS
        CHARACTER UTILITY READ'CHAR ← 50;

         DECLARE PARAMETER
         TTY'STATUS ← 3,
         TTY'DATA ← 2;

         DECLARE INTEGER
         I1, I2, I3, I4,    /*  TEMPORARY VARIABLES.  */
         ERROR'1,ERROR'2,  /*   FOR ERROR PURPOSES  */
         PAU;              /*  FINISHED FLAG  */


         DECLARE LABEL ARRAY INSTR'BRANCH[256] ←
         (NOP,LXI'B,STAX'B,INX'B,INR'B,DCR'B,MVI'B,RLC);
        DECLARE LABEL ARRAY INSTR'BRANCH[8] ←
         (BREAK'POINT,DAD'B,LDAX'B,DCX'B,INR'C,DCR'C,MVI'C,RRC);
        DECLARE LABEL ARRAY INSTR'BRANCH[16] ←
         (TRAP,LXI'D,STAX'D,INX'D,INR'D,DCR'D,MVI'D,RAL);
        DECLARE LABEL ARRAY INSTR'BRANCH[24] ←
         (TRAP,DAD'D,LDAX'D,DCX'D,INR'E,DCR'E,MVI'E,RAR);
        DECLARE LABEL ARRAY INSTR'BRANCH[32] ←
         (TRAP,LXI'H,SHLD,INX'H,INR'H,DCR'H,MVI'H,DAA);
        DECLARE LABEL ARRAY INSTR'BRANCH[40] ←
         (TRAP,DAD'H,LHLD,DCX'H,INR'L,DCR'L,MVI'L,CMA);
        DECLARE LABEL ARRAY INSTR'BRANCH[48] ←
         (TRAP,LXI'SP,STA,INX'SP,INR'M,DCR'M,MVI'M,STC);
        DECLARE LABEL ARRAY INSTR'BRANCH[56] ←
         (TRAP,DAD'SP,LDA,DCX'SP,INR'A,DCR'A,MVI'A,CMC);
        DECLARE LABEL ARRAY INSTR'BRANCH[64] ←
         (MOV'B'B,MOV'B'C,MOV'B'D,MOV'B'E,MOV'B'H,MOV'B'L,MOV'B'M,MOV'B'A);
        DECLARE LABEL ARRAY INSTR'BRANCH[72] ←
         (MOV'C'B,MOV'C'C,MOV'C'D,MOV'C'E,MOV'C'H,MOV'C'L,MOV'C'M,MOV'C'A);
        DECLARE LABEL ARRAY INSTR'BRANCH[80] ←
         (MOV'D'B,MOV'D'C,MOV'D'D,MOV'D'E,MOV'D'H,MOV'D'L,MOV'D'M,MOV'D'A);
        DECLARE LABEL ARRAY INSTR'BRANCH[88] ←
         (MOV'E'B,MOV'E'C,MOV'E'D,MOV'E'E,MOV'E'H,MOV'E'L,MOV'E'M,MOV'E'A);
        DECLARE LABEL ARRAY INSTR'BRANCH[96] ←
         (MOV'H'B,MOV'H'C,MOV'H'D,MOV'H'E,MOV'H'H,MOV'H'L,MOV'H'M,MOV'H'A);
        DECLARE LABEL ARRAY INSTR'BRANCH[104] ←
         (MOV'L'B,MOV'L'C,MOV'L'D,MOV'L'E,MOV'L'H,MOV'L'L,MOV'L'M,MOV'L'A);
        DECLARE LABEL ARRAY INSTR'BRANCH[112] ←
         (MOV'M'B,MOV'M'C,MOV'M'D,MOV'M'E,MOV'M'H,MOV'M'L,HLT,MOV'M'A);
        DECLARE LABEL ARRAY INSTR'BRANCH[120] ←
         (MOV'A'B,MOV'A'C,MOV'A'D,MOV'A'E,MOV'A'H,MOV'A'L,MOV'A'M,MOV'A'A);
        DECLARE LABEL ARRAY INSTR'BRANCH[128] ←
         (ADD'B,ADD'C,ADD'D,ADD'E,ADD'H,ADD'L,ADD'M,ADD'A);
        DECLARE LABEL ARRAY INSTR'BRANCH[136] ←
         (ADC'B,ADC'C,ADC'D,ADC'E,ADC'H,ADC'L,ADC'M,ADC'A);
        DECLARE LABEL ARRAY INSTR'BRANCH[144] ←
         (SUB'B,SUB'C,SUB'D,SUB'E,SUB'H,SUB'L,SUB'M,SUB'A);
        DECLARE LABEL ARRAY INSTR'BRANCH[152] ←
         (SBB'B,SBB'C,SBB'D,SBB'E,SBB'H,SBB'L,SBB'M,SBB'A);
        DECLARE LABEL ARRAY INSTR'BRANCH[160] ←
         (ANA'B,ANA'C,ANA'D,ANA'E,ANA'H,ANA'L,ANA'M,ANA'A);
        DECLARE LABEL ARRAY INSTR'BRANCH[168] ←
         (XRA'B,XRA'C,XRA'D,XRA'E,XRA'H,XRA'L,XRA'M,XRA'A);
        DECLARE LABEL ARRAY INSTR'BRANCH[176] ←
         (ORA'B,ORA'C,ORA'D,ORA'E,ORA'H,ORA'L,ORA'M,ORA'A);
        DECLARE LABEL ARRAY INSTR'BRANCH[184] ←
         (CMP'B,CMP'C,CMP'D,CMP'E,CMP'H,CMP'L,CMP'M,CMP'A);
        DECLARE LABEL ARRAY INSTR'BRANCH[192] ←
         (RNZ,POP'B,JNZ,JMP,CNZ,PUSH'B,ADI,RST'0);
        DECLARE LABEL ARRAY INSTR'BRANCH[200] ←
         (RZ,RET,JZ,TRAP,CZ,CALL,ACI,RST'1);
        DECLARE LABEL ARRAY INSTR'BRANCH[208] ←
         (RNC,POP'D,JNC,OUT,CNC,PUSH'D,SUI,RST'2);
        DECLARE LABEL ARRAY INSTR'BRANCH[216] ←
         (RC,TRAP,JC,IN,CC,TRAP,SBI,RST'3);
        DECLARE LABEL ARRAY INSTR'BRANCH[224] ←
         (RPO,POP'H,JPO,XTHL,CPO,PUSH'H,ANI,RST'4);
        DECLARE LABEL ARRAY INSTR'BRANCH[232] ←
         (RPE,PCHL,JPE,XCHG,CPE,TRAP,XRI,RST'5);
        DECLARE LABEL ARRAY INSTR'BRANCH[240] ←
         (RP,POP'PSW,JP,DI,CP,PUSH'PSW,ORI,RST'6);
        DECLARE LABEL ARRAY INSTR'BRANCH[248] ←
         (RM,SPHL,JM,EI,CM,TRAP,CPI,RST'7);



         FUNCTION INTERP(SINGLE'STEP), FRETURN;

         FOR I1 ← 0 TO 30
         DO;
            DEL'PAGE'CWS(-1// GOTO L1:ERROR'1,ERROR'2);
            L1:
        ENDFOR;
        PAU ← 0;

         WHILE NOT PAU
         DO;
            CURRENT'INSTR ← GET'M(P'COUNTER// FRETURN);
            PAU ← SINGLE'STEP;
            GOTO INSTR'BRANCH[CURRENT'INSTR];

             BREAK'POINT:
            B'P'HANDLER();
            RETURN;

             TRAP:
            ERROR'MESSAGE(1);
            FRETURN;

OUT:

             I1 ← GET'M(P'COUNTER+1// FRETURN);
            IF I1 = TTY'DATA
             DO;
                I1 ← REG'AREA.REG'A;
                IF I1 = 10
                 DO;  /*  OUTPUT A LINE FEED  */
                I1 ← LF;
                ELSEIF I1 = 13
                 DO;
                    I1 ← CR;
                ELSE
                 DO;  /*  MUST BE A REGULAR CHARACTER  */
                I1 ← I1 - 40B;
                ENDIF;
                PRINT'CHAR(-1, I1, 0//
                 ERROR'MESSAGE(8) & FRETURN : I1, I2, I3);
                START'OUTPUT(-1,0//ERROR'MESSAGE(8) & FRETURN : I1, I2);
            ELSEIF I1 = TTY'STATUS
             DO;
            ELSE
             DO;
                ERROR'MESSAGE(4);
                FRETURN;
            ENDIF;
            GOTO COM;

IN:

             I1 ← GET'M(P'COUNTER+1// FRETURN);
            IF I1 = TTY'DATA
             DO;
                I1 ← READ'CHAR(-1, 0// ERROR'MESSAGE(7) & FRETURN :
                 I1, I2);
                REG'AREA.REG'A ← I1 + 40B;
*           CARRIAGE RETURN
                 REG'AREA.REG'A ← 13 IF I1 = 199;
*           LINE FEED
                 REG'AREA ← 10 IF I1 = 200;
            ELSEIF I1 = TTY'STATUS
             DO;
                REG'AREA.REG'A ← 377B;
            ELSE
             DO;
                ERROR'MESSAGE(4);
                FRETURN;
            ENDIF;

             GOTO COM;

NOP:

             GOTO COM;

RST'0:       RST'1:RST'2:RST'3:RST'4:RST'5:RST'6:RST'7:

             RST'ADDRS(// FRETURN);
            GOTO COM;

HLT:
            ERROR'MESSAGE(5);
            P'COUNTER ← P'COUNTER+1;
            FRETURN;

DI:          EI:
            ERROR'MESSAGE(6);
            FRETURN;

             STA:

             I1$B'16'23 ← GET'M(P'COUNTER+1// FRETURN);
            I1$B'8'15 ← GET'M(P'COUNTER+2// FRETURN);
            PUT'M(REG'AREA.REG'A, I1// FRETURN);
            GOTO COM;

             LDA:
            I1$B'16'23 ← GET'M(P'COUNTER+1// FRETURN);
            I1$B'8'15 ← GET'M(P'COUNTER+2// FRETURN);
            REG'AREA.REG'A ← GET'M(I1// FRETURN);
            GOTO COM;

             SHLD:
            I1$B'16'23 ← GET'M(P'COUNTER+1// FRETURN);
            I1$B'8'15 ← GET'M(P'COUNTER+2// FRETURN);
            PUT'M(REG'AREA.REG'L, I1// FRETURN);
            PUT'M(REG'AREA.REG'H,I1+1// FRETURN);
            GOTO COM;

             LHLD:

             I1$B'16'23 ← GET'M(P'COUNTER+1// FRETURN);
            I1$B'8'15 ← GET'M(P'COUNTER+2// FRETURN);
            REG'AREA.REG'L ← GET'M(I1// FRETURN);
            REG'AREA.REG'H ← GET'M(I1+1// FRETURN);
            GOTO COM;

*      ALL MOV INSTRUCTIONS.

MOV'A'A:     MOV'A'B:MOV'A'C:MOV'A'D:MOV'A'E:MOV'A'H:MOV'A'L:MOV'A'M:
MOV'B'A:    MOV'B'B:MOV'B'C:MOV'B'D:MOV'B'E:MOV'B'H:MOV'B'L:MOV'B'M:
MOV'C'A:    MOV'C'B:MOV'C'C:MOV'C'D:MOV'C'E:MOV'C'H:MOV'C'L:MOV'C'M:
MOV'D'A:    MOV'D'B:MOV'D'C:MOV'D'D:MOV'D'E:MOV'D'H:MOV'D'L:MOV'D'M:
MOV'E'A:    MOV'E'B:MOV'E'C:MOV'E'D:MOV'E'E:MOV'E'H:MOV'E'L:MOV'E'M:
MOV'H'A:    MOV'H'B:MOV'H'C:MOV'H'D:MOV'H'E:MOV'H'H:MOV'H'L:MOV'H'M:
MOV'L'A:    MOV'L'B:MOV'L'C:MOV'L'D:MOV'L'E:MOV'L'H:MOV'L'L:MOV'L'M:
MOV'M'A:    MOV'M'B:MOV'M'C:MOV'M'D:MOV'M'E:MOV'M'H:MOV'M'L:

             I1 ← GET'REG(CURRENT'INSTR$B'21'23// FRETURN);
            PUT'REG(I1, CURRENT'INSTR$B'18'20// FRETURN);
            GOTO COM;

*      ALL MVI INSTRUCTIONS.

MVI'A:       MVI'B:MVI'C:MVI'D:MVI'E:MVI'H:MVI'L:MVI'M:

             PUT'REG(GET'M(P'COUNTER+1// FRETURN), CURRENT'INSTR$B'18'20// FRETURN);
            GOTO COM;

             PCHL:

             PCHL'ADDR();
            GOTO COM;

             SPHL:
            STACK$B'8'15 ← REG'AREA.REG'H;
            STACK$B'16'23 ← REG'AREA.REG'L;
            GOTO COM;

             XTHL:

             I1 ← GET'M(STACK// FRETURN);
            PUT'M(REG'AREA.REG'L, STACK// FRETURN);
            REG'AREA.REG'L ← I1;
            I1 ← GET'M(STACK+1// FRETURN);
            PUT'M(REG'AREA.REG'H, STACK+1// FRETURN);
            REG'AREA.REG'H ← I1;
            GOTO COM;

             XCHG:

             I1 ← REG'AREA.REG'D'E;
            REG'AREA.REG'D'E ← REG'AREA.REG'H'L;
            REG'AREA.REG'H'L ← I1;
            GOTO COM;

             CMA:

             REG'AREA.REG'A ← N' REG'AREA.REG'A;
            GOTO COM;

             STC:
            REG'AREA.CARRY'BIT ← 1;
            GOTO COM;

             CMC:
            REG'AREA.CARRY'BIT ← N' REG'AREA.CARRY'BIT;
            GOTO COM;

             PUSH'B:
            PUSH'D:
            PUSH'H:

             I1 ← GET'D(CURRENT'INSTR$B'18'19);
            PUT'M(I1$B'8'15, STACK - 1// FRETURN);
            PUT'M(I1$B'16'23, STACK - 2// FRETURN);
            STACK ← STACK - 2;
            GOTO COM;

             PUSH'PSW:

             PUT'M(REG'AREA.REG'A,STACK-1// FRETURN);
            PUT'M(REG'AREA.PSW,STACK-2// FRETURN);
            STACK ← STACK-2;
            GOTO COM;

             POP'B:
            POP'D:
            POP'H:
            I1$B'16'23 ← GET'M(STACK// FRETURN);
            I1$B'8'15 ← GET'M(STACK+1// FRETURN);
            STACK ← STACK + 2;
            PUT'D(I1, CURRENT'INSTR$B'18'19);
            GOTO COM;

             POP'PSW:

             REG'AREA.PSW ← GET'M(STACK// FRETURN);
            REG'AREA.REG'A ← GET'M(STACK+1// FRETURN);
            STACK ← STACK + 2;
            GOTO COM;

             RLC:

             I1 ← REG'AREA.REG'A;
            I1 ← I1 LCY 1;
            I1$B'23'23 ← I1$B'15'15;
            REG'AREA.REG'A ← I1;
            REG'AREA.CARRY'BIT ← I1$B'15'15;
            GOTO COM;

             RRC:

             I1 ← REG'AREA.REG'A;
            REG'AREA.CARRY'BIT ← I1$B'23'23;
            I1 ← I1 RCY 1;
            I1$B'16'16 ← REG'AREA.CARRY'BIT;
            REG'AREA.REG'A ← I1;
            GOTO COM;

             RAL:

             I1 ← REG'AREA.REG'A;
            I1 ← I1 LSH 1;
            I1$B'23'23 ← REG'AREA.CARRY'BIT;
            REG'AREA.CARRY'BIT ← I1$B'15'15;
            REG'AREA.REG'A ← I1;
            GOTO COM;

             RAR:
            I1 ← REG'AREA.REG'A;
            I1$B'15'15 ← REG'AREA.CARRY'BIT;
            REG'AREA.CARRY'BIT ← I1$B'23'23;
            I1 ← I1 RSH 1;
            REG'AREA.REG'A ← I1;
            GOTO COM;

             RET:

             RET'P(// FRETURN);
            GOTO COM;

             RNZ:

             RET'P(// FRETURN) IF REG'AREA.ZERO'BIT # 1;
            GOTO COM;

             RZ:

             RET'P(// FRETURN) IF REG'AREA.ZERO'BIT = 1;
            GOTO COM;
            RNC:

             RET'P(// FRETURN) IF REG'AREA.CARRY'BIT # 1;
            GOTO COM;

             RC:

             RET'P(// FRETURN) IF REG'AREA.CARRY'BIT = 1;
            GOTO COM;

             RPO:

             RET'P(// FRETURN) IF REG'AREA.PARITY'BIT # 1;
            GOTO COM;

             RPE:

             RET'P(// FRETURN) IF REG'AREA.PARITY'BIT = 1;
            GOTO COM;

             RP:

             RET'P(// FRETURN) IF REG'AREA.SIGN'BIT = 0;
            GOTO COM;

             RM:

             RET'P(// FRETURN) IF REG'AREA.SIGN'BIT = 0;
            GOTO COM;

             ADI:
            ADD(GET'M(P'COUNTER+1// FRETURN));
            GOTO COM;

             ACI:
            ADC(GET'M(P'COUNTER+1// FRETURN));
            GOTO COM;

             SUI:
            SUB(GET'M(P'COUNTER+1// FRETURN));
            GOTO COM;

             SBI:
            SBB(GET'M(P'COUNTER+1// FRETURN));
            GOTO COM;

             ANI:

             ANA(GET'M(P'COUNTER+1// FRETURN));
            GOTO COM;
            XRI:

             XRA(GET'M(P'COUNTER+1// FRETURN));
            GOTO COM;

             ORI:

             ORA(GET'M(P'COUNTER+1// FRETURN));
            GOTO COM;

             CPI:

             CMP(GET'M(P'COUNTER+1// FRETURN));
            GOTO COM;

*      THIS SECTION CONTAINS ALL 'ADD' INSTRUCTIONS.

ADD'A:       ADD'B:ADD'C:ADD'D:ADD'E:ADD'H:ADD'L:ADD'M:

             ADD(GET'REG(CURRENT'INSTR$B'21'23// FRETURN));
            GOTO COM;

*      THIS SECTION CONTAINS ALL 'ADC' INSTRUCTIONS.

ADC'A:       ADC'B:ADC'C:ADC'D:ADC'E:ADC'H:ADC'L:ADC'M:

             ADC(GET'REG(CURRENT'INSTR$B'21'23// FRETURN));
            GOTO COM;

*      THIS SECTION CONTAINS ALL 'SBB' INSTRUCTIONS.

SBB'A:       SBB'B:SBB'C:SBB'D:SBB'E:SBB'H:SBB'L:SBB'M:

             SBB(GET'REG(CURRENT'INSTR$B'21'23// FRETURN));
            GOTO COM;

*      THIS SECTION CONTAINS ALL 'SUB' INSTRUCTIONS.

SUB'A:       SUB'B:SUB'C:SUB'D:SUB'E:SUB'H:SUB'L:SUB'M:

             SUB(GET'REG(CURRENT'INSTR$B'21'23// FRETURN));
            GOTO COM;

*      THIS SECTION CONTAINS ALL 'XRA' INSTRUCTIONS.

XRA'A:       XRA'B:XRA'C:XRA'D:XRA'E:XRA'H:XRA'L:XRA'M:

             XRA(GET'REG(CURRENT'INSTR$B'21'23// FRETURN));
            GOTO COM;

*      THIS SECTION CONTAINS ALL 'ORA' INSTRUCTIONS.

ORA'A:       ORA'B:ORA'C:ORA'D:ORA'E:ORA'H:ORA'L:ORA'M:

             ORA(GET'REG(CURRENT'INSTR$B'21'23// FRETURN));
            GOTO COM;

*      THIS SECTION CONTAINS ALL 'ANA' INSTRUCTIONS.

ANA'A:       ANA'B:ANA'C:ANA'D:ANA'E:ANA'H:ANA'L:ANA'M:

             ANA(GET'REG(CURRENT'INSTR$B'21'23// FRETURN));
            GOTO COM;

*      THIS SECTION CONTAINS ALL 'CMP' INSTRUCTIONS.

CMP'A:       CMP'B:CMP'C:CMP'D:CMP'E:CMP'H:CMP'L:CMP'M:

             CMP(GET'REG(CURRENT'INSTR$B'21'23// FRETURN));
            GOTO COM;

*      THIS SECTION CONTAINS ALL 'INX' INSTRUCTIONS.

INX'B:       INX'D:INX'H:INX'SP:

             I1 ← CURRENT'INSTR$B'18'19;
            PUT'D(GET'D(I1)+1, I1);
            GOTO COM;

*      THIS SECTION CONTAINS ALL 'DCX' INSTRUCTIONS.

DCX'B:       DCX'D:DCX'H:DCX'SP:

             I1 ← CURRENT'INSTR$B'18'19;
            PUT'D(GET'D(I1)-1,I1);
            GOTO COM;
*      THIS SECTION CONTAINS ALL 'DAD' INSTRUCTIONS.

DAD'B:       DAD'D:DAD'H:DAD'SP:

             I1 ← GET'D(CURRENT'INSTR$B'18'19)+REG'AREA.REG'H'L;
            REG'AREA.CARRY'BIT ← I1$B'7'7;
            REG'AREA.REG'H'L ← I1;
            GOTO COM;
*      THIS SECTION CONTAINS ALL 'LXI' INSTRUCTIONS.

LXI'B:       LXI'D:LXI'H:LXI'SP:

             I1$B'16'23 ← GET'M(P'COUNTER+1// FRETURN);
            I1$B'8'15 ← GET'M(P'COUNTER+2// FRETURN);
            PUT'D(I1,CURRENT'INSTR$B'18'19);
            GOTO COM;

*      THIS SECTION CONTAINS ALL 'LDAX' INSTRUCTIONS.

LDAX'B:      LDAX'D:

             REG'AREA.REG'A ← GET'M(GET'D(CURRENT'INSTR$B'19'19)// FRETURN);
            GOTO COM;
*      THIS SECTION CONTAINS ALL 'STAX' INSTRUCTIONS.

STAX'B:      STAX'D:

             PUT'M(REG'AREA.REG'A , GET'D(CURRENT'INSTR$B'19'19)// FRETURN);
            GOTO COM;

             CALL:

             CALL'ADDR(// FRETURN);
            GOTO COM;

             CNZ:

             CALL'ADDR(// FRETURN) IF REG'AREA.ZERO'BIT # 1;
            GOTO COM;

             CZ:

             CALL'ADDR(// FRETURN) IF REG'AREA.ZERO'BIT = 1;
            GOTO COM;
            CNC:

             CALL'ADDR(// FRETURN) IF REG'AREA.CARRY'BIT # 1;
            GOTO COM;

             CC:

             CALL'ADDR(// FRETURN) IF REG'AREA.CARRY'BIT = 1;
            GOTO COM;

             CPO:

             CALL'ADDR(// FRETURN) IF REG'AREA.PARITY'BIT # 1;
            GOTO COM;

             CPE:

             CALL'ADDR(// FRETURN) IF REG'AREA.PARITY'BIT = 1;
            GOTO COM;

             CP:

             CALL'ADDR(// FRETURN) IF REG'AREA.SIGN'BIT = 0;
            GOTO COM;

             CM:

             CALL'ADDR(// FRETURN) IF REG'AREA.SIGN'BIT = 1;
            GOTO COM;

             JMP:

             JUMP(// FRETURN);
            GOTO COM;

             JNZ:

             JUMP(// FRETURN) IF REG'AREA.ZERO'BIT # 1;
            GOTO COM;

             JZ:

             JUMP(// FRETURN) IF REG'AREA.ZERO'BIT = 1;
            GOTO COM;
            JNC:

             JUMP(// FRETURN) IF REG'AREA.CARRY'BIT # 1;
            GOTO COM;

             JC:

             JUMP(// FRETURN) IF REG'AREA.CARRY'BIT = 1;
            GOTO COM;

             JPO:

             JUMP(// FRETURN) IF REG'AREA.PARITY'BIT # 1;
            GOTO COM;

             JPE:

             JUMP(// FRETURN) IF REG'AREA.PARITY'BIT = 1;
            GOTO COM;

             JP:

             JUMP(// FRETURN) IF REG'AREA.SIGN'BIT = 0;
            GOTO COM;

             JM:

             JUMP(// FRETURN) IF REG'AREA.SIGN'BIT = 1;
            GOTO COM;

*      THIS SECTION CONTAINS ALL 'INR' INSTRUCTIONS.

INR'A:       INR'B:INR'C:INR'D:INR'E:INR'H:INR'L:INR'M:

             I1 ← GET'REG(CURRENT'INSTR$B'18'20// FRETURN);
            I2 ← I1 + 1;
            I3 ← I1$B'20'23 + 1;
            I4 ← REG'AREA.CARRY'BIT;
            SET'STATUS(I2,I3);
            REG'AREA.CARRY'BIT ← I4;
            PUT'REG(I2,CURRENT'INSTR$B'18'20// FRETURN);
            GOTO COM;

*      THIS SECTION CONTAINS ALL 'DCR' INSTRUCTIONS.

DCR'A:       DCR'B:DCR'C:DCR'D:DCR'E:DCR'H:DCR'L:DCR'M:

             I1 ← GET'REG(CURRENT'INSTR$B'18'20// FRETURN);
            I2 ← I1 - 1;
            I3 ← I1$B'20'23 - 1;
            I4 ← REG'AREA.CARRY'BIT;
            SET'STATUS(I2,I3);
            REG'AREA.CARRY'BIT ← I4;
            PUT'REG(I2,CURRENT'INSTR$B'18'20// FRETURN);
            GOTO COM;

             DAA:
            I1 ← REG'AREA.REG'A;
            IF I1$B'20'23 > 9 OR REG'AREA.AUX'CARRY = 1
             DO;
                I1 ← I1 + 6;
                I2 ← I1$B'20'23 + 6;
                SET'STATUS(0,I2);
            ELSEIF I1$B'16'19 > 6 OR REG'AREA.AUX'CARRY = 1
             DO;
                I1 ← I1 + 140B;
            ENDIF;
            SET'STATUS(I1, I2);
            GOTO COM;

*  COMMON POINT.

             COM:
            P'COUNTER ← P'COUNTER + INSTR'INCRE[CURRENT'INSTR];
        ENDFOR;  /*  END OF WHILE LOOP  */
        RETURN;

         END;  /*  END INTERP.  */

        PROGRAM MEMORY'ACCESS;
*
*  THIS BLOCK CONTROLS ALL ACCESS TO MEMORY REFERENCES BOTH
*  READ AND WRITE.
*

         INCLUDE SIMU'VARS, FIELD'DESC;

         DECLARE FIELD
         B'8'23(0:8,23);

         DECLARE INTEGER
         ARG1,
         DATA,
         ADDRS;

         FUNCTION PUT'M(DATA, ARG1), FRETURN;

         ADDRS ← ARG1$B'8'23;
        SETR(MEMORY, 0);
        SETW(MEMORY, ADDRS);
        WCI(DATA$B'16'23, MEMORY//ERROR'MESSAGE(2) & FRETURN);
        RETURN;

         FUNCTION GET'M(ARG1), FRETURN;

         ADDRS ← ARG1$B'8'23;
        SETS(MEMORY, ADDRS, MAX'MEM);
        DATA ← GCI(MEMORY//ERROR'MESSAGE(3) & FRETURN);
        RETURN DATA;

         END;  /* MEMORY'ACCESS  */

        PROGRAM PUT'D;
*
*  THIS FUNCTION IS USED TO STORE DOUBLE.
*

         INCLUDE SIMU'VARS, FIELD'DESC;

         DECLARE INTEGER
         DATA,
         RP;

         DECLARE LABEL ARRAY CASE[4] ←
         (CASE0,CASE1, CASE2, CASE3);

         FUNCTION PUT'D(DATA, RP);

/*    HELP() IF RP < 0 OR RP > 3; */
         GOTO CASE[RP];

CASE0:
        REG'AREA.REG'B'C ← DATA$B'8'23;
        RETURN;

CASE1:
        REG'AREA.REG'D'E ← DATA$B'8'23;
        RETURN;

CASE2:
        REG'AREA.REG'H'L ← DATA$B'8'23;
        RETURN;

CASE3:
        STACK$B'8'23 ← DATA$B'8'23;
        RETURN;

         END;  /*  END PUT'D  */

        PROGRAM PUT'REG;
*
*  THIS PROGRAM WILL DO THE OPPOSITE OF GET'REG.
*

         INCLUDE FIELD'DESC, SIMU'VARS;

         DECLARE LABEL ARRAY CASE[8] ←
         (CASE0, CASE1, CASE2, CASE3, CASE4, CASE5, CASE6, CASE7);

         DECLARE INTEGER
         DATA,
         REG;

         FUNCTION PUT'REG(DATA, REG), FRETURN;

/*    HELP() IF REG < 0 OR REG > 7; */

         GOTO CASE[REG];

         CASE0:
        REG'AREA.REG'B ← DATA$B'16'23;
        RETURN;

         CASE1:
        REG'AREA.REG'C ← DATA$B'16'23;
        RETURN;

         CASE2:
        REG'AREA.REG'D ← DATA$B'16'23;
        RETURN;

         CASE3:
        REG'AREA.REG'E ← DATA$B'16'23;
        RETURN;

         CASE4:
        REG'AREA.REG'H ← DATA$B'16'23;
        RETURN;

         CASE5:
        REG'AREA.REG'L ← DATA$B'16'23;
        RETURN;

         CASE6:
        PUT'M(DATA$B'16'23, REG'AREA.REG'H'L// FRETURN);
        RETURN;

         CASE7:
        REG'AREA.REG'A ← DATA$B'16'23;
        RETURN;

         END;  /*  END PUT'REG  */

        PROGRAM SET'STATUS;
*  THIS FUNCTION SETS THE STATUS OF THE 8080'S CONDITION
*  BITS AFTER AN ARITHMETIC OPERATION.
*

         INCLUDE SIMU'VARS, FIELD'DESC;

         DECLARE INTEGER
         I1, I2, I3, I4, I5;

         FUNCTION SET'STATUS(I1, I5);

         REG'AREA.SIGN'BIT ← I1$B'16'16;
        REG'AREA.ZERO'BIT ← 0;
        REG'AREA.ZERO'BIT ← 1 IF I1$B'16'23 = 0;
        I4 ← I1;
        I3 ← 0;
        FOR I2 ← 1 TO 8
         DO;
            I3 ← I3 + 1 IF I4$B'23'23 = 1;
            I4 ← I4 RSH 1;
        ENDFOR;
        REG'AREA.PARITY'BIT ← 1;
        REG'AREA.PARITY'BIT ← 0 IF (I3/2)*2 # I3;
        REG'AREA.AUX'CARRY ← I5$B'19'19;
        REG'AREA.CARRY'BIT ← I1$B'15'15;
        RETURN;

         END;  /*  END SET'STATUS.  */

        PROGRAM AMPERSAND;
*
*  THIS FUNCTION DECODES AND EXECUTES THE AMPERSAND COMMANDS.
*

         INCLUDE SIMU'VARS, FIELD'DESC;

         DECLARE LABEL ARRAY CASE[6] ←
         (CASE0,CASE1,CASE2,CASE3,CASE4,CASE5);

         DECLARE CHARACTER
         C1;

         DECLARE INTEGER
         I1, I2;

         DECLARE STRING
         BUFR(15);

         FUNCTION AMPERSAND();

         I1 ← CINDEX(INPUT'CHARACTER(),"CASZP");
        GOTO CASE[I1];

         CASE0:
        MESSAGE(6);
        C1 ← 307B;
        GOTO COM;

         CASE1:
        SETS(BUFR,0,0);
        CNS(REG'AREA.CARRY'BIT,BUFR,0,2//HELP());
        WCI(' ',BUFR);
        WCI(' ',BUFR);
        PUTA(BUFR,0);
        COLLECT'ALL(REG'AREA.CARRY'BIT, "&307;:*%&&":I1,I2,C1// RETURN 307B);
        REG'AREA.CARRY'BIT ← I1$B'23'23;
        GOTO COM;

         CASE2:
        SETS(BUFR,0,0);
        CNS(REG'AREA.AUX'CARRY,BUFR,0,2//HELP());
        WCI(' ',BUFR);
        WCI(' ',BUFR);
        PUTA(BUFR,0);
        COLLECT'ALL(REG'AREA.AUX'CARRY, "&307;:*%&&":I1,I2,C1// RETURN 307B);
        REG'AREA.AUX'CARRY ← I1$B'23'23;
        GOTO COM;

         CASE3:
        SETS(BUFR,0,0);
        CNS(REG'AREA.SIGN'BIT,BUFR,0,2//HELP());
        WCI(' ',BUFR);
        WCI(' ',BUFR);
        PUTA(BUFR,0);
        COLLECT'ALL(REG'AREA.SIGN'BIT, "&307;:*%&&":I1,I2,C1// RETURN 307B);
        REG'AREA.SIGN'BIT ← I1$B'23'23;
        GOTO COM;

         CASE4:
        SETS(BUFR,0,0);
        CNS(REG'AREA.ZERO'BIT,BUFR,0,2//HELP());
        WCI(' ',BUFR);
        WCI(' ',BUFR);
        PUTA(BUFR,0);
        COLLECT'ALL(REG'AREA.ZERO'BIT, "&307;:*%&&":I1,I2,C1// RETURN 307B);
        REG'AREA.ZERO'BIT ← I1$B'23'23;
        GOTO COM;

         CASE5:
        SETS(BUFR,0,0);
        CNS(REG'AREA.PARITY'BIT,BUFR,0,2//HELP());
        WCI(' ',BUFR);
        WCI(' ',BUFR);
        PUTA(BUFR,0);
        COLLECT'ALL(REG'AREA.PARITY'BIT, "&307;:*%&&":I1,I2,C1// RETURN 307B);
        REG'AREA.PARITY'BIT ← I1$B'23'23;
        GOTO COM;

         COM:
        RETURN C1;
        END;  /*  END AMPERSAND  */

        PROGRAM ASSM1;

         INCLUDE SIMU'VARS, FIELD'DESC;

         DECLARE INTEGER
         I1, I2,
         ADDRS,
         HIGH,
         LOW,
         DONE;

         DECLARE STRING
         ARG1,
         TOKEN(5),
         TOKEN1(8),
         STR1,
         STR2,
         STR3(8);

         DECLARE CHARACTER
         C1;

         FUNCTION ENTER'SYMBOL(ADDRS,ARG1), FRETURN;

         SETS(TOKEN,0,0);
        WHILE 1
         DO;
            C1 ← GCI(ARG1//C1 ← ' ');
            WCI(C1,TOKEN// GOTO L2);
        ENDFOR;
        L2:
        DONE ← 0;
        I1 ← LAST'SYMBOL;
        WHILE I1 # -1 AND NOT DONE
         DO;
            SETUP(STR1,5,SYMBOL'START+(I1 LSH 1), 8);
            SETS(STR1,0,5);
            IF LLT(TOKEN,STR1//HELP()) = -1
             DO;
                SETUP(STR2,5,SYMBOL'START+((I1+1) LSH 1),8);
                SCOPY(STR2,STR1//HELP());
                VALUES[I1+1] ← VALUES[I1];
            ELSEIF LEQ(TOKEN,STR1//HELP()) =-1
             DO;
                PUT'SKIP(1);
                PUTA("REDEFINING SYMBOL:  ",0);
                PUTA(STR1,0);
                PUTA(", PLEASE CONFIRM WITH A PERIOD",0);
                C1 ← INPUT'CHARACTER();
                PUT'SKIP(1);
                IF C1 = '.'
                 DO;
                    VALUES[I1] ← ADDRS;
                    SORT'TABLE();
                ENDIF;
                RETURN;
            ELSE
             DO;
                DONE ← 1;
            ENDIF;
        ENDFOR;
        SETUP(STR1,5,SYMBOL'START+((I1+1) LSH 1),8);
        SCOPY(STR1,TOKEN//HELP());
        VALUES[I1+1] ← ADDRS;
        LAST'SYMBOL ← LAST'SYMBOL+1;
        IF LAST'SYMBOL = 0
         DO;
            SORT'PTRS[0] ← 0;
        ELSE
         DO;
            SORT'PTRS[LAST'SYMBOL] ← LAST'SYMBOL;
            SORT'TABLE();
        ENDIF;
        RETURN;

         FUNCTION SEARCH'OPCODE(ARG1);

         WHILE 1
         DO;
            C1 ← GCI(ARG1//C1 ← ' ');
            WCI(C1,TOKEN1// GOTO L1);
        ENDFOR;
        L1:
        HIGH ← 255;
        LOW ← 0;
        WHILE HIGH >= LOW
         DO;
            I1 ← (HIGH+LOW)/2;
            STR1 ← INSTR'MNEMONICS[INSTR'DATA[I1]$OP'SORT];
            SCOPY(STR3,STR1//HELP());
            WHILE 1
             DO;
                WCI(' ',STR3// GOTO L3);
            ENDFOR;
            L3:
            IF LLT(TOKEN1,STR3//HELP()) = -1
             DO;
                HIGH ← I1 - 1;
            ELSEIF LGT(TOKEN1,STR3//HELP()) = -1
             DO;
                LOW ← I1+1;
            ELSE
             DO;
                RETURN INSTR'DATA[I1]$OP'SORT;
            ENDIF;
        ENDFOR;
        RETURN -1;


         END;  /*  END OF ASSM1  */

        PROGRAM ASTERISK;
*
*  THIS FUNCTION DECODES ALL THE ASTERISKS COMMANDS.
*

         INCLUDE SEQ'FILE'DEFS;

         DECLARE CHARACTER
         C1;

         DECLARE INTEGER
         FILE'NO,
         I1;

         DECLARE STRING
         NAME(15);

         DECLARE LABEL ARRAY CASE[4] ←
         (CASE0,CASE1,CASE2,CASE3);

         FUNCTION ASTERISK();
        I1 ← CINDEX(INPUT'CHARACTER(),"LDT");
        PUT'SKIP(1);
        GOTO CASE[I1];

         CASE0:
        MESSAGE(6);
        GOTO COM;

         CASE1:
        LOAD();
        GOTO COM;

         CASE2:
        PUTA("COMMAND NOT IMPLEMENTED",1);
        GOTO COM;

         CASE3:
        READ'SYMBOL();
        GOTO COM;

         COM:
        RETURN 307B;

         END;  /*  END OF ASTERISK  */

        PROGRAM B'P'1;
*
*  THIS PROGRAM BLOCK CONTAINS FUNCTIONS WILL SET, KILL, AND LIST
*  BREAKPOINTS.  IT IS PART OF THE RUNTIME.
*

         INCLUDE SIMU'VARS;

         DECLARE INTEGER
         I1, I2, I3,
         ADDRS;
        FUNCTION SET'B'P(ADDRS);

         I3 ← GET'M(ADDRS// RETURN);
        PUT'M(8,ADDRS// RETURN);
        IF NEXT'B'P = 0
         DO;
            NEXT'B'P ← 1;
            B'P'TABLE[0] ← ADDRS;
            B'P'TABLE[50] ← I3;
            RETURN;
        ENDIF;
        I1 ← NEXT'B'P;
        I2 ← B'P'TABLE[I1-1];
        WHILE ADDRS < I2 AND I1 > 0
         DO;
            B'P'TABLE[I1] ← B'P'TABLE[I1-1];
            B'P'TABLE[I1+50] ← B'P'TABLE[I1+49];
            I2 ← B'P'TABLE[I1-1];
            I1 ← I1 - 1;
        ENDFOR;
        B'P'TABLE[I1] ← ADDRS;
        B'P'TABLE[I1+50] ← I3;
        NEXT'B'P ← NEXT'B'P + 1;
        RETURN;

         FUNCTION PRINT'B'P();

         IF NEXT'B'P # 0
         DO;
            FOR I1 ← 0 TO NEXT'B'P - 1
             DO;
                PUT'SKIP(1);
                I2 ← B'P'TABLE[I1];
                DISP'ADDRS(I2);
            ENDFOR;
        ENDIF;
        RETURN;

         FUNCTION KILL'B'P(ADDRS);

         I1 ← SEARCH'B'P(ADDRS);
        IF I1 < 0
         DO;
            MESSAGE(7);
            RETURN;
        ENDIF;
        I3 ← B'P'TABLE[I1];
        I2 ← B'P'TABLE[I1+50];
        PUT'M(I2,I3// HELP());
        IF I1 = NEXT'B'P - 1
         DO;
*           THIS BREAK POINT HAD THE HIGHEST ADDRESS IN THE TABLE
*           AND HENCE WAS THE LAST ENTRY IN THE TABLE.
             NEXT'B'P ← I1;
            RETURN;
        ENDIF;
        I2 ← NEXT'B'P - 1;
        WHILE I1 # I2
         DO;
            B'P'TABLE[I1] ← B'P'TABLE[I1+1];
            B'P'TABLE[I1+50] ← B'P'TABLE[I1+51];
            I1 ← I1+1;
        ENDFOR;
        NEXT'B'P ← NEXT'B'P - 1;
        RETURN;


         END;  /*  END OF B'P'1  */

        PROGRAM CHOP;

         DECLARE STRING
         STR;                /* STRING TO BE CHOPPED.  */

         DECLARE INTEGER
         I1, I2;

         STRING FUNCTION CHOP(STR, I1);

         RETURN STR IF I1 = 0;
        FOR I2 ← 1 TO I1
         DO;
            GCI(STR// RETURN STR);
        ENDFOR;
        RETURN STR;

         END;  /*  END OF CHOP  */

        PROGRAM B'P'2;

         INCLUDE SIMU'VARS;

         DECLARE INTEGER
         I1,I2,I3;

         FUNCTION PROCEED'B'P();

         I1 ← SEARCH'B'P(P'COUNTER);
        IF I1 <  0
         DO;
            MESSAGE(6);
        ELSE
         DO;
            I2 ← B'P'TABLE[I1+50];
            PUT'M(I2,P'COUNTER//HELP());
            I3 ← P'COUNTER;
            INTERP(1// RETURN);
            PUT'M(8,I3//HELP());
            INTERP(0// RETURN);
        ENDIF;
        RETURN;

         FUNCTION B'P'HANDLER();

         I1 ← SEARCH'B'P(P'COUNTER);
        IF I1 < 0
         DO;
            ERROR'MESSAGE(1);
        ELSE
         DO;
            ERROR'MESSAGE(0);
            DUMP'REG() & PUT'SKIP(1) IF DUMP'BREAK;
        ENDIF;
        RETURN;

         END;  /*  END OF B'P'2  */

        PROGRAM CINDEX;
*
*  THIS PROGRAM SIMPLY FINDS THE CHARACTER C1 IN STRING
*  STR1.  IT WORKS LIKE A PL/I INDEX FUNCTION.
*

         DECLARE INTEGER I1;

         DECLARE CHARACTER C1;

         DECLARE STRING STR1;

         FUNCTION CINDEX(C1, STR1);

         FOR I1 ← 1 TO 1000
         DO;
            IF C1 = GCI(STR1// RETURN 0)
             DO;
                RETURN I1;
            ENDIF;
        ENDFOR;
        HELP();

         END;  /*  END OF CINDEX  */

        PROGRAM COLLECT'ALL;

         INCLUDE SPECIAL'CHARS;

         DECLARE INTEGER
         OLD,
         I1,I2,
         FIRST;

         DECLARE CHARACTER
         C1;

         DECLARE STRING
         BUFR(20),
         BREAK;

         FUNCTION COLLECT'ALL(OLD,BREAK), FRETURN;

         SETS(BUFR,0,0);
        FIRST ← 1;
        C1 ← INPUT'CHARACTER();
        I1 ← CINDEX(C1,BREAK);
        WHILE I1 = 0
         DO;
            IF C1 = CNTL'A
             DO;
                GCD(BUFR// GOTO L1);
                OUTPUT'CHARACTER('↑');
                L1:
            ELSE
             DO;
                WCI(C1,BUFR);
                FIRST ← 0;
            ENDIF;
            C1 ← INPUT'CHARACTER();
            I1 ← CINDEX(C1,BREAK);
        ENDFOR;
        IF FIRST
         DO;
            RETURN (OLD,I1,C1);
        ELSE
         DO;
            I2 ← EVALUATE(BUFR// FRETURN);
            RETURN (I2,I1,C1);
        ENDIF;

         END;  /*  END OF COLLECT'ALL  */

        PROGRAM COMMAND1;
*
*  THIS BLOCK CONTAINS FUNCTIONS WHICH INTERPRET THE COMMANDS
*  ENTERED DURING THE RUNTIME.
*

         INCLUDE SIMU'VARS;

         DECLARE CHARACTER
         C1;


         DECLARE INTEGER
         I1, I2, I3, I4,
         ADDRS;

         FUNCTION SEMI();

         I1 ← CINDEX(INPUT'CHARACTER(), "BCDEHLMA");
        IF I1 = 0
         DO;
            MESSAGE(6);
            C1 ← 307B;
        ELSE
         DO;
            OUTPUT'CHARACTER(' ');
            I2 ← GET'REG(I1 - 1// RETURN 307B);
            DISPLAY(I2,1);
            COLLECT'ALL(I2, "&307;:*%&&":I3, I4, C1// RETURN 307B);
            PUT'REG(I3,I1-1// RETURN 307B);
        ENDIF;
        RETURN C1;

         FUNCTION COLON();

         I1 ← CINDEX(INPUT'CHARACTER(),"BDHSP$");
        IF I1 = 0
         DO;
            MESSAGE(6);
            C1 ← 307B;
        ELSEIF I1 = 5 OR I1 = 6
         DO;
            OUTPUT'CHARACTER(' ');
            DISPLAY(P'COUNTER,2);
            COLLECT'ALL(P'COUNTER, "&307;:*%&&":P'COUNTER,I2,C1// RETURN 307B);
        ELSE
         DO;
            OUTPUT'CHARACTER(' ');
            I2 ← GET'D(I1-1);
            DISPLAY(I2,2);
            COLLECT'ALL(I2, "&307;:*%&&":I2,I3,C1// RETURN 307B);
            PUT'D(I2,I1-1);
        ENDIF;
        RETURN C1;

         END;  /*  END COMMAND1  */

        PROGRAM DEBUGGER;
*
*  THIS IS THE MAIN ENTRY POINT FOR THE SIMULATOR.  THIS FUNCTION
*  COORDINATES THE ACTIVITIES OF THE RUNTIME AND THE INTERPRETER 
*  PROGRAMS OF THE SIMULATOR.
*

         INCLUDE SPECIAL'CHARS, MONITOR'CALLS;

         DECLARE CHARACTER
         C1;

         DECLARE INTEGER
         FLAG,
         ERROR'1, ERROR'2,  /*  FOR ERROR PURPOSES  */
         I1;

         DECLARE LABEL ARRAY CASE[9] ←
         (CASE0,CASE1,CASE2,CASE3,CASE4,CASE5,CASE6,CASE7,CASE8);
        FUNCTION DEBUGGER(FLAG);

*        INITIALIZE THE SIMULATOR
         INIT'SIMU(FLAG);
        C1 ← INPUT'CHARACTER();
        WHILE 1
         DO;
            I1 ← CINDEX(C1,";%:*&&&310&307↑");
            SET'LEN'WS('OCW',16//HELP():ERROR'1,ERROR'2);
            GOTO CASE[I1];

             CASE0:  /*  EXPRESSION  */
            EXPRESSION(C1:C1);
            GOTO COM;

             CASE1:
            SEMI(:C1);
            GOTO COM;

             CASE2:
            PERCENT(:C1);
            GOTO COM;

             CASE3:
            COLON(:C1);
            GOTO COM;

             CASE4:
            ASTERISK(:C1);
            GOTO COM;

             CASE5:
            AMPERSAND(:C1);
            GOTO COM;

             CASE7:  /*   CARRIAGE RETURN  */
            OUTPUT'CHARACTER(LF);
            C1 ← 307B;
            GOTO COM;

             CASE6:CASE8:
            PUT'SKIP(1);
            C1 ← 307B;
            GOTO COM;

             COM:
            IF C1 = 307B
             DO;
                C1 ← INPUT'CHARACTER();
            ENDIF;
        ENDFOR;

         END;  /*  END OF DEBUGGER  */

        PROGRAM DISPLAY;

         INCLUDE SIMU'VARS, FIELD'DESC;

         DECLARE INTEGER
         LENT,
         RADIX,
         DATA,
         I1,
         BYTE'COUNT;

         DECLARE CHARACTER
         C1;

         DECLARE STRING
         STR1,
         STR2(15),
         BUFR(15);

         DECLARE LABEL ARRAY CASE[4] ←
         (CASE0,CASE1,CASE2,CASE3);

         FUNCTION DISPLAY(DATA,BYTE'COUNT);

         GOTO CASE[MODE];

         CASE0:  /*   OCTAL  */
        RADIX ← 8;
        LENT ← 3;
        GOTO COM;

         CASE1:  /*  DECIMAL  */
        RADIX ← 10;
        LENT ← 0;
        GOTO COM;

         CASE2:  /*  HEX  */
        RADIX ←  16;
        LENT ← 2;
        GOTO COM;

         CASE3:  /*  MNEMONICS  */
        STR1 ← INSTR'MNEMONICS[DATA];
        SCOPY(BUFR,STR1//HELP());
        WCI(' ',BUFR);
        WCI(' ',BUFR);
        PUTA(BUFR,0);
        RETURN;

         COM:
        SETS(BUFR,0,0);
        IF BYTE'COUNT = 1
         DO;
            CNS(DATA$B'16'23,BUFR,LENT,RADIX//HELP());
        ELSE
         DO;
            CNS(DATA$B'8'15,BUFR,LENT,RADIX//HELP());
            WCI(377B,BUFR);
            CNS(DATA$B'16'23,BUFR,LENT,RADIX//HELP());
        ENDIF;
        WHILE 1
         DO;
            C1 ← GCI(BUFR// GOTO L1);
            IF C1 = ' '
             DO;
                WCI('0',STR2);
            ELSEIF C1 = 377B
             DO;
                WCI(' ',STR2);
            ELSE
             DO;
                WCI(C1,STR2);
            ENDIF;
        ENDFOR;
        L1:
        WCI(' ',STR2);
        WCI(' ',STR2);
        PUTA(STR2,0);
        RETURN;

         END;  /*  END DISPLAY  */

        PROGRAM DISP'ADDRS;
*
*  THIS FUNCTION DISPLAYS THE ADDRESS OF THE PARAMETE IT IS GIVEN.
*  DISP'ADDRS TRIES TO FIND A SYMBOL WHOSE VALUE IS LESS THAN OR
*  EQUAL TO THE ONE TO BE DISPLAYED AND PRINTS THIS OUT.  ABSOLUTE
*  NUMBERS ARE PRINTED OUT ONLY WHEN THERE ARE NO SYMBOLS IN THE
*  SYMBOL TABLE OR ALL THE SYMBOLS IN THE TABLE ARE TOO BIG.
*

         INCLUDE SIMU'VARS;

         DECLARE INTEGER ARRAY RADIX[4] ←
         (8,10,16,10);

         DECLARE INTEGER
         I1, I2, I3,
         ADDRS;

         DECLARE CHARACTER
         C1;

         DECLARE STRING
         BUFR(15),
         STR1;

         FUNCTION DISP'ADDRS(ADDRS);

         I1 ← SEARCH'ADDRS(ADDRS);
        IF I1 = - 1 /*  NO SYMBOL COULD BE FOUND  */
         DO;  /*  JUST OUTPUT THE NUMERIC NUMBER  */
        SETS(BUFR,0,0);
            CNS(ADDRS,BUFR,0,RADIX[MODE]//HELP());
            PUTA(BUFR,0);
            RETURN;
        ENDIF;
        I2 ← SORT'PTRS[I1];
        I3 ← VALUES[I2];
        SETUP(STR1,5,SYMBOL'START+(I2 LSH 1),8);
        SETS(STR1,0,5);
        SETS(BUFR,0,0);
        C1 ← GCI(STR1);
        WHILE C1 # ' '
         DO;
            WCI(C1,BUFR);
            C1 ← GCI(STR1// GOTO L1);
        ENDFOR;
        L1:
        IF ADDRS = I3
         DO;
            PUTA(BUFR,0);
        ELSEIF ADDRS > I3
         DO;
            WCI('+',BUFR);
            WCI('0',BUFR);
            CNS(ADDRS-I3,BUFR,0,RADIX[MODE]//HELP());
            PUTA(BUFR,0);
        ELSE
         DO;
            IF I1 = 0
             DO;
                SETS(BUFR,0,0);
                CNS(ADDRS,BUFR,0,RADIX[MODE]//HELP());
                PUTA(BUFR,0);
            ELSE
             DO;
                I1 ← I1-1;
                I2 ← SORT'PTRS[I1];
                I3 ← VALUES[I2];
                SETUP(STR1,5,SYMBOL'START+(I2 LSH 1),8);
                SETS(STR1,0,5);
                SETS(BUFR,0,0);
                C1 ← GCI(STR1);
                WHILE C1 # ' '
                 DO;
                    WCI(C1,BUFR);
                    C1 ← GCI(STR1// GOTO L2);
                ENDFOR;
                L2:
                WCI('+',BUFR);
                WCI('0',BUFR);
                CNS(ADDRS-I3,BUFR,0,RADIX[MODE]//HELP());
                PUTA(BUFR,0);
            ENDIF;
        ENDIF;
        RETURN;

         END;  /*  END DISP'ADDRS  */

        PROGRAM DUMP'DATA;

         INCLUDE SIMU'VARS, FIELD'DESC;

         DECLARE INTEGER
         I1, I2, I3, I4, I5, I6,
         HIGH,
         LOW,
         CMND;

         DECLARE INTEGER ARRAYONE COMMAND[5] ←
         ('/',']','[',')','(');

         DECLARE STRING
         BUFR(40);

         DECLARE LABEL ARRAYONE CASE[5] ←
         (CASE1,CASE2,CASE3,CASE4,CASE5);

         FUNCTION DUMP'DATA(LOW);

         COLLECT'ALL(-1,"/][)(":I6,CMND,I1// RETURN);
        HIGH ← I6;
        IF LOW > HIGH
         DO;
            MESSAGE(6);
            RETURN;
        ENDIF;
        PUT'SKIP(1);
        I3 ← MODE;
        FOR I1 ← LOW TO HIGH
         DO;
            MODE ← I3;
            DISP'ADDRS(I1);
            SETS(BUFR,0,0);
            WCI(COMMAND[CMND],BUFR);
            WCI(' ',BUFR);
            WCI(' ',BUFR);
            PUTA(BUFR,0);
            I2 ← GET'M(I1// RETURN);
            I3 ← MODE;
            GOTO CASE[CMND];

             CASE1:  /*  PRINT  */
            GOTO COM;

             CASE2:  /*  OCTAL  */
            MODE ← 0;
            GOTO COM;

             CASE3:  /*  DECIMAL  */
            MODE ← 1;
            GOTO COM;

             CASE4:  /*  HEX  */
            MODE ← 2;
            GOTO COM;

             CASE5:  /*   MNEMONICS  */
            I4 ← INSTR'INCRE[I2];
            MODE ← 3;
            IF I4 = - 1 /*  INSTRUCTION TRAP  */
             DO;
/*  TREAT AS DATA  */
                 MODE ← I3;
                GOTO COM;
            ELSEIF I4 =  1 /*  SINGLE BYTE INSTRUCTION  */
             DO;
                GOTO COM;
            ELSEIF I4 =  2 /*  2 BYTE INSTRUCTION  */
             DO;
                DISPLAY(I2,1);
                I1 ← I1 + 1;
                I2 ← GET'M(I1// RETURN);
                MODE ← I3;
                DISP'ADDRS(I2);
            ELSEIF I4 =  3 /*  3 BYTE INSTRUCTION  */
             DO;
                DISPLAY(I2,1);
                I1 ← I1 + 1;
                I2 ← GET'M(I1// RETURN);
                I4 ← 0;
                I4$B'16'23 ← I2$B'16'23;
                I1 ← I1 + 1;
                I2 ← GET'M(I1// RETURN);
                I4$B'8'15 ← I2$B'16'23;
                MODE ← I3;
                DISP'ADDRS(I4);
            ELSE
             DO;
                HELP();
            ENDIF;
            GOTO L1;
            COM:
            DISPLAY(I2,1);
            L1:
            MODE ← I3;
            PUT'SKIP(1);
        ENDFOR;
        CURRENT'LINE ← I1;
        RETURN;

         END;  /*  END OF DUMP'DATA  */

        PROGRAM DUMP'REG;

         INCLUDE SIMU'VARS, FIELD'DESC;

         DECLARE INTEGER ARRAY
         TRAN1[7] ←
         (7,0,1,2,3,4,5),
         ALPHA[7] ←
         ('A','B','C','D','E','H','L');

         DECLARE INTEGER
         I1, I2, I3, I4, I5;

         FUNCTION DUMP'REG();

         FOR I1 ← 0 TO 6
         DO;
            I2 ← TRAN1[I1];
            I3 ← OLD'STORE[I2]$OLD'DATA;
            I4 ← OLD'STORE[I2]$OLD'COUNT;
            I5 ← GET'REG(I2// RETURN);
            IF I5 # I3 OR I4 = 0
             DO;
                OUTPUT'CHARACTER(';');
                OUTPUT'CHARACTER(ALPHA[I1]);
                OUTPUT'CHARACTER('=');
                DISPLAY(I5,1);
                OLD'STORE[I2]$OLD'DATA ← I5;
                OLD'STORE[I2]$OLD'COUNT ← 10;
            ELSE
             DO;
                OLD'STORE[I2]$OLD'COUNT ← I4-1;
            ENDIF;
        ENDFOR;
        RETURN;

         END;  /*  END DUMP'REG  */

        PROGRAM ENTER'MNEMONICS;

         INCLUDE SIMU'VARS, FIELD'DESC, SPECIAL'CHARS;

         DECLARE INTEGER
         ADDRS,
         PAU,
         I1,I2,I3,I4;

         DECLARE CHARACTER
         C1, C2;

         FUNCTION ENTER'MNEMONICS(ADDRS, C1);

         PAU ← 0;
        WHILE NOT PAU
         DO;
            PAU ← 1;
            IF C1 = '<'
             DO;
                I1 ← GET'M(ADDRS// RETURN);
                I2 ← INSTR'DATA[I1]$INCRE;
                I4 ← MODE;
                MODE ← 3;
                IF I2 = - 1 /*  INSTRUCTION TRAP  */
                 DO;
                    MODE ← I4;
                    DISPLAY(I1,1);
                ELSEIF I2 =  1 /*  ONE BYTE INSTRUCTION  */
                 DO;
                    DISPLAY(I1,1);
                ELSEIF I2 = 2 /*  2 BYTE  */
                 DO;
                    DISPLAY(I1,1);
                    I1 ← GET'M(ADDRS+1// RETURN);
                    DISP'ADDRS(I1);
                ELSEIF I2 =  3 /*  3 BYTE  */
                 DO;
                    DISPLAY(I1,1);
                    I1 ← GET'M(ADDRS+1// RETURN);
                    I3 ← 0;
                    I3$B'16'23 ← I1$B'16'23;
                    I1 ← GET'M(ADDRS+2// RETURN);
                    I3$B'8'15 ← I1$B'16'23;
                    DISP'ADDRS(I3);
                    OUTPUT'CHARACTER(' ');
                    OUTPUT'CHARACTER(' ');
                ELSE
                 DO;
                    HELP();
                ENDIF;
                MODE ← I4;
            ENDIF;
            MINI'ASSM(ADDRS:ADDRS,C2// RETURN);
            IF C2 =  200 /*  M1 LF  */
             DO;
                PAU ← 0;
                OUTPUT'CHARACTER(CR);
                DISP'ADDRS(ADDRS);
                OUTPUT'CHARACTER(C1);
            ENDIF;
        ENDFOR;
        RETURN;

         END;  /*  END OF ENTER'MNEMONICS  */

        PROGRAM ERROR'MSG;

         INCLUDE MESSAGE'BLOCK, SPECIAL'CHARS;

         DECLARE INTEGER
         ERROR'NO;

         DECLARE STRING
         STR1,
         OUT'STR(200);
        FUNCTION ERROR'MSG(ERROR'NO);

         SETS(OUT'STR, 0, 0);
        WCI(CR, OUT'STR);
        WCI(LF, OUT'STR);
        IF ERROR'NO < 13
         DO;
            APPEND(OUT'STR, "          "//HELP());
            STR1 ← MESSAGES[ERROR'NO];
            APPEND(OUT'STR, STR1//HELP());
            WCI(CR, OUT'STR);
            WCI(LF, OUT'STR);
        ENDIF;
        PUTA(OUT'STR, 1);
        RETURN;

         END;  /*  END OF ERROR'MSG.  */

        PROGRAM EVALUATE;

         INCLUDE SIMU'VARS;

         DECLARE INTEGER
         RESULT, I1, I2;

         DECLARE CHARACTER
         C1;

         DECLARE STRING
         EXP,                    /*  THE EXPRESSION  */
         ARG1,                   /*  DUMMY ARGUMENT  */
         TMP2(80),
         TMP(80),                /*  TEMPORARY VARIABLE  */
         DOPE(1);

         INTEGER FUNCTION EVALUATE(ARG1), FRETURN;

         RETURN 0 IF COMPARE'STRING(ARG1, ""//HELP()) = -1 OR
         COMPARE'STRING(ARG1, "     "//HELP()) = -1;
        EXP ← ARG1;
        C1 ← GCI(EXP);
        WCD(C1, EXP);
        IF C1 = '+' OR C1 = '-'
         DO;  /* NOTHING  */
        ELSE
         DO;
            SETS(TMP2, 0, 0);
            WCI('+', TMP2);
            APPEND(TMP2, EXP//HELP());
            EXP ← TMP2;
        ENDIF;
        RESULT ← 0;
        WHILE 1
         DO;
            C1 ← GCI(EXP// CURRENT'LINE ← RESULT & RETURN RESULT);
            I1 ← NEAREST(EXP);
            I2 ← FIND(SUBSTR(EXP,1,I1-1,TMP)// FRETURN);
            IF C1 = '+'
             DO;
                RESULT ← RESULT + I2;
            ELSE
             DO;
                RESULT ← RESULT - I2;
            ENDIF;
            EXP ← CHOP(EXP, I1 - 1);
        ENDFOR;

         END;  /*  END OF EVALUATE.  */

        PROGRAM EXPRESSION;
*
*  THIS IS THE EXPRESSION EVALUATOR USED DURING THE RUNTIME.
*

         INCLUDE SPECIAL'CHARS, SIMU'VARS;

         DECLARE INTEGER
         I1, I2, I3, I4, I5,
         ADDRS;

         DECLARE INTEGER ARRAYONE
         COMMAND[7] ← ('/','\','=',']','[',')','(',);

         DECLARE STRING
         BREAK,  /*  JUST RESERVE A DESCRIPTOR FOR FUTURE INITIALIZATION  */
         BUFR(80);

         DECLARE CHARACTER
         C1, C2;

         DECLARE LABEL ARRAYONE
         CASE[15] ←
         (CASE0,CASE1,CASE2,CASE3,CASE4,CASE5,CASE6,CASE7,CASE8,CASE9,CASE10);
        DECLARE LABEL ARRAYONE CASE[12] ←
         (CASE11,CASE12,CASE13,CASE14);

         FUNCTION EXPRESSION(C1);

         BREAK ← ("↑&307&310/\=][)(!#$<>%;:*&&");
        SETS(BUFR,0,0);
        I3 ← ADDRS ← 0;
        WHILE I3 = 0
         DO;
            IF C1 = CNTL'A
             DO;
                GCD(BUFR// GOTO L1);
                OUTPUT'CHARACTER('↑');
                L1:
            ELSE
             DO;
                WCI(C1,BUFR);
            ENDIF;
            C1 ← INPUT'CHARACTER();
            I3 ← CINDEX(C1,"/\=][)(!#$,&307&310<>");
        ENDFOR;
        ADDRS ← EVALUATE(BUFR// RETURN 307B);
        IF ADDRS < 0
         DO;
            MESSAGE(6);
            RETURN 307B;
        ENDIF;
        C2 ← 199;
*       AT THIS POINT WE WANT THE CHANGE THE SET OF CHARACTERS
*       WHICH CAUSE COLLECT'ALL TO RETURN.  "BREAK" WILL
*       BE SET SUCH THAT ONLY CHARACTERS WHICH ARE CONTROL BUT NOT
*       EXPRESSION COMMANDS WHICH CAUSE COLLECT'ALL TO RETURN.
*       THIS STRATEGY HOWEVER MAKES IT IMPOSSIBLE TO ENTER FURTHER
*       EXPRESSION COMMANDS WHICH INPUTING TO AN OPEN CELL AS IN
*       DDT.

         BREAK ← ("↑&307&310%;:*&&");
        WHILE 1
         DO;
            GOTO CASE[I3];

             CASE0:
            I1 ← GET'M(ADDRS// RETURN 307B);
            DISPLAY(I1,1);
            COLLECT'ALL(I1, BREAK:I4, I5, C2// RETURN 307B);
            PUT'M(I4,ADDRS// RETURN 307B);
            GOTO COM;

             CASE1:
            PUTA("  ",0);
            I1 ← GET'M(ADDRS// RETURN 307B);
            COLLECT'ALL(I1, BREAK:I4, I5, C2// RETURN 307B);
            PUT'M(I4,ADDRS// RETURN 307B);
            GOTO COM;

             CASE2:
            DISP'ADDRS(ADDRS);
            PUT'SKIP(1);
            GOTO COM;

             CASE3:
            I2 ← MODE;
            MODE ← 0;
            I1 ← GET'M(ADDRS// RETURN 307B);
            DISPLAY(I1, 1);
            COLLECT'ALL(I1, BREAK:I4, I5, C2// RETURN 307B0);
            PUT'M(I4,ADDRS// RETURN 307B);
            MODE ← I2;
            GOTO COM;

             CASE4:
            I2 ← MODE;
            MODE ← 1;
            I1 ← GET'M(ADDRS// RETURN 307B);
            DISPLAY(I1, 1);
            COLLECT'ALL(I1, BREAK:I4, I5, C2// RETURN 307B);
            PUT'M(I4,ADDRS// RETURN 307B);
            MODE ← I2;
            GOTO COM;

             CASE5:
            I2 ← MODE;
            MODE ← 2;
            I1 ← GET'M(ADDRS// RETURN 307B);
            DISPLAY(I1, 1);
            COLLECT'ALL(I1, BREAK:I4, I5, C2// RETURN 307B);
            PUT'M(I4,ADDRS// RETURN 307B);
            MODE ← I2;
            GOTO COM;

             CASE6:
            I2 ← MODE;
            MODE ← 3;
            I1 ← GET'M(ADDRS// RETURN 307B);
            DISPLAY(I1,1);
            COLLECT'ALL(I1, BREAK:I4, I5, C2// RETURN 307B);
            PUT'M(I4,ADDRS// RETURN 307B);
            MODE ← I2;
            GOTO COM;

             CASE7:
            SET'B'P(ADDRS);
            PUT'SKIP(1);
            GOTO COM;

             CASE8:
            P'COUNTER ← ADDRS;
            INTERP(0// GOTO COM);
            GOTO COM;

             CASE9:
            KILL'B'P(ADDRS);
            PUT'SKIP(1);
            GOTO COM;

             CASE10:
            DUMP'DATA(ADDRS);
            GOTO COM;

             CASE11:CASE12:
            MESSAGE(6);
            GOTO COM;

             CASE13:CASE14:
            ENTER'MNEMONICS(ADDRS, C1);
            GOTO COM;

             COM:

             CURRENT'LINE ← ADDRS;
            IF CINDEX(C2,"%;:*&&") # 0
             DO;
                RETURN C2;
            ELSEIF C2 = 199
             DO;
                RETURN 307B;
            ELSEIF C2 = 200
             DO;
                OUTPUT'CHARACTER(CR);
                ADDRS ← ADDRS+1;
            ELSEIF C2 = '↑'
             DO;
                PUT'SKIP(1);
                ADDRS ← ADDRS-1;
            ENDIF;
            DISP'ADDRS(ADDRS);
            OUTPUT'CHARACTER(COMMAND[I3]);
        ENDFOR;

         END;  /*  END EXPRESSION  */

        PROGRAM FIND;

         INCLUDE SIMU'VARS;
        DECLARE INTEGER
         I1;

         DECLARE CHARACTER
         C1;

         DECLARE STRING
         FIRST(1),
         EXP;

         DECLARE INTEGER ARRAYONE REG'VALUE[13] ←
         (7, 0, 1, 2, 3, 4, 5, 6, 6, 6, 6, 0, 0);
        DECLARE INTEGER ARRAY
         RADIX[4] ← (8,10,16,10);

         INTEGER FUNCTION FIND(EXP), FRETURN;

         IF COMPARE'STRING(EXP, "$"//HELP()) = -1
         DO;
            RETURN P'COUNTER;
        ENDIF;
        I1 ← INDEX("ABCDEHLMPSPSW", EXP);
        IF I1 # 0
         DO;
            I1 ← REG'VALUE[I1];
            RETURN I1;
        ENDIF;
        IF COMPARE'STRING(EXP,"."//HELP()) = -1
         DO;
            RETURN CURRENT'LINE;
        ENDIF;
        FIRST ← SUBSTR(EXP, 1, 1, FIRST);
        IF VERIFY(FIRST, "0123456789") = 0
         DO;  /*  WE HAVE A NUMBER */
        C1 ← GCD(EXP);
            IF VERIFY(EXP, "0123456789ABCDEF") # 0
             DO;
*                 WE DON'T HAVE A GOOD NUMBER
*                 RAISE THE CONVERSION CONDITION.
                 MESSAGE(8);
                FRETURN;
            ENDIF;
            IF C1 = 'H'
             DO;  /*  WE HAVE A HEX NUMBER.  */
            I1 ← CSN(EXP, 16//MESSAGE(8) & FRETURN);
                RETURN I1;
            ELSEIF C1 = 'O' OR C1 = 'Q'
             DO;  /*  WE HAVE AN OCTAL NUMBER.  */
            I1 ← CSN(EXP, 8//MESSAGE(8) & FRETURN);
                RETURN I1;
            ELSEIF C1 = 'D'
             DO;  /*  WE STILL HAVE A DECIMAL NUMBER.  */
            I1 ← CSN(EXP, 10//MESSAGE(8) & FRETURN);
                RETURN I1;
            ELSEIF C1 = 'B'
             DO;  /*  WE HAVE A BINARY NUMBER.  */
            I1 ← CSN(EXP, 2//MESSAGE(8) & FRETURN);
                RETURN I1;
            ELSE
             DO;
                WCI(C1, EXP);
                IF VERIFY(EXP, "0123456789ABCDEF") # 0
                 DO;
*                 WE DON'T HAVE A GOOD NUMBER
*                 RAISE THE CONVERSION CONDITION.
                     MESSAGE(8);
                    FRETURN;
                ENDIF;
                I1 ← CSN(EXP, RADIX[MODE]//MESSAGE(8) & FRETURN);
                RETURN I1;
            ENDIF;
        ENDIF;
        IF COMPARE'STRING(FIRST, "'"//HELP()) = -1
         DO;
            GCI(EXP);
            C1 ← GCI(EXP//MESSAGE(8) & FRETURN);
            RETURN (C1 + 32);
        ENDIF;
        WHILE LENGTH(EXP) < 5
         DO;
            WCI(' ', EXP);
        ENDFOR;
        FRETURN IF COMPARE'STRING(EXP, "     "//HELP()) = -1;
        I1 ← SEARCH'SYMBOL(EXP, LAST'SYMBOL//
         MESSAGE(8) & FRETURN);
        I1 ← VALUES[I1];
        RETURN I1;

         END;  /*   END OF VALUE.  */

        PROGRAM INDEX;

         DECLARE STRING
         S1, S2, S3, S4, SOURCE, TEST;

         DECLARE CHARACTER
         C1, C2;

         DECLARE INTEGER
         I1;

         INTEGER FUNCTION INDEX(SOURCE, TEST);

         I1 ← 1;
        S1 ← SOURCE;
        S2 ← TEST;
        C1 ← GCI(S2// RETURN 0);
        S4 ← S2;
        WHILE 1
         DO;
            C2 ← GCI(S1// RETURN 0);
            WHILE C1 # C2
             DO;
                C2 ← GCI(S1// RETURN 0);
                I1 ← I1 + 1;
            ENDFOR;
            S3 ← S1;
            WHILE C1 = C2
             DO;
                C1 ← GCI(S2// RETURN I1);
                C2 ← GCI(S1// RETURN 0);
            ENDFOR;
            S1 ← S3;
            S2 ← S4;
        ENDFOR;

         END;  /*  END OF INDEX.  */

        PROGRAM INFILE;

         DECLARE CHARACTER
         C1;

         DECLARE STRING
         NAME;

         STRING FUNCTION INFILE(NAME), FRETURN;

         SETS(NAME, 0, 0);
        C1 ← INPUT'CHARACTER();
        IF C1 = ';'
         DO;
            PUT'SKIP(1);
            FRETURN;
        ENDIF;
        WHILE C1 # '.'
         DO;
            WCI(C1, NAME//PUT'SKIP(1) & FRETURN);
            C1 ← INPUT'CHARACTER();
            WHILE C1 = 225
             DO;
                GCD(NAME// GOTO L1);
                OUTPUT'CHARACTER('↑');
                L1:
                C1 ← INPUT'CHARACTER();
            ENDFOR;
        ENDFOR;
        PUT'SKIP(1);
        RETURN NAME;

         END;  /*  END OF INFILE  */

        PROGRAM INIT'SIMU;
*
*  THIS SECTION INITIALIZES THE VARIABLES USED IN THE SIMULATOR
*

         INCLUDE SIMU'VARS, MONITOR'CALLS, UTILITY'CALLS;

         DECLARE INTEGER
         FLAG,
         I1, I2, I3,
         START,    /* STARTING POINT FOR MEMORY  */
         ERROR'1,ERROR'2,
         MYLINE;

         FUNCTION INIT'SIMU(FLAG);


*  THIS SEGEMENT OF CODE WILL TURN OFF THE ECHOING OF THE USER
*  TTY.
*
         MYLINE ← READ'CIOS'FIELD(-1, 'OPN'//SYSTEM'ERROR()) LSH 1;
        SET'LINE'FIELD(MYLINE,'BWS',3//SYSTEM'ERROR());
        SET'LINE'FIELD(MYLINE,'EST',0//SYSTEM'ERROR());
*       INITIALIZE SOME VARIABLES
         IF FLAG = 1 /*  THEN DO INITIALIZATION  */
         DO;
            MODE ← 2;
            CONTROL'BREAK ← DUMP'BREAK ← CONTROL'TRACE ← NEXT'B'P ← 0;
            LAST'SYMBOL ← CURRENT'LINE ← -1;
            STACK ← P'COUNTER ← 0;
            FOR I1 ← 0 TO 7
             DO;
                REG'STORE[I1] ← 0;
            ENDFOR;
*       THE 8080'S MEMORY STARTS A 130000B IN THE 500'S ADDRESS SPACE.
             SETUP(MEMORY,MAX'MEM,130000B,8);
            PUTA("8080 SIMULATOR 4/16/78",2);
        ENDIF;
*       MAKE THE CORE WORKING SET SMALLER
*       MAKE IT AS SMALL AS POSSIBLE
         FOR I1 ← 0 TO 30
         DO;
            DEL'PAGE'CWS(-1// GOTO L1:ERROR'1,ERROR'2);
            L1:
        ENDFOR;
        I1 ← READ'LEN'WS('CWS'//HELP():ERROR'1,ERROR'2);
*       INCREASE BOTH THE DRUM & CORE WORKING SETS
         I1 ← READ'LEN'WS('MCW'//HELP():ERROR'1,ERROR'2);
        I2 ← READ'LEN'WS('MDW'//HELP():ERROR'1,ERROR'2);
        SET'LEN'WS('ODW',I2//HELP():ERROR'1,ERROR'2);
        SET'LEN'WS('OCW',16//HELP():ERROR'1,ERROR'2);
*       SET THE 'DPNIM' BIT ON TO ALLOW FOR DYNAMIC STORAGE
*       ALLOCATION.  THIS FOOLS WITH THE SUB-PROCESS-TABLE.
         I1 ← READ'SPT'FIELD(-1,'SB'//HELP():ERROR'1,ERROR'2);
        I1 ← I1 V' 1B6;
        SET'SPT'FIELD(-1,'SB',I1//HELP():ERROR'1,ERROR'2);

         RETURN;

         END;  /*  END OF INIT'SIMU.  */

        PROGRAM LEQ;

         DECLARE STRING
         STR1,
         STR2;

         FUNCTION LEQ(STR1, STR2), FRETURN;

         WHILE 1
         DO;
            IF GCI(STR1// GOTO L1) # GCI(STR2// RETURN 0)
             DO;
                RETURN 0;
            ENDIF;
        ENDFOR;
        L1:
        GCI(STR2// RETURN -1);
        RETURN 0;

         END;  /*  END OF LEQ  */

        PROGRAM LOAD;
*
*  THIS PROGRAM IS USED TO LOAD IMSAI OBJECT TAPE FILE INTO
*  MEMORY.  IT IS PART OF THE RUNTIME SYSTEM.
*

         INCLUDE SEQ'FILE'DEFS, FIELD'DESC;

         DECLARE INTEGER
         INNO,
         I1,
         I2,
         RECORD'LENT,
         CHK'SUM,
         COUNT,
         LOAD'ADDRS;


         DECLARE CHARACTER
         C1;

         DECLARE STRING
         BUFR(100),
         STR1(4),
         STR2(2),
         NAME(15);

         FUNCTION LOAD();

         L1:
        PUTA("OBJECT FILE:  ",0);
        NAME ← INFILE(NAME// RETURN);
        INNO ← OPEN'SEQ'FILE(NAME, READ'FILE, SYMBOLIC'FILE,
         8// GOTO L1);
        WHILE 1
         DO;
            BUFR ← INPUT'SEQ'FILE(INNO,BUFR//HELP());
            MESSAGE(3) & RETURN IF LENGTH(BUFR) = 0;
            C1 ← GCI(BUFR//HELP());
            WHILE C1 # ':'
             DO;
                C1 ← GCI(BUFR// GOTO L2);
            ENDFOR;
            COUNT ← 0;
            SETS(STR1,0,0);
            WCI(GCI(BUFR//MESSAGE(1) & RETURN),STR1);
            WCI(GCI(BUFR//MESSAGE(1) & RETURN),STR1);
            RECORD'LENT ← CSN(STR1,16//MESSAGE(2) & RETURN);
            COUNT$B'16'23 ← COUNT$B'16'23 + RECORD'LENT$B'16'23;
            IF RECORD'LENT = 0
             DO;
                CLOSE'SEQ'FILE(INNO//HELP());
                PUTA("LOADING COMPLETE",1);
                RETURN;
            ENDIF;
*          HANDLE THE LOAD ADDRESS
             SETS(STR1,0,0);
            SETS(STR2,0,0);
            C1 ← GCI(BUFR//MESSAGE(1) & RETURN);
            WCI(C1,STR1);
            WCI(C1,STR2);
            C1 ← GCI(BUFR//MESSAGE(1) & RETURN);
            WCI(C1,STR1);
            WCI(C1,STR2);
            I2 ← CSN(STR2,16//HELP());
            SETS(STR2,0,0);
            COUNT$B'16'23 ← COUNT$B'16'23 + I2$B'16'23;
            C1 ← GCI(BUFR//MESSAGE(1) & RETURN);
            WCI(C1,STR1);
            WCI(C1,STR2);
            C1 ← GCI(BUFR//MESSAGE(1) & RETURN);
            WCI(C1,STR1);
            WCI(C1,STR2);
            I2 ← CSN(STR2,16//HELP());
            COUNT$B'16'23 ← COUNT$B'16'23 + I2$B'16'23;
            LOAD'ADDRS ← CSN(STR1,16//MESSAGE(2) & RETURN);
*          HANDLE THE RECORD TYPE
             SETS(STR1,0,0);
            WCI(GCI(BUFR//MESSAGE(1) & RETURN),STR1);
            WCI(GCI(BUFR//MESSAGE(1) & RETURN),STR1);
            I2 ← CSN(STR1,16//MESSAGE(2) & RETURN);
            COUNT$B'16'23 ← COUNT$B'16'23 + I2$B'16'23;
*          NOW READ IN THE REST OF THE DATA
             FOR I1 ← 1 TO RECORD'LENT
             DO;
                SETS(STR1,0,0);
                WCI(GCI(BUFR//MESSAGE(1) & RETURN),STR1);
                WCI(GCI(BUFR//MESSAGE(1) & RETURN),STR1);
                I2 ← CSN(STR1,16//MESSAGE(2) & CLOSE'SEQ'FILE(INNO//
                 HELP()) & RETURN);
                COUNT$B'16'23 ← COUNT$B'16'23 + I2$B'16'23;
                PUT'M(I2,LOAD'ADDRS//CLOSE'SEQ'FILE(INNO) & RETURN);
                LOAD'ADDRS ← LOAD'ADDRS + 1;
            ENDFOR;
            SETS(STR1,0,0);
            WCI(GCI(BUFR//MESSAGE(1) & RETURN),STR1);
            WCI(GCI(BUFR//MESSAGE(1) & RETURN),STR1);
            CHK'SUM ← CSN(STR1,16//MESSAGE(2) & RETURN);
            MESSAGE(4) & RETURN
             IF (CHK'SUM + COUNT)$B'16'23 # 0;
            L2:
        ENDFOR;


         END;  /*  END OF LOAD  */

        PROGRAM MESSAGES;

         INCLUDE SIMU'VARS;

         DECLARE INTEGER
         MSG'NO;

         DECLARE STRING
         STR1;

         FUNCTION ERROR'MESSAGE(MSG'NO);

         IF MSG'NO > 10
         DO;
            PUT'SKIP(1);
            PUTA("ERROR #  ",0); PUTN(MSG'NO,1);
            RETURN;
        ENDIF;
        STR1 ← MESS1[MSG'NO];
        PUTA("  ",0);
        PUTA(STR1,0);
        PUTA("  AT P = ",0);
        DISP'ADDRS(P'COUNTER);
        PUT'SKIP(1);
        RETURN;

         FUNCTION MESSAGE(MSG'NO);

         STR1 ← MESS2[MSG'NO];
        PUTA("  ",0);
        PUTA(STR1,1);
        RETURN;

         END;  /*  END OF MESSAGES  */

        PROGRAM MINI'ASSM;

         INCLUDE SIMU'VARS, FIELD'DESC, SPECIAL'CHARS;

         DECLARE LABEL ARRAYONE CASE[3] ←
         (CASE1,CASE2,CASE3);

         DECLARE INTEGER
         I1,I2,I3,I4,
         ADDRS,
         DATA;

         DECLARE STRING
         STR1(100),
         STR2,
         L'FIELD(15),
         OPC'FIELD(15),
         OPR'FIELD(80);

         DECLARE CHARACTER
         C1, C2;

         FUNCTION MINI'ASSM(ADDRS), FRETURN;

         SETS(STR1,0,0);
        C1 ← INPUT'CHARACTER();
        WHILE C1 # 199 AND C1 # 200
         DO;
            IF C1 = CNTL'A
             DO;
                GCD(STR1// GOTO L1);
                OUTPUT'CHARACTER('↑');
                L1:
            ELSE
             DO;
                WCI(C1,STR1);
            ENDIF;
            C1 ← INPUT'CHARACTER();
        ENDFOR;
        C2 ← C1;
        IF LENGTH(STR1) =  0 /*  MEANING NOTHING WAS ENTERED  */
         DO;
            I1 ← GET'M(ADDRS//HELP());
            ADDRS ← ADDRS+INSTR'DATA[I1]$INCRE;
            RETURN (ADDRS,C1);
        ENDIF;
        PARSE(STR1,L'FIELD,OPC'FIELD,OPR'FIELD:STR1,L'FIELD,OPC'FIELD,
         OPR'FIELD// FRETURN);
        IF LENGTH(L'FIELD) # 0
         DO;
            ENTER'SYMBOL(ADDRS,L'FIELD// FRETURN);
        ENDIF;

         I1 ← SEARCH'OPCODE(OPC'FIELD);
        STR2 ← OPR'FIELD;
        IF I1 < 0
         DO;  /*  GET SOME OF THE OPERAND FIELD  */
        SCOPY(STR1,OPC'FIELD//HELP());
            WCI(' ',STR1);
            C1 ← GCI(STR2//MESSAGE(9) & FRETURN);
            WHILE C1 # ','
             DO;
                WCI(C1,STR1);
                C1 ← GCI(STR2// GOTO L2);
            ENDFOR;
            L2:
            I1 ← SEARCH'OPCODE(STR1);
            IF I1 < 0
             DO;  /*  GET SOME MORE OF THE OPERAND FIELD  */
            WCI(',',STR1);
                C1 ← GCI(STR2//MESSAGE(9) & FRETURN);
                WHILE 1
                 DO;
                    WCI(C1,STR1);
                    C1 ← GCI(STR2// GOTO L3);
                ENDFOR;
                L3:
                I1 ← SEARCH'OPCODE(STR1);
                IF I1 < 0
                 DO;  /*  OUT OF LUCK  */
                MESSAGE(9);
                    FRETURN;
                ENDIF;
            ENDIF;
        ENDIF;

*      AT THIS POINT "I1" SHOULD CONTAIN THE OPCODE INDEX AND "STR2"
*      CONTAINS "ENOUGH" OF THE OPERAND.

         DATA$B'0'7 ← I1$B'16'23;
        I2 ← INSTR'INCRE[I1];
        IF I2 = -1
         DO;  /*  TRAP  */
        MESSAGE(9);
            FRETURN;
        ENDIF;
        GOTO CASE[I2];

         CASE1:  /*  SINGLE BYTE INSTRUCTION  */
        GOTO COM;

         CASE2:  /*  2 BYTE  */
        I3 ← EVALUATE(STR2// FRETURN);
        DATA$B'8'15 ← I3$B'16'23;
        GOTO COM;

         CASE3:  /*  3 BYTE  */
        I3 ← EVALUATE(STR2// FRETURN);
        DATA$B'8'15 ← I3$B'16'23;
        DATA$B'16'23 ← I3$B'8'15;
        GOTO COM;

         COM:
        FOR I4 ← 1 TO I2
         DO;
            PUT'M(DATA$B'0'7,ADDRS// FRETURN);
            ADDRS ← ADDRS+1;
            DATA ← DATA LCY 8;
        ENDFOR;
        RETURN (ADDRS,C2);

         END;  /*  END MINI'ASSM  */

        PROGRAM NEAREST;

         DECLARE INTEGER
         I1, I2, LENT, IN;

         DECLARE CHARACTER
         C1;
        DECLARE STRING
         ARG1,
         EXP(80);

         INTEGER FUNCTION NEAREST(ARG1);

         SETS(EXP, 0, 0);
        IN ← -1;
        C1 ← GCI(ARG1);
        WHILE 1
         DO;
            IF C1 = 7B
             DO;
                IN ← - IN;
                WCI(C1, EXP);
                C1 ← GCI(ARG1// GOTO L1);
            ENDIF;
            IF IN = 1
             DO;
                WCI('!', EXP);
            ELSE
             DO;
                WCI(C1, EXP);
            ENDIF;
            C1 ← GCI(ARG1// GOTO L1);
        ENDFOR;
L1:
        I1 ← INDEX(EXP, "+");
        I2 ← INDEX(EXP, "-");
        LENT ← LENGTH(EXP) + 1;
        IF I1 <= 0
         DO;
            I1 ← LENT;
        ENDIF;
        IF I2 <= 0
         DO;
            I2 ← LENT;
        ENDIF;
        IF I1 < I2
         DO;
            RETURN I1;
        ELSE
         DO;
            RETURN I2;
        ENDIF;

         END;  /*  END OF NEAREST  */

        PROGRAM PARSE;

         DECLARE STRING
         LINE,
         LABEL'FIELD,
         OPCODE'FIELD,
         OPERAND'FIELD;

         DECLARE CHARACTER
         FIRST,
         C1;

         DECLARE INTEGER
         IN;

         FUNCTION PARSE(LINE, LABEL'FIELD, OPCODE'FIELD, OPERAND'FIELD),
         FRETURN;

         SETS(LABEL'FIELD, 0, 0);
        SETS(OPCODE'FIELD, 0, 0);
        SETS(OPERAND'FIELD, 0, 0);


         FIRST ← GCI(LINE);
        WCD(FIRST,LINE);
        IF FIRST = '*'
         DO;
            RETURN (LINE,LABEL'FIELD,OPCODE'FIELD,OPERAND'FIELD);
        ENDIF;

         IF FIRST # ' '
         DO;
            C1 ← GCI(LINE);
            WHILE C1 # ' ' AND C1 # ':'
             DO;
                WCI(C1, LABEL'FIELD);
                C1 ← GCI(LINE//ERROR'MSG(8) & FRETURN);
            ENDFOR;
        ENDIF;

         C1 ← GCI(LINE// RETURN (LINE,LABEL'FIELD,OPCODE'FIELD,OPERAND'FIELD));
        WHILE C1 = ' '
         DO;
            C1 ← GCI(LINE// RETURN (LINE,LABEL'FIELD,OPCODE'FIELD,OPERAND'FIELD));
        ENDFOR;
        WHILE C1 # ' '
         DO;
            WCI(C1, OPCODE'FIELD);
            C1 ← GCI(LINE// RETURN (LINE,LABEL'FIELD,OPCODE'FIELD,OPERAND'FIELD));
        ENDFOR;

         WHILE C1 = ' '
         DO;
            C1 ← GCI(LINE// RETURN (LINE,LABEL'FIELD,OPCODE'FIELD,OPERAND'FIELD));
        ENDFOR;
        IN ← -1;
        WHILE C1 # ' ' OR IN = 1
         DO;
            IF C1 = 7B
             DO;
                IN ← -IN;
            ENDIF;
            WCI(C1,OPERAND'FIELD);
            C1 ← GCI(LINE// RETURN (LINE,LABEL'FIELD,OPCODE'FIELD,OPERAND'FIELD));
        ENDFOR;

         RETURN (LINE,LABEL'FIELD,OPCODE'FIELD,OPERAND'FIELD);

         END;  /*  END OF PARSE.  */

        PROGRAM PERCENT;
*
*  THIS PROGRAM INTERPRETS THE PERCENT COMMANDS.
*

         INCLUDE SIMU'VARS, FIELD'DESC;

         UNKNOWN MONITOR SET'LINE'FIELD ← 180;
        INTEGER UTILITY READ'CIOS'FIELD ← 41;

         DECLARE INTEGER
         I1, I2;

         DECLARE LABEL ARRAY CASE[17] ←
         (CASE0,CASE1,CASE2,CASE3,CASE4,CASE5,CASE6,CASE7);
        DECLARE LABEL ARRAY CASE[8] ←
         (CASE8,CASE9,CASE10,CASE11,CASE12,CASE13,CASE14);
        DECLARE LABEL ARRAY CASE[15] ←
         (CASE15,CASE16);

         FUNCTION PERCENT();

         I1 ← CINDEX(INPUT'CHARACTER(),"FODLHMPNRSTUVWAC");
        GOTO CASE[I1];

         CASE0:
        MESSAGE(6);
        GOTO COM;

         CASE1:
        I1 ← READ'CIOS'FIELD(-1,'OPN'//HELP()) LSH 1;
        SET'LINE'FIELD(I1,'EST',1//HELP());
        PUT'SKIP(1);
        EXIT();

         CASE2:
        MODE ← 0;
        GOTO COM;

         CASE3:
        MODE ← 1;
        GOTO COM;

         CASE4:
        PRINT'B'P();
        GOTO COM;

         CASE5:
        MODE ← 2;
        GOTO COM;

         CASE6:
        MODE ← 3;
        GOTO COM;

         CASE7:
        PROCEED'B'P();
        GOTO COM2;

         CASE8:
        I1 ← -1;
*       BEFORE SINGLE STEPPING, FIRST CHECK TO SEE IF THE P'COUNTER
*       POINTS TO A BREAK.  IF IT DOES WARN THE USER THAT THE
*       BREAK POINT WILL BE TEMPORARILY CLEARED FOR THE SINGLE
*       STEP.  WE THEN PROCEED TO SINGLE STEP THRU THE
*       INSTRUCTION.
*       AN ADDITIONAL POINT.  THE CONTROL-BREAK MODE WILL
*       TEMPORARILY BE TURNED OFF.
         I2 ← CONTROL'BREAK;
        CONTROL'BREAK ← 0;
        IF SEARCH'B'P(P'COUNTER) # - 1 /*  B'P EXISTS  */
         DO;
            PUTA("  BPT NOT SET",1);
            I1 ← P'COUNTER;
            KILL'B'P(I1);
        ENDIF;
        INTERP(1// GOTO COM);
        CONTROL'BREAK ← I2;
        PUTA("  SS BREAK AT P = ",0);
        DISP'ADDRS(P'COUNTER);
        IF I1 # - 1 /*  WE MUST RESET THE BREAK POINT  */
         DO;
            SET'B'P(I1);
        ENDIF;
        GOTO COM;

         CASE9:
        DUMP'BREAK ← 1;
        GOTO COM;

         CASE10:
        DUMP'BREAK ← 0;
        GOTO COM;

         CASE11:
        CONTROL'TRACE ← 1;
        GOTO COM;

         CASE12:
        CONTROL'TRACE ← 0;
        GOTO COM;

         CASE13:
        CONTROL'BREAK ← 1;
        GOTO COM;

         CASE14:
        CONTROL'BREAK ← 0;
        GOTO COM;

         CASE15:
        FOR I1 ← 0 TO 7
         DO;
            OLD'STORE[I1]$OLD'COUNT ← 0;
        ENDFOR;
        PUT'SKIP(1);
        DUMP'REG();
        GOTO COM;

         CASE16: /*  %C  CONTINUE COMMAND  */
*        WE FIRST TURN OFF THE CONTROL BREAK MODE MOMENTARILY
*        THEN SINGLE STEP AN INSTRUCTION AND THEN
*        RESET THE CONTROL BREAK MODE THEN CONTINUE ON.
         I1 ← CONTROL'BREAK;
        CONTROL'BREAK ← 0;
        INTERP(1//CONTROL'BREAK ← I1 & GOTO COM);
        CONTROL'BREAK ← I1;
        INTERP(0// GOTO COM);
        GOTO COM;

         COM:
        PUT'SKIP(1);
        COM2:
        RETURN 307B;

         END;  /*  END PERCENT.  */

        PROGRAM PUTN;

         DECLARE INTEGER
         LINE'FEEDS,
         NUMBER;

         FUNCTION PUTN(NUMBER, LINE'FEEDS);

         OUTPUT'NUMBER(NUMBER);
        IF LINE'FEEDS = 0
         DO;
            RETURN;
        ENDIF;

         PUT'SKIP(LINE'FEEDS);
        RETURN;

         END;  /*  END PUTN  */

        PROGRAM PUT'SKIP;

         INCLUDE SPECIAL'CHARS;

         DECLARE INTEGER
         I1,
         SKIPS;

         FUNCTION PUT'SKIP(SKIPS);

         RETURN IF SKIPS < 1;
        OUTPUT'CHARACTER(CR);
        FOR I1 ← 1 TO SKIPS
         DO;
            OUTPUT'CHARACTER(LF);
        ENDFOR;
        RETURN;

         END;  /*  END OF PUT'SKIP.  */

        PROGRAM READ'SYMBOL;
*
*  THIS FUNCTION READS IN THE SYMBOL TABLE DUMPED BY THE CROSS-ASSEM-
*  BLER.  THIS ALLOWS THE RUNTIME TO RECOGNIZE SYMBOLS.
*

         INCLUDE SIMU'VARS, SEQ'FILE'DEFS;

         DECLARE CHARACTER
         C1, C2;

         DECLARE INTEGER
         I1, I2, I3,
         FILE'NO,
         SORTED;

         DECLARE STRING
         NAME(15),
         SYMBOL'STRING,
         STR1(10),
         BUFR(100);

         FUNCTION READ'SYMBOL();

         L3:
        PUTA("TABLE FILE:  ",0);
        NAME ← INFILE(NAME// RETURN);
        FILE'NO ← OPEN'SEQ'FILE(NAME,READ'FILE,SYMBOLIC'FILE,
         8// GOTO L3);
        SETUP(SYMBOL'STRING,6,SYMBOL'START,8);
        LAST'SYMBOL ← 0;
        SETS(SYMBOL'STRING,0,0);
        WHILE 1
         DO;
            BUFR ← INPUT'SEQ'FILE(FILE'NO,BUFR//HELP());
            GOTO L2 IF LENGTH(BUFR) = 0;
            GCD(BUFR);
            GCD(BUFR);
            WHILE 1
             DO;
                C1 ← GCI(BUFR// GOTO L4);
                FOR I1 ← 1 TO 5
                 DO;
                    IF C1 = ','
                     DO;
                        WCI(' ',SYMBOL'STRING);
                    ELSE
                     DO;
                        WCI(C1,SYMBOL'STRING);
                        C1 ← GCI(BUFR);
                    ENDIF;
                ENDFOR;
                C1 ← GCI(BUFR);
                SETS(STR1,0,0);
                WHILE C1 # ','
                 DO;
                    WCI(C1, STR1);
                    C1 ← GCI(BUFR// GOTO L1);
                ENDFOR;
                L1:
                VALUES[LAST'SYMBOL] ← CSN(STR1,16//HELP());
                LAST'SYMBOL ← LAST'SYMBOL + 1;
                SETUP(SYMBOL'STRING,6,(SYMBOL'START+(LAST'SYMBOL LSH 1)),8);
            ENDFOR;
            L4:
        ENDFOR;
        L2:
        CLOSE'SEQ'FILE(FILE'NO//HELP());

         FOR I1 ← 0 TO LAST'SYMBOL
         DO;
            SORT'PTRS[I1] ← I1;
        ENDFOR;
        I1 ← LAST'SYMBOL;
        SORTED ← 0;
        WHILE NOT SORTED
         DO;
            SORTED ← 1;
            FOR I2 ← 0 TO I1-1
             DO;
                IF VALUES[SORT'PTRS[I2]] > VALUES[SORT'PTRS[I2+1]]
                 DO;
                    I3 ← SORT'PTRS[I2];
                    SORT'PTRS[I2] ← SORT'PTRS[I2+1];
                    SORT'PTRS[I2+1] ← I3;
                    SORTED ← 0;
                ENDIF;
            ENDFOR;
            I1 ← I1 - 1;
        ENDFOR;
        PUTA("LOADING COMPLETE",1);
        RETURN;

         END;  /*  END READ'SYMBOL  */

        PROGRAM SEARCH'ADDRS;
*  
*  THIS FUNCTION SEARCHES THE SYMBOL TABLE FOR A SYMBOL WHOSE VALUE
*  IS LESS THAN OR EQUAL TO SEARCH'ADDRS PARAMETER.  THIS FUNCTION
*  IS USED BY DISP'ADDRS.
*

         INCLUDE SIMU'VARS;

         DECLARE INTEGER
         HIGH,
         LOW,
         I1, I2,
         ADDRS;

         FUNCTION SEARCH'ADDRS(ADDRS);

         RETURN -1 IF LAST'SYMBOL = -1;
        HIGH ← LAST'SYMBOL;
        I1 ← LOW ← 0;
        WHILE HIGH >= LOW
         DO;
            I1 ← (HIGH+LOW)/2;
            I2 ← VALUES[SORT'PTRS[I1]];
            IF ADDRS < I2
             DO;
                HIGH ← I1 - 1;
            ELSEIF ADDRS > I2
             DO;
                LOW ← I1+1;
            ELSE
             DO;
                RETURN I1;
            ENDIF;

         ENDFOR;
        RETURN I1;

         END;  /*  END OF SEARCH'ADDRS  */

        PROGRAM SEARCH'B'P;
*
*  THIS FUNCTIONS SEARCHES THE BREAK POINT TABLE FOR 'ADDRS'.
*

         INCLUDE SIMU'VARS;

         DECLARE INTEGER
         ADDRS,
         HIGH,
         LOW,
         I1, I2;

         FUNCTION SEARCH'B'P(ADDRS);

         RETURN -1 IF NEXT'B'P = 0;
        HIGH ← NEXT'B'P - 1;
        LOW ← 0;
        WHILE HIGH >= LOW
         DO;
            I1 ← (HIGH+LOW)/2;
            I2 ← B'P'TABLE[I1];
            IF ADDRS > I2
             DO;
                LOW ← I1+1;
            ELSEIF ADDRS < I2
             DO;
                HIGH ← I1-1;
            ELSE
             DO;
                RETURN I1;
            ENDIF;
        ENDFOR;

         RETURN -1;

         END;  /*  END SEARCH'B'P  */

        PROGRAM SEARCH'SYMBOL;
*
*  THIS FUNCTION SEARCHES THE SYMBOL TABLE USING A BINARY
*  SEARCH TECHINQUE.  IT IS USED PRIMARILY BY THE EXPRESSION EVALUATOR.
*

         INCLUDE SIMU'VARS;

         DECLARE INTEGER
         HIGH,
         LOW,
         HBOUND,
         I1;

         DECLARE STRING
         TOKEN,
         STR1;

         FUNCTION SEARCH'SYMBOL(TOKEN, HBOUND), FRETURN;

         HIGH ← HBOUND;
        LOW ← 0;
        WHILE HIGH >= LOW
         DO;
            I1 ← (HIGH+LOW)/2;
            SETUP(STR1,5,SYMBOL'START+(I1 LSH 1),8);
            SETS(STR1,0,5);
            IF LLT(TOKEN,STR1//HELP()) = -1
             DO;
                HIGH ← I1-1;
            ELSEIF LGT(TOKEN,STR1//HELP()) = -1
             DO;
                LOW ← I1+1;
            ELSE
             DO;
                RETURN I1;
            ENDIF;
        ENDFOR;
        FRETURN;

         END;  /*  END SEARCH'SYMBOL  */

        PROGRAM SORT'TABLE;

         INCLUDE SIMU'VARS;

         DECLARE INTEGER
         I1, I2, I3,
         SORTED;

         FUNCTION SORT'TABLE();

         FOR I1 ← 0 TO LAST'SYMBOL
         DO;
            SORT'PTRS[I1] ← I1;
        ENDFOR;
        I1 ← LAST'SYMBOL;
        SORTED ← 0;
        WHILE NOT SORTED
         DO;
            SORTED ← 1;
            FOR I2 ← 0 TO I1-1
             DO;
                IF VALUES[SORT'PTRS[I2]] > VALUES[SORT'PTRS[I2+1]]
                 DO;
                    I3 ← SORT'PTRS[I2];
                    SORT'PTRS[I2] ← SORT'PTRS[I2+1];
                    SORT'PTRS[I2+1] ← I3;
                    SORTED ← 0;
                ENDIF;
            ENDFOR;
            I1 ← I1 - 1;
        ENDFOR;

         RETURN;
        END;

        PROGRAM SUBSTR;

         DECLARE STRING
         SOURCE,                 /*  SOURCE STRING  */
         TARGET,                 /*  TARGET STRING  */
         TMP1;                   /*  TEMPORARY DESCRIPTOR  */

         DECLARE INTEGER
         START,                  /*  START OF CHARACTER POSITION  */
         LENT,                   /*  LENGTH OF SUBSTRING REQUIRED  */
         I1;                     /*  INDEX VARIABLE  */

         STRING FUNCTION SUBSTR(SOURCE, START, LENT, TARGET);

         SETS(TARGET, 0, 0);
        IF LENT = 0
         DO;
            RETURN TARGET;
        ENDIF;
        TMP1 ← SOURCE;
        TMP1 ← CHOP(TMP1, START -1);
        FOR I1 ← 1 TO LENT
         DO;
            WCI(GCI(TMP1// GOTO STRINGRANGE), TARGET// GOTO STRINGSIZE);
        ENDFOR;
        RETURN (TARGET);

         STRINGRANGE:  /*  STRINGRANGE CONDITION RAISED  */
        PUTA("STRINGRANGE CONDITION RAISED.  PARAMETERS ARE:",1);
        PUTA(SOURCE,1);                                                            PUTN(START,1);                                                            PUTN(LENT, 1);
        EXIT();

         STRINGSIZE:  /*   STRINGSIZE CONDITION RAISED  */
        PUTA("STRINGSIZE CONDITION RAISED.  PARAMETERS ARE:", 1);
        PUTA(SOURCE,1);                                                            PUTN(START,1);                                                            PUTN(LENT, 1);
        EXIT();

         END;  /*  END OF 'SUBSTR'.  */

        PROGRAM VERIFY;

         DECLARE STRING
         FIRST,
         SECOND,
         DUMMY(1);

         DECLARE INTEGER
         I1;

         INTEGER FUNCTION VERIFY(FIRST, SECOND);

         FOR I1 ← 1 TO LENGTH(FIRST)
         DO;
            IF INDEX(SECOND, SUBSTR(FIRST, I1, 1, DUMMY)) = 0
             DO;
                RETURN I1;
            ENDIF;
        ENDFOR;
        RETURN 0;

         END;  /*  END OF VERIFY.  */

        PROGRAM TEST;

         DECLARE INTEGER
         E1,E2,
         I1,I2, I3, I4, I5, I6;

         FUNCTION TEST();

         I1 ← FIND("0XYZ"//PUTA("FAILED",1) & RETURN);
        PUTN(I1,1);
        RETURN;

         END;
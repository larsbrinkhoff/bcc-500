*
*       RUNOFF IS COMPOSED OF 5 SEPARATE PACKAGES
*
*
*           1)  NOP
*           2)  NCP
*           3)  NTP
*           4)  NFP
*           5)  NIP
*
******** RUNOFF (HOW TO LOAD AND RUN)  FIRST SEPARATE THE PACKAGES INTO FILES.
       @QRUN

       ;T   RUNOFF-NIP.
       IDENT.   IPROC   2564

       ;T   RUNOFF-NFP.
       IDENT.   FPROC   13357

       %R   20303100   12
       20B6,12;R
       4000;T   RUNOFF-NCP.
       IDENT.   CPROC   10026

       ;T RUNOFF-NOP.
       IDENT.   OPROC   12054

       ;T RUNOFF-NTP.
       IDENT.   TPROC   16525

       ;U

       %R   20323335   12
       20323335,303112;R
       ..;G
        3/12/71
       INPUT FROM: R-6.

       OUTPUT TO: FOO.

       %F
       @

****************     NOP     *******************

**QSPL
       IDENT OPROC;


* GENERAL FIELD AND PARAMETER DEFINITIONS FOR RUNOFF

* FIELDS FOR STRING DESCRIPTORS
DECLARE FIELD $BPTR(0), $RPTR(1), $WPTR(2), $EPTR(3);
DECLARE FIELD CH1(0:0,7),CH2(0:8,15),CH3(0:16,23);

* CHARACTER VALUE DEFINITIONS
DECLARE PARAMETER NILCH ← 200B, BOPCH ← 201B, VSPCH ← 202B,
       EODCH ← 204B, TABCH ← 211B, COMCH ← 213B,
       EOLCH ← 215B, BFNCH ← 216B, EFNCH ← 217B;

DECLARE MACRO BIO(F,C,SL) ← POP(576B, F, C,, SL);

* TEXT FIELDS AND PARAMETERS
DECLARE FIELD LTYPF(0: 0, 2), CTYPF(0: 3, 5), ADDRF(0: 10, 23);
DECLARE MACRO RTYPE(X) ← LTYPF(COMCD) OR CTYPF(2) OR CH2(X);
DECLARE PARAMETER LINCD ←0, TABCD ← 1, FLDCD ← 2, CNTCD ← 3,
       STRCD ← 6, COMCD ← 7,
       SFLCD ← LTYPF(COMCD) OR CTYPF(1),
       PMDCD ← RTYPE(1), HMDCD ← RTYPE(2), BPGCD ← RTYPE(3),
       EPGCD ← RTYPE(4), VSPCD ← RTYPE(5), LLACD ← RTYPE(6),
       HLACD ← RTYPE(7), PLACD ← RTYPE(8), PGNCD ← RTYPE(9),
       ODPCD ← RTYPE(10), EJECD ← RTYPE(11), HYBCD ← RTYPE(12),
       INPCD ← RTYPE(13);

* EXTERNALS
DECLARE *FILLF, *FMTP, *PAGF, *DOF, *ERFLG, *CMB,
       *CNCTR, *SYPPC, *MAX, *MIN, *SBLK, *DSPF;

* MARGIN TABLES
DECLARE FIXED ARRAY $AMAR(7) ← PRLA, NLAM, NRAM, NTAM,
       NBAM, NLILN, NLORG;
DECLARE FIXED ARRAY $OAMAR(7) ← 0, LAMAR, RAMAR, TAMAR, BAMAR,
       LINORG, LINLEN;
DECLARE FIXED ARRAY $LMAR(5) ← PRLL, NLLM, NRLM, NNCL, NCSP;
DECLARE FIXED ARRAY $OLMAR(5) ← 0, LHMAR, RHMAR, NCOL, ZMAR;
DECLARE FIXED ARRAY $PMAR(4) ← PRPL, NTPM, NBPM, NPTOL;
DECLARE FIXED ARRAY $OPMAR(4) ← 0, TPMAR, BPMAR, PSLOP;
DECLARE FIXED ARRAY $IMAR(3) ← PRRM, NLLM, NRLM;
DECLARE FIXED ARRAY $UMAR(3) ← PREM, NLLM, NRLM;
DECLARE FIXED ARRAY $ORMAR(3) ← 0, ZMAR, ZMAR;
DECLARE ZMAR ← 0;


DECLARE LAMAR, LLMAR, LHMAR, RAMAR, RLMAR, RHMAR, NCOL, CSPC;* LINE MARGINS
DECLARE LINORG, LINLEN, MLLM, MRLM, MXLM, NLILN, NLORG;
DECLARE NLAM, NLLM, NRAM, NRLM, NNCL, NCSP;

DECLARE BAMAR, BPMAR, TAMAR, TPMAR, PSLOP;* PAGE MARGINS
DECLARE NBAM, NBPM, NTAM, NTPM, NPTOL;

DECLARE *TOPGC, GAM3, TOPFC, TOPFB, TOPLI, TOPPI, TOPLM,
       OBFF, OBFL, OBFP, OBFIF, PTCHN, PTCHW, PTCHC;

DECLARE MACRO STERF()← ERFLG ← ERFLG + 1;

* CONTROL FUNCTIONS FOR LINE FORMATTING
FUNCTION USLM(); PRER() WHILE PRCMS > 0; RETURN;

FUNCTION PRLA();
       (STERF() & RETURN) IF MIN(NLORG + NLILN - NLAM, NRAM - NLORG) <=
               MAX(NLAM - NLORG, NLORG + NLILN - NRAM) OR
          NLILN <= 25 OR NBAM - NTAM <= 6;
       USLM(); LAMAR ← NLAM; RAMAR ← NRAM; NCOL ← 1; CSPC ← 0;
       LINORG ← NLORG; LHMAR ← 15; LLMAR ← 0;
       RHMAR ← (LINLEN ← NLILN) - 10; MXLM ← RLMAR ← RHMAR - LHMAR;
       MRLM ← MIN(LINLEN, MIN(RAMAR - LINORG, LINLEN + LINORG - LAMAR));
       MLLM ← MAX(0, MAX(LAMAR - LINORG, LINORG + LINLEN - RAMAR));
       TPMAR ← TAMAR ← NTAM; BPMAR ← (BAMAR ← NBAM) - 6; PSLOP ← 4;
       DMPL(); DMHL(); DMLL(); RETURN;

FUNCTION PRLL(); USLM();
       (STERF() & RETURN) IF NRLM > MRLM OR NNCL <= 0 OR NLLM < MLLM
            OR NCSP < 0 OR (NRLM - NLLM - NCSP *(NNCL - 1))/ NNCL <= 0;
       LHMAR ← NLLM; RHMAR ← NRLM; LLMAR ← 0; NCOL ← NNCL; CSPC ← NCSP;
       MXLM ← RLMAR ← (RHMAR - LHMAR - CSPC *(NCOL - 1))/ NCOL;
       DMHL(); DMLL(); RETURN;

* RELATIVE MARGINS
DECLARE PRCMS, PRCMT;
FUNCTION PREM(), LINK XPRER;
       NLLM ← LLMAR - NLLM; NRLM ← RLMAR + NRLM; GOTO PRCM;

FUNCTION PRRM(), LINK XPRER;
       NLLM ← LLMAR + NLLM; NRLM ← RLMAR - NRLM;

PRCM:  PRCMT ← MAKE(3); PRCMT[0] ← LLMAR; PRCMT[1] ← RLMAR;
       PRCMT[2] ← PRCMS; PRCMS ← PRCMT;
       (LLMAR ← NLLM & RLMAR ← NRLM) IF NRLM <= MXLM AND NRLM > NLLM AND
               NLLM >= 0 ELSE STERF();
       DMLL(); RETURN;

FUNCTION $PRER(), LINK XPRER; RETURN IF PRCMS = 0;
       PRCMT ← PRCMS; PRCMS ← PRCMT[2]; RLMAR ← PRCMT[1];
       LLMAR ← PRCMT[0]; FREE(PRCMT); DMLL(); RETURN;

* PARAGRAPH SPACING
FUNCTION $PRPI(TOPPI); RETURN;
FUNCTION $PRPU(TOPPI); TOPPI ← - TOPPI; RETURN;

FUNCTION $PRIN(TOPLI); RETURN;
FUNCTION $PRUN(TOPLI); TOPLI ← - TOPLI; RETURN;

* SINGLE LINE COMMANDS
FUNCTION $PRCE(); TOPLM ← 1; RETURN;
FUNCTION $PRMA(); TOPLM ← 2; RETURN;

* CONTROL FUNCTIONS FOR PAGE FORMATTING
FUNCTION PRPL(); GOTO PRPLE IF TAMAR > NTPM OR NBPM > BAMAR OR
               NBPM <= NTPM OR (NBPM - NTPM) <= NPTOL;
       TPMAR ← NTPM; BPMAR ← NBPM; PSLOP ← NPTOL; DMPL(); RETURN;
PRPLE: STERF(); RETURN;

FUNCTION $PREJ(TOPTS); TOPPW(EJECD OR CH3(TOPTS)); RETURN;
FUNCTION $PROP(); TOPPW(ODPCD); RETURN;
FUNCTION $PRPN(TOPTS); TOPPW(PGNCD OR CH3(TOPTS)) IF TOPTS > 0;
       OFLAG(SFLCD, @PAGF, -1); RETURN;
FUNCTION $PRIP(TOPTS); TOPPW(INPCD OR CH3(TOPTS)); RETURN;

FUNCTION $PRHM(TOPTS); TOPPW(HMDCD OR CH3(TOPTS)); RETURN;
FUNCTION $PRPH(TOPTS); TOPPW(PMDCD OR CH3(TOPTS)); RETURN;

FUNCTION $PRBG(); CINIT(BPGCD); CFILL(); RETURN;
FUNCTION $PREG(); CINIT(EPGCD); CFILL(); RETURN;
FUNCTION $PRFS(TOPTS); PRBG(); PRSP(TOPTS); PREG(); RETURN;

FUNCTION $PRSP(TOPTS); TOPTS ← 1 IF TOPTS < 0;
       SYPPC(VSPCH); TLF(TOPTS); RETURN;

FUNCTION $PRHB(TOPTS); CINIT(HYBCD OR CH3(TOPTS)); CFILL(); RETURN;

FUNCTION $PRPS(TOPPS); RETURN;

* COLLECT AND OUTPUT STRING FOR PFP
FUNCTION $CPCS(CPCSC, CPCST); CINIT(LTYPF(STRCD) OR CTYPF(CPCST));

CPCS1: CPCST ← GCI(CMB: CPCS5); GOTO CPCS2 IF CPCST = CPCSC;
       PTCH(CPCST); GOTO CPCS1;

CPCS2: PTCH(EOLCH); SBLK(CPCS3);
CPCS3: CFILL(); SRETURN;

CPCS5: STERF(); CFILL(); RETURN;

FUNCTION $OFLAG(LTYP, OFLAGF, OFLAGV); CINIT(LTYP OR ADDRF(OFLAGF));
       CFILL(); $OFLAGF ← OFLAGV; RETURN;

FUNCTION CINIT(LTYP); DECLARE OBFCF; OBFCF ← OBFIF;
       (PTCH(COMCH) & TFILL()) IF OBFCF < 0; TINIT(LTYP); RETURN;
FUNCTION CFILL(); TFILL(); TINIT(LTYPF(CNTCD)) IF OBFCF < 0; RETURN;

FUNCTION DMPL(); TOPPW(PLACD OR CH3(TPMAR - TAMAR));
       TOPPW(CH1(BPMAR - TAMAR) OR CH3(PSLOP)); RETURN;

FUNCTION DMHL(); TOPPW(HLACD OR CH3(RHMAR - LHMAR));
       TOPPW(CH1(LINLEN - RHMAR + LINORG - LAMAR) OR
               CH3(LHMAR + LINORG - LAMAR));
       TOPPW(CH1(NCOL) OR CH3(CSPC)); RETURN;

FUNCTION DMLL(); TOPPW(LLACD OR CH3(LLMAR)); TOPPW(RLMAR); RETURN;

* OUTPUT BUFFERING FUNCTIONS FOR PASS 3

FUNCTION TINIT(LTYP); FTLERR() IF OBFIF < 0;

       TOPPW(LTYP);* SET UP HEADER WORD

* INITIALIZE PTCH, AND RETURN
       PTCHN ← 2; OBFIF ← -1; RETURN;

FUNCTION TFILL(); RETURN IF OBFIF >= 0;
IF PTCHN = 0 DO; PTCHW ← PTCHW LSH 8 OR CH3(NILCH); GOTO TFL1;
ELSEIF PTCHN = 1 DO; PTCHW ← PTCHW LSH 16 OR (CH2(NILCH) OR CH3(NILCH));
       GOTO TFL1;
ELSE DO; GOTO TFL2;
ENDIF;

TFL1:  TOPPW(PTCHW);
TFL2:  OBFIF ← 0; RETURN;

* PUT CHARACTER INTO OUTPUT BUFFER, AND DUMP ON OVERFLOW
FUNCTION PTCH(PTCHC); FTLERR() IF OBFIF >= 0;
       PTCHW ← PTCHW LSH 8 OR PTCHC; RETURN IF (PTCHN ← PTCHN - 1) >= 0;
       TOPPW(PTCHW); PTCHN ← 2; RETURN;

* OUTPUT BLANK LINES
FUNCTION TLF(PTCHC); TOPPW(VSPCD OR ADDRF(PTCHC)); RETURN;

FUNCTION TOPPW(TOPWD); $OBFP ← TOPWD; RETURN IF (OBFP ← OBFP + 1) < OBFL;
       BIO(DOF, 256, OBFF: FTLERR); OBFP ← OBFF; RETURN;

*
* TEXT OUTPUT COROUTINE
*

* INITIAL LAYOUTS FOR DEVICES
DECLARE FIXED ARRAY ILAM[3] ← 6, 5, 0;
DECLARE FIXED ARRAY IRAM[3] ← 89, 137, 512;
DECLARE FIXED ARRAY ILOR[3] ← 0, 15, 0;

* INITIALIZE TOP
FUNCTION $ITOP(TOPTS);
       OBFP ← OBFF ← MAKE(256); OBFL ← OBFF + 256; OBFIF ← 0;
       FMTP ← FILLF ← -1; PRCMS ← 0;
       NLAM ← ILAM[TOPTS]; NRAM ← IRAM[TOPTS]; NTAM ← 6; NBAM ← 66;
       NLILN ← 85; NLORG ← ILOR[TOPTS]; PRLA();
       TOPLM ← 0; TOPPS ← 1; TOPPI ← 5; TOPGC ← CNCTR(FTLERR); RETURN;

FUNCTION $TOP();

* BETWEEN LINE COLLECTION
TOP1:  GAM3 ← TOPGC(); RETURN IF GAM3 = EODCH ELSE
       GOTO TOP1 IF GAM3 = EOLCH OR GAM3 = VSPCH;

TOP2:  GOTO FTP1 IF FMTP >= 0 ELSE GOTO LTP1;

TOP3:  GAM3 ← TOPGC(); RETURN IF GAM3 = EODCH ELSE
       GOTO TOP3 IF GAM3 = EOLCH ELSE GOTO TOP1 IF GAM3 = VSPCH ELSE
       TLF(TOPPS) IF GAM3 = BOPCH; GOTO TOP2;

FUNCTION $DTOP(); BIO(DOF, OBFP - OBFF, OBFF: FTLERR);
       FREE(OBFF); FREE(TOPGC); RETURN;

* FILL/NOFILL LINE COLLECTION
LTP1:  TOPFB ← ((GAM3 ← TOPGC() & TOPPI) IF GAM3 = BOPCH ELSE 0) + TOPLI;
       TOPLI ← TOPFB + LLMAR; (STERF() & TOPFB ← 0) IF TOPLI < 0 OR
               RLMAR - TOPLI <= 0;
       TINIT(LTYPF(LINCD) OR CTYPF(TOPLM) OR ADDRF(TOPFB));
       TOPLI ← TOPLM ← 0;

LTP2:  PTCH(GAM3); (TFILL() & GOTO TOP3) IF GAM3 = EOLCH;
       GAM3 ← TOPGC(); GOTO LTP2;

* TABLE ENTRY COLLECTION
FTP1:  TINIT(LTYPF(TABCD) OR ADDRF(FMTP));
       TOPFC ← FMTP.CH3; GAM3 ← TOPGC() IF GAM3 = BOPCH;

FTP2:  PTCH(GAM3); (TFILL() & GOTO TOP3) IF GAM3 = EOLCH;
       ((STERF() & GOTO FTP3) IF (TOPFC ← TOPFC - 1) < 0)
               IF GAM3 = TABCH;
       GAM3 ← TOPGC(); GOTO FTP2;

FTP3:  GAM3 ← TOPGC(); GOTO FTP3 IF GAM3 # EOLCH ELSE GOTO TOP3;

       END;

***************  NCP  *******************

**QSPL
       IDENT CPROC;

* GENERAL FIELD AND PARAMETER DEFINITIONS FOR RUNOFF

* FIELDS FOR STRING DESCRIPTORS
DECLARE FIELD BPTR(0), RPTR(1), WPTR(2), EPTR(3);
DECLARE FIELD CH1(0:0,7), CH2(0:8,15), CH3(0:16,23);
DECLARE FIELD LKPTR(0: 10, 23), LENGF(-1: 10, 23);

* CHARACTER VALUE DEFINITIONS
DECLARE PARAMETER DQCH ← 2, CSHFT ← 40B,
       EOCCH ← 203B, EOPCH ← 214B, EOLCH ← 215B;

* EXTERNAL ARRAYS, STRINGS, AND ROUTINES FOR PROCESSORS
DECLARE EXTERNAL ARRAY AMAR, LMAR, PMAR, IMAR, UMAR,
       OAMAR, OLMAR, OPMAR, ORMAR;

DECLARE EXTERNAL PRCL,PREJ,PRHM,PRCE,PRMA,PROP,PRPH,PRPN,PRIP,PRPS,PRSH;
DECLARE EXTERNAL PRFS,PRES,PRLI,PRSP,PRIN,PRPI,PRPU,PRUN,PRER;
DECLARE EXTERNAL PRTC,PRDF,PRFM,PRFI,PRNF,PRBG,PREG,PRHB,PRISS;

DECLARE *DSPF, *HYPF, *ULNF, *JUSTF, *FILLF, *FMTP, *PAGF, *TOPGF, *ERFLG;
DECLARE *CNCTR, *CONEC, *TRUNC, *LKP, *INS, *CPCS, *INSGW,
       *CVCGC, *GCHPC, *TOPGC, *SYPPC;

DECLARE PARAMETER HESCD ← 0, PFSCD ← 1, SCSCD ← 2, SFSCD ← 3, IXSCD ← 4;

DECLARE MACRO INC(X, Y) ← X ← X + (Y);

* CURRENT COMMAND TABLES
DECLARE LCTAB, ARRAY ATAB, STAB, CTAB;

* COMMAND TABLES
DECLARE PARAMETER LNCTAB ← 44;
DECLARE STRING STSAD ← "ADJUST", STSBG ← "BEGIN GROUP", STSBR ← "BREAK",
   STSCL ← "CALL", STSCE ← "CENTER", STSDC ← "DEFINE COMMAND",
   STSDF ← "DEFINE FORMAT", STSDS ← "DOUBLE SPACE", STSEJ ← "EJECT";
DECLARE STRING STSEC ← "END COMMAND", STSEF ← "END FORMAT",
   STSEG ← "END GROUP", STSER ← "END REDUCTION", STSES ← "ESCAPE",
   STSEM ← "EXPAND MARGIN", STSFS ← "FIGURE SPACING", STSFI ← "FILL",
   STSFM ← "FORMAT", STSGL ← "GLOSSARY", STSHE ← "HEADER";
DECLARE STRING STSHM ← "HEADING MODE", STSHY ← "HYPHENATE",
   STSHB ← "HYPHENATION BREAK", STSIN ← "INDENT",
   STSIP ← "INCREMENT PAGE", STSIX ← "INDEX",
   STSLA ← "LAYOUT", STSLL ← "LINE LAYOUT", STSLI ← "LITERAL",
   STSMA ← "MARGIN", STSNF ← "NOFILL";
DECLARE STRING STSNH ← "NOHYPHEN", STSNJ ← "NOJUST",
   STSOP ← "ODD PAGE", STSPN ← "PAGE", STSPL ← "PAGE LAYOUT",
   STSPM ← "PAGING MODE", STSPI ←  "PARAGRAPH INDENTATION";
DECLARE STRING STSPS ← "PARAGRAPH SPACING",
   STSPU ← "PARAGRAPH UNDENTATION", STSRM ← "REDUCE MARGIN",
   STSSS ← "SINGLE SPACE", STSSP ← "SPACE",
   STSTC ← "TAB CHARACTER", STSUN ← "UNDENT", STSUL ← "UNDERLINE";
DECLARE FIXED ARRAY NSTAB(LNCTAB) ← STSAD, STSBG, STSBR, STSCL, STSCE,
   STSDC, STSDF, STSDS, STSEJ, STSEG, STSER, STSES, STSEM, STSFS,
   STSFI, STSFM, STSGL, STSHE, STSHM, STSHY, STSHB, STSIN, STSIP, STSIX,
   STSLA, STSLL, STSLI, STSMA, STSNF, STSNH, STSNJ, STSOP, STSPN,
   STSPL, STSPM, STSPI, STSPS, STSPU, STSRM, STSSS, STSSP, STSTC,
   STSUN, STSUL;
DECLARE FIXED ARRAY NATAB(LNCTAB) ← 'AD ', 'BG ', 'BR ', 'CL ', 'CE ',
   'DC ', 'DF ', 'DS ', 'EJ ', 'EG ', 'ER ', 'ES ', 'EM ', 'FS ',
   'FI ', 'FM ', 'GL ', 'HE ', 'HM ', 'HY ', 'HB ', 'IN ', 'IP ', 'IX ',
   'LA ', 'LL ', 'LI ', 'MA ', 'NF ', 'NH ', 'NJ ', 'OP ', 'PA ',
   'PL ', 'PM ', 'PI ', 'PS ', 'PU ', 'RM ', 'SS ', 'SP ', 'TC ',
   'UN ', 'UL ';
DECLARE FIXED ARRAY NCTAB(LNCTAB) ← CPAD, PRBG, CPBR, CPCL, CPCE,
   CPDC, CPDF, CPDS, CPEJ, PREG, CPER, CPES, CPEM, CPFS,
   CPFI, CPFM, CPGL, CPHE, CPHM, CPHY, CPHB, CPIN, CPIP, CPIX,
   CPLA, CPLL, PRLI, CPMA, CPNF, CPNH, CPNJ, CPOP, CPPN,
   CPPL, CPPM, CPPI, CPPS, CPPU, CPRM, CPSS, CPSP, CPTC,
   CPUN, CPUL;

* MACRO 'COMMAND' TABLES
DECLARE PARAMETER LMCTAB ← 1;
DECLARE FIXED ARRAY MSTAB(LMCTAB) ← STSEC;
DECLARE FIXED ARRAY MATAB(LMCTAB) ← 'EC ';
DECLARE FIXED ARRAY MCTAB(LMCTAB) ← CPEC;

* FORMAT 'COMMAND' TABLES
DECLARE PARAMETER LFCTAB ← 1;
DECLARE FIXED ARRAY FSTAB(LFCTAB) ← STSEF;
DECLARE FIXED ARRAY FATAB(LFCTAB) ← 'EF ';
DECLARE FIXED ARRAY FCTAB(LFCTAB) ← CPEF;


* STORAGE FOR COMMAND PROCESSORS
DECLARE CPL, CCPN, CPT, CFH, CPTI, CPTL;
DECLARE FIXED STRING $CMB(90), CPOPS;

DECLARE MACRO STERF()← ERFLG ← ERFLG + 1;

* FLAG ROUTINES
DECLARE *OFLAG, FIELD LTYPF(0:0,2), CTYPF(0:3,5),
       PARAMETER COMCD ← 7, SFLCD ← LTYPF(COMCD) OR CTYPF(1),
               RFLCD ← LTYPF(COMCD) OR CTYPF(0);
DECLARE MACRO SFLAG(FLG) ← OFLAG(SFLCD, @FLG, -1);
DECLARE MACRO RFLAG(FLG) ← OFLAG(RFLCD, @FLG, 0);

* SET CELL
DECLARE MACRO VSET(CSSB, CSPR) ← $CSSB ← CSPR;

* SET-UP SUBROUTINE CALL
DECLARE MACRO CSET(CSSB,CSPR) ← CSSB(CSPR);

DECLARE MACRO LTRP(X) ← (X) > '@' AND (X) <= 'Z';
DECLARE MACRO LBRK() ← (SYPPC(EOLCH) & PRISS());


* INITIALIZE COMMAND PROCESSOR
DECLARE MACRO MKTAB(X,Y) ← (X ← MAKE(Y))[0] ← 0;

FUNCTION $ICMP(), LINK XCCP; SMB();
       MKTAB(MNTAB, 10); MKTAB(GLTAB, 20); MKTAB(FMTAB, 5);
ICMP1: LCTAB ← LNCTAB; ATAB ← NATAB; STAB ← NSTAB; CTAB ← NCTAB; RETURN;

* FREE CPROC STORAGE FOR PASS II
FUNCTION $DCMP(); (FREE(MNTAB[CPL].LKPTR) & FREE(MNTAB[CPL]))
               FOR CPL ← MNTAB[0] BY -1 TO 1;
       FREE(MNTAB); FREE(SMBGC); FREE(SMBPC); RETURN;


* SKIP BLANKS IN COMMAND LINE
FUNCTION $SBLK(SBLKE); DECLARE SBLKC;
       SBLKC ← GCI(CMB: SBLKE); GOTO SBLK1 IF SBLKC = ' ';
       CMB.RPTR ← CMB.RPTR - 1; GOTO SBLKE;

SBLK1:  SBLKC ← GCI(CMB: SBLKE); GOTO SBLK1 IF SBLKC = ' ';
       CMB.RPTR ← CMB.RPTR - 1; RETURN SBLKC;


* READ NUMBER FROM COMMAND STRING
FUNCTION CPRN(); DECLARE CPRNV, CPRNS, CPRNC, CPRNT;
       CPRNV ← 0; CPRNS ← -1; CPRNT ← CMB.RPTR;

CPRN1: GOTO CPRN1 IF (CPRNC ← GCI(CMB: CPRN5)) <= ' ';
IF CPRNC = '-' DO; CPRNS ← CPRNS + 1; CPRNC ← GCI(CMB: CPRN5); ENDIF;

CPRN2: GOTO CPRN3 IF CPRNC > '9' OR CPRNC <= '0'-1;
       CPRNV ← CPRNV * 10 + CPRNC - '0';
       CPRNC ← GCI(CMB: CPRN4); GOTO CPRN2;

CPRN3: CMB.RPTR ← CMB.RPTR - 1; SBLK(CPRN4);
CPRN4: SRETURN CPRNV IF CPRNS < 0 ELSE SRETURN - CPRNV;
CPRN5: CMB.RPTR ← CPRNT; RETURN;


* COMPARE ARGUMENT TO COMMAND BUFFER
FUNCTION CPSE(CPSEST); DECLARE CPSESC, CPSERP, FIXED STRING CPSETS;
      BCOPY(CPSETS, CPSEST, 4); CPSERP ← CMB.RPTR;

CPSE1: CPSESC ← GCI(CPSETS: CPSE2);

IF CPSESC = ' ' DO; SBLK(CPSE5);
ELSE DO; GOTO CPSE5 IF GCMC(:CPSE5) # CPSESC;
ENDIF; GOTO CPSE1;

CPSE2: GOTO CPSE5 IF GCI(CMB: CPSE4) # ' '; SBLK(CPSE4);
CPSE4: SRETURN;
CPSE5: CMB.RPTR ← CPSERP; RETURN;

* GET CHARACTER FROM COMMAND STRING AND CONVERT TO
*  UPPER CASE
FUNCTION GCMC(); DECLARE GCMCH;

       GCMCH ← GCI(CMB: GCMC1);
       GCMCH ← GCMCH - CSHFT IF GCMCH > '←'; SRETURN GCMCH;

GCMC1: RETURN;


* LOOK UP COMMAND WORDS AND EVALUATE PROCESSOR
FUNCTION $CPLKP();
       CPL ← ((CMB.RPTR + 1)/3)[0];

IF (CPTL ← LENGTH(CMB)) = 2 OR CPTL > 2 AND CPL$CH3 = ' ' DO;

       CPTI ← CPL$CH1; CPTI ← CPTI - CSHFT IF CPTI > '←';
       CPTL ← CPL$CH2; CPTL ← CPTL - CSHFT IF CPTL > '←';
       CPL ← CH1(CPTI) OR CH2(CPTL);

       GOTO CPA1 IF ATAB[CPTI] = CPL FOR CPTI = LCTAB-1 BY -1 TO 0;
       STERF() IF STAB # MSTAB; RETURN;* ABBREVIATION SCAN FAILED

CPA1:  CMB.RPTR ← CMB.RPTR + 2; SBLK(CPA2);
CPA2:  $CTAB[CPTI](); RETURN;

* ELSE LOOK UP NORMALLY
ELSEIF LENGTH(CMB) > 2 DO;

   FOR CPTI ← LCTAB-1 BY -1 TO 0 DO;
       CMB.RPTR ← CMB.BPTR; CPSE($STAB[CPTI]: CPL3:);
       $CTAB[CPTI](); RETURN;
CPL3:  ENDFOR;

       STERF() IF STAB # MSTAB; RETURN;* NOT PROPER PHRASE

* FINISHED
ENDIF;

       STERF(); RETURN;

* COMMANDS IN PASS I AND II

FUNCTION CPBR(), LINK XCCP; LBRK(); RETURN;* BREAK

FUNCTION CPES(), LINK XCCP; PRES(GCI(CMB: CPES1)); RETURN;
CPES1: STERF(); RETURN;* ESCAPE X

FUNCTION CPSH(), LINK XCCP; PRSH(GCI(CMB: CPSH1)); RETURN;* SHIFT X
CPSH1: PRSH(-1); RETURN;

FUNCTION CPTC(), LINK XCCP; PRTC(GCI(CMB: CPTC1)); RETURN;* TAB CHAR X
CPTC1: PRTC(-1); RETURN;


FUNCTION CPIX(), LINK XCCP; WCI(EOLCH, CMB: CPIX2);
       CPCS(EOLCH, IXSCD: CPIX2);
CPIX2: RETURN;


* MACRO PROCESSOR
DECLARE *MNTAB, MNBUF, $MNWPTR, FIXED STRING $MNSTR, MNM(45);

FUNCTION CPDC(), LINK XCCP; CPMN();

       MNPTR ← INS(@MNTAB, MNM, DELMN)[0];
       MNPTR.LKPTR ← MNBUF ← MAKE(500);
       SETUP(MNSTR, 3*500, MNBUF); SETW(MNSTR, 1);

       CONEC(SYPPC, SYPPC); CONEC(SMBPC, CVCGC);
       CONEC(GCHPC, SMBGC);

       LCTAB ← LMCTAB; ATAB ← MATAB; STAB ← MSTAB; CTAB ←MCTAB;
       RETURN;

FUNCTION CPEC(), LINK XCCP;

       MNSTR.WPTR ← MNWPTR;* 'DELETE' END COMMAND
       MNBUF.CH1 ← (MNPTR ← LENGTH(MNSTR)) - 1;
       TRUNC(MNBUF, (MNPTR + 2)/ 3);

       CONEC(SYPPC, TOPGC); CONEC(GCHPC, CVCGC);
       GOTO ICMP1;

FUNCTION CPCL(), LINK XCCP; CPMN();

       MNPTR ← LKP(MNTAB, MNM: CPCL1)[0].LKPTR;
       MNSTR.WPTR ← MNSTR.EPTR ←
            (MNSTR.RPTR ← MNSTR.BPTR ← MNPTR * 3 ) + MNPTR.CH1;

       PRCL(); RETURN;

CPCL1: STERF(); RETURN;

* SUPPORTING SUBROUTINES FOR MACROS

FUNCTION CPMN(); SETS(MNM, 0, 0);

CPMN1: MNBUF ← GCMC(:CPMN2); GOTO CPMN2 IF MNBUF = ' ';
       WCI(MNBUF, MNM); GOTO CPMN1;

CPMN2: SBLK(CPMN3);
CPMN3: RETURN;

FUNCTION DELMN(MNPTR); RETURN FREE(MNPTR[0].LKPTR);

FUNCTION SMB(); DECLARE SMBGC, SMBPC, SMBCH;
       SMBPC ← CNCTR(SMB1); SMBGC ← CNCTR(FTLERR); RETURN;

SMB1:  SMBCH ← SMBGC(); SMBPC(WCI(SMBCH, MNSTR)); GOTO SMB1;


* TABLE FORMATTING COMMAND PROCESSOR
DECLARE FIXED ARRAY $CPDFF('Z' - 'A' + 1);
DECLARE *FMTAB, *DFMTP, *DFMTI, *DFMTS;

FUNCTION CPDF(), LINK XCCP; CPMN();

       MNPTR ← INS(@FMTAB, MNM, DELFM)[0];

* GET FORMAT POSITIONING
       CPL ← 2; CPOPS ← "CENTER"; CPSE(CPOPS: CPDF2); GOTO CPDF4;
CPDF2: CPOPS ← "LEFT"; CPSE(CPOPS: CPDF3); CPL ← 0; GOTO CPDF4;
CPDF3: CPOPS ← "RIGHT"; CPSE(CPOPS: CPDF4); CPL ← 1;

CPDF4: DFMTP[0] ← CH1(CPL); DFMTI ← 1; DFMTS ← 0;
       CPDFF[CPTI] ← -1 FOR CPTI ← 'Z'-'A' BY -1 TO 0;

* LOOP OVER FIELD POSITION DEFINITIONS
CPDF5: CFH ← GCMC(: CPDF8); CPTI ← (0 IF CFH = 'L' ELSE
               1 IF CFH = 'R' ELSE 2 IF CFH = 'C' ELSE
               3 IF CFH = 'F' ELSE 4 IF CFH = 'J' ELSE (STERF() & -1));
       STERF() IF GCMC(:CPDF7) # '(';

* LOOP OVER FIELDS
CPDF6: CFH ← GCMC(:CPDF7); (SBLK(CPDF5) & GOTO CPDF5) IF CFH = ')';
       CPDFF[CFH - 'A'] ← CH1(-1) OR CH3(CPTI) IF
               LTRP(CFH) AND CPDFF[CFH - 'A'] = -1 AND CPTI >= 0 ELSE
          STERF(); GOTO CPDF6;

CPDF7: STERF();
* SET UP TO PROCESS FORMAT DEFINTION
CPDF8: LCTAB ← LFCTAB; ATAB ← FATAB; STAB ← FSTAB; CTAB ← FCTAB;
       PRDF(); RETURN;

FUNCTION CPEF(), LINK XCCP; DFMTP.CH3 ← DFMTS;* SAVE FIELD COUNT
       MNPTR.LKPTR ← DFMTS ← MAKE(DFMTI); BCOPY(DFMTS, DFMTP, DFMTI);
       PRISS(); GOTO ICMP1;

FUNCTION CPFM(), LINK XCCP; CPMN(); LBRK();

       FMTP ← LKP(FMTAB, MNM: CPFM1)[0].LKPTR; PRFM(); RETURN;

CPFM1: STERF(); RETURN;

FUNCTION DELFM(MNPTR); CPTL ← MNPTR[0].LKPTR;
       FREE(CPTL[CPL]) FOR CPL ← CPTL.LENGF - 2 BY -1 TO 1;
       FREE(CPTL); RETURN;




* COMMANDS IN PASS III AND IV
* FLAG ROUTINES

FUNCTION CPAD(), LINK XCCP; LBRK(); SFLAG(JUSTF); RETURN;* ADJUST

FUNCTION CPNJ(), LINK XCCP; LBRK(); RFLAG(JUSTF); RETURN;* NOJUST

FUNCTION CPFI(), LINK XCCP; LBRK(); SFLAG(FILLF);
       PRFI(); FMTP ← -1; RETURN;* FILL

FUNCTION CPNF(), LINK XCCP; LBRK(); RFLAG(FILLF);
       PRNF(); FMTP ← -1; RETURN;* NOFILL

FUNCTION CPDS(), LINK XCCP; LBRK(); SFLAG(DSPF); RETURN;* DOUBLE SPACE

FUNCTION CPSS(), LINK XCCP; LBRK(); RFLAG(DSPF); RETURN;* SINGLE SPACE

FUNCTION CPHY(), LINK XCCP; SFLAG(HYPF); RETURN;* HYPHENATE

FUNCTION CPNH(), LINK XCCP; RFLAG(HYPF); RETURN;* NOHYPHEN

FUNCTION CPUL(), LINK XCCP; LBRK(); SFLAG(ULNF); RETURN;* UNDERLINE


* MODE ROUTINES

FUNCTION CPCE(), LINK XCCP; LBRK(); CSET(PRCE,0); RETURN;* CENTER

FUNCTION CPMA(), LINK XCCP; LBRK(); CSET(PRMA,0); RETURN;* MARGIN

FUNCTION CPOP(), LINK XCCP; LBRK(); CSET(PROP,0); RETURN;* ODD PAGE


* ROUTINES WITH OPTIONAL SINGLE PARAMETER
FUNCTION CPEJ(), LINK XCCP1;
       CPL ← PREJ; CCPN ← 0; GOTO CCP1;* EJECT (N/)
FUNCTION CPIN(), LINK XCCP1;
       CPL ← PRIN; CCPN ← 5; GOTO CCP1;* INDENT (N /)
FUNCTION CPPN(), LINK XCCP1;
       CPL ← PRPN; CCPN ← 0; GOTO CCP1;* PAGE NUMBER (N /)
FUNCTION CPIP(), LINK XCCP1;
       CPL ← PRIP; CCPN ← 1; GOTO CCP1;* INCREMENT PAGE(N /)
FUNCTION CPSP(), LINK XCCP1;
       CPL ← PRSP; CCPN ← 1; GOTO CCP1;* SPACE (N /)
FUNCTION CPUN(), LINK XCCP1;
       CPL ← PRUN; CCPN ← 5;* UNDENT (N /)

CCP1: LBRK(); CCPN ← CPRN(:CCP1A);
CCP1A: CSET(CPL,CCPN); RETURN FROM XCCP1;

* ROUTINES WITH REQUIRED SINGLE PARAMETER
FUNCTION CPFS(), LINK XCCP2; LBRK();
       CPL ← PRFS; GOTO CCP2;* FIGURE SPACING N
FUNCTION CPHB(), LINK XCCP2; CPL ← PRHB; GOTO CCP2;* HYPHENATION BREAK
FUNCTION CPPI(), LINK XCCP2; CPL ← PRPI; GOTO CCP2;* PARAGRAPH INDENTION N
FUNCTION CPPS(), LINK XCCP2; CPL ← PRPS; GOTO CCP2;* PARAGRAPH SPACING N
FUNCTION CPPU(), LINK XCCP2; CPL ← PRPU;* PARAGRAPH UNDENTION N

CCP2:  CCPN ← CPRN(:CCP2A); CSET(CPL,CCPN); RETURN FROM XCCP2;
CCP2A: STERF(); RETURN FROM XCCP2;

* LAYOUT ROUTINES
FUNCTION CPLA(), LINK XCCP3;
       CPT ← AMAR; CPTL ← OAMAR; GOTO CCP3;* LAYOUT L, R, T, B, W, O
FUNCTION CPLL(), LINK XCCP3;
       CPT ← LMAR; CPTL ← OLMAR; GOTO CCP3;* LINE LAYOUT L, R
FUNCTION CPPL(), LINK XCCP3;
       CPT ← PMAR; CPTL ← OPMAR; GOTO CCP3;* PAGE LAYOUT T, B, S
FUNCTION CPRM(), LINK XCCP3;
       CPT ← IMAR; CPTL ← ORMAR; GOTO CCP3;* REDUCE MARGIN DL, DR
FUNCTION CPEM(), LINK XCCP3;
       CPT ← UMAR; CPTL ← ORMAR;* EXPAND MARGIN DL, DR

CCP3:  LBRK(); $CPT[CPTI] ← $CPTL[CPTI] FOR CPTI ← 1 TO CPT.LENGF - 1;
FOR CPTI ← 1 TO CPT.LENGF - 1 DO; GOTO CCP3A IF SBLKC = ',';
       CCPN ← CPRN(:CCP3B); VSET(CPT[CPTI],CCPN);
       (GCI(CMB) & SBLK(CCP3A)) IF SBLKC = ',';
CCP3A: ENDFOR;
CCP3B: CSET($CPT[0],0); RETURN FROM XCCP3;

FUNCTION CPER(); LBRK(); CSET(PRER, 0); RETURN;* END REDUCTION

* COMMANDS TAKING STRINGS OR MODE WORDS

* HEADER XXXXXXXXXXXXXXXXXXXX
FUNCTION CPHE(); WCI(EOLCH, CMB: CPHE2);

CPHE1: CPCS(EOLCH, HESCD: CPHE2);
CPHE2: RETURN;


* HEADING MODE (CENTER / FACING / MARGIN / OPPOSED)
FUNCTION CPHM(), LINK XCCP;

CPHM1: CPOPS ← "CENTER"; CPSE(CPOPS: CPHM2);
       CSET(PRHM,1); GOTO CPHM1;

CPHM2: CPOPS ← "FACING"; CPSE(CPOPS: CPHM3);
       CSET(PRHM,2); GOTO CPHM1;

CPHM3: CPOPS ← "MARGIN"; CPSE(CPOPS: CPHM4);
       CSET(PRHM,3); GOTO CPHM1;

CPHM4: CPOPS ← "OPPOSED"; CPSE(CPOPS: CPHM5);
       CSET(PRHM,4); GOTO CPHM1;

CPHM5: RETURN;


* PAGING MODE ((BOTTOM / TOP /) (CENTER / FACING / MARGIN /)
*  (PREFIX "XXXXXXX" /)) / OFF)
FUNCTION CPPM(), LINK XCCP;

CPPMA: CPOPS ← "BOTTOM"; CPSE(CPOPS: CPPMB);
       RFLAG(TOPGF); GOTO CPPMA;

CPPMB: CPOPS ← "CENTER"; CPSE(CPOPS: CPPMC);
       CSET(PRPH,2);  GOTO CPPMA;

CPPMC: CPOPS ← "FACING"; CPSE(CPOPS: CPPMD);
       CSET(PRPH,3); GOTO CPPMA;

CPPMD: CPOPS ← "MARGIN"; CPSE(CPOPS: CPPME);
       CSET(PRPH,1); GOTO CPPMA;

CPPME: CPOPS ← "OFF"; CPSE(CPOPS: CPPMF);
       RFLAG(PAGF); GOTO CPPMA;

CPPMF: CPOPS ← "PREFIX"; CPSE(CPOPS: CPPMG);
       GOTO CPPMJ IF GCI(CMB: CPPMJ) # DQCH;
       CPCS(DQCH, PFSCD: CPPMJ); GOTO CPPMA;

CPPMG: CPOPS ← "SECTION"; CPSE(CPOPS: CPPMH);
       GOTO CPPMJ IF GCI(CMB: CPPMJ) # DQCH;
       CPCS(DQCH, SCSCD: CPPMJ); GOTO CPPMA;

CPPMH: CPOPS ← "SUFFIX"; CPSE(CPOPS: CPPMI);
       GOTO CPPMJ IF GCI(CMB: CPPMJ) # DQCH;
       CPCS(DQCH, SFSCD: CPPMJ); GOTO CPPMA;

CPPMI: CPOPS ← "TOP"; CPSE(CPOPS: CPPMJ);
       SFLAG(TOPGF); GOTO CPPMA;

CPPMJ: RETURN;


* GLOSSARY COMMAND
DECLARE *GLTAB, STRING *HYB, ARRAY *HYPT;

FUNCTION CPGL(), LINK XCCP; CFH ← GCMC(:CPGL6);

* INITIALIZE FOR NEXT WORD
CPGL1: SETS(HYB, 0, 0); CPL ← 0;

* COLLECT NEXT WORD
CPGL2: IF LTRP(CFH) DO; WCI(CFH, HYB);
ELSEIF CFH = '-' DO; HYPT[CPL] ← LENGTH(HYB); CPL ← CPL + 1;
       RETURN STERF() IF CPL > HYPT.LENGF;
ELSEIF CFH = ' ' DO; GOTO CPGL3;
ELSE DO; STERF(); RETURN;
ENDIF; CFH ← GCMC(:CPGL3); GOTO CPGL2;

CPGL3: INSGW(HYB, CPL);* INSERT WORD IN GLOSSARY

* LOOP TO NEXT WORD IF ANY
CPGL5: CFH ← GCMC(:CPGL6); GOTO CPGL5 IF CFH = ' '; GOTO CPGL1;
CPGL6: RETURN;

       END;

***************  NTP  ******************

**QSPL
       IDENT TPROC;

* GENERAL FIELD AND PARAMETER DEFINITIONS FOR RUNOFF

DECLARE FIELD BPTR(0), RPTR(1), WPTR(2), EPTR(3);
DECLARE FIELD CH1(0:0,7), CH2(0:8,15), CH3(0:16,23);
DECLARE FIELD BLKBIT(0:16,17), BLKCNT(0:18,23);

* CHARACTER VALUE DEFINITIONS
DECLARE PARAMETER MBCH ← 135B, PBSCH ← 150B, NPCH ← 154B,
       CRCH ← 155B, LFCH ← 152B, EOFCH ← 137B,
       AACH ← 141B, ALCH ← 143B, UACH ← 165B, SHCH ← 163B, PSCH ← 176B,
       CSHFT ← 40B, PSHFT ← 140B, CGTCH ← 136B, ULCH ← 100B, DQCH ← 2;

DECLARE PARAMETER BOPCH ← 201B, VSPCH ← 202B, CAPCH ← 203B,
       EODCH ← 204B, ERRCH ← 205B, ULWCH ← 206B, ULSCH ← 207B,
       BSPCH ← 210B, TABCH ← 211B, DSCH ← 212B, ESGCH ← 213B,
       EOPCH ← 214B, EOLCH ← 215B;

DECLARE PARAMETER BIO ← 576B, WIO ← 560B;

*
* PASS II - RECOGNIZE TEXT
*
* THIS PASS RECOGNIZES:
*      (1) LOGICAL LINES
*      (2) WORD AND SENTENCE BREAKS
*      (3) PARAGRAPH BREAKS
*      (4) COMMANDS
* IT ALSO IMPLEMENTS UNDERLINING
*

* DECLARATIONS FOR PASS II
DECLARE *SYPGC, *SYPPC, GAM2, ST, CAPFG, ULWFG, LINC,
       GAMC, CLCMGC, SYPMT, SYPST;
DECLARE *CNCTR, *CONEC, *MAX, *TRUNC, *CPLKP, *PRSP, *MATE, *ICNCT;* COMMAND INTERFACE
DECLARE *FILLF, *FMTP, *CMB, *MNWPTR;

DECLARE MACRO STERF()← ERFLG ← ERFLG + 1;

* CHARACTER CLASS TESTS
DECLARE MACRO CTRL(X) ← (X > 177B);
DECLARE MACRO WCTL(X) ← (X = ULSCH OR X = ULWCH OR X = CAPCH OR X = DSCH);

DECLARE MACRO LTRM(X) ← (X = EOLCH OR X = TABCH);
DECLARE MACRO TTRM(X) ← (X = ']' OR X = ')' OR X = ']'+CSHFT OR
       X = '&002' OR X = '&007');
DECLARE MACRO BTRM(X) ← (X = ',' OR X = '&033');
DECLARE MACRO STRM(X) ← (X = '.' OR X = ':' OR X = '?' OR X = '!');
DECLARE MACRO WTRM(X) ← (STRM(X) OR BTRM(X) OR LTRM(X) OR X = ' ');

DECLARE MACRO LTRP(X) ← (X > '@' AND X <= 'Z');
DECLARE MACRO LLTR(X) ← (X > '@'+CSHFT AND X <= 'Z'+CSHFT);

* FILE WORD BREAK
DECLARE MBRK, SBRK; DECLARE MACRO IBRK(X) ← MBRK ← SBRK ← X;
DECLARE MACRO WBRK(X) ← SYPPC(300B + X);

* DUMP BUFFER AND SET NEW LINE OR PARAGRAPH
DECLARE MACRO LBRK() ← SYPPC(EOLCH);
DECLARE MACRO PABRK() ← LBRK() & SYPPC(BOPCH);

* END OF FILE
FUNCTION EBRK(); LBRK(); SYPPC(EODCH); FTLERR();

* STATE MANIPULATION MACHINERY
DECLARE STI, FIXED ARRAY STS(8);

FUNCTION ENT(NST); STS[STI] ← ST; STI ← STI + 1; RETURN ST ← NST;
DECLARE MACRO CH(NST) ← ST ← (NST);

* INITIALIZE FOR COMMANDS
FUNCTION ICLN(); SETS(CMB, 0, 0); MNWPTR ← MNSTR.WPTR - 1;
       CH(C0); RETURN;

FUNCTION $PRLI(), LINK XPRST;* LITERAL PROCESSOR
       CH((F4 IF FILLF < 0 ELSE N3) IF FMTP < 0 ELSE T5); RETURN;

FUNCTION $PRISS(), LINK XPRST;
       CH((F0 IF FILLF < 0 ELSE N0) IF FMTP < 0 ELSE T0); RETURN;
FUNCTION $PRFI(), LINK XPRST; CH(F0); RETURN;* FILL
FUNCTION $PRNF(), LINK XPRST; CH(N0); RETURN;* NOFILL
FUNCTION $PRFM(), LINK XPRST; CH(T0); RETURN;* FORMAT
FUNCTION $PRDF(), LINK XPRST; CH(P0); RETURN;* DEFINE FORMAT

* FILL-MODE LINE PROCESSOR
FUNCTION $ISYP(); STI ← 0; ST ← F0; DFMTP ← MAKE(10);
       SYPGC ← CNCTR(FTLERR); SYPPC ← CNCTR(SCAN);
       CLCMGC ← CNCTR(FTLERR); RETURN;

FUNCTION $DSYP(); FREE(SYPPC); FREE(SYPGC); FREE(CLCMGC); RETURN;

RPT:   ST ← STS[STI ← STI - 1]; GOTO PP;
XIT:   ST ← STS[STI ← STI - 1];

SCAN:  GAM2 ← SYPGC();
PP: GOTO ST;

* F0 IS INITIAL STATE AFTER COMMANDS AND BREAKS
F0: IF GAM2 = EOLCH DO; LBRK(); GOTO SCAN;
ELSEIF GAM2 = ' ' DO; CH(F1); GOTO SCAN;
ELSEIF GAM2 = '.' DO; GOTO C0;
ELSEIF GAM2 = EODCH DO; EBRK();
ELSE DO; CH(F2); ENT(L0); GOTO PP;
ENDIF;

* BEGINNING OF PARAGRAPH
F1: IF GAM2 = EOLCH DO; LBRK(); CH(F0); GOTO SCAN;
ELSEIF GAM2 = ' ' DO; GOTO SCAN;
ELSE DO; PABRK(); CH(F2); ENT(L0); GOTO PP;
ENDIF;

* END OF LINE
F2:  IF GAM2 = EOLCH DO; CH(F3); GOTO SCAN;
ELSE DO; STERF(); ENT(L0); GOTO SCAN;
ENDIF;

* FIRST OF NEXT LINE
F3: IF GAM2 = EOLCH DO; LBRK(); CH(F0); GOTO SCAN;
ELSEIF GAM2 = ' ' DO; CH(F1); GOTO SCAN;
ELSEIF GAM2 = '.' DO; GOTO C0;
ELSEIF GAM2 = EODCH DO; EBRK();
ELSE DO; WBRK(SBRK); CH(F2); ENT(L0); GOTO PP;
ENDIF;

* NEXT TEXT LINE MAY BEGIN WITH DOT
F4: IF GAM2 = '.' DO; CH(F2); ENT(L0); GOTO PP;
ELSE DO; CH(F0); GOTO PP;
ENDIF;

* PROCESS COMMAND LINES
C0:    SETS(CMB, 0,0); MNWPTR ← MNSTR.WPTR - 1;
       SYPST ← ST; CH(C1); ENT(L0); 
       SYPMT ← MATE(SYPPC); CONEC(SYPPC, CLCMGC); ICNCT(SYPPC, SCAN);

* COROUTINE TO FILE CHARACTERS IN BUFFER
CLCM1: GAMC ← CLCMGC(); GOTO CLCM3 IF GAMC > BLKBIT(-1)-1;
       WCI(GAMC, CMB: CLCM2); GOTO CLCM1;
CLCM2: STERF(); GOTO CLCM1;

CLCM3: WCI(' ', CMB: CLCM2) FOR GAMC ← GAMC$BLKCNT - 1 BY -1 TO 0;
       GOTO CLCM1;

C1:    STERF() IF GAM2 # EOLCH; CONEC(SYPPC, SYPMT);
       CPLKP(); CH(SYPST) IF ST = C1; GOTO SCAN;


* NON-FILL PROCESSOR
N0: IF GAM2 = EOLCH DO; LBRK(); PRSP(1); GOTO SCAN;
ELSEIF GAM2 = ' ' DO; IBRK(1); CH(N1); GOTO SCAN;
ELSEIF GAM2 = '.' DO; GOTO C0;
ELSEIF GAM2 = EODCH DO; EBRK();
ELSE DO; CH(N2); ENT(L0); GOTO PP;
ENDIF;

N1: IF GAM2 = EOLCH DO; LBRK(); PRSP(1); CH(N0); GOTO SCAN;
ELSEIF GAM2 = ' ' DO; MBRK ← MBRK + 1; GOTO SCAN;
ELSE DO; WBRK(MBRK); CH(N2); ENT(L0); GOTO PP;
ENDIF;

N2: IF GAM2 = EOLCH DO; LBRK(); CH(N0); GOTO SCAN;
ELSE DO; STERF(); ENT(L0); GOTO SCAN;
ENDIF;

N3: IF GAM2 = '.' DO; CH(N2); ENT(L0); GOTO PP;
ELSE DO; CH(N0); GOTO PP;
ENDIF;

* TABLE PROCESSOR
T0:  IF GAM2 = EOLCH DO; LBRK(); GOTO SCAN;
ELSEIF GAM2 = '.' DO; GOTO C0;
ELSEIF GAM2 = EODCH DO; EBRK();
ELSEIF GAM2 = ' ' DO; CH(T1); GOTO SCAN;
ELSEIF GAM2 = TABCH DO; SYPPC(GAM2); CH(T3); GOTO SCAN;
ELSE DO; CH(T2); ENT(L0); GOTO PP;
ENDIF;

T1: IF GAM2 = EOLCH DO; LBRK(); CH(T0); GOTO SCAN;
ELSEIF GAM2 = TABCH DO; PABRK(); SYPPC(TABCH); CH(T3); GOTO SCAN;
ELSEIF GAM2 = ' ' DO; GOTO SCAN;
ELSE DO; PABRK(); CH(T2); ENT(L0); GOTO PP;
ENDIF;

T2: IF GAM2 = EOLCH DO; CH(T4); GOTO SCAN;
ELSEIF GAM2 = TABCH DO; SYPPC(GAM2); CH(T3); GOTO SCAN;
ELSE DO; STERF(); ENT(L0); GOTO SCAN;
ENDIF;

T3: IF GAM2 = EOLCH DO; CH(T0); GOTO SCAN;
ELSEIF GAM2 = TABCH DO; SYPPC(GAM2); GOTO SCAN;
ELSE DO; CH(T2); ENT(L0); GOTO PP;
ENDIF;

T4: IF GAM2 = EOLCH DO; LBRK(); CH(T0); GOTO SCAN;
ELSEIF GAM2 = '.' DO; GOTO C0;
ELSEIF GAM2 = EODCH DO; EBRK();
ELSEIF GAM2 = ' ' DO; CH(T1); GOTO SCAN;
ELSEIF GAM2 = TABCH DO; SYPPC(GAM2); CH(T3); GOTO SCAN;
ELSE DO; WBRK(SBRK); CH(T2); ENT(L0); GOTO PP;
ENDIF;

T5: IF GAM2 = '.' DO; CH(T2); ENT(L0); GOTO PP;
ELSE DO; CH(T0); GOTO PP;
ENDIF;

*
* STATES FOR WORD PROCESSING
*

* FORCE NEXT CHARACTER TO OPPOSITE STATE
SH:    (STERF() & GOTO SCAN) IF CTRL(GAM2) ELSE
       GAM2 ← GAM2 - CSHFT IF GAM2 > '←' ELSE
       GAM2 ← GAM2 + CSHFT IF GAM2 > '?';
       GOTO RPT;

* CAPITALIZE CHARACTER IF LOWER-CASE
CP: GAM2 ← GAM2 - CSHFT IF GAM2 > 100B AND GAM2 <= 137B; GOTO RPT;

* COLLECT CHARACTER POSITION
PS0: IF GAM2 = DSCH DO; CH(PS1); ENT(CP) IF CAPFG < 0; ENT(SH); GOTO SCAN;
ELSEIF CTRL(GAM2) DO; STERF(); GOTO SCAN;
ELSE DO; CH(PS1); ENT(CP) IF CAPFG < 0; GOTO PP;
ENDIF;

PS1: IF CTRL(GAM2) DO; STERF(); GOTO SCAN;
ELSE DO; SYPPC(GAM2); CH(PS2); GOTO SCAN;
ENDIF;

PS2: IF GAM2 = BSPCH DO; CH(PS3); GOTO SCAN;
ELSE DO; GOTO RPT;
ENDIF;

PS3: IF GAM2 = DSCH DO; CH(PS4); ENT(CP) IF CAPFG < 0; ENT(SH); GOTO SCAN;
ELSEIF CTRL(GAM2) DO; STERF(); GOTO SCAN;
ELSE DO; CH(PS4); ENT(CP) IF CAPFG < 0; GOTO PP;
ENDIF;

PS4: IF CTRL(GAM2) DO; STERF(); GOTO SCAN;
ELSE DO; SYPPC(BSPCH); SYPPC(GAM2); CH(PS2); GOTO SCAN;
ENDIF;

* UNDERLINE NEXT POSITION
UL: SYPPC(BSPCH); SYPPC(ULCH); GOTO RPT;

* WORD PROCESSOR
W0: ULWFG ← CAPFG ← 0; CH(W1);

W1: IF GAM2 = ULSCH DO; CH(W3); GOTO SCAN;
ELSEIF GAM2 = ULWCH DO; ULWFG ← -1; GOTO SCAN;
ELSEIF GAM2 = CAPCH DO; CAPFG ← -1; GOTO SCAN;
ELSEIF GAM2 = DSCH DO;
ELSEIF CTRL(GAM2) DO; STERF(); GOTO SCAN;
ENDIF;
       CH(W2); ENT(UL) IF ULWFG < 0; ENT(PS0); GOTO PP;

W2: IF WTRM(GAM2) DO; GOTO RPT;
ELSEIF GAM2 = ESGCH DO; ULWFG ← CAPFG ← 0; CH(W1); GOTO SCAN;
ELSE DO; CH(W1); GOTO PP;
ENDIF;

* ABNORMAL UNDERLINE
W3: (CAPFG ← -1 & GOTO SCAN) IF GAM2 = CAPCH;
       CH(W4); ENT(UL); ENT(PS0); GOTO PP;

W4:    CAPFG ← 0 IF WTRM(GAM2);
    IF LTRM(GAM2) DO; GOTO RPT;
ELSEIF GAM2 = ' ' DO; IBRK(1); CH(W5); GOTO SCAN;
ELSEIF GAM2 = ESGCH DO; CH(W2); GOTO PP;
ELSE DO; CH(W3); GOTO PP;
ENDIF;

W5: IF LTRM(GAM2) DO; GOTO RPT;
ELSEIF GAM2 = ' ' DO; MBRK ← MBRK + 1; GOTO SCAN;
ELSEIF GAM2 = ESGCH DO; WBRK(MBRK); CH(W2); GOTO PP;
ELSE DO; WBRK(MBRK); CH(W3); GOTO PP;
ENDIF;


* LINE PROCESSOR
L0: GOTO L0C IF WCTL(GAM2) ELSE GOTO L0D IF CTRL(GAM2) ELSE GOTO L0C;

L3C:   WBRK(1);
L0C:   CH(L1); ENT(W0); GOTO PP;

L0D:   STERF(); GOTO SCAN;


L1: GOTO L1A IF LTRM(GAM2) ELSE GOTO L1B IF GAM2 = ' ' ELSE
       GOTO L1C IF STRM(GAM2) ELSE GOTO L1D IF BTRM(GAM2) ELSE GOTO L0D;

L1A:   IBRK(1); GOTO RPT;
L1B:   IBRK(1); CH(L5); GOTO SCAN;
L1C:   IBRK(2); CH(L2); SYPPC(GAM2); GOTO SCAN;
L1D:   IBRK(1); CH(L4); SYPPC(GAM2); GOTO SCAN;

L2: GOTO L2A IF LTRM(GAM2) ELSE GOTO L2B IF GAM2 = ' ' ELSE
       GOTO L2C IF TTRM(GAM2) ELSE GOTO L0C IF WCTL(GAM2) ELSE
       GOTO L2E IF GAM2 = BSPCH ELSE GOTO L0D IF CTRL(GAM2) ELSE
       GOTO L1C IF STRM(GAM2) ELSE GOTO L1D IF BTRM(GAM2) ELSE
       GOTO L0C;

L2A:   GOTO RPT;
L2B:   CH(L3); GOTO SCAN;
L2C:   SYPPC(GAM2); GOTO SCAN;
L2E:   CH(L1); ENT(W2); ENT(PS3); GOTO SCAN;

L3: GOTO L1A IF LTRM(GAM2) ELSE GOTO L4A IF GAM2 = ' ' ELSE
       GOTO L3C IF WCTL(GAM2) ELSE GOTO L0D IF CTRL(GAM2) ELSE
       GOTO L3C;

L4: GOTO L2A IF LTRM(GAM2) ELSE GOTO L4A IF GAM2 = ' ' ELSE
       GOTO L4B IF WCTL(GAM2) ELSE GOTO L2E IF GAM2 = BSPCH ELSE
       GOTO L0D IF CTRL(GAM2) ELSE GOTO L2C IF TTRM(GAM2) ELSE
       GOTO L1D IF BTRM(GAM2) ELSE GOTO L1C IF STRM(GAM2) ELSE
       GOTO L4B;

L4A:   CH(L5); GOTO SCAN;
L4B:   WBRK(0); GOTO L0C;

L5: IF LTRM(GAM2) DO; GOTO RPT;
ELSEIF GAM2 = ' ' DO; MBRK ← MBRK + 1; GOTO SCAN;
ELSEIF WCTL(GAM2) DO; WBRK(MBRK); GOTO L0C;
ELSEIF CTRL(GAM2) DO; GOTO L0D;
ELSE DO; WBRK(MBRK); GOTO L0C;
ENDIF;

* FORMAT FIELD DEFINITION PROCESSOR
DECLARE *CPDFF, $DFMTP, $DFMTI, $DFMTS,
       DFMTL, DFMTF, DFMTJ, DFMTC, DFMTK, DFMTX, DFMTY;

* BEGINNING OF FORMAT LINE
P0:    DFMTJ ← DFMTL ← DFMTC ← 0; DFMTF ← MAKE(100);
       $DFMTX ← CH1(5) FOR DFMTX ← DFMTF + 99 BY -1 TO DFMTF;
       CH(P1); ENT(P2); ENT(P3); GOTO PP;

* BEGINNING OF NEXT FORMAT LINE
P1:    GOTO SCAN IF GAM2 = EOLCH;
IF GAM2 = '.' DO; GOTO C0;
ELSEIF DFMTI >= 10 DO; ENT(P9); GOTO SCAN;
ELSE DO; CH(P0); GOTO PP;
ENDIF;

* STORE FORMAT LINE
P2:    DFMTP[DFMTI] ← DFMTF; TRUNC(DFMTF, DFMTJ);
       DFMTI ← DFMTI + 1; (STERF() & FREE(DFMTF) & GOTO RPT) IF
               DFMTI >= 10;
       DFMTP.CH2 ← MAX(DFMTL, DFMTP.CH2); GOTO RPT;

* STORE FORMAT SEGMENT AND INCREMENT LINE LENGTH
FUNCTION SFFLD(SFFLDS, SFFLDC);
       IF DFMTJ >= 100 DO; CH(P9); STERF(); GOTO SCAN; ENDIF;
       DFMTF[DFMTJ] ← SFFLDS; DFMTJ ← DFMTJ + 1;
       DFMTL ← DFMTL + SFFLDC; CH(P3); RETURN;

* BEGGINNG OF FORMAT SEGMENT
P3: IF LTRP(GAM2) DO; DFMTK ← (DFMTX ← GAM2) - 'A';
       DFMTY ← DFMTX + CSHFT; DFMTC ← 0; CH(P8);
       (STERF() & CPDFF[DFMTK] ← 0 & DFMTS ← DFMTS + 1)
               IF CPDFF[DFMTK] = -1 ELSE
          (CPDFF[DFMTK]$CH1 ← 0 & DFMTS ← DFMTS + 1)
               IF CPDFF[DFMTK] < 0;
       GOTO PP;
ELSEIF LLTR(GAM2) DO; GAM2 ← GAM2 - CSHFT; GOTO PP;
ELSEIF GAM2 = DQCH DO; CH(P6); GOTO SCAN;
ELSEIF GAM2 = ' ' DO; DFMTC ← 0; CH(P4); GOTO PP;
ELSEIF GAM2 = EOLCH DO; GOTO XIT;
ELSEIF CTRL(GAM2) DO; STERF(); GOTO SCAN;
ELSE DO; CH(P5); DFMTC ← GAM2; GOTO SCAN;
ENDIF;

* BLANK SEGMENT
P4:    (DFMTC ← DFMTC + 1 & GOTO SCAN) IF GAM2 = ' ';
       SFFLD(CH1(5) OR CH2(DFMTC), DFMTC); GOTO PP;

* LITERAL SEGMENT
P5: IF LTRP(GAM2) OR LLTR(GAM2) OR GAM2 = ' ' OR GAM2 = EOLCH DO;
       SFFLD(CH1(6) OR CH3(DFMTC), 1); GOTO PP;
ELSEIF CTRL(GAM2) DO; STERF(); GOTO SCAN;
ELSEIF GAM2 = DQCH DO; CH(P7); GOTO SCAN;
ELSE DO; SFFLD(CH1(7) OR CH2(DFMTC) OR CH3(GAM2), 2); GOTO SCAN;
ENDIF;

* STRING SEGMENT
P6: IF CTRL(GAM2) DO; STERF(); GOTO SCAN;
ELSEIF GAM2 = DQCH DO; CH(P3); GOTO SCAN;
ELSE DO; DFMTC ← GAM2; CH(P7); GOTO SCAN;
ENDIF;

P7: IF CTRL(GAM2) DO; STERF(); GOTO SCAN;
ELSEIF GAM2 = DQCH DO; SFFLD(CH1(6) OR CH3(DFMTC), 1); GOTO SCAN;
ELSE DO; SFFLD(CH1(7) OR CH2(DFMTC) OR CH3(GAM2), 2); CH(P6); GOTO SCAN;
ENDIF;

* TEXT SEGMENT
P8:    (DFMTC ← DFMTC + 1 & GOTO SCAN) IF GAM2 = DFMTX OR GAM2 = DFMTY;
       SFFLD(CH1(CPDFF[DFMTK]$CH3) OR CH2(DFMTC) OR CH3(DFMTK), DFMTC);
       GOTO PP;

* SKIP REST OF FMT LINE
P9:    GOTO SCAN IF GAM2 # EOLCH ELSE GOTO XIT;

*
* PASS I - CONVERT FROM EXTERNAL FORMAT TO INTERNAL CHARACTER SET
*
* CVC:
*      (1) HANDLES CASE SHIFTS
*      (2) DELETES UNUSED CONTROL CHARACTERS
*      (3) CONVERTS SPACE/BACKSPACE SEQUENCES TO CANONICAL FORM
*

DECLARE GAM1, LCCFG, LCLFG, SHFG, PSFG, MBC, MCHAR, SCHAR, TCHAR,
       CVCGL, *CVCGC, *CVCPC, *MNSTR, *DIF, *ERFLG;

DECLARE FIXED STRING DTST; DECLARE PARAMETER RTOD ← 39;
DECLARE FIXED STRING ARRAY MTHST(12) ← "*ANUARY", "&&EBRUARY",
       "-ARCH", "!PRIL", "-AY", "*UNE", "*ULY", "!UGUST",
       "3EPTEMBER", "/CTOBER", ".OVEMBER", "$ECEMBER";

* GET CHARACTERS FROM MACRO BODY
FUNCTION GMC(); RETURN GCI(MNSTR: GMC1);
GMC1:  CVCGL ← CVCGC; RETURN CVCGC();

* ESCAPE AND SHIFT PROCESSORS
FUNCTION $PRES(MCHAR), LINK XPRCH; RETURN;

FUNCTION $PRSH(SCHAR), LINK XPRCH; RETURN;

FUNCTION $PRTC(TCHAR), LINK XPRCH; RETURN;


FUNCTION $PRCL(); CVCGL ← GMC; RETURN;


FUNCTION $ICVP();* INITIALIZE CVC
       PSFG ← SHFG ← LCCFG ← 0; LCLFG ← -1;
       MCHAR ← '↑'; SCHAR ← '/'; TCHAR ← '\';
       CVCGL ← CVCGC ← CNCTR(FTLERR); CVCPC ← CNCTR(CVC1);
       LINC ← 1; ERFLG ← -1; RETURN;

FUNCTION $DCVP(); FREE(CVCGC); FREE(CVCPC); RETURN;

CVC1: GAM1 ← CVCGL();* READ CHARACTER AND TEST
   IF GAM1 = MCHAR DO; GAM1 ← CVCGL();* PROCESS META CHARACTER SEQUENCE

       IF GAM1 = MCHAR OR GAM1 = SCHAR OR GAM1 = TCHAR DO;
               GOTO CVC3;* SAVE LITERAL META CHAR

       ELSEIF GAM1 = 'A' DO; SHFG ← 0;
               LCLFG ← LCCFG ← -1;* SHIFT ALL UPPER CASE CHARACTERS

       ELSEIF GAM1 = 'L' DO; SHFG ← LCCFG ← 0;
               LCLFG ← -1;* SHIFT UPPER CASE LETTERS ONLY

       ELSEIF GAM1 = 'U' DO; LCCFG ← LCLFG ← 0;* NO SHIFTING DESIRED
       ELSEIF GAM1 = 'S' DO; SHFG ← -1;* NO SHIFTING FOR 'NEXT' CHARACTER

       ELSEIF GAM1 = 'Y' DO; BRS(RTOD:: MBC);* OUTPUT DATE STRING
          BCOPY(DTST, MTHST[MBC$CH2 - 1], 4);
          CVCPC(GAM1 + CSHFT) FOR GAM1 ← GCI(DTST: CVC2) WHILE 1;
CVC2:     CVCPC(' '); CVCPC(GAM1 / 10 OR 20B) IF (GAM1 ← MBC$CH3) > 9;
               CVCPC(GAM1 MOD 10 OR 20B);
          CVCPC(','); CVCPC(' '); CVCPC('1'); CVCPC('9');
          CVCPC((GAM1 ← MBC$CH1)/ 10 OR 20B); CVCPC(GAM1 MOD 10 OR 20B);

       ELSE DO;
          CVCPC(ULWCH IF GAM1 = 'I' ELSE ULSCH IF GAM1 = '-'
               ELSE TABCH IF GAM1 = 'T' ELSE ESGCH IF GAM1 = 'E'
               ELSE BSPCH IF GAM1 = 'B' ELSE DSCH IF GAM1 = 'D'
               ELSE CAPCH IF GAM1 = 'C' ELSE ERRCH);* SAVE FORMATTING CHARACTERS
       ENDIF;
       GOTO CVC1;

ELSEIF GAM1 = SCHAR DO; SHFG ← -1; GOTO CVC1;

ELSEIF GAM1 = TCHAR DO; CVCPC(TABCH); GOTO CVC1;
ENDIF;

CVC3: IF GAM1 <= '?' DO;* NON-SHIFTING/360 CHARACTER
       (GAM1 ← GAM1 + PSHFT & PSFG ← 0) IF PSFG < 0;

ELSEIF GAM1 > '@' AND GAM1 <= 'Z' DO;* SHIFT LETTERS IF CALLED FOR
       (SHFG ← 0 IF SHFG < 0 ELSE GAM1 ← GAM1 + CSHFT) IF LCLFG < 0;

ELSEIF GAM1 = MBCH DO;* EXPAND MULTIPLE BLANKS
       CVCPC(' ') FOR GAM1 ← CVCGL() - 1 BY -1 TO 0; GOTO CVC1;

ELSEIF GAM1 > 177B DO; CVCPC(GAM1 - CSHFT); GOTO CVC1;* 360 CHARACTER
ELSEIF GAM1 > CGTCH DO;* PROCESS CONTROL CHARACTERS

    IF GAM1 = AACH DO; SHFG ← 0; LCLFG ← LCCFG ← -1;* SHIFT ALL
    ELSEIF GAM1 = ALCH DO; SHFG ← LCCFG ← 0; LCLFG ← -1;* SHIFT LETTERS
    ELSEIF GAM1 = UACH DO; LCCFG ← LCLFG ← 0;* NO SHIFTING
    ELSEIF GAM1 = SHCH DO; SHFG ← -1;* SINGLE NO-SHIFT
    ELSEIF GAM1 = PSCH DO; PSFG ← -1;* SHIFT TO 360

    ELSEIF GAM1 = EOFCH DO;
       CVCPC(EOLCH); CVCPC(EODCH); FTLERR();* END-OF-FILE
    ELSEIF GAM1 = LFCH DO;* LINE FEED
       IF ERFLG >= 0 DO; CRLF(1);
          SOUT("ERROR IN LINE "); IOUT(LINC); ENDIF;
       LINC ← LINC + 1 IF CVCGL # GMC; ERFLG ← -1;
    ELSEIF GAM1 = CRCH DO; CVCPC(EOLCH);* CARRIAGE RETURN
    ELSEIF GAM1 = PBSCH DO; CVCPC(BSPCH);* BACKSPACE
    ELSEIF GAM1 # NPCH DO; STERF();
    ENDIF;
       GOTO CVC1;

ELSEIF GAM1 <= '←' DO;* SHIFT NON-ALPHABETIC UPPER-CASE IF CALLED FOR
       (SHFG ← 0 IF SHFG < 0 ELSE GAM1 ← GAM1 + CSHFT) IF LCCFG < 0;

ENDIF;
       CVCPC(GAM1); GOTO CVC1;* SAVE CHAR

*
* PASS 0 - BUFFER THE INPUT FILE
*

DECLARE GCHW, GCHE, GCHF, GCHP, GCHL, *GCHPC;

FUNCTION $IGCH(); GCHPC ← CNCTR(GCH1);
       GCHF ← MAKE(256); GCHL ← GCHF + 255; GCHE ← 0; RETURN;

FUNCTION $DGCH(); FREE(GCHPC); FREE(GCHF); RETURN;

GCH1:  POP(BIO, DIF, GCHL - GCHF + 1,, GCHF: GCH3:);

GCH2:  FOR GCHP ← GCHF TO GCHL DO;

       GCHW ← $GCHP; GCHPC(GCHW$CH1); GCHPC(GCHW$CH2); GCHPC(GCHW$CH3);

ENDFOR;
       GOTO GCH1 IF GCHE >= 0; GCHPC(EOFCH); FTLERR();

GCH3:  SAVE(GCHL); GCHL ← GCHL + 1; GCHE ← -1; GOTO GCH2;

       END;

* CANONICAL BUFFERING SUBROUTINES
DECLARE CCHP, MCHP, FCHP, FIELD CVCBL(0: 10, 23);
DECLARE FIXED ARRAY CVCB[400];

FUNCTION BSCH(GAM1); CCHP ← CCHP + 1;* BUFFER SPACING CHARACTER

IF CCHP > MCHP DO; HALT() IF MCHP = FCHP;
       CVCB[CCHP] ← CH1(GAM1); MCHP ← MCHP + 1;

ELSEIF CVCB[CCHP] = 0 DO; CVCB[CCHP] ← CH1(GAM1);

ELSE DO; CVCB[FCHP] ← CVCB[CCHP]; CVCB[CCHP] ← CH1(GAM1) OR CVCBL(FCHP);
       FCHP ← FCHP - 1; HALT() IF FCHP = MCHP;

ENDIF;
       RETURN;

FUNCTION BCCH(GAM1);* BUFFER CONTROL CHARACTER
       BSCH(GAM1); CCHP ← CCHP - 1; RETURN;

FUNCTION BMSP(GAM1); CCHP ← CCHP + GAM1;* BUFFER MUTIPLE SPACES

IF CCHP > MCHP DO;

       CVCB[MCHP] ← 0 FOR MCHP ← MCHP + 1 TO CCHP;
       MCHP ← CCHP; HALT() IF MCHP >= FCHP;

ENDIF;
       RETURN;

FUNCTION DCB(); DECLARE DCBT;* DUMP BUFFER

FOR CCHP ← 0 TO MCHP DO; DCBT ← CVCB[CCHP];

    IF DCBT$CVCBL = 0 DO; CVCPC(GAM1 ← DCBT$CH1);
       CVCPC(' ') IF GAM1 > 140B-1;

    ELSE DO;
DCB1:  GAM1 ← DCBT$CH1;

       IF GAM1 > 140B-1 DO; CVCPC(GAM1);
           IF (DCBT ← DCBT$CVCBL) = 0 DO;
               CVCPC(' '); GOTO DCB4;
           ELSE DO; CVCB[CCHP] ← DCBT ← CVCB[DCBT]; GOTO DCB1;

           ENDIF;
       ENDIF;

       FCHP ← CCHP;

DCB2:  GOTO DCB3 IF (DCBT ← CVCB[FCHP]$CVCBL) = 0;

       DCBT ← CVCB[DCBT]; GAM1 ← DCBT$CH1;

       IF GAM1 > 140B-1 DO; CVCPC(GAM1);
           CVCB[FCHP]$CVCBL ← DCBT ← DCBT$CVCBL;
           GOTO DCB3 IF DCBT = 0 ELSE GOTO DCB2;

       ELSE DO; FCHP ← CVCB[FCHP]$CVCBL; GOTO DCB2;

       ENDIF;

DCB3:  CVCPC(CVCB[FCHP ← CCHP]$CH1);

       (CVCPC(BSPCH) & CVCPC(CVCB[FCHP]$CH1))
               FOR FCHP ← CVCB[FCHP]$CVCBL WHILE FCHP > 0;

    ENDIF;
DCB4: ENDFOR;

       CCHP ← MCHP ← -1; FCHP ← 400-1; RETURN;

       END;

********************  NFP  ************************

**QSPL
       IDENT FPROC;


* GENERAL FIELD AND PARAMETER DEFINITIONS FOR RUNOFF

* FIELDS FOR STRING DESCRIPTORS
DECLARE FIELD $BPTR(0), $RPTR(1), $WPTR(2), $EPTR(3);
DECLARE FIELD CH1(0:0,7),CH2(0:8,15),CH3(0:16,23);
DECLARE FIELD BLKBIT(0:16,17), BLKCNT(0:18,23);
DECLARE FIELD LENGF(-1: 10, 23), LKPNC(0: 0, 9), LKPTR(0: 10,23);

DECLARE MACRO MAKARY(X) ← MAKE(X) OR 2B7;

* CHARACTER VALUE DEFINITIONS
DECLARE PARAMETER CRCH ← 155B, LFCH ← 152B, EJCH ← 154B,
       ULCH ← 100B, NULCH ← 140B, CSHFT ← 40B, CGTCH ← 137B;

DECLARE PARAMETER VSPCH ← 202B, EOCCH ← 203B, EODCH ← 204B,
       BSPCH ← 210B, TABCH ← 211B, COMCH ← 213B,
       EOPCH ← 214B, EOLCH ← 215B, BFNCH ← 216B, EFNCH ← 217B;

* EXTERNALS
DECLARE *FILLF, *FMTP, *ULNF, *JUSTF, *DSPF, *HYPF, *PAGF, *TOPGF,
       *DIF, *DOF, *IHYFLG, *ERFLG, *GLPRF, *GLTAB, *HYB, *HYPT,
       *RINAD, *SINAD;
DECLARE *TRUNC, *TRUNCZ, *CNCTR, *CONEC, *ICNCT, *INS, *LKP,
       *MAX, *MIN, *INSGW;

DECLARE FIXED STRING STLFP(300), STRPTL, STCPY, IPPFS ← "P&101&107&105  ",
       PAGST(5), PPFST(48), PSCST(30), PSFST(30), HEDST(132);
DECLARE PAGARY, PFPGC, GNLC, CFMCH, PMODE, HMODE, PAGNO, NHDCH, NPFCH, NSCCH,
       NSFCH, LHDPOS, RHDPOS, LPGPOS, RPGPOS;
DECLARE LMODE, OPGBL, EPGBL, TPBL, PLENG, CSLOP,
       CSPC, LWIDTH, NCOL, RLMAR, LLMAR;
DECLARE CHRCNT, CHRMAX, FRTBL, PGBL, CLJCH, NLJCH, OLJCH,
       LJSTBL, LJSTPT, LNPTY;
DECLARE LFCNT, LINCNT, LINMAX, COLMAX, TSPC, GSPC,
       PBB, PBI, PBJ, PBK, PBM, ARRAY PBF, PCB;
DECLARE HYCNT, HYMCT, HYPTR, HYIND, HYPFCT, HYFLG, HYBWP, HYBPT, WHPS,
       IHYCH, IHYCNT, IHYRB, IHYWB, IHYBRP;
DECLARE FLCNT, FLPCT, FMTF, FTXT, FTXTP, FMTSP, FMTCC, FMTI, FOPL,
       FMTC1, FMTC2, FMTC3, FOPPT, FIXED STRING FTXTS;
DECLARE IXTAB, SCTAB, INXCH, IXTBP, IXPTR, IXLPTR, IXPPTR, IXLLEN,
       IXI, IXB, ARRAY IXF, FIXED STRING INXST(48);

DECLARE MACRO STERF()← ERFLG ← ERFLG + 1;

DECLARE MACRO LTRP(X) ← (X) > '@' AND (X) <= 'Z';
DECLARE MACRO DGTP(X) ← (X) > '/' AND (X) <= '9';

* CONTROL FUNCTIONS FOR LINE FORMATTING
FUNCTION CPBL();
       PGBL ← (EPGBL IF (HMODE = 2 OR PMODE = 3)
                   AND PAGNO MOD 2 = 0 ELSE OPGBL);
       COLMAX ← (LINMAX - LINCNT)* NCOL; RETURN;

* INPUT/OUTPUT FUNCTIONS FOR PASS III

FUNCTION GNCS(); RETURN GCI(STRPTL:GNCS1);

GNCS1: GNLC ← PFPGC; RETURN PFPGC();


DECLARE FIELD FPCHB(0: 0, 0), FPCHE(0: 1, 1), FPCHG(0: 2,2),
       FPCHL(0: 3, 8), FPCHP(0: 10, 23);
DECLARE PCHN, PCHW, PCHF, PCHP, PCHL, PCHB, PCHG, PCHCC;

FUNCTION LFILL(); PCHR(EOLCH);* CHECK FOR EMPTY BUFFER!

IF PCHN = 1 DO;
       PCHW ← PCHW LSH 16 OR (CH2(NULCH) OR CH3(NULCH)); GOTO LFILL1;

ELSEIF PCHN = 0 DO;
       PCHW ← PCHW LSH 8 OR CH3(NULCH); GOTO LFILL1;

ELSE DO; GOTO LFILL2;
ENDIF;

LFILL1: FTLERR() IF (PCHP ← PCHP + 1) > PCHL; $PCHP ← PCHW;

LFILL2: PCHL ← PCHP - PCHF; TRUNCZ(PCHF, PCHL + 1, PAGARY); RETURN;

FUNCTION PFILL(), LINK LPINIT;
       LFILL(); $PCHF ← CH1(PCHL) OR CH3(PCHCC);

IF PBI >= PBF.LENGF - 2 - LFCNT DO; PCHP ← MAKARY((PBF.LENGF * 3)/ 2);
       BCOPY(PCHP, PBF, PBI); FREE(PBF); PBF ← PCHP; ENDIF;

       PCHB ← (FPCHB(-1) IF PCHB < 0 ELSE 0) OR
               (FPCHG(-1) IF GSPC >= 0 OR PCHG < 0 ELSE 0);

       (PBF[PBI] ← PCHB & PBI ← PBI + 1)
               FOR LFCNT ← LFCNT - 1 BY -1 TO 0;

       PBF[PBI] ← PCHB OR (0 IF ERFLG < 0 ELSE FPCHE(-1))
               OR FPCHP(PCHF); PBI ← PBI + 1;
       GSPC ← -1 IF (GSPC ← GSPC - 1) < 0; LFCNT ← PCHB ← 0;
       LNPTY ← (0 IF LNPTY < 0 ELSE -1); GOTO PINIT1;

FUNCTION PINIT(), LINK LPINIT;

PINIT1: PCHP ← PCHF ← MAKE(133, PAGARY); PCHL ← PCHF + 132;
       PCHW ← ''; PCHN ← 2; ERFLG ← -1; RETURN;


FUNCTION PLF(PCHC), LINK LPCH;

       LFCNT ← LFCNT + PCHC;
       (GSPC ← -1 & PCHB ← -1 IF PCHG >= 0) IF (GSPC ← GSPC - PCHC) < 0;
       RETURN;

FUNCTION PCHR(PCHC), LINK LPCH;

       PCHW ← PCHW LSH 8 OR PCHC; RETURN IF (PCHN ← PCHN - 1) >= 0;

       FTLERR() IF (PCHP ← PCHP + 1) > PCHL;
       $PCHP ← PCHW; PCHW ← 0; PCHN ← 2; RETURN;

FUNCTION PSTR(PSTRST); DECLARE FIXED STRING PSTRTS;
       BCOPY(PSTRTS, PSTRST, 4);
PSTR1: PCHR(GCI(PSTRTS: PSTR2)); GOTO PSTR1;
PSTR2: RETURN;

* CONVERT LINE TO NO-BACKSPACE FORM AND OUTPUT IT
FUNCTION LDMP(LDMPP); DECLARE CLDCH, NLDCH, LDMPSP, LDMPI,
       FIXED STRING STLD1, STLD2;

       COUT(LFCH, DOF) FOR LDMPI ← LDMPP$FPCHL - 1 BY -1 TO 0;
       (COUT('*', DOF) & COUT(CRCH, DOF)) IF LDMPP$FPCHE # 0;

       LDMPP ← LDMPP$FPCHP; SETUP(STLD1, LDMPI ← 3*LDMPP[0], LDMPP + 1);
       BCOPY(STLD2, STLD1, 4); SETW(STLD1, LDMPI);

LDMP1: LDMPSP ← 0; COUT(' ', DOF) FOR LDMPI ← PGBL - 1 BY -1 TO 0;

       NLDCH ← GCI(STLD1);
LDMP2: CLDCH ← NLDCH; GOTO LDMP7 IF CLDCH = EOLCH; NLDCH ← GCI(STLD1);
LDMP3: GOTO LDMP2 IF CLDCH = NULCH; GOTO LDMP5 IF CLDCH = BSPCH;
       GOTO LDMP4 IF CLDCH > BLKBIT(-1)-1; LDMPSP ← LDMPSP + 1;
       COUT(CLDCH + CSHFT IF CLDCH > CGTCH ELSE CLDCH, DOF);
       GOTO LDMP2;

LDMP4: LDMPI ← CLDCH$BLKCNT;
IF NLDCH = BSPCH DO; WCI(BLKBIT(-1) OR LDMPSP, STLD2) IF
               (LDMPSP ← LDMPSP - 1) > 0;
       LDMPSP ← LDMPI; NLDCH ← GCI(STLD1);
       COUT(NLDCH, DOF) FOR LDMPI ← LDMPI - 1 BY -1 TO 0;
       NLDCH ← GCI(STLD1); GOTO LDMP2 IF NLDCH # BSPCH; FTLERR();
ELSE DO; LDMPSP ← LDMPSP + LDMPI;
       COUT(' ', DOF) FOR LDMPI ← LDMPI - 1 BY -1 TO 0; GOTO LDMP2;
ENDIF;

LDMP5: (FTLERR() IF LDMPSP > (77B+77B) ELSE
           (WCI(BLKBIT(-1) OR 77B, STLD2) &
               WCI(BLKBIT(-1) OR LDMPSP - 77B, STLD2)) IF
                   LDMPSP > 77B ELSE
           WCI(BLKBIT(-1) OR LDMPSP, STLD2)) IF
               (LDMPSP ← LDMPSP - 1) > 0; LDMPSP ← 0;

LDMP6: WCI(NLDCH, STLD2); NLDCH ← GCI(STLD1);
       GOTO LDMP2 IF NLDCH # BSPCH; WCI(NLDCH, STLD2);
       NLDCH ← GCI(STLD1); GOTO LDMP6;

LDMP7: COUT(CRCH, DOF);
IF STLD2.WPTR # STLD2.BPTR DO; WCI(EOLCH, STLD2);
       BCOPY(STLD1, STLD2, 4); SETS(STLD2, 0, 0); GOTO LDMP1;
ENDIF;
       COUT(LFCH, DOF); FREE(LDMPP, PAGARY); RETURN;

* DUMP HEADER LINE
FUNCTION HFILL(); LFILL(); $PCHF ← PCHL;
       PBF[0] ← (0 IF ERFLG < 0 ELSE FPCHE(1)) OR FPCHL(LFCNT)
               OR FPCHP(PCHF); PBB ← PBI ← 1; LINCNT ← LFCNT + 1;
       PINIT(); RETURN;

* COMPUTE HEADING AND PAGING POSITION
FUNCTION CPHP();
       LHDPOS ← (((LWIDTH - NHDCH)/ 2 IF HMODE = 1 ELSE
           LWIDTH - NHDCH IF HMODE = 3 OR
               (HMODE = 2 OR HMODE = 4 AND PMODE = 3)
                   AND PAGNO MOD 2 = 0 ELSE 0) IF NHDCH > 0 ELSE -1);
       RHDPOS ← LHDPOS + NHDCH - 1;

       CNS(PAGNO, PAGST); RPGPOS ← LENGTH(PAGST) + NPFCH + NSCCH + NSFCH - 1;
       LPGPOS ← ((LWIDTH - RPGPOS)/ 2 IF PMODE = 2 ELSE
           LWIDTH - RPGPOS IF PMODE = 1 OR
               PMODE = 3 AND PAGNO MOD 2 = 1 ELSE 0);
       RPGPOS ← RPGPOS + LPGPOS; RETURN;

* OUTPUT HEADING STRING
FUNCTION HOUT(); SETR(HEDST, 0);
IF LHDPOS < CHRCNT DO; STERF();* DELETE FIRST PART OF HEADER
HOUT1: CLDCH ← GCI(HEDST: HOUT5);
       (GCI(HEDST) & GOTO HOUT1) IF CLDCH = BSPCH;
       LHDPOS ← LHDPOS + 1; GOTO HOUT1 IF LHDPOS < CHRCNT;
ELSE DO;
       PCHR(BLKBIT(-1) OR LHDPOS - CHRCNT); CHRCNT ← LHDPOS;
ENDIF;

HOUT2: CLDCH ← GCI(HEDST: HOUT5); GOTO HOUT4 IF CLDCH = BSPCH;
HOUT3: CHRCNT ← CHRCNT + 1; (STERF() & GOTO HOUT5)
               IF CHRCNT >= LPGPOS AND LHDPOS < RPGPOS AND LPGPOS >= 0;
       PCHR(CLDCH); GOTO HOUT2;

HOUT4: PCHR(CLDCH); PCHR(GCI(HEDST)); CLDCH ← GCI(HEDST: HOUT5);
       GOTO HOUT3 IF CLDCH # BSPCH ELSE GOTO HOUT4;

HOUT5: RETURN;

* OUTPUT PAGE STRING
FUNCTION POUT(); PCHR(BLKBIT(-1) OR LPGPOS - CHRCNT); CHRCNT ← RPGPOS;
       PSTR(PPFST); PSTR(PSCST); PSTR(PAGST); PSTR(PSFST); RETURN;

* OUTPUT TITLE AND INITIALIZE NEW PAGE
FUNCTION NEWPG();

       LFCNT ← TPBL; PBB ← PBI ← LINCNT ← 0; GSPC ← -1;
       LINMAX ← (-2 IF TOPGF >= 0 AND PAGF < 0 ELSE 0) + PLENG;
       CPBL(); PBF ← MAKARY((COLMAX * 3)/ 2);

       CPHP(); LPGPOS ← RPGPOS ← -1 IF PAGF >= 0 OR TOPGF >= 0;
IF LHDPOS >= 0 OR LPGPOS >= 0 DO; CHRCNT ← 0;
       HOUT() IF LHDPOS >= 0 AND LHDPOS <= LPGPOS; POUT() IF LPGPOS >= 0;
       HOUT() IF LHDPOS >= 0 AND LHDPOS > LPGPOS; HFILL(); LFCNT ← 2;
ENDIF;

       CPBL(); RETURN;

* FUNCTIONS FOR LINE FORMATTING
FUNCTION ICCNT(ICCH); RETURN IF ICCH = EOLCH
  ELSE (CHRCNT ← CHRCNT + ICCH$BLKCNT & LJSTPT ← LJSTPT + 1 &
               RETURN IF CHRCNT > CHRMAX) IF ICCH > BLKBIT(-1)-1
  ELSE CHRCNT ← CHRCNT - 1 IF ICCH = BSPCH
  ELSE CHRCNT ← CHRCNT + 1; SRETURN;

* FIND LINE BREAK POINT, HYPHENATE, AND SET UP FOR JUSTIFICATION
FUNCTION BKPT();

       STRPTL.WPTR ← STRPTL.EPTR ← STLFP.WPTR;
       HYB.RPTR ← HYB.WPTR ← HYB.EPTR; HYFLG ← HYPF;
       IHYCNT ← HYCNT ← HYPFCT ← 0; HYPTR ← -1;

       WHPS ← WHP2; NLJCH ← GCD(STLFP); HYMCT ← CHRCNT;
       NLJCH ← GCD(STLFP) IF NLJCH = EOLCH;
       GOTO WHP1 IF NLJCH <= BLKBIT(-1)-1;

       CHRCNT ← CHRCNT - NLJCH$BLKCNT; LJSTPT ← LJSTPT - 1;
       GOTO BPT1 IF CHRCNT <= CHRMAX;
       HYMCT ← CHRCNT; NLJCH ← GCD(STLFP: BPT2);

* GET NEXT CHAR, SKIPPING BACKSPACES, AND ADJUST CHRCNT
WHP1:  CLJCH ← NLJCH; NLJCH ← GCD(STLFP: BPT2);
IF NLJCH = BSPCH DO; NLJCH ← GCD(STLFP); GOTO WHP1;
ELSEIF CLJCH > BLKBIT(-1)-1 DO;
       CHRCNT ← CHRCNT - CLJCH$BLKCNT; LJSTPT ← LJSTPT - 1;
       GOTO WHP7 IF CHRCNT <= CHRMAX;
ELSEIF CLJCH # EOLCH DO; CHRCNT ← CHRCNT - 1;
       CLJCH ← CLJCH - CSHFT IF CLJCH > '←';
ENDIF; GOTO WHPS;

* SCAN OVER WORD TAIL
WHP2: IF LTRP(CLJCH) DO; HYBWP ← HYB.RPTR; WCD(CLJCH, HYB);
       HYCNT ← HYCNT + 1; WHPS ← WHP3 IF CLJCH = 'S' ELSE
          WHPS ← WHP4 IF CLJCH = 'D' ELSE
          (WHPS ← WHP5 & HYBWP ← HYB.RPTR) IF CLJCH = 'E' ELSE
          WHPS ← WHP5;
ELSEIF DGTP(CLJCH) DO; HYFLG ← HYFLG + 1; WHPS ← WHP1;
ENDIF; GOTO WHP1;

* STRIP OFF -S, -ES, OR -[QUOTE]S
WHP3:  WCD(CLJCH, HYB); HYCNT ← HYCNT + 1; WHPS ← WHP5;
       HYBWP ← (HYB.RPTR IF CLJCH = 'E' OR CLJCH = '&007' ELSE
               HYB.RPTR + 1); GOTO WHP1;

* STRIP OFF -ED
WHP4:  WCD(CLJCH, HYB); HYCNT ← HYCNT + 1; WHPS ← WHP5;
       HYBWP ← HYB.RPTR IF CLJCH = 'E'; GOTO WHP1;

* SCAN BACK OVER LETTERS AND COLLECT THEM IN HYB
WHP5:  IF LTRP(CLJCH) DO; WCD(CLJCH, HYB); HYCNT ← HYCNT + 1;
ELSEIF CLJCH = '-' OR CLJCH = '/' DO; IHYCNT ← IHYCNT + 1;
       (HYIND ← CHRCNT & HYPTR ← STLFP.WPTR) IF HYPTR < 0 AND
               CHRCNT < CHRMAX AND CHRCNT + 3 <= HYMCT;
ELSEIF DGTP(CLJCH) DO; HYFLG ← HYFLG + 1; WHPS ← WHP1;
ELSE DO; WHPS ← WHP6; HYPFCT ← 1;
ENDIF; GOTO WHP1;

* SCAN OVER WORD PREFIX
WHP6:  IF LTRP(CLJCH) OR DGTP(CLJCH) DO;
          HYFLG ← HYFLG + 1; WHPS ← WHP1;
ELSE DO; HYPFCT ← HYPFCT + 1;
ENDIF; GOTO WHP1;

* INTERACTIVE HYPHENATION PROCESSOR
IHP1:  GOTO BPT1 IF IHYFLG < 0; IHYBRP ← HYB.RPTR;
IHP2:  CRLF(1); SOUT("HYPHENATE: "); IHYCNT ← HYCNT; HYB.RPTR ← IHYBRP;

       HYB.WPTR ← HYB.EPTR; SOUT(HYB); HYB.WPTR ← HYBWP;

* COLLECT WORD
IHP5:  CRLF(1); SETS(IHYWB, 0, 0); SETS(IHYRB, 0, 0);
IHP6:  IHYCH ← CIN(0); (GCD(IHYRB: IHP5) & COUT('↑')
               & GOTO IHP6) IF IHYCH = '&A'
          ELSE (COUT('←') & GOTO IHP5) IF IHYCH = '&Q' ELSE
           GOTO IHP7 IF IHYCH = '&M' ELSE
       (COUT('&M') & IHYFLG ← -1 & GOTO IHP7) IF IHYCH = '&D';
       WCI(IHYCH, IHYRB: IHP6); GOTO IHP6;

* IGNORE IF EMPTY, OTHERWISE ADD TO GLOSSARY
IHP7:  COUT('&J'); GOTO BPT1 IF LENGTH(IHYRB) = 0;

       IHYCNT ← 0; HYB.RPTR ← IHYBRP;

* CHECK WORD AGAINST BUFFER
IHP8:  IHYCH ← GCI(IHYRB: IHP9);
IF LTRP(IHYCH) DO; WCI(IHYCH, IHYWB);
       GOTO IHP2 IF IHYCH # GCI(HYB: IHP8);
ELSEIF IHYCH = '-' DO; IHYCH ← HYB.RPTR - IHYBRP;
       (HYPT[IHYCNT] ← IHYCH & IHYCNT ← IHYCNT + 1) IF
          IHYCNT <= HYPT.LENGF - 2;
ELSE DO; GOTO IHP2;
ENDIF; GOTO IHP8;

* ADD TO GLOSSARY AND LOOP
IHP9:  GOTO IHP2 IF HYB.RPTR # HYB.WPTR; HYB.RPTR ← IHYBRP;
       IHYCNT ← INSGW(IHYWB, IHYCNT);
       (IHYCNT.FPCHB ← -1 & GLPRF ← GLPRF + 1) IF IHYCNT > 0;
       GOTO WHP8;

* LOOK UP WORD IN GLOSSARY, AND CHECK FOR MAXIMAL HYPHEN POINT
WHP7:  STLFP.WPTR ← STLFP.WPTR + 1;
       GOTO BPT1 IF HYFLG >= 0 OR HYCNT <= 5;
       FTLERR() IF CLJCH < BLKBIT(-1);
       HYCNT ← CHRCNT + HYPFCT + CLJCH$BLKCNT;
       GOTO BPT1 IF HYCNT + 3 > CHRMAX OR
               ((CHRMAX - HYCNT)* 10)/ LJSTPT <= HYBPT;
       (GOTO HYP3 IF HYPTR >= 0 ELSE GOTO BPT1) IF IHYCNT < 0;

WHP8:  HYB.WPTR ← HYBWP;
       HYPTR ← LKP(GLTAB, HYB: IHP1)[0].LKPTR;* TO IHP1 IF NOT FOUND
       GOTO HYP1 IF HYCNT + HYPTR[HYIND] < CHRMAX
          FOR HYIND ← (HYPTR.LENGF - 1) - 1 BY -1 TO 1;
       GOTO BPT1;* NO HYPHEN POINT IN BOUNDS

* PREPARE TO HYPHENATE
HYP1:  HYCNT ← HYCNT + HYPTR[HYIND];
       GOTO BPT1 IF HYCNT < CLJCH$BLKCNT + CHRCNT + 2 OR
               HYCNT + 3 > HYMCT;
       STRPTL.BPTR ← STRPTL.RPTR ← STLFP.WPTR;

* SCAN TO HYPHENATION POINT
HYP2:  CLJCH ← GCI(STRPTL);
IF CLJCH > BLKBIT(-1)-1 DO; CHRCNT ← CHRCNT + CLJCH$BLKCNT;
       LJSTPT ← LJSTPT + 1;
ELSEIF CLJCH = BSPCH DO; CHRCNT ← CHRCNT - 1;
ELSE DO; CHRCNT ← CHRCNT + 1; GOTO HYP4 IF CHRCNT > HYCNT;
ENDIF; GOTO HYP2;

* ENTER HERE FOR HYPHEN IN WORD
HYP3:  GOTO BPT1 IF HYIND < CLJCH$BLKCNT + CHRCNT + 2;
       STRPTL.BPTR ← STRPTL.RPTR ← STLFP.WPTR ←
          STCPY.WPTR ← (STLFP.WPTR ← HYPTR) + 2; CHRCNT ← HYIND + 1;
       OLJCH ← EOLCH; NLJCH ← GCI(STRPTL); CLJCH ← GCI(STRPTL: HYP6);
       GOTO HYP5;

* COPY REST OF STRING
HYP4:  STCPY.WPTR ← (STLFP.WPTR ← STRPTL.RPTR) - 1;
       OLJCH ← '-'; NLJCH ← EOLCH;

HYP5:  WCI(OLJCH, STCPY); OLJCH ← NLJCH; NLJCH ← CLJCH;
       CLJCH ← GCI(STRPTL: HYP6); GOTO HYP5;

HYP6:  WCI(OLJCH, STCPY); WCI(NLJCH, STCPY);
       STRPTL.WPTR ← STRPTL.EPTR ← STCPY.WPTR;


BPT1:  LJSTBL ← CHRMAX - CHRCNT; WCI(EOLCH, STLFP: BPT3);
       STRPTL.BPTR ← STRPTL.RPTR ← STLFP.WPTR; SRETURN;

BPT2:  STLFP.WPTR ← STRPTL.WPTR; STERF();
BPT3:  RETURN;

* JUSTIFICATION SUBROUTINE
FUNCTION JUST();
JUST1: CLJCH ← GCI(STLFP: JUST6);
JUST2: GOTO JUST6 IF CLJCH = EOLCH; GOTO JUST5 IF CLJCH = BSPCH;
       GOTO JUST4 IF CLJCH > BLKBIT(-1)-1; PCHR(CLJCH);
JUST3: (PCHR(BSPCH) & PCHR(ULCH)) IF ULNF < 0; GOTO JUST1;

JUST4: IF LJSTBL > 0 DO;
       CHRCNT ← (LJSTBL IF LNPTY < 0 ELSE LJSTBL + LJSTPT - 1)/ LJSTPT;
       LJSTBL ← LJSTBL - CHRCNT; LJSTPT ← LJSTPT - 1;
       PCHR(BLKBIT(-1) OR CHRCNT + CLJCH$BLKCNT);
ELSE DO; PCHR(CLJCH);
ENDIF; GOTO JUST3;

JUST5: PCHR(BSPCH); PCHR(GCI(STLFP)); CLJCH ← GCI(STLFP);
       GOTO JUST2 IF CLJCH # BSPCH ELSE GOTO JUST5;

JUST6: RETURN;

*
* TEXT AND COMMAND INPUT PASS
*
DECLARE FIELD LTYPF(0: 0,2), CTYPF(0: 3,5), ADDRF(0: 10, 23);
DECLARE IBFF, IBFP, IBFL, IBFEF, GAM4,
       TIPPC, TIPCH, TIPAD, DCSGC, DCSCH, DCSST, DCSCT;

DECLARE MACRO BIO(F, C, SL) ← POP(576B, F, C,, SL);
FUNCTION TIPGW(); RETURN $IBFP IF (IBFP ← IBFP + 1) < IBFL;
       RETURN (LTYPF(7) OR CTYPF(2)) IF IBFEF < 0;
       BIO(DIF, 256, IBFF: TIPG1); IBFP ← IBFF; RETURN $IBFF;
TIPG1: SAVE(IBFL); IBFEF ← -1; IBFP ← IBFF; RETURN $IBFF;

TIPA:  GAM4 ← TIPGW(); TIPAD ← GAM4$ADDRF;
       GOTO $TIP1[GAM4$LTYPF]; DECLARE FIXED ARRAY TIP1[8] ←
           TIPB, TIPC, FTLERR, TIPD, FTLERR, FTLERR, TIPE, TIPH;

* NEW FILL LINE
TIPB:  FMTP ← -1; LMODE ← GAM4$CTYPF;
       FRTBL ← (TIPAD - 4B4 IF TIPAD > 17777B ELSE TIPAD); GOTO TIPD;
TIPC:  FMTP ← TIPAD;* NEW FORMAT LINE

* MAIN TEXT LOOP
TIPD:  GAM4 ← TIPGW(); TIPCH ← GAM4$CH1; GOTO TIPA IF TIPCH = COMCH;
       TIPPC(TIPCH); GOTO TIPA IF TIPCH = EOLCH;

       TIPCH ← GAM4$CH2; GOTO TIPA IF TIPCH = COMCH;
       TIPPC(TIPCH); GOTO TIPA IF TIPCH = EOLCH;

       TIPCH ← GAM4$CH3; GOTO TIPA IF TIPCH = COMCH;
       TIPPC(TIPCH); GOTO TIPD IF TIPCH # EOLCH ELSE GOTO TIPA;

DECLARE FIXED ARRAY DCSA(5) ← HEDST, PPFST, PSCST, PSFST, INXST;
DECLARE FIXED ARRAY DCSC(4) ← NHDCH, NPFCH, NSCCH, NSFCH;

* COMMAND STRING
TIPE:  TIPCH ← GAM4$CTYPF; DCSST ← $DCSA[TIPCH]; SETS(DCSST, 0,0);
       CONEC(TIPPC, DCSGC); ICNCT(TIPPC, TIPD); GOTO $TIP2[TIPCH];
   DECLARE FIXED ARRAY TIP2[5] ← TIPF, TIPF, TIPF, TIPF, INXA;

* (SOME) HEADING STRING
TIPF:  DCSCT ← DCSC[TIPCH]; $DCSCT ← 0;

* COLLECT STRING
DCS1:  DCSCH ← DCSGC(); GOTO DCS3 IF DCSCH = EOLCH;
       $DCSCT ← $DCSCT - 1 IF DCSCH = BSPCH ELSE $DCSCT ← $DCSCT + 1;
       WCI(DCSCH, DCSST: DCS2); GOTO DCS1;
DCS2:  STERF(); GOTO DCS1;

DCS3:  CONEC(TIPPC, PFPGC); DCSGC(); FTLERR();

* COLLECT INDEX ENTRY AND ADD TO TABLE
INXA:  DCSCH ← DCSGC(); (IXLLEN ← 0 & GOTO INXD) IF DCSCH = ' ';
INXB:  GOTO INXE IF DCSCH = ',';
       (IXTBP ← @IXTAB & GOTO INXP) IF DCSCH = EOLCH;
       WCI(DCSCH, INXST: INXC); GOTO INXA;
INXC:  STERF(); GOTO INXA;

INXD:  IXLLEN ← IXLLEN + 1; GOTO INXD IF (DCSCH ← DCSGC()) = ' ';
       WCI(BLKBIT(-1) OR BLKCNT(IXLLEN), INXST: INXC); GOTO INXB;

* WE HAVE A SECONDARY PHRASE TO COLLECT, SAVE REFERENCE
INXE:  IXPTR ← LKP(IXTAB, INXST: INXF)[0].LKPTR; GOTO INXG;
INXF:  IXPTR ← INS(@IXTAB, INXST, FTLERR)[0]; IXPTR.LKPTR ← MAKE(3);
       IXPTR ← IXPTR.LKPTR; IXPTR[1] ← 1;

INXG:  IXPPTR ← IXPTR[0]; IXPTR[0] ← IXPPTR ← MAKE(5) IF IXPPTR = 0;
       IXTBP ← @IXPTR[0]; SETS(INXST, 0,0);

INXH:  DCSCH ← DCSGC(); GOTO INXH IF DCSCH = ' '; WCI(DCSCH, INXST);

INXJ:  DCSCH ← DCSGC(); (IXLLEN ← 0 & GOTO INXM) IF DCSCH = ' ';
INXK:  GOTO INXP IF DCSCH = EOLCH;
       WCI(DCSCH, INXST: INXL); GOTO INXJ;
INXL:  STERF(); GOTO INXJ;

INXM:  IXLLEN ← IXLLEN + 1; GOTO INXM IF (DCSCH ← DCSGC()) = ' ';
       WCI(BLKBIT(-1) OR BLKCNT(IXLLEN), INXST: INXL); GOTO INXK;

* ADD PAGE REFERENCE TO IXTBP
INXP:  IXPTR ← LKP($IXTBP, INXST: INXQ)[0]; IXLPTR ← IXPTR.LKPTR;
       IXLLEN ← IXLPTR.LENGF;
IF IXLPTR[1] + 2 = IXLLEN DO;
       IXPPTR ← MAKE((IXLLEN * 3)/ 2); BCOPY(IXPPTR, IXLPTR, IXLLEN);
       FREE(IXLPTR); IXPTR.LKPTR ← IXLPTR ← IXPPTR;
ENDIF; GOTO INXR;

INXQ:  IXPTR ← INS(IXTBP, INXST, FTLERR)[0];
       IXPTR.LKPTR ← IXLPTR ← MAKE(3); IXLPTR[1] ← 1;

INXR:  IXLPTR[1] ← IXPPTR ← IXLPTR[1] + 1;

IF IXI >= IXF.LENGF - 1 DO; IXLPTR ← MAKARY((IXF.LENGF RSH 1)* 6);
       BCOPY(IXLPTR, IXF, IXI); FREE(IXF); IXF ← IXLPTR; ENDIF;

       IXF[IXI] ← PBI + LFCNT; IXF[IXI + 1] ← CH1(IXPPTR) OR ADDRF(IXPTR);
       IXI ← IXI + 2; GOTO DCS3;

TIPH:  GOTO $TIP3[GAM4$CTYPF]; DECLARE FIXED ARRAY TIP3[3] ←
           TIPJ, TIPK, TIPL;

TIPJ:  $TIPAD ← 0; GOTO TIPA;* RESET FLAG
TIPK:  $TIPAD ← -1; GOTO TIPA;* SET FLAG

* MODE ROUTINE WITH PARAMETERS
TIPL:  $DCPA[GAM4$CH2](GAM4$CH3); GOTO TIPA;
DECLARE FIXED ARRAY DCPA(14) ← DCED, DCPM, DCHM, DCBG, DCEG,
       DCSP, DCLL, DCHL, DCPL, DCPG, DCOP, DCEJ, DCHB, DCIP;

FUNCTION DCHB(HYBPT); RETURN;

FUNCTION DCPM(PMODE); RETURN;
FUNCTION DCHM(HMODE); RETURN;

FUNCTION DCBG(); STERF() IF PCHG < 0 ELSE
       (PCHB ← -1 IF GSPC < 0 & PCHG ← -1); RETURN;
FUNCTION DCEG(); PCHG ← 0; RETURN;

FUNCTION DCSP(TSPC); TIPPC(VSPCH); RETURN;

FUNCTION DCLL(LLMAR); RLMAR ← TIPGW(); RETURN;

FUNCTION DCHL(TIPCH); TIPPC(EOCCH); LWIDTH ← TIPCH;
       GAM4 ← TIPGW(); EPGBL ← GAM4$CH1; OPGBL ← GAM4$CH3;
       GAM4 ← TIPGW(); TIPCH ← GAM4$CH1;
       (FREE(PCB) & PCB ← MAKARY(TIPCH + 1)) IF TIPCH # NCOL;
       NCOL ← TIPCH; CSPC ← GAM4$CH3; CPBL(); RETURN;

FUNCTION DCPL(TIPCH); TIPPC(EOPCH); TPBL ← TIPCH;
       GAM4 ← TIPGW(); PLENG ← GAM4$CH1; CSLOP ← GAM4$CH3; RETURN;

FUNCTION DCPG(TIPCH); TIPPC(EOPCH); PAGNO ← TIPCH; RETURN;
FUNCTION DCOP(TIPCH); TIPPC(EOPCH);
       PAGNO ← PAGNO + 1 IF PAGNO MOD 2 = 0; RETURN;
FUNCTION DCEJ(GSPC); (TIPPC(EOPCH) & GSPC ← -1 & RETURN) IF
           (GSPC ← GSPC - 1) < 0; PCHB ← -1 IF PCHG >= 0; RETURN;
FUNCTION DCIP(TIPCH); PAGNO ← PAGNO + TIPCH; RETURN;

FUNCTION DCED(); (TIPPC(EODCH) & FTLERR()) IF IXTAB[0] = 0;* NO INDEX

       TIPPC(EOPCH); INXCH ← -1;
FOR IXPTR ← 1 TO IXTAB[0] DO; FMTP ← RINAD; IXLPTR ← IXTAB[IXPTR];

       IXPPTR ← IXLPTR[1]$CH1; IXPPTR ← IXPPTR - CSHFT IF IXPPTR > '←';
       DCSP(1) IF IXPPTR # INXCH; INXCH ← IXPPTR; DCEPI(IXLPTR);

       IXTBP ← IXLPTR.LKPTR[0];
   IF IXTBP > 0 DO; TIPPC(','); TIPPC(EOLCH); FMTP ← SINAD;
       (DCEPI(IXTBP[IXPPTR]) & TIPPC(EOLCH)) FOR IXPPTR ← 1 TO IXTBP[0];
   ELSE DO; TIPPC(EOLCH);
   ENDIF;* IXTBP
ENDFOR;* IXPTR

       TIPPC(EODCH); FTLERR();

* PRINT INDEX TABLE ENTRY
FUNCTION DCEPI(DCEPIT); DECLARE DCEPIP, DCEPIB;
       DCEPS(DCEPIT); DCEPIT ← DCEPIT.LKPTR;
FOR DCEPIP ← 2 TO DCEPIT[1] DO; TIPPC(','); TIPPC(' ');
       DCEPIB ← DCEPIT[DCEPIP]; DCEPS(DCEPIB$ADDRF) IF DCEPIB$ADDRF # 0;
       CNS(DCEPIB$CH1, INXST); TIPPC(DCSCH) FOR DCSCH ←
               GCI(INXST: DCEPIX) WHILE 1;
DCEPIX: ENDFOR; RETURN;

* PRINT INDEX TABLE STRING
FUNCTION DCEPS(DCEPSP); DECLARE FIXED STRING DCEPST;
       SETUP(DCEPST, DCEPSP.LKPNC, DCEPSP + 1);
       DCEPST.WPTR ← DCEPST.EPTR;
       TIPPC(DCSCH) FOR DCSCH ← GCI(DCEPST: DCEPS1) WHILE 1;
DCEPS1: RETURN;

*
* PAGE FORMATTING PASS
*

* INITIALIZE PFP
FUNCTION $PFP(), LINK XPFP;
       FMTP ← FILLF ← JUSTF ← HYPF ← -1; ULNF ← DSPF ← 0;
       NCOL ← 1; PCB ← MAKARY(2);
       PAGNO ← 1; SCOPY(PPFST, IPPFS); NPFCH ← 6;
       NSCCH ← NSFCH ← NHDCH ← 0; SETS(PSCST, 0,0); SETS(PSFST, 0,0);
       PMODE ← 1; HMODE ← 4; GSPC ← TOPGF ← PAGF ← -1;
       GLPRF ← -1; HYBPT ← 5; IHYRB ← (IHYWB ← MAKE(6)) + 2;
       SETUP(IHYWB, 45); IHYRB.EPTR ← IHYWB.EPTR;

       PAGARY ← 14001B; PAGARY[-1] ← SARRAY - PAGARY  - 1; SETARRAY(0, PAGARY);
       PFPGC ← CNCTR(FTLERR); TIPPC ← CNCTR(TIPA);
       DCSGC ← CNCTR(FTLERR); CONEC(PFPGC, TIPPC);

       IBFF ← MAKE(256); IBFP ← IBFL ← IBFF + 256; IBFEF ← 0;
       IXTAB ← MAKE(5); IXF ← MAKARY(10); IXI ← 0; SCTAB ← MAKE(5);

       GNLC ← PFPGC; PINIT();
       SETS(STLFP, 0, 0); BCOPY(STCPY, STLFP, 4);

PFP1:  CFMCH ← GNLC();
       RETURN FROM XPFP IF CFMCH = EODCH ELSE
       GOTO PFP1 IF CFMCH = EOLCH OR CFMCH = EOPCH OR CFMCH = EOCCH;

       NEWPG(); GOTO PFP5 IF CFMCH # VSPCH;

PFP2:  PLF(TSPC);

PFP3:  CFMCH ← GNLC();
       GOTO PFP2 IF CFMCH = VSPCH ELSE
            GOTO PFP3 IF CFMCH = EOLCH ELSE
            GOTO CDMP1 IF CFMCH = EODCH OR CFMCH = EOPCH OR CFMCH = EOCCH;

PFP5:  LNPTY ← -1; GOTO TFP1 IF FMTP >= 0;

*LINE FORMATING PASS

LFP1:  FRTBL ← FRTBL + LLMAR; CHRMAX ← RLMAR - FRTBL;
       (STERF() & CHRMAX ← RLMAR - LLMAR) IF CHRMAX <= 0;
       CHRCNT ← LJSTPT ← 0; SETS(STLFP, 0, 0);

LFP2:  WCI(CFMCH, STLFP); ICCNT(CFMCH: LFP3);
       CFMCH ← GNLC(); GOTO LFP2;

LFP3:  GOTO LFP4 IF CHRCNT <= CHRMAX; BKPT(:LFP4);
       GOTO LFP5 IF JUSTF < 0 AND FILLF < 0;

LFP4:  LJSTBL ← 0;

****DELETE LAST CHAR IF BLANK AND CHECK FOR LINE OFLO
LFP5:  (FRTBL ← (RLMAR + LLMAR - CHRCNT)/ 2 & LJSTBL ← 0) IF LMODE = 1
ELSE   (FRTBL ← RLMAR - CHRCNT & LJSTBL ← 0) IF LMODE = 2;
       PCHCC ← FRTBL + CHRCNT + LJSTBL;
       PCHR(BLKBIT(-1) OR BLKCNT(FRTBL)); FRTBL ← LMODE ← 0;

       JUST(); PFILL();

       (GNLC ← GNCS & CFMCH ← GNLC()) IF
               STRPTL.WPTR # STRPTL.RPTR AND FILLF < 0 ELSE
          CFMCH ← GNLC() IF CFMCH # EOLCH;
       (ULNF ← 0 & GOTO PFP6) IF CFMCH = EOLCH ELSE
       LFCNT ← LFCNT + 1 IF DSPF < 0; GOTO LFP1;

DECLARE FIELD FTXCF(0: 0, 9);

* TABLE FORMATTING PASS
TFP1:  FTXT ← MAKE(2 * FMTP[0]$CH3); CHRCNT ← FLCNT ← 0; CHRMAX ← 1D6;
       FTXT[0] ← FTXTP ← MAKE(100); SETUP(FTXTS, 297, FTXTP + 1);

TFP2:  IF CFMCH = TABCH DO;

       FTXTP.FTXCF ← FMTI ← LENGTH(FTXTS); TRUNC(FTXTP, (FMTI + 5)/ 3);
       FTXT[2 * FLCNT + 1] ← CHRCNT; CHRCNT ← 0;

       FLCNT ← FLCNT + 1; (STERF() & GOTO TFP5) IF
               FLCNT = (FTXT.LENGF - 1)/ 2;
       FTXT[2 * FLCNT] ← FTXTP ← MAKE(100); SETUP(FTXTS, 297, FTXTP + 1);

ELSE DO; ICCNT(CFMCH: FOP1);

TFP3:  WCI(CFMCH, FTXTS: TFP4);

ENDIF; CFMCH ← GNLC(); GOTO TFP2;
TFP4:  FTXTP.FTXCF ← LENGTH(FTXTS); FTXTP.LKPTR ← FMTI ← MAKE(100);
       FTXTP ← FMTI; SETUP(FTXTS, 297, FTXTP + 1); GOTO TFP3;

TFP5:  CFMCH ← GNLC(); GOTO TFP5 IF CFMCH # EOLCH;

* FORMATTED OUTPUT PROCESSOR
FOP1:  FTXTP.FTXCF ← FMTI ← LENGTH(FTXTS); TRUNC(FTXTP, (FMTI + 5)/ 3);
       FTXT[2 * FLCNT + 1] ← CHRCNT; FLCNT ← FLCNT + 1; FOPL ← 1;

       FMTC3 ← FMTP[0]; FMTC2 ← FMTC3$CH2; FMTC1 ← FMTC3$CH1;
       FRTBL ← ((RLMAR + LLMAR - FMTC2)/ 2 IF FMTC1 = 2
               ELSE RLMAR - FMTC2 IF FMTC1 = 1 ELSE LLMAR);
       (STERF() & FRTBL ← 0) IF FRTBL < 0;

WHILE FLCNT > 0 DO; FMTF ← FMTP[FOPL];
       PCHCC ← 0; FMTSP ← FRTBL; FLPCT ← FTXT.LENGF - 3;

FOR FMTI ← 0 TO FMTF.LENGF - 2 DO;* ITERATE OVER FORMATS

       FMTC3 ← FMTF[FMTI]; FMTC1 ← FMTC3$CH1;
       FMTC2 ← FMTC3$CH2; FMTC3 ← FMTC3$CH3; GOTO $FOPP[FMTC1];
DECLARE FIXED ARRAY FOPP[8] ← FOPF1, FOPF1, FOPF1, FOPV1, FOPV1,
       FOP3, FOP4, FOP4;

* FIXED FIELD (L R C)
FOPF1: FOPPT ← FTXT[2 * FMTC3]; FLPCT ← FLPCT - 1;
IF FOPPT = 0 DO; FMTSP ← FMTSP + FMTC2;* SKIP MISSING SEGMENT

ELSE DO; CHRCNT ← FTXT[2 * FMTC3 + 1];* GET SEGMENT LENGTH
       (STERF() & CHRCNT ← FMTC2) IF CHRCNT > FMTC2;

       FMTCC ← ((FMTC2 - CHRCNT)/ 2 IF FMTC1 = 2 ELSE
               FMTC2 - CHRCNT IF FMTC1 = 1 ELSE 0);

       PCHR(BLKBIT(-1) OR BLKCNT(FMTSP + FMTCC));
       PCHCC ← PCHCC + (FMTSP + FMTCC + CHRCNT);
       FMTSP ← FMTC2 - CHRCNT - FMTCC;

       CHRMAX ← CHRCNT + 1; CHRCNT ← 0;
       FOPPT ← FOPPT$LKPTR; FTXT[2 * FMTC3] ← 0; FLCNT ← FLCNT - 1;
* LOOP OVER TEXT BLOCKS
FOPF2: SETUP(STLD1, FOPPT.FTXCF, FOPPT + 1); STLD1.WPTR ← STLD1.EPTR;

FOPF3: CLJCH ← GCI(STLD1: FOPF4); ICCNT(CLJCH: FTLERR);
       (CHRCNT ← 0 & GOTIPCOPF4) IF CHRCNT > FMTC2;
       PCHR(CLJCH); GOTO FOPF3;

FOPF4: FMTC3 ← FOPPT.LKPTR; FREE(FOPPT); FOPPT ← FMTC3;
       GOTO FOPF2 IF FOPPT > 0;

ENDIF; GOTO FOP6;

* VARIABLE FIELD (F J)
FOPV1: FOPPT ← FTXT[2 * FMTC3]; FLPCT ← FLPCT - 1;
IF FOPPT = 0 DO; FMTSP ← FMTSP + FMTC2;* SKIP MISSING SEGMENT

ELSE DO; PCHR(BLKBIT(-1) OR BLKCNT(FMTSP));
       PCHCC ← PCHCC + FMTSP;
       CHRMAX ← FMTC2; FMTC2 ← CHRCNT ← LJSTPT ← 0;
       SETS(STLFP, 0, 0);

* LOOP OVER TEXT BLOCKS
FOR FOPPT ← FOPPT$LKPTR, FOPPT.LKPTR WHILE FOPPT > 0 DO;
       SETUP(STLD1, FOPPT.FTXCF, FOPPT + 1); STLD1.WPTR ← STLD1.EPTR;

FOPV2: CLJCH ← GCI(STLD1: FOPV3); FMTC2 ← FMTC2 + 1;
       WCI(CLJCH, STLFP); ICCNT(CLJCH: FOPV4); GOTO FOPV2;

FOPV3: ENDFOR;
       (WCI(EOLCH, STLFP) & GOTO FOPV5) IF CHRCNT <= CHRMAX;

FOPV4: BKPT(:FOPV5); GOTO FOPV6 IF FMTC1 # 4 ELSE GOTO FOPV7;
FOPV5: SETS(STRPTL, 0, 0);
FOPV6: LJSTBL ← 0;
FOPV7: FTXT[2 * FMTC3 + 1] ← FTXT[2 * FMTC3 + 1] - CHRCNT;
       PCHCC ← PCHCC + (CHRCNT + LJSTBL);
       FMTSP ← CHRMAX - CHRCNT - LJSTBL;
       JUST(); CHRCNT ← FMTC2 - LENGTH(STRPTL);

FOPV8: FOPPT ← FTXT[2 * FMTC3];
       (FLCNT ← FLCNT - 1 & FTXT[2 * FMTC3] ← 0 & GOTO FOP6)
               IF FOPPT$LKPTR = 0;
       FMTC2 ← FOPPT.FTXCF;
IF FMTC2 <= CHRCNT DO; FTXT[2 * FMTC3]$LKPTR ← FOPPT.LKPTR;
       FREE(FOPPT$LKPTR); CHRCNT ← CHRCNT - FMTC2; GOTO FOPV8;
ENDIF;

       SETUP(STLD1, FMTC2, FOPPT + 1); BCOPY(STLD2, STLD1, 4);
       SETS(STLD1, CHRCNT, FMTC2); SCOPY(STLD2, STLD1);
       FOPPT.FTXCF ← FMTC2 ← FMTC2 - CHRCNT;
       TRUNC(FOPPT$LKPTR, (FMTC2 + 5)/ 3);
ENDIF; GOTO FOP6;

* MISCELLANEOUS FORMATTING
FOP3:  FMTSP ← FMTSP + FMTC2; GOTO FOP6;* BLANKS
FOP4:  PCHR(BLKBIT(-1) OR FMTSP); PCHCC ← PCHCC + FMTSP; FMTSP ← 0;
       PCHR(FMTC2) IF FMTC1 = 7; PCHR(FMTC3);

FOP6: ENDFOR;* FMTI

       PFILL(); LFCNT ← LFCNT + 1 IF DSPF < 0 AND FLCNT > 0;
       FOPL ← FOPL + 1 IF FOPL < FMTP.LENGF - 2;

ENDFOR;* FLCNT
       FREE(FTXT);

PFP6:  CFMCH ← GNLC();
       GOTO PFP6 IF CFMCH = EOLCH ELSE
          GOTO CDMP1 IF CFMCH = EODCH OR CFMCH = EOPCH OR
               CFMCH = EOCCH OR PBI - PBB > COLMAX ELSE GOTO PFP8;

PFP7:  PBI ← PBI + 1; LFCNT ← CDLF;* CLEAN UP COLUMN MESS
PFP8:  GOTO PFP2 IF CFMCH = VSPCH ELSE LFCNT ← LFCNT + 1 IF DSPF < 0;
               GOTO PFP5;


* FUNCTION FOR DETERMINING COLUMN BREAK POINT
DECLARE CDLF, CDCL, CDCLM, PCI, PCJ, PCL, PCS, PCF, PCP, PCT, PCE;

FUNCTION CBPT(CBPI); DECLARE CBPK;
       (CBPI ← CBPK & GOTO CBPT1) IF PBF[CBPK]$FPCHB # 0
               FOR CBPK ← CBPI BY -1 TO CBPI - CSLOP;
       (CBPI ← CBPI - 1 IF PBF[CBPI + 1]$FPCHB # 0) IF CBPI < PBI
               ELSE FTLERR();* BETTER HAVE OFLO (RETURN IF BAD ASSUMPTION)

       ((CBPI ← CBPK & GOTO CBPT1) IF PBF[CBPK]$FPCHB # 0
           FOR CBPK ← CBPI BY -1 TO PCI) IF PBF[CBPI]$FPCHG # 0;

CBPT1: SRETURN CBPI IF PBF[CBPI]$FPCHP # 0
               FOR CBPI ← CBPI TO PBI; RETURN;

CDMP1: CDLF ← LFCNT; LFCNT ← PCS ← 0; PBI ← PBI - 1;
       (PBM ← PBB & GOTO CDMP6) IF PBB > PBI;* COLUMNS ALREADY PACKED(?)

* SKIP OVER INITIAL BLANK LINES AT HEAD OF COLUMN
       GOTO CDMP2 IF PBF[PBK]$FPCHP # 0 ELSE LFCNT ← LFCNT + 1
               FOR PBK ← PBB TO PBI; FTLERR();* ?

CDMP2: PCB[0] ← PCI ← PBK; CDCL ← LINMAX - LFCNT - LINCNT;
       (PBM ← PBB & GOTO CDMP6) IF CDCL <= 0;

* IF END OF COLUMN CONDITION
IF CFMCH = EOCCH OR CFMCH = EODCH OR CFMCH = EOPCH DO; CDCLM ← CDCL;

* ITERATIVELY FIND BEST COLUMN DIVISION
       PCS ← PCS + 1 IF PBF[PCJ]$FPCHP # 0 FOR PCJ ← PBK TO PBI;
       PCS ← CDCLM IF PCS > CDCLM;

   FOR CDCL ← (PCS + NCOL - 1)/ NCOL TO CDCLM DO;* IMPROVE THIS

       PCB[PCJ] ← PCI ← CBPT(PCI + CDCL: FTLERR)
           FOR PCJ ← 1 TO NCOL - 1;
       (PCB[NCOL] ← PCI ← PBI + 1 & GOTO CDMP4) IF PBI - PCI <= CDCL;

CDMP3: PCI ← PBK;
   ENDFOR;
       CDCL ← CDCLM;

* CHECK FOR TRUE OVERFLOW AND DIVIDE INTO COLUMNS
ELSE DO;

       PCB[PCJ] ← PCI ← CBPT(PCI + CDCL: PFP7)
          FOR PCJ ← 1 TO NCOL - 1;
       GOTO PFP7 IF PBI - PCI <= CDCL;

ENDIF;
       PCB[NCOL] ← PCI ← CBPT(PCI + CDCL: FTLERR);

CDMP4: PBM ← PCI;* PACK THE COLUMNS INTO LINES
FOR PCI ← 0 TO CDCL DO; PCL ← (LWIDTH - CSPC *(NCOL - 1))/ NCOL;

       PCE ← -1; PCS ← 0;
       (PCT ← PCB[PCJ] + PCI & (PCT ← PBF[PCT] &
           PCE ← PCE + 1 IF PCT$FPCHE # 0 & PCT ← PCT$FPCHP &
               PCS ← PCS + PCT.CH1 IF PCT > 0) IF PCT < PCB[PCJ + 1])
          FOR PCJ ← NCOL - 1 BY -1 TO 0;* COMPUTE BLOCK LENGTH

   IF PCS > 0 DO;
     IF NCOL = 1 DO; PCF ← PBF[PCB[0] + PCI]$ADDRF;
       $PCF ← PCS;* SIMULATE PACKING

     ELSE DO; PCF ← MAKE(PCS + 1, PAGARY); PCP ← PCF + 1;
       PCS ← (LWIDTH - NCOL *(PCL + CSPC) + CSPC)/ 2;

       FOR PCJ ← 0 TO NCOL - 1 DO; PCT ← PCB[PCJ] + PCI;
          IF PCT < PCB[PCJ + 1] AND (PCT ← PBF[PCT]$FPCHP) > 0 DO;

               PCT[1]$CH1 ← PCT[1]$CH1 + PCS; PCS ← PCT.CH1 + PCT;

               PCS.CH1 ← NULCH IF PCS.CH1 = EOLCH ELSE
                  PCS.CH2 ← NULCH IF PCS.CH2 = EOLCH ELSE PCS.CH3 ← NULCH;

               PCS ← PCT.CH1; BCOPY(PCP, PCT + 1, PCS); $PCF ← $PCF + PCS;
               PCP ← PCP + PCS; PCS ← PCL - PCT.CH3; FREE(PCT, PAGARY);

          ELSE DO; PCS ← PCS + PCL;
          ENDIF;
       PCS ← PCS + CSPC;
       ENDFOR;* PCJ

       PCT ← PCF + $PCF; PCT.CH3 ← EOLCH;
   ENDIF;* NCOL

       PBF[PBB] ← (0 IF PCE < 0 ELSE FPCHE(-1)) OR
               FPCHL(LFCNT) OR FPCHP(PCF);
       LINCNT ← LINCNT + (LFCNT + 1); LFCNT ← 0; PBB ← PBB + 1;

   ELSE DO; LFCNT ← LFCNT + 1;
   ENDIF;* PCS
ENDFOR;* PCI

* PROCESS INDEX ENTRIES
       PCJ ← (INS(@SCTAB, PSCST, DELSC)[0] IF NSCCH > 0 ELSE 0);
       IXI ← IXI - 2; (GOTO CDMP5 IF IXF[IXB] >= PBM &
           PCT ← IXF[IXB + 1] & PCT$ADDRF.LKPTR[PCT$CH1] ←
               CH1(PAGNO) OR ADDRF(PCJ)) FOR IXB ← 0 BY 2 TO IXI;

* EXIT UNLESS PAGE DUMP IS REQUIRED
CDMP5: (PBI ← PBB & CPBL() &
           (GOTO PFP8 IF CFMCH # EOCCH ELSE GOTO PFP6))
               IF CFMCH # EOPCH AND CFMCH # EODCH AND PBM > PBI;

CDMP6: PBK ← PBB - 1; LDMP(PBF[PBJ]) FOR PBJ ← 0 TO PBK;

       IF TOPGF >=0 AND PAGF < 0 DO; PCL ← PBI; PBI ← 0;
       LFCNT ← PLENG - LINCNT; CPHP(); CHRCNT ← 0;
       POUT(); HFILL(); LDMP(PBF[0]); PBI ← PCL; ENDIF;

       RETURN FROM XPFP IF CFMCH = EODCH AND PBM > PBI;
       COUT(EJCH, DOF); PAGNO ← PAGNO + 1;

* EXIT IF FORCED PAGE EJECT AND 'NEXT' PAGE IS EMPTY
       (FREE(PBF) & TRUNC(IXF, 10) & IXI ← 0 &
          (GOTO PFP1 IF CFMCH = EOCCH OR CFMCH = EOPCH
               ELSE FTLERR())) IF PBM > PBI;

       PCP ← PBF; PCF ← PBM; PCL ← PBI; PCT ← IXF; PCS ← IXI; NEWPG();

       (PBF[PBI] ← 0 & PBI ← PBI + 1) FOR LFCNT ← LFCNT - 1 BY -1 TO 0;

       GOTO CDMP7 IF PCP[PCJ]$FPCHP # 0 FOR PCJ ← PCF TO PCL;
       LFCNT ← 0; PCF ← PCJ; GOTO CDMP8;

CDMP7: PCF ← PCJ;
       (PBF[PBI] ← PCP[PCJ] & PBI ← PBI + 1) FOR PCJ ← PCJ TO PCL;
       LFCNT ← CDLF;

CDMP8: PCS ← IXI; IXI ← 0;* UPDATE REMAINING INDEX ENTRIES

       ((PCL ← IXF[PCJ] - PCF & PCL ← 0 IF PCL < 0 & IXF[IXI] ← PCL &
           IXF[IXI + 1] ← IXF[PCJ + 1] & IXI ← IXI + 2)
               FOR PCJ ← IXB BY 2 TO PCS) IF PCS >= 0;

       TRUNC(IXF, MAX(IXI, 10));* THROW OUT EXTRA ENTRIES
       FREE(PCP);* RELEASE OLD PAGE BUFFER
       GOTO CDMP1 IF CFMCH = EOCCH OR CFMCH = EOPCH OR CFMCH = EODCH
               ELSE GOTO PFP8;

FUNCTION DELSC(); RETURN;

* DUMP GLOSSARY
FUNCTION $DMPGL(), LINK XPFP;
       CHRCNT ← 0; STLD2 ← ".GL "; SOUT(STLD2, DOF);

FOR PBI ← GLTAB[0] BY -1 TO 1 DO; PBJ ← GLTAB[PBI];
IF PBJ < 0 DO;* PROCESS NEW ENTRIES

       (CRLF(1, DOF) & SOUT(STLD2, DOF) & CHRCNT ← 0)
               IF CHRCNT > 50 ELSE COUT(' ', DOF);* FORCE NEW LINE

       SETUP(STLD1, PBJ.LKPNC, PBJ + 1); STLD1.WPTR ← STLD1.EPTR;
       PBJ ← PBJ.LKPTR; HYCNT ← 0; PBK ← 1; PBM ← PBJ[PBK];

DMPG1: COUT(GCI(STLD1: DMPG2), DOF); HYCNT ← HYCNT + 1;
       (COUT('-', DOF) & PBK ← PBK + 1 &
          PBM ← (PBJ[PBK] IF PBK < PBJ.LENGF - 1 ELSE 512))
               IF HYCNT >= PBM; GOTO DMPG1;

DMPG2: CHRCNT ← CHRCNT + (HYCNT + PBJ.LENGF);
       (COUT(HYCNT$CH1, DOF) & CHRCNT ← CHRCNT + 1)
               FOR HYCNT ← PBJ[0], HYCNT LSH 8 WHILE HYCNT > 0;
ENDIF; ENDFOR; RETURN;

       END;

*********************  NIP  ************************

**QSPL
       IDENT IPROC;


GO:    GOTO INIT; GOTO DMP;

DECLARE FIELD RPTR(1), WPTR(2);
DECLARE FIELD CH1(0:0,7), CH2(0:8,15), CH3(0:16,23);

* GLOBAL ENVIRONMENT FOR RUNOFF
DECLARE $FILLF, $FMTP, $ULNF, $JUSTF, $DSPF, $HYPF, $PAGF, $TOPGF,
       $IHYFLG, $GLPRF, $ERFLG;
DECLARE $MNTAB, $FMTAB, $GLTAB, FIXED STRING $HYB(45),
       FIXED ARRAY $HYPT(30);
DECLARE $DIF, $DOF, DEV, $RINAD, $SINAD;
DECLARE $CVCGC, $SYPGC, $GCHPC, $CVCPC, $SYPPC, $TOPGC;

* PARAMETERS FOR CO-ROUTINE CONNECTOR
DECLARE PARAMETER LDA ← 76B5, XMA ← 62B5, STA ← 35B5,
       BRU ← 1B5, BRR ← 51B5, IABIT ← 4B4;

* INITIALIZE CO-ROUTINE
FUNCTION $CNCTR(CN2); DECLARE CN1; CN1 ← MAKE(7);
       CN1[0] ← (STA+5) + CN1; CN1[1] ← LDA; CN1[2] ← (XMA+5) + CN1;
       CN1[3] ← (BRU+IABIT+6) + CN1; CN1[4] ← (BRR+5) + CN1;
       CN1[5] ← CN2 - 1; RETURN CN1;

* CONNECT TWO CO-ROUTINES
FUNCTION $CONEC(CN1, CN2); CN1[6] ← CN2 + 4; CN2[6] ← CN1 + 4;
       RETURN;

FUNCTION $MATE(CN1); RETURN CN1[6] - 4;
FUNCTION $ICNCT(CN1, CN2); CN1[5] ← CN2 - 1; RETURN;

FUNCTION $TRUNCZ(TRUNCL, TRUNCS, TRUNCA), LINK TRUNCX; GOTO TRNC1;
FUNCTION $TRUNC(TRUNCL, TRUNCS), LINK TRUNCX; TRUNCA ← SARRAY;
DECLARE TRUNCT, FIELD LENGF(-1: 10, 23);

TRNC1: TRUNCS ← 2 IF TRUNCS <= 1;
IF (TRUNCT ← TRUNCL.LENGF - (TRUNCS ← TRUNCS + 1)) > 2 DO;

       TRUNCL.LENGF ← TRUNCS; TRUNCL[TRUNCS - 1] ← TRUNCT;
       FREE(TRUNCL + TRUNCS, TRUNCA);

ENDIF;
       RETURN;

FUNCTION $MIN(MNMXX, MNMXY); RETURN (MNMXX IF MNMXY > MNMXX ELSE MNMXY);
FUNCTION $MAX(MNMXX, MNMXY); RETURN (MNMXX IF MNMXX > MNMXY ELSE MNMXY);

DECLARE MACRO INC(X, Y) ← X ← X + (Y);

FUNCTION $LKP(LKPTB, LKPST), LINK XLKP;* BINARY LOOKUP FUNCTION
DECLARE LKPL, LKPT, LKPU, LKPKC, LKPTC, LKPCL, LKPSR;
DECLARE FIELD LKPNC(0:0,9), LKPTR(0:10,23), FIXED STRING LKPCS;

       RETURN (LKPT ← LKPTB + 1) IF LKPTB[0] < 1;

       LKPL ← LKPTB + 1; LKPU ← LKPTB + LKPTB[0];
       LKPSR ← LKPST.RPTR;

LKP1:  LKPTC ← (LKPT ← (LKPU + LKPL) RSH 1)[0];
       LKPCL ← LKPTC.LKPNC;

       SETUP(LKPCS, LKPCL, LKPTC+1); SETW(LKPCS, LKPCL);
       LKPST.RPTR ← LKPSR;

LKP2:  LKPTC ← GCI(LKPCS: LKP4); LKPKC ← GCI(LKPST: LKP3);

       GOTO LKP3 IF LKPKC < LKPTC ELSE
               GOTO LKP5 IF LKPKC > LKPTC ELSE GOTO LKP2;

LKP3:  LKPU ← LKPT - 1; GOTO LKP6;* KEY < ENTRY

LKP4:  GOTO LKP5 IF LKPST.RPTR # LKPST.WPTR;
       XLKP ← XLKP + 1; GOTO LKP7;* KEY = ENTRY

LKP5:  LKPL ← (LKPT ← LKPT + 1);* KEY > ENTRY

LKP6:  GOTO LKP1 IF LKPU >= LKPL;
LKP7:  LKPST.RPTR ← LKPSR; RETURN LKPT;

FUNCTION $INS(INSTB, LKPST, INSFN); LKP($INSTB, LKPST: INS1);
       INSFN(LKPT); GOTO INS3;

INS1:  IF LKPTB.LENGF - 2 = LKPTB[0] DO;
       LKPCL ← LKPTB[0]; LKPTC ← MAKE((LKPCL * 5)/ 4 + 1);
       BCOPY(LKPTC, LKPTB, LKPCL + 1);
       LKPT ← LKPT + (LKPTC - LKPTB);
       FREE(LKPTB); $INSTB ← LKPTB ← LKPTC;
ENDIF;

       GOTO INS2 IF LKPT > (LKPU ← LKPTB + LKPTB[0]);

       LKPTC[1] ← LKPTC[0] FOR LKPTC ← LKPU BY -1 TO LKPT;

INS2:  LKPTB[0] ← LKPTB[0] + 1;

INS3:  LKPCL ← LENGTH(LKPST); LKPTC ← MAKE((LKPCL + 5)/ 3);
       SETUP(LKPCS, LKPCL, LKPTC + 1);
       SCOPY(LKPCS, LKPST); LKPTC[0] ← LKPNC(LKPCL);
       LKPT[0] ← LKPTC; RETURN LKPT;

* INSERT WORD IN GLOSSARY
FUNCTION $INSGW(INSGWB, INSGWI); DECLARE INSGWC, INSGWT, INSGWW;

* PREPARE WORD FOR STORAGE, STRIP -E, -S, -ES, -ED
       INSGWT ← LENGTH(INSGWB); RETURN 0 IF INSGWT < 5;
       INSGWW ← 0; INSGWC ← GCD(INSGWB);
       (INSGWW ← '' IF (INSGWC ← GCD(INSGWB)) = '&007' ELSE
          (INC(INSGWB.WPTR, 1) & INSGWW ← 'S  ') IF INSGWC # 'E'
               ELSE INSGWW ← 'ES ') IF INSGWC = 'S' ELSE
          (INC(INSGWB.WPTR, 2) IF GCD(INSGWB) # 'E' ELSE INSGWW ← 'ED ')
               IF INSGWC = 'D' ELSE
          INSGWW ← 'E  ' IF INSGWC = 'E' ELSE INC(INSGWB.WPTR, 1);

       INSGWT ← MAKE(INSGWI + 1);* INSERT THE ENTRY IN THE GLOSSARY
       BCOPY(INSGWT + 1, HYPT, INSGWI) IF INSGWI > 0;
       INSGWT[1] ← 512 IF INSGWI = 0; INSGWT[0] ← INSGWW;
       INSGWI ← INS(@GLTAB, INSGWB, DELGW); INSGWI[0].LKPTR ← INSGWT;
       RETURN INSGWI;



FUNCTION DELGW(DELGWP); RETURN FREE(DELGWP[0].LKPTR);

* INITIALIZE FORMATS FOR INDEXING
FUNCTION IINX(); DECLARE PARAMETER IXWDTH ← 27;
   MSG ← "RINDEX"; CN1 ← INS(@FMTAB, MSG, FTLERR)[0];
   CN1.LKPTR ← RINAD ← MAKE(3); RINAD[0] ← CH1(2) OR CH2(IXWDTH) OR CH3(1);
   RINAD[1] ← CN1 ← MAKE(2); CN1[0] ← CH1(3) OR CH2(IXWDTH); CN1[1] ← CH1(5);
   RINAD[2] ← CN1 ← MAKE(2); CN1[0] ← CH1(5) OR CH2(4);
       CN1[1] ← CH1(3) OR CH2(IXWDTH-4);

   MSG ← "SINDEX"; CN1 ← INS(@FMTAB, MSG, FTLERR)[0];
   CN1.LKPTR ← SINAD ← MAKE(3); SINAD[0] ← CH1(2) OR CH2(IXWDTH) OR CH3(1);
   SINAD[1] ← CN1 ← MAKE(2); CN1[0] ← CH1(5) OR CH2(2);
       CN1[1] ← CH1(3) OR CH2(IXWDTH-2);
   SINAD[2] ← CN1 ← MAKE(2); CN1[0] ← CH1(5) OR CH2(4);
       CN1[1] ← CH1(3) OR CH2(IXWDTH-4); RETURN;

* START OF PASS 1 INITIALIZE FIRST

DECLARE ICHR, RLA, RLB, RLC, FIXED STRING MSG, FNM(45);
DECLARE *DMPGL, *PFP, *IGCH, *ISYP, *ICVP, *ICMP, *ITOP, *TOP,
       *DGCH, *DSYP, *DCVP, *DCMP, *DTOP;
DECLARE FIELD MB0(0: 0, 5), MB12(0: 6, 17);

DECLARE MACRO RYN(FE) ← ICHR ← CIN(0) &
       ((COUT('E') & COUT('S')) IF ICHR = 'Y' ELSE
               COUT('O') IF ICHR = 'N' ELSE GOTO FE) &
           GOTO FE IF CIN(0) # '.';

INIT:  BRS(43:: RLA, RLC); RLB ← MB0(RLA$MB0) OR MB12(RLC$MB12);
       RLC$MB12 ← 0; BRS(44, RLA, RLC);
       SARRAY ← 24001B; INITIALIZE();* SET-UP ROUTINE
       MSG ← " 3/12/71"; SOUT(MSG);

* ASSUME OUTPUT DEVICE = TELETYPE (GOOD FOR PRINTERS)
       DEV ← 0;

* OPEN TEXT FILE AND INITIALIZE FIRST PASS
RUN1:  MSG ← "&"RUNOFF-TXT-FILE&""; DOF ← OUTFILE(MSG, 13B6: FTLERR);
       ICMP(); ITOP(DEV); IINX();

OPIF: MSG ← "INPUT FROM: "; CRLF(1); SOUT(MSG);
       SETS(FNM, 0, 0); ICHR ← INNAME(FNM: OPIF);
       GOTO OPIF IF ICHR # '.' AND ICHR # ',';
       DIF ← INFILE(FNM: OPIF); CRLF(1);
       IGCH(); ISYP(); ICVP();
       CONEC(GCHPC, CVCGC); CONEC(CVCPC, SYPGC); CONEC(SYPPC, TOPGC);
       TOP(); DGCH(); DSYP(); DCVP(); CLOSE(DIF);
       GOTO RUN2 IF ICHR = '.';

RDMI:  MSG ← "MORE? "; CRLF(1); SOUT(MSG); RYN(RDMI);
       GOTO OPIF IF ICHR = 'Y';

* START PASS II
RUN2:  DCMP(); DTOP(); CLOSE(DOF);
       BRS(43::, RLC); BRS(44, RLB, RLC); GOTO OPOF;

OPOFE: CLOSE(DIF); CLOSE(DOF);
OPOF:  MSG ← "OUTPUT TO: "; CRLF(1); SOUT(MSG);
       SETS(FNM, 0, 0); ICHR ← OUTNAME(FNM:OPOF);
       DOF ← OUTFILE(FNM, 13B6: OPOF); IHYFLG ← -1;
       MSG ← "RUNOFF-TXT-FILE"; DIF ← INFILE(MSG: FTLERR);
       GOTO FMT IF ICHR = '.'; GOTO OPOFE IF ICHR # ',';

RDIH:  MSG ← "INTERACTIVE HYPHENATION? "; CRLF(1); SOUT(MSG);
       RYN(RDIH); IHYFLG ← (0 IF ICHR = 'Y' ELSE -1);

* FORCE RUNOFF PRINTING MODE
FMT:   CRLF(1); WOUT('**R', DOF); WOUT('UNO', DOF);
       WOUT('FF ', DOF); WOUT('&155&152&154', DOF);

       PFP(); CLOSE(DIF); CLOSE(DOF); EXIT() IF GLPRF < 0;

* DUMP THE GLOSSARY
DMP:   MSG ← "/$GLOSSARY$/"; DOF ← OUTFILE(MSG, 13B6: FTLERR);
       DMPGL(); COUT('&137', DOF); COUT('&137', DOF);
      COUT('&137', DOF); CLOSE(DOF); EXIT();

       END;

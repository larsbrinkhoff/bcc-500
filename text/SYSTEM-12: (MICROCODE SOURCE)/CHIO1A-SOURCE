*
*TRICKS USED IN CODING:
*
* CERTAIN TABLES ARE ORIGINED AT LOCATIONS DIVISIBLE BY 2 ↑ N FOR SOME N
*SO THAT A MRG RATHER THAN AN ADD CAN BE USED TO FETCH A WORD FROM 
*THE TABLE
*
*
* CALL A AND RETURN IS SOMETIMES WRITTEN GOTO A;
* AN EXAMPLE OF THIS IS THAT RCH CALLS LNK WHICH CALLS RCH BUT
*EACH OF THE CALLS IS DONE BY A BRANCH. THIS HAS TWO ADVANTAGES.
* 1) EACH CAN BE WRITTEN AS A LEVEL 0 SUBROUTINE BECAUSE
*   IT DOESNT HAVE TO SAVE MORE THEN ONE LINK AT A TIME.
* 2) A PROGRAM CAN SORT OF CALL ITSELF RECURSIVELY.
*
@      NOLIST EXT
*

* DOCUMENTATION CONVENTIONS:
*
* A COMMENT THAT BEGINS WITH THE WORD 'KNOW' INDICATES THAT THE MICROCODE
* AT THAT POINT USES AD HOC KNOWLEDGE ABOUT SOMETHING
*
*
*FOR EACH SUBROUTINE THE  VARIBLES THAT ARE SET UP FOR THE
*SUBROUTINE ARE LISTED UNDER ARGUMENTS, AND THE VALUE IS LISTED.
*UNDER SIDE EFFECTS IS LISTED THE SCRATCH PAD REIGISTERS THAT MIGHT
* CHANGE AS A RESULT OF THIS CALL
*
*REGISTERS M, Q, Z, R0, AND VR ARE VOLATILE AND MAY BE CHANGED AT ANY 
*TIME UNLESS EXPLICITLY STATED THAY ARE DESTROYED ACROSS 
*SUBROUTINE CALLS
*
*
* CONSIDER THE THE FOLLOWING PAIRS OF SPL AND EQUIVILENT MICROPROCESSOR 
*STATEMENTS:
*
*         MICROPROCESSOR STATEMENT       SPL STATEMENT
*
*       DF,F,D,FB,LB;                    DECLARE FIELD F(D:FB,LB);
*
*       @SKN                           NUMBER(0 TO 63) OF THE SCRATCH PAD
*
*       DISP(F)                          F
*
*       MASK(F)                          FMASK(F)
*
*       NMASK(F)                         FMASK(F) EOR -1
*
*       ONE(F)                           IF A←0, A$F←1, THEN A = ONE(F)
*
*       HIGH(F)                          1 LCY (23 - FB)
*
*       LDCY(F)                          23-FSHIFT(F)
*
*       STCY(F)                          FSHIFT(F)
*
*       [N]STUFF(F)                      M AND [NOT] Q LCY LDCY(F)  #
*
*       [N]STUFL(F)                      M AND [NOT] Q LCY LDCYL(F)
*
*
*# COUNT MUST BE 0,1,2,3,4,8,12,16,20 OR ERROR MESSAGE RESULTS
*IF COUNT IS ZERO  A ← B LCY 0 ASSUMED TO BE JUST A ← B;
* AND IS GATED THROUGH THE ADDER

*
*GENERAL COMMENTS ABOUT READ AND WRITE CHARACTER SUBROUTINES.
*
*READ AN WRITE CHARACTER POINTERS MAY ONLY POINT TO WORDS THUS
*THE REST OF THE WORD MUST BE PADDED WITH NULLS.
*THIS MEANS THAT THERE MAY NOT BE ANY POINTERS TO THE MIDDLE
*OF STRINGS.  THIS DOES NOT OCCUR IN THE CHIO HOWEVER.
*RCP POINTS TO THE WORD TO BE READ, AND WCP POINTS TO THE
*WORD TO BE WRITTEN.
*
*THE GENERAL READ CHARACTER AND WRITE CHARACTER PRIMITIVES (RCH, WCH)
*HOLD THE WORD  POINTED TO, THE POINTER, AND THE
* COUNT OF THE NUMBER OF CHARACTER READ (WRITTEN) IN LIVE REGISTERS.
*THIS MINIMIZES MEMORY REFERENCES.
*NEW WORDS MUST BE FETCHED (FOR RCH) OR STORED (FOR WCH) WHENEVER
*THE POINTER IS INCREMENTED.
*
*IF THE READ (WRITE) CHARACTER POINTER ATTEMPTS TO INCREMENT
*INTO A LOCATION DIVISIBLE BY 8 THEN A SUBROUTINE FOUND
*IN RBUF (WBUF) IS CALLED TO MOVE THE POINTER TO THE 
*NEXT BUFFER (GET A NEW BUFFER ).
*
*IF A LINE IS EMPTY BOTH RCH AND WCH POINT TO BUF0 WHICH CONTAINS 0;
*
*IRCH AND IWCH ARE CALLED TO INITIALIZE THE SUBROUTINES AND 
* CRCH AND CWCH ARE CALL TO CLEANUP AFTER THE SUBROUTINES.
*
*WHENEVER A CHARACTER IS READ (WRITTEN),  RCNT (WCNT) IS INCREMENTED;
*RCP (WCP) IS USED TO HOLD THE POINTER.
*THERE IS AN IMPORTANT CONCEPTIUAL DIFFERENCE BETWEEN RCNT AND WCNT.
*RCNT IS INCREMENTED FOR EACH NULL CHARACTER STEPPED OVER AS WELL AS EACH 
*CHARACTER READ. THUS RCNT IS USED TO DETERMINE THE NUMBR OF 
*CHARACTER SHIPPED FROM THE CPU.
*WCNT INDICATES THE NUMBER OF CHARACTERS WRITTEN AND IS THUS USED
*TO KEEP TRACK OF THE CHARACTER COUNT IN THE LINE
*RWORD (WWORD) IS USED TO HOLD THE WORD BEING
*POINTED TO.
* CORE IS UPDATED TO RWORD AND WWORD ONLY WHEN NECESSARY.
*
*IF RCP, OR WCP IS UPDATED THEN THIS IS SIGNALED BY SETTING
*THE BIT (STFLAG)IN THE WORD:
*
*WCP AND RCP ARE ABSOLUTE MEMORY ADDRESSES
*

* BUFFER ALLOCATION:
*
*1) IF THERE ARE ANY BUFFERS IN THE SYSTEM THEN A REQUEST FOR A 
* BUFFER IS ALWAYS FULFILLED
*2) CONSIDER THE SET OF ALL INPUT LINES SUCH THAT
*
*       ABCNT > XBCNT   WHERE D = ABCNT - XBCNT AND ABCNT IS THE ACTUAL
*
* BUFFER COUNT AND  XBCNT IS THE MAX BUFFER COUNT FOR THE LINE
* THEN XIB IS SET TO BE THE SUM OF D FOR ALL LINES IN THE SET.
*
*SIMILERLY XOB IS SO SET FOR OUTPUT LINES
*
*NFB IS THE NUMBER OF FREE BUFFERS
*
*IF AT ANY TIME ONE OF THE FOLLOWING FORUR CONDITIONS OCCURS:
*
* NFB < MINFB, NFB > MAXFB.
*
*THEN THE PROCESS BERTHOLD IS AWAKENED IF IT IS NOT ALREADY AWAKE
* BRECHT IS A FLAG WHOSE VALUE IS 1 IF BERTHOLD IS NOT AWAKE.
*
*THERE ALSO EXISTS A MULTIPLIER MP WHICH  MAY TAKE ON A VALUE FROM 1 TO 
*64
*WHENEVER A PROCESS DOES A WST IF:
*
*       ABCNT >= MP * XBCNT/64
*
*THE PROCESS IS ADVISED NOT TO OUTPUT MORE CHARACTERS. (NSR = 1)
*
*MP IS ONLY UPDATED BY THE CPU
*WHEN A BERTHOLD IS AWAKENED IT SHOULD CHECK FOR THE REASONABLENES OFF
*XIB, XOB, AND NFB;
*

*
*THE TIME INTERUPT QUEUE
*
*SCRATCH PAD REGISTERS NCI TO LCI ARE OF THE FOLLOWING FORM:
*FTOSUB HA A TABLE ENTRY OF A SUBROUTINE
*FTOTIM HAS THE TIME (17 BITS WOTH , CLOCK TICK 10 MICROS.)
*
*THE HIGH ORDER TIME BIT IS NORMALLY 0.
*WHEN A SUBROUTINES IS CALLED IT MUST SPECIFY THE NEXT TIME THAT 
*IT SOULD BE CALLED BY INCREMENTING  NCI APPROPRIATLY AND WHEN IT
*RETURNS GNRFIN WILL SORT THESE SCRATCH PAD REGISTERS
*THE TABLE OF SUBROUTINES CALLED IN GNR
*THE INITIALIZATION OF SUCH SUBROUTINE CALLS IN NCI TO LCI IS DONE BY THE CPU
*
* DOESN'T WORD IF THE INCRIMENT IS >2↑17 * 10 US. (APX. 1 SEC)
*
*HE EIGHTEENTH BIT IS USED AS AN OVERFLOW BIT, IF ALL REGS
*HAVE THE OVERFLOW BIT ON CKFXP IS CALLED TO TURN THEM ALL OFF
*

*
*LIST OF ALL SIGNALS BETWEEN CHIO AND OTHER PROCESSORS
*
*THE CPU CAN SEND A STROBE1 TO THE CHIO INDICATING A REQUEST
*
*THE UTP CAN SEND A STROBE 1 TO THE CHIO INDICATING RESUME FROM RESTART
*SEQUENCE.  THIS CASE IS DIFFERENT FROM THE ONE BEFORE IT
*BECAUSE IT CAN ONLY OCCUR AFTER A Z.M. SIGNAL.
*
*THE CHIO CAN SEND A STOBE1 (SIGUTP) TO THE UTP INDICATING A PROCESS
*HAS BEEN AWAKENED OR THAT THE CLOCK IN CORE HAS BEEN
*UPDATED (EVERY 1 M.S.)
*
*THE CHIO CAN SEND A STROBE2 (SETFAIL) TO THE  UTP INDICATEING IT SHOULD 
*CRASH THE SYSTEM.
*THE UTP CAN SEND A STROBE2(NFAIL) TO THE CHIO INDICATING THAT IT SHOULD
*CLEAN UP IN PREPERATION FOR A SYSTEM CRASH
*
*THE MICROSCHEDULER MAY SEND A Z.M. SIGNAL WHICH SETS THE CHIOS
*PROGRAM COUNTER TO 0 AND SIGNALS EITHER A SYSTEM CRASH(FAILURE) OR
*THE CHIO SHOULD RELOAD ITS REGISTERS AND DO
*A SYSTEM RESTART AS DETERMINED BY SRMEM. (SEE RESTART)
*
*THE LOCATION COUNTER MAY ALSO BE SET TO ZERO BY A HARDWARE
*BREAKPOINT.  THIS IS TESTED BY THE BRANCH CONDITION IBREAK.
*

*
*HERE FOLLOWS THE CALL AND RETURN MICROSUBROUTINES
*FOR LEVELS 0 TO 4;
* A LEVEL - SUBROUTINE WILL CALL NO SUBROUTINES DIRECTLY ALTHOUGH IT 
*MAY BRANCH TO ANOTHER LEVEL - SUBROUTINE
* A LEVEL TOP SUBROUTINE DOES NOT RETURN BUT BRANCHES TO ANOTHER
*TOP LEVEL SUBROUTINE
*WCH AND RCH ARE ON LEVEL 0 BY DEFINITION.  SUBROUTINES THAT CALL THEM 
* ARE ON LEVEL 1 OR HIGHER.
*NOTE THAT A SUBROUTINE MAY EITHER RETURN BY RETURNING OR
*GOING TO RTSSN. OS IS SET UP TO MAKE THIS POSSIBLE
*
*THE FOLLOWING INSTRUCTION MUST BE IN LOCATION 0
       ORG 0;
SYSI:  GOTO SAVEST IF IBREAK;
       GOTO RESTART;
GOGNR:         GOTO GNR;
               GOTO 1B, .MS←60B;   *SET BANK B GOTO CTP
               M←2404B;     *CTPREL
*
*BAD CPU REQUEST 
*
ABCPU:    DGOTO ABORT;                    *TURN OFF DGOTO TO ABORT
       M ← OS, STORE DISP(VALU), GOTO *+1;
       FETCH DISP(NSR);
       Q ← MASK(NSR);
       M ← M OR Q, Q ← MASK(RWCH);
       M ← M AND NOT Q, STORE, GOTO GNR;   *TURN OFF GOTO TO ABORT
ABORT:    GOTO SAVEST, SETFAIL;
SVOS0: SVR0 ← Z, GOTO ABORT, Z ← OS;
RTSS0:  VR ← Q, Q ← SVR0;
       GOTO Q, Q ← VR;
SVOS1: SVR1 ← Z, GOTO ABORT, Z ← OS;
RTSS1:  Q ← SVR1, VR ← Q;
       GOTO Q, Q ← VR;
SVOS2: SVR2 ← Z, GOTO ABORT, Z ← OS;
RTSS2:  Q ← SVR2, VR ← Q;
       GOTO Q, Q ← VR;
SVOS3: SVR3←Z, GOTO ABORT, Z ← OS;
RTSS3:  Q ← SVR3, VR ← Q;
       GOTO Q, Q ← VR;
SVOS4: SVR4 ← Z, GOTO ABORT, Z ← OS;
RTSS4:  Q ← SVR4, VR ← Q;
       GOTO Q, Q ← VR;
*
*
*SPECIAL TRIVIAL SUBROUTINES AND LOCATIONS
*
RETRESET:    RESETA, RETURN;
*
RETSET:    SETA, RETURN;
*
FSTORE:   STORE, RETURN;
*
FFETCH:    FETCH, RETURN;
GOTOZ: GOTO Z;
GOTOM: GOTO M;
GOMPQ: GOTO M+Q;
GOQPZ: GOTO Q+Z;
QQCYZ: Q ← Q LCH Z, DRETURN;
        Q ← Q LCL Z;
NSR1:  NSRFLAG←1, RETURN;
NSR2:  NSRFLAG←2, RETURN;

*
* B2400: HANDLE 2400 BAUD LINE REQUEST
*
* ARGUMENTS: IN HARDWARE INTERFACE
*
*VALUE: NONE
*
*LEVEL: TOP
*
*NMR: 0
*
*SUBROUTINES CALLED: OUTL2, INL2, INLOGIC, GMTL;
*
B2400:         ALERT, Z ← WHYAT2;
       PIN, M ← E2, Q ← MASK(B24D);
       BWORD ← Q ←  M AND Q;
*
*SETUP LDVTE
       Q ← Q LCY 1, Z ← LB24T;
       LDVTE← Z + Q, Q ← MASK(ERB);
       GOTO INER ON M AND Q # 0, Q ← MASK(RRQ);
       GOTO B24I ON M AND Q # 0, Q ← MASK(TRQ);
       GOTO B2403 ON M AND Q # 0;
*IF FALSE REQUEST RETURN
       FETCH F24C;
       M ← M + 1, STORE, GOTO GNR;
INER:    ALERT, Z ← BWORD MRG INRQ;
       PIN, M ← Q ← 71B, Z ← E2;    *IF TRANS. RATE ERROR ONLY
       GOTO TRE24 ON M AND Q - Z AND Q = 0;
*SEND STATUS CHANGE INFORMATION
       BWORD ← Z, CALL GMTL, Z ← 0;
       CALL INLOGIC, M ← FLDCHAR;
       M ← BWORD, Q ← MASK(MSF), DGOTO B24I;
       CALL INLOGIC, M ← STUFF(MSF) MRG 200B;
*OUTPUT CHARACTER
B2403:    CALL GMTL, Z ← 1;
       CALL OUTL2;
       GOTO B24N IF ASET;
       ALERT, Z ← BWORD MRG OUTRQ;
*
       Z ← M MRG MASK(TRCH), POT, GOTO GNR;
*INPUT CHARACTER
B24I:    CALL GMTL, Z ← 0;
       ALERT, Z ← BWORD MRG 200B + INRQ;
       M ← E2, PIN, Q ← MASK(RRE);
       BWORD ← M;
       GOTO B24I1 ON M AND Q =0, Q ← MASK(ICHAR);
       CALL INLOGIC, M ← SUBI;
       FETCH RECC;
       M ← M + 1, STORE;
       M ← BWORD;
B24I1:    BWORD ← STUFF(ICHAR), Q ← MASK(ICR), DGOTO GNR;
       M ← BWORD, CALL INL2 ON M AND Q # 0;
*
*TRANSMITTER RATE ERROR BUMP TRECNT
TRE24:    FETCH TRECNT;
       BWORD ← Z;
       M ← M + 1, STORE, GOTO B24I;
*
*
* ASET: NO OUTPUT = 0  ONLY LEGAL CHARACTER
*
B24N:    GOTO GNR ON M = 0;
       FETCH ILC24;                    *ILLEGAL CONTROL TO 2400 BAUD LINE
       M ← M + 1, STORE, GOTO GNR;

*
* BLAKE: KEEPS TRACK OF FREE BUFFERS
*
* BLAKE IS CALLED AT THE END OF EACH REQUEST THAT MIGHT HAVE USED OR
*RETURNED BUFFERS. IT ENSURES THAT PRB WILL NOT POINT TO A BUFFER AND
*THAT AVB WILL.
* BLAKE WILL WAKEUP BERTHOLD IF:
*       1) NFB< MINFB
*       2) NFB > MAXFB
*
*NOTE: NORMALLY NO REQUEST MAY USE OR FREE MORE THEN ONE
* BUFFER (ONE REQUEST WILL NOT DO BOTH).
* AN EXCEPTION EXISTS FOR LINKED LINE, WHICH MIGHT USE
*TWO BUFFERS IN ONE REQUEST.  THEREFORE THE LOGIC THAT HANDLES LINKING
*MUST CALL BLAKE EVERY TIME IT WRITES A CHARACTER IN A LINKED LINE;
*
* ARGUMENTS:
*       BFLAG: 0, NO ACTION, 4B7: CHECK AVB AND PRB.
* WAKEUP (3 AND 4 ABOVE)
*
*VALUE: NONE
*
*LEVEL: -
*
*SUBROUTINES CALLED: WAKEUP(GOTO)
*
BLAKE:      Z ← MASK(ZLIN)+7B;
       Q ← PRB;
* PRB = 0,NO BUFFER RELEASED; PRB = 1 TO 7 , NULL SOURCE BUFFER 
* WHICH SHOULD NOT BE RELEASED
       GOTO BLAK2 ON Q ← Q AND NOT Z = 0, M ← FREEL;
*RETURN RELEASED BUFFER
       FREEL ← Q;
       Z ← BUF0;
       STORE Q + Z;
       PRB ← 0, FETCH DISP(NFB);
       STORE, M ← M + 1, Z ← MAXFB;
       GOTO BLAK2 ON Z - M > 0, M ← FREEL;
*SIGNAL WAKEUP OF BERTHOLD BY RESETING BFLAG;
       ALERT, BFLAG ← 0, Z←103B, GOTO 1625B;
*NOW SEE IF THER IS AN AVAILABLE BUFFER AND IF THERE IS NOT MAKE ONE 
* AVAILABLE
*M CONTAINS FREEL
BLAK2:    M, Z ← AVB, CALL ABORT IF LB=0;  *IF FREE LIST NULL
       GOTO BLAKA IF Z>=0, Z ← BUF0; *IF AVB<0, BUFFER IN AVB HAS BEEN USED
*MAKE BUFFER AVAILABLE
       AVB ← M;
       FETCH M + Z, Q ← MASK(ZLIN)+7B;
       CALL ABORT ON M AND Q # 0;      *BUFFERS SCREWED UP
       FREEL ← M, FETCH DISP(NFB);
       STORE, M ← M - 1, Z ← MINFB;
       Z ← Z - M, GOTO BLAKA ON BFLAG>=0;
*IF Z>=O TURN OFF 360
* BFLAG = 0 USED A FLAG TO WAKEUP BERTHOLD
       GOTO 1626B, BFLAG ← 0;
*
*WAKEUP BERTHOLD
BLAKA:    DRETURN ON BFLAG < 0;
       BFLAG ← 0, Z ← WKBERT;
       FETCH BRECHT;
       STORE, RETURN ON M = 0, M ← 0;
       FETCH BERTHOLD, GOTO WAKEUP;
*

*
* BSCN: BIT SCAN
*
* BSCN IS CALLED EACH 1/7 OF A BIT TIME TO SCAN THE TTYS
* AND DO ANY INPUT OR OUTPUT THAT MIGHT BE NECESSARY
* BSCN LOOKS FOR THREE DIFFERENT TYPES OF REQUESTS:
*
* 1) NO INPUT IN PROGRESS- IF A ONE BIT COMES IN INITIATE CHARACTER READ
* 2) INPUT BIT MUST BE READ
* 3) OUTPUT BIT TO TTY.
*
*THE TTYS
* ARE STAGGERED SO THAT EACH 1/7 OF A BIT TIME 1/7 OF THE TTYS ARE 
*SERVICED AND THAT TTY IS NOT RESERVICED UNTIL THE NEXT BIT TIME.
*
* ARGUMENTS:
*       M: TIME
*       Z: INTERVAL (SET UP IN BRANCH VECTOR)
*
*VALUE: NONE
*
*SIDE EFFECTS: ALL VARIABLE REGISTERS MAY BY DESTROYED
*
*LEVEL: TOP
*
*SUBROUTINES CALLED: GLBTE,IBF,FLB,DID,DOD (SETBT, AN INTERNAL SUB)
*
*NOT THAT THE SUBROUTINE NUMBER IS THE DEVICE NUMBER
BSCN:    NCI ← M + Z, Q ← MASK(FTOSUB);  *SUB NO IS DEVICE TYPE
       M ← STUFF(FTOSUB), CALL GLBTE;
       STORE;                  *UPDATED BSNO
* DO INPUT
       HFETCH BTIME MRG 1, Q ← -1,  CALL SETBT;
*M HAS BWORD
BSCN6:    GOTO BSCN7 ON M=0;
       CALL FLB;
       Q ← 3777B, CALL DOD, HFETCH LDVTE;
       M ← BWORD, GOTO BSCN6;
* DO OUTPUT
BSCN7:  Q ← -1, FETCH BTIME , CALL SETBT;
*M HAS BWORD
BSCN8:    GOTO BSCN1 ON M =0;
       CALL FLB;
       Q ← 77740000B, CALL DID, HFETCH LDVTE;
       M ← BWORD, GOTO BSCN8;
*SERVICE LEADING BITS ON INACTIVE INPUT TTYS
BSCN1:    FETCH LBTBE MRG DISP(NCIP);
       Z←TINPUT, ALERT;
       PIN, Q ← E2, GOTO 1657B;
RE1:   BWORD ← M ← M AND NOT Q;
*M HAS BWORD
BSCN4:    GOTO GNRFIN ON M =0;
       CALL FLB;
       CALL IBF, HFETCH LDVTE;
       M ← BWORD, GOTO BSCN4;
*
SETBT: BWORD ← M ← M AND Q, RETURN;
*

*
* CKFXP: CLOCK FIXUP
*
* CKFXP IS CALLED WHEN THE OVERFLOW BIT(BIT 18) IS ON FOR ALL THE
* CLOCK DRIVEN FUNCTIONS.
*IT WILL TURN OFF THE BIT IN ALL OF THE CLOCK DRIVEN FUNCTIONS
*(SEE GNR)
*THIS SUBROUTINE MAY BE CALLED TO INITIALIZE THE STACK. IT 
*THIS IS DONE BY STTING THE TIME TO ZERO (THUS THE WHOLE WORD IS ZERO)
* CKFXP WILL THEN SET THE TIME FOR EACH OF THE REGISTERS TO THE CURRENT 
*TIME
*
* ARGUMENTS:
*       R0: -@LCI+@NCI-1 SETUP IN GNR
*
*VALUE: NONE
*
*SIDE EFFECTS: NONE
*
*LEVEL: -
*
CKFXP:    VR ← Z ← @NCI+1;
CKL:   M ← SKZ, Q ← MASK(OVTIM);
       Z ← M AND NOT Q, GOTO GNRFIN ON R0←R0+1 >=0;
       GOTO CKL2 ON M AND Q#0, Q ← MASK(FTOTIM);
       Z ← RDCKL, ALERT;
       PIN, Z ← E2, NCI ← MASK(OVTIM);
CKL2:    M ← M AND NOT Q + Z AND Q, Z ← VR;
       SKZ ← M, Z ← VR ← VR + 1, GOTO CKL;
*

*
* CPUFIN: BRANCHED TO AT END OF CPU REQUEST
*
* ARGUMENTS:
*       M: VALU
*
CPUFIN:    STORE DISP(VALU), Q ← NSRFLAG;
       Q ← Q LCH STCY(NSR);
       Z ← Q LCL STCY(NSR), Q ← MASK(RWCH);
       FETCH DISP(RWCH);
*IF NO REQUEST WAITING SOMETHING VERY STRANGE HAPPENED
       CALL ABORT ON Q AND M = 0;      *RWCH CLOBBERED
       M ← M AND NOT Q, Q ← MASK(NSR), DGOTO GNR;
       M ← M AND NOT Q + Z AND Q, STORE;
*

*
* CPURQ: SERVICE CPU REQUEST
* CPU FUNCTIONS MAY EITHER RETURN OR BRANCH TO CPUFIN
*NOTE: THE LINE NUMBER FOR THE FIELD MUST BE LEGAL EVEN IF NOT USED
*
* ARGUMENTS: CPUIT
*
*VALUE: NONE
*
*LEVEL: TOP
*
*SUBROUTINES CALLED: BRANCHES TO REQUEST SPECIFIC CODE, GLE
*
*
*SIDE EFFECTS: ALL REGISTERS THAT HOLD VARIABLES CLOBBERED
*
CPURQ:    FETCH DISP(LNO), DGOTO RESTART;
       NSRFLAG ← 0, Q ← MASK(CRT), GOTO *+1 IF NFAIL;
       VR ← STUFF(CRT), Q ← MASK(RWCH);
       CALL BDRQ ON M AND Q=0, Q ← MASK(LNO), RESETCPU;
*KNOW GLE DOES NOT DESTROY VR
       M ← LINE ← Q AND M, RESETA, CALL GLE;
*
*MAXIMUM LEGAL LINE NUMBER MUST BE HAND COMPILED IN
*
       Q ← VR, M ← 17B;
       CALL GOQPZ ON M - Q >= 0, Z ← CPUTBL;
*NOTE NEXT INSTRUCTION  MUST BE GOTO CPUFIN
CPUTBL:    GOTO CPUFIN;
       GOTO WST;
       GOTO RCND;
       GOTO RSTB;
       GOTO MBLK;
       CPUFLAG ← -1, GOTO CPUFIN;
       CPUFLAG ← 0, GOTO CPUFIN;
       GOTO PUTFIELD;
       GOTO GETFIELD;
       GOTO GETREG;
       GOTO PUTREG;
       GOTO RTUPC;
       GOTO DOAPOT;
       GOTO DOAPIN;
       FETCH, R0 ← 43B, GOTO TOFF24;   *CARG1 AT LOCATION 43B
*
* INCREMENT MAXIMUM LEGAL LINE NUMBER IF NEW CALLS ADDED
*
       R2←-LSCRATCH, GOTO LOADST;
       GOTO CPUFIN, RESETTU;
       ALL; *SPARE
     CALL ABORT;  *SPARE
BDRQ:    FETCH NULRQC;
       M ← M + 1, STORE, GOTO GNR;
*

*
* CRCH: CLEANUP FOR RCH
*
*THIS MUST BE CALLED AFTER A SERIES OF CALLS TO RCH
*
* ARGUMENTS: NONE
*
*NMR: 1
*
*VALUE:
*       A: AS ON ENTRY
*
*SIDE EFFECTS: NONE
*
*LEVEL: -
*
*SUBROUTINES CALLED: NONE
*
*KNOW: A IS LEFT ALONE
*
CRCH:    M ← RWORD, DRETURN;
        STORE RCP;
*

*
* CWCH: CLEANUP WRITE CHARACTER SUBROUTINE SUBROUTINE
*
* CWCH MUST BE CALLED AFTER A SERIES OF WCHS ARE CALLED.
* A IS SET FOR RSTB AND RCND SO CHAR CAN BE LEFT JUSTIFIED IN CPUIT
*
* ARGUMENTS: A IS SET IF WORD SHOULD BE LEFT JUSTIFIED BEFORE STORE
*      Z: UNRTOUCHED (FOR PWP)
*
*NMR: 1
*
*VALUE:
*      Z: AS ON ENTRY
*
*SIDE EFFECTS: NONE
*
*LEVEL: -
*
*SUBROUTINES CALLED: NONE
*
*KNOW: A IS LEFT AS IS
CWCH:    M ← WWORD, Q ← MASK(LCHAR), DRETURN IF ARESET;
       STORE WCP, RETURN ON M = 0;
       RETURN ON M AND Q # 0;
       M ← M LCY 8, GOTO *-2;

*
*
* DID: DO INPUT DEVICE
*
*THIS SUBROUTINE IS CALLED WHEN AN INPUT BIT TO  TTY IS FOUND
*DID SHIFTS IN THE NEXT BIT AND LOOKS FOR 2 IMPORTANT CASES
*  1) THE CHARACTER WAS AND IS ALL ONES INDICATING A FALSE FIRST BIT WAS FOUND
*  2) THE LEADING BIT OF THE CHARACTER WAS A ZERO INDICATING THE CHARACTER
*  IS NOW CORRECT AND SHOULD BE PLACED IN THE LINE. THIS IS DONE.
*  3) IF THE CHARACTER IS ALL ZEROS (MORE THEN 8 BITS) SEND CBREAK
*
*NOTE THAT THE CHARACTER IS BAS ACKWARDS
*(LOW ORDER BIT FIRST, AND LINE HIGHT MEANS 0.
*
*WHEN THERE IS NO CHARACTER THE BUFFER IS ALL ONES
*
* ARGUMENTS
*       R0: ADDRESS OF CIPT
*       M: WORD CONTAINING CIPT
*       Q: MASK(CIP)
*
*VALUE: NONE
*
*SIDE EFFECTS: CHARACTER IS UPDATED AND PUT IN THE LINE IF COMPLETE
*
*SUBROUTINES CALLED: INLOGIC, GMTL
*
*LEVEL: 4
*
DID:   Q ← NOT M OR NOT Q LCL 23 MRG 10B;
       Z ← NOT Q LCH 23, Q ← MASK(CIPT);
       M ← M AND NOT Q ! Z AND Q, Q ← LBIT;
       Z←TINPUT, ALERT;
       Q ← E2, PIN, GOTO 1663B;
*
RE2:   GOTO DID1 ON Z AND Q=0, Q ← MASK(CIPT), SETA;
       M ← M MRG  4B7;
DID1:    STORE, GOTO DID2 ON NOT M AND Q=0, Q ← 1B5;
       DRETURN ON NOT M AND Q=0, Q ← 40000B, RESETA;
       GOTO 1633B ON M AND Q = 0, Z ← NCI MRG 4B6-1;
*IF TYPE = 2741, CHARACTER HAS BEEN RECEIVED OTHERWISE ONE MORE BIT TIME
       M ← M LCL 23, Q ← M2741T*4B6+4B6-1;
       M ← M LCH 23 MRG 2B7, DGOTO DID2;
       RETURN ON Z-Q#0;
DID3:  Q ← MASK(CIPT), Z ← OS, GOTO SH1;
       GOTO 1622B ON M AND Q=0, Q ← MASK(CIP);  * BREAK FOUND
*STORED WORD HAS CHARACTER IN LEFT 8 BITS
       M ←M AND Q LCL LDCY(CIP);
       CHAR ← M  LCY 8, CALL GMTL, Z ← 0;
       M ← MTCE, CALL 1667B;     * PATCH OF 12/13/75 (WWL)
       FETCH BTIME;
       Q ← LBIT, GOTO RTSS4;
       M ← M AND NOT Q, STORE, CALL DID2;  *GOTO DID2 AND RETURN
DID5:  M ← CHAR  ← CBREAK, CALL INLOGIC;
       GOTO RTSS4;
*FIRST BIT STORED AS A FALSE START; ALSO CLEVERLY CALLED FROM DID1+7
DID2:  VR ← M, Q ← LBIT;
       FETCH BTIME;
       M ← M AND NOT Q, STORE;
       FETCH LBTBE MRG DISP(NCIP), DRETURN;
       M ← M OR Q, STORE, GOTO DID3 IF ARESET;
*

*
*DOAPOT AND DOAPIN
*
*JUST FOR THE CONVIENCE OF RANDOM PEOPLE
*
DOAPOT:        FETCH, R0 ← 43B;    *CARG1 AT LOCATION 43B
       FETCH R0+1, Z ← M;
       Q ← M, ALERT;
       Z ← Q, POT, GOTO CPUFIN;
DOAPIN:  FETCH CARG1;
       Z ← M, ALERT;
       PIN, M ← E2;
       GOTO CPUFIN;
*

*
* DOD: DO OUTPUT DEVICE
*THIS SUBROUTINE IS CALLED TO OUTPUT A BIT TO A LOCAL DEVICE
*
*THIS USES A NINE (2741), TEN (MODEL 37), OR AN ELEVEN (MODEL 35) BIT
*CHARACTER, THE FIRST BIT BEING A 1 AND THE
*LAST  ONE TWO BEING ZEROS. THIS CHARACTER IS FILLED WITH 1 WHEN IT IS
*SHIFTED AND IF THE CHARACTER IS ALL ONES THEN IT
*HAS BEEN OUTPUT AND MUST BE RELOADED.
*THE BITS ARE BAS ACKWARDS
*LEAST SIGNIFICANT BIT FIRST)
*
* ARGUMENTS
*       R0: ADDRESS OF COP
*       M: WORD CONTAINING COP
*       Q: MASK(COP)
*
*VALUE: NONE
*
*SIDE EFFECTS: 1 BIT IS OUTPUT AND A CHARACTER MAY BE FETCHED.
*
*LEVEL: 4
*
*SUBROUTINES CALLED: OUTLOGIC, GMTL, WKOL,DOD;
*
*SHIFT RIGHT 1 AND SHIFT IN A 0 BIT.
DOD:   GOTO DOD2 ON Q ← M AND Q  LCH 23 = 0, Z ← MASK(HCOP);
       Q ← Q LCL 23;
       Z ← Q AND NOT Z, Q ← MASK(COP);
       M ← M AND NOT Q + Z AND Q, STORE, Q ← LBIT;
*4B7 BIT IN Z IS BIT SHIFTED OUT
       Z ← 0, GOTO DOD1 IF Z>=0, M ← OBITS;
       Z ← - 1;
*CHANGE OBITS AND OUTPUT
DOD1:  OBITS ← M ←  M AND NOT Q ! Z AND Q, Z ← TOUTPUT, ALERT;
       Z←M LCY 16, DGOTO 1654B;
       POT;
* NEED A NEW CHARACTER, OUTPUT WORD FILLED WITH ZEROS.
DOD2: Z ← OS;
       CALL GMTL, SVR4 ← Z, Z ← 1;
       CALL  OUTL2;
       GOTO DOD4 IF ASET;     *IF NO CHARACTERS
       VR ← 0;
       VR ← M LCY 1;
DOD9:  Q ← LBTBE;
*VR NOW HAS WORD TO BE OUTPUT WITH START AND STOP BITS FOR MODEL 35
       M ← LBTBA;
       Q ← Q - M;
       Q ← Q LCY 20, Z ← BV3;
*SET UP OUTPUT BUFFER: 2 STOP BITS(0), CHARACTER, 1 START BIT(1).
*THE WHOLE THING IS COMPLEMENTED ON OUTPUT
*DISPATCH ON DEVICE TYPE
       DGOTO Q + Z + 1, M ← VR;
       DGOTO DOD3;
DOD3:  HFETCH LDVTE, Q ← MASK(COP), DGOTO RTSS4;
***    HFETCH LDVTE MRG DISP(COP), Q ← MASK(COP), DGOTO RTSS4;
       M ← M AND NOT Q ! Z AND Q, CALL DOD;
DOD4:  GOTO DOD9 ON M # 0, VR ← MASK(COP);  * IF SNULL OUTPUT ALL 1S
*0 MEANS NOT OUTPUT TURN OFF LINE,  (ALL OTHER CONT CH. AS SNULL)
       CALL WKOL, Z ← 0;       *TURN OFF LINE, NO MORE CHARACTERS FOR IT
       GOTO RTSS4;
*M HAS CHARACTER SHIFTED LEFT ONE
BV3:   CALL ABORT;             *OUTPUT TO DEVICE 0 (DOD)
       Z ← M MRG MASK(COP37); *MODEL 37
       Z ← M MRG MASK(COP35); *MODEL 35
       Z ← M MRG MASK(COP41); *IBM 2741
*
*NOTE THAT SNULL IS WRONG

*
*ECHO:  ECHO CHARACTER TO OUTPUT LINE ALSO
*
*THE NAME ECHO IS SOMEWHAT OF A MISNOMER. ECHO IS CALLED BY
* A SUBROUTINE THAT HAS REASON TO BELIEVE
*THAT THE CHARACTER IN CHAR SHOULD BE OUTPUT TO SOME LINE OTHER
*THE OBVIOUS ONE, EITHER AS AN ECHOED CHARACTER OR AS A LINKED
* CHARACTER (OR BOTH).
*ECHO WILL SEND CHARACTERS TO THE APPROPRIATE LINES,
*IT IS A LITTLE TRICKY BECAUSE IT MUST SAVE AND RESTORE
*THE STATE OF THE LINE BEING WRITTEN
*ECHO SAVES AND RESTORES WCNT, WWORD, WCP AND BFLAG
*
*
*
*ECHO SHOULD:
*     1) ECHO TO THE OUTPUT LINE IF THE LINE IS AN INPUT LINE
*      2) LINK TO AN OUTPUT LINE
*
*  ARGUMENTS:
*      CHAR: CHARACTER TO BE ECHOED
*
*  VALUE: NONE
*
*  LEVEL:   2
*
*SUBROUNTINES CALLED:  WCH1,GLE
*
ECHO:  M ← LINE;
       XLINK ← M, Z←OS, GOTO SH2;
*
*PUSH DOWN WWORD, WCNT, WCP, BFLAG
       M ← WWORD;
       SWORD ← M, M ← WCNT;
       SWCNT ← M, M ← WCP;
       SWCP ← M;
       M ← BFLAG;
       SBFLAG ← M;
       CALL BLAKE ON BFLAG<0;
        M←WD1, Q←MASK(ES);
       GOTO ECHO2 ON M AND Q =0;
       GOTO ECHO2 IF ODD, Q ← LINE;
*ECHO CHARACTER
       SETA,  CALL GLE, M←LINE MRG 1;
*
*THE FOLLOWING CODE IS A HORRIBLE KLUGE WHICH HANDELS THE PROBLEM OF
*ECHOING (OR NOT ECHOING OF CHISC IS 4B7) SHIFT1 CONTROL CHARACTER
*IF LCWS1 = 1 THEN A SHIFT1 IS ECHOED BEFORE CHAR, ALSO LCWS1 IS
*KLUGILY USED AS STORAGE FOR THE CHARACTER
       GOTO ECHO2 ON M ← LCWS1<0;
       GOTO OKTE ON M = 0, M ← CHAR;
       LCWS1 ← M;
       CHAR ← SHIFT1;
       CALL WCH1 ON CHISC >=0;
       M ← LCWS1;
       CHAR ← M;
       ALL;    *NOP
OKTE:   CALL WCH1 ON CHISC >=0;        *DONT ECHO CONTROL CHARS
       CALL BLAKE ON BFLAG<0;
       CALL WKOL ON CHISC >= 0, Z ← -1;   *WAKEUP OUTPUT LINE
*NOW OUTPUT TO LINKED LINE IF LNKBIT IS ON
ECHO2:     M←WD1, Q←MASK(LNKBIT);
        GOTO ECHOR ON M AND Q=0, Q ← MASK(LQNK);
*YES LINK, GET THE LINE NUMBER
        HFETCH MTAE MRG DISP(LQNK);
        M←STUFF(LQNK), RESETA, CALL GLE;
       GOTO ECHOR ON M ← LCWS1<0;
       GOTO OKTR ON M = 0, M ← CHAR;
       LCWS1 ← M;
       CHAR ← SHIFT1;
       CALL WCH1 ON CHISC >=0;
       M ← LCWS1;
       CHAR ← M;
       LCWS1 ← 0;
OKTR:  CALL WCH1 ON CHISC >=0;
       CALL WKOL ON CHISC >=0, Z←-1;
*
ECHOR:     M ← XLINK, RESETA, CALL GLE;
*POP WCNT, WCP, WWORD, BFLAG
       WCNT ← SWCNT;
       WCP ← SWCP;
       M ← SWORD;
       WWORD ← M, CALL BLAKE;
       M ← SBFLAG;
        GOTO RTSS2, BFLAG ← M;
*

*
*FLB: FIND LEADING BIT
*
*LEADING BIT FOUND AND LBIT IS SET TO A MASK WITH THE LEAD BIT ONLY ON.
*
* ARGUMENTS:
*       M: BITS (AT LEAST ONE BIT MUST BE ON)
*
*VALUE:
*
*SIDE EFFECTS:
*      LBIT: WORD WITH A BIT SET FOR INPUT TTY
*      BWORD: OLD BWORD AND NOT LBIT
*      LLINE: LOCAL LINE NUMBER SETUP
*      LDVTE: SETUP
*
*LEVEL: -
*
*SUBROUTINES CALLED: NONE
*
FLB:   R0←-1, Q  ← 17B;
*FIND FIRST GROUP OF 4 BITS THAT HAS A BIT SET
CYP:   Q ← Q LCY 20, R0 ← R0 + 1;
CYQ:   GOTO CYP ON M AND Q = 0;
       Z ← Q LCY 3;
***    LBIT ← Q ← Q AND Z, Z ← R0, R0 ← 0;
       LBIT ← Q ← Q AND Z, Z ← R0, .LR0;
*FIND BIT OF THE GROUP THAT IS SET
CYR:   GOTO FIB3 ON M AND Q # 0;
       DGOTO CYR, Q ← Q LCL 23;
       LBIT ← Q ← Q LCH 23, R0 ← R0 + 1;
FIB3:  BWORD ← M AND NOT Q;
       M ← Z, Z ← R0;
       M ← M LCY 2;
       LLINE ← M ← M + Z;
       Q ← M LCY 1, Z ← LDVTA, DRETURN;
       HFETCH LDVTE ← Q + Z, CALL BLAKE;
*

*
*GAB: GET A BUFFER
*
*GAB IS CALLED TO GET A NEW BUFFER FOR WRITE CHARACTER. IT WILL ALWAYS 
*SUCCEED (OR ABORT.
*
* ARGUMENTS:
*       WCP IS SETUP
*
*VALUE: NONE
*
*LEVEL: 0
*
*SUBROUTINES CALLED: NONE
*
GAB:   CALL ABORT ON M←AVB<0, Q ← 8;      *BUFFERS SCREWED UP
       Z ← WCP, AVB ← -1;
       R0 ← Z - Q, Q ← BUF0;
***    WCP←M + Q + 1 MRG STFLAG;
       WCP←M + Q MRG STFLAG+1;
       VR ← M + Q, Q ← LINE;
       Z ← Q LCY 16, Q ← MASK(ZLIN);
       M ← M AND NOT Q + Z AND Q, STORE;
       BFLAG ← 4B7, DRETURN;
       M ← Z AND Q, STORE VR;
*

*
*GETFIELD: LOAD FIELD FROM LINE TABLE
*
*THIS WILL GET A FIELD FROM EITHER OF THELINE TABLES
*
* ARGUMENTS:
*       CARG1: FIELD DISCRIPTOR
*VALUE: FIELD
*
*SUBROUTINES CALLED GFD
*
*LEVEL: TOP
*
GETFIELD:  CALL GFD;
       M ← M AND Q LCH Z, DGOTO CPUFIN;
       M ← M LCL Z;
*

*
*GETREG: STORE REGISTER
*
* ARGUMENTS:
*       CARG1: SAME AS FOR LDRG
*
*VALUE(IN CPUIT): REGISTERS VAALUE
*
*LEVEL: -
*
*SIDE EFFECTS: NONE
*
*SUBROUTINES CALLED: NONE
*
GETREG: FETCH DISP(CARG1);
       Z ← M;
       M ← SKZ, GOTO CPUFIN;

*GFD: GET FIELD DESCRIPTOR
*
*GFD WILL FETCH FROM CARG1 A FIELD DESCRIPTOR AND HAVE SEVERAL
*INTERESTING QUANTITIES SET UP ON RETURN
*
* ARGUMENTS: CARG1: FIELD DESCRIPTOR
*
*VALUE:
*       M: CONTENTS OF WORD POINTED TO BY FIELD DESCRIPTOR
*       R0: LOCATION POINTED TO BY FIELD DISCRIPTOR (IN LINE TABLE)
*       Q: MASK FOR THE FIELD
*       Z: CYCLE SET UP FOR 'STUFF'
*
*LEVEL: -
*
*NMR: 1
*
*SUBROUTINES CALLED: NONE
*
GFD:   Z←OS,  Q ← MASK(CXBIT), GOTO SH3;
       FETCH DISP(CARG1), Z ← MTAE;
       GOTO GFD1 ON M AND Q = 0, Q ← MASK(SFDDISP);
       Z ← MTCE;
GFD1:  R0 ← M AND Q  + Z, Q ← MASK(FDSZ);
       Z ← STUFF(FDSZ), Q ← 1, CALL QQCYZ;
       GOTO GFD2 ON VR ← Q - 1#0, Q ← MASK(FDFB);
       VR ← -1;
GFD2:  Q ← M AND Q LCL LDCY(FDFB);
       Q ← Q LCH LDCY(FDFB);
       Z ←  Z+Q, M ← 24;
       Z ← M - Z, Q ← VR, CALL QQCYZ;
       FETCH, Z ← M - Z, GOTO RTSS1;
*

*
*GLBTE: GET LOCAL BIT TABLE ENTRY
*
*GLBTE SETS UP LBTBE AND BTIME AND LEAVES BSNO INCREMENTED IN M
*
* ARGUMENTS:
*       M: DEVICE TYPE
*
*VALUE: M: BIT SLICE NUMBER(0-6)
*      R0: LOCATION WHERE UPDATED BSNO SHOULD BE STORED
*
*SIDE EFFECTS: LBTBE AND BTIME SETUP
*
*LEVEL: -
*
*NMR: 1
*
*SUBROUTINES CALLED: NONE
*
*KNOW DOES NOT GRONK VR
*
GLBTE: M ← M - 1;
       Q ← M LCY 4, Z ← LBTBA;
***    Z ← LBTBE ← Q + Z, FETCH Q + Z + DISP(BSNO);
       Z ← LBTBE ← Q + Z, FETCH DISP(BSNO), .TXW;
       GOTO GLB1 ON Q ← M ← M - 1 >= 0;
       Q ← M ← 6;
GLB1:  BTIME ← M + Q OR Z, RETURN;     *LBTBE + 2* BSNO
*

*
*GLE: GENERATE LINE ENTRY
*
* ARGUMENTS:
*       M: LINE
*       A: SET IF ABCPU SHOULD BE CALLED IF BAD REQUEST
*
*VALUE: NONE
*
*LEVEL: -
*
*SUBROUTINES CALLED: NONE
*
*SIDE EFFECTS: MTCE, MTAE, WD1, AND WD2 ARE SETUP
*
*NMR: 2
*
*NOTE THAT VR IS NOT DESTROYED
*
GLE:   Q ← LINE ← M, M ← 1+4B7;
       Z ← XLINE;
       GOTO BADGL ON Z - Q<0;          *ILLEGAL LINE NUMBER
       Z ← Q AND NOT M LCY 1, M ← MTAA;
       HFETCH MTAE ← M + Z;
       Z ← Q LCY 1;
       Z ← Q + Z, Q ← MTCA;
       WD1 ← M, FETCH R0+1;
       MTCE ← Z + Q, DRETURN;
       WD2 ← M;
BADGL:    CALL ABORT IF ARESET;
       CALL ABCPU;
*

*
*GMTL: GET MAIN TABLE LINE NUMBER
*
*GMTL WILL SET UP LINE AS EITHER AN INPUT OR OUTPUT LINE
*KNOWING THE LOCAL LINE IS SET UP
*
* ARGUMENTS:
*       Z: 0 IF INPUTLINE, 1 IF OUTPUT LINE
*       ASSUMES LDVTE SETUP
*
*VALUE: NONE
*
*LEVEL: 0
*
*NMR: 1
*
*SUBROUTINES CALLED: GLE
*
GMTL:  Q←1, FETCH LDVTE MRG DISP(CLINE);
*THE GOTO PART OF THIS NEXT INSTRUCTION IS FOR LATER USE (ADVISING?)
*REFER TO PAGE 61 OF CHIO LOG.  FOR NOW BITS 4 AND 8 ARE CUT TO KEEP
*THE GOTO FROM HAPPENING AND TO KEEP THE ROMPARITY OK
       GOTO 1641B ON VR ← Q AND Z = 0, Q ← 7777B;
       M ← STUFF(CLINE), M ← VR, GOTO GLE;

*
*GNR: GET NEXT REQUEST
*
*GNR FINDS THE HIGHEST PRIORITY REQUEST AND SERVICES IT
*IT WILL DO ONE OF THE FOLLOWING:
*      1) GOTO CPURQ TO SERVICE A CPU REQUEST
*      2) GOTO B2400 TO SERVICE A 2400 BAUD LINE REQUEST
*      3) DISPATCH ON A SUBROUTINE IN TIMTBL TO PERFORM A PERIODIC FUNCTION
*
*IF IT DISPATCHES ON A FUNCTION THROUGH 
*TIMTBL THE FUNCTION MAY EITHER RETURN OR GOTO GNRFIN;
*
* ARGUMENTS: NONE
*
*VALUE: NONE
*
*SIDE EFFECTS: ALL
*
*LEVEL: TOP
*
*SUBROUTINES CALLED: CPUREQ, CLOCK SUBROUTINES.
*
ONYCPU:   DGOTO CPURQ;
       GOTO GNR IF NOREQ;
* BLAKE WILL ENSURE THAT FREE BUFFERS ARE SET UP OK
GNR:   CALL BLAKE ON BFLAG < 0, TOCPU;
*IF CPUFLAG IS ON (NEGATIVE) ONLY SERVICE CPU REQUESTS
       GOTO ONYCPU ON CPUFLAG < 0, Q ← 76B6;   *SFTIM
       Z ← RDCKL, ALERT, M ← NCI;
       PIN, Z ← E2;
       M ← Z AND NOT Q - M AND NOT Q, Q ← 1B6;    *STM
       GOTO SCI ON BL ← M = 0;
       GOTO 1602B;
       DGOTO CPURQ;
       GOTO *+1 IF NOREQ;
       CALL GOCTP;
       GOTO GNR, SETBAS;
SCI:   M ← NCI, Q ← MASK(FTOSUB), DGOTO GNRFIN;
       Q ← STUFF(FTOSUB), Z ← TIMTBL, CALL GOQPZ;
*NOTE CKFXP SUBROUTINE NUMBER IS ZERO, AND THE SUBROUTINE NUMBER FOR 
*THE BIT SCANNING SUBROUTINES IS THE SUBROUTINE NUMBER
TIMTBL:   GOTO CKFXP, R0 ← -@LCI+@NCI-1;
       ORG TIMTBL+M37T;
       GOTO BSCN, Z ← 60B;     *FOR 30 CHARS/SEC
       ORG TIMTBL+M35T;
       GOTO BSCN, Z ← N35I;
       ORG TIMTBL+M2741T;
       GOTO BSCN, Z ← N2741;
       ORG TIMTBL+4;
*SUBROUTINE SUBNUL IS SUBROUTINE NUMBER 4 IT DOES NOTHING
       NCI ← M + 1 MRG MASK(FTOTIM), GOTO GNRFIN;
       GOTO GPRUPDATE, Z ← XLINE;
       GOTO RTUPDATE, Q ← UPAM;
       ALL;    *SPARE
       CALL ABORT;            *SPARE

*
*GNRFIN: CONTROL GOES HERE FROM ANY OF THE CLOCK DRIVEN FUNCTIONS
*
*GNRFIN MUST SORT THE CLOCK QUEUE AND GO TO MAIN LOOP
*
* ARGUMENTS: NCI: TIME THE FUNCTION SPECIFIED BY NCI WANTS TO BE CALLED
*
*VALUE: NONE
*
*SIDE EFFECTS: NONE
*
*LEVEL: TOP
*
*SUBROUTINES CALLED: NONE
*
***   Z ← VR ← @NCI, M ← NCI;
GNRFIN:    Z ← VR ← 32, M ← NCI;
***    R0 ← @NCI-@LCI;
       R0 ← -5;
*VR AND Z HAVE NUMBER OF LOWER NUMBERED SCRATCH PAD REG, M HAS ITS CONTENTS
SCIL:  Z ← Z + 1, Q ← NMASK(FTOTIM);
       M ← SKZ, Z ← M;
       DGOTO GNRR ON M AND NOT Q - Z AND NOT Q>=0;
       VR ← Q ← Z, Z ← VR;
*Z HAS LOWER NUMBER REGISTER SCRATCH PAD ADDRESS, VR HAS OLD CONTENTS
*OF SCRATCH PAD Z.
*PUT CONTENTS OF SCRATCH PAD Z+1 IN SCRATCH PAD Z, AND PRETEND
*TO PUT CONTENTS OF SCRATCH PAD Z INTO SCRATCH PAD Z+1.
       SKZ ← M, DGOTO SCIL ON R0←R0+1<0;
       M ← VR, VR ← Z ← Z + 1;
*PUT CONTENTS OF SCRATCH PAD Z IN SCRATCH PAD Z+1(WHICH WE ONLY 
*PRETENDED TO DO).
GNRR:  SKZ ← Q, GOTO GNR;
*

*
*GPR: GUARANTEED POOR RESPONSE
*
*WHEN GNR HAS NOTHING ELSE TO DO
*GPR IS CALLED TO DECREMENT THE 
* AWT COUNT IN THE LINE TABLE AND IT IT IS ZERO WAKEUP THE OUTPUT DEVICE.
*GPR WILL FIND ITSELF IN ONE OF THREE STATES:
*
*       1) NORMAL: DECREMENT AWT COUNT(IF NOT 0) ON ONE LINE
*       2) FINISHED: LAST LINE SERVICED WAS LAST LINE, SET NEXT MIN TIME;
*       3) WAIT: WAIT UNTIL PNEXT IS EQUAL TO THE CURRENT TIME BEFORE 
*           GOING TO STATE 1
*
* ARGUMENTS: M: CURRENT TIME
*
*VALUE: 0 WAS IN STATE ONE
*
*SIDE EFFECTS:  NONE
*
*LEVEL: -
*
*SUBROUTINES CALLED: WKOL
*
GPR:   Z ← Q ← PLINE, GOTO GPR1 IF ODD, SETA;
       M ← XLINE, Q ← Q LCY 1;
       GOTO GPREND ON Z - M>0, M ← MTAA, RESETA;
       FETCH M + Q MRG DISP(AWT);
GPR1:  PLINE ← Z + 1, Q ← MASK(AWT), RETURN IF ASET;
       RETURN ON M AND Q=0, Q ← ONE(AWT), SETA;
       GOTO 1604B, M ← M - Q, STORE, Z ← -1;
*NOTHING TO DO SO BUMP IDLE COUNT IF A RESET
GPREND:     R0 ← IDLCNT, RETURN IF ASET;
       M ← M + 1,  RETURN;
*

*
*GPRUPDATE: CALLED EACH 1/2 SECOND TO REINITIALIZE PLINE
*
* ARGUMENTS:
*       Z: XLINE (SET UP BY GNR)
*       M: TIME OF INTERRUPT
*
*VALUE: NONE
*
*LEVEL: -
*SUBROUTINES CALLED: NONE
*
GPRUPDATE:    Z ← PLINE, Q ← SEC1H;
       PLINE ← 0;
       NCI ← M + Q;
       GOTO GNRFIN ON Z = 0, FETCH PROB;
       M ← M + 1, STORE, GOTO GNRFIN;
*

*
*GRP: GET READ POINTER
*
*GRP FINDS MCTA MOD 2 =1 DESIRABLE
*
* ARGUMENTS: NONE
*
*IMPLICIT: ASSUMES THAT GLE HAS BEEN CALLED
*
*VALUE: NONE
*
*SIDE EFFECTS: RWORD, RCP, RTCE1, RCPEND, RCNT AND RBUF ARE SET UP. PRP WORRYS ABOUT CCNT
*
*LEVEL: -
*
*SUBROUTINES CALLED: IRCH
*
*NMR: 2
*
***    HFETCH MTCE+DISP(RCPF);
GRP:   HFETCH MTCE, Q ←  NMASK(RCPF);
       RTCE1 ← M AND Q, R0 ← R0 + 1;
*KNOW RTCE1 HAS RCP PART =0
       GOTO GRP2 ON M AND NOT Q=0, Z ← BUF0;
       VR ← M AND NOT Q + Z, FETCH;
       Q ← M AND NOT Q + Z, Z ← LNKB, DGOTO IRCH;
       M ← VR;
*NO CHARACTERS IN LINE READ FROM A NULL CHARACTER SOURCE
GRP2:  M ← Q ←  BUF0 MRG ZRB, DGOTO IRCH;  
       Z ← ABORT;                      *LINK FOR NULL CHARACTER SOURCE
*

*
*GWP: GET WRITE POINTER
*
*THIS SUBROUTINE SETS UP AN INPUT LINE SO THAT WCH WHEN CALLED WILL
*STORE CHARACTERS INTO THAT LINE
*
* ARGUMENTS: NONE
* IMPLICIT: ASSUMES THAT GLE HAS BEEN CALLED
*
*VALUE: NONE
*
*SIDE EFFECTS: WWORD, WCP, WTCE2, , AND WBUF ARE SET UP.  PWP WORRIES ABOUT CCNT
*
*
*SUBROUTINES CALLED: IWCH
*
*KNOW ABCNT, IBCNT AND WCP ARE SINGLE CYCLE FIELDS AND WCP AND ABCNT ARE
* ALL OF ONE WORD.
*LEVEL: -
*
*NMR: 1(MAX 5)
*
GWP:   Z ← MTCE, Q ← NMASK(WCPF);
       FETCH Z + DISP(WCPF), Z ← BUF0;
*KNOW WCTE2 HAS ABCNT ON LEFT, AND 0 ON RIGHT
       WTCE2 ← M AND Q, DGOTO IWCH;
       Q ← M AND NOT Q + Z, Z ← GAB, GOTO * + 1 IF LB=0;
*NO CHARACTERS IN LINE, GET BUFFER , AND SET READ POINTER
GWPZ: CALL ABORT ON Z ← AVB < 0;    *NO BUFFER AVAILABLE (GWP)
       M ← LINE;
       AVB ← -1, Q ← 377B;
       M ← M AND Q LCY 16, Q ← BUF0 MRG STFLAG;
       STORE VR ← Z +Q, Q ← MTCE;
       FETCH Q + DISP(RCPF), Q ← NMASK(RCPF);
       BFLAG←4B7;
*STORE READ POINTER
       M ← M AND Q + Z AND NOT Q + 1, Z ← GAB, STORE, DGOTO IWCH;
*STORE ZERO IN FIRST WORD OF BUFFER (ZEROTH WORD IS LINK)
       M ← 0, STORE Q ← VR+1;
*

       END;
*

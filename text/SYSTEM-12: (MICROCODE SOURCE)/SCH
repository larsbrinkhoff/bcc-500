* INITIALIZATION AND STATE-SAVING

* LOCATION COUNTER IS 0

START: GOTO SAVEST IF BRKON, SSMREG←M, M←MAR, CLFAIL;
* NO BREAK. READ SCR
       Z←SCRADR, ALERT, GOTO *+1 IF AT2OFF;
       M←READ, GOTO *+1 IF AT1OFF;
       UNPROTECT, Q←SELFILLBIT;
       Z←M AND Q, GOTO XSELFFILL IF LB#0, Q←COMPUTEBIT, CLSTROBE;
       M AND Q, GOTO IRESET IF LB#0, Q←CONTINUEBIT;
* WE ARE NOT DOING ITP INITIALIZATION.  TURN COMPUTE MODE OFF
* AND SCHEDULE MODE ON. CLEAR STROBE
       MODE←ONSCHEDULE, CLSTROBE;
       M AND Q, GOTO WAITGO IF LB=0, MAR←SCRMEM, FETCH;
* CONTINUE SET IN SCR. LOOK AT SCRMEM. IF CONTINUE SET THERE,
* ACCEPT IT AS PROPER SWITCH INFO
       M AND Q, GOTO GOTSCR IF LB#0;
* MUST WAIT FOR GO, THEN READ SWITCHES INTO SCRMEM
WAITGO: Z←SCRADR, ALERT;
       GOTO WAITGO ON M←E2>=0, PIN, .VCY, .TAX;

       MAR←SCRMEM, STORE;
* M AND SCRMEM NOW BOTH CONTAIN THE VALUE OF SCR TO BE USED FOR RESTART
* SEND STROBES TO CHIO AND AMC
* IF THE UTP'S PART IN SYSTEM INITIALIZATION IS ELABORATED, THE
* NEW STUFF GOES HERE
GOTSCR: SK0←CHIOSTROBE+SWAPSTROBE, STROBE;
* WAIT FOR STROBE SIGNAL, THEN LOAD STATE AS IF RETURNING FROM BREAK
       GOTO * IF NOSTROBE;
       Z←0, R2←-LSCRATCH, GOTO LOADST, STORE;

* BREAK. DUMP STATE IN THE SAVE AREA.  THE STRATEGY IS AS FOLLOWS
* 1) SAVE M IN SSMREG IN THE SCRATCHPAD
* 2) STORE MAR AT SAVER0. STORE OS AT SAVEOS
* 3) STORE Z,Q AT SAVEZ,Q AND R1-R6 AT SAVER1 TO SAVER6
* 4) EXCHANGE SCRATCHPAD AND SAVE TO SAVE+LSCRATCH-1

* AFTER SAVING THE STATE, BREAK WAITS UNTILL BRKWAIT
* BECOMES NON-ZERO.

* THE RELOAD STRATEGY IS OBTAINED BY DOING STEPS 4-3 IN REVERSE,
* AND THEN
* 2) FETCH SAVEOS AND DGOTO IT
* 1) DGOTO *+1 (THIS SETS UP OS), FETCH BREAK
* 0) DGOTO M (THIS SETS UP O), FETCH SAVER0
* -1) MAR←M, M←SSMREG

       MACRO IMS←MAR←Z←Z+1, STORE;
SAVEST: MAR←SAVER0, STORE;
       M←Z, MAR←SAVEZ, STORE;
       M←R1, MAR←Z←SAVER1, STORE;
       M←R2, IMS;
       M←R3, IMS;
       M←R4, IMS;
       M←R5, IMS;
       M←R6, IMS;
       M←OS, IMS;
       M←Q, MAR←Z←MAR+1, STORE;
       MAR←SAVE-1;
       R2←-LSCRATCH, Z←0, CALL XSCRATCH;
BWAIT: MAR←BRKWAIT, FETCH;
       GOTO *-1 ON M=0, R2←-LSCRATCH;
LOADST: MAR←SAVE-1, Z←0, CALL XSCRATCH;
       MAR←SAVER1, FETCH;
       R1←M, CALL FN;
       R2←M, CALL FN;
       R3←M, CALL FN;
       R4←M, CALL FN;
       R5←M, CALL FN;
       R6←M, CALL FN;
       DGOTO M, MAR←MAR+1, FETCH;
       Q←M, MAR←MAR+1, FETCH, CALL *+1;
       Z←M, MAR←BREAK, FETCH;
       DGOTO M, MAR←SAVER0, FETCH, .VCY;
       MAR←M, M←SSMREG;

* SUBROUTINE TO BUMP MAR AND FETCH
FN:    MAR←MAR+1, FETCH, RETURN;

* SUBROUTINE TO EXCHANGE -(R2) SCRATCHPAD LOCATIONS, STARTING AT (Z),
* WITH CORE LOCATIONS STARTING AT (MAR)+1. CLOBBERS M,Z,R1,R2
XSCRATCH: FETCH, MAR←MAR+1;
       R1←SKZ;
       SKZ←M, M←R1, DGOTO XSCRATCH;
       STORE, Z←Z+1, RETURN ON R2←R2+1>=0;



* ROUTINES TO LOAD AND STORE. THESE ALLOW A CONSTANT FIELD
* TO BE USED IN AN INSTRUCTION WHICH WANTS TO LOAD OR STORE, AT
* THE EXPENSE OF 300 NS, IF THE INSTRUCTION DOES NOT ALSO HAVE
* HAVE A BRANCH ADDRESS
* CALL WITH CALL, DO NOT USE STACK. LEAVE REGISTERS UNTOUCHED

MFETCH: FETCH, RETURN;
MSTORE: STORE, RETURN;
*
* SUBROUTINE CALLING CONVENTIONS
* STKP CONTAINS THE STACK POINTER.  THE ROUTINE STKLK PUSHES
* OS ONTO THE STACK AND SENDS CONTROL TO (SUBR). THUS A SUBROUTINE
* S CAN BE CALLED IN TWO WAYS
*      SUBR←S, CALL STKLK
* WHICH USES ABOUT HALF OF THE CALLING INSTRUCTION, OR ALTERNATIVELY
*      CALL S
* WHERE
* S:   SUBR←S+1, GOTO STKLK
* WHICH COSES A WORD IN THE SUBROUTINE AND TWO EXTRA CYCLES.  THE
* TWO SCHEMES ARE INCOMPATIBLE IN THE SENSE THAT A ROUTINE
* WHICH CAN BE CALLED BY METHOD 2 MUST BE ENTERED ONE LOCATION EARLIER
* BY METHOD 1
* THE CALL WIPES SUBR AND SCRATCHPAD LOCATION CALLT1 (WHICH ARE
* THEREFORE NEVER GIVEN ALTERNATE NAMES) BUT PRESERVES MQZ

       MACRO ENTRY←SUBR←*+1, GOTO STKLK;
       MACRO QENTRY←Q←*+1, GOTO QSTKLK;
       MACRO C←SUBR←*1*, CALL STKLK;
* GOING TO RET POPS THE STACK AND RETURNS, CLOBBERING ONLY SUBR.
* GOING TO RETXZ AFTER Z←STKP+1 IS THE SAME BUT ALSO CLOBBERS Z.
* IT IS ONE CYCLE SHORTER
       MACRO R←GOTO RET;
       MACRO DR←DGOTO RET;
       MACRO RXZ←Z←STKP+1, GOTO RETXZ;

QSTKLK: SUBR←Q;
STKLK: Z←STKP, CALLT1←Z;
STKL1: STKP←Q, Q←OS;
       SKZ←Q, Q←SUBR;
       DGOTO Q, Q←STKP;
       STKP←Z-1, Z←CALLT1;

RET:   SUBR←Z, Z←STKP+1;
RETXZ: Z←SKZ, STKP←Z;
       GOTO Z, Z←SUBR;

*
* QUEUE CONVENTIONS
* MOST QUEUES HAVE TWO-WORD HEADERS, THE FIRST WORD POINTING
* TO THE FIRST ENTRY ON THE QUEUE AND THE SECOND TO THE LAST. A QUEUE
* POINTER IS 18 BITS AND IS ALWAYS RIGHT-JUSITFIED IN A MEMORY WORD.
* THE TOP 6 BITS OF SUCH A WORD ARE PRESERVED.  THESE BITS ARE ALWAYS
* 0 FOR A QUEUE POINTER IN A HEADER OR IN THE UPROCESSOR.
* 777777 IS USED FOR THE NULL POINTER.  A POINTER IS ALWAYS TO
* THE FIRST WORD OF THE ITEM BEING REFERENCED.  THE NEXT POINTER
* IS USUALLY NOT IN THAT WORD, BUT OFFSET BY AN AMOUNT WHICH 
* QUEUE-HANDLING ROUTINES EXPECT TO FIND IN OFFSET.
* THE QUEUES WHICH HAVE THE ABOVE FORM ARE: USQ'S, WAKEUPQ,
*      SWFREL, SWAPIQ, SWAPRQ
* ONES WHICH DO NOT ARE: RTQ

* GET NEXT ENTRY FROM QUEUE ADDRESSED BY M.  LEAVE ITS ADDRESS
* IN Z AND REMOVE IT FROM THE QUEUE.  LEAVE A NULL POINTER IN Z IF
* THE QUEUE IS EMPTY.
* CALL WITH CALL, USES STACK, WIPES MQZ, MAR, SPT1
GETNEXT: SPT1←MAR←M, QENTRY, FETCH;
       Q←ADMREG;
       Z←M AND Q, R IF NULLPTR, Q←OFFSET;
       MAR←M+Q, FETCH, Q←ADMREG;
       M←M AND Q, R IF NNPTR, Q←MAR←SPT1, STORE;
* QUEUE HAS BECOME NULL. FIX UP SECOND WORD OF HEADER.
       M←OFFSET, DR;
       M←Q-M, MAR←MAR+1, STORE;

* PUT NODE IN Z ON END OF QUEUE IN MAR
* CALL WITH CALL, USES STACK, WIPES MQ, MAR, SPT1,2
* LEAVES Z UNTOUCHED THROUGHOUT.
* LEAVES OLD FIRST WORD OF QUEUE HEADER IN SPT2, Q
APPEND: QENTRY, FETCH;   *FETCH 1ST WORD OF HEADER
       SPT2←M, MAR←MAR+1, FETCH;
* FETCH 2ND WORD OF HEADER
       Q←OFFSET, SPT1←Z;
       Q←Q+M, M←SPT1, STORE;
*  STORE PTR TO MODE INTO 2ND WORD OF HEADER
       MAR←Q, FETCH, Q←ADMREG;
*   FETCH PTR WORD FROM LOD LAST NODE
       M←M AND NOT Q ! Z AND Q, STORE, Q←OFFSET;
*  STORE INTO PTR WORD OF OLD LAST NODE--1ST 6
*  BITS ARE WHAT WE JUST FETCHED, BITS 6-23 ARE ADDRESS OF
*  NEW LAST NODE
       MAR←Q+Z, FETCH, Q←ADMREG, DR;
*  FETCH PRT WORD FROM NEW LAST NODE
       M←M OR Q, STORE, Q←SPT2;
*  STORE INTO PTR WORD OF NEW LAST NODE WHAT WE JUST FETCHED
*  WITH ADMREG (777777) MERGED IN.
*
* ROUTINES TO FETCH PARTICULAR WORDS FROM A PROCESS WITH PRT ADDRESS
* IN M.  THE WORD IS LEFT IN M, ITS ADDRESS IN MAR AND SUBR
* CALL WITH CALL, DOES NOT USE STACK, WIPES M, MAR, SUBR

GETPIW: SUBR←Q, Q←PRPIW;

* GET M+Q
GETMPQ: MAR←SUBR←M+Q, FETCH, Q←SUBR, RETURN;

GETST: SUBR←Q, Q←PRST, GOTO GETMPQ;

* THIS ONE ZEROS THE TOP 6 BITS OF M FIRST
GETRTP: SUBR←Q, Q←ADMASK, DGOTO GETMPQ;
       M←M AND NOT Q, Q←PRRTP;
*
* MAIN LOOP
MAIN:  STKP←TOPSTACK, GOTO NOUSWORK IF NOSTROBE, M←MODE, CLSTROBE;
       GOTO NOUSWORK ON M LCY 2>=0;
GOMAIN: TEMP2←OLDRT;
* FETCH CLOCK AND CHECK FOR CHANGE
* TEMP2 CONTAINS THE INITIAL VALUE OF OLDRT THROUGHOUT
* EXCEPT DURING THE CALL OF WAKEUP, WHEN IT IS SAVED IN OLDOLDRT
RTLOOP: UNPROTECT, MAR←RTC, CALL MFETCH;
*$$$$$$$ PATCH 1
       Q←M, MAR←MAR+1, FETCH, CALL FIX1;
       M←M LCY 12, Q←17770000B;
       M←M AND NOT Q ! Z AND Q, Q←10000000B;
       M←OLDRT←M AND NOT Q LCY 2, Q←TEMP2;
       M EOR Q, GOTO USIBLP IF LB=0;
* HAVE NEW CLOCK VALUE.
* SAVE SSR AND LOAD SSL
       Z←SSRADR, ALERT;
       M←READ, MAR←SSRMEM, CALL MSTORE;
       Z←SWR5ADR, ALERT;
       M←READ, MAR←SWR5MEM, CALL MSTORE;
       MAR←SSLMEM, CALL MFETCH;
       Z←SSLADR, ALERT;
       Z←M, POT, M←OLDRT;
* CHECK CLOCK AGAINST TOP OF RTQ
       Z←TRTQT, CALL TIMINT, OFFSET←PRRTP;
* TRY TO REMOVE TOP PROCESS FROM RTQ AND WAKE IT UP
       GOTO USIBLP IF R0>=0;
       M←RTQ, CALL GETNEXT;
       CPROC←Z, GOTO USIBLP IF NULLPTR, Q←TEMP2;
        OLDOLDRT←Q,  GOTO FIX3, M←OFFSET;
FIX3A: TEMP2←RTBIT, M←CPROC, CALL STKLK;
       GOTO RTLOOP IF NOCRASH, TEMP2←OLDOLDRT;
*
* FALL THROUGH
* NO FURTHER ACTION IN RTQ REQUIRED. CHECK USIB
* CONTROL RETURNS HERE FROM ALL ACTIONS TRIGGERED BY USIB ENTRIES.
USIBLP: UNPROTECT, GOTO *+2 IF NOCRASH;
       CALL UERROR;
       PROTECT(USIBPRO);
       MAR←USIBTOP, FETCH;
       Q←SPT1←M, MAR←USIBASE, FETCH;
       M EOR Q, GOTO IBEMPTY IF LB=0, Z←LUSIBE;
       MAR←SPT1, FETCH, Z←Q-Z;
       SPT1←Q←M, MAR←MAR+1, FETCH;
       TEMP2←M;
       M←Z, MAR←USIBTOP, STORE;
* HAVE FETCHED REQUEST FROM USIB. FIRST WORD IN Q AND SPT1. SECOND
* IN TEMP2. DISPATCH ON OPCODE
        M←Q LCY 4, Q←60000017B;
       M←M AND Q LCY 2, Q←MAXUOP, CALL UERROR IF LB=0;
       UNPROTECT, CPROC←SPT1;
       CALL UERROR ON Q-M<0, Q←OPTAB-1;
       SUBR←M+Q, Q←TEMP2, DGOTO USIBLP;
       MAR←Z←M←CPROC, CALL STKLK, .C←3, .TCX, .TXW;
*  NOTE THAT MAR IS LOADED WITH CPROC + 3
* DISPATCH WITH FIRST WORD IN M, Z AND TEMP1, SECOND IN Q AND TEMP2.
* USIBLP ON STACK
OPTAB: GOTO WAKEUP;                    * WAKEUP
       GOTO IWAKEUP;                   * IWAKEUP
RETCALL: GOTO FREECPU, TEMP4←WKUP1;      * RETURN
       GOTO CHKPIW, TEMP4←BLOCK1, FETCH;     * BLOCK
       GOTO CHKPIW, TEMP4←BLKOUT1, FETCH;    * BLOCKOUT
       GOTO FREECPU, TEMP4←UNLOAD1;    * UNLOAD
       GOTO GIVEUP;                    * GIVEUP
       GOTO CHRT;                      * CHANGERT
       GOTO SETMODE;
       GOTO SAVEST;
       .DGO;
       CALL UERROR;


* EITHER STROBE NOT SET OR US OFF.  GIVE CONTROL TO ITP IF IT
* NEEDS IT.  MODE IN M
NOUSWORK: GOTO ICONT ON M<0;
       GOTO IOWAIT ON M LCY 1<0;
* ITP IS OFF. LOOP
       GOTO MAIN;
*
* CHRT IS IN THE ITP PACKAGE, SO THAT THIS ONE WILL FIT ON 4 BOARDS

* SUBROUTINE TO DETERMINE WHETHER A TIME T (IN Z) FALLS IN THE
* INTERVAL BETWEEN T1 (IN Q) AND T2 (IN M). IT DOES IF
*      T1<=T<=T2  OR  T>=T1>T2  OR  T1>T2>=T
* WIPES MQZ, SUBR. RETURN <0 IN R0
* IF TRUE, >=0 IF FALSE. PUT SPT4 IN M ON EXIT
* ANALYSIS REVEALS THAT SIGN(T-T1) EOR SIGN(T-T2) EOR SIGN(T2-T1)
* IS THE RIGHT THING TO PUT IN THE SIGN OF R0
* CALL WITH CALL, DOES NOT USE STACK, WIPES MQZ, MAR
TIMINT: R0←M-Q;
       R0←Z-Q, Q←R0;
       M←Z-M, Z←R0;
       Q←M EOR Q, DRETURN IF NOCRASH;
       SUBR←R0←Q EOR Z, M←SPT4;
       GOTO UERROR;


* SUBROUTINE TO RE-ESTABLISH TRTQT
* CALL WITH CALL, DOES NOT USE STACK, WIPES MQ, MAR
FIXRTQ: MAR←RTQ, FETCH;
       M, RETURN IF NULLPTR, Q←PRRT;
       MAR←M+Q, FETCH, DRETURN;
       TRTQT←M;
*
* WAKEUP PROCESS IN M.  SECOND WORD (IN TEMP2) IS TO BE MERGED
* INTO PIW.
* CALL WITH C. USES MQZ, CPROC, NEWPIW, OFFSET, TEMP2, SUBR
* MUST UNPROTECT UPON RETURN
WAKEUP: Z←M, CALL CHKPID;
       PROTECT(PRTPRO);
       CALL GETPIW, Q←TEMP2;
       M←M OR Q, Q←BLKBIT, CALL MSTORE;
       M←CPROC, CALL GETST;
* NOW HAVE M=ST, MAR=ADDR(ST), Q=BITS TO CLEAR IN IT
WKUP2: M←M AND NOT Q, Q←LDDBIT, CALL MSTORE;
*  CLEAR BLOCK
       M AND Q, GOTO NOTLDD IF LB=0, Q←USQBIT+RUNBIT;
*   CHECK LOAD
       M AND Q, R IF LB#0, Q←USQBIT;
*  PROCESS IS LOADED, CHECK FOR MSQ OR RUN.  IF ON MSQ OR RUNNING
* WE ARE DONE.
       M←M OR Q, Q←PRIMASK, CALL MSTORE;
*  ELSE SET MSQ
       Q←M AND Q LCY 12, M←USQBASE;
*  GET PRIORITY
       MAR←M+Q, Z←CPROC;
*  SET UP POINTER TO QUEUE, Z POINTS TO PROCESS TO BE ADDED
       OFFSET←PRPTR, CALL APPEND;
*  BRANCH TO ROUTINE TO ADD NODE ON DESIRED PRIORITY QUEUE
       Q, R IF NNPTR;
       SCHFLG←4B7, R;
NOTLDD: Q←WAQBIT+SCQBIT+PQBIT+SWQBIT+CBCBIT;
       M AND Q, R IF LB#0;
* IF SYSTEM IS IDLE, WE WANT TO GET SWAPIN CALLED DIRECTLY.
* OTHERWISE JUST GOTO PUTWQ. ITS RETURN WILL RETURN FROM WAKEUP
       Q←PUTWQ, CALL CHKIDLE;
* IT IS. FALL THROUGH TO SWAPIN
       M←CPROC, TEMP2←SWAPIQ, CALL GETST;
*$$$$$$$ PATCH 2
       M←M MRG SWQBIT, STORE, GOTO FIX2;

* COMMON CODE FOR SWAPPER REQUESTS: READ PROCESS AND WRITE PROCESS ONLY
* CPROC=PRT FOR PROCESS, TEMP2=QUEUE TO PUT REQUEST ON
* OBTAIN ENTRY FROM SWAPPER FREE LIST.
SWREQUEST: UNPROTECT, OFFSET←0;
       PROTECT(SWAPRO), Q←CPROC;
       TEMP3←Q-1, M←SWFREL, CALL GETNEXT;
       SPT1←Z, GOTO SWQEMPTY IF NULLPTR, OFFSET←SWNPTR;
       SUBR←Z-1, Z←2;
* SET UP REAL NAME
SWRQ1: MAR←TEMP3←TEMP3+1, FETCH, Z←Z-1;
       Q←MAR←SUBR←SUBR+1, STORE, GOTO *-1 IF Z>=0;
       M←CPROC, MAR←Q+1, CALL MSTORE;
       M←SWAPOP, Q←MAR←MAR+1, CALL MSTORE;
       Z←SPT1, MAR←Q+1, STORE;
* SPLICE ENTRY ONTO PROPER QUEUE
       MAR←TEMP2, CALL APPEND;
       SK0←SWAPSTROBE, STROBE, R;
SWQEMPTY: UNPROTECT, GOTO SWREQUEST;


* ALTERNATE ENTRY TO WAKEUP FROM FREECPU: PRST ADDRESS IN MAR,
* PRST IN M, PRTPRO SET
* NOTHING IS DONE TO PIW
WKUP1: Q←BLKBIT, GOTO WKUP2;


* SAME AS WAKEUP EXCEPT THAT FIRST PARAMETER (IN M) HAS TO BE MULTIPLIED
* BY 12 AND HAVE MINPRT ADDED
IWAKEUP: Z←M LCY 1;
       M←M+Z;
       M←M LCY 2, Z←MINPRT, DGOTO WAKEUP;
       M←Z←CPROC←M+Z;

*
* COMMON CODE FOR RETURN, BLOCK, BLOCKOUT, UNLOAD. 
* DECREMENTS AL. SETS SCHFLG IF AL=I. FETCHES ST WORD,
* CLEARS RUNBIT AND STORES IT.
* ENTER WITH LOCATION TO GOTO NEXT IN TEMP4, OTHER REGISTERS SET UP
* BY USIBLP AS USUAL
FREECPU: PROTECT(PRTPRO);
         CALL CHKPID;
       Z←TEMP2 MRG AL, CALL GETST;
       CALL UERROR ON Q←SKZ<0;
       Q←Q LCY 4;
       GOTO CPUNOTIDLE ON SKZ←Q>=0, Q←RUNBIT+CPUBIT;
       SCHFLG←4B7+PRI, Z←TEMP2, .TCY;
       SKZ←10B;
CPUNOTIDLE: M←M AND NOT Q, Q←TEMP4;
       GOTO Q, STORE;
* LEAVE WITH PRST IN M, ADDR(PRST) IN MAR, PROCESS IN CPROC
* PRTPRO SET

BLOCK1: M←M MRG BLKBIT, STORE, R;

BLKOUT1: M←M MRG BLKBIT, STORE, GOTO SWAPOUT;

UNLOAD1: C(PUTWQ);
* FALL THROUGH INTO SWAPOUT

* SWAPOUT PROCESS IN CPROC AND RETURN TO USIBLP. CLEAR LDD (ST IN TEMP4)
* PRTPRO SET ON ENTRY
SWAPOUT: M←CPROC, CALL GETST, Q←LDDBIT;
       M←M AND NOT Q, TEMP2←SWAPRQ, STORE, GOTO SWREQUEST;

* GIVEUP IS NOT IMPLEMENTED AT THE MOMENT
GIVEUP: R;

* SET MODE FROM DATA WORD OF REQUEST
SETMODE: R ON MODE←Q>=0;
* TURNING COMPUTE MODE ON. RESET ITP
       GOTO IRESET;
*
* PUT PROCESS CPROC ON THE END OF WAKEUPQ. SET WAQ
* IN ST.
* CALLED WITH C, USES MQZ, MAR, SPT1,2, OFFSET
* CALLED FROM WAKEUP, UNLOAD
PUTWQ: Z←M←CPROC, CALL GETST, OFFSET←PRPTR;
       M←M MRG WAQBIT, STORE, DR;
       MAR←WAKEUPQ, CALL APPEND;


* SUBROUTINE TO CHECK FOR IDLE SYSTEM.
* GOTO Q IF SYSTEM NOT IDLE, RETURN IF IT IS
* CALL WITH CALL[TsOES NOT USE STACK
* CALLED FROM WAKEUP, NOSWITCH
CHKIDLE: Z←AL0, MAR←RIPQ, FETCH;
       Z←AL1, DGOTO CHKOUT IF Z>=0, MAR←USQBASE-1;
       Z←NPRI, GOTO CHKOUT IF Z>=0;
       MAR←MAR+1, FETCH, M, GOTO CHKOUT IF NNPTR;
       GOTO *-1 ON Z←Z-1>=0, MAR←MAR+1;
       RETURN;
CHKOUT: GOTO Q;


* SUBROUTINE TO CHECK A PROCESS ID (PRT ADDRESS) IN Z
* FOR VALIDITY. IT LEAVES THE ADDRESS, WITH THE TOP 6 BITS CLEAR,
* IN  M , Z AND CPROC.  THE CHECK IS FOR THE ADDRESS TO BE IN THE
* RANGE FOR PRT AND THE LAST TWO BITS TO BE ZERO.CALL UERROR IF
* CHECK FAILS. WIPES R0, MQZ
* ALSO CHECKS FOR ACTIVE PROCESS, AND GOES TO GOMAIN IF THE PROCESS
* IS NOT ACTIVE, AFTER RESETTING THE STACK
* CALL WITH CALL, DOES NOT USE STACK
CHKPID: Q←ADMASK, M←MINPRT;
       CPROC←Z←Z AND NOT Q, Q←3;
       R0←Z-M, M←MAXPRT;
       M←M-Z, M←R0;
* SIGN OF M IS 1 IF ADDRESS IS OUT OF RANGE
       M←M AND NOT Q LCY 1, M←CPROC;
       M AND Q, CALL UERROR IF LB#0, Q←2;
       MAR←Z+Q, FETCH, DRETURN;
       GOTO *+1 ON M>=0, M←CPROC;
       STKP←TOPSTACK, GOTO GOMAIN;


*

* IB EMPTY. SCHEDULE CPU AS SPECIFIED BY USI/W-14 PP 5-6
IBEMPTY: UNPROTECT;
       TEMP1←Z←WNPFLG MRG AL;
       M←SKZ, .RRN←1, .THY, Q←ALIDLE+ALRUNNING;
       M AND Q, GOTO MAIN IF LB=0, Z←SCHFLG;
* WAIT IS OVER. CLEAR WNPFLG (I.E. MAKE IT NEGATIVE) AND CHECK SCHFLG
       WNPFLG←Q, MAR←USQBASE-1, GOTO MAIN IF Z>=0;
* SCHFLG IS SET. CONSIDER RESCHEDULING. SEARCH FOR HIGHEST NON-EMPTY USQI
       Z←NPRI-1, Q←PRI0;
       TEMP1←MAR←MAR+1, FETCH, Z←Z-1, GOTO NOSWITCH IF Z<0;
       MAR←MAR+1, M, GOTO *-1 IF NULLPTR;
       TEMP3←M;
* FOUND NON-EMPTY USQ, ADDRESS IN TEMP1, ADDRESS OF FIRST ENTRY IN TEMP3,
* NPRI-2-PRIORITY IN Z. COMPARE WITH CPU PRIORITIES
* FIRST COMPUTE SMALLEST CPU PRIORITY
       M←PRI1, TEMP4←0;
       R0←Q-M, M←NPRI-2;
       GOTO *+2 IF R0>=0, Z←TEMP2←M-Z;
       Q←PRI1, TEMP4←1;
* NOW HAVE WEAKEST CPU IN TEMP4 (0 OR 1), ITS PRIORITY IN Q,
* THE PRIORITY OF THE STRONGEST NON-EMPTY USQ IN Z AND TEMP2
       R0←Z-Q, Z←TEMP4 MRG AL;
       GOTO NOSWITCH IF R0>=0, M←SKZ;
* WANT TO SWITCH WEAKEST CPU IF ITS AL#P
       GOTO SETWNP ON M LCY 8<0, Q←TEMP4;
* GO AHEAD. INCREMENT AL AND STORE NEW PRI
       M←M LCY 20, Q←TEMP2;
       SKZ←M, Z←TEMP4 MRG PRI;
       SKZ←Q, M←TEMP3;
* STORE PRT ADDRESS OF PROCESS FOR CPU AND SEND IT AN ATTENTION
       MAR←TEMP4 MRG CPUPROC, CALL MSTORE;
       Q←TEMP4+1, PROTECT(PRTPRO);
       Q←Q LCY CPUSTSH;
* CLEAR USQBIT, SET RUNBIT AND CPU NUMBER IN ST OF PROCESS
       Q, STROBE, Q←USQBIT, CALL GETST;
       M←M AND NOT Q, M←TEMP4 MRG RUNBIT, STORE, DGOTO IBEMPTY;
* REMOVE PROCESS FROM ITS USQ
       M←TEMP1, OFFSET←PRPTR, CALL GETNEXT;
* NOTE THAT IBEMPTY CLEARS PROTECT
SETWNP: WNPFLG←Q, GOTO MAIN;
NOSWITCH: TEMP2←SCHFLG←0, Q←MAIN, CALL CHKIDLE;
* IDLE. RUN PROCESS ON WAKEUPQ IF THERE IS ONE
       OFFSET←PRPTR;
       M←WAKEUPQ, CALL GETNEXT;
       M←Z, GOTO MAIN IF NULLPTR;
       CALL GETST, Q←WAQBIT, TEMP2←0;
       M←M AND NOT Q, STORE, DGOTO IBEMPTY;
       M←Z, C(WAKEUP);

*$$$$$$$ PATCHES 1 AND 2
FIX1:  GOTO RTLOOP ON M EOR Q<0;
       Z←Q LCY 12, RETURN;
FIX2:  M←CPROC, CALL GETPIW;
       M←M MRG RSIBIT, STORE, GOTO SWREQUEST;
FIX3:  FETCH, R0←M+Z, Q←ADMREG, DGOTO FIX3A;
       M←M AND NOT Q, STORE, SUBR←WAKEUP, CALL FIXRTQ;
       CALL UERROR;

       END;
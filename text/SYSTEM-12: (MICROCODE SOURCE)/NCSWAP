       ORG 1000B;
*  THIS IS THE MAIN LOOP,  CONTROL RESIDES IN THIS LOOP UNTIL AN
*  ATTENTION, REQUEST IS RECIIVED, OR THE
*  DISK QUEUES NEED SERVICING.
MAIN:  CALL SETSTK, UNPRO(17B);        *PATCH
       C(PATTN);               *EW5←0 FOR 1.03
       GOTO *+3 ON Q >=0;
       C(COPYK),  M ← NKT;
       GOTO MAIN;  *GOTO MAIN2, M←FLAGRG;  FOR 1.03


*  A REQUEST STROBE HAS BEEN RECEIVED
MAIN0: FETCH ACTCL;
*  ACTIVATE?
       GOTO MAIN1 ON M-1#0,  RSTRQL;
*  AN ACTIVATE HAS BEEN FOUND
       FETCH ACTHD,  CALL SETSTK;
       T ← PNT;
       Z ← ACTREQ,  CALL SAPU;
*  GENERAL REQUEST?
MAIN1: T←MAIN, CALL SETSTK;            *PATCH
       PRO(2);                         *PATCH
       FETCH GRQ;                      *PATCH
       Z ← GENREQ,  CALL SAPU;
*  CHECK ON THE DRUM AND DISK
       C(PATTN);
*  PROCESS DISK QUEUES?
       C(COPYK),  M ← NKT;
*  CHECK ON DRUM AND DISK AGAIN
       C(PATTN);
*  TEST FOR ACTIVATE IF REQUEST STROBE RECEIVED
       GOTO MAIN0 ON Q=0;
       GOTO MAIN1;


*  IF NKT = 0 OR FLAG BIT 0 = 1 CALL COPY FUNCTION
*  M - NKT
COPYK: P ← CCYLF,  CALL STCSTK;
       GOTO COPK1 ON M <= 0, Z ← KCQCNT;
       GOTO ICONT ON FLAGRG < 0;
       R;


*  PROCESS ATTENTION IF ATTN SET
*  RETURN -1 - NO REQUEST
*          0 - REQEST 1 SET
*          CALL R2PNT IF REQUEST 2 SET
PATTN: GOTO PATN0 IF ATTS;
       R IF NORQ, Q←-1;
       R IF RQ2NS, Q←0;
       CALL R2PNT;


*  DO CLEANUP BY CALLING APU SUBROUTINE
*  A,X CONTAIN REQUEST CODE
*  B CONTAINS POINTER TO NODE
*  THE TSU STATE PLUS ADDITIONAL INFORMATION IS PUT IN CORE IN
*  THE RELATIVE ADDRESS SPACE
PATN2: Q←Q LCY 1, Z←CLBUF;
       M ← BR←Q+Z,  Z ← TSUSTATE;
       Q ← RELL;
       STORE Q + Z,  Q ← PATI;
       Q ← Q LCL STCY(RSLTSU),  INC(ADR);
       M ← Q LCH STCY(RSLTSU),  CALL DPTSU;
       FETCH BR,  CALL STCSTK;
       T ← PNT;
       Z ← CLPRC,  CALL SAPU;


*  SEARCH FOR TSU NEEDING CLEANUP
PATN0: M←PATI←0;
PATN1: M←M LCL STCY(RSLTSU);
       Z←M LCH STCY(RSLTSU) MRG TSPC0, ALERT;
       M←PIN, Z←2;
       GOTO PATN2 ON M LCY 2<0, Q←PATI;
       M←PATI←Z+Q, Q←3, DGOTO PATN3;
       GOTO PATN1 ON Q-M>=0;


*  DO STARTUP
*  PATI - TSU #
PATN4: P←DMCOM, CALL PATN5;
       DGOTO PATN3 ON Z-1<=0;
       CALL SICONT ON Z-1<=0;
       P←DKCOM, CALL SICONT;

*  SEARCH FOR A TSU NEEDING A COMMAND
PATN3: M←PATI←0;
       M←M LCL STCY(RSLTSU);
       Z←M LCH STCY(RSLTSU) MRG TSPC0, ALERT;
       M←PIN, Q←2;
*  FOUND ONE?
       GOTO PATN4 ON M>=0, Z←PATI;
*  NOPE
RESUMESTART:
       M←PATI←Z+Q, Q←3;
       GOTO PATN3+1 ON Q-M>=0;
       GOTO PATN0 IF ATTS;
*  CHECK ON CONTEXT BLOCKS
       P←NDCTX, CALL SICONT;
       GOTO PATN0 IF ATTS;
*  CHECK ON PROCESS BEING CONSIDERED
       P←NDPRC, CALL SICONT;
       GOTO PATTN;


*  SET STACKS
SETSTK: STKP ← LSKPR, UNPROTECT;
STCSTK: Q ← RELL,  Z ← BASCSTK,  DRETURN;
       CSTK ← Q + Z;


*  START APU
*  Z - P COUNTER
*  M - PTR TO NODE
*  T - FAIL ADDRESS
*  PLACES REQUEST CODE IN A,X
*  PLACES PTR TO NODE IN B (THE TOP 6 BITS ARE 0)
SAPU:  P ← Z,  Q ← NADB;
       ENDL(FT,BR ← M AND NOT Q),  Q ← DISP(RCD);
       FETCH M+Q,  Q ← MASK(RCD);
       M ← XR ← M AND Q,  DGOTO SICONT;
       AR ← M;


*  R0 - MEMORY ADDRESS OF STORAGE
*  DUMP TSU STATE
*  M - TSU NUMBER IN SELECT POSITION
FUNCTION(DPTSU),  STORE;
       T2←-9,  DGOTO DPTS0;
       T1 ← M,  Q←4B7,  DGOTO *+1;
       Q←Z←Q LCY 1, Z←T1, ALERT;
       M←PIN;
       STORE, DGOTO *-2 ON INC(T2)<0;
DPTS0: INC(ADR);
       Q ← Z ← 0,  T2←-4;
       CALL GETPOS, Z ← Z + Q;
       STORE, DGOTO *-1 ON Z ← INC(T2)<0;
       INC(ADR),  Q ← 4;
       T2←-3;
       Q←TSPC0;
       Q←Z←Q LCY 1, Z←T1, ALERT;
       M←PIN;
       STORE, DGOTO *-2 ON INC(T2)<0;
       INC(ADR);
       R;


*  GENERATE WAKEUP
*  Q - PRT PTR
*  Z - SECOND WORD OF WAKEUP

WAKU0: UNPRO(8);
WAKEUP:        PRO(8);
       FETCH USIBTOP;
       T ← Q,  Q ← 2;
       M ← M + Q,  Q ← MASK(USIB);
       GOTO WAKU0 ON M AND Q = 0,  Q ← T;
       T ← Z,  Z ← NADB;
       STORE, T←NOT Z AND Q MRG WAKCOM, Z←T;
       M ← T,  ADR ← M, STORE;
       SRQS(2);
       M ← Z,  INC(ADR),  STORE,  DRETURN;
       UNPRO(8);


*  SEND TSU INSTRUCTIONS
*  T4(R1) - INSTRUCTION V UNIT #
*  T3(R2) - DEVICE ADDRESS
*  T2(R3) - PAGE ADDRESS
*  Z - WORD COUNT
*  ADR(R0) - TSU # LEFT ADJUSTED TO POSITION IN SELECT WORD
*  M - UN0
*  Q - UN1

STSUI: T ← Z,  Z←ADR MRG TSIN+TSEL, ALERT;
       Z←T4, POT;
*  SEND DEVICE ADDRESS
    Z←ADR MRG TSDA+TSEL, ALERT;
       Z←T3, POT;
*  SEND PAGE ADDRESS
       Z←ADR MRG TSCMA+TSEL, ALERT;
       Z←T2, POT;
*  SEND WORD COUNT
       Z←ADR MRG TSWC+TSEL, ALERT;
       Z←T, POT;
*  SEND UNIQUE NAME
       Z←ADR MRG TSUN0+TSEL, ALERT;
       Z←M, POT;
       Z←ADR MRG TSUN1+TSEL, ALERT;
       Z←Q, POT;
*  SEND UNIT #
       Z←ADR MRG TSHU+TSEL, ALERT;
       Z←T4, POT;
       R;


*  THE FOLLOWING TEST ROUTINES ALL EXPECT
*  Q - PTR TO CHT ENTRY
*  RETURN IF FIELD = 0
*  FAIL THRU Z IF FIELD # 0
*  TEST LOCK BITS IN CHT

LKNST: T ← Q,  M ← DISP(PL),  DGOTO TESTF;
       ADR ← Q + M,  Q ← MASK(PL), FETCH, DRETURN;

*TEST DIRTY BIT IN CHT

DNST:  T ← Q,  M ← DISP(DB),  DGOTO TESTF;
       ADR ← Q+M,  Q ← MASK(DB),FETCH, DRETURN;

*TEST SCHEDULED COUNT

SCHZ:   T ← Q,  M ← DISP(SCH),  DGOTO TESTF;
       ADR ← Q + M,  Q ← MASK(SCH), FETCH, DRETURN;


*TEST NOT ZERO

TESTF:  GOTO GZ ON M AND Q # 0, Q←T;


RCH1:      M←M RCH 1;* LCY 3
PRO2:     PRO(2);
          RETURN;
UNPROA:   UNPRO(15), RETURN;
ALERTF:   ALERTSC, RETURN;
POTF:     POTSC, RETURN;
*  STACK ENTRY ON FREE LIST,  CALLED BY MACRO SEFL.

FUNCTION(SETFL);
       PRO(2);
       MIN(NFREL);
       M ← FREL,  OFFSET ← 0,  CALL SEL;
       UNPRO(2),  R;


*  REMOVE ENTRY FROM FREE LIST
FUNCTION(REFFL);
       PRO(2);
       FA0 ← Z,  Z ← REFL0;
       Q ← FREL,  OFFSET ← 0,  CALL RTE;
       MDC(NFREL);
       UNPRO(2),  R;
REFL0: MIN(ROFN);
       UNPRO(2), FRA(FA0);


*  MEMORY INCREMENT, CALLED BY MACRO MIN.
FUNCTION(MINF);
       INC(M),  STORE,  RETURN;

*  MEMORY DECREMENT, CALLED BY MACRO MDC.

FUNCTION(MDCF);
       DEC(M),  STORE,  RETURN;


*  12 BIT MULTIPLICATION ROUTINE
*  M - SHORT ARGUEMENT
*  Z - LONG ARGUEMENT
*  RETURN:  PRODUCT IN Q,AR
MULP:  M ← M LCH 23 - NMBIT,  Q ← 0,  GOTO MUL1;


*  INITIALIZATION SEQUENCE
*
GO:    RSTRQL2;
       GOTO * IF NORQ, R0 ← -1 + 1, Q ← MASK(SRDST);
*  DISK OR DRUM RESTART
*  T = TSU#, T3 = ADDRESS OF DISK OR DRUM, T4 = UNIT #
*  ST3 = ADD FOR JUMP IN ADDRESS, ST4 = DISK/DRUM BIT MASK FOR ADD
GO1:   FETCH SRMEM;
       GOTO GO10 ON M AND Q = 0, Q ← ONE(SRTSU) * 2,  RSTRQL;
       ST1←M;
*  TEST FOR DISK OR DRUM
       M AND Q, GOTO GOA IF BL#0, Q ← MASK(SRBND);
*  DRUM START
       T3 ← M AND Q RCY 8, DGOTO GOB, Q←DRCON;* DRCON=44B
       ST4←DBITM;* DBITM=134B
*  DISK START
GOA:   T4←M;
       Z←M AND Q RCY 8, M←1, CALL MULP;
       T3←Q, Q←DKCON;
       M←T4, ST4←DKBITM;
GOB:   ST3←Q, Q ← MASK(SRTSU);
*  SET UP TSU#
       ADR←M AND Q LCY LDCY(SRTSU)-5, Q ← MASK(SRUNT);
*  SET UP UNIT#, PAGE ADDRESS
       M←M AND Q LCL LDCY(SRUNT), T2←0;
       T4←M LCH LDCY(SRUNT) MRG WRITE;


*  LOOP FOR WRITING AND READING 64K
*  GET IN SYNC WITH TSU
       ST0←-31, CALL RDST;
GO2:   M←ST1, Q←MASK(SRSOLD);
       Q ← M AND Q MRG WRITE, GOTO *+2 IF LB#0,  M ← T4;
       GOTO GO5 ON M AND Q#0,  M ← T3;
       Z ← 4000B;
       M←Q←-1, C(STSUI);
*  WAIT FOR COMMAND TO FINISH
       CALL RDST;
*  TEST FOR ERROR
       Z←ADR MRG TSSTS;
       GOTO *+1, ALERTSC;
       M←PIN;
       M AND Q, GOTO GO2 IF BL#0, M←T3;
GO5:   Z←ST4, Q←MASK(DSTR);
*  UPDATE ADDRESSES
       GOTO GO3 ON M AND Q-Z=0, Q←ONE(DSTR);
       T3←M+Q, GOTO GO4, M←T2;
GO3:   Q←ST3, GOTO *-1;

GO4:   Z ← ST0,  Q←MASK(DSTR);
       ST0 ← Z + 1,  Z ← 4B3,  DGOTO GO2 IF Z<0;
       T2←M+Z,  M ← T3;
*  FIX DEVICE ADDRESS (KEPT IN T3) TO POINT TO NEXT BAND
       M ← M AND NOT Q,  Q ← ONE(DBND);
       T3 ← M + Q,  Q  ← WRITE;
*  CHECK WHETHER READS HAVE TO BE DONE
       ST0 ← -31,  M ← T4;
       M AND Q, T2←0, DGOTO GO2 IF BL#0, .TAX←0;
       T4←M AND NOT Q;
       SRQS(2);
GO10:  GOTO * IF NORQ;
       GOTO LOADST,  RSTRQL;


RDST:  Z←ADR MRG TSPC0;
       GOTO *+1, ALERTSC, Q←TSPNV;
       M←PIN;
*  POSITION INVALID?
       M AND Q, GOTO *-2 IF BL#0, Q←6B7+2;
*  
       M AND Q, GOTO *-3 IF BL#0;
       RETURN, Q←3776B;


*  GET SELECTED POSITION
*  M - TSU NUMBER RIGHT ADJUSTED
*  Z - UNIT #
*  Q - FAIL ADDRESS
*  RETURN:  M,Q - SECTRO POSITION RIGHT JUSTIFIED
     FUNCTION(FSTR),  FA0 ← Q;
       M←M LCY 3;
       TSUN←M LCY 16, Q←3;
       CALL GETPOS, SU←Z←Q AND Z;
*  GET FUNCTIONAL UNIT
       SP←M, Z←TSUN MRG TSFU, ALERT;
       Z←PIN, Q←3;
*  GET FUNCTIONAL POSITION
       FU←Q AND Z, CALL GETPOS;
       FP←M AND Q, Z←SP;
       SP←Q AND Z, Q←PCFEX+PCEOS;
*  TEST TSU ACTIVE
       M←M AND Q, Q←PCFEX;
*  TEST TSU TRANSFER
       M EOR Q, GOTO FRA0 IF BL=0, M←37B;
*  UPDATE SP
FSTR1: Z←FP, Q←MASK(PCRCP);
*  TEST FOR 512 WORD RECORD LEFT IN FU
       Z←Z AND Q, Q←10B;            *PATCH
       GOTO FRA0 ON Z-Q>0;
       Z←FP, Q←MASK(PCRCP);
       Z←M-Q AND Z, M←SP;
       Z←M+Z, M←SU;
       Q←FU;
*  COMPARE UNIT NUMBERS
       M EOR Q, GOTO FSTR2 IF BL=0, Q←2;
       Z←Q+Z;
*  UPDATE SECTOR POSITION FOR WRAPAROUND
FSTR2: M←Z, Q←MASK(PCSTR);
       T←M AND Q LCY 20;
*  TEST FOR DISK
       M←TSUN, Q←4B6;
       GOTO FSTR3 ON M-Q>=0, Z←NKSECT;
       Z←24;
FSTR3: M←Q←T, DR;
       GOTO *+1 ON M-Z>=0;
       M←Q←M-Z, R;


*  GET POSITION
*  Z - UNIT #
*  T1 = TSU# IN SELECT POSITION
*  RETURN:  M - POSITION
*           Q - MASK(POSITION)
*           T1 - TSU # IN SELECT POSITION
GETPOS: Q←3;
       Z←Q-Z AND Q, Q←TSPC3;
       Z←Q LCL Z, Z←TSUN;
       .VCY, GOTO *+1, ALERTSC, Q←TSPNV;
       M←PIN;
       GOTO *-2 ON M AND Q#0;
       Q←MASK(POSITION), RETURN;


*  THE FOLLOWING PATCHES COPYK TO SEARCH AROUND THE CYLINDER QUEUES ONCE
*  WHEN NOTHING IS HAPPENING ON THE DISK
COPK1: GOTO *+2 ON Z-1>=0, M←FLAGRG;
       KCQCNT←Z+1,  GOTO ICONT;
       R ON M LCY 1 < 0, Z ← -NKCQ;
       FLAGRG←M MRG MASK(STKCQ), GOTO *-2;
*  PATCH FOR FAST STARTUP
PATN5: SAVEPATI←M←Z, Q←3;              *PATCH
       M←M AND Q LCL 19;               *PATCH
       TSUNM←Z←M←M LCH 19, DGOTO STDRUM;*PATCH
       GOTO STDISK ON M LCY 3 < 0;     *PATCH
*  PATCH TO FAST START FOR NEWPAGE REQUEST
NPAGE: Q←BR, FETCH WRTQ;
       Q, GOTO FINSTART IF NENDLT;
       P←APUWRITE, DGOTO FINSTART;
       BR←M, CALL SICONT IF NENDLT;
*  PATCH TO MAIN LOOP TO QUEUE PROCESS IF FLAG SET (THE FOLLOWING 
* FOR 1.03)
MAIN2: P←NDPRC, DGOTO MAIN;
       CALL SICONT ON M LCY 2<0;


*  SET FLAG REGISTER
*  M - BIT TO SET

SFLG:  Q←M, Z←FLAGRG;
SFLG0: FLAGRG←Z AND NOT Q ! M AND Q, RETURN;
       ALL;
       ALL;
       ALL;
       ALL;
       ORG 1376B;
       CALL PUNT;
@      NOLIST EXT;
       END;
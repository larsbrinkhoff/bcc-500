* LOCATION 400B

       ORG 400B;

* INSTRUCTION TABLE.  MUST BE ON 128 WORD BOUNDARY
*  Z,Q - CONTAIN AR
*  M - CONTAINS R (RELATIVE EFFECTIVE ADDRESS)
*  MAR - CONTAINS ABSOLUTE EFFECTIVE ADDRESS
HLTF:  CALL PNT,  BREAKSC;
* OVERFLOW FROM SHIFT
SHFT1:   AR←Q LCH Z, GOTO ILOOP;
BRU:     Q←R, Z←-1, GOTO FIXP;
LDI1:  AR ← M MRG 7774B4,  GOTO ILOOP;
ETR:     FETCH, DGOTO ILOOP;
         AR←M AND Q;
MRG:     FETCH, DGOTO ILOOP;
         AR←M OR Q;
EOR:     FETCH, DGOTO ILOOP;
         AR←M EOR Q;
         GOTO ILOOP;*  NOP
MSIN1: M ← SKZ,  GOTO STOR;
EXU:     FETCH, Q ← OPMASK, GOTO IL1;
MSIN2: SKZ ← M,  GOTO ILOOP;
STA:    M←AR, GOTO STOR;
BSX1:  XR ← M,  GOTO BSL1;
STB:     M←BR, GOTO STOR;
MUL0:  AR ← Q,  RETURN;
STX:     M←XR, GOTO STOR;
UPOT2:   POT, GOTO ILOOP;
BRXF:    M←XR, Z←-1, DGOTO ILOOP;
         GOTO FIXP ON XR←M+1 < 0,  Q ← R;
BRM:     M←P, SETA, CALL STOR;
         Q←0, GOTO FIXP;
UPOT:    ALERT, GOTO *+1;
         Z←BR, GOTO UPOT2;
UPIN:   ALERT, GOTO *+1;
         M←READ, GOTO CAB;
RCH:     M←R, Q←RCHMASK, DGOTO RCH1;
         M←M AND Q LCY 16, T←Z←XR;
SKE:     FETCH, DGOTO TEST;
         M←M EOR Q;
BRR:     Q←ADMASK, FETCH, DGOTO FIXP;
         Q←M AND NOT Q, Z←0;
SKB:     Q←BR, FETCH;
SKB1:    M←M AND Q, GOTO TEST;
SKN:     Q←4B7, FETCH;
SKN1:    M←M AND Q ! Q, GOTO TEST;
SUB:     FETCH, DGOTO ILOOP;
         AR←Q-M;
ADD:     FETCH, DGOTO ILOOP;
         AR←Q+M;
SKR:     HFETCH, DGOTO SKN1;
         M←M-1, Q←BOUND, SETA, CALL STOR1;
MIN:     Q←1, HFETCH;
MIN1:    M←M+Q, GOTO STOR;
XMA:     HFETCH, DGOTO CBA;
         Q←M, M←AR, DGOTO STOR;
ADM:     HFETCH, GOTO MIN1;
BSL1:  CSTK ← Z + 1,  GOTO ICNT1;
SHIFT:   Z←R, DGOTO SHFT1;
LLN3:    Q←Q LCL Z;
SKM:     Q←BR, FETCH;
         M←M AND Q - Z AND Q, GOTO TEST;
LDX:     Q←0, FETCH, DGOTO ILOOP;
LDX1:    XR←M AND NOT Q ! Z AND Q;
SKA:     FETCH, GOTO SKB1;
* SKG WHERE SIGNS DISAGREE
SKG2:  Q←4B7, GOTO SKN1;
* SKG IS SIGN OF M-AR IF SIGNS AGREE, SIGN OF M IF NOT
SKG:   FETCH, DGOTO SKG1;
       GOTO SKG2 ON M EOR Q<0;
LDB:     FETCH, DGOTO ILOOP;
LDB1:    BR←M;
LDA:     FETCH, DGOTO ILOOP;
LDA1:    AR←M;
EAX:     M←R, Q←LONGAD, DGOTO LDX1;
         Z←XR, DGOTO ILOOP;
UPS:     Q ← M LCY 16,  Z ← 7,  DGOTO UPS1;
         DGOTO Z AND Q MRG UPSTAB,  Q ← R;
CSK:   M←R, Q←300B, DGOTO CSK1;
       Q ← M AND Q LCL 24 - 6;
LDY:   T1←LDF1, GOTO FLDO, M←BR;
LDF1:  AR←Z AND Q, GOTO ILOOP;
STY:   T1←ADF2, GOTO FLDO, M←BR;
ZRF2:    M←Z AND NOT Q, Q←T1, GOTO ADF2;
ADF:   T1←ADF1, GOTO FLDO, M←BR;
MGF2:  M←Z OR Q, Q←T1, GOTO ADF2;
MGF:   T1←MGF1,GOTO FLDO, M←BR;
MGF1:  T1←Q, Q←AR, GOTO MGF2;
GOTB:  Z←R,  CALL GZ;
*  THE REST OF STACK P AND CALL MICROCODE SUBROUTINE
SCAL3: SKZ ← NOT Q MRG ADMASK;
CALX:  R5 ← SR5,  Q←34B3,  DGOTO CALL1;
       GOTO CALL2 ON Q←M AND Q LCY 12 = 0,R0←SR0;
ZRF:    M←BR, T1←ZRF1, GOTO FLDO;
ZRF1:   T1←Q, Q←AR, GOTO ZRF2;
SKNEX: FETCH,  DGOTO ILOOP;*  SKNE
       M EOR Q,  GOTO SKIP IF LB#0;
SNEL:  FETCH,  DGOTO ILOOP;
       M,  GOTO SKIP IF NNPTR;
MDC:   HFETCH,  DGOTO STOR;
       M ← M - 1;
SKLEF: FETCH,  DGOTO SKL1;
       M EOR Q,  GOTO SKIP IF LB=0;
SCALF: Z ← STKP,  Q ← 34B3,  DGOTO SCAL1;
       T ← P,  GOTO SCAL2 ON M AND Q # 0;
SKELF: FETCH,  DGOTO ILOOP;
       M,  GOTO SKIP IF NULLPTR;
SKLF:  FETCH,  DGOTO SKG + 1;
       Q ← M,  M ← AR,  DGOTO SKG1;
SKGEF: FETCH,  DGOTO SKGE1;
       M EOR Q,  GOTO SKIP IF LB=0;
SKPF:  FETCH,  DGOTO ILOOP;
       GOTO SKIP ON M >= 0;
SKACF: FETCH,  DGOTO ILOOP;
       M AND Q,  GOTO SKIP IF LB#0;
SKBCF: FETCH,  Q ← BR,  DGOTO ILOOP;
       M AND Q,  GOTO SKIP IF LB#0;
BSRF:  FETCH,  Q ← ADMASK,  DGOTO FIXP;
       Q ← M AND NOT Q,  Z ← 1;
BSLF:  MAR ← Z ← CSTK,  DGOTO BSL1;
       Q ← P ← M,  M ← T2 + 1,  STORE;
BSXF:  MAR ← Z ← CSTK,  DGOTO BSX1;
       Q ← P ← M,  M ← T2 + 1,  STORE;
BVRF:  Z ← CSTK,  Q ← ADMASK,  DGOTO BVR1;
       CSTK ← MAR ← Z - 1,  Z ← R,  FETCH;
SKUMF: Q ← BR,  FETCH,  DGOTO ILOOP;
       GOTO SKIP ON M AND Q - Z AND Q # 0;
SKIF:  HFETCH,  DGOTO SKI1;
       M ← M + 1,  Q ← BOUND,  SETA,  CALL STOR1;
BRNXF: Z ← -1,  DGOTO ILOOP;
       GOTO FIXP IF AT1ON,  Q ← R;
MULF:  FETCH,  DGOTO ILOOP;
       M ← M LCH 23 - NMBIT,  Q ← 0,  CALL MUL1;
BRQF:  DGOTO BRQ1,  Q ← R,  Z ← -1;
       DGOTO FIXP IF NOCRASH;
LLNF:  Q,  GOTO LLN2 IF LB=0,  Z ← R + 1;
       T ← 0 - Z,  Z ← AR,  GOTO LLN1;
LDIF:  AR ← M,  Q ← 2B4,  DGOTO ILOOP;
       GOTO LDI1 IF BL#0,  M AND Q;


* LOCATION 600B;

CLL3B: AR←M, Q←R5;
       SR5←Q,Q←R4;
       SR4←Q,Q←R3;
       SR3←Q,Q←R2;
       SR2←Q,Q←R1;
       SR1←Q,Q←R0;
       SR0←Q , DGOTO FIXP;
       Q←P;


* UPS TABLE. MUST BE ON 8-WORD BOUNDARY
UPSTAB:  Q, STROBE;
UPR:     Q, CLRPRO;
PRO:     Q, SETPRO, GOTO PRO1 IF PRONEX;
       CLEARMAP;
       RESETTSU;
       CALL PNT;
       CALL PNT;
       CALL PNT;


* RCH TABLE. MUST BE ON 16-WORD BOUNDARY.
*  ENTERED WITH DGOTO ILOOP PENDING, ABX IN MQZ, XR IN T
RCHTAB:  XR ← 0-Z;
CLEAR: XR←0,  GOTO *+1;
CLAB:    AR←M←0, GOTO CAB;
CLA:     AR←0;
CLB:     BR←0;
CLX:     XR←0;
CAB:     BR←M, GOTO ILOOP;
* THIS LINE IS EXECUTED FROM SEVERAL PLACES
CBA:     AR←Q;
XAB:     AR←Q, GOTO CAB;
CBX:     XR←Q;
CXB:     BR←Z;
XXB:     XR←Q, GOTO CAB, M←T;
CXA:     AR←Z, GOTO ILOOP;
CAX:     XR←M;
XXA:     XR←M, M←T, GOTO CXA;
CNA:   AR←0-M;


*  FAIL RETURN TABLE FOR CALL,  MUST OCCUR ON AN 8 WORD BOUNDARY
FTABLE: NOP;
       NOP;
       XR←CALL4;
       BR←CALL4;
       R5←CALL4;
       AR←CALL4;
       FA0 ← CALL4;
       NOP;


*  SCRATCHPAD TO SCRATCHPAD (CSK) TABLE, MUST BE ON 4-WORD BOUNDARY
CSKTAB:        T ← SKZ,  GOTO CSK2;
       T ← 0,  GOTO CSK2;
       Z ← SKZ,  Q ← 1;
       Z ← SKZ,  Q ← -1;


* CHECK R FOR < BOUND, THEN STORE M WITH MAR AND GOTO ILOOP
* UNLESS A IS SET, IN WHICH CASE RETURN
*  EXIT:  Z - R,  Q - 4B7
STOR:    Q←BOUND;
STOR1:   GOTO *+2 ON Z←R<0;
STOR2:   CALL PNT ON Q-Z<=0;
STOR3:   STORE, RETURN IF ASET, Q←4B7;
* FALL THROUGH
       T2 ← Q ← P,  DGOTO IL0;
       FETCH ABSP ← ABSP + 1,  P ← Q + 1;


* CONTINUE EXECUTION, STARTING WITH INSTRUCTION ADDRESSED BY P
ICONT:   Q←P;
ICNT1:   Z←REL,  T2 ← Q - 1;
         CALL PNT ON MAR←ABSP←Q+Z < 0, FETCH;
*  BEGIN MAIN LOOP
*  Q - P
*  T2 - P - 1
*  MAR - ABSP
*  FETCH OF INSTRUCTION STARTED
IL0:     MAR←MAR+1, Q←OPMASK, PREFETCH;
IL1:     Q←M AND Q LCY 8;
         Q←T1←Q LCY 2;
         CALL INDEX ON T←M LCY 1<0, Q←ADMASK;
*  CHECK RELATIVE ADDRESSING
IL2:     GOTO IL2A IF YODD, T, R←M AND NOT Q;
         Z ← REL;
         MAR←M AND NOT Q+Z, Q←T,  CLRA;
IL2R:    GOTO MSINS ON Q LCY 1<0, M←T1;
         DGOTO M MRG HLTF,  M ← R;
         GOTO *+1 ON Q LCY 8<0, Z←Q←AR;
*  INDIRECTION
         FETCH,  Q ← 4B7;
         M AND Q,  GOTO IL3 IF BL=0;
         M←M AND NOT Q,DGOTO IL2;
       CALL INDEX ON T ← M LCY 1 < 0,  Q ← ADMASK;
*  ABSOLUTE INDIRECTION
IL3:     CALL INDEX ON T←M LCY 1<0, Q←LONGAD;
         M ← R←MAR←M AND NOT Q MRG 4B7, Z←T1;
         GOTO Z MRG HLTF, Z←Q←AR;


IL2A:  R ← R MRG 4B7,  DGOTO IL2R;
       MAR ← M AND NOT Q,  Q ← T,  CLRA;


* SUBROUTINE FOR INDEXING
INDEX:   Z←XR, DRETURN;
         M←M AND NOT Q+Z,Q←LONGAD;


* SET P TO Q+Z, RECOMPUTE ABSP AND GO TO ILOOP
*  NEXT INSTRUCTION COMES FROM P+1
FIXP:    Q←P←Q+Z;
         Z←REL, DGOTO ILOOP;
         CALL PNT ON ABSP←Q+Z < 0;


*  MEMORY TO SCRATCHPAD INSTRUCTION
*
MSINS: Z←Q LCY 8, M←1B5,  DGOTO MSIN1;
*  TEST FOR LOAD OR STORE
       M AND Q, GOTO *+1 IF BL=0;
       FETCH,  GOTO MSIN2;


*  12 BIT MULTIPLICATION ROUTINE
*  M - SHORT ARGUEMENT LCH 23 - NMBIT
*  Q - 0
*  Z - LONG ARGUEMENT
*  RETURN:  PRODUCT IN ,AR,  M RESTORED
*  CLOBBERS: ADR

MUL1:  M ← M LCL 23-NMBIT, R0 ← -NMBIT;
       M ← R0+1, R0 ← M LCY 1, DGOTO MUL0 IF R0>=0;
       M ← R0, R0 ← M, DGOTO *-1 IF R0>=0;
       Q ← Q LCY 1;
       Q ← Q!Z, GOTO *-3;


*  THE REST OF BVR
BVR1:  M ← M + Z,  DGOTO ICNT1;
       Q ← P ← M AND NOT Q;


*  THE REST OF SKI
SKI1:  DGOTO ILOOP;
       GOTO SKIP ON M >= 0;


*  THE REST OF SKIP A <= M
SKL1:  Q ← M,  M ← AR,  DGOTO SKG1;
       GOTO SKG2 ON M EOR Q < 0;


SKGE1: GOTO SKG2 ON M EOR Q < 0;
SKG1:  M←M-Q, Q←4B7, GOTO SKN1;


*  THE REST OF BRANCH ON REQUEST STROBE
BRQ1:  GOTO ILOOP IF NOREQ;
       CALL R2PNT;


* THESE LINES ARE USED  BY SKIP INSTRUCTIONS
TEST:    M, GOTO ILOOP IF LB#0;
SKIP:    Q←P, Z←1, GOTO FIXP;


* REMAINDER OF RCH
RCH1:    DGOTO M MRG RCHTAB, Q←BR;
UPS1:    M←AR, DGOTO ILOOP;


*  REMAINDER OF PROTECT
PRO1:  Q,  CLRPRO,  DGOTO ILOOP;
       Q,  SETPRO,  GOTO *-1 IF PRONEX;


*  SCRATCHPAD RCH INSTRUCTIONS
*
CSK1:  DGOTO Q LCH 24 - 6 MRG CSKTAB;
       Z ← M LCY 16,  Q ← 77B,  DGOTO *+1;
       T ← Z + Q,  Q ← 77B;
CSK2:  Z ← M AND Q,  Q ← T,  DGOTO ILOOP;
       SKZ←Q;


*  CALL MICRO-CODE SUBROUTINES
CALL1: DGOTO Q LCY 1 MRG FTABLE, Q←P;
       P←Q+1, DGOTO CALL2;


*  ACTUAL CALL ON ROUTINE
CALL2: R1←SR1, Q←3777B;
       R2←SR2, Z←M AND Q;
       R3←SR3, DGOTO CALL3;
       R4←SR4, CALL *+1;
       M←AR;
       Q←BR, DGOTO Z;
       Z←XR;


*  RETURN FROM ROUTINE
CALL3: XR←Z, Z←0;
CLL3A: BR←Q,  GOTO CLL3B;


*  FAILURE RETURN FROM ROUTINE
CALL4: XR←Z, Z←STKP;
       GOTO *+2 ON Z ← SKZ < 0;
       BR ← Q,  Z ← -1,  GOTO CLL3B;
       P ← NOT Z - 1,  Z ← STKP,  GOTO PATCH1;


*  PATCH SPACE
SCAL1: Q ← T,  STKP ← Z - 1,  GOTO SCAL3;
SCAL2: Q ← T + 1,  STKP ← Z - 1,  GOTO SCAL3;
PATCH1: Z←SKZ←0,  GOTO CLL3A;
*  PATCH TO ALLOW A RCY INSTRUCTION, NOTE ONLY BOTTOM 8 BITS MAY 
*  CONTAIN DATA
RCY:   R←Z-Q, Q←AR, GOTO SHIFT;


*  MODULO OPERATION (A MOD M)
*  Q - A
*  Z - M
*  RETURN
*  M - A MOD M
*  Q - (A-M) MOD M
*  OFFSET - DISP(EQP)

MOD:   M←Q, DGOTO *;
       RETURN ON Q←Q-Z<0, R3←5;
       CALL PUNT;
       CHECK 1000B;


       END;
*  THE PHILOSOPHY OF STARTUP.


*  WHEN IT COMES TIME TO SEND A COMMAND TO A TSU THE ROUTINES IN THIS
*  PACKAGE ARE CALLED.  THE DISKS AND DRUMS HAVE THE SAME PROPERTIES I.E.
*    A.  THERE ARE SEVERAL UNITS, ANY OF WHICH MAY BE SICK.
*    B.  A DATA STRUCTURE IS ASSOCIATED WITH EACH DEVICE CALLED A 
*        "SECTOR TABLE".
*    C.  IT IS BEST TO AVOID CHANGING UNITS IF POSSIBLE.


*  BECAUSE OF THESE SIMILARITIES A PAIR OF ROUTINES CALLED GET FIRST
*  DEVICE (GTFDV) AND DO STARTUP (DOSTART) DO MOST OF THE WORK OF THE
*  STARTUP.  GET FIRST DEVICE ALSO HAS AN ENTRY POINT AT GET NEXT NODE
*  (GTNND).


*  THE IDEA IS THEN THAT STARTUP FOR THE DRUM INITIALIZES A FEW
*  SCRATCHPAD REGISTERS AND CALLS GET FIRST DEVICE.  IF THIS ROUTINE 
*  RETURNS THE DISK ADDRESS WILL BE IN M, THE CURRENT UNIT IN Z.  BY
*  DOING A DHT SEARCH THE UNIT # CAN BE COMPARED.  IF THEY COMPARE (OR
*  THE SEARCH FAILS), DOSTART IS CALLED.  OTHERWISE, GET NEXT NODE IS
*  CALLED.


*  THE DISK STARTUP IS SIMILAR EXCEPT THAT THE COMPARISON IS MADE ON THE
*  DISK UNIT #.  THIS COMPARISON IS MADE SUCH THAT ADJACENT UNITS
*  (EG 0,1) ARE TREATED AS THE SAME UNIT.  NOTE THE CURRENT FIND 
*  SECTOR ROUTINE COMPUTES THE SECTOR IMPROPERLY FOR A DUAL 
*  POSITIONER DISK WHEN THE FUNCTIONAL UNIT IS CHANGED.  IT WILL 
*  CAUSE ONE WHOLE SECTOR TO BE MISSED.  


*  FEATURES AND IDIOSYNCRASIES


*  THE FLAG WORD CONTAINS TWO BIT TABLES FOR DESIGNATING ACTIVE
*  UNITS.  BITS 20 THROUGH 23 REPRESENT DRUMS UNIT 0-3 RESPECTIVELY,
*  AND BITS 16 THROUGH 19 REPRESENT DISK UNIT 0-3 RESPECTIVELY.


*  IF IT IS DESIRED TO EXECUTE AN APU-CODED STARTUP ROUTINE A NEGATIVE
*  NUMBER IS PLACED IN STAPUFLAG IN CORE.  WHEN THIS OCCURS, THE GET 
*  FIRST DEVICE ROUTINE NOTES THIS AND BRANCHES INTO THE DOSTART ROUTINE.
*  P WILL BE EITHER APUREAD OR APUDISK DEPENDING ON THE TSU VALUE.
*  WHEN STAPUFLAG=-1 THE FOLLOWING APU-CODE PRECEEDING THE NORMAL APU
*  STARTUP ROUTINE WILL ALLOW ONE TSU TO BE STARTED BY THE MICROCODE:
*     CSX SELUNIT; LDS SR5,=GTDV0; CALL FRET,Q;
*  THE OTHER TSU MAY THEN BE STARTED BY WHATEVER METHOD DESIRED.


*  WHEN THE APU CODE IS CALLED, THE NODE HAS BEEN REMOVED FROM ITS
*  QUEUE, AND ITS POINTER IS IN A AND B.  X CONTAINS THE REQUEST CODE.
*  DIRECT I/O REQUESTS (CODES 4,5) ALWAYS CAUSE A STARTUP.


*  IF A STARTUP CANNOT BE BEGUN ONE OF TWO THINGS OCCUR DEPENDING ON THE
*  TSU NUMBER:
*    1.  A WRITE IS CONSIDERED FOR THE DRUM.  IF THE WRITE LIST IS EMPTY
*        THE TSU WILL IDLE.
*    2.  THE NUMBER OF DISK TRANSFERS IN THE SECTOR TABLE (NKT) IS CHECKED
*        IF NKT#0 AND MAXCHECKNKT>=0.  THIS CHECK MERELY INSURES
*        THAT NKT WILL ALWAYS GO TO ZERO AFTER A SUFFICIENTLY LONG TIME.


*  DOSTART NEVER RETURNS TO THE PLACE FROM WHICH IT WAS CALLED, HOWEVER
*  IT DOES UNWIND THE STACK.  THIS KLUDGE IS NECESSARY SINCE IT IS
*  BRANCHED TO FROM THE GET FIRST DEVICE ROUTINE FOR DIRECT I/O.


*  PROTECT 2 IS SET BY GET FIRST DEVICE BEFORE RETURNING THE DISK 
*  ADDRESS.  THEREFORE THE DHT SEARCH IS UNDER PROTECT 2.  UNPROTECTS 
*  ARE SCATTERED THROUGH THE CODE SUCH THAT PROTECT 2 IS RESET AFTER
*  THE SEARCH IS COMPLETED.  IT IS ALWAYS RESET BEFORE THE APU IS CALLED
*  OR CONTROL RETURNED TO THE PROCESS ATTENTION ROUTINE AT RESUMESTARTUP.


*  INITIALIZATION BY MONITOR

*  THE MONITOR MUST INITIALIZE THE FOLLOWING REGISTERS AS FOLLOWS:

*  NAME        LOCATION       CONTENTS        COMMENT

*  STAPUFLAG      164              0   FAST STARTUP
*                                 -1   USE APU CODE
*  NPAGSW         165             ?    NUMBER OF PAGES IN SWAP SPACE
*  NPAGQ          166         777777   NEW PAGE QUEUE
*                 167            161
*  FLAGRG        2523            314   FLAG BITS FOR DRUM UNITS 0,1, 
*                                      DISK UNITS 0,1
*  DSRL          2543             ?    LOCATION OF DRUM SECTOR READ LIST
*  MAXCHECKNKT   2544            200?  NUMBER OF DISK SECTORS BEFORE
*                                      NKT RESET TO 0 WHEN ERRONEOUSLY
*                                      NOT 0
*                                 -1   OR DO NOT CHECK NKT AT ALL
*  DFPT          2554             ?    BASE ADDRESS OF FREE DRUM PAGE 
*                                      TABLE (TABLE BEGINS AT 1 MOD 8)


*  PATCH IN THE FSTR ROUTINE ALSO REQUIRES ONE OTHER CELL TO BE 
*  INITIALIZED:

*  FSTRPM        2542          10-14   POSITION W/IN SECTOR AFTER WHICH
*                                      FSTR FAILS


@SSWAP IDENT;
       ORG 1400B;

*  DECLERATIONS


*SCRATCHPAD PARAMETERS
       SPM(DSRL);                      *DRUM SECTOR READ LIST BASE
       SPM(MAXCHECKNKT);


*  LOOP VARIABLES
       SPM(SECTORQUEUES);              *HOLDS SECTOR QUEUE BASE
       SPM(DEVICEMASK);                *BIT TO MASK FLAGRG FOR UNIT TEST
       SPM(CURUNIT);
       SPM(CQUEUE);
       SPM(LASTNODE);
       SPM(CHECKNKT);
       SPM(SELUNIT);
       SPM(FDPT);                      *FREE DRUM PAGE TABLE BASE ADDRESS
       SPM(IDSEQ);                     *IDENTIFICATION SEQUENCE NUMBER
       SPM(DHTPT);                     *DHT POINTER
       SPM(DRUMAD);                    *DRUM ADDRESS
       SPM(DHTST);                     *DHT STATE WORD
       SPM(CHTPT);                     *CHT POINTER
       SPM(PRTPT);                     *PRT POINTER
       SPM(CWSI);                      *CWS INDEX
       SPM(BCWS);                      *BASE OF CWS
       SPM(BPMT);                      *BASE OF PMT
       SPM(CWSPT);                     *PTR TO CWS ENTRY
       SPM(CWSWD);                     *CWS WORD
       SPM(PMTPT);                     *PTR TO PMT ENTRY
       REG(SR2,SK10);                  *IMAGE HOLDING REGISTER IN SKP
       REG(SR3,SK11);
       REG(SR4,SK12);
       REG(DKACMP,EW0);                *DISK ADDRESS COMPARE FLAG, SIGN BIT
       REG(MAXSOT,EW1);*               *MAXIMUM NUMBER OF BITS IN SECTOR
       REG(OLDAGE,EW3);                *OLD CWS
       REG(OCWSI,EW4);                 *OLD CWSI 
                                       *OCCUPIED TABLE
       REG(FA1,BR);*                   *FAIL ADDRESS # 1, USES BR


* PARAMETERS
       PM(LASTDEVICE,3);               *LAST DRUM 
       PM(NKTER,152B);                 *CORE ADDRESS OF NKT ERRORS
       PM(STAPUFLAG,164B);             *CORE ADDRESS OF APU START FLAG
       PM(APUREAD,3B);                 *ADRESS OF DRUM READ START ROUTINE
       PM(APUDISK,11B);                *ADDRESS OF DISK START ROUTINE
       PM(SRKTSU,4B6);                   *SELECT REGISTER DISK TSU
       PM(CDSDDT,4);                   *REQUEST CODE FOR DIRECT I/O STARTUP
       PM(DKSLB,136B);                 *DISK SECTOR LIST BASE ADDRESS
       PM(ACTQ,102B);                  * ACTIVATE QUEUE HEADER
       PM(NCTX,153B);*                 *NUMBER OF CONTEXT BLOCK CONSIDERED
       PM(KCQB,160B);*                 *DISK CYLINDER QUEUE
       PM(RELQ,170B);                  *RELEASE QUEUE HEADER
       PM(PMTDSP,300B-4);              *PMT DISPLACEMENT IN CONTEXT BLOCK
       PM(CWSDSP,2731B);               *CWS DISPLACEMENT IN CONTEXT BLOCK
       PM(PRST,8);                     *PRT STATUS INDEX
       PM(AMCSTSBITS,11710B);          *PRT STATE BITS
       PM(INCORM,24B6);                *IN CORE MASK
       PM(INSTC,60B);                 *INSTRUCTION FROM TSU
       PM(STATC,77B);                  *STATUS REGISTER
       PM(TSTAG,4B7);                  *TSU TAG ERROR
       PM(TSUNE,2B7);                  *UNIQUE NAME DOES NOT COMPARE


*  FIELDS

       DF(DIORCD,4,18,22);              *MAPS BOTH DIRECT I/O INTO
*                                      ONE CODE
       DF(DISKADDRESS,2,2,23);
       DF(DHTUNIT,0,22,23);
       DF(FLAGDM0,0,20,20);            *FLAG FOR DRUM UNITS
       DF(FLAGDK0,0,16,16);            *FLAG FOR DISK UNITS
       DF(DKA,2,2,23);*                DISK ADDRESS
       DF(NCWS,2,0,23);*               NUMBER OF CWS ENTRIES
       DF(SOT,10,0,23);                *SECTOR OCCUPIED TABLE
       DF(RF,3,1,1);                   *REFERENCE FLAG
       DF(UHIST,0,5,12);               *USE HISTORY FIELD OF CWS
       DF(AGEF,0,0,12);*               *AGE FIELD
       DF(IDCOD,5,0,3);                *IDENTIFICATION CODE
       DF(ERRF,0,12,23);               *TSU ERROR FIELD IN STATUS REGISTER


*  SPECIAL CONDITIONS
       SC(BANKA,61B);                  *SET BANK A
       SC(BANKB,60B);                  *SET BANK B


*  GET FIRST DEVICE
FUNCTION(GTFDV), SECTORQUEUES←M;
       Z←Z MRG TSFU, ALERT;
       ADR←Z←PIN, Q←MASK(DHTUNIT);
       Z←SELUNIT←Z AND Q, FETCH STAPUFLAG;
       GOTO DOST0 ON M<0;

GTDV0: CURUNIT←Z;
       M←SAVEPATI, Q←FINSTART, CALL FSTR;
       Z←Q LCY 1, M←SECTORQUEUES;
       CQUEUE←M←M+Z, Q←5, DGOTO GTDV1;
       M←M-Q, Q←NADB;
*  FIND NEXT NODE
GTNND: M←LASTNODE, Q←DISP(EQP), DGOTO GTDV1;
       FETCH M+Q, Q←NADB;
GTDV1: LASTNODE←M←M AND NOT Q, Q←DISP(EQP);
       FETCH M+Q, CALL STCSTK;
*  QUEUE EMPTY?
       ENDL(GTDV4,M), Q←NADB;
*  STUFF POINTER TO NODE AWAY
       T2←M←AR←M AND NOT Q, Q←DISP(RCD);
       FETCH M+Q, Z←TSUNM MRG TSPC0, ALERT;
       Q←PIN, Z←CDSDDT;
* INSURE CLEANUP NOT PENDING
       GOTO FINSTART ON Q LCY 2 < 0, Q←MASK(DIORCD);
*  DIRECT I/O?
       DGOTO DOSTART ON M AND Q-Z=0, Q←MASK(RCD);
       XR←M AND Q, Q←DISP(DISKADDRESS);
       M←T2, PRO(2);
*  RETURN W/DISK ADDRESS IN M AND PROTECT 2 SET
       FETCH M+Q, Z←CURUNIT, R;


*  ENTRY POINT INTO FUNCTION (CALL WITH C(DOSTART))
*  BEGINS APU CODE FOR STARTUP
*  AR,BR - POINTER TO NODE RELEASED
*  XR CONTAINS REQUEST CODE
DOSTART: M←LASTNODE, UNPRO(2);
       Q←CQUEUE, Z←PNT, CALL RELEQP;
DOST0: BR←Q, CALL SICONT;

*  RETURN TO PROCESS ATTENTION STARTUP LOOP
FINSTART: Z←SAVEPATI, Q←X←2, UNPROTECT;
       FRA(RESUMESTARTUP);

*  FIND NEXT DRUM
GTDV4: Z←CURUNIT, ADR←0;
GTDV5: Z←Z+1, M←LASTDEVICE;
       CALL SWITCH ON Z-M>0, M←SELUNIT;
       GOTO NOREAD ON Z-M=0, M←FLAGRG;
       M←M LCL Z, Q←DEVICEMASK, DGOTO GTDV0;
       GOTO GTDV5 ON ADR←M AND Q=0;


*  DRUM OR DISK TSU?
NOREAD: Q←SAVEPATI, FETCH NPGQ, DGOTO NKTOK;
       GOTO STWRT ON Q-1<=0, Q←MAXCHECKNKT;
       

*  START DRUM WRITE
STWRT: P←NEWPAGE, DGOTO NPAGE;
       BR←M, CALL SICONT IF NENDLT;


*  CHECK NKT COUNT
NKTOK: GOTO FINSTART ON Q<0, M←NKT;
       GOTO FINSTART ON M<=0, ADR←DKSLB;
       Q←CHECKNKT, Z←-NKSECT, FETCH;
*  LOOP WHICH SCANS DISK SECTOR TABLE
       NENDL(NKTK0,M), ADR←ADR+1;
       FETCH ADR+1, GOTO *-1 ON INC(Z)<0;
       CHECKNKT←Q←Q+1;
       Z←MAXCHECKNKT, DGOTO FINSTART;
*  IS CHECK NKT TOO BIG?
       GOTO *+1 ON Q-Z>0;
       NKT←0, MIN(NKTER);
*  RESET CHECK NKT
NKTK0: CHECKNKT←0, GOTO FINSTART;


* START DRUM
STDRUM: DEVICEMASK←MASK(FLAGDM0);
       M←DSRL, DGOTO STDM1;
       P←APUREAD, CALL GTFDV;

STDM0: C(GTNND);
*  FIND DRUM ADDRESS, IF CANNOT DO START
STDM1: Z←STDM3, CALL DHTSCH;
       FETCH Z, Q←MASK(DHTUNIT);
STDM2: Z←CURUNIT, UNPRO(2);
*  CHECK UNIT NUMBER AGAINST CURRENT UNIT
       GOTO STDM0 ON M AND Q - Z # 0;
STDM3: C(DOSTART);


*  START DISK?
STDISK: DEVICEMASK←MASK(FLAGDK0);
       M←DKSLB, DGOTO STDK1;
       P←APUDISK, CALL GTFDV;

STDK0: C(GTNND);
STDK1: Q←X←2, UNPROTECT, DGOTO STDK0;  *CONSECUTIVE UNITS ARE TREATED
                                       *AS THE SAME UNIT
       CALL STKLK ON M AND Q - Z = 0, SUBR←DOSTART;


*  ROUTINE TO BE USED TO IMPLEMENT CONDITIONALS
SWITCH: Z←ADR, ADR←Z, RETURN;


*  BLOCK COPY - NO OVERLAPPING BLOCKS
*  R0 - SOURCE BLOCK
*  Q - DESTINATION BLOCK
*  Z - COUNT
BCOPY: FETCH, GOTO *+2;
BCOP0: R0←Q, Q←R0+1, FETCH;
       R0←Q, Q←R0+1, STORE, DGOTO BCOP0;
       RETURN ON Z←Z-1<=0;


*  CYCLE Q BY AMOUNT IN Z
CYLQ:  Q←Q LCH Z, DRETURN;
       Q←Q LCL Z;


*  FIND ENTRY IN DRUM FREE PAGE TABLE
*  R1 - SECTOR
*  R2 - UNIT
*  RETURN  R0 - ADDRESS OF ENTRY
*           Q - R4
*           Z - 24
FDPTE: M←R1, Z←24;
       M←M LCY 3, Q←R2;
       Q←Q LCY 1, Q←FDPT, DRETURN;
       R0←M+Q, Q←R4;


*  FIND BAND IN FREE DRUM PAGE TABLE
*  FA0 - FAIL ADDRESS
*  R1 - SECTOR
*  R2 - UNIT
*  CALL WITH C(FBFDPT) OR SCALL FBFDPT,FA0
*  RETURN
*  M - DRUM ADDRESS

FBFDPT: CALL FDPTE, R4←-48;
       FETCH R0+1, GOTO FRA0 ON Q←Q+Z>0;
       GOTO *-1 ON M=0, R3←0;
       Z←M;
       M←Z←M LCY 1, DGOTO *+1 IF Z>=0;
       M←Z←M LCY 1, DGOTO * IF Z>=0, R3←R3+1;
       M←R3, Z←23, GOTO *+1;
       M←M+Q, Q←R1, DR;
       M←M+Z, Z←R2, CALL *+1;
*  NOW BAND IS IN M, SECTOR IN Q, UNIT IN Z.
*  FALL THROUGH TO MAKE DRUM ADDRESS

MDRM:  T←Q, Q←377B;
       M←M AND Q LCL 5, Q←37B;
       T←M LCH 5, M←T;
       M←M AND Q, M←T;
       M←M LCY 2, Q←3, DRETURN;
       M←M AND NOT Q ! Z AND Q;


*  PARSE DRUM ADDRESS
*  M - DRUM ADDRESS
*  CALL WITH C(PDRM) OR SCALL PDRM
*  RETURN:
*  R1 - SECTOR
*  R2 - UNIT
*  M - DRUM ADDRESS
*  Q - BAND

PDRM:  Q←3;
       R2←M AND Q, Q←MASK(DSTR);
       Q←M AND Q, Z←LDCY(DSTR), CALL CYLQ;
       R1←Q, Q←MASK(DBND), DR;
       Q←M AND Q, Z←LDCY(DBND), CALL CYLQ;


*  CLEAR/SET DRUM FREE PAGE TABLE
*  M - DRUM ADDRESS
*  R3 - 0 FOR CLEAR
*     - -1 FOR SET
*  CALL WITH SCALL CSFDPT

CSFDPT: C(PDRM);
       CALL FDPTE, R4←Q;
       GOTO * ON Q←Q-Z>=0, R0←R0+1;
       Z←0-Q, Q←4B7, CALL CYLQ, HFETCH;
       R3←M AND Q, Z←R3;
       M←M AND NOT Q ! Z AND Q, STORE;
       Z←Z AND Q, Q←R3, DR;
       PUNT ON Q EOR Z = 0;


*  INCORE ROUTINE
*  Z - PTR TO REAL NAME
*  CALL WITH SCALL INCOR,FA0
*  RETURN: M - STATUS, SCH WORD OF CHT ENTRY
*          Q,Z - PTR TO CHT ENTRY
****    PROTECT 2 IS LEFT SET BY THIS ROUTINE   ****
INCOR: HFETCH Z, Z←FRA0;
       UN0←M, FETCH R0+1;
       Q←M, FETCH R0+1;
       DKACMP←X←40000002B, PROTECT, GOTO * IF PRONS;
       T4←M, M←UN0, CALL CHTSCH;
       CHTPT←Z, FETCH R0+1;            *PATCH *********
*   NOTE THAT CHTPT←Z IS NOT INSTALLED YET (FOR 1.03)
       M←M MRG NKAD, Q←T4, .TCY;
       GOTO *+2 ON DKACMP←M EOR Q#0, Q←NADB;
       Q←Z, FETCH R0+1, R;

*  CONTINUE SCANNING CHT
       C(CONSCN);
       PUNT;
CONSCN: T←FRA0, GOTO CHTS0;


*  CLEAR FLAG REGISTER BIT
*  M - (BIT TO CLEAR) - 1

CFLG:  Q←M+1, Z←FLAGRG, GOTO SFLG0;*********PATCH
*   NOTE NOT INSTALLED YET (1.03)


*  EXECUTE COMMAND
*  M - DRUM ADDRESS (DEVICE ADDRESS + TSU# + UNIT#)
*  Q - CHTPT   ==> WORD COUNT =4000B,UNIQUE NAME =$CHTPT
*    - CHTPT,4                =  0               =$CHTPT
*    -   0                    =  0               =  0
*    -   1                    =  1               =  0
*  Z - INSTRUCTION
*  CALL WITH SCALL EXEC

EXEC:  T←Q, Q←MASK(DTSU);
       T1←M AND Q, Q←MASK(DNUMR);
KEXC0: T4←M AND Q ! Z AND NOT Q, Q←IDSEQ, .TYW;
       T3←M, Z←4B6;
       IDSEQ←Q+Z, GOTO EXEC3 ON Z←T<0;
       GOTO EXEC1 ON Z-1<=0, Q←DISP(PG);
       FETCH Z+Q, Q←MASK(PG);
       T2←M AND Q, Z←4000B;
EXEC0: R0←T+1, HFETCH, DGOTO EXEC2;
       Q←M, FETCH T, DGOTO STSUI;
EXEC1: T2←M←Q←0, DGOTO STSUI;
EXEC2: R0←T1;
EXEC3: T2←Z←0, GOTO EXEC0;


* EXECUTE DISK COMMAND
* M - INTERNAL DISK ADDRESS
* Q - CHTPT (AS FOR Q ABOVE)
* T2 - INSTRUCTION
*  CALL WITH SCALL KEXEC

WUEXEC: Q←Q MRG 4B7;
KEXEC: T←Q, Q←MASK(KTSU);
       Q←M AND Q, Z←23, CALL CYLQ;
       T1←Q, Q←MASK(KTRK);
       T3←M AND Q LCY 2;
       Q ← MASK(KBD);
       Z←M AND Q LCY 1, Q←77B;
       M←M AND Q ! Z AND NOT Q, M←T3, DGOTO KEXC0;
       Z←T2, Q←MASK(DNUMR);


*  SUCCESS/FAIL RETURN ACTIVATE
*  AR - DATA WORD
*  USE GOTO
SRACT: M←Q←AR←0, GOTO *+2;
FRACT: M←AR, Q←4B7+37B;
       MIN(M AND Q MRG 200B);
       M←AR, STORE ACTCL+1, DGOTO RET1;
       M←Q, STORE ACTCL;


*  REMOVE ENTRY FROM ACTIVATE QUEUE
*  Z - FAIL ADDRESS
*  USE CALL REACT,Z
*  RETURN M,Q,Z,EPTR - PTR TO NODE
REACT: Q←ACTQ, CALL RTEQP;
REAC0: MDC(NFREL);
REAC1: M←EPTR←Z←Q, GOTO CALL3;


*  REMOVE GENERAL RQUEST FROM GRQ
*  USE CALL REGRQ
*  RETURN M,Q,Z,EPTR - PTR TO NODE

REGRQ: Q←GRQ, DGOTO REAC0;
       Z←PNT, CALL RTEQP;


*  REMOVE ENTRY FROM APPROPRIATE CLEANUP QUEUE
*  USE CALL RECLQ
*  RETURN M,Q,Z,EPTR - PTR TO NODE

RECLQ: FETCH RELL MRG TSUSTATE, DGOTO REAC1;
       Q←M, Z←PNT, CALL RTEQP;


*  REMOVE ENTRY FROM CONTEXT BLOCK QUEUE
RCTXQ: MDC(NCTX);
       DGOTO REAC1 ON M>=0, Q←CTXQ;
       Z←PNT, CALL RTEQP;
       M←0, STORE NCTX, GOTO REAC1;


*  REMOVE ENTRY FROM SWAPIN QUEUE
RSWAP: Q←SWAPIN, DGOTO REAC0;
       Z←RET1, CALL RTEQP;


*  REMOVE ENTRY FROM RELEASE QUEUE
RRELQ: Q←RELQ, DGOTO REAC1; 
       CALL RTEQP;


*  FAIL ROUTINE
FRA1:  GRA(FA1);


*  RETURN DOING UNPROTECT
*  USE GOTO

RET1:  UNPRO(17B), R;


*  RELEASE NODE AND RETURN
*  EPTR - PTR TO NODE OR
*       - 0
*  USE GOTO IF RETURNING TO UCODE ROTINES OTHERWISE,
*  USE SCALL FRENOD
FRENOD: Q←EPTR, UNPRO(17B), DR;
       CALL SETFL ON Q#0;


*  FIND DHT ENTRY
*  EPTR - PTR TO NODE
*  BR - FAIL ADDRESS
*  FAILS IF DHT ENTRY DOES NOT EXIST
*  OTHERWISE RETURNS WITH
*  M,DRUMAD - DRUM ADDRESS
*  Q,DHTST - DHT STATUS WORD
*  Z,DHTPT - PTR TO DHT ENTRY

FDHT:  M←EPTR, Q←DISP(DKA);
       FETCH M+Q, Z←FRA1, CALL DHTSCH;
FDHT0: FETCH DHTPT←Z;
       DRUMAD←Q←M, FETCH R0+1;
       DHTST←T←M, DR;
       M←Q, Q←T;


*  APPEND OR STACK ON DRUM SECTOR READ LIST
*  EPTR - PTR TO NODE
*  DRUMAD,DHTST - DHT DATA
*  Z - FAIL ADDRESS
*  RETURN Z - PTR TO QUEUE IN DSRL

SDRD:  M←DHTST, R1←Q←MASK(DSTR)+4B7, GOTO *+2;
ADRD:  M←DHTST, R1←Q←MASK(DSTR);
       GOTO FRZ ON M LCY 1>=0, M←DRUMAD;
       Q←M AND Q, Z←LDCY(DSTR)+1, CALL CYLQ;
       M←Q, Z←24*2;
       GOTO *-1 ON Q←Q-Z>=0, Z←DSRL;
       R2←M←M+Z, Q←EPTR;
       CALL AELEQP ON R1>=0;
       CALL SELEQP ON R1<0;
       Z←R2, R;


*  INITIALIZE CONTEXT BLOCK DESCRIPTOR TABLE  (PRTPT,BPMT,BCWS)
*  Z - PTR TO NODE CONTAINING PRT POINTER
*  BR - FAIL ADDRESS
*  USE SCALL ICBTBL,Q;
*  FAILS IF CONTEXT BLOCK NOT IN CORE
*  RETURNS: M - CWSI
*  Q - CHT STATUS WORD FOR CONTEXT BLOCK
*  Z - BCWS

ICBTBL: FA0←FRA1, CALL SPRTPT;
       C(INCOR);
       DKACMP←Q←INCORM;
       GOTO FRA1 ON M AND Q # 0, Q←MASK(PG);
       BPMT←M AND Q MRG PMTDSP;
       R0←Z←BCWS←M AND Q MRG CWSDSP, DR;
       Q←M, FETCH R0+1;


*  CLEAR/SET SF
*  M - INDEX OF CWS ENTRY
*  SETS CWSI, CWSPT, CWSWD, PMTPT
*  CLEARS OR SETS SF ACCORDING TO ENTRY POINT USED
*  RETURNS PMT[3] IN M
*          Q - OLD SF BIT

STSF:  M←CWSI, R3←MASK(SF), GOTO *+4;
CLSF:  M←CWSI, R3←0, GOTO *+3;
ICSF:  CWSI←M, R3←0, GOTO *+2;
ISSF:  CWSI←M, R3←MASK(SF);
       Z←BCWS;
       FETCH CWSPT←Z-M, Q←MASK(PMTF);
       Q←M AND Q LCY 2, Z←BPMT;
       CWSWD←M, M←DISP(SF);
       PMTPT←Z←Z+Q;
       HFETCH M+Z, Q←MASK(SF);
*  FALL THROUGH TO SET/CLEAR SF


*  SET/CLEAR N BITS IN M
*  M - ORIGINAL WORD
*  Q - MASK OF BITS TO REPLACE
*  R0 - ADDRESS OF WORD
*  R3 - REPLACEMENT BITS
*  RETURN
*  M - NEW WORD WHICH IS STORED AT R0
*  Q - BITS WHICH WERE REPLACED

SCNBT: T←M AND Q, Z←R3;
       M←M AND NOT Q ! Q AND Z, Q←T, STORE, RETURN;


*  SET PRTPT
*  Z - PTR TO NODE CONTAINING PROCESS TABLE PTR
*  RETURN : Q,Z,PRTPT - POINTER TO PRT FOR PROCESS
*      M - CONTENTS OF T
*  USE CALL SPRTPT
SPRTPT: R3←M, Q←DISP(EPRT);
       FETCH Z+Q, Q←NADB, DRETURN;
       Q←Z←PRTPT←M AND NOT Q, M←T;


*  MANIPULATE PROCESS STATUS BITS
*  RETURN: M - PROCESS STATUS WORD
*          Q - OLD VALUE OF BITS
*  BITS AFFECTED: PGF, CBC, PDW, PQ, SWQ, LDD


*  CLEAR/SET PROCESS STATUS BITS
*  PRTPT - POINTER TO PROCESS TABLE
*  R3 VALUE OF RESULTING AMC STATUS BITS
*  USE CALL CSSTS
CSSTS: Z←PRTPT, M←PRST;
CSST0: FETCH M+Z, Q←AMCSTSBITS, GOTO SCNBT;

*  CLEAR/SET PROCESS STATUS BITS
*  EPTR - PTR TO NODE CONTAINING PRTPT
*  M - VALUE OF RESULTING AMC STATUS BITS
*  USE SCALL PSTS
PSTS:  Z ← EPTR, T←PRST, CALL SPRTPT;
       CALL CSST0;
       R;


*  READ PROCESS STATUS BITS
*  Z - POINTER TO NODE CONTAINING PRTPT
*  USE SCALL RSTS
RSTS:  T←PRST, CALL SPRTPT;
       FETCH M+Z, R;


*  SET SECTOR OCCUPIED TABLE
*  DRUMAD - DRUM ADDRESS
*  PRTPT - PTR POINTER
*  BR - FAIL ADDRESS

SSOT:  M←DRUMAD, C(PDRM);
       M←PRTPT, Z←DISP(SOT);
       HFETCH M+Z;
       Q←1, Z←R1, .LRN←4, CALL CYLQ;
SSOT0: R3←Q, CALL SCNBT;
       Q, GOTO FRA1 IF BL#0, Z←MAXSOT;
       Q←M-1, DGOTO *;
       M←M AND Q, Q←INC(T1), GOTO *+1 IF BL=0;
       R ON Z-Q>=0;
       Q←R3, T1←M←0, GOTO SSOT0;


*  AGE CORE WORKING SET
*  PMTPT, CWSPT, CWSWD ALL REQUIRED TO BE ACCURATE
*  MERGES REFERENCE FLAG INTO BIT 5 AND RIGHT SHIFTS  THE USE HISTORY ONE
*  BIT.  RETURNS WITH NEW CWS WORD IN M

AGECWS: M←PMTPT, Q←DISP(RF), .LRN←3;*  CLEAR R3
       HFETCH M+Q, Q←MASK(RF), CALL SCNBT;
       R3←Q RCY 4, Q←MASK(UHIST);
       M←CWSWD, Z←23;
       Q←M AND Q, R0←CWSPT, CALL CYLQ;
       R3←Q, R3, .TYW;*        ****R3←Q MRG R3
       Q←MASK(UHIST), CALL SCNBT;
       CWSWD←M, R;


*  COMPUTE OLDEST CWS ENTRY
OCWS:  Q←CWSWD, M←MASK(AGEF);
       Q←M AND Q RCY 4, M←OLDAGE;
       RETURN ON Q-M>=0, M←CWSI;
       OLDAGE←Q, DRETURN;
       OCWSI←M;


*  EXCHANGE MEMORY AND T
*  R0 - ADDRESS IN MEMORY
*  T - DATA TO STORE
*  RETURN: Q,T - DATA FROM MEMORY

XMT:   HFETCH, DRETURN;
       Q←T←M, M←T, STORE;


*  INCREMENT NCWS AND EXCHANGE CWS ENTRIES
*  BCWS - BASE OF CORE WORKING SET
*  CWSPT - POINTER TO ENTRY TO MOVE TO LAST POSITION
*  RETURN: M - CWSI

XCWS:  Z←BCWS, Q←DISP(NCWS);
       MDC(Q+Z);
       T1←R0←Z-M, CALL XMT;
       R0←CWSPT, CALL XMT;
       M←Q, STORE T1, DR;
       M←CWSI;


*  DRUM BASH ROUTINE
*  THIS ROUTINE WILL RUN THE DRUM AT FULL SPEED PROVIDED IT IS STARTED
*  CORRECTLY.  
*  IT USES THE FOLLOWING REGISTERS FOR PARAMETERS
*  REL - BASE REGISTER OF TSU DUMP (AND APU STARTUP ROUTINE)

*  AR - UNIQUE NAME 0 USED IN ALL TRANSFERS
*  BR - UNIQUE NAME 1 USED IN ALL TRANSFERS
*  SR1 - FIRST INSTRUCTION V UNIT NUMBER
*  SR4 - SECOND INSTRUCTION V UNIT NUMBER
*  SR2 - DEVICE ADDRESS (WHICH SHOULD HAVE 0 SECTOR FIELD)

*  THE STRATEGY IS TO USE THE FIRST INSTRUCTION FOR 24 SECTORS (0-23), 
*  THEN REINITIALIZE THE DRUM ADDRERS, CORE ADDRESS, AND SWAP
*  INSTRUCTIONS, THEN LOOP.
*  TWO COUNTERS ARE INCREMENTED BY THIS ROUTINE.  IF AN ERROR OCCURS
*  DURING EXECUTION CELL 4 IS INCREMENTED.  EACH TIME AROUND
*  THE BAND CELL 5 IS INCREMENTED.

DMBASH: M←AR, Z←4000B;
       R3←Q←SR3;
       SR3←Q+Z, R0←0;
       Q←BR, C(STSUI);
       Z←R1, T1←M←4B7, CALL GETPOS IF ATTS;
       GOTO *-1 ON M<0, M←0;
       R0←RELL MRG TSUSTATE+1, CALL DPTSU;
       Z←R2, Q←MASK(ERRF);
       M AND Q, MIN(Q←ONE(DSTR)) IF BL#0;
       R2←M←Q+Z, Q←MASK(DSTR);
       M←M AND Q, Q←ONE(DSTR)*24;
       GOTO DMBASH ON M-Q<0, Q←SR4;
       R1←Q, Q←R1;
       SR4←Q, MIN(ONE(DSTR)+1);
       R2←SR2, DGOTO DMBASH;
       SR3←20000B;


*  DECREMENT SCHEDULED COUNT
*  M - CHT STATUS FIELD
*  R0 - PTR TO CHT STATUS FIELD
*  RETURN
*  M, CHT STATUS - NEW CHT STATUS WORD

DSCH:  T←Q, Q←MASK(SCH);
       M AND Q, Q←T, RETURN IF BL=0;
       M←M-1, STORE, RETURN;


       CHECK 2000B;


*  CONCATENATE STANDARD LISTS
*  R0 - ADDRESS OF HEADER OF LIST MOVED
*  R1 - ADDRESS OF HEADER OF DESTINATION LIST

CONC:  HFETCH, Z←R0, Q←DISP(EQP);
       R2←M, M←777777B, STORE, RETURN IF ENDLT;
       HFETCH R0+1, AR←Z-Q;
       Z←M, M←AR, STORE;
       HFETCH R1+1, DGOTO CONC0;
       R1←M+Q, Q←NADB, DGOTO *+1;
       HFETCH R1, DRETURN;
CONC0: M←M AND Q ! Z AND NOT Q, Z← R2, STORE;


*  ERROR CHECK
*  THIS ROUTINE CHECKS ALL SOURCES OF ERRORS
*  IT SUCCEEDS IF THERE ARE NO ERRORS, OTHERWISE IT FAILS WITH A 
*  BIT WORD STATING THE NATURE OF THE ERROR IN Q, AND THE TSU UN MRG IN M,
*  Z CONTAINS EPTR
*  BR - FAIL ADDRESS

ERRCK: FETCH RELL MRG STATC;
       Q←MASK(ERRF);
*  INITIALIZE ERROR STATUS WORD
       T←M AND Q;
*  TEST IDENTIFICATION CODE (IS MEANINGLESS IF RLV SET)
       T1←Z←EPTR, Q←DISP(IDCOD);
       FETCH Z+Q, Q←MASK(IDCOD);
       Z←M, FETCH RELL MRG INSTC;
       CALL SETBIT ON M AND Q - Z AND Q #0, Q←TSTAG;
*TEST UNIQUE NAME
       FETCH Z←R0 MRG 6;
       XR←Q←M, FETCH T1, CALL UNTEST;
       FETCH R0+1, AR←Z-1;
       Q←M, FETCH AR, CALL UNTEST;
*  MERGE UN IN M FOR ZERO TEST
       M←M, M←XR;
       Q←T, DR, BANKA;
       Q, Z←T1, GOTO FRA1 IF BL#0, BANKA;


*  UNIQUE NAME TEST
UNTEST: RETURN ON M EOR Q = 0, Q←TSUNE;
*  FALL THROUGH AND SET BIT 2B7 IN ERROR STATUS WORD


*SET BIT ROUTINE, MERGES BIT INTO T,Q

SETBIT: Q←T←T, Q←Q, .TXW, RETURN;


*  SEARCH LIST ROUTINES
*  BEGIN SEARCH
BSCHL: T1←M, Q←DISP(DKA);
       FETCH Z+Q, Q←NADB;
       EW2←M, M←T1, GOTO CHTS0-1, BANKA;


*  TEST DISK ADDRESS
*  FAIL IF DISK ADDRESS COMPARE
TSCH:  FETCH R0+1;
       M←M MRG NKAD, Q←EW2, .TCY, DGOTO FT, BANKA;
       M EOR Q, Q←NADB, RETURN IF BL#0;


*  MAKE NODE
*  AR - REQUEST CODE
*  T - FAIL ADDRESS
*  EPTR - PTR TO REAL NAME
*  RETURN:  EPTR,Q,Z,R1 - PTR TO NODE
*  USE CALL MNODE,T;

MNODE: Z←FT, CALL REFFL, BANKA;
       R0←EPTR, Z←3, CALL BCOPY, BANKA;
       Q←CWSI, Z←18, CALL CYLQ, BANKA;
       M←PRTPT, R2←Q;
       STORE Q←R0+1;
       M←R2, .SSP←5, .TSPY, STORE Q+1;
       Q←R1, GOTO REAC1, BANKA;


*  ENTER CHT ENTRY
*  M - BITS TO MERGE INTO STATUS WORD IN CHT ENTRY
*  Z - PTR TO CHT ENTRY (CLEAN)
*  EPTR - PTR TO NODE CONTAINING REAL NAME

ECHTE: Q←M, M←DISP(SCH);
       HFETCH Z+M;
       M←M OR Q, STORE;
       HFETCH EPTR;
       Q←M, FETCH R0+1;
       UN1←M, FETCH R0+1;
       EW2←M;
       M←Q, Q←UN1;
       M OR Q, GOTO FRA0 IF BL=0;
       CHTPT←Z, CALL ECHT, BANKA;
       Q←Z←CHTPT, R, BANKA;


*  FETCH DISK ADDRESS FROM NODE

GDISK: Z←EPTR, M←DISP(DKA), DRETURN;
       FETCH M+Z;


*  QUEUE ENTRY ONTO DISK SECTOR LIST
*  EPTR - PTR TO ENTRY
QKSL:  Q←MASK(KSTR), CALL GDISK;
       Q←M AND Q, Z←23, CALL CYLQ, BANKA;
       Z←NKSECT*2, CALL MOD, BANKA;
       Z←KSQ, DR, BANKA;
       M←M+Z, Q←EPTR, CALL AELEQP, BANKA;


*  QUEUE ENTRY ONTO DISK CYLINDER QUEUE
*  EPTR - PTR TO ENTRY

QKCYL: Q←MASK(KTRK), CALL GDISK;
       Q←M AND Q, Z←LDCY(KTRK), CALL CYLQ, BANKA;
       Z←NKCQ, CALL MOD, BANKA;
       Q←M, FETCH KCQB;
       FETCH M+Q, Q←NADB;
       T←M, Z←EPTR, CALL AEL0, BANKA;
       M←MASK(STKCQ)-1, CALL CFLG, BANKA;
       KCQCNT←-NKCQ, R, BANKA;
       CALL PNT, BANK A;


       END;
